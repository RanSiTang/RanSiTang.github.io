<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="冉的技术宝典">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">冉的技术宝典</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/JDBC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/JDBC/" class="post-title-link" itemprop="url">JDBC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-22 13:29:15" itemprop="dateCreated datePublished" datetime="2025-09-22T13:29:15+08:00">2025-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-18 14:10:25" itemprop="dateModified" datetime="2025-10-18T14:10:25+08:00">2025-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">数据库与持久化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、JDBC-入门"><a href="#一、JDBC-入门" class="headerlink" title="一、JDBC 入门"></a>一、JDBC 入门</h1><h2 id="1-JDBC-概述"><a href="#1-JDBC-概述" class="headerlink" title="1. JDBC 概述"></a>1. JDBC 概述</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>JDBC</strong> 的全称是 <strong>Java™ Database Connectivity</strong>（Java 数据库连接）。</p>
<p>从本质上讲，JDBC 是由 Sun Microsystems (现为 Oracle) 定义的一套 <strong>标准的 Java API (应用程序编程接口)</strong>。这套 API 由一系列的接口（Interfaces）和类（Classes）组成，它们位于 <code>java.sql</code> 和 <code>javax.sql</code> 包中。</p>
<p><strong>核心思想：</strong> JDBC 的目标是为 Java 程序员提供一种 <strong>统一的、与具体数据库无关的</strong> 方式来访问和操作数据库。</p>
<hr>
<h3 id="1-2-JDBC-的作用与优势"><a href="#1-2-JDBC-的作用与优势" class="headerlink" title="1.2 JDBC 的作用与优势"></a>1.2 JDBC 的作用与优势</h3><p>JDBC 的主要作用是充当 <strong>Java 应用程序</strong> 和 <strong>数据库</strong> 之间的桥梁。它的存在带来了诸多优势：</p>
<ol>
<li><strong>数据库无关性 (Database Independence)</strong><br>这是 JDBC 最核心的优势。你的 Java 代码是面向 JDBC 接口编写的，而不是面向某个特定的数据库。这意味着，如果项目需要从 MySQL 数据库迁移到 Oracle 数据库，理论上你只需要更换数据库驱动 JAR 包和修改数据库连接信息，而业务逻辑代码几乎不需要改动。这大大提高了代码的<strong>可移植性</strong>和<strong>灵活性</strong>，避免了“厂商锁定”。</li>
<li><strong>标准统一 (Standardization)</strong><br>JDBC 是 Java SE 平台的核心组成部分。所有主流的数据库厂商（Oracle, Microsoft, IBM, MySQL 等）都遵循 JDBC 规范，并提供相应的数据库驱动程序。这使得开发者可以用一套统一的、熟悉的方式来操作各种关系型数据库，降低了学习成本。</li>
<li><strong>简单易用 (Simplicity)</strong><br>JDBC API 设计得相对直观。对于常见的数据库操作（CRUD），其基本步骤清晰明了：<ul>
<li>加载驱动</li>
<li>建立连接</li>
<li>创建执行对象</li>
<li>执行 SQL 语句</li>
<li>处理结果集</li>
<li>释放资源</li>
</ul>
</li>
<li><strong>功能强大 (Powerful Features)</strong><br>除了基本的查询和更新，JDBC 还提供了丰富的高级功能，以满足复杂应用的需求，例如：<ul>
<li><strong>事务管理</strong>：支持手动提交、回滚和保存点，保证数据的一致性。</li>
<li><strong>批处理</strong>：可以一次性向数据库发送多条 SQL 语句，显著提升性能。</li>
<li><strong>调用存储过程</strong>：能够执行数据库中预先定义好的复杂逻辑。</li>
<li><strong>元数据处理</strong>：可以获取关于数据库、表、列等的详细信息。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="1-3-JDBC-体系结构"><a href="#1-3-JDBC-体系结构" class="headerlink" title="**1.3 JDBC 体系结构 **"></a>**1.3 JDBC 体系结构 **</h5><p>JDBC 的体系结构是分层的，主要包含四个核心组件，它们协同工作，完成从 Java 应用到数据库的通信。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------+</span><br><span class="line">|     Java 应用程序          |  &lt;-- 开发者编写的业务代码</span><br><span class="line">+---------------------------+</span><br><span class="line">             |</span><br><span class="line">             | (调用)</span><br><span class="line">             V</span><br><span class="line">+---------------------------+</span><br><span class="line">|        JDBC API           |  &lt;-- Java 提供的标准接口 (Connection, Statement, etc.)</span><br><span class="line">+---------------------------+</span><br><span class="line">             |</span><br><span class="line">             | (委托)</span><br><span class="line">             V</span><br><span class="line">+---------------------------+</span><br><span class="line">|      JDBC 驱动管理器       |   &lt;-- DriverManager, 负责管理和选择驱动</span><br><span class="line">+---------------------------+</span><br><span class="line">             |</span><br><span class="line">             | (使用)</span><br><span class="line">             V</span><br><span class="line">+---------------------------+  +---------------------------+  +---------------------------+</span><br><span class="line">|        MySQL 驱动          |  |       Oracle 驱动         |  |      PostgreSQL 驱动       |  &lt;-- 各数据库厂商实现的具体逻辑</span><br><span class="line">+---------------------------+  +---------------------------+  +---------------------------+</span><br><span class="line">             |                              |                              |</span><br><span class="line">             | (通信)                        | (通信)                       | (通信)</span><br><span class="line">             V                              V                              V</span><br><span class="line">+---------------------------+  +---------------------------+  +---------------------------+</span><br><span class="line">|        MySQL 数据库        |  |       Oracle 数据库        |  |      PostgreSQL 数据库     |</span><br><span class="line">+---------------------------+  +---------------------------+  +---------------------------+</span><br></pre></td></tr></table></figure>

<p><strong>四个核心组件的角色：</strong></p>
<ol>
<li><strong>Java 应用程序 (Java Application)</strong><br>这是最顶层，即我们编写的业务代码。我们的代码通过调用 JDBC API 来执行数据库操作，而无需关心底层是如何实现的。</li>
<li><strong>JDBC API</strong><br>这是 Java 平台提供的一套标准接口和类，是程序员直接交互的层面。它定义了“能做什么”，例如 <code>Connection</code> 接口定义了如何建立连接、提交事务，<code>Statement</code> 接口定义了如何执行 SQL。但它不关心“如何做”。</li>
<li><strong>JDBC 驱动管理器 (Driver Manager)</strong><br><code>DriverManager</code> 是一个工厂类，扮演着“交通警察”的角色。它的主要职责是：<ul>
<li><strong>管理驱动</strong>：跟踪所有已注册的 JDBC 驱动。</li>
<li><strong>选择驱动</strong>：当应用程序请求建立连接时 (<code>DriverManager.getConnection(url, ...)</code>), 它会根据传入的数据库 URL (<code>jdbc:mysql://...</code>) 格式，智能地选择一个合适的驱动来处理这个请求。</li>
</ul>
</li>
<li><strong>JDBC 驱动 (JDBC Driver)</strong><br>这是体系结构中最关键的部分，由数据库厂商提供。驱动是 <strong>JDBC 接口的具体实现</strong>。例如，MySQL 提供的 <code>mysql-connector-java.jar</code> 就是一个 JDBC 驱动。它内部包含了将标准的 JDBC API 调用转换为 MySQL 数据库原生通信协议的代码。正是因为有了它，<code>DriverManager</code> 才能真正连接到数据库并执行操作。</li>
</ol>
<p>**工作流程总结：**应用程序想连接数据库 -&gt; 调用 <code>DriverManager.getConnection()</code> -&gt; <code>DriverManager</code> 找到能处理该 URL 的特定驱动（如 MySQL 驱动） -&gt; 该驱动与真实的 MySQL 数据库建立网络连接 -&gt; 驱动创建一个实现了 <code>Connection</code> 接口的实例对象并返回给应用程序 -&gt; 应用程序通过这个 <code>Connection</code> 对象执行 SQL，所有调用都会被该驱动“翻译”并发送给数据库。</p>
<hr>
<h2 id="2-驱动（Driver）"><a href="#2-驱动（Driver）" class="headerlink" title="2. 驱动（Driver）"></a>2. 驱动（Driver）</h2><h3 id="2-1-驱动的角色：连接-API-与数据库的桥梁"><a href="#2-1-驱动的角色：连接-API-与数据库的桥梁" class="headerlink" title="2.1 驱动的角色：连接 API 与数据库的桥梁"></a><strong>2.1 驱动的角色：连接 API 与数据库的桥梁</strong></h3><p>一个 <strong>JDBC 驱动</strong> 本质上是一个实现了 <code>java.sql.Driver</code> 接口的 Java 类库（通常以 <code>.jar</code> 文件形式提供）。它由数据库厂商（如 Oracle, MySQL）或第三方组织开发，并专门为某一种数据库服务。</p>
<p><strong>其核心职责包括：</strong></p>
<ol>
<li><strong>连接管理</strong>：接收来自 <code>DriverManager</code> 的请求，使用特定数据库的协议和认证方式，与数据库服务器建立一个网络连接。</li>
<li><strong>指令翻译</strong>：将 Java 代码中标准的 SQL 语句（如 <code>SELECT * FROM users</code>）和 JDBC API 调用（如 <code>statement.executeQuery()</code>）转换成数据库服务器能够执行的底层命令。</li>
<li><strong>数据转换</strong>：将从数据库返回的数据（通常是二进制格式的表格数据）解析并转换为 Java 中对应的数据类型（如 <code>String</code>, <code>int</code>, <code>Date</code>）和对象（如 <code>ResultSet</code>）。</li>
<li><strong>异常映射</strong>：将数据库返回的特定错误码或异常信息，包装成标准的 <code>java.sql.SQLException</code> 及其子类，供 Java 应用程序捕获和处理。</li>
</ol>
<hr>
<h3 id="2-2-JDBC-驱动的四种类型"><a href="#2-2-JDBC-驱动的四种类型" class="headerlink" title="2.2 JDBC 驱动的四种类型"></a><strong>2.2 JDBC 驱动的四种类型</strong></h3><p>根据其实现方式和架构，JDBC 规范定义了四种类型的驱动。了解它们的演进有助于理解为什么现代开发几乎只使用一种类型。</p>
<p><strong>类型 1：JDBC-ODBC 桥 (JDBC-ODBC Bridge)</strong></p>
<ul>
<li><strong>架构</strong>: <code>Java App -&gt; JDBC API -&gt; JDBC-ODBC Bridge Driver -&gt; ODBC Driver -&gt; Database</code></li>
<li><strong>原理</strong>: 这是最早期的驱动类型。它将 JDBC 调用转换为对 <strong>ODBC (Open Database Connectivity)</strong> API 的调用。ODBC 是一个主要用于 C&#x2F;C++ 语言的数据库访问标准。这意味着，客户端机器上必须安装并配置好特定数据库的 ODBC 驱动。</li>
<li><strong>优点</strong>: 早期可以快速连接到任何支持 ODBC 的数据库。</li>
<li><strong>缺点</strong>:<ul>
<li><strong>性能差</strong>: 调用链条长，涉及 JDBC 到 ODBC 的转换，效率低下。</li>
<li><strong>依赖平台</strong>: 依赖于本地的 ODBC 驱动，降低了 Java 的“一次编写，到处运行”的跨平台特性。</li>
<li><strong>部署复杂</strong>: 需要在每台客户端机器上安装和配置 ODBC 驱动。</li>
</ul>
</li>
<li><strong>现状</strong>: <strong>已废弃</strong>。从 Java 8 开始，Oracle 已将 JDBC-ODBC 桥从 JDK 中移除。它仅具有历史意义。</li>
</ul>
<p><strong>类型 2：本地 API 驱动 (Native-API Driver)</strong></p>
<ul>
<li><strong>架构</strong>: <code>Java App -&gt; JDBC API -&gt; Native-API Driver -&gt; Vendor&#39;s Native Client Library -&gt; Database</code></li>
<li><strong>原理</strong>: 这种驱动部分由 Java 编写，部分由本地代码（C&#x2F;C++）编写。它通过调用数据库厂商提供的本地客户端库（如 Oracle 的 OCI - Oracle Call Interface）来与数据库通信。</li>
<li><strong>优点</strong>: 相比类型 1，性能有显著提升，因为它绕过了 ODBC。</li>
<li><strong>缺点</strong>:<ul>
<li><strong>非纯 Java</strong>: 含有本地代码，丧失了完全的平台无关性。</li>
<li><strong>部署复杂</strong>: 同样需要在客户端机器上安装数据库厂商的本地客户端库。</li>
<li><strong>厂商绑定</strong>: 驱动与特定的客户端库版本紧密耦合。</li>
</ul>
</li>
<li><strong>现状</strong>: 很少使用，通常只在某些特定环境或需要利用本地库特有功能的场景下使用。</li>
</ul>
<p><strong>类型 3：网络协议驱动 (Network-Protocol Driver)</strong></p>
<ul>
<li><strong>架构</strong>: <code>Java App -&gt; JDBC API -&gt; Net-Protocol Driver -&gt; Middleware Server -&gt; Database</code></li>
<li><strong>原理</strong>: 这是一个纯 Java 驱动，它不直接与数据库通信，而是通过一个<strong>中间件服务器 (Middleware)</strong>。应用程序通过网络向中间件发送与数据库无关的请求，中间件再将这些请求翻译成特定数据库的协议并转发给数据库。</li>
<li><strong>优点</strong>:<ul>
<li><strong>纯 Java</strong>: 客户端非常轻量，不需要安装任何本地库。</li>
<li><strong>灵活性高</strong>: 中间件可以提供额外的服务，如负载均衡、连接池、缓存和安全认证。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>架构复杂</strong>: 引入了额外的中间件层，增加了配置、管理和维护的成本。</li>
<li><strong>性能瓶颈</strong>: 中间件可能成为系统的单点故障或性能瓶颈。</li>
<li><strong>通常是商业产品</strong>，需要额外付费。</li>
</ul>
</li>
<li><strong>现状</strong>: 在复杂的企业级分布式计算环境中有一些应用，但对于大多数项目而言不是首选。</li>
</ul>
<p><strong>类型 4：原生协议驱动 (Native-Protocol Driver &#x2F; Thin Driver)</strong></p>
<ul>
<li><strong>架构</strong>: <code>Java App -&gt; JDBC API -&gt; Native-Protocol Driver -&gt; Database</code></li>
<li><strong>原理</strong>: 这是<strong>纯 Java</strong>实现的驱动。它直接将 JDBC 调用转换为数据库厂商所使用的原生网络通信协议。驱动本身就“知道”如何直接与数据库服务器的监听端口进行对话。</li>
<li><strong>优点</strong>:<ul>
<li><strong>纯 Java</strong>: 实现了完全的平台无关性，真正做到“一次编写，到处运行”。</li>
<li><strong>部署简单</strong>: 只需要将一个 <code>.jar</code> 文件添加到项目的 classpath 中即可，无需任何客户端安装。</li>
<li><strong>性能最佳</strong>: 调用路径最短，直接与数据库通信，没有额外的转换或中间层。</li>
<li><strong>易于管理</strong>: 无需维护客户端软件。</li>
</ul>
</li>
<li><strong>现状</strong>: <strong>现代 Java 开发的绝对主流和行业标准</strong>。几乎所有主流数据库（MySQL, Oracle, PostgreSQL, SQL Server 等）都提供 Type 4 驱动。我们通常称之为“瘦客户端驱动 (Thin Driver)”。</li>
</ul>
<p><strong>总结对比表</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">实现方式</th>
<th align="left">平台依赖</th>
<th align="left">部署</th>
<th align="left">性能</th>
<th align="left">当前状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Type 1</strong></td>
<td align="left">JDBC-ODBC 桥</td>
<td align="left">依赖 ODBC</td>
<td align="left">复杂</td>
<td align="left">差</td>
<td align="left"><strong>已废弃</strong></td>
</tr>
<tr>
<td align="left"><strong>Type 2</strong></td>
<td align="left">Java + 本地库</td>
<td align="left">依赖本地库</td>
<td align="left">复杂</td>
<td align="left">较好</td>
<td align="left">很少使用</td>
</tr>
<tr>
<td align="left"><strong>Type 3</strong></td>
<td align="left">纯 Java (通过中间件)</td>
<td align="left">无</td>
<td align="left">中等 (需配置中间件)</td>
<td align="left">取决于中间件</td>
<td align="left">特定场景使用</td>
</tr>
<tr>
<td align="left"><strong>Type 4</strong></td>
<td align="left"><strong>纯 Java (直接通信)</strong></td>
<td align="left"><strong>无</strong></td>
<td align="left"><strong>简单 (只需 JAR)</strong></td>
<td align="left"><strong>最佳</strong></td>
<td align="left"><strong>行业标准</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="2-3-如何使用驱动：加载与注册"><a href="#2-3-如何使用驱动：加载与注册" class="headerlink" title="2.3 如何使用驱动：加载与注册"></a><strong>2.3 如何使用驱动：加载与注册</strong></h3><p>在早期的 JDBC（4.0 以前）中，我们需要手动加载驱动类到 JVM 中。</p>
<p><strong>传统方式 (JDBC 4.0 之前): <code>Class.forName()</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 手动加载 MySQL 驱动类</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class="comment">// 对于 MySQL 5.x</span></span><br><span class="line">    <span class="comment">// Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 对于 MySQL 8.x</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这行代码利用 Java 的反射机制，将驱动类的 <code>.class</code> 文件加载到内存中。该驱动类的静态代码块（<code>static { ... }</code>）会自动执行，在这个代码块里，驱动实例会调用 <code>DriverManager.registerDriver(new Driver())</code> 将自己注册到 <code>DriverManager</code> 中。</p>
<p><strong>现代方式 (JDBC 4.0 及以后): 自动注册 (SPI机制)</strong></p>
<p>从 JDBC 4.0 开始，驱动的加载过程实现了自动化，我们<strong>不再需要</strong>显式调用 <code>Class.forName()</code>。</p>
<p>这是通过 <strong>SPI (Service Provider Interface)</strong> 机制实现的。符合 JDBC 4.0 规范的驱动 JAR 包中，会包含一个 <code>META-INF/services/java.sql.Driver</code> 文件。这个文件的内容就是驱动主类的全限定名，例如：<code>com.mysql.cj.jdbc.Driver</code>，当我们的应用程序启动时，<code>DriverManager</code> 会自动扫描 classpath，找到所有符合这个规范的 JAR 包，读取这个文件，并自动加载和注册其中指定的驱动类。</p>
<p><strong>因此，在现代开发中，只需要确保数据库驱动的 JAR 包在你的项目依赖中（例如通过 Maven 或 Gradle 添加），连接过程就会自动完成，无需任何手动加载代码。</strong></p>
<hr>
<h2 id="3-开发环境准备"><a href="#3-开发环境准备" class="headerlink" title="3. 开发环境准备"></a>3. 开发环境准备</h2><h5 id="3-1-导入-JDBC-驱动"><a href="#3-1-导入-JDBC-驱动" class="headerlink" title="3.1 导入 JDBC 驱动"></a><strong>3.1 导入 JDBC 驱动</strong></h5><p>要让 Java 程序使用 JDBC 驱动，必须将驱动的 JAR 文件添加到项目的 <strong>Classpath</strong> (类路径) 中。Classpath 是 JVM 用来搜索类和资源的路径集合。</p>
<p>目前主流的导入方式有两种：使用构建工具（推荐）和手动导入。</p>
<p><strong>方式一：使用构建工具 (Maven &#x2F; Gradle) - 推荐</strong></p>
<p>在企业开发中，所有项目都是使用 Maven 或 Gradle 等构建工具来管理项目依赖。你只需要在项目的构建配置文件中（<code>pom.xml</code> for Maven, <code>build.gradle</code> for Gradle）添加相应的依赖项即可。</p>
<p><strong>示例：</strong></p>
<ol>
<li><p><strong>MySQL 驱动 (<code>mysql-connector-j</code>)</strong></p>
<ul>
<li><p><strong>Maven (<code>pom.xml</code>):</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用你需要的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Gradle (<code>build.gradle</code>):</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.mysql:mysql-connector-j:8.0.33&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Oracle 驱动 (<code>ojdbc</code>)</strong></p>
<ul>
<li><p>Oracle 的驱动可能不在公共的 Maven 中央仓库，但通常可以从 Oracle 自己的仓库或可信的第三方仓库获取。</p>
</li>
<li><p><strong>Maven (<code>pom.xml</code>):</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle.database.jdbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!-- ojdbc11 对应 JDK 11+, ojdbc8 对应 JDK 8+ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>21.9.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Gradle (<code>build.gradle</code>):</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.oracle.database.jdbc:ojdbc11:21.9.0.0&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>PostgreSQL 驱动</strong></p>
<ul>
<li><p><strong>Maven (<code>pom.xml</code>):</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>42.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Gradle (<code>build.gradle</code>):</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.postgresql:postgresql:42.6.0&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>方式二：手动导入 JAR 包</strong></p>
<p>如果你未使用构建工具（例如在学习阶段或简单的桌面应用中），可以手动下载驱动 JAR 文件并添加到项目中。</p>
<ol>
<li><strong>下载驱动</strong>:<ul>
<li><strong>MySQL</strong>: 前往 <a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/connector/j/">MySQL Community Downloads</a> 页面，选择 “Platform Independent”，下载 ZIP 或 TAR.GZ 压缩包，解压后找到 <code>mysql-connector-j-x.x.x.jar</code>。</li>
<li><strong>Oracle</strong>: 前往 <a target="_blank" rel="noopener" href="https://www.oracle.com/database/technologies/jdbc-ucp-19c-downloads.html">Oracle JDBC Driver Downloads</a> 页面下载对应版本的 <code>ojdbcX.jar</code>。</li>
<li><strong>PostgreSQL</strong>: 前往 <a target="_blank" rel="noopener" href="https://jdbc.postgresql.org/download/">PostgreSQL JDBC Driver Downloads</a> 页面下载 JAR 文件。</li>
</ul>
</li>
<li><strong>添加到项目</strong>:<ul>
<li>在你的项目根目录下创建一个 <code>lib</code> (或 <code>libs</code>) 文件夹。</li>
<li>将下载好的 JAR 文件复制到这个 <code>lib</code> 文件夹中。</li>
<li>在你的 IDE (如 IntelliJ IDEA) 中，将这个 JAR 文件添加到项目的构建路径中。<ul>
<li><strong>IntelliJ IDEA</strong>: 右键点击 JAR 文件 -&gt; <code>Add as Library...</code> -&gt; 选择模块并确认。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-2-数据库连接-URL-格式详解"><a href="#3-2-数据库连接-URL-格式详解" class="headerlink" title="3.2 数据库连接 URL 格式详解"></a><strong>3.2 数据库连接 URL 格式详解</strong></h5><p>数据库连接 URL 是一个特殊格式的字符串，它为 <code>DriverManager</code> 提供了连接数据库所需的所有信息。它就像一个数据库的“地址”。</p>
<p><strong>通用格式:</strong><code>jdbc:&lt;subprotocol&gt;://&lt;hostname&gt;:&lt;port&gt;/&lt;databaseName&gt;?&lt;property1&gt;=&lt;value1&gt;&amp;&lt;property2&gt;=&lt;value2&gt;</code></p>
<ul>
<li><strong><code>jdbc:</code></strong>: JDBC URL 的标准前缀，固定不变。</li>
<li><strong><code>&lt;subprotocol&gt;</code></strong>: 子协议，用于标识特定的数据库类型，例如 <code>mysql</code>, <code>oracle</code>, <code>postgresql</code>。<code>DriverManager</code> 就是根据这个来选择正确的驱动。</li>
<li><strong><code>&lt;hostname&gt;</code></strong>: 数据库服务器的主机名或 IP 地址。如果是本地数据库，通常使用 <code>localhost</code> 或 <code>127.0.0.1</code>。</li>
<li><strong><code>&lt;port&gt;</code></strong>: 数据库服务器监听连接的端口号。每种数据库都有一个默认端口。</li>
<li><strong><code>&lt;databaseName&gt;</code></strong>: 要连接的具体数据库、模式或服务名。</li>
<li><strong><code>?&lt;properties&gt;</code></strong>: 可选参数，用于提供额外的连接配置，以 <code>key=value</code> 形式给出，多个参数用 <code>&amp;</code> 分隔。</li>
</ul>
<p><strong>常见数据库 URL 示例与详解:</strong></p>
<ol>
<li><p><strong>MySQL</strong></p>
<ul>
<li><p><strong>默认端口</strong>: <code>3306</code></p>
</li>
<li><p><strong>基本格式</strong>: <code>jdbc:mysql://&lt;hostname&gt;:&lt;port&gt;/&lt;databaseName&gt;</code></p>
</li>
<li><p><strong>示例</strong>:<code>jdbc:mysql://localhost:3306/my_db</code></p>
</li>
<li><p><strong>带有推荐参数的完整示例 (MySQL 8.x):</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://localhost:3306/my_db?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8</span><br></pre></td></tr></table></figure>

<ul>
<li><code>useSSL=false</code>: 在开发环境中通常关闭 SSL 连接以避免警告。</li>
<li><code>serverTimezone=UTC</code>: <strong>非常重要！</strong> 建议显式设置时区，以避免因服务器、客户端、JVM 时区不一致导致的 <code>java.sql.SQLException: The server time zone ... is not recognized</code> 错误。也可以设置为 <code>Asia/Shanghai</code>。</li>
<li><code>characterEncoding=utf8</code>: 确保在数据传输过程中正确处理中文字符，防止乱码。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Oracle</strong></p>
<ul>
<li><strong>默认端口</strong>: <code>1521</code></li>
<li>Oracle 的连接方式主要有两种：SID 和 Service Name。</li>
<li><strong>a) SID (System Identifier) 格式 (旧式&#x2F;简单环境):</strong><ul>
<li><strong>格式</strong>: <code>jdbc:oracle:thin:@&lt;hostname&gt;:&lt;port&gt;:&lt;SID&gt;</code></li>
<li><strong>示例</strong>: <code>jdbc:oracle:thin:@localhost:1521:XE</code> (XE 是 Oracle Express Edition 的默认 SID)</li>
</ul>
</li>
<li><strong>b) Service Name 格式 (推荐&#x2F;RAC环境):</strong><ul>
<li><strong>格式</strong>: <code>jdbc:oracle:thin:@//&lt;hostname&gt;:&lt;port&gt;/&lt;serviceName&gt;</code></li>
<li><strong>注意</strong>: 主机名前有两个斜杠 <code>//</code>，并且 SID 的分隔符 <code>:</code> 变成了 <code>/</code>。</li>
<li><strong>示例</strong>: <code>jdbc:oracle:thin:@//localhost:1521/orclpdb</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>PostgreSQL</strong></p>
<ul>
<li><strong>默认端口</strong>: <code>5432</code></li>
<li><strong>基本格式</strong>: <code>jdbc:postgresql://&lt;hostname&gt;:&lt;port&gt;/&lt;databaseName&gt;</code></li>
<li><strong>示例</strong>:<br><code>jdbc:postgresql://localhost:5432/my_postgres_db</code></li>
<li><strong>带模式(schema)的示例</strong>:<br><code>jdbc:postgresql://localhost:5432/my_postgres_db?currentSchema=public</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="4-第一个-JDBC-程序"><a href="#4-第一个-JDBC-程序" class="headerlink" title="4. 第一个 JDBC 程序"></a>4. 第一个 JDBC 程序</h2><h3 id="4-1-准备工作-Prerequisites"><a href="#4-1-准备工作-Prerequisites" class="headerlink" title="4.1 准备工作 (Prerequisites)"></a>4.1 准备工作 (Prerequisites)</h3><p>在运行代码之前，请确保你已经完成了以下准备：</p>
<ol>
<li><p><strong>数据库和表已创建</strong>：</p>
<ul>
<li><p>在你的 MySQL 数据库中，创建一个名为 <code>my_db</code> 的数据库。</p>
</li>
<li><p>在该数据库中，执行以下 SQL 语句创建 <code>users</code> 表并插入一些示例数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> users (name, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;alice@example.com&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;bob@example.com&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;charlie@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>JDBC 驱动已导入</strong>：</p>
<ul>
<li>确保 MySQL 的 JDBC 驱动 JAR 包（例如 <code>mysql-connector-j-8.0.33.jar</code>）已经按照上一节的方法添加到了你的项目类路径 (Classpath) 中。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-2-示例代码"><a href="#4-2-示例代码" class="headerlink" title="4.2 示例代码"></a>4.2 示例代码</h3><p>下面是一个完整的 Java 类，它演示了 JDBC 的基本操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcHelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 定义数据库连接参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dbUrl</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbUser</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>; <span class="comment">// 替换为你的数据库用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dbPassword</span> <span class="operator">=</span> <span class="string">&quot;your_password&quot;</span>; <span class="comment">// 替换为你的数据库密码</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 加载并注册驱动 (在JDBC 4.0+中，此步骤通常是自动的，可以省略)</span></span><br><span class="line">            <span class="comment">// Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 获取数据库连接 (Connection)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Connecting to database...&quot;</span>);</span><br><span class="line">            connection = DriverManager.getConnection(dbUrl, dbUser, dbPassword);</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection successful!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 创建执行 SQL 的对象 (Statement)</span></span><br><span class="line">            statement = connection.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 执行 SQL 查询，并获取结果集 (ResultSet)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email FROM users&quot;</span>;</span><br><span class="line">            resultSet = statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 遍历结果集，处理数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Users in database:&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="comment">// 根据列名或列索引(从1开始)获取数据</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 打印结果</span></span><br><span class="line">                System.out.println(<span class="string">&quot;ID: &quot;</span> + id + <span class="string">&quot;, Name: &quot;</span> + name + <span class="string">&quot;, Email: &quot;</span> + email);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印详细的异常信息</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7. 释放资源 (至关重要！)</span></span><br><span class="line">            <span class="comment">// 按照 &quot;后开先关&quot; 的原则，依次关闭</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Closing resources...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                    resultSet.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">                    statement.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Resources closed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-JDBC-核心六大步骤详解"><a href="#4-3-JDBC-核心六大步骤详解" class="headerlink" title="4.3 JDBC 核心六大步骤详解"></a><strong>4.3 JDBC 核心六大步骤详解</strong></h3><p>上面的代码清晰地展示了使用 JDBC 的标准流程，可以总结为以下六个步骤：</p>
<p><strong>第 1 步：定义连接参数</strong></p>
<p>这是准备工作，我们将 URL、用户名和密码存储在变量中，便于管理和修改。</p>
<p><strong>第 2 步：加载并注册驱动</strong> (可选)</p>
<p><code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code></p>
<ul>
<li><strong>作用</strong>: 告诉 JVM 加载这个驱动类。</li>
<li><strong>现状</strong>: 在现代 JDBC 4.0+ 规范下，由于 SPI 自动注册机制，<code>DriverManager</code> 能自动发现并加载 classpath 中的驱动。因此，<strong>这行代码通常可以省略</strong>。</li>
</ul>
<p><strong>第 3 步：获取数据库连接</strong></p>
<p><code>connection = DriverManager.getConnection(dbUrl, dbUser, dbPassword);</code></p>
<ul>
<li><strong>核心</strong>: 这是 JDBC 的入口点。</li>
<li><code>DriverManager</code> 类会根据 <code>dbUrl</code> (<code>jdbc:mysql://...</code>) 找到已注册的 MySQL 驱动。</li>
<li>然后委托该驱动与数据库服务器建立一个网络连接。</li>
<li>如果连接成功，它会返回一个 <code>Connection</code> 对象。这个对象代表了你的 Java 程序与数据库之间的一个活动会话。如果失败（如密码错误、数据库未启动），则会抛出 <code>SQLException</code>。</li>
</ul>
<p><strong>第 4 步：创建执行 SQL 的对象</strong></p>
<p><code>statement = connection.createStatement();</code></p>
<ul>
<li><strong>作用</strong>: <code>Connection</code> 对象本身不能直接执行 SQL。你需要通过它创建一个 “SQL 运载工具”，即 <code>Statement</code> 对象。</li>
<li><code>Statement</code> 对象用于发送简单的、不带参数的 SQL 语句到数据库。</li>
</ul>
<p><strong>第 5 步：执行 SQL 并获取结果集</strong></p>
<p><code>resultSet = statement.executeQuery(sql);</code></p>
<ul>
<li><strong><code>executeQuery(String sql)</code></strong>: 这个方法专门用于执行 <strong>查询语句 (SELECT)</strong>。</li>
<li><strong><code>ResultSet</code> 对象</strong>: 如果查询成功，会返回一个 <code>ResultSet</code> 对象。你可以把 <code>ResultSet</code> 想象成一个指向查询结果数据表格的 <strong>“行指针”或“游标”</strong>。初始时，这个指针位于第一行数据之前。</li>
</ul>
<p><strong>第 6 步：遍历结果集，处理数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">// ... 获取数据 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>resultSet.next()</code></strong>: 这是一个非常重要的方法。它有两个作用：<ol>
<li>尝试将指针移动到下一行。</li>
<li>如果下一行存在数据，则返回 <code>true</code>；如果已经没有更多行（到达数据末尾），则返回 <code>false</code>。</li>
</ol>
</li>
<li><code>while</code> 循环完美地利用了这个特性来遍历所有查询结果。</li>
<li><strong><code>resultSet.getXXX(&quot;columnName&quot;)</code> 或 <code>resultSet.getXXX(columnIndex)</code></strong>: 在循环内部，我们使用 <code>get</code> 系列方法从当前行中提取数据。<ul>
<li><code>getInt(&quot;id&quot;)</code>: 获取名为 <code>id</code> 的列的 <code>int</code> 类型值。</li>
<li><code>getString(&quot;name&quot;)</code>: 获取名为 <code>name</code> 的列的 <code>String</code> 类型值。</li>
<li>使用列名更具可读性，使用列索引（从 1 开始，不是 0！）在某些情况下性能稍好。</li>
</ul>
</li>
</ul>
<p><strong>第 7 步 (在 <code>finally</code> 块中)：释放资源</strong></p>
<ul>
<li><strong>为什么至关重要</strong>: <code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 都是非常宝贵的资源，它们占用了数据库连接和内存。<strong>如果不显式关闭它们，会导致资源泄露</strong>。当大量连接不被释放时，最终会耗尽数据库的连接数，导致整个应用无法连接数据库。</li>
<li><strong>为什么在 <code>finally</code> 块中</strong>: <code>finally</code> 块确保了无论 <code>try</code> 块中的代码是否发生异常，资源关闭的逻辑 <strong>总会被执行</strong>。</li>
<li><strong>关闭顺序</strong>: 遵循 <strong>“后开先关”</strong> 的原则：<code>ResultSet</code> -&gt; <code>Statement</code> -&gt; <code>Connection</code>。因为 <code>Statement</code> 依赖 <code>Connection</code>，<code>ResultSet</code> 依赖 <code>Statement</code>。</li>
</ul>
<hr>
<h3 id="4-4-运行结果"><a href="#4-4-运行结果" class="headerlink" title="4.4 运行结果"></a><strong>4.4 运行结果</strong></h3><p>如果你正确配置了所有内容，运行上述 <code>main</code> 方法后，你将在控制台看到类似以下的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connecting to database...</span><br><span class="line">Connection successful!</span><br><span class="line">Users in database:</span><br><span class="line">ID: 1, Name: Alice, Email: alice@example.com</span><br><span class="line">ID: 2, Name: Bob, Email: bob@example.com</span><br><span class="line">ID: 3, Name: Charlie, Email: charlie@example.com</span><br><span class="line">Closing resources...</span><br><span class="line">Resources closed.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-基础异常处理"><a href="#5-基础异常处理" class="headerlink" title="5. 基础异常处理"></a>5. 基础异常处理</h2><h3 id="5-1-理解-SQLException"><a href="#5-1-理解-SQLException" class="headerlink" title="5.1 理解 SQLException"></a><strong>5.1 理解 <code>SQLException</code></strong></h3><p><code>SQLException</code> 是 JDBC API 中所有数据库访问错误的 <strong>根异常</strong>。它是一个 <strong>受检异常 (Checked Exception)</strong>，这意味着 Java 编译器会强制你必须在代码中处理它（通过 <code>try-catch</code> 捕获或 <code>throws</code> 声明抛出）。</p>
<p><strong><code>SQLException</code> 何时会抛出？</strong></p>
<p>几乎在 JDBC 的每一个环节都可能遇到 <code>SQLException</code>，常见原因包括：</p>
<ul>
<li><strong>连接阶段 (<code>DriverManager.getConnection</code>)</strong>:<ul>
<li>数据库 URL 格式错误。</li>
<li>用户名或密码不正确。</li>
<li>数据库服务器未运行或网络不通。</li>
<li>驱动程序未找到（虽然更常见的是 <code>ClassNotFoundException</code>，但某些驱动实现可能包装成 <code>SQLException</code>）。</li>
</ul>
</li>
<li><strong>执行 SQL 阶段 (<code>statement.execute...</code>)</strong>:<ul>
<li>SQL 语法错误。</li>
<li>查询的表或列不存在。</li>
<li>违反数据库约束（如插入重复的主键、外键约束失败）。</li>
<li>权限不足，用户无权执行该操作。</li>
</ul>
</li>
<li><strong>处理结果阶段 (<code>resultSet.get...</code>)</strong>:<ul>
<li>尝试获取不存在的列名。</li>
<li>数据类型不匹配（如尝试用 <code>getInt</code> 获取一个字符串类型的值）。</li>
</ul>
</li>
<li><strong>其他</strong>:<ul>
<li>数据库连接超时或被服务器中断。</li>
</ul>
</li>
</ul>
<p><strong>从 <code>SQLException</code> 中获取有用的调试信息</strong></p>
<p>当捕获到 <code>SQLException</code> 时，它不仅仅是一个简单的错误信号，还包含了诊断信息，帮助我们快速定位问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;Database Error!&quot;</span>);</span><br><span class="line">    <span class="comment">// 1. 获取详细的错误信息 (给开发者看)</span></span><br><span class="line">    System.err.println(<span class="string">&quot;Message: &quot;</span> + e.getMessage());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取数据库厂商特定的错误码 (非常有用！)</span></span><br><span class="line">    System.err.println(<span class="string">&quot;Error Code: &quot;</span> + e.getErrorCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取标准的 SQLState 码 (5位字符，跨数据库)</span></span><br><span class="line">    System.err.println(<span class="string">&quot;SQLState: &quot;</span> + e.getSQLState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 打印完整的堆栈跟踪信息</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>getMessage()</code></strong>: 返回一个描述错误的字符串，通常是数据库直接返回的错误信息，例如 “Table ‘my_db.non_existent_table’ doesn’t exist”。</li>
<li><strong><code>getErrorCode()</code></strong>: 返回一个特定于数据库厂商的整数错误代码。例如，MySQL 的 <code>1064</code> 表示语法错误，<code>1045</code> 表示访问被拒绝。你可以根据这个代码去查阅对应数据库的官方文档，找到最精确的错误原因。</li>
<li><strong><code>getSQLState()</code></strong>: 返回一个遵循 X&#x2F;Open 或 SQL:2003 标准的 5 位字符串代码。它的通用性更强，但通常不如 <code>ErrorCode</code> 直观。</li>
</ul>
<hr>
<h3 id="5-2-资源释放的重要性与-finally"><a href="#5-2-资源释放的重要性与-finally" class="headerlink" title="5.2 资源释放的重要性与 finally"></a><strong>5.2 资源释放的重要性与 <code>finally</code></strong></h3><p><strong>1. 为什么必须释放资源？—— 资源泄露的危害</strong></p>
<p>在 JDBC 中，<code>Connection</code>, <code>Statement</code>, 和 <code>ResultSet</code> 对象不仅是 Java 对象，它们还代表着底层的、有限的物理资源：</p>
<ul>
<li><strong><code>Connection</code></strong>: 代表一个与数据库服务器的真实网络连接。数据库能支持的并发连接数是有限的。</li>
<li><strong><code>Statement</code></strong>: 在数据库服务器端可能会占用游标 (cursor) 和内存。</li>
<li><strong><code>ResultSet</code></strong>: 可能会在数据库端或内存中缓存大量的查询结果数据。</li>
</ul>
<p><strong>资源泄露 (Resource Leak)</strong> 指的是程序在使用完这些资源后，没有调用它们的 <code>close()</code> 方法将其归还。</p>
<p><strong>2. 为什么选择 <code>finally</code> 块？—— 保证执行</strong></p>
<p><code>finally</code> 块的特性是：<strong>无论 <code>try</code> 块中的代码是正常执行完毕，还是中途因为异常而跳出，<code>finally</code> 块中的代码都保证会被执行。</strong></p>
<p>这完美地契合了资源释放的需求。我们不能把 <code>close()</code> 方法放在 <code>try</code> 块的末尾，因为一旦 <code>try</code> 块中发生异常，后面的 <code>close()</code> 代码就永远不会被执行，从而导致资源泄露。</p>
<p><strong>3. 传统的、健壮的 <code>finally</code> 写法</strong></p>
<p>在 “HelloWorld” 示例中，我们看到了一个基本的 <code>finally</code> 块。但一个更健壮的写法需要考虑 <code>close()</code> 方法本身也可能抛出 <code>SQLException</code>，并且要处理对象为 <code>null</code> 的情况（如果在 <code>try</code> 块早期就发生异常，某些对象可能还未被实例化）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 关闭 ResultSet</span></span><br><span class="line">    <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resultSet.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 记录日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 关闭 Statement</span></span><br><span class="line">    <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 记录日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 关闭 Connection</span></span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 记录日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种层层嵌套的写法虽然代码冗长，但它确保了：</p>
<ul>
<li><strong>空指针安全</strong>：在调用 <code>close()</code> 前检查对象是否为 <code>null</code>。</li>
<li><strong>关闭独立性</strong>：一个资源的关闭失败，不会影响其他资源的关闭尝试。</li>
</ul>
<hr>
<h3 id="5-3-现代化的资源管理：try-with-resources-预告"><a href="#5-3-现代化的资源管理：try-with-resources-预告" class="headerlink" title="5.3 现代化的资源管理：try-with-resources (预告)"></a><strong>5.3 现代化的资源管理：<code>try-with-resources</code> (预告)</strong></h3><p>传统的 <code>finally</code> 写法非常繁琐且容易出错。幸运的是，从 <strong>Java 7</strong> 开始，引入了一种更优雅、更安全的语法糖—— <strong><code>try-with-resources</code></strong> 语句。</p>
<p>它能自动管理实现了 <code>AutoCloseable</code> 接口（<code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 都实现了该接口）的资源。</p>
<p><strong>对比一下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 try-with-resources (推荐)</span></span><br><span class="line"><span class="comment">// 将需要关闭的资源在 try() 的括号内声明</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, USER, PASS);</span><br><span class="line">     <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">     <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(SQL)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接在这里使用 conn, stmt, rs</span></span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        <span class="comment">// ... process data ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无需 finally 块！</span></span><br><span class="line"><span class="comment">// 在 try 块结束时，rs, stmt, conn 会被自动、安全地关闭，顺序也是正确的。</span></span><br></pre></td></tr></table></figure>

<p>我们将在后续的 <strong>“六、高级主题与性能优化”</strong> 章节中详细讲解并推荐全面使用 <code>try-with-resources</code>，因为它极大地简化了代码，并从根本上避免了资源泄露的风险。目前，你只需要了解它的存在，并理解它解决了传统 <code>finally</code> 块的痛点。</p>
<hr>
<hr>
<h1 id="二、JDBC-核心-API-详解"><a href="#二、JDBC-核心-API-详解" class="headerlink" title="二、JDBC 核心 API 详解"></a>二、JDBC 核心 API 详解</h1><h2 id="1-DriverManager"><a href="#1-DriverManager" class="headerlink" title="1. DriverManager"></a>1. DriverManager</h2><p><code>DriverManager</code> 是位于 <code>java.sql</code> 包下的一个<strong>核心类</strong>。它的主要职责是<strong>管理</strong>一组 JDBC 驱动程序，并作为应用程序获取数据库连接的<strong>工厂</strong>。</p>
<h3 id="1-1-核心职责"><a href="#1-1-核心职责" class="headerlink" title="1.1 核心职责"></a><strong>1.1 核心职责</strong></h3><ol>
<li><strong>管理驱动程序 (Managing Drivers)</strong><ul>
<li><code>DriverManager</code> 维护着一个已注册的 <code>Driver</code> 列表。当 JVM 启动时，它会通过 SPI 机制自动发现并加载 classpath 中所有可用的 JDBC 驱动，并将它们注册到这个列表中。</li>
<li>它也提供了手动注册 (<code>registerDriver</code>) 和注销 (<code>deregisterDriver</code>) 驱动的方法，但在现代 JDBC 编程中已很少直接使用。</li>
</ul>
</li>
<li><strong>建立数据库连接 (Establishing Connections)</strong><ul>
<li>这是 <code>DriverManager</code> 最常用也是最重要的功能。它提供了一系列重载的静态方法 <code>getConnection()</code>，应用程序通过调用这些方法来获取一个 <code>Connection</code> 对象。</li>
<li><code>DriverManager</code> 会遍历其内部已注册的驱动列表，依次询问每个驱动：“你能处理这个 URL 吗？”。第一个成功建立连接并返回 <code>Connection</code> 对象的驱动将被选中。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-关键方法详解"><a href="#1-2-关键方法详解" class="headerlink" title="1.2 关键方法详解"></a><strong>1.2 关键方法详解</strong></h3><p><code>DriverManager</code> 的所有方法都是静态的，这意味着你不需要创建它的实例，直接通过类名 <code>DriverManager.methodName()</code> 调用即可。</p>
<h4 id="1-2-1-static-Connection-getConnection-String-url"><a href="#1-2-1-static-Connection-getConnection-String-url" class="headerlink" title="1.2.1 static Connection getConnection(String url)"></a>1.2.1 <code>static Connection getConnection(String url)</code></h4><ul>
<li>这是最简单的形式，只接收一个数据库连接 URL。</li>
<li>这种形式通常用于 URL 中已经包含了所有认证信息，或者用于那些不需要用户名&#x2F;密码的数据库（如嵌入式数据库 H2 的某些模式）。</li>
<li><strong>不推荐</strong>在 URL 中硬编码密码，因为存在安全风险。</li>
<li><strong>示例</strong>: <code>DriverManager.getConnection(&quot;jdbc:h2:mem:testdb&quot;);</code></li>
</ul>
<hr>
<h4 id="1-2-2-static-Connection-getConnection-String-url-String-user-String-password"><a href="#1-2-2-static-Connection-getConnection-String-url-String-user-String-password" class="headerlink" title="1.2.2 static Connection getConnection(String url, String user, String password)"></a>1.2.2 <code>static Connection getConnection(String url, String user, String password)</code></h4><ul>
<li><p><strong>这是最常用、最推荐的方法</strong>。</p>
</li>
<li><p>它将连接 URL、数据库用户名和密码作为独立的参数传入。这比将认证信息写在 URL 中更清晰、更安全。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>; </span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;your_password&quot;</span>; </span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-3-static-Connection-getConnection-String-url-java-util-Properties-info"><a href="#1-2-3-static-Connection-getConnection-String-url-java-util-Properties-info" class="headerlink" title="1.2.3 static Connection getConnection(String url, java.util.Properties info)"></a>1.2.3 <code>static Connection getConnection(String url, java.util.Properties info)</code></h4><ul>
<li><p>这是一个更灵活的版本，允许你将用户名、密码以及其他任意连接属性（如 <code>characterEncoding</code>）都放入一个 <code>Properties</code> 对象中。</p>
</li>
<li><p>当需要配置大量连接参数时，这种方式能让代码更整洁。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/my_db&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;your_password&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;serverTimezone&quot;</span>, <span class="string">&quot;UTC&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;autoReconnect&quot;</span>, <span class="string">&quot;true&quot;</span>); </span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, props);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-4-static-void-registerDriver-java-sql-Driver-driver"><a href="#1-2-4-static-void-registerDriver-java-sql-Driver-driver" class="headerlink" title="1.2.4 static void registerDriver(java.sql.Driver driver)"></a>1.2.4 <code>static void registerDriver(java.sql.Driver driver)</code></h4><ul>
<li>用于手动向 <code>DriverManager</code> 注册一个驱动实例。</li>
<li>在 <code>Class.forName()</code> 的时代，驱动类的静态代码块会调用这个方法来完成自我注册。</li>
<li><strong>现代开发中基本无需手动调用</strong>。</li>
</ul>
<hr>
<h3 id="1-3-驱动注册机制的演进：从-Class-forName-到-SPI"><a href="#1-3-驱动注册机制的演进：从-Class-forName-到-SPI" class="headerlink" title="1.3 驱动注册机制的演进：从 Class.forName() 到 SPI"></a><strong>1.3 驱动注册机制的演进：从 <code>Class.forName()</code> 到 SPI</strong></h3><p>理解 <code>DriverManager</code> 如何“发现”驱动是理解 JDBC 工作原理的关键。</p>
<h4 id="1-3-1-传统方式-JDBC-3-0-及以前-Class-forName"><a href="#1-3-1-传统方式-JDBC-3-0-及以前-Class-forName" class="headerlink" title="1.3.1 传统方式 (JDBC 3.0 及以前): Class.forName()"></a>1.3.1 传统方式 (JDBC 3.0 及以前): <code>Class.forName()</code></h4><p>在早期，开发者必须在代码中显式加载驱动类：<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></p>
<p>这行代码背后发生了什么？</p>
<ul>
<li><p><strong>第1步: 类加载</strong><br>Java 的反射机制会找到并加载 <code>com.mysql.jdbc.Driver</code> 这个类的字节码（<code>.class</code> 文件）到 JVM 内存中。</p>
</li>
<li><p><strong>第2步: 执行静态代码块</strong><br>类在首次被加载时，其内部的静态代码块 (<code>static { ... }</code>) 会被自动执行。MySQL 驱动的源码中，这个静态块看起来类似这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In com.mysql.jdbc.Driver class</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建驱动实例并向 DriverManager 注册自己</span></span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>Class.forName()</code> 的真正目的是<strong>触发驱动的自我注册过程</strong>。</p>
</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>代码与具体的驱动类名硬耦合。如果更换数据库（比如从 MySQL 换到 PostgreSQL），就必须修改 Java 源代码。</li>
<li>增加了模板代码。</li>
</ul>
<hr>
<h4 id="1-3-2-现代方式-JDBC-4-0-及以后-SPI-Service-Provider-Interface"><a href="#1-3-2-现代方式-JDBC-4-0-及以后-SPI-Service-Provider-Interface" class="headerlink" title="1.3.2 现代方式 (JDBC 4.0 及以后): SPI (Service Provider Interface)"></a>1.3.2 现代方式 (JDBC 4.0 及以后): SPI (Service Provider Interface)</h4><p>从 Java 6 (JDBC 4.0) 开始，引入了 <strong>SPI 服务发现机制</strong>，使得驱动加载完全自动化。</p>
<p><strong>工作原理</strong>:</p>
<ul>
<li>符合 JDBC 4.0 规范的驱动 JAR 包，在其 <code>META-INF/services/</code> 目录下会包含一个名为 <code>java.sql.Driver</code> 的文本文件。</li>
<li>这个文件的内容就是该驱动实现 <code>java.sql.Driver</code> 接口的那个类的<strong>全限定名</strong>。例如，MySQL 8.x 驱动的这个文件内容是：<code>com.mysql.cj.jdbc.Driver</code></li>
<li>当应用程序启动时，<code>DriverManager</code> 会自动扫描 classpath，查找所有 JAR 包中的 <code>META-INF/services/java.sql.Driver</code> 文件。</li>
<li>它会读取文件中的类名，并使用 <code>Class.forName()</code> 在后台自动加载并实例化这些驱动类，从而完成注册。</li>
</ul>
<p><strong>优点</strong>:</p>
<ul>
<li><strong>解耦</strong>: Java 代码不再依赖任何具体的驱动类名，实现了真正的“即插即用”。</li>
<li><strong>简化</strong>: 无需再编写 <code>Class.forName()</code> 这行样板代码。</li>
</ul>
<hr>
<h3 id="1-4-DriverManager-vs-DataSource-现代实践"><a href="#1-4-DriverManager-vs-DataSource-现代实践" class="headerlink" title="1.4 DriverManager vs. DataSource (现代实践)"></a><strong>1.4 <code>DriverManager</code> vs. <code>DataSource</code> (现代实践)</strong></h3><p>尽管 <code>DriverManager</code> 是学习 JDBC 的起点，但在现代企业级应用和生产环境中，我们<strong>更推荐使用 <code>DataSource</code> 接口</strong>来获取连接。<code>DataSource</code> 是在 JDBC 2.0 中引入的，它提供了比 <code>DriverManager</code> 更强大和灵活的功能：</p>
<ul>
<li><strong>更好的抽象</strong>: <code>DataSource</code> 将连接的获取方式与应用程序代码分离。连接的细节（URL, user, password 等）可以在外部配置（如配置文件、JNDI），而不是硬编码在代码中。</li>
<li><strong>连接池支持</strong>: <code>DataSource</code> 是实现数据库连接池（Connection Pooling）的标准方式。连接池可以极大地提升应用程序性能和资源利用率。</li>
<li><strong>分布式事务支持</strong>: <code>DataSource</code> 也是参与 JTA (Java Transaction API) 分布式事务的基础。</li>
</ul>
<p><strong>结论</strong>:<code>DriverManager</code> 非常适合用于简单的应用程序、快速测试和教学演示。但对于任何严肃的、需要高性能和可维护性的项目，都应该转向使用 <code>DataSource</code>（通常由连接池库如 HikariCP, Druid 提供实现）。我们将在后续章节详细介绍连接池和 <code>DataSource</code>。</p>
<hr>
<h2 id="2-Connection"><a href="#2-Connection" class="headerlink" title="2. Connection"></a>2. Connection</h2><p>一旦通过 <code>DriverManager</code> 或 <code>DataSource</code> 成功获取一个 <code>Connection</code> 对象，你就拥有了一个与特定数据库建立的<strong>活动会话 (Session)</strong>。</p>
<h3 id="2-1-核心职责"><a href="#2-1-核心职责" class="headerlink" title="2.1 核心职责"></a>2.1 核心职责</h3><p><code>Connection</code> 对象是 JDBC 编程的中心枢纽，主要承担三大职责：</p>
<ol>
<li><strong>创建 Statement 对象</strong>：它是创建 <code>Statement</code>、<code>PreparedStatement</code> 和 <code>CallableStatement</code> 对象的工厂。这些 Statement 对象是真正用来执行 SQL 语句的工具。</li>
<li><strong>管理事务 (Transaction Management)</strong>：控制事务的边界，包括开启事务、提交事务或回滚事务，确保一组数据库操作的原子性。</li>
<li><strong>获取数据库元数据 (Metadata)</strong>：提供访问关于数据库本身信息的能力，例如数据库产品名称、版本、支持的功能、表结构等。</li>
</ol>
<hr>
<h3 id="2-2-关键方法详解-按功能分组"><a href="#2-2-关键方法详解-按功能分组" class="headerlink" title="2.2 关键方法详解 - 按功能分组"></a>2.2 关键方法详解 - 按功能分组</h3><h4 id="2-2-1-SQL-执行准备"><a href="#2-2-1-SQL-执行准备" class="headerlink" title="2.2.1 SQL 执行准备"></a>2.2.1 SQL 执行准备</h4><p><code>Connection</code> 本身不执行 SQL，而是创建用于执行 SQL 的对象。</p>
<h5 id="1-Statement-createStatement"><a href="#1-Statement-createStatement" class="headerlink" title="1. Statement createStatement()"></a>1. <code>Statement createStatement()</code></h5><ul>
<li>创建一个 <code>Statement</code> 对象，用于发送<strong>简单的、静态的 SQL 语句</strong>。</li>
<li><strong>适用场景</strong>: 执行没有参数的、一次性的 SQL 语句。</li>
<li><strong>缺点</strong>: 存在 SQL 注入风险，性能相对较低（每次执行都需要数据库重新解析 SQL）。</li>
<li><strong>示例</strong>: <code>Statement stmt = connection.createStatement();</code></li>
</ul>
<hr>
<h5 id="2-PreparedStatement-prepareStatement-String-sql"><a href="#2-PreparedStatement-prepareStatement-String-sql" class="headerlink" title="2. PreparedStatement prepareStatement(String sql)"></a>2. <code>PreparedStatement prepareStatement(String sql)</code></h5><ul>
<li><strong>JDBC 中最常用、最重要的 Statement 类型</strong>。</li>
<li>创建一个 <code>PreparedStatement</code> 对象，用于执行<strong>带参数的、预编译的 SQL 语句</strong>。SQL 语句中的参数用占位符 <code>?</code> 表示。</li>
<li><strong>核心优势</strong>:<ul>
<li><strong>防止 SQL 注入</strong>: 它将 SQL 结构和参数数据分开处理，从根本上杜绝了 SQL 注入攻击。</li>
<li><strong>性能更高</strong>: SQL 语句只需在数据库端编译一次，后续可以带着不同的参数高效地执行多次。</li>
</ul>
</li>
<li><strong>示例</strong>: <code>PreparedStatement pstmt = connection.prepareStatement(&quot;SELECT * FROM users WHERE id = ?&quot;);</code></li>
</ul>
<hr>
<h5 id="3-CallableStatement-prepareCall-String-sql"><a href="#3-CallableStatement-prepareCall-String-sql" class="headerlink" title="3. CallableStatement prepareCall(String sql)"></a>3. <code>CallableStatement prepareCall(String sql)</code></h5><ul>
<li>创建一个 <code>CallableStatement</code> 对象，用于<strong>调用数据库中的存储过程</strong>。</li>
<li><strong>适用场景</strong>: 当业务逻辑封装在数据库的存储过程中时使用。</li>
<li><strong>示例</strong>: <code>CallableStatement cstmt = connection.prepareCall(&quot;{call get_user_by_id(?)}&quot;);</code></li>
</ul>
<hr>
<h4 id="2-2-2-事务控制"><a href="#2-2-2-事务控制" class="headerlink" title="2.2.2 事务控制"></a>2.2.2 事务控制</h4><p>事务是一组必须“要么全部成功，要么全部失败”的数据库操作单元。银行转账是解释事务最经典的例子。</p>
<ol>
<li><strong><code>void setAutoCommit(boolean autoCommit)</code></strong><ul>
<li><strong>这是事务管理的核心开关</strong>。</li>
<li>默认情况下，JDBC 的连接处于 <strong>自动提交模式 (<code>autoCommit = true</code>)</strong>。这意味着你执行的每一条 SQL 语句都会被立即视为一个独立的事务并自动提交给数据库，永久生效。</li>
<li>要手动管理事务，必须在执行任何 SQL 之前调用 <code>connection.setAutoCommit(false);</code>，这会开启一个新事务。</li>
</ul>
</li>
<li><strong><code>void commit()</code></strong><ul>
<li>在手动事务模式下（<code>autoCommit = false</code>），调用此方法会将<strong>当前事务中所有已执行的 SQL 操作永久保存</strong>到数据库中。</li>
<li>如果操作成功，一个新的事务会立即开始。</li>
</ul>
</li>
<li><strong><code>void rollback()</code></strong><ul>
<li>在手动事务模式下，调用此方法会<strong>撤销当前事务中所有已执行的 SQL 操作</strong>，使数据库恢复到事务开始之前的状态。</li>
<li>这通常在 <code>catch</code> 块中调用，当事务中的任何一步发生错误时，用以保证数据的一致性。</li>
</ul>
</li>
</ol>
<p><strong>事务实战示例：银行转账</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(<span class="type">int</span> fromAccountId, <span class="type">int</span> toAccountId, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">debitStmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">creditStmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = DriverManager.getConnection(URL, USER, PASS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 关闭自动提交，开启事务</span></span><br><span class="line">        conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. A 账户扣钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">debitSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;</span>;</span><br><span class="line">        debitStmt = conn.prepareStatement(debitSql);</span><br><span class="line">        debitStmt.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">        debitStmt.setInt(<span class="number">2</span>, fromAccountId);</span><br><span class="line">        debitStmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟一个意外（例如，系统崩溃）</span></span><br><span class="line">        <span class="comment">// if (true) &#123; throw new SQLException(&quot;Simulated system failure!&quot;); &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. B 账户加钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">creditSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;</span>;</span><br><span class="line">        creditStmt = conn.prepareStatement(creditSql);</span><br><span class="line">        creditStmt.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">        creditStmt.setInt(<span class="number">2</span>, toAccountId);</span><br><span class="line">        creditStmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 所有操作成功，提交事务</span></span><br><span class="line">        conn.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;Transfer successful!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Transfer failed. Rolling back transaction...&quot;</span>);</span><br><span class="line">        <span class="comment">// 5. 发生任何异常，回滚事务</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 6. 最终都要关闭资源，并恢复自动提交模式（如果连接被池化复用）</span></span><br><span class="line">        <span class="comment">// ... close statements and connection ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-3-连接管理与状态"><a href="#2-2-3-连接管理与状态" class="headerlink" title="2.2.3 连接管理与状态"></a>2.2.3 连接管理与状态</h4><ol>
<li><strong><code>void close()</code></strong><ul>
<li><strong>极其重要的方法</strong>。调用它会立即释放此 <code>Connection</code> 对象占用的数据库和 JDBC 资源。</li>
<li><strong>必须在 <code>finally</code> 块或 <code>try-with-resources</code> 语句中调用</strong>，以确保连接无论如何都会被关闭，防止资源泄露。</li>
</ul>
</li>
<li><strong><code>boolean isClosed()</code></strong><ul>
<li>检查连接是否已经被关闭。</li>
</ul>
</li>
<li><strong><code>boolean isValid(int timeout)</code></strong><ul>
<li>一个更可靠的检查连接是否仍然有效的方法。它会尝试与数据库进行一次简短的通信来确认连接是否存活。比 <code>!isClosed()</code> 更可靠，后者只表示你是否调用了 <code>close()</code> 方法。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-2-4-获取数据库元数据"><a href="#2-2-4-获取数据库元数据" class="headerlink" title="2.2.4 获取数据库元数据"></a>2.2.4 获取数据库元数据</h4><p><strong><code>DatabaseMetaData getMetaData()</code></strong></p>
<ul>
<li>返回一个 <code>DatabaseMetaData</code> 对象，该对象封装了关于整个数据库的综合信息。</li>
<li>你可以用它来动态地发现数据库的能力，例如：<ul>
<li>获取数据库产品名称和版本 (<code>getDatabaseProductName()</code>, <code>getDatabaseProductVersion()</code>)。</li>
<li>获取当前连接的用户名 (<code>getUserName()</code>)。</li>
<li>检查数据库是否支持事务、批量更新等特性。</li>
<li>获取数据库中的所有表、视图、存储过程等信息。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-生命周期与最佳实践"><a href="#2-3-生命周期与最佳实践" class="headerlink" title="2.3 生命周期与最佳实践"></a>2.3 生命周期与最佳实践</h3><ul>
<li><strong>生命周期</strong>: <code>Connection</code> 的生命周期应该是<strong>短暂的</strong>。遵循“尽早获取，尽快释放”的原则。在一个业务操作开始时获取连接，操作结束后立即在 <code>finally</code> 块中关闭它。</li>
<li><strong>线程安全</strong>: <code>Connection</code> 对象<strong>不是线程安全的</strong>。在多线程环境（如 Web 应用）中，绝不能在多个线程之间共享同一个 <code>Connection</code> 对象。正确的做法是为每个线程（或每个请求）分配一个独立的连接。连接池技术就是为此而生。</li>
<li><strong>现代用法</strong>: 强烈推荐使用 <strong><code>try-with-resources</code></strong> 语句来管理 <code>Connection</code>，它能自动、安全地为你关闭连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐的现代写法</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, USER, PASS)) &#123;</span><br><span class="line">    <span class="comment">// 在这里使用 conn 对象</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// conn 会在此处被自动关闭，无需 finally 块</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-SQL-执行器"><a href="#3-SQL-执行器" class="headerlink" title="3. SQL 执行器"></a>3. SQL 执行器</h2><h3 id="3-1-Statement-基本的-SQL-执行器"><a href="#3-1-Statement-基本的-SQL-执行器" class="headerlink" title="3.1 Statement(基本的 SQL 执行器)"></a>3.1 <code>Statement</code>(基本的 SQL 执行器)</h3><p><code>Statement</code> 是最基础的 SQL 执行接口。它用于执行<strong>静态的、不含参数的 SQL 语句</strong>。</p>
<ul>
<li><p><strong>创建方式</strong>: <code>Statement stmt = connection.createStatement();</code></p>
</li>
<li><p><strong>核心方法</strong>:</p>
<ul>
<li><strong><code>ResultSet executeQuery(String sql)</code></strong>:<ul>
<li><strong>用途</strong>: 专门用于执行 <strong><code>SELECT</code> 查询语句</strong>。</li>
<li><strong>返回值</strong>: 返回一个 <code>ResultSet</code> 对象，其中包含了查询结果。</li>
</ul>
</li>
<li><strong><code>int executeUpdate(String sql)</code></strong>:<ul>
<li><strong>用途</strong>: 用于执行 <strong><code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code></strong> 等数据操作语句（DML），以及 <code>CREATE TABLE</code>、<code>DROP TABLE</code> 等数据定义语句（DDL）。</li>
<li><strong>返回值</strong>: 返回一个 <code>int</code> 值，表示<strong>受影响的行数</strong>。对于 DDL 语句，通常返回 0。</li>
</ul>
</li>
<li><strong><code>boolean execute(String sql)</code></strong>:<ul>
<li><strong>用途</strong>: 一个通用的执行方法，可以执行任何类型的 SQL 语句。</li>
<li><strong>返回值</strong>:<ul>
<li>返回 <code>true</code>：如果执行的第一个结果是 <code>ResultSet</code>（即执行了查询语句）。</li>
<li>返回 <code>false</code>：如果执行的第一个结果是更新计数或没有结果（即 DML 或 DDL）。</li>
</ul>
</li>
<li><strong>后续操作</strong>: 调用 <code>execute()</code> 后，你需要通过 <code>getResultSet()</code> 来获取查询结果，或者通过 <code>getUpdateCount()</code> 来获取受影响的行数。这个方法在你不确定将要执行的 SQL 类型时有用，但通常我们更倾向于使用明确的 <code>executeQuery</code> 或 <code>executeUpdate</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ...; <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name FROM users WHERE id = 1&quot;</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line">    <span class="comment">// ... process rs ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主要缺点</strong>:</p>
<ol>
<li><p><strong>存在严重的 SQL 注入风险 (SQL Injection)</strong>:<br><code>Statement</code> 通过字符串拼接来构建 SQL，如果 SQL 中包含用户输入的内容，恶意用户可以构造特殊的输入来篡改原始 SQL 的逻辑，从而执行未授权的操作。<br><strong>危险示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userInputName</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27;=&#x27;1&quot;</span>; <span class="comment">// 恶意输入</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE name = &#x27;&quot;</span> + userInputName + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">// 拼接后的 SQL 变为:</span></span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;&#x27; or &#x27;1&#x27;=&#x27;1&#x27;</span></span><br><span class="line"><span class="comment">// 这将绕过认证，查询出所有用户！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能较差</strong>:<br>每次执行 <code>statement.executeQuery(sql)</code>，数据库都需要对传入的完整 SQL 字符串进行<strong>解析、编译和生成执行计划</strong>。如果一个 SQL 语句需要被反复执行（只是条件不同），这种重复的编译过程会浪费大量数据库资源。</p>
</li>
</ol>
</li>
</ul>
<p><strong>结论</strong>：由于安全和性能问题，<strong><code>Statement</code> 在现代开发中应极力避免使用</strong>，尤其是在处理任何包含外部输入的 SQL 时。它只适用于执行完全硬编码、无变量的 SQL。</p>
<hr>
<h3 id="3-2-PreparedStatement-推荐的-SQL-执行器"><a href="#3-2-PreparedStatement-推荐的-SQL-执行器" class="headerlink" title="3.2 PreparedStatement(推荐的 SQL 执行器)"></a>3.2 <code>PreparedStatement</code>(推荐的 SQL 执行器)</h3><p><code>PreparedStatement</code> 继承自 <code>Statement</code>，是 JDBC 的主力军，<strong>强烈推荐在所有场景下优先使用</strong>。它代表一个<strong>预编译</strong>的 SQL 语句。</p>
<ul>
<li><p><strong>创建方式</strong>: <code>PreparedStatement pstmt = connection.prepareStatement(&quot;SELECT * FROM users WHERE id = ? AND name = ?&quot;);</code></p>
<ul>
<li>SQL 语句在创建时就被发送到数据库进行预编译。</li>
<li>变量部分使用占位符 <code>?</code> 来代替。</li>
</ul>
</li>
<li><p><strong>核心流程</strong>:</p>
<ol>
<li><strong>创建时预编译</strong>: <code>connection.prepareStatement(sql)</code> 将 SQL 模板发送给数据库。数据库对这个不含具体值的 SQL 结构进行解析、编译，并缓存执行计划。</li>
<li><strong>设置参数</strong>: 使用 <code>setXXX(int parameterIndex, value)</code> 方法为占位符 <code>?</code> 绑定具体的值。<strong>注意：参数索引 <code>parameterIndex</code> 从 1 开始！</strong><ul>
<li><code>pstmt.setInt(1, 101);</code> &#x2F;&#x2F; 设置第一个 ? 的值为 101</li>
<li><code>pstmt.setString(2, &quot;Alice&quot;);</code> &#x2F;&#x2F; 设置第二个 ? 的值为 “Alice”</li>
</ul>
</li>
<li><strong>执行</strong>: 调用<strong>不带 SQL 参数</strong>的执行方法。<ul>
<li><code>ResultSet rs = pstmt.executeQuery();</code></li>
<li><code>int affectedRows = pstmt.executeUpdate();</code></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>核心优势</strong>:</p>
<ol>
<li><strong>从根本上防止 SQL 注入</strong>:<br><code>PreparedStatement</code> 将 SQL 的<strong>结构</strong>和<strong>数据</strong>完全分离。当你调用 <code>setString()</code> 等方法时，驱动会将数据作为纯粹的参数传递给数据库，数据库绝不会将这些参数值作为 SQL 指令来解析。即使恶意用户输入 <code>&quot;&#39; or &#39;1&#39;=&#39;1&quot;</code>，数据库也只会把它当作一个普通的字符串去查找一个名字就叫 <code>&quot;&#39; or &#39;1&#39;=&#39;1&quot;</code> 的用户，而不会改变查询的逻辑。</li>
<li><strong>性能显著提升</strong>:<br>由于 SQL 语句只在创建时编译一次，之后每次执行时，数据库只需将新的参数代入已缓存的执行计划中即可，省去了反复解析和编译的开销。这对于需要<strong>批量或重复执行</strong>的 SQL 操作（如循环插入数据）性能提升尤为明显。</li>
<li><strong>代码可读性和可维护性更好</strong>:<br>将 SQL 语句和参数设置分开，使得代码逻辑更清晰，避免了繁琐且容易出错的字符串拼接。</li>
</ol>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ...; <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">    pstmt.setString(<span class="number">1</span>, <span class="string">&quot;David&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">2</span>, <span class="string">&quot;david@example.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line">    System.out.println(<span class="string">&quot;Inserted &quot;</span> + affectedRows + <span class="string">&quot; row(s).&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-3-CallableStatement：专业的存储过程执行器"><a href="#3-3-CallableStatement：专业的存储过程执行器" class="headerlink" title="3.3 CallableStatement：专业的存储过程执行器"></a>3.3 <code>CallableStatement</code>：专业的存储过程执行器</h3><p><code>CallableStatement</code> 继承自 <code>PreparedStatement</code>，专门用于<strong>调用数据库中的存储过程和函数</strong>。</p>
<ul>
<li><p><strong>创建方式</strong>: <code>CallableStatement cstmt = connection.prepareCall(&quot;{call procedure_name(?, ?)}&quot;);</code></p>
<ul>
<li>使用标准的 JDBC 调用语法 <code>{call ...}</code>。</li>
</ul>
</li>
<li><p><strong>核心特性</strong>:</p>
<ul>
<li><strong>支持 IN 参数</strong>: 与 <code>PreparedStatement</code> 一样，通过 <code>setXXX()</code> 方法设置输入参数。</li>
<li><strong>支持 OUT 参数</strong>: 可以接收存储过程的输出参数。你需要先用 <code>registerOutParameter(int parameterIndex, int sqlType)</code> 方法注册输出参数的类型，执行完毕后再用 <code>getXXX(int parameterIndex)</code> 方法获取其值。</li>
<li><strong>支持 INOUT 参数</strong>: 既是输入也是输出的参数。</li>
</ul>
</li>
<li><p><strong>示例</strong>:<br>假设数据库中有一个存储过程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_user_name_by_id (<span class="keyword">IN</span> user_id <span class="type">INT</span>, <span class="keyword">OUT</span> user_name <span class="type">VARCHAR</span>(<span class="number">50</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> name <span class="keyword">INTO</span> user_name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> user_id;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>Java 调用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;&#123;call get_user_name_by_id(?, ?)&#125;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ...; <span class="type">CallableStatement</span> <span class="variable">cstmt</span> <span class="operator">=</span> conn.prepareCall(sql)) &#123;</span><br><span class="line">    <span class="comment">// 设置 IN 参数</span></span><br><span class="line">    cstmt.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 OUT 参数，指定其 SQL 类型</span></span><br><span class="line">    cstmt.registerOutParameter(<span class="number">2</span>, java.sql.Types.VARCHAR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行存储过程</span></span><br><span class="line">    cstmt.execute();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 OUT 参数的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> cstmt.getString(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User name is: &quot;</span> + userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>结论</strong>：当业务逻辑被封装在数据库的存储过程中时，<code>CallableStatement</code> 是与它们交互的唯一标准方式。</p>
<hr>
<h3 id="3-4-总结对比"><a href="#3-4-总结对比" class="headerlink" title="3.4 总结对比"></a>3.4 总结对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>Statement</code></th>
<th align="left"><code>PreparedStatement</code></th>
<th align="left"><code>CallableStatement</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>用途</strong></td>
<td align="left">执行静态、无参数的SQL</td>
<td align="left">执行带参数、预编译的SQL</td>
<td align="left">调用数据库存储过程&#x2F;函数</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">差 (每次都编译)</td>
<td align="left"><strong>好</strong> (编译一次，多次运行)</td>
<td align="left">同 PreparedStatement</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>不安全 (易SQL注入)</strong></td>
<td align="left"><strong>安全 (从根本上防止)</strong></td>
<td align="left">安全</td>
</tr>
<tr>
<td align="left"><strong>参数类型</strong></td>
<td align="left">无</td>
<td align="left">仅 IN 参数</td>
<td align="left">IN, OUT, INOUT 参数</td>
</tr>
<tr>
<td align="left"><strong>推荐使用</strong></td>
<td align="left"><strong>永不用于生产</strong></td>
<td align="left"><strong>绝大多数场景下的首选</strong></td>
<td align="left">仅用于调用存储过程</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-ResultSet"><a href="#4-ResultSet" class="headerlink" title="4. ResultSet"></a>4. ResultSet</h2><h3 id="4-1-核心概念：行光标-Cursor"><a href="#4-1-核心概念：行光标-Cursor" class="headerlink" title="4.1 核心概念：行光标 (Cursor)"></a>4.1 核心概念：行光标 (Cursor)</h3><p>理解 <code>ResultSet</code> 的关键在于理解其内部的光标（也叫指针）。</p>
<ul>
<li><strong>初始位置</strong>: 当你刚拿到一个 <code>ResultSet</code> 对象时，光标指向一个虚拟的“第 0 行”，即在第一行实际数据之前。</li>
<li><strong>移动光标</strong>: 你需要调用 <code>next()</code> 方法将光标向下移动一行。</li>
<li><strong>数据访问</strong>: 只有当光标指向一个有效的数据行时，你才能使用 <code>getXXX()</code> 方法来获取该行的数据。</li>
<li><strong>结束位置</strong>: 当 <code>next()</code> 方法将光标移动到最后一行数据时，再次调用 <code>next()</code> 将返回 <code>false</code>，表示所有数据都已遍历完毕。</li>
</ul>
<hr>
<h3 id="4-2-核心方法详解"><a href="#4-2-核心方法详解" class="headerlink" title="4.2 核心方法详解"></a>4.2 核心方法详解</h3><h4 id="4-2-1-移动光标与遍历"><a href="#4-2-1-移动光标与遍历" class="headerlink" title="4.2.1 移动光标与遍历"></a>4.2.1 移动光标与遍历</h4><p><strong><code>boolean next()</code></strong></p>
<ul>
<li><p><strong>这是最核心、最常用的方法</strong>。</p>
</li>
<li><p><strong>双重作用</strong>:</p>
<ol>
<li>将光标从当前位置向下移动一行。</li>
<li><strong>返回一个布尔值</strong>：如果光标成功移动到了一个有效的数据行，返回 <code>true</code>；如果当前已经是最后一行，再次移动将越过末尾，此时返回 <code>false</code>。</li>
</ol>
</li>
<li><p><strong>典型用法</strong>: 与 <code>while</code> 循环结合，构成标准的 <code>ResultSet</code> 遍历模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    <span class="comment">// 在这里处理当前行的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种结构优雅地处理了从 0 行到 N 行的所有情况，当没有查询结果时，第一次调用 <code>rs.next()</code> 就会返回 <code>false</code>，循环体根本不会执行。</p>
</li>
</ul>
<hr>
<h4 id="4-2-2-获取数据-getXXX"><a href="#4-2-2-获取数据-getXXX" class="headerlink" title="4.2.2 获取数据 (getXXX)"></a>4.2.2 获取数据 (getXXX)</h4><p>当光标指向一个有效行时，你可以使用 <code>getXXX()</code> 系列方法来提取该行中特定列的值。<code>XXX</code> 代表 Java 的数据类型。</p>
<p>有两种方式来指定列：</p>
<ol>
<li><p><strong>通过列名 (Column Name) - 推荐</strong></p>
<ul>
<li><p><strong>方法</strong>: <code>getXXX(&quot;column_name&quot;)</code></p>
</li>
<li><p><strong>优点</strong>: 代码可读性强，不依赖于 <code>SELECT</code> 语句中列的顺序。即使你改变了查询列的顺序（例如 <code>SELECT name, id FROM users</code>），代码依然能正常工作。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">createTime</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;created_at&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;price&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>通过列索引 (Column Index)</strong></p>
<ul>
<li><p><strong>方法</strong>: <code>getXXX(int columnIndex)</code></p>
</li>
<li><p><strong>注意</strong>: <strong>列索引从 1 开始，而不是 0！</strong></p>
</li>
<li><p><strong>优点</strong>: 性能可能略高于使用列名，因为它省去了查找列名对应索引的步骤。</p>
</li>
<li><p><strong>缺点</strong>: 代码可读性差，且与 <code>SELECT</code> 语句的列顺序紧密耦合。一旦 <code>SELECT</code> 语句的列顺序发生变化，代码就必须随之修改，否则会取错数据，非常容易出错。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 SQL 是 SELECT id, name, created_at, price FROM ...</span></span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>); <span class="comment">// 第 1 列是 id</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>); <span class="comment">// 第 2 列是 name</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">createTime</span> <span class="operator">=</span> rs.getDate(<span class="number">3</span>); <span class="comment">// 第 3 列是 created_at</span></span><br><span class="line"><span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> rs.getDouble(<span class="number">4</span>); <span class="comment">// 第 4 列是 price</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>最佳实践</strong>: 除非是在对性能有极致要求的场景，否则<strong>始终推荐使用列名</strong>来获取数据，以提高代码的可读性和可维护性。</p>
<hr>
<h4 id="4-2-3-资源管理"><a href="#4-2-3-资源管理" class="headerlink" title="4.2.3 资源管理"></a>4.2.3 资源管理</h4><p><strong><code>void close()</code></strong></p>
<ul>
<li>与 <code>Connection</code> 和 <code>Statement</code> 一样，<code>ResultSet</code> 也必须在使用完毕后显式关闭。</li>
<li>它会释放与该结果集相关的数据库资源（如服务器端的游标）。</li>
<li><strong>必须在 <code>finally</code> 块或 <code>try-with-resources</code> 语句中关闭</strong>。</li>
<li><strong>关闭顺序</strong>: 遵循“后开先关”原则，<code>ResultSet</code> 应在 <code>Statement</code> 和 <code>Connection</code> 之前关闭。<code>try-with-resources</code> 会自动处理好这个顺序。</li>
</ul>
<hr>
<h3 id="4-3-ResultSet-的类型与并发性-高级特性"><a href="#4-3-ResultSet-的类型与并发性-高级特性" class="headerlink" title="4.3 ResultSet 的类型与并发性 (高级特性)"></a>4.3 ResultSet 的类型与并发性 (高级特性)</h3><p>默认情况下，我们创建的 <code>ResultSet</code> 是<strong>只读、只能向前移动</strong>的。但在创建 <code>Statement</code> 或 <code>PreparedStatement</code> 时，我们可以指定 <code>ResultSet</code> 的类型和并发性，以获得更强大的功能。</p>
<p><code>connection.createStatement(int resultSetType, int resultSetConcurrency);</code></p>
<p><code>connection.prepareStatement(String sql, int resultSetType, int resultSetConcurrency);</code></p>
<h4 id="4-3-1-resultSetType-滚动性"><a href="#4-3-1-resultSetType-滚动性" class="headerlink" title="4.3.1 resultSetType (滚动性)"></a>4.3.1 <code>resultSetType</code> (滚动性)</h4><ol>
<li><strong><code>ResultSet.TYPE_FORWARD_ONLY</code> (默认)</strong><ul>
<li>光标只能向前移动（通过 <code>next()</code>）。不能后退，也不能跳到指定行。</li>
<li>这是最轻量、性能最好的类型，适用于绝大多数简单的遍历场景。</li>
</ul>
</li>
<li><strong><code>ResultSet.TYPE_SCROLL_INSENSITIVE</code></strong><ul>
<li><strong>可滚动</strong>: 光标可以自由地向前、向后、跳到第一行、最后一行或任意指定行。<ul>
<li><code>previous()</code>: 向上移动一行。</li>
<li><code>first()</code>: 移动到第一行。</li>
<li><code>last()</code>: 移动到最后一行。</li>
<li><code>absolute(int row)</code>: 移动到指定行号。</li>
</ul>
</li>
<li><strong>不敏感 (Insensitive)</strong>: 结果集是创建时数据库数据的一个<strong>快照</strong>。在 <code>ResultSet</code> 打开期间，其他事务所做的对底层数据的修改（增、删、改）<strong>不会</strong>反映在这个 <code>ResultSet</code> 中。</li>
</ul>
</li>
<li><strong><code>ResultSet.TYPE_SCROLL_SENSITIVE</code></strong><ul>
<li><strong>可滚动</strong>: 与上面一样，光标可以自由移动。</li>
<li><strong>敏感 (Sensitive)</strong>: 结果集是动态的，能够<strong>反映</strong>出在 <code>ResultSet</code> 打开期间，其他事务对底层数据的修改。</li>
<li><strong>注意</strong>: 这是一个非常消耗资源的功能，并且不是所有数据库驱动都支持。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-3-2-resultSetConcurrency-并发性-可更新性"><a href="#4-3-2-resultSetConcurrency-并发性-可更新性" class="headerlink" title="4.3.2 resultSetConcurrency (并发性&#x2F;可更新性)"></a>4.3.2 <code>resultSetConcurrency</code> (并发性&#x2F;可更新性)</h4><ol>
<li><strong><code>ResultSet.CONCUR_READ_ONLY</code> (默认)</strong><ul>
<li>结果集是只读的，你不能通过 <code>ResultSet</code> 对象来修改数据库中的数据。</li>
</ul>
</li>
<li><strong><code>ResultSet.CONCUR_UPDATABLE</code></strong><ul>
<li>结果集是可更新的。你可以通过 <code>updateXXX()</code> 和 <code>updateRow()</code> &#x2F; <code>insertRow()</code> &#x2F; <code>deleteRow()</code> 方法来直接修改、插入或删除数据库中的行。</li>
</ul>
</li>
</ol>
<p><strong>可更新结果集示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个可滚动、可更新的 PreparedStatement</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name FROM users WHERE id = ?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql,</span><br><span class="line">                                               ResultSet.TYPE_SCROLL_INSENSITIVE,</span><br><span class="line">                                               ResultSet.CONCUR_UPDATABLE);</span><br><span class="line">pstmt.setInt(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">    <span class="comment">// 更新当前行的数据</span></span><br><span class="line">    rs.updateString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;New Name&quot;</span>); <span class="comment">// 在内存中更新</span></span><br><span class="line">    rs.updateRow(); <span class="comment">// 将内存中的更新提交到数据库</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Row updated.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>: 可滚动和可更新的 <code>ResultSet</code> 提供了强大的功能，尤其是在某些 GUI 桌面应用或需要“即见即改”的场景中。但在典型的 Web 应用中，由于其对数据库资源的消耗较大且与业务逻辑耦合紧密，<strong>使用频率较低</strong>。大多数情况下，我们仍然坚持使用默认的 <code>TYPE_FORWARD_ONLY</code> 和 <code>CONCUR_READ_ONLY</code> 类型，并通过标准的 <code>UPDATE</code> 语句来修改数据。</p>
<hr>
<h3 id="4-4-处理-NULL-值"><a href="#4-4-处理-NULL-值" class="headerlink" title="4.4 处理 NULL 值"></a>4.4 处理 <code>NULL</code> 值</h3><p>当数据库中的列值为 <code>NULL</code> 时，<code>getXXX()</code> 方法的行为需要注意：</p>
<ul>
<li>对于返回对象的 <code>getXXX()</code> 方法（如 <code>getString()</code>, <code>getDate()</code>），它们会直接返回 <code>null</code>。</li>
<li>对于返回基本数据类型的 <code>getXXX()</code> 方法（如 <code>getInt()</code>, <code>getDouble()</code>），它们会返回该类型的默认值（<code>0</code>, <code>0.0</code>）。</li>
</ul>
<p>这会带来一个问题：如果 <code>getInt()</code> 返回 <code>0</code>，你无法区分是数据库里真的存的是 <code>0</code>，还是存的是 <code>NULL</code>。</p>
<p>为了解决这个问题，<code>ResultSet</code> 提供了 <code>wasNull()</code> 方法。</p>
<p><strong><code>boolean wasNull()</code></strong></p>
<ul>
<li><strong>用途</strong>: 检查<strong>最后一次</strong>调用的 <code>getXXX()</code> 方法所读取的值是否为 SQL <code>NULL</code>。</li>
<li><strong>用法</strong>: 必须在调用 <code>getXXX()</code> 之后<strong>立即</strong>调用。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;score&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">    <span class="comment">// 数据库中是 NULL</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Score is not available.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库中是 0 或其他整数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Score is: &quot;</span> + score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-MetaData-API"><a href="#5-MetaData-API" class="headerlink" title="5. MetaData API"></a>5. MetaData API</h2><h3 id="5-1-ResultSetMetaData"><a href="#5-1-ResultSetMetaData" class="headerlink" title="5.1 ResultSetMetaData"></a>5.1 <code>ResultSetMetaData</code></h3><p><code>ResultSetMetaData</code> 专注于描述一个<strong>特定查询结果</strong>的结构。当你执行一个查询，但事先不知道（或者不想硬编码）查询结果的列信息时，这个 API 就非常有用了。</p>
<ul>
<li><p><strong>如何获取</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT id, name, email FROM users&quot;</span>);</span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>核心应用场景</strong>:</p>
<ul>
<li><strong>编写通用的数据导出工具</strong>: 可以动态地生成 CSV 或 Excel 的表头。</li>
<li><strong>动态 ORM (对象关系映射)</strong>: 自动将 <code>ResultSet</code> 的一行数据映射到一个 <code>JavaBean</code> 或 <code>Map</code> 对象，而无需硬编码列名。</li>
<li><strong>通用数据显示组件</strong>: 在 GUI 或网页上动态地创建一个表格来显示任何查询的结果。</li>
</ul>
</li>
<li><p><strong>关键方法详解</strong>:</p>
<ol>
<li><p><strong><code>int getColumnCount()</code></strong></p>
<ul>
<li><p>返回结果集中的<strong>列数</strong>。这是最常用的方法，通常用于循环遍历所有列。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">    <span class="comment">// ... process column i ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>String getColumnName(int column)</code></strong></p>
<ul>
<li>获取指定列的<strong>原始列名</strong>（在数据库中定义的名称）。</li>
<li><strong>参数</strong>: 列索引，<strong>从 1 开始</strong>。</li>
</ul>
</li>
<li><p><strong><code>String getColumnLabel(int column)</code></strong></p>
<ul>
<li>获取指定列的<strong>显示标签</strong>。在大多数情况下，它和 <code>getColumnName()</code> 返回值相同。</li>
<li>但如果你的 SQL 查询中使用了<strong>别名 (alias)</strong>，如 <code>SELECT user_name AS userName FROM users</code>，那么 <code>getColumnName()</code> 返回 <code>user_name</code>，而 <code>getColumnLabel()</code> 返回 <code>userName</code>。<strong>因此，在显示或映射时，使用 <code>getColumnLabel()</code> 通常是更安全的选择。</strong></li>
</ul>
</li>
<li><p><strong><code>int getColumnType(int column)</code></strong></p>
<ul>
<li>以一个整数代码的形式，返回指定列的 <strong>SQL 数据类型</strong>。</li>
<li>这些整数代码定义在 <code>java.sql.Types</code> 类中（例如, <code>Types.INTEGER</code>, <code>Types.VARCHAR</code>, <code>Types.TIMESTAMP</code>）。你可以用它来判断如何处理该列的数据。</li>
</ul>
</li>
<li><p><strong><code>String getColumnTypeName(int column)</code></strong></p>
<ul>
<li>以字符串形式返回指定列在数据库中的<strong>具体类型名称</strong>，例如 “VARCHAR”, “INT”, “DATETIME”。</li>
</ul>
</li>
<li><p><strong><code>int getPrecision(int column)</code></strong></p>
<ul>
<li>对于数字类型，返回其<strong>精度</strong>（总位数）。</li>
<li>对于字符类型，返回其<strong>最大长度</strong>。</li>
</ul>
</li>
<li><p><strong><code>int getScale(int column)</code></strong></p>
<ul>
<li>对于数字类型（如 <code>DECIMAL</code>），返回其<strong>小数位数</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>实战示例：将 <code>ResultSet</code> 动态转换为 <code>List&lt;Map&gt;</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">convertResultSetToList</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">ResultSetMetaData</span> <span class="variable">md</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">    <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> md.getColumnCount();</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; rowData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用 getColumnLabel() 更具稳健性</span></span><br><span class="line">            <span class="comment">// 使用 getObject() 可以自动处理大多数数据类型</span></span><br><span class="line">            rowData.put(md.getColumnLabel(i), rs.getObject(i));</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(rowData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是许多轻量级 JDBC 框架（如 Apache DbUtils）的核心思想。</p>
</li>
</ul>
<hr>
<h3 id="5-2-DatabaseMetaData"><a href="#5-2-DatabaseMetaData" class="headerlink" title="5.2 DatabaseMetaData"></a>5.2 <code>DatabaseMetaData</code></h3><p><code>DatabaseMetaData</code> 提供了关于整个数据库的极其丰富的信息。它是一个庞大的接口，拥有超过 150 个方法。</p>
<ul>
<li><p><strong>如何获取</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> conn.getMetaData();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>核心应用场景</strong>:</p>
<ul>
<li><strong>数据库管理工具</strong>: 类似 Navicat, DBeaver 这样的工具，需要用它来列出所有的数据库、表、视图、索引等。</li>
<li><strong>代码生成器</strong>: 可以读取表结构信息，自动生成对应的 JavaBean 实体类、DAO 代码等。</li>
<li><strong>数据库迁移工具</strong>: 需要用它来获取源数据库的完整结构，以便在目标数据库中重建。</li>
<li><strong>跨数据库兼容性框架</strong>: 判断当前连接的数据库是否支持某个特定的 SQL 特性或语法。</li>
</ul>
</li>
<li><p><strong>关键方法详解 (按功能分类)</strong>:</p>
<p><strong>1. 获取数据库基本信息</strong></p>
<ul>
<li><code>String getDatabaseProductName()</code>: 返回数据库产品名，如 “MySQL”。</li>
<li><code>String getDatabaseProductVersion()</code>: 返回数据库版本号，如 “8.0.33”。</li>
<li><code>String getDriverName()</code>: 返回 JDBC 驱动名。</li>
<li><code>String getURL()</code>: 返回用于创建连接的 URL。</li>
<li><code>String getUserName()</code>: 返回当前连接的用户名。</li>
</ul>
<p><strong>2. 获取数据库对象 (表、列、主键等)</strong><br>这些方法通常返回一个 <code>ResultSet</code>，你需要遍历这个结果集来获取信息。它们支持使用通配符 <code>%</code> (匹配任意多个字符) 和 <code>_</code> (匹配单个字符)。</p>
<ul>
<li><strong><code>ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String[] types)</code></strong><ul>
<li>获取数据库中的表信息。</li>
<li><code>catalog</code>: 目录名，对于 MySQL 来说就是数据库名。可以为 <code>null</code>。</li>
<li><code>schemaPattern</code>: 模式名，可以为 <code>null</code>。</li>
<li><code>tableNamePattern</code>: 表名模式，例如 <code>user_%</code> 会匹配所有以 <code>user_</code> 开头的表。<code>null</code> 或 <code>%</code> 表示所有表。</li>
<li><code>types</code>: 一个字符串数组，指定要获取的对象类型，如 <code>{&quot;TABLE&quot;, &quot;VIEW&quot;}</code>。</li>
</ul>
</li>
<li><strong><code>ResultSet getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern)</code></strong><ul>
<li>获取表的列信息。</li>
</ul>
</li>
<li><strong><code>ResultSet getPrimaryKeys(String catalog, String schema, String table)</code></strong><ul>
<li>获取指定表的主键信息。</li>
</ul>
</li>
<li><code>ResultSet getImportedKeys(...)</code>: 获取外键信息。</li>
<li><code>ResultSet getIndexInfo(...)</code>: 获取索引信息。</li>
</ul>
</li>
<li><p><strong>实战示例：列出指定数据库中的所有表名</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listAllTables</span><span class="params">(Connection conn, String dbName)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line">    <span class="comment">// 第一个参数是 catalog (数据库名), 第三个是表名模式 (null表示所有)</span></span><br><span class="line">    <span class="comment">// 第四个参数是类型 (&quot;TABLE&quot;表示只查找表)</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> dbmd.getTables(dbName, <span class="literal">null</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;TABLE&quot;</span>&#125;)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tables in database &#x27;&quot;</span> + dbName + <span class="string">&quot;&#x27;:&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="comment">// 从返回的 ResultSet 中获取表名，表名在名为 &quot;TABLE_NAME&quot; 的列中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;TABLE_NAME&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;- &quot;</span> + tableName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 获取数据库能力与限制</strong></p>
<ul>
<li><code>boolean supportsTransactions()</code>: 是否支持事务。</li>
<li><code>boolean supportsBatchUpdates()</code>: 是否支持批量更新。</li>
<li><code>int getMaxConnections()</code>: 最大并发连接数。</li>
<li><code>String getSQLKeywords()</code>: 返回数据库保留的 SQL 关键字列表。</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="三、数据库操作实战（CRUD-Batch）"><a href="#三、数据库操作实战（CRUD-Batch）" class="headerlink" title="三、数据库操作实战（CRUD &amp; Batch）"></a>三、数据库操作实战（CRUD &amp; Batch）</h1><h2 id="1-查询操作"><a href="#1-查询操作" class="headerlink" title="1. 查询操作"></a>1. 查询操作</h2><h3 id="1-1-核心步骤"><a href="#1-1-核心步骤" class="headerlink" title="1.1 核心步骤"></a>1.1 核心步骤</h3><p>一个完整的查询操作通常遵循以下七个步骤：</p>
<ol>
<li><strong>获取连接</strong>: 从 <code>DriverManager</code> 或 <code>DataSource</code> 获取 <code>Connection</code> 对象。</li>
<li><strong>准备 SQL</strong>: 定义一个包含 <code>SELECT</code> 语句的字符串，使用 <code>?</code>作为参数占位符。</li>
<li><strong>创建 PreparedStatement</strong>: 调用 <code>connection.prepareStatement(sql)</code> 创建预编译的执行器。</li>
<li><strong>设置参数</strong>: 如果 SQL 中有 <code>?</code> 占位符，使用 <code>pstmt.setXXX()</code> 方法为其绑定具体值。</li>
<li><strong>执行查询</strong>: 调用 <code>pstmt.executeQuery()</code> 方法。<strong>该方法专门用于 <code>SELECT</code> 语句，并返回一个 <code>ResultSet</code> 对象。</strong></li>
<li><strong>处理结果集</strong>: 遍历 <code>ResultSet</code>，提取所需的数据。</li>
<li><strong>关闭资源</strong>: 使用 <code>try-with-resources</code> 语句自动关闭 <code>Connection</code>, <code>PreparedStatement</code>, 和 <code>ResultSet</code>。</li>
</ol>
<hr>
<h3 id="1-2-实战代码示例"><a href="#1-2-实战代码示例" class="headerlink" title="1.2 实战代码示例"></a>1.2 实战代码示例</h3><p>假设我们有如下的 <code>users</code> 表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    registration_date <span class="type">DATE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="1-2-1-查询单个记录-按-ID-查询"><a href="#1-2-1-查询单个记录-按-ID-查询" class="headerlink" title="1.2.1 查询单个记录 (按 ID 查询)"></a>1.2.1 查询单个记录 (按 ID 查询)</h4><p>这是最常见的查询场景之一，例如根据主键查找一个特定的用户。我们预期最多只有一条结果，因此使用 <code>if (rs.next())</code> 来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email, registration_date FROM users WHERE id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 try-with-resources 自动管理资源</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection(); <span class="comment">// 假设有一个获取连接的工具类</span></span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 设置参数 (将第一个 ? 设置为 userId)</span></span><br><span class="line">        pstmt.setInt(<span class="number">1</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 执行查询</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">            <span class="comment">// 6. 处理结果集</span></span><br><span class="line">            <span class="comment">// 因为是按主键查询，结果最多只有一条，所以用 if</span></span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">                java.sql.<span class="type">Date</span> <span class="variable">regDate</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;registration_date&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;User Found:&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;ID: &quot;</span> + id);</span><br><span class="line">                System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">                System.out.println(<span class="string">&quot;Email: &quot;</span> + email);</span><br><span class="line">                System.out.println(<span class="string">&quot;Registration Date: &quot;</span> + regDate);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;No user found with ID: &quot;</span> + userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-2-查询多个记录-查询所有用户"><a href="#1-2-2-查询多个记录-查询所有用户" class="headerlink" title="1.2.2 查询多个记录 (查询所有用户)"></a>1.2.2 查询多个记录 (查询所有用户)</h4><p>当查询可能返回多条记录时，我们需要使用 <code>while (rs.next())</code> 循环来遍历整个结果集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email FROM users ORDER BY name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">         <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123; <span class="comment">// 对于无参数查询，可以直接执行</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;All Users:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 6. 遍历结果集</span></span><br><span class="line">        <span class="comment">// 当可能有多条结果时，使用 while 循环</span></span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;ID: %-5d | Name: %-15s | Email: %s\n&quot;</span>, id, name, email);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-3-将查询结果映射为-Java-对象-ORM-基础"><a href="#1-2-3-将查询结果映射为-Java-对象-ORM-基础" class="headerlink" title="1.2.3 将查询结果映射为 Java 对象 (ORM 基础)"></a>1.2.3 将查询结果映射为 Java 对象 (ORM 基础)</h4><p>在实际开发中，我们很少直接打印数据。更常见的做法是将 <code>ResultSet</code> 中的数据行转换为一个 Java 对象（POJO 或 JavaBean）。这是 ORM (对象关系映射) 思想的基础。</p>
<p>首先，定义一个 <code>User</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// Getters, Setters, Constructor, toString()...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，修改查询方法，使其返回一个 <code>User</code> 对象的列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAllUsersAsObjects</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email FROM users&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">         <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="comment">// 创建一个新的 User 对象来存储当前行的数据</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            user.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将填充好的对象添加到列表中</span></span><br><span class="line">            userList.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userList; <span class="comment">// 返回包含所有用户对象的列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-最佳实践"><a href="#1-3-最佳实践" class="headerlink" title="1.3 最佳实践"></a>1.3 最佳实践</h3><ol>
<li><strong>始终使用 <code>try-with-resources</code></strong>：<br>这是管理 JDBC 资源的最佳方式。它能确保 <code>Connection</code>, <code>PreparedStatement</code>, <code>ResultSet</code> 在代码块结束时被自动、正确地关闭，即使发生异常也能保证，从而彻底避免资源泄露。</li>
<li><strong><code>PreparedStatement</code> 优先</strong>：<br>即使查询没有参数，也推荐使用 <code>PreparedStatement</code>。它不仅能防止 SQL 注入，还能在多次执行相同结构的 SQL 时提供性能优势。</li>
<li><strong>理解 <code>executeQuery()</code> 的返回值</strong>：<br><code>executeQuery()</code> <strong>永远不会返回 <code>null</code></strong>。如果查询没有找到任何匹配的记录，它会返回一个<strong>空的 <code>ResultSet</code> 对象</strong>。你可以通过 <code>rs.next()</code> 的返回值来判断是否有数据。</li>
<li><strong><code>if (rs.next())</code> vs <code>while (rs.next())</code></strong>：<ul>
<li>当你预期查询结果最多只有 <strong>一条</strong> (如按唯一键查询) 时，使用 <code>if</code>。</li>
<li>当你预期查询结果可能有 <strong>多条</strong> 时，使用 <code>while</code> 循环。</li>
</ul>
</li>
<li><strong>使用列名获取数据</strong>：<br>强烈推荐使用 <code>rs.getString(&quot;column_name&quot;)</code> 而不是 <code>rs.getString(1)</code>。使用列名使得代码更具可读性，并且不受 <code>SELECT</code> 语句中列顺序变化的影响。</li>
<li><strong>及时将数据转换为领域对象</strong>：<br>不要让 <code>ResultSet</code> 对象在你的应用程序中传递太远。最佳实践是在数据访问层（DAO）中立即将其转换为业务领域对象（如 <code>User</code> 对象），这样可以使业务逻辑代码与 JDBC API 解耦。</li>
</ol>
<hr>
<h2 id="2-增删改操作"><a href="#2-增删改操作" class="headerlink" title="2. 增删改操作"></a>2. 增删改操作</h2><h3 id="2-1-核心方法：int-executeUpdate"><a href="#2-1-核心方法：int-executeUpdate" class="headerlink" title="2.1 核心方法：int executeUpdate()"></a>2.1 核心方法：<code>int executeUpdate()</code></h3><p><code>executeUpdate()</code> 是执行 DML (Data Manipulation Language) 和 DDL (Data Definition Language) 语句的核心方法。</p>
<ul>
<li><strong>用途</strong>: 用于执行 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 语句，也可以执行 <code>CREATE TABLE</code>, <code>DROP TABLE</code> 等。</li>
<li><strong>返回值 (<code>int</code>)</strong>: 该方法返回一个整数，表示<strong>受此 SQL 语句影响的数据库行数</strong>。<ul>
<li>对于 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>，返回值是实际被插入、更新或删除的行数。</li>
<li>对于 DDL 语句，返回值通常是 <code>0</code>。</li>
</ul>
</li>
<li><strong>返回值的重要性</strong>: 检查 <code>executeUpdate()</code> 的返回值是<strong>非常重要的</strong>。它可以帮助你判断操作是否真正成功。例如，如果你期望更新一行数据，但返回值是 <code>0</code>，这通常意味着 <code>WHERE</code> 子句没有匹配到任何记录。</li>
</ul>
<hr>
<h3 id="2-2-插入操作-INSERT"><a href="#2-2-插入操作-INSERT" class="headerlink" title="2.2 插入操作 (INSERT)"></a>2.2 插入操作 (INSERT)</h3><p>插入操作用于向数据库表中添加新的记录。</p>
<p><strong>示例：向 <code>users</code> 表中添加一个新用户</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String name, String email, java.sql.Date registrationDate)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO users (name, email, registration_date) VALUES (?, ?, ?)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置参数</span></span><br><span class="line">        pstmt.setString(<span class="number">1</span>, name);</span><br><span class="line">        pstmt.setString(<span class="number">2</span>, email);</span><br><span class="line">        pstmt.setDate(<span class="number">3</span>, registrationDate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行插入操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查返回值</span></span><br><span class="line">        <span class="keyword">if</span> (affectedRows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User inserted successfully!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User insertion failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// 比如，email 字段有 UNIQUE 约束，插入重复 email 会抛出异常</span></span><br><span class="line">        System.err.println(<span class="string">&quot;Error inserting user: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>高级技巧：获取自增主键 (Auto-Generated Keys)</strong></p>
<p>在许多场景下，当我们插入一条新记录后，需要立即知道数据库为它生成的自增主键 。JDBC 提供了标准的方式来获取这个值。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>在调用 <code>connection.prepareStatement()</code> 时，传入第二个参数 <code>Statement.RETURN_GENERATED_KEYS</code>。</li>
<li>正常执行 <code>executeUpdate()</code>。</li>
<li>执行后，通过 <code>pstmt.getGeneratedKeys()</code> 方法获取一个包含生成键的 <code>ResultSet</code>。</li>
<li>遍历这个 <code>ResultSet</code> 来提取键值。</li>
</ol>
<p><strong>示例：插入用户并获取其新生成的 ID</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">addUserAndGetId</span><span class="params">(String name, String email)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">newUserId</span> <span class="operator">=</span> -<span class="number">1L</span>; <span class="comment">// 默认为-1，表示失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="comment">// 1. 告知 PreparedStatement 需要返回生成的主键</span></span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) &#123;</span><br><span class="line"></span><br><span class="line">        pstmt.setString(<span class="number">1</span>, name);</span><br><span class="line">        pstmt.setString(<span class="number">2</span>, email);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (affectedRows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 获取包含主键的 ResultSet</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">generatedKeys</span> <span class="operator">=</span> pstmt.getGeneratedKeys()) &#123;</span><br><span class="line">                <span class="comment">// 3. 移动到第一行并获取主键值</span></span><br><span class="line">                <span class="keyword">if</span> (generatedKeys.next()) &#123;</span><br><span class="line">                    newUserId = generatedKeys.getLong(<span class="number">1</span>); <span class="comment">// 通常主键在第一列</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;User inserted successfully with ID: &quot;</span> + newUserId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newUserId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-更新操作-UPDATE"><a href="#2-3-更新操作-UPDATE" class="headerlink" title="2.3 更新操作 (UPDATE)"></a>2.3 更新操作 (UPDATE)</h3><p>更新操作用于修改表中已存在的记录。</p>
<p><strong>关键点</strong>: <code>UPDATE</code> 语句<strong>必须</strong>带上 <code>WHERE</code> 子句，否则将会更新表中的所有行，这通常是灾难性的。</p>
<p><strong>示例：根据用户 ID 更新其 email 地址</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateUserEmail</span><span class="params">(<span class="type">int</span> userId, String newEmail)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE users SET email = ? WHERE id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        pstmt.setString(<span class="number">1</span>, newEmail);</span><br><span class="line">        pstmt.setInt(<span class="number">2</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 affectedRows == 1，表示成功更新了一行</span></span><br><span class="line">        <span class="comment">// 如果 affectedRows == 0，表示没有找到 ID 匹配的用户</span></span><br><span class="line">        <span class="keyword">if</span> (affectedRows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User email updated successfully for ID: &quot;</span> + userId);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No user found with ID: &quot;</span> + userId + <span class="string">&quot;. Nothing updated.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-删除操作-DELETE"><a href="#2-4-删除操作-DELETE" class="headerlink" title="2.4 删除操作 (DELETE)"></a>2.4 删除操作 (DELETE)</h3><p>删除操作用于从表中移除记录。</p>
<p><strong>关键点</strong>: 与 <code>UPDATE</code> 一样，<code>DELETE</code> 语句<strong>必须</strong>带上 <code>WHERE</code> 子句，否则会清空整个表！</p>
<p><strong>示例：根据用户 ID 删除用户</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUser</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DELETE FROM users WHERE id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        pstmt.setInt(<span class="number">1</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (affectedRows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User with ID: &quot;</span> + userId + <span class="string">&quot; was deleted successfully.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No user found with ID: &quot;</span> + userId + <span class="string">&quot;. Nothing deleted.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-最佳实践"><a href="#2-5-最佳实践" class="headerlink" title="2.5 最佳实践"></a>2.5 最佳实践</h3><ol>
<li><strong>统一使用 <code>executeUpdate()</code></strong>：这是执行所有数据修改操作的标准方法。</li>
<li><strong><code>PreparedStatement</code> 是必须的</strong>：防止 SQL 注入，提高性能和代码可读性。</li>
<li><strong>总是检查 <code>affectedRows</code></strong>：不要假设你的操作一定成功。通过检查返回值，可以为你的应用程序增加更健壮的逻辑判断（例如，向用户反馈“更新失败，记录不存在”）。</li>
<li><strong><code>WHERE</code> 子句，再三确认</strong>：在编写 <code>UPDATE</code> 和 <code>DELETE</code> 语句时，<code>WHERE</code> 子句是你的安全带。在执行前务必确认其逻辑是正确的。</li>
<li><strong>资源管理</strong>：始终使用 <code>try-with-resources</code> 来确保 <code>Connection</code> 和 <code>PreparedStatement</code> 被正确关闭。</li>
<li><strong>封装到 DAO 方法中</strong>：将这些数据库操作逻辑封装在数据访问对象（DAO）的方法中（如 <code>userDao.addUser()</code>, <code>userDao.updateUser()</code>），使业务逻辑层代码更清晰。</li>
</ol>
<hr>
<h2 id="3-批量操作"><a href="#3-批量操作" class="headerlink" title="3. 批量操作"></a>3. 批量操作</h2><h3 id="3-1-核心方法"><a href="#3-1-核心方法" class="headerlink" title="3.1 核心方法"></a>3.1 核心方法</h3><p><strong>批量操作的核心思想</strong>：将多条 SQL 语句“打包”在一起，通过一次网络通信发送给数据库，由数据库一次性执行完毕。主要通过 <code>Statement</code> 或 <code>PreparedStatement</code> 接口的三个方法实现：</p>
<ol>
<li><strong><code>void addBatch()</code></strong><ul>
<li><strong>作用</strong>: 将当前已设置好参数的 <code>PreparedStatement</code>（或 <code>Statement</code> 的 SQL）添加到当前的“批处理”列表中。它不清空参数，只是将当前状态“暂存”起来，等待执行。</li>
</ul>
</li>
<li><strong><code>int[] executeBatch()</code></strong><ul>
<li><strong>作用</strong>: 将 <code>addBatch()</code> 添加的所有 SQL 语句一次性发送到数据库执行。</li>
<li><strong>返回值 (<code>int[]</code>)</strong>: 返回一个整数数组。数组中的<strong>每个元素对应一批中一条 SQL 语句的执行结果</strong>。<ul>
<li>对于 <code>INSERT/UPDATE/DELETE</code>，该元素的值是该语句影响的行数。</li>
<li>如果某条语句执行成功但无法确定影响的行数，驱动程序可能返回 <code>Statement.SUCCESS_NO_INFO</code> (-2)。</li>
<li>如果某条语句执行失败，驱动程序可能返回 <code>Statement.EXECUTE_FAILED</code> (-3) 或直接抛出 <code>BatchUpdateException</code>。</li>
</ul>
</li>
<li><strong>注意</strong>: 数组的长度等于你调用 <code>addBatch()</code> 的次数。</li>
</ul>
</li>
<li><strong><code>void clearBatch()</code></strong><ul>
<li><strong>作用</strong>: 清空当前批处理列表中的所有 SQL 语句。如果你在执行前想取消这批操作，可以调用此方法。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-2-实战示例"><a href="#3-2-实战示例" class="headerlink" title="3.2 实战示例"></a>3.2 实战示例</h3><p><strong>示例：批量插入多个用户记录</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUsersInBatch</span><span class="params">(List&lt;User&gt; userList)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历用户列表</span></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            <span class="comment">// 1. 设置参数</span></span><br><span class="line">            pstmt.setString(<span class="number">1</span>, user.getName());</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, user.getEmail());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 添加到批处理</span></span><br><span class="line">            pstmt.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行批处理</span></span><br><span class="line">        <span class="type">int</span>[] updateCounts = pstmt.executeBatch();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. (可选) 检查执行结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Batch execution completed.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Total statements in batch: &quot;</span> + updateCounts.length);</span><br><span class="line">        <span class="comment">// 可以遍历 updateCounts 数组来检查每一条语句的执行情况</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-最佳实践"><a href="#3-3-最佳实践" class="headerlink" title="3.3 最佳实践"></a>3.3 最佳实践</h3><ol>
<li><p><strong>分批提交 (Batch Sizing)</strong>:<br>一次性向上百万条数据 <code>addBatch()</code> 可能会导致客户端内存溢出。明智的做法是设定一个合理的批次大小（例如每 1000 条执行一次），分批提交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (User user : largeUserList) &#123;</span><br><span class="line">    pstmt.setString(<span class="number">1</span>, user.getName());</span><br><span class="line">    pstmt.addBatch();</span><br><span class="line">    <span class="keyword">if</span> (++count % BATCH_SIZE == <span class="number">0</span>) &#123;</span><br><span class="line">        pstmt.executeBatch(); <span class="comment">// 执行批处理</span></span><br><span class="line">        <span class="comment">// pstmt.clearBatch(); // 某些驱动需要手动清空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pstmt.executeBatch(); <span class="comment">// 执行最后一批不足 BATCH_SIZE 的数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MySQL 驱动的特定优化</strong>:<br>对于 MySQL，为了获得最佳的批量插入性能，需要在数据库连接 URL 中添加一个关键参数 <code>rewriteBatchedStatements=true</code>。<br><code>jdbc:mysql://localhost:3306/my_db?rewriteBatchedStatements=true</code><br>这个参数会告诉驱动将多个 <code>INSERT</code> 语句重写为一条多值插入语句 (<code>INSERT INTO ... VALUES (...), (...), ...</code>)，性能提升非常巨大。</p>
</li>
<li><p><strong>关闭自动提交</strong>:<br>执行批量操作前先 <code>conn.setAutoCommit(false)</code>，不仅是为了事务的原子性，在某些数据库和驱动中，这也能带来性能提升，因为它减少了每次操作都要写事务日志的开销。</p>
</li>
</ol>
<hr>
<h2 id="4-事务处理（Transaction）"><a href="#4-事务处理（Transaction）" class="headerlink" title="4. 事务处理（Transaction）"></a>4. 事务处理（Transaction）</h2><h3 id="4-1-事务的开关"><a href="#4-1-事务的开关" class="headerlink" title="4.1 事务的开关"></a>4.1 事务的开关</h3><p><code>setAutoCommit</code> 是 <code>Connection</code> 对象的一个方法，它控制着连接的提交模式。这是 JDBC 事务管理的<strong>核心开关</strong>。</p>
<ul>
<li><strong><code>connection.setAutoCommit(true)</code> (默认模式)</strong><ul>
<li><strong>含义</strong>: 自动提交模式。</li>
<li><strong>行为</strong>: 在这种模式下，<strong>每一条单独的 SQL 语句都被视为一个独立的事务</strong>，并且在执行完毕后会<strong>立即自动提交</strong>到数据库。</li>
<li><strong>优点</strong>: 简单，无需手动管理。对于那些独立的、不需要与其他操作绑定的单条 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 语句来说非常方便。</li>
<li><strong>缺点</strong>: 无法将多个 SQL 语句组合成一个逻辑单元。例如，在银行转账案例中，如果使用自动提交，扣款操作一旦成功就会立刻生效，即使后续的存款操作失败，也无法撤销扣款。</li>
</ul>
</li>
<li><strong><code>connection.setAutoCommit(false)</code> (手动事务模式)</strong><ul>
<li><strong>含义</strong>: 关闭自动提交，开启手动事务管理。</li>
<li><strong>行为</strong>: 当你调用此方法后，JDBC 不会再自动提交任何 SQL 语句。从这个调用点开始，直到你显式调用 <code>commit()</code> 或 <code>rollback()</code> 方法之前，所有执行的 SQL 语句都属于<strong>同一个事务</strong>。</li>
<li><strong>这是进行手动事务控制的</strong>第一步，也是<strong>必须的</strong>一步。</li>
</ul>
</li>
</ul>
<p><strong>最佳实践</strong>:</p>
<ul>
<li>在一个业务方法开始时，获取连接后，<strong>立即</strong>调用 <code>conn.setAutoCommit(false);</code> 来开启事务。</li>
<li>在方法的 <code>finally</code> 块中，将连接关闭前，<strong>恢复</strong>其自动提交状态 <code>conn.setAutoCommit(true);</code>。这对于使用了<strong>连接池</strong>的环境至关重要，因为当你关闭（归还）连接时，连接池期望连接恢复到默认状态，以免影响下一个使用者。</li>
</ul>
<hr>
<h3 id="4-2-事务的终点"><a href="#4-2-事务的终点" class="headerlink" title="4.2 事务的终点"></a>4.2 事务的终点</h3><p>一旦进入手动事务模式，就必须为事务的结束负责。事务的结束只有两种可能：成功提交或失败回滚。</p>
<ul>
<li><strong><code>void commit()</code></strong><ul>
<li><strong>含义</strong>: 提交事务。</li>
<li><strong>行为</strong>: 将当前事务中自上次提交&#x2F;回滚以来执行的所有 SQL 操作<strong>永久性地保存</strong>到数据库中。这对应了事务的<strong>持久性 (Durability)</strong>。</li>
<li><strong>调用时机</strong>: 在 <code>try</code> 块的<strong>末尾</strong>，当所有数据库操作都已成功执行，并且业务逻辑确认可以提交时调用。</li>
<li>调用 <code>commit()</code> 之后，当前事务结束。如果连接继续使用，一个新的事务会立即隐式开始。</li>
</ul>
</li>
<li><strong><code>void rollback()</code></strong><ul>
<li><strong>含义</strong>: 回滚事务。</li>
<li><strong>行为</strong>: <strong>撤销</strong>当前事务中自上次提交&#x2F;回滚以来执行的所有 SQL 操作，使数据库恢复到事务开始之前的状态。这对应了事务的<strong>原子性 (Atomicity)</strong>。</li>
<li><strong>调用时机</strong>: 在 <code>catch</code> 块中。当 <code>try</code> 块中的任何数据库操作或业务逻辑检查抛出异常时，表明事务无法成功完成，此时必须调用 <code>rollback()</code> 来保证数据的一致性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-3-事务代码"><a href="#4-3-事务代码" class="headerlink" title="4.3 事务代码"></a>4.3 事务代码</h3><p>结合 <code>try-catch-finally</code> 结构，一个健壮的 JDBC 事务处理代码应遵循以下模板。我们再次以银行转账为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(<span class="type">int</span> fromId, <span class="type">int</span> toId, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">debitStmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">creditStmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取连接</span></span><br><span class="line">        conn = DatabaseUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 关闭自动提交，开启事务</span></span><br><span class="line">        conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 事务操作开始 ---</span></span><br><span class="line">        <span class="comment">// 步骤 A: 扣款</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">debitSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;</span>;</span><br><span class="line">        debitStmt = conn.prepareStatement(debitSql);</span><br><span class="line">        debitStmt.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">        debitStmt.setInt(<span class="number">2</span>, fromId);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowsAffected1</span> <span class="operator">=</span> debitStmt.executeUpdate();</span><br><span class="line">        <span class="keyword">if</span> (rowsAffected1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;Debit failed, account not found or insufficient funds.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 B: 存款</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">creditSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;</span>;</span><br><span class="line">        creditStmt = conn.prepareStatement(creditSql);</span><br><span class="line">        creditStmt.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">        creditStmt.setInt(<span class="number">2</span>, toId);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowsAffected2</span> <span class="operator">=</span> creditStmt.executeUpdate();</span><br><span class="line">        <span class="keyword">if</span> (rowsAffected2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;Credit failed, account not found.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --- 事务操作结束 ---</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 所有操作成功，提交事务</span></span><br><span class="line">        conn.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;Transaction committed successfully.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Transaction failed. Performing rollback.&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 发生异常，回滚事务</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.rollback();</span><br><span class="line">                System.err.println(<span class="string">&quot;Rollback successful.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Error during rollback: &quot;</span> + ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 5. 在 finally 块中统一关闭资源</span></span><br><span class="line">        <span class="comment">//    注意：为了代码简洁，这里省略了每个 close 的 try-catch，</span></span><br><span class="line">        <span class="comment">//    在实际工具类中应妥善处理。</span></span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="keyword">if</span> (debitStmt != <span class="literal">null</span>) debitStmt.close(); &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="keyword">if</span> (creditStmt != <span class="literal">null</span>) creditStmt.close(); &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 恢复自动提交模式，为连接池做准备</span></span><br><span class="line">                conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码模板要点总结</strong>：</p>
<ol>
<li><strong>资源声明</strong>: 将 <code>Connection</code> 对象在 <code>try</code> 块外部声明为 <code>null</code>，以便 <code>catch</code> 和 <code>finally</code> 块可以访问它。</li>
<li><strong>开启事务</strong>: 在 <code>try</code> 块的开头，获取连接后立即调用 <code>conn.setAutoCommit(false);</code>。</li>
<li><strong>提交事务</strong>: 在 <code>try</code> 块的末尾，所有数据库操作成功后调用 <code>conn.commit();</code>。</li>
<li><strong>回滚事务</strong>: 在 <code>catch (SQLException e)</code> 块中，捕获到任何与数据库相关的异常时，调用 <code>conn.rollback();</code>。回滚操作本身也可能失败，所以 <code>rollback()</code> 调用也应该被一个 <code>try-catch</code> 包围。</li>
<li><strong>资源清理</strong>: 在 <code>finally</code> 块中，<strong>必须</strong>关闭所有打开的 <code>Statement</code> 和 <code>Connection</code> 资源。并且在关闭 <code>Connection</code> 之前，最好将其恢复到自动提交模式 <code>conn.setAutoCommit(true);</code>。</li>
</ol>
<hr>
<hr>
<h1 id="四、企业级开发实践"><a href="#四、企业级开发实践" class="headerlink" title="四、企业级开发实践"></a>四、企业级开发实践</h1><h2 id="1-连接池"><a href="#1-连接池" class="headerlink" title="1. 连接池"></a>1. 连接池</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p><strong>数据库连接池</strong>是一种管理数据库连接的<strong>缓冲池技术</strong>。它的核心思想是在应用程序启动时，预先创建并维护一定数量的数据库连接对象，并将这些连接存放在一个“池子”里。当应用程序需要与数据库交互时，它不是直接创建一个新的连接，而是从池中“借用”一个已存在的空闲连接。使用完毕后，也不是关闭这个连接，而是将其“归还”到池中，以供其他线程或请求复用。</p>
<hr>
<h3 id="1-2-解决的核心问题"><a href="#1-2-解决的核心问题" class="headerlink" title="1.2 解决的核心问题"></a>1.2 解决的核心问题</h3><p>如果不使用连接池，每次数据库操作都遵循“<strong>建立连接 -&gt; 执行SQL -&gt; 关闭连接</strong>”的流程。这个过程，尤其是“建立连接”，是一个非常耗费资源和时间的操作。</p>
<p><strong>建立一个数据库连接的成本包括：</strong></p>
<ol>
<li><strong>网络开销</strong>：客户端与数据库服务器之间需要经过 TCP&#x2F;IP 的三次握手来建立物理连接。</li>
<li><strong>数据库认证</strong>：数据库需要验证客户端提供的用户名和密码。</li>
<li><strong>会话准备</strong>：数据库需要为这个连接创建和分配内存、准备会话环境等。</li>
<li><strong>资源消耗</strong>：频繁地创建和销毁连接会给数据库服务器带来巨大的性能压力，并消耗大量的内存和 CPU 资源。</li>
</ol>
<p><strong>使用连接池带来的核心优势：</strong></p>
<ul>
<li><strong>性能提升</strong>：通过复用连接，避免了频繁创建和销毁连接的开销，极大地减少了请求的响应时间。</li>
<li><strong>资源管理</strong>：连接池可以统一管理连接的分配和释放，有效控制应用程序的最大连接数，防止因连接数过多而压垮数据库。</li>
<li><strong>可靠性增强</strong>：连接池通常具备连接有效性检测、自动重连等功能，可以剔除失效的连接，保证应用程序获取到的连接是可用的。</li>
</ul>
<hr>
<h3 id="1-3-工作原理"><a href="#1-3-工作原理" class="headerlink" title="1.3 工作原理"></a>1.3 工作原理</h3><p>一个典型的连接池工作流程如下：</p>
<ol>
<li><strong>初始化 (Initialization)</strong>：服务启动时，连接池根据配置创建一组初始的数据库连接（<code>initialSize</code>），并将它们置为空闲状态。</li>
<li><strong>借用连接 (Borrowing)</strong>：<ul>
<li>当应用程序请求连接时，连接池首先检查是否有空闲连接。</li>
<li>如果有，就将一个空闲连接标记为“活动”状态并返回给应用程序。</li>
<li>如果没有空闲连接，且当前总连接数未达到上限（<code>maxActive</code>），连接池会创建一个新的连接。</li>
<li>如果已达到上限，请求线程会根据配置进行等待（<code>maxWait</code>），直到有连接被归还或等待超时。</li>
</ul>
</li>
<li><strong>使用连接 (Using)</strong>：应用程序使用这个连接执行数据库操作。</li>
<li><strong>归还连接 (Returning)</strong>：<ul>
<li>应用程序调用 <code>connection.close()</code> 方法。</li>
<li><strong>关键点</strong>：这个 <code>close()</code> 方法被连接池框架重写了。它并<strong>不会真正关闭物理连接</strong>，而是将连接的状态从“活动”重置为“空闲”，然后将其放回池中。</li>
</ul>
</li>
<li><strong>维护 (Maintenance)</strong>：连接池在后台会有一个维护线程，定期检查池中连接的健康状况（如使用 <code>validationQuery</code>），关闭长时间未使用的空闲连接（维持在 <code>minIdle</code> 数量），并确保连接的有效性。</li>
</ol>
<hr>
<h3 id="1-4-核心配置参数解析"><a href="#1-4-核心配置参数解析" class="headerlink" title="1.4 核心配置参数解析"></a>1.4 核心配置参数解析</h3><p>配置连接池时，通常会遇到以下几个关键参数，合理配置它们对系统性能至关重要。</p>
<table>
<thead>
<tr>
<th>参数名 (常见)</th>
<th>含义</th>
<th>建议与说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>initialSize</code></td>
<td>初始连接数。连接池启动时创建的连接数量。</td>
<td>建议设置一个合理的值，避免应用启动后短时间内因创建连接导致响应变慢。</td>
</tr>
<tr>
<td><code>minIdle</code></td>
<td>最小空闲连接数。即使没有请求，池中也要保留的最小连接数。</td>
<td>如果系统有突发流量，设置此值可以保证能快速响应，因为它避免了从零开始创建连接。</td>
</tr>
<tr>
<td><code>maxActive</code> &#x2F; <code>maximumPoolSize</code></td>
<td>最大连接数。池中允许存在的最大连接总数（包括活动和空闲）。</td>
<td><strong>最关键的参数</strong>。设置过小会导致请求排队等待，设置过大会耗尽数据库资源。需要根据数据库并发能力和应用QPS进行压测后确定。</td>
</tr>
<tr>
<td><code>maxWait</code> &#x2F; <code>connectionTimeout</code></td>
<td>最大等待时间。当池中没有可用连接时，请求线程等待的最长时间（毫秒）。</td>
<td>设置-1表示无限等待（不推荐）。建议设置一个合理的超时时间（如3000ms），超时后应抛出异常，防止线程无限期阻塞。</td>
</tr>
<tr>
<td><code>validationQuery</code></td>
<td>连接有效性检查SQL。用于在借出连接前，检查该连接是否仍然有效。</td>
<td>例如 <code>SELECT 1</code> (MySQL)。开启此功能会带来轻微性能损耗，但能有效避免拿到“死亡”连接。</td>
</tr>
<tr>
<td><code>testOnBorrow</code></td>
<td>是否在借用连接前进行有效性检查。</td>
<td>设为 <code>true</code> 可以保证每次拿到的连接都是可用的，但性能开销较大。现代连接池（如HikariCP）有更高效的检测机制。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-5-主流连接池介绍"><a href="#1-5-主流连接池介绍" class="headerlink" title="1.5 主流连接池介绍"></a>1.5 主流连接池介绍</h3><ul>
<li><strong><code>DataSource</code> 接口</strong>:<br>在介绍具体实现之前，必须提到 <code>javax.sql.DataSource</code> 接口。这是 JDBC 2.0 引入的标准接口，是所有连接池实现的<strong>通用门面</strong>。它取代了 <code>DriverManager</code>，成为现代应用中获取连接的首选方式。通过面向 <code>DataSource</code> 编程，你的代码可以与任何连接池实现解耦。</li>
<li><strong>常见连接池库</strong>:<ol>
<li><strong>DBCP (Database Connection Pool)</strong>:<ul>
<li>由 Apache Commons 开发，是比较早期的连接池实现。</li>
<li><strong>优点</strong>: 成熟，与 Apache 其他项目集成良好。</li>
<li><strong>缺点</strong>: 配置相对复杂，性能在现代连接池中已不占优势，存在一些已知的并发问题。</li>
</ul>
</li>
<li><strong>C3P0</strong>:<ul>
<li>一个非常稳定、功能强大的老牌连接池。</li>
<li><strong>优点</strong>: 功能极其丰富，配置项非常多，提供了强大的连接测试和自动重连功能。</li>
<li><strong>缺点</strong>: 配置复杂，性能相比新一代连接池较慢。</li>
</ul>
</li>
<li><strong>HikariCP (光连接池)</strong>:<ul>
<li><strong>当前 Java 社区公认的性能之王</strong>。</li>
<li><strong>优点</strong>:<ul>
<li><strong>极速</strong>: 在性能和可靠性上做了大量的微优化，号称“史上最快连接池”。</li>
<li><strong>轻量</strong>: JAR 包非常小。</li>
<li><strong>稳定可靠</strong>: 设计简洁，代码质量高。</li>
</ul>
</li>
<li><strong>现状</strong>: <strong>Spring Boot 2.x 及以后版本的默认连接池</strong>。对于新项目，<strong>HikariCP 是首选</strong>。</li>
</ul>
</li>
<li><strong>Druid (德鲁伊)</strong>:<ul>
<li>由阿里巴巴开源，是国内使用最广泛的连接池之一。</li>
<li><strong>优点</strong>:<ul>
<li><strong>强大的监控功能</strong>: 提供了丰富、详细的 SQL 监控、Web URI 监控、Session 监控等，并内置了一个美观的监控 Web 界面。这是它最大的特色。</li>
<li><strong>防 SQL 注入</strong>: 内置了 SQL 解析器，可以有效地防御 SQL 注入。</li>
<li><strong>丰富的扩展功能</strong>: 支持数据库密码加密、SQL 防火墙等。</li>
</ul>
</li>
<li><strong>缺点</strong>: 相比 HikariCP，性能略逊一筹，且 JAR 包较大。</li>
<li><strong>适用场景</strong>: 如果你对数据库监控有强烈的需求，Druid 是一个非常好的选择。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>选择建议</strong>:</p>
<ul>
<li><strong>新项目&#x2F;性能优先</strong>: 毫不犹豫地选择 <strong>HikariCP</strong>。</li>
<li><strong>需要强大监控&#x2F;遗留项目升级</strong>: <strong>Druid</strong> 是一个非常可靠且功能丰富的选项。</li>
<li>DBCP 和 C3P0 在新项目中已不推荐使用。</li>
</ul>
<hr>
<h3 id="1-6-Druid-连接池配置与使用示例"><a href="#1-6-Druid-连接池配置与使用示例" class="headerlink" title="1.6 Druid 连接池配置与使用示例"></a>1.6 Druid 连接池配置与使用示例</h3><p>下面以国内广泛使用的 Druid 为例，演示如何配置和使用连接池。</p>
<p><strong>步骤 1: 添加 Maven 依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用最新稳定版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库驱动依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 创建并配置 DataSource</strong></p>
<p>通常我们会创建一个工具类来管理 <code>DataSource</code> 的单例实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，在类加载时初始化 DataSource</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 加载配置文件</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DruidUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            props.load(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 使用 DruidDataSourceFactory 创建 DataSource</span></span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(props);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to initialize Druid DataSource&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个公共的静态方法来获取 DataSource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个公共的静态方法来获取连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 从连接池获取连接</span></span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 创建配置文件 (<code>druid.properties</code>)</strong></p>
<p>在你的 <code>resources</code> 目录下创建 <code>druid.properties</code> 文件。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本属性</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC&amp;rewriteBatchedStatements=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">your_password</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Druid 配置项</span></span><br><span class="line"><span class="comment"># 初始化连接池大小</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 最小空闲连接数</span></span><br><span class="line"><span class="attr">minIdle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 最大活动连接数</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"># 获取连接等待超时的时间 (毫秒)</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接 (毫秒)</span></span><br><span class="line"><span class="attr">timeBetweenEvictionRunsMillis</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment"># 配置一个连接在池中最小生存的时间 (毫秒)</span></span><br><span class="line"><span class="attr">minEvictableIdleTimeMillis</span>=<span class="string">300000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 用来检测连接是否有效的 sql</span></span><br><span class="line"><span class="attr">validationQuery</span>=<span class="string">SELECT 1</span></span><br><span class="line"><span class="comment"># 建议配置为 true，不影响性能，并且保证安全性</span></span><br><span class="line"><span class="attr">testWhileIdle</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 申请连接的时候检测</span></span><br><span class="line"><span class="attr">testOnBorrow</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 归还连接的时候检测</span></span><br><span class="line"><span class="attr">testOnReturn</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否开启 PS Cache，并指定每个连接上 PS Cache 的大小</span></span><br><span class="line"><span class="attr">poolPreparedStatements</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">maxPoolPreparedStatementPerConnectionSize</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置监控统计拦截的 filters，wall 用于防火墙</span></span><br><span class="line"><span class="attr">filters</span>=<span class="string">stat,wall,log4j</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 4: 在业务代码中使用</strong></p>
<p>代码不再需要关心 <code>DriverManager</code>，直接通过工具类向连接池获取连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这里 conn 的获取方式变了</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DruidUtil.getConnection(); <span class="comment">// 从连接池借用连接</span></span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        pstmt.setInt(<span class="number">1</span>, userId);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">// ... process data</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// try-with-resources 会自动调用 conn.close()，</span></span><br><span class="line">    <span class="comment">// 对于连接池来说，这实际上是“归还连接”的操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>: <code>conn.close()</code> 的行为被连接池<strong>重写 (override)</strong> 了。它不再是关闭物理连接，而是将连接的状态重置并放回池中，等待下一次被借用。这个机制对应用程序是<strong>透明的</strong>。</p>
<hr>
<h3 id="1-7-连接泄漏"><a href="#1-7-连接泄漏" class="headerlink" title="1.7 连接泄漏"></a>1.7 连接泄漏</h3><p><strong>连接泄漏</strong>是指应用程序从连接池中借用了连接，但在使用完毕后<strong>没有将其归还</strong>。这会导致池中的可用连接越来越少，最终耗尽所有连接，使得新的请求无法获取连接，导致整个应用无响应或超时。</p>
<p><strong>主要原因</strong>：通常是由于代码中存在逻辑缺陷，如在 <code>try</code> 块中获取连接，但在 <code>finally</code> 块中没有确保执行 <code>connection.close()</code>。</p>
<p>**如何避免：**始终使用 <code>try-with-resources</code> (Java 7+) 语句或 <code>try-finally</code> 结构来保证连接一定会被关闭（归还）。</p>
<p><strong>正确示范 (try-with-resources):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connection, PreparedStatement, ResultSet 都实现了 AutoCloseable 接口</span></span><br><span class="line"><span class="comment">// JVM 会自动在末尾调用它们的 close() 方法</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">     <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">    <span class="comment">// ... 执行SQL ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// ... 异常处理 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确示范 (try-finally):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    conn = dataSource.getConnection();</span><br><span class="line">    <span class="comment">// ... 执行SQL ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// ... 异常处理 ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.close(); <span class="comment">// 确保归还连接</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// log error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-DAO-Data-Access-Object-设计模式"><a href="#2-DAO-Data-Access-Object-设计模式" class="headerlink" title="2. DAO (Data Access Object) 设计模式"></a>2. DAO (Data Access Object) 设计模式</h2><h3 id="2-1-DAO简介与优势"><a href="#2-1-DAO简介与优势" class="headerlink" title="2.1 DAO简介与优势"></a>2.1 DAO简介与优势</h3><h3 id="2-1-1-简介"><a href="#2-1-1-简介" class="headerlink" title="2.1.1 简介"></a>2.1.1 简介</h3><p>DAO (Data Access Object) 是一种广泛应用于企业级应用中的设计模式。它的核心思想是<strong>将数据访问逻辑（如何与数据库交互）从业务逻辑（做什么业务操作）中分离出来</strong>。</p>
<p>DAO 模式通过定义一个接口和其实现类，为每一种数据实体（如 User, Product, Order）提供一个专门的、统一的数据访问入口，在后续的Web开发中DAO是三层架构的重要组成部分，务必要熟悉DAO设计模式。</p>
<hr>
<h3 id="2-1-2-优势"><a href="#2-1-2-优势" class="headerlink" title="2.1.2 优势"></a>2.1.2 优势</h3><ol>
<li><strong>分层与解耦 (Separation of Concerns)</strong>:<ul>
<li><strong>业务逻辑</strong>（Service 层）变得非常纯粹，它只关心业务流程，而不需要知道数据是存在 MySQL、Oracle 还是文件中。</li>
<li><strong>数据访问</strong>（DAO 层）专注于与特定数据源的交互，所有与 JDBC API、SQL 语句相关的“脏活累活”都封装在这里。</li>
<li>当底层数据库需要更换时，理论上只需要替换 DAO 的实现类，而业务逻辑层代码<strong>完全不需要改动</strong>。</li>
</ul>
</li>
<li><strong>代码复用与可维护性 (Reusability &amp; Maintainability)</strong>:<ul>
<li>对某个实体（如 User）的所有数据库操作（增删改查）都集中在 <code>UserDAO</code> 中，避免了在不同业务代码中散落着重复的 JDBC 代码。</li>
<li>修改 SQL 语句或数据库交互逻辑时，只需要修改 DAO 中的一个地方，所有调用该方法的地方都会受益。</li>
</ul>
</li>
<li><strong>易于测试 (Testability)</strong>:<ul>
<li>由于业务逻辑与数据访问解耦，我们可以很容易地为 Service 层编写单元测试，通过模拟（Mock）一个 DAO 对象来提供测试数据，而无需启动一个真实的数据库。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-2-DAO-模式的组成部分"><a href="#2-2-DAO-模式的组成部分" class="headerlink" title="2.2 DAO 模式的组成部分"></a>2.2 DAO 模式的组成部分</h3><p>一个典型的 DAO 实现通常包含以下几个部分：</p>
<ol>
<li><strong>实体类 (Entity &#x2F; POJO &#x2F; JavaBean)</strong>:<ul>
<li>用于封装数据的普通 Java 对象，其属性与数据库表的字段一一对应。例如 <code>User</code> 类对应 <code>users</code> 表。</li>
</ul>
</li>
<li><strong>DAO 接口 (DAO Interface)</strong>:<ul>
<li>定义了针对该实体类的所有数据访问操作的<strong>契约</strong>。它只包含方法签名，不包含具体实现。</li>
<li>例如 <code>UserDAO</code> 接口会定义 <code>addUser(User user)</code>, <code>findUserById(int id)</code>, <code>findAllUsers()</code> 等方法。</li>
</ul>
</li>
<li><strong>DAO 实现类 (DAO Implementation)</strong>:<ul>
<li>实现了 DAO 接口的具体类。所有与 JDBC API 交互的底层代码都写在这里。</li>
<li>例如 <code>UserDAOImpl</code> 类会具体实现 <code>addUser</code> 方法，包括获取连接、创建 <code>PreparedStatement</code>、设置参数、执行 SQL 等。</li>
</ul>
</li>
<li><strong>(可选) 通用 JDBC 工具类 (Utility Class)</strong>:<ul>
<li>为了避免在每个 DAO 实现类中重复编写获取连接、关闭资源等模板代码，通常会抽取一个 <code>JdbcUtils</code> 或 <code>DBUtil</code> 类来封装这些通用逻辑。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-3-实战"><a href="#2-3-实战" class="headerlink" title="2.3 实战"></a>2.3 实战</h3><p>我们来一步步构建一个完整的 <code>UserDAO</code> 示例。</p>
<p><strong>第 1 步：创建实体类 <code>User.java</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// 省略构造函数、getters、setters 和 toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 2 步：创建通用 JDBC 工具类 <code>JdbcUtils.java</code></strong></p>
<p>这个工具类使用 Druid 连接池来管理连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            props.load(is);</span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(props);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to initialize DataSource&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 3 步：定义 <code>UserDAO</code> 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDAO</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteUser</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAllUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 4 步：创建 <code>UserDAOImpl</code> 实现类</strong></p>
<p>这是 DAO 模式的核心，包含了所有具体的数据库操作逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDAO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">            pstmt.setString(<span class="number">1</span>, user.getName());</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, user.getEmail());</span><br><span class="line">            pstmt.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email FROM users WHERE id = ?&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">            pstmt.setInt(<span class="number">1</span>, id);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                    user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                    user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                    user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                    user.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email FROM users&quot;</span>;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">             <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                user.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">                userList.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... updateUser 和 deleteUser 的实现 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 5 步：在业务层 (Service) 中使用 DAO</strong></p>
<p>业务层通过接口与 DAO 交互，完全不知道底层实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 通过依赖注入或工厂模式获取 DAO 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDAO</span> <span class="variable">userDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDAOImpl</span>(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerNewUser</span><span class="params">(String name, String email)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span> || name.isEmpty() || email == <span class="literal">null</span> || email.isEmpty()) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Invalid user data.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        newUser.setName(name);</span><br><span class="line">        newUser.setEmail(email);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 DAO 方法完成数据持久化</span></span><br><span class="line">        userDAO.addUser(newUser);</span><br><span class="line">        System.out.println(<span class="string">&quot;User &quot;</span> + name + <span class="string">&quot; registered successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-使用反射简化"><a href="#2-4-使用反射简化" class="headerlink" title="2.4 使用反射简化"></a>2.4 使用反射简化</h3><p>在 <code>findUserById</code> 和 <code>findAllUsers</code> 方法中，我们看到了一段重复的、繁琐的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">user.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>如果 <code>User</code> 类有 20 个属性，这段代码会变得非常长且容易出错。我们可以利用 <strong>Java 反射 (Reflection)</strong> 和 <strong><code>ResultSetMetaData</code></strong> 来编写一个通用的映射工具，自动完成这个过程。</p>
<p>许多 JDBC 框架（如 Apache DbUtils, Spring JDBC Template, MyBatis）的核心原理就是基于此。虽然我们不一定要自己实现一个完美的框架，但理解其原理非常重要。</p>
<p><strong>简化的实现思路</strong>:</p>
<ol>
<li>创建一个通用的查询方法，接收 SQL、参数和一个 <code>Class</code> 对象（如 <code>User.class</code>）。</li>
<li>执行查询后，获取 <code>ResultSet</code> 和 <code>ResultSetMetaData</code>。</li>
<li>遍历 <code>ResultSet</code> 的每一行。</li>
<li>在每一行中，通过 <code>rsmd.getColumnLabel(i)</code> 获取列名。</li>
<li>通过 Java 反射，找到 <code>User.class</code> 中与列名对应的 <code>setter</code> 方法（例如，列名是 <code>user_name</code>，就去找 <code>setUserName</code> 方法）。</li>
<li>调用 <code>setter</code> 方法，将 <code>rs.getObject(i)</code> 的值设置到新创建的 <code>User</code> 对象实例中。</li>
</ol>
<hr>
<hr>
<h1 id="五、高级主题与性能优化"><a href="#五、高级主题与性能优化" class="headerlink" title="五、高级主题与性能优化"></a>五、高级主题与性能优化</h1><h2 id="1-高级查询"><a href="#1-高级查询" class="headerlink" title="1. 高级查询"></a>1. 高级查询</h2><h3 id="1-1-分页查询实现-Pagination"><a href="#1-1-分页查询实现-Pagination" class="headerlink" title="1.1 分页查询实现 (Pagination)"></a>1.1 分页查询实现 (Pagination)</h3><h4 id="1-1-1-为什么需要分页？"><a href="#1-1-1-为什么需要分页？" class="headerlink" title="1.1.1 为什么需要分页？"></a>1.1.1 为什么需要分页？</h4><p>一个拥有数百万条记录的商品表。如果执行 <code>SELECT * FROM products</code>，会发生</p>
<ul>
<li><strong>内存溢出 (OOM)</strong>: 应用程序试图将数百万条记录加载到内存中，很可能导致内存耗尽而崩溃。</li>
<li><strong>网络拥堵</strong>: 大量数据通过网络从数据库传输到应用程序，耗时极长。</li>
<li><strong>数据库压力</strong>: 数据库需要读取并处理海量数据，消耗大量 I&#x2F;O 和 CPU 资源。</li>
<li><strong>用户体验差</strong>: 用户无法也无需一次性看到所有数据。</li>
</ul>
<p><strong>分页 (Pagination)</strong> 就是解决这个问题的标准方案。其核心思想是：<strong>每次只从数据库中查询出用户当前需要看的一小部分数据（一“页”）</strong>。</p>
<hr>
<h4 id="1-1-2-分页的两个核心参数："><a href="#1-1-2-分页的两个核心参数：" class="headerlink" title="1.1.2 分页的两个核心参数："></a>1.1.2 分页的两个核心参数：</h4><ul>
<li><code>pageNumber</code> (或 <code>currentPage</code>)：当前页码，例如第 1 页，第 2 页。</li>
<li><code>pageSize</code>：每页显示的记录数，例如每页 10 条，每页 20 条。</li>
</ul>
<hr>
<h4 id="1-1-3-如何用-SQL-实现分页？"><a href="#1-1-3-如何用-SQL-实现分页？" class="headerlink" title="1.1.3 如何用 SQL 实现分页？"></a>1.1.3 如何用 SQL 实现分页？</h4><p>JDBC 本身<strong>没有</strong>提供标准的分页 API。分页是<strong>通过特定数据库的 SQL 方言</strong>来实现的。你需要为你的目标数据库编写相应的分页 SQL。</p>
<ul>
<li><p><strong>MySQL &amp; PostgreSQL (使用 <code>LIMIT ... OFFSET ...</code>)</strong></p>
<ul>
<li><strong>语法</strong>: <code>SELECT ... FROM ... ORDER BY ... LIMIT [每页数量] OFFSET [跳过的记录数]</code></li>
<li><code>LIMIT</code>: 指定最多返回多少条记录。</li>
<li><code>OFFSET</code>: 指定从结果集的第几条记录开始返回（从 0 开始计数）。</li>
<li><strong>计算 <code>OFFSET</code></strong>: <code>offset = (pageNumber - 1) * pageSize</code></li>
<li><strong>示例 SQL (查询第 3 页，每页 10 条)</strong>:<br><code>SELECT * FROM products ORDER BY id LIMIT 10 OFFSET 20;</code> (跳过前 20 条，取 10 条)</li>
</ul>
</li>
<li><p><strong>Oracle (12c 及以后版本，推荐)</strong></p>
<ul>
<li><strong>语法</strong>: <code>SELECT ... FROM ... ORDER BY ... OFFSET [跳过的行数] ROWS FETCH NEXT [获取的行数] ROWS ONLY</code></li>
<li><strong>示例 SQL (查询第 3 页，每页 10 条)</strong>:<br><code>SELECT * FROM products ORDER BY id OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;</code></li>
</ul>
</li>
<li><p><strong>Oracle (11g 及以前版本，传统方式)</strong></p>
<ul>
<li><p><strong>语法</strong>: 使用 <code>ROWNUM</code> 和嵌套子查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> t.<span class="operator">*</span>, ROWNUM <span class="keyword">AS</span> row_num <span class="keyword">FROM</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">    ) t <span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> (pageNumber <span class="operator">*</span> pageSize)</span><br><span class="line">) <span class="keyword">WHERE</span> row_num <span class="operator">&gt;</span> ((pageNumber <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> pageSize);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-4-JDBC-代码实战-以-MySQL-为例"><a href="#1-1-4-JDBC-代码实战-以-MySQL-为例" class="headerlink" title="1.1.4 JDBC 代码实战 (以 MySQL 为例)"></a>1.1.4 JDBC 代码实战 (以 MySQL 为例)</h4><p>通常，一个完整的分页查询不仅要返回当前页的数据列表，还要返回<strong>总记录数</strong>，以便前端计算总页数并显示分页控件。</p>
<p><strong>步骤 A: 定义一个分页结果的包装类 <code>Page&lt;T&gt;</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; data; <span class="comment">// 当前页的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> totalRecords; <span class="comment">// 总记录数</span></span><br><span class="line">    <span class="comment">// ... constructors, getters, setters ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 B: 实现分页查询方法</strong></p>
<p>这个方法需要执行两次数据库查询：一次获取总数，一次获取当前页数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Page&lt;Product&gt; <span class="title function_">findProductsByPage</span><span class="params">(<span class="type">int</span> pageNumber, <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查询总记录数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">countSql</span> <span class="operator">=</span> <span class="string">&quot;SELECT COUNT(*) FROM products&quot;</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">countPstmt</span> <span class="operator">=</span> conn.prepareStatement(countSql);</span><br><span class="line">         <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> countPstmt.executeQuery()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">            total = rs.getLong(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 查询当前页的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dataSql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, price FROM products ORDER BY id LIMIT ? OFFSET ?&quot;</span>;</span><br><span class="line">    List&lt;Product&gt; productList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">dataPstmt</span> <span class="operator">=</span> conn.prepareStatement(dataSql)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> (pageNumber - <span class="number">1</span>) * pageSize;</span><br><span class="line">        dataPstmt.setInt(<span class="number">1</span>, pageSize);</span><br><span class="line">        dataPstmt.setInt(<span class="number">2</span>, offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> dataPstmt.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">                product.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                product.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                product.setPrice(rs.getDouble(<span class="string">&quot;price&quot;</span>));</span><br><span class="line">                productList.add(product);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 封装并返回 Page 对象</span></span><br><span class="line">    Page&lt;Product&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line">    page.setData(productList);</span><br><span class="line">    page.setTotalRecords(total);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-动态-SQL-构建技巧"><a href="#1-2-动态-SQL-构建技巧" class="headerlink" title="1.2 动态 SQL 构建技巧"></a>1.2 动态 SQL 构建技巧</h3><h4 id="1-2-1-什么是动态-SQL？"><a href="#1-2-1-什么是动态-SQL？" class="headerlink" title="1.2.1 什么是动态 SQL？"></a>1.2.1 什么是动态 SQL？</h4><p>在很多应用场景中，SQL 的查询条件是<strong>不固定的</strong>，需要根据用户的输入动态生成。例如，一个商品搜索功能可能包含：</p>
<ul>
<li>商品名称（模糊匹配）</li>
<li>价格区间（大于某个值，小于某个值）</li>
<li>商品分类</li>
<li>库存状态</li>
</ul>
<p>用户可能只填写其中一两个条件，也可能全部填写。为每一种组合都写一个固定的 SQL 是不现实的。<strong>动态 SQL</strong> 就是在 Java 代码中根据条件动态拼接 SQL 字符串的技术。</p>
<hr>
<h4 id="1-2-2-危险的实现方式：字符串拼接"><a href="#1-2-2-危险的实现方式：字符串拼接" class="headerlink" title="1.2.2 危险的实现方式：字符串拼接"></a>1.2.2 危险的实现方式：字符串拼接</h4><p>初学者最容易想到的方法是直接用 <code>+</code> 拼接字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 极度危险，绝对禁止！</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM products WHERE 1=1&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">    sql += <span class="string">&quot; AND name LIKE &#x27;%&quot;</span> + name + <span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (minPrice != <span class="literal">null</span>) &#123;</span><br><span class="line">    sql += <span class="string">&quot; AND price &gt;= &quot;</span> + minPrice;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br></pre></td></tr></table></figure>

<p>这种方式存在<strong>致命的 SQL 注入漏洞</strong>。如果用户输入 <code>name</code> 为 <code>&#39;; DROP TABLE products; --</code>，你的数据表就没了。</p>
<hr>
<h4 id="1-2-3-安全的实现方式：PreparedStatement-条件拼接"><a href="#1-2-3-安全的实现方式：PreparedStatement-条件拼接" class="headerlink" title="1.2.3 安全的实现方式：PreparedStatement + 条件拼接"></a>1.2.3 安全的实现方式：<code>PreparedStatement</code> + 条件拼接</h4><p>正确的做法是，<strong>只动态拼接 SQL 的结构部分，而所有的值都必须通过 <code>?</code> 占位符和 <code>PreparedStatement</code> 来绑定</strong>。</p>
<p><strong>核心思路</strong>：</p>
<ol>
<li>使用 <code>StringBuilder</code> 来构建 SQL 字符串。</li>
<li>使用 <code>ArrayList</code> 来按顺序存储需要绑定的参数值。</li>
<li>以 <code>WHERE 1=1</code> 作为查询条件的开头，这样后续所有条件都可以统一用 <code>AND</code> 来追加，无需判断是否是第一个条件。</li>
</ol>
<p><strong>JDBC 代码实战：动态商品搜索</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">searchProducts</span><span class="params">(String name, Double minPrice, Double maxPrice)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;SELECT id, name, price FROM products WHERE 1=1&quot;</span>);</span><br><span class="line">    List&lt;Object&gt; params = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态构建 SQL 和参数列表</span></span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; !name.trim().isEmpty()) &#123;</span><br><span class="line">        sql.append(<span class="string">&quot; AND name LIKE ?&quot;</span>);</span><br><span class="line">        params.add(<span class="string">&quot;%&quot;</span> + name + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minPrice != <span class="literal">null</span>) &#123;</span><br><span class="line">        sql.append(<span class="string">&quot; AND price &gt;= ?&quot;</span>);</span><br><span class="line">        params.add(minPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxPrice != <span class="literal">null</span>) &#123;</span><br><span class="line">        sql.append(<span class="string">&quot; AND price &lt;= ?&quot;</span>);</span><br><span class="line">        params.add(maxPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sql.append(<span class="string">&quot; ORDER BY id&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Product&gt; productList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql.toString())) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态设置参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; params.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// setObject 可以处理大多数类型</span></span><br><span class="line">            pstmt.setObject(i + <span class="number">1</span>, params.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">                product.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                product.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                product.setPrice(rs.getDouble(<span class="string">&quot;price&quot;</span>));</span><br><span class="line">                productList.add(product);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> productList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>:</p>
<ul>
<li><strong>分页查询</strong>是处理大数据集显示的基础，其实现依赖于特定数据库的 SQL 语法，通常需要两次查询（一次查总数，一次查数据）。</li>
<li><strong>动态 SQL</strong> 是构建灵活查询功能的关键，<strong>必须</strong>结合 <code>PreparedStatement</code> 和参数列表来构建，以从根本上杜дотвратить SQL 注入。</li>
<li>在实际项目中，这些复杂的 JDBC 操作通常会被 <strong>MyBatis</strong>、<strong>JPA (Hibernate)</strong> 等持久层框架所封装，它们提供了更强大、更便捷的分页和动态 SQL 功能。但理解底层的 JDBC 实现原理，对于排查问题和深入理解框架至关重要。</li>
</ul>
<hr>
<h2 id="2-性能优化建议"><a href="#2-性能优化建议" class="headerlink" title="2. 性能优化建议"></a>2. 性能优化建议</h2><h3 id="2-1-使用数据库连接池"><a href="#2-1-使用数据库连接池" class="headerlink" title="2.1 使用数据库连接池"></a>2.1 使用数据库连接池</h3><ul>
<li><strong>为什么</strong>: 这是<strong>最重要、最有效</strong>的性能优化手段，没有之一。直接使用 <code>DriverManager.getConnection()</code> 在高并发场景下是灾难性的。连接的创建和销毁涉及网络通信、数据库认证、会话创建等重量级操作，开销巨大。</li>
<li><strong>怎么做</strong>:<ul>
<li>在应用程序中集成一个高性能的连接池，如 <strong>HikariCP</strong> (Spring Boot 默认，首选) 或 <strong>Druid</strong> (监控功能强大)。</li>
<li>合理配置连接池参数：<ul>
<li><code>maximumPoolSize</code> (最大连接数): 不是越大越好。需要根据应用的 QPS、数据库服务器的 CPU 核心数和 I&#x2F;O 能力进行压力测试来确定。一个常见的经验法则是 <code>(核心数 * 2) + 1</code>。设置过大会导致数据库因上下文切换而性能下降。</li>
<li><code>minimumIdle</code> (最小空闲连接数): 保持一定数量的“热”连接，以应对突发流量，避免在高峰期临时创建连接。</li>
<li><code>connectionTimeout</code> (连接超时): 设置一个合理的等待时间，避免线程因无法获取连接而无限期阻塞。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-优先并复用-PreparedStatement"><a href="#2-2-优先并复用-PreparedStatement" class="headerlink" title="2.2 优先并复用 PreparedStatement"></a>2.2 优先并复用 <code>PreparedStatement</code></h3><ul>
<li><strong>为什么</strong>:<ul>
<li><strong>预编译</strong>: <code>PreparedStatement</code> 将 SQL 语句发送给数据库进行一次预编译，并缓存执行计划。后续执行时，只需传输参数，数据库无需再次解析和编译 SQL，大大减少了数据库的 CPU 开销。</li>
<li><strong>安全性</strong>: 从根本上防止 SQL 注入。</li>
</ul>
</li>
<li><strong>怎么做</strong>:<ul>
<li><strong>杜绝 <code>Statement</code></strong>: 除非是执行完全静态、无参数的 DDL 语句，否则永远不要使用 <code>Statement</code> 来拼接 SQL。</li>
<li><strong>缓存 <code>PreparedStatement</code></strong>: 在某些极端高性能场景下（通常由连接池实现），可以开启 <code>PreparedStatement</code> 缓存 (<code>poolPreparedStatements=true</code> in Druid&#x2F;HikariCP)，连接池会为每个连接缓存一些常用的 <code>PreparedStatement</code> 对象，避免了 <code>connection.prepareStatement()</code> 的开销。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-使用批量操作处理大量数据"><a href="#2-3-使用批量操作处理大量数据" class="headerlink" title="2.3 使用批量操作处理大量数据"></a>2.3 使用批量操作处理大量数据</h3><ul>
<li><strong>为什么</strong>: 逐条 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 会产生大量的网络往返，性能极差。批量操作 (<code>addBatch()</code>, <code>executeBatch()</code>) 可以将多条 SQL 打包成一次请求发送给数据库，显著减少网络延迟。</li>
<li><strong>怎么做</strong>:<ul>
<li>当需要插入或更新大量数据时，使用 <code>for</code> 循环构建批处理。</li>
<li><strong>分批提交</strong>: 对于海量数据，不要一次性将所有数据都 <code>addBatch()</code>，这可能导致内存溢出。设置一个合理的批次大小（如 1000），分批执行 <code>executeBatch()</code>。</li>
<li><strong>开启特定驱动优化</strong>: 对于 MySQL，务必在 JDBC URL 中添加 <code>rewriteBatchedStatements=true</code>，性能提升可达数倍。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-4-高效处理-ResultSet"><a href="#2-4-高效处理-ResultSet" class="headerlink" title="2.4 高效处理 ResultSet"></a>2.4 高效处理 <code>ResultSet</code></h3><ul>
<li><strong>为什么</strong>: <code>ResultSet</code> 可能会在内存或数据库端占用大量资源。低效的处理方式会拖慢整个应用。</li>
<li><strong>怎么做</strong>:<ul>
<li><strong>明确指定查询列</strong>: <strong>永远不要使用 <code>SELECT \*</code></strong>。只查询你业务逻辑中确实需要的列。这可以减少网络传输的数据量、降低数据库的 I&#x2F;O 开销，并且如果查询能命中覆盖索引，性能会大幅提升。</li>
<li><strong>尽快处理和关闭</strong>: 遵循“尽早获取，尽快释放”的原则。在循环遍历 <code>ResultSet</code> 时，应尽快将数据转换为业务对象 (DTO&#x2F;VO)，然后立即关闭 <code>ResultSet</code> (通过 <code>try-with-resources</code> 自动完成)。不要持有 <code>ResultSet</code> 对象太长时间。</li>
<li><strong>使用 <code>ResultSet</code> 的 <code>getXXX()</code> 方法时，优先使用列索引</strong>: <code>rs.getString(1)</code> 通常比 <code>rs.getString(&quot;column_name&quot;)</code> 性能稍好，因为它避免了通过列名查找索引的开销。但这会牺牲代码的可读性和可维护性，因此只在性能压榨到极致的场景下考虑。在绝大多数情况下，<strong>可读性更重要</strong>。</li>
<li><strong>流式处理大结果集 (Fetch Size)</strong>: 默认情况下，JDBC 驱动可能会一次性将所有查询结果都从数据库拉取到内存中。如果结果集非常大，这会导致 OOM。可以通过 <code>statement.setFetchSize(int rows)</code> 来提示驱动一次从数据库拉取多少行数据到内存中。<ul>
<li>对于 MySQL，需要 <code>setFetchSize(Integer.MIN_VALUE)</code> 来开启流式读取。</li>
<li>这是一种高级优化，只在处理百万级别以上的大结果集时才需要考虑。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-5-事务管理优化"><a href="#2-5-事务管理优化" class="headerlink" title="2.5 事务管理优化"></a>2.5 事务管理优化</h3><ul>
<li><strong>为什么</strong>: 事务会持有数据库锁，过长的事务会阻塞其他操作，降低系统的并发能力。</li>
<li><strong>怎么做</strong>:<ul>
<li><strong>事务尽可能短</strong>: 遵循“小事务”原则。只将必要的数据库操作放在事务边界内。避免在事务中包含耗时的非数据库操作（如文件 I&#x2F;O、网络调用）。</li>
<li><strong>合理设置事务隔离级别</strong>: 不要盲目使用最高的 <code>SERIALIZABLE</code> 级别。根据业务需求选择足够用的最低隔离级别（通常是 <code>READ_COMMITTED</code> 或 <code>REPEATABLE_READ</code>），以在数据一致性和并发性能之间取得平衡。</li>
<li><strong>只在需要时开启事务</strong>: 对于只读的查询操作，如果业务允许（不需要在一次业务中保证多次查询的一致性），可以不开启事务（即使用自动提交模式），这样可以减少事务开销和锁竞争。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-6-正确关闭资源"><a href="#2-6-正确关闭资源" class="headerlink" title="2.6 正确关闭资源"></a>2.6 正确关闭资源</h3><ul>
<li><strong>为什么</strong>: 资源泄露（特别是连接泄露）是 JDBC 应用中最常见也最致命的问题。它会逐渐耗尽连接池中的所有连接，最终导致整个应用无法访问数据库。</li>
<li><strong>怎么做</strong>:<ul>
<li><strong>始终使用 <code>try-with-resources</code></strong>: 这是 Java 7+ 的最佳实践，能从语法层面保证 <code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 被自动、安全、正确地关闭。彻底告别手写 <code>finally</code> 块。</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="六、故障排查与最佳实践"><a href="#六、故障排查与最佳实践" class="headerlink" title="六、故障排查与最佳实践"></a>六、故障排查与最佳实践</h1><h2 id="1-常见问题与解决方案"><a href="#1-常见问题与解决方案" class="headerlink" title="1. 常见问题与解决方案"></a>1. 常见问题与解决方案</h2><h3 id="1-1-连接异常-ClassNotFoundException-SQLException"><a href="#1-1-连接异常-ClassNotFoundException-SQLException" class="headerlink" title="1.1 连接异常: ClassNotFoundException &#x2F; SQLException"></a>1.1 连接异常: <code>ClassNotFoundException</code> &#x2F; <code>SQLException</code></h3><h4 id="1-1-1-java-lang-ClassNotFoundException-com-mysql-cj-jdbc-Driver"><a href="#1-1-1-java-lang-ClassNotFoundException-com-mysql-cj-jdbc-Driver" class="headerlink" title="1.1.1 java.lang.ClassNotFoundException: com.mysql.cj.jdbc.Driver"></a>1.1.1 <code>java.lang.ClassNotFoundException: com.mysql.cj.jdbc.Driver</code></h4><p><strong>问题描述</strong>: JVM 在运行时无法在 Classpath (类路径) 中找到指定的 JDBC 驱动类。</p>
<p><strong>根本原因</strong>: <strong>JDBC 驱动的 JAR 包没有被正确地添加到项目中。</strong></p>
<p><strong>解决方案</strong>:</p>
<ol>
<li><strong>检查依赖管理工具 (Maven&#x2F;Gradle)</strong>:<ul>
<li>打开 <code>pom.xml</code> (Maven) 或 <code>build.gradle</code> (Gradle) 文件。</li>
<li>确认你已经添加了正确的数据库驱动依赖，例如 <code>&lt;dependency&gt;&lt;groupId&gt;com.mysql&lt;/groupId&gt;...&lt;/dependency&gt;</code>。</li>
<li>检查 <code>groupId</code>, <code>artifactId</code>, <code>version</code> 是否拼写正确。</li>
<li>刷新或重新导入你的项目依赖，确保 IDE 已经将 JAR 包下载到本地仓库并添加到项目中。</li>
</ul>
</li>
<li><strong>检查手动导入的 JAR 包</strong>:<ul>
<li>如果你是手动管理 JAR 包，请确保驱动 JAR 文件（如 <code>mysql-connector-j-8.x.x.jar</code>）已经被复制到项目的 <code>lib</code> 目录下。</li>
<li>在 IDE (Eclipse&#x2F;IntelliJ IDEA) 中，检查项目的构建路径 (Build Path) 或模块依赖 (Module Dependencies)，确认这个 JAR 文件已经被明确地添加为库。</li>
</ul>
</li>
<li><strong>检查部署环境 (Tomcat 等)</strong>:<ul>
<li>如果是在 Web 服务器（如 Tomcat）上运行，请确保驱动 JAR 包被放置在 <code>WEB-INF/lib</code> 目录下，这样它才能被 Web 应用程序的类加载器找到。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-1-2-java-sql-SQLException-No-suitable-driver-found-for-jdbc-mysql"><a href="#1-1-2-java-sql-SQLException-No-suitable-driver-found-for-jdbc-mysql" class="headerlink" title="1.1.2 java.sql.SQLException: No suitable driver found for jdbc:mysql://..."></a>1.1.2 <code>java.sql.SQLException: No suitable driver found for jdbc:mysql://...</code></h4><p><strong>问题描述</strong>: <code>DriverManager</code> 已经成功加载，但在其已注册的驱动列表中，没有一个驱动能够识别并处理你提供的数据库连接 URL。</p>
<p><strong>常见原因与解决方案</strong>:</p>
<ol>
<li><strong>驱动未加载 (根因同上)</strong>: 这是最常见的原因。虽然没有报 <code>ClassNotFoundException</code>，但驱动确实没被加载和注册。请先按照上面 <code>ClassNotFoundException</code> 的解决方案排查。</li>
<li><strong>URL 拼写错误</strong>: 仔细检查你的 JDBC URL 字符串。<ul>
<li>协议部分是否正确？<code>jdbc:mysql://</code>，<code>jdbc:oracle:thin:@</code>。一个字母的错误都会导致匹配失败。</li>
<li>主机名、端口、数据库名是否正确？</li>
</ul>
</li>
<li><strong>驱动与数据库版本不兼容</strong>:<ul>
<li>例如，使用非常老的 MySQL 驱动 (5.x) 去连接最新的 MySQL 数据库 (8.x)，或者反之，可能会导致驱动无法正确处理连接。请确保驱动版本与你的数据库版本大致匹配。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-1-3-java-sql-SQLException-Access-denied-for-user-root-localhost"><a href="#1-1-3-java-sql-SQLException-Access-denied-for-user-root-localhost" class="headerlink" title="1.1.3 java.sql.SQLException: Access denied for user &#39;root&#39;@&#39;localhost&#39;"></a>1.1.3 <code>java.sql.SQLException: Access denied for user &#39;root&#39;@&#39;localhost&#39;</code></h4><p><strong>问题描述</strong>: 数据库服务器拒绝了你的连接请求。</p>
<p><strong>原因与解决方案</strong>:</p>
<ol>
<li><strong>用户名或密码错误</strong>: 这是最直接的原因。请再三确认你在代码中使用的用户名和密码与数据库中设置的完全一致。注意区分大小写，以及密码中是否包含特殊字符。</li>
<li><strong>权限问题</strong>:<ul>
<li>你使用的数据库用户可能没有从你的应用程序所在的主机（例如 <code>localhost</code> 或某个 IP 地址）连接的权限。</li>
<li>登录到数据库，检查用户权限。在 MySQL 中，可以使用 <code>SELECT user, host FROM mysql.user;</code> 查看。如果 <code>host</code> 字段是 <code>localhost</code>，那么该用户只能从数据库服务器本机登录。你需要创建一个允许从 <code>%</code> (任何主机) 或你应用服务器的特定 IP 登录的用户，或者修改现有用户的 <code>host</code>。</li>
</ul>
</li>
<li><strong>防火墙</strong>: 检查数据库服务器或网络中的防火墙是否阻止了来自应用服务器对数据库端口（如 MySQL 的 3306）的访问。</li>
</ol>
<hr>
<h3 id="1-2-中文乱码问题"><a href="#1-2-中文乱码问题" class="headerlink" title="1.2 中文乱码问题"></a>1.2 中文乱码问题</h3><p><strong>问题描述</strong>: 向数据库中插入中文字符后，在数据库客户端查看时显示为 <code>???</code> 或乱码；或者从数据库读取出的中文字符在 Java 程序中显示为乱码。</p>
<p><strong>根本原因</strong>: 字符编码不一致。涉及的环节包括：<strong>Java 源代码文件编码</strong>、<strong>JVM 运行环境编码</strong>、<strong>JDBC 连接编码</strong>、<strong>数据库服务器编码</strong>、<strong>数据库表&#x2F;字段编码</strong>。任何一个环节出错都可能导致乱码。</p>
<p><strong>解决方案 (系统性排查)</strong>:</p>
<ol>
<li><p><strong>统一数据库编码</strong>: 确保你的数据库、表、字段都使用统一的字符集，<strong>强烈推荐 <code>utf8mb4</code></strong> (对于 MySQL) 或 <code>UTF-8</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE my_db <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> my_table (...) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置 JDBC 连接 URL</strong>: 这是<strong>最关键</strong>的一步。在 JDBC URL 中明确指定连接使用的字符编码。</p>
<ul>
<li><strong>MySQL</strong>: <code>jdbc:mysql://localhost:3306/my_db?characterEncoding=utf8</code></li>
</ul>
</li>
<li><p><strong>检查 Java 源代码文件编码</strong>: 确保你的 <code>.java</code> 文件是以 UTF-8 编码保存的。在 IDE (Eclipse&#x2F;IntelliJ IDEA) 的设置中可以全局配置。</p>
</li>
<li><p><strong>检查应用服务器配置 (如 Tomcat)</strong>:</p>
<ul>
<li>在 Tomcat 的 <code>server.xml</code> 中，为 <code>&lt;Connector&gt;</code> 添加 <code>URIEncoding=&quot;UTF-8&quot;</code> 属性，以确保 GET 请求参数正确解码。</li>
<li>在 Java Web 应用中，使用过滤器 (Filter) 来统一设置所有请求和响应的编码为 <code>UTF-8</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-3-资源泄露-Resource-Leak-与内存溢出-OutOfMemoryError"><a href="#1-3-资源泄露-Resource-Leak-与内存溢出-OutOfMemoryError" class="headerlink" title="1.3 资源泄露 (Resource Leak) 与内存溢出 (OutOfMemoryError)"></a>1.3 资源泄露 (Resource Leak) 与内存溢出 (OutOfMemoryError)</h3><p><strong>问题描述</strong>: 应用程序运行一段时间后，性能逐渐下降，最终抛出 “Too many connections” 错误或 <code>OutOfMemoryError</code>，然后崩溃。</p>
<p><strong>根本原因</strong>: <strong><code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 等 JDBC 资源在使用完毕后没有被正确关闭</strong>。这会导致连接池中的连接被耗尽，或者 <code>ResultSet</code> 缓存的数据占满内存。</p>
<p><strong>解决方案</strong>:</p>
<ol>
<li><p><strong>强制使用 <code>try-with-resources</code></strong>: 这是<strong>根治</strong>此问题的最佳方法。将所有实现了 <code>AutoCloseable</code> 接口的资源（<code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 等）都放在 <code>try()</code> 的括号内声明。Java 编译器会保证它们在任何情况下都被自动、安全地关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ...; <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> ...; <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ...) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码审查</strong>: 如果是维护旧代码，需要仔细审查所有 JDBC 操作，确保每个 <code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 都在 <code>finally</code> 块中有对应的 <code>close()</code> 调用，并且 <code>close()</code> 本身也被 <code>try-catch</code> 包围。</p>
</li>
<li><p><strong>使用连接池监控</strong>: 像 Druid 这样的连接池提供了强大的监控功能，可以帮你检测和定位未关闭的连接。开启 “removeAbandoned” (移除被遗弃的连接) 等配置项可以在生产环境中作为一道防线，但最好的方式还是从代码层面解决问题。</p>
</li>
<li><p><strong>处理大结果集</strong>: 如果查询返回的数据量非常大，即使正确关闭了资源，也可能在处理过程中导致内存溢出。此时应考虑：</p>
<ul>
<li><strong>分页查询</strong>: 只查询当前需要的数据。</li>
<li><strong>流式读取</strong>: 使用 <code>statement.setFetchSize()</code> 来控制一次从数据库拉取的数据量，避免一次性加载所有结果到内存。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2. 单元测试"></a>2. 单元测试</h2><h3 id="2-1-为什么需要为-DAO-层编写单元测试"><a href="#2-1-为什么需要为-DAO-层编写单元测试" class="headerlink" title="2.1 为什么需要为 DAO 层编写单元测试"></a>2.1 为什么需要为 DAO 层编写单元测试</h3><p>直接在开发、测试甚至生产数据库上进行调试是一种低效且危险的做法。为 DAO (Data Access Object) 层编写单元测试能带来诸多好处：</p>
<ol>
<li><strong>快速验证</strong>: 可以在不启动整个应用程序的情况下，快速、独立地验证 SQL 语句和 JDBC 逻辑是否正确。</li>
<li><strong>隔离性</strong>: 测试在隔离的环境中运行，不依赖于外部数据库的状态，也不会污染开发数据库。每次测试都可以从一个干净、可预测的数据库状态开始。</li>
<li><strong>回归防护</strong>: 建立一套完整的测试用例后，每当修改了 DAO 层的代码或 SQL 语句，只需运行一遍测试，就能立即发现是否引入了新的 bug（即回归问题）。</li>
<li><strong>提升开发效率</strong>: “测试驱动开发”(TDD) 理念鼓励先写测试再写实现，这能帮助开发者更清晰地思考接口设计和边界情况。</li>
<li><strong>自动化</strong>: 单元测试可以轻松地集成到持续集成&#x2F;持续部署 (CI&#x2F;CD) 流程中，实现自动化构建和质量保证。</li>
</ol>
<hr>
<h3 id="2-2-如何隔离对数据库的依赖？"><a href="#2-2-如何隔离对数据库的依赖？" class="headerlink" title="2.2 如何隔离对数据库的依赖？"></a>2.2 如何隔离对数据库的依赖？</h3><p>DAO 层的测试有一个核心挑战：它天生就依赖于数据库。如果直接连接开发数据库，测试会变得：</p>
<ul>
<li><strong>慢</strong>: 涉及网络 I&#x2F;O，运行速度慢。</li>
<li><strong>不稳定</strong>: 依赖于网络和开发数据库的可用性。</li>
<li><strong>不干净</strong>: 测试会产生脏数据，影响其他开发者。</li>
</ul>
<p><strong>解决方案：使用内存数据库 (In-Memory Database)</strong></p>
<p>内存数据库是一种将数据存储在主内存（RAM）中的数据库。它具有以下特性，使其成为单元测试的理想选择：</p>
<ul>
<li><strong>极速</strong>: 所有操作都在内存中完成，没有磁盘 I&#x2F;O，速度飞快。</li>
<li><strong>易于集成</strong>: 通常以一个简单的 JAR 包形式提供，无需安装独立的数据库服务器。</li>
<li><strong>生命周期短暂</strong>: 数据库实例可以与 JVM 的生命周期绑定。测试开始时创建，测试结束时所有数据随之销毁，每次测试都是全新的开始。</li>
<li><strong>兼容性</strong>: 许多内存数据库（如 H2）提供了与标准 SQL 和主流数据库（如 MySQL, PostgreSQL）的兼容模式，使得 SQL 语句可以无缝运行。</li>
</ul>
<p><strong>H2 数据库</strong> 是 Java 社区中最流行、最常用的内存数据库之一，非常适合用于单元测试。</p>
<hr>
<h3 id="2-3-实战-1"><a href="#2-3-实战-1" class="headerlink" title="2.3 实战"></a>2.3 实战</h3><p>使用 JUnit 5（当前主流的 Java 测试框架）和 H2 数据库来为之前创建的 <code>UserDAOImpl</code> 编写测试。</p>
<p><strong>步骤 1: 添加测试依赖 (Maven <code>pom.xml</code>)</strong></p>
<p>这些依赖的作用域通常是 <code>test</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JUnit 5 (Jupiter) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- H2 Database --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.224<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 准备测试用的数据库环境</strong></p>
<p>我们需要一个机制，在<strong>每个测试方法运行前</strong>创建一个干净的 H2 数据库和表，并在<strong>测试方法运行后</strong>销毁它。JUnit 5 提供了 <code>@BeforeEach</code> 和 <code>@AfterEach</code> 注解可以完成这种操作。</p>
<p>在测试资源目录 (<code>src/test/resources</code>) 下创建一个 SQL 脚本来初始化数据库。</p>
<p><strong><code>src/test/resources/schema.sql</code> (建表语句)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong><code>src/test/resources/data.sql</code> (初始数据)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users (name, email) <span class="keyword">VALUES</span> (<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;alice@test.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> users (name, email) <span class="keyword">VALUES</span> (<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;bob@test.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 编写 <code>UserDAOImplTest.java</code></strong></p>
<p>这个测试类通常放在 <code>src/test/java</code> 目录下，包结构与被测试的类对应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserDAOImplTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> UserDAO userDAO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有测试运行前执行一次，用于建立 H2 数据库连接</span></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setupDatabase</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// H2 内存数据库的连接 URL，MODE=MySQL 使其兼容 MySQL 语法</span></span><br><span class="line">        <span class="comment">// DB_CLOSE_DELAY=-1 防止连接关闭时数据库被清空</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:h2:mem:testdb;MODE=MySQL;DB_CLOSE_DELAY=-1&quot;</span>;</span><br><span class="line">        connection = DriverManager.getConnection(url, <span class="string">&quot;sa&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在每个测试方法运行前执行</span></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setupTestData</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        userDAO = <span class="keyword">new</span> <span class="title class_">UserDAOImpl</span>(connection); <span class="comment">// 假设 DAO 实现可以接收一个 Connection</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次测试前，清空并重建表结构和数据</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.createStatement()) &#123;</span><br><span class="line">            stmt.execute(<span class="string">&quot;DROP TABLE IF EXISTS users&quot;</span>);</span><br><span class="line">            <span class="comment">// 这里可以写一个辅助方法来执行 SQL 脚本</span></span><br><span class="line">            stmt.execute(<span class="string">&quot;CREATE TABLE users (id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50), email VARCHAR(100))&quot;</span>);</span><br><span class="line">            stmt.execute(<span class="string">&quot;INSERT INTO users (id, name, email) VALUES (1, &#x27;Alice&#x27;, &#x27;alice@test.com&#x27;)&quot;</span>);</span><br><span class="line">            stmt.execute(<span class="string">&quot;INSERT INTO users (id, name, email) VALUES (2, &#x27;Bob&#x27;, &#x27;bob@test.com&#x27;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFindUserById_existingUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDAO.findUserById(<span class="number">1</span>);</span><br><span class="line">        assertNotNull(user, <span class="string">&quot;User should not be null&quot;</span>);</span><br><span class="line">        assertEquals(<span class="number">1</span>, user.getId());</span><br><span class="line">        assertEquals(<span class="string">&quot;Alice&quot;</span>, user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFindUserById_nonExistingUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDAO.findUserById(<span class="number">99</span>);</span><br><span class="line">        assertNull(user, <span class="string">&quot;User should be null for non-existing ID&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFindAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = userDAO.findAllUsers();</span><br><span class="line">        assertNotNull(users);</span><br><span class="line">        assertEquals(<span class="number">2</span>, users.size(), <span class="string">&quot;Should find 2 users&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testAddUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        newUser.setName(<span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">        newUser.setEmail(<span class="string">&quot;charlie@test.com&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        userDAO.addUser(newUser);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 验证是否真的插入成功</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">foundUser</span> <span class="operator">=</span> userDAO.findUserByEmail(<span class="string">&quot;charlie@test.com&quot;</span>); <span class="comment">// 假设有这个方法</span></span><br><span class="line">        assertNotNull(foundUser);</span><br><span class="line">        assertEquals(<span class="string">&quot;Charlie&quot;</span>, foundUser.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他测试，如 updateUser, deleteUser ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在所有测试运行后执行一次，关闭连接</span></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tearDownDatabase</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 为了让测试代码能够控制数据库连接，通常需要对原有的 <code>UserDAOImpl</code> 做一些调整，比如提供一个构造函数，允许外部注入一个 <code>Connection</code> 或 <code>DataSource</code>。这是实现可测试性的常见模式。</p>
<p><strong>测试要点总结</strong>:</p>
<ol>
<li><strong>使用 H2 内存数据库</strong>：在 <code>pom.xml</code> 中添加依赖，并使用 <code>jdbc:h2:mem:...</code> URL。</li>
<li><strong>JUnit 5 生命周期注解</strong>:<ul>
<li><code>@BeforeAll</code>: 在所有测试之前初始化数据库连接。</li>
<li><code>@BeforeEach</code>: 在每个测试方法之前，创建干净的表和测试数据。这是保证测试<strong>独立性</strong>的关键。</li>
<li><code>@AfterAll</code>: 在所有测试之后关闭连接。</li>
</ul>
</li>
<li><strong>断言 (Assertions)</strong>: 使用 <code>assertEquals</code>, <code>assertNotNull</code>, <code>assertTrue</code> 等 JUnit 的断言方法来验证 DAO 方法的返回值是否符合预期。</li>
<li><strong>覆盖各种场景</strong>: 不仅要测试成功的情况（如找到用户），也要测试失败或边界情况（如找不到用户、插入 null 数据等）。</li>
</ol>
<hr>
<h2 id="3-日志与调试"><a href="#3-日志与调试" class="headerlink" title="3. 日志与调试"></a>3. 日志与调试</h2><h3 id="3-1-为什么需要日志？"><a href="#3-1-为什么需要日志？" class="headerlink" title="3.1 为什么需要日志？"></a>3.1 为什么需要日志？</h3><p>在开发过程中，可以通过 <code>System.out.println()</code> 来打印信息或使用 Debugger 逐行调试。但一旦应用程序部署到服务器上，这些方法就失效了。这时，<strong>日志 (Logging)</strong> 就成了我们了解应用程序内部运行状态的唯一窗口。</p>
<p>对于 JDBC 编程而言，日志尤其重要，因为：</p>
<ol>
<li><strong>SQL 可见性</strong>: 能够清晰地看到应用程序<strong>实际执行</strong>的 SQL 语句是什么，以及绑定的参数是什么。这是排查 SQL 语法错误、逻辑错误（如 <code>WHERE</code> 条件不符预期）的最直接方式。</li>
<li><strong>性能监控</strong>: 记录每条 SQL 的执行耗时，可以帮助我们快速定位慢查询，找到性能瓶颈。</li>
<li><strong>异常追踪</strong>: 当 <code>SQLException</code> 发生时，日志可以记录下完整的异常堆栈信息、上下文参数以及当时的 SQL，为事后分析问题提供了宝贵的线索。</li>
<li><strong>审计与安全</strong>: 在某些场景下，记录关键的数据库操作（谁、在什么时间、执行了什么 SQL）是合规性审计的要求。</li>
</ol>
<p><strong>日志框架的选择</strong>:</p>
<p>在 Java 世界中，我们通常不直接使用 <code>java.util.logging</code>，而是选择更强大、更灵活的日志框架。</p>
<ul>
<li><strong>SLF4J (Simple Logging Facade for Java)</strong>: 这是一个<strong>日志门面 (Facade)</strong>，它本身不实现日志功能，而是提供一套标准的 API。</li>
<li><strong>Logback &#x2F; Log4j2</strong>: 这是 SLF4J 背后具体的<strong>日志实现 (Implementation)</strong>。<br><strong>最佳实践</strong>：在代码中<strong>始终面向 SLF4J API 编程</strong>，而在配置中选择 Logback 或 Log4j2 作为实现。这样你的代码就与具体的日志实现解耦了。</li>
</ul>
<hr>
<h3 id="3-2-在-JDBC-代码中添加日志"><a href="#3-2-在-JDBC-代码中添加日志" class="headerlink" title="3.2 在 JDBC 代码中添加日志"></a>3.2 在 JDBC 代码中添加日志</h3><p>让我们看看如何在一个 DAO 方法中有效地使用日志。</p>
<p><strong>步骤 1: 添加 SLF4J 和 Logback 依赖 (Maven <code>pom.xml</code>)</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在 DAO 实现类中添加日志记录</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDAO</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取 Logger 实例，通常为静态常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(UserDAOImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email FROM users WHERE id = ?&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用 DEBUG 级别记录将要执行的 SQL 和参数</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Executing SQL: &#123;&#125; with parameters: &#123;&#125;&quot;</span>, sql, id);</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">            </span><br><span class="line">            pstmt.setInt(<span class="number">1</span>, id);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                    user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                    <span class="comment">// ... map result set to user object ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// 3. 使用 ERROR 级别记录异常</span></span><br><span class="line">            logger.error(<span class="string">&quot;Failed to find user by ID: &#123;&#125;&quot;</span>, id, e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 4. 使用 INFO 或 DEBUG 级别记录执行耗时</span></span><br><span class="line">        logger.info(<span class="string">&quot;SQL execution time: &#123;&#125; ms&quot;</span>, (endTime - startTime));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>日志级别的使用约定</strong>:</p>
<ul>
<li><code>ERROR</code>: 严重错误，影响程序正常运行。<strong>必须</strong>记录异常堆栈信息。</li>
<li><code>WARN</code>: 警告，潜在的问题或非预期的技术性事件，但程序仍可继续运行。</li>
<li><code>INFO</code>: 关键业务流程的进度信息，如“用户登录成功”、“订单创建完毕”，或重要的性能指标。</li>
<li><code>DEBUG</code>: 用于开发和调试的详细信息，如 SQL 语句、参数、方法入参&#x2F;出参等。</li>
<li><code>TRACE</code>: 比 DEBUG 更细粒度的信息，用于追踪代码执行的详细路径。</li>
</ul>
<hr>
<h3 id="3-3-使用专业的-JDBC-日志代理-拦截器-更强大的方式"><a href="#3-3-使用专业的-JDBC-日志代理-拦截器-更强大的方式" class="headerlink" title="3.3 使用专业的 JDBC 日志代理&#x2F;拦截器 (更强大的方式)"></a>3.3 使用专业的 JDBC 日志代理&#x2F;拦截器 (更强大的方式)</h3><p>手动在每个 DAO 方法中添加日志虽然可行，但很繁琐且容易遗漏。更专业、更强大的方式是使用能够<strong>自动拦截</strong> JDBC 调用并记录日志的工具。</p>
<p><strong>p6spy</strong>:</p>
<ul>
<li><strong>是什么</strong>: 一个开源的 JDBC 驱动代理。它把自己“包装”在你的真实 JDBC 驱动外面，拦截所有对数据库的调用（包括执行的 SQL、参数、耗时等），并将这些信息输出到日志中，而你<strong>无需修改任何一行 DAO 代码</strong>。</li>
<li><strong>优点</strong>: 非侵入式，配置简单，功能强大，可以格式化输出 SQL，非常适合在开发和测试环境中使用。</li>
</ul>
<p><strong>Druid 连接池的内置 Filter</strong>:</p>
<ul>
<li><p>如果你正在使用 Druid 连接池，它内置了强大的 <code>Filter</code> 链，可以轻松开启日志功能。</p>
</li>
<li><p><strong>配置 (<code>druid.properties</code>)</strong>:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stat 用于监控，log4j 或 log4j2 用于记录日志</span></span><br><span class="line"><span class="attr">druid.filters</span>=<span class="string">stat,log4j2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置 log4j2 filter 的属性</span></span><br><span class="line"><span class="attr">druid.filter.log4j2.statementExecutableSqlLogEnable</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>: 与连接池紧密集成，配置方便，性能较好。</p>
</li>
</ul>
<p><strong>使用这些工具后，你可以在日志文件中看到类似这样的输出，非常清晰</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEBUG 2023-10-27 10:30:00 [com.yourapp.UserDAOImpl] - ==&gt; Preparing: SELECT id, name, email FROM users WHERE id = ?</span><br><span class="line">DEBUG 2023-10-27 10:30:00 [com.yourapp.UserDAOImpl] - ==&gt; Parameters: 1(Integer)</span><br><span class="line">INFO  2023-10-27 10:30:00 [com.yourapp.UserDAOImpl] - &lt;== Total: 1</span><br><span class="line">INFO  2023-10-27 10:30:00 [com.yourapp.UserDAOImpl] - Time Elapsed: 5ms</span><br></pre></td></tr></table></figure>

<p>(这是模仿 MyBatis 日志的风格，但 p6spy 和 Druid 的输出格式类似)</p>
<hr>
<h3 id="3-4-调试技巧"><a href="#3-4-调试技巧" class="headerlink" title="3.4 调试技巧"></a>3.4 调试技巧</h3><p>当遇到复杂的数据库问题时，除了日志，调试器 (Debugger) 也可以为你提供帮助。</p>
<ol>
<li><strong>断点位置</strong>:<ul>
<li>在 <code>PreparedStatement</code> 执行前（<code>executeQuery()</code> &#x2F; <code>executeUpdate()</code>）设置断点，检查 SQL 语句是否拼接正确（对于动态 SQL），以及绑定的参数值是否符合预期。</li>
<li>在 <code>ResultSet</code> 遍历循环内设置断点，检查从数据库取出的原始数据是否正确，是否存在 <code>null</code> 值或意外的格式。</li>
<li>在 <code>catch (SQLException e)</code> 块的第一行设置断点，当异常发生时，可以立即暂停程序，检查 <code>e</code> 对象中的 <code>errorCode</code>, <code>sqlState</code> 和 <code>message</code>，获取最直接的错误原因。</li>
</ul>
</li>
<li><strong>检查变量状态</strong>:<ul>
<li><strong><code>Connection</code> 对象</strong>: 检查其 <code>isClosed()</code>, <code>getAutoCommit()</code> 等状态，确认连接是否正常，事务模式是否正确。</li>
<li><strong><code>PreparedStatement</code> 对象</strong>: 在 Debugger 的监视窗口中，有时可以（取决于驱动和 IDE 的实现）看到 <code>pstmt</code> 内部绑定的参数值。</li>
<li><strong><code>ResultSet</code> 对象</strong>: 检查其内部状态，确认是否包含数据。</li>
</ul>
</li>
<li><strong>结合数据库客户端</strong>:<ul>
<li>当你从日志或 Debugger 中获取到<strong>最终执行的 SQL 和参数</strong>后，如果仍然不明白为什么结果不符合预期，<strong>立即将这条 SQL 语句复制到数据库客户端工具（如 Navicat, DBeaver, MySQL Workbench）中，手动执行一遍</strong>。</li>
<li>这可以帮助你判断问题是出在 Java 代码逻辑层面，还是 SQL 语句本身就有问题。这是<strong>最高效</strong>的调试方法之一。</li>
</ul>
</li>
</ol>
<hr>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/Mysql/" class="post-title-link" itemprop="url">Mysql</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-19 15:05:46" itemprop="dateCreated datePublished" datetime="2025-09-19T15:05:46+08:00">2025-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-04 12:30:52" itemprop="dateModified" datetime="2025-12-04T12:30:52+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">数据库与持久化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、数据库基础核心"><a href="#一、数据库基础核心" class="headerlink" title="一、数据库基础核心"></a>一、数据库基础核心</h1><h2 id="1-数据库基本概念"><a href="#1-数据库基本概念" class="headerlink" title="1. 数据库基本概念"></a>1. 数据库基本概念</h2><h3 id="1-1-数据库、数据库管理系统、SQL"><a href="#1-1-数据库、数据库管理系统、SQL" class="headerlink" title="1.1 数据库、数据库管理系统、SQL"></a>1.1 数据库、数据库管理系统、SQL</h3><h4 id="1-1-1-数据库-Database-DB"><a href="#1-1-1-数据库-Database-DB" class="headerlink" title="1.1.1 数据库 (Database, DB)"></a>1.1.1 数据库 (Database, DB)</h4><h5 id="1-核心定义"><a href="#1-核心定义" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h5><p>数据库是一个<strong>长期存储</strong>在计算机内、<strong>有组织的</strong>、可<strong>共享</strong>的大量数据的集合。</p>
<p>简单来说，数据库就是一个专门用来<strong>存放和管理数据</strong>的“电子仓库”。这个仓库按照一定的规则（数据模型）将数据分门别类地整理好，以便于我们后续高效地进行增、删、改、查等操作。</p>
<hr>
<h5 id="2-生活中的类比"><a href="#2-生活中的类比" class="headerlink" title="2. 生活中的类比"></a>2. 生活中的类比</h5><table>
<thead>
<tr>
<th align="left">数据库概念</th>
<th align="left">图书馆类比</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据库 (Database)</strong></td>
<td align="left"><strong>整个图书馆</strong></td>
<td align="left">图书馆是所有图书的集合，是一个庞大而有组织的知识仓库。</td>
</tr>
<tr>
<td align="left"><strong>数据表 (Table)</strong></td>
<td align="left"><strong>书架</strong></td>
<td align="left">图书馆按类别（如“文学”、“历史”、“科技”）将书放在不同的书架上。</td>
</tr>
<tr>
<td align="left"><strong>行 (Row &#x2F; Record)</strong></td>
<td align="left"><strong>每一本书</strong></td>
<td align="left">书架上的每一本书都是一个独立的实体，包含完整的信息。</td>
</tr>
<tr>
<td align="left"><strong>列 (Column &#x2F; Field)</strong></td>
<td align="left"><strong>书的信息项</strong></td>
<td align="left">每本书都有固定的信息项，如“书名”、“作者”、“出版社”、“ISBN号”。</td>
</tr>
<tr>
<td align="left"><strong>数据 (Data)</strong></td>
<td align="left"><strong>具体的书本信息</strong></td>
<td align="left">比如“《三体》”、“刘慈欣”、“重庆出版社”、“978-7-5366-9293-0”。</td>
</tr>
</tbody></table>
<hr>
<h5 id="3-核心组成部分（以关系型数据库为例）"><a href="#3-核心组成部分（以关系型数据库为例）" class="headerlink" title="3. 核心组成部分（以关系型数据库为例）"></a>3. 核心组成部分（以关系型数据库为例）</h5><p>在像 MySQL 这样的关系型数据库中，数据主要通过以下几个核心组件来组织：</p>
<ul>
<li><strong>数据表 (Table)</strong>: 数据库中存储数据的基本单位。一个数据库通常包含多个表，每个表用于存储特定类型实体的信息。例如，一个图书馆数据库可能有 <code>书籍表 (books)</code>、<code>书架表 (bookshelf)</code> 和 <code>书籍类别表 (category)</code>。</li>
<li><strong>行 (Row)</strong>: 也称为“记录 (Record)”，是表中的一个条目，代表一个具体的实体。例如，<code>书籍表</code>中的一行就代表一个特定的书籍（如《三体》的所有信息）。</li>
<li><strong>列 (Column)</strong>: 也称为“字段 (Field)”，是表中的一个垂直栏，定义了该列中所有数据的类型和含义。例如，<code>书籍表</code>中的“书名”、“作者”、“借阅次数”列。</li>
</ul>
<p><strong>示例：一个简单的 <code>书籍表 (books)</code></strong></p>
<table>
<thead>
<tr>
<th align="left">书籍编号 (id)</th>
<th align="left">书名 (name)</th>
<th align="left">作者 (author)</th>
<th align="left">借阅次数(borrow_num)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2023001</td>
<td align="left">《三体》</td>
<td align="left">刘慈欣</td>
<td align="left">2145</td>
</tr>
<tr>
<td align="left">2023002</td>
<td align="left">《橘子不是唯一的水果》</td>
<td align="left">珍妮特·温特森</td>
<td align="left">4150</td>
</tr>
<tr>
<td align="left">2023003</td>
<td align="left">《共产党宣言》</td>
<td align="left">卡尔·马克思、弗里德里希·恩格斯</td>
<td align="left">10458</td>
</tr>
</tbody></table>
<p>在这个例子中：</p>
<ul>
<li><code>books</code> 是<strong>表名</strong>。</li>
<li>整个表格就是一个<strong>数据表</strong>。</li>
<li>每一行（如 <code>2023001, 《三体》, 刘慈欣, 2145</code>）就是一条<strong>记录</strong>。</li>
<li>每一列（如 <code>书名</code>）就是一个<strong>字段</strong>。</li>
</ul>
<hr>
<h4 id="1-1-2-数据库管理系统（DataBase-Management-System，DBMS）"><a href="#1-1-2-数据库管理系统（DataBase-Management-System，DBMS）" class="headerlink" title="1.1.2 数据库管理系统（DataBase Management System，DBMS）"></a>1.1.2 数据库管理系统（DataBase Management System，DBMS）</h4><h5 id="1-核心定义-1"><a href="#1-核心定义-1" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h5><p>如果说数据库（DB）是存放数据的“仓库”，那么<strong>数据库管理系统（DBMS）</strong> 就是管理这个仓库的**“管家”或“管理员软件”**。</p>
<p>它是一个位于用户&#x2F;应用程序与数据库之间的一层<strong>系统软件</strong>。我们所有对数据库的操作（增、删、改、查等），实际上都不是直接操作物理的数据文件，而是通过向 DBMS 发出指令，由 DBMS 来代我们完成。</p>
<p><strong>核心关系：</strong><code>用户/应用程序 (User/Application) &lt;--&gt; DBMS &lt;--&gt; 数据库 (Database)</code></p>
<p>DBMS 帮助我们<strong>科学地、有效地组织和管理数据</strong>，并隐藏了底层复杂的存储细节和操作过程，我们只需通过标准的接口（如 SQL 语言）与之交互即可。</p>
<hr>
<h5 id="2-图书馆类比"><a href="#2-图书馆类比" class="headerlink" title="2. 图书馆类比"></a>2. 图书馆类比</h5><p>我们继续用图书馆的例子来理解 DBMS 的角色。</p>
<table>
<thead>
<tr>
<th align="left">数据库概念</th>
<th align="left">图书馆类比</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据库 (DB)</strong></td>
<td align="left"><strong>整个图书馆</strong></td>
<td align="left">数据的集合。</td>
</tr>
<tr>
<td align="left"><strong>DBMS</strong></td>
<td align="left"><strong>整个图书馆管理团队和系统</strong></td>
<td align="left">这不仅包括图书管理员，还包括借阅系统、安全系统、图书编目系统等一整套管理机制。</td>
</tr>
<tr>
<td align="left">用户（你）</td>
<td align="left">读者</td>
<td align="left">需要从图书馆获取信息或知识的人。</td>
</tr>
<tr>
<td align="left">SQL 语言</td>
<td align="left">你对管理员说的话</td>
<td align="left">“请帮我找一下刘慈欣写的《三体》这本书。”</td>
</tr>
<tr>
<td align="left">DBMS 的工作</td>
<td align="left">管理员的操作</td>
<td align="left">1. <strong>查询</strong>：管理员使用电脑系统（索引）快速定位到《三体》在“科幻区-K排-3架”。<br> 2. <strong>存取</strong>：走到书架，把书取给你。<br> 3. <strong>并发控制</strong>：如果最后一本《三体》已经被别人借走，管理员会告诉你“已被借阅，请稍后再来”，而不是让你和另一个人为抢一本书打起来。<br> 4. <strong>安全</strong>：只有持有效借书证的读者才能借书，确保了图书的安全。</td>
</tr>
</tbody></table>
<hr>
<h5 id="3-核心功能与职责"><a href="#3-核心功能与职责" class="headerlink" title="3. 核心功能与职责"></a>3. 核心功能与职责</h5><p>DBMS 的强大之处在于它提供了一整套完整的数据管理功能，主要包括以下几个方面：</p>
<ol>
<li><strong>数据定义功能 (Data Definition)</strong><ul>
<li>DBMS 允许用户定义数据库的结构，包括创建表、定义字段（列）的数据类型、设置约束等。</li>
</ul>
</li>
<li><strong>数据操作功能 (Data Manipulation)</strong><ul>
<li>提供让用户对数据库中的数据进行增、删、改、查的各种操作。</li>
</ul>
</li>
<li><strong>数据库运行管理 (Database Operation &amp; Control)</strong><ul>
<li><strong>并发控制 (Concurrency Control)</strong>：当多个用户同时访问数据库时，DBMS 通过锁机制等技术，确保数据操作的隔离性和正确性，防止数据错乱。</li>
<li><strong>事务管理 (Transaction Management)</strong>：保证一系列操作要么全部成功，要么全部失败（原子性），确保数据状态的一致性。这是数据库可靠性的基石（详见 ACID 章节）。</li>
<li><strong>安全性控制 (Security Control)</strong>：提供用户身份验证、权限授予与管理机制，确保只有授权用户才能访问和操作指定的数据。</li>
<li><strong>完整性控制 (Integrity Control)</strong>：通过主键、外键、非空等约束，确保存入数据库的数据符合业务规则，保证数据的准确性和相容性。</li>
</ul>
</li>
<li><strong>数据备份与恢复 (Backup &amp; Recovery)</strong><ul>
<li>提供数据库备份和恢复的机制，当发生硬件故障、软件错误或人为误操作时，能将数据库恢复到某个正常的状态，确保数据不丢失。</li>
</ul>
</li>
<li><strong>性能优化 (Performance Optimization)</strong><ul>
<li>DBMS 内部包含查询优化器（Query Optimizer），它会自动分析用户的查询请求，并生成一个最高效的执行计划去获取数据（例如，决定是否使用索引、使用哪种连接方式等）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-1-3-SQL（Structured-Query-Language）"><a href="#1-1-3-SQL（Structured-Query-Language）" class="headerlink" title="1.1.3 SQL（Structured Query Language）"></a>1.1.3 SQL（Structured Query Language）</h4><h5 id="1-核心定义-2"><a href="#1-核心定义-2" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h5><p><strong>SQL</strong> 是一种专门为<strong>管理关系型数据库管理系统（RDBMS）</strong> 而设计的<strong>标准化编程语言</strong>。</p>
<p>简单来说，如果 DBMS 是“仓库管理员”，那么 SQL 就是我们<strong>与这位管理员沟通时必须使用的、统一的、标准的“工作语言”</strong>。通过 SQL，我们可以向 DBMS 下达指令，让它去执行数据的定义、查询、修改和控制等一系列操作。</p>
<p>SQL 是一种<strong>声明式语言（Declarative Language）</strong>。这意味着你只需要告诉 DBMS <strong>“你想要什么（What）”</strong>，而不需要告诉它**“该怎么做（How）”**。DBMS 内部的查询优化器会负责制定最高效的执行计划来完成你的指令。</p>
<hr>
<h5 id="2-图书馆类比-1"><a href="#2-图书馆类比-1" class="headerlink" title="2. 图书馆类比"></a>2. 图书馆类比</h5><table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">类比</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据库 (DB)</strong></td>
<td align="left">图书馆（所有藏书）</td>
<td align="left">数据的集合。</td>
</tr>
<tr>
<td align="left"><strong>DBMS</strong></td>
<td align="left">图书馆管理团队与系统</td>
<td align="left">管理数据的软件。</td>
</tr>
<tr>
<td align="left"><strong>SQL</strong></td>
<td align="left"><strong>你向管理员提出的、符合规范的请求指令</strong></td>
<td align="left">与 DBMS 沟通的语言。</td>
</tr>
</tbody></table>
<p><strong>场景：</strong></p>
<ul>
<li><strong>你 (用户)</strong>: “请帮我找出所有’村上春树’写的书。” ————&gt; <strong>SQL DQL 指令</strong>: <code>SELECT * FROM books WHERE author = &#39;村上春树&#39;</code></li>
<li><strong>你 (用户)</strong>: “请给我的实习生授予查询图书的权限。” ————&gt; <strong>SQL DCL 指令</strong>: <code>GRANT SELECT ON books TO &#39;intern_user&#39;</code></li>
</ul>
<p>SQL 就是这套标准、无歧义的指令集，确保了“仓库管理员”（DBMS）能够准确无误地理解并执行你的意图。</p>
<hr>
<h5 id="3-SQL-的主要组成部分"><a href="#3-SQL-的主要组成部分" class="headerlink" title="3. SQL 的主要组成部分"></a>3. SQL 的主要组成部分</h5><p>SQL 语言根据其功能，通常被划分为几个主要的类别。这部分内容在第二章有详细展开，这里我们先做一个概览性的介绍：</p>
<ul>
<li><strong>DDL (Data Definition Language) - 数据定义语言</strong><ul>
<li><strong>作用</strong>：用于定义和管理数据库的结构（“骨架”）。</li>
<li><strong>核心命令</strong>：<code>CREATE</code> (创建数据库、表等), <code>ALTER</code> (修改表结构), <code>DROP</code> (删除数据库、表等)。</li>
</ul>
</li>
<li><strong>DML (Data Manipulation Language) - 数据操作语言</strong><ul>
<li><strong>作用</strong>：用于操作数据库表中的具体数据（“血肉”）。</li>
<li><strong>核心命令</strong>：<code>INSERT</code> (插入数据), <code>UPDATE</code> (更新数据), <code>DELETE</code> (删除数据)。</li>
</ul>
</li>
<li><strong>DQL (Data Query Language) - 数据查询语言</strong><ul>
<li><strong>作用</strong>：用于从数据库中查询和检索数据。这是 SQL 中最常用、最核心的部分。</li>
<li><strong>核心命令</strong>：<code>SELECT</code>。</li>
</ul>
</li>
<li><strong>DCL (Data Control Language) - 数据控制语言</strong><ul>
<li><strong>作用</strong>：用于管理数据库的访问权限和安全级别。</li>
<li><strong>核心命令</strong>：<code>GRANT</code> (授予权限), <code>REVOKE</code> (撤销权限)。</li>
</ul>
</li>
<li><strong>TCL (Transaction Control Language) - 事务控制语言</strong><ul>
<li><strong>作用</strong>：用于管理数据库中的事务，确保数据操作的完整性和一致性。</li>
<li><strong>核心命令</strong>：<code>COMMIT</code> (提交事务), <code>ROLLBACK</code> (回滚事务), <code>SAVEPOINT</code> (设置保存点)。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-SQL-的标准化与方言-Dialects"><a href="#4-SQL-的标准化与方言-Dialects" class="headerlink" title="4. SQL 的标准化与方言 (Dialects)"></a>4. SQL 的标准化与方言 (Dialects)</h5><ul>
<li><strong>标准化</strong>: SQL 是由美国国家标准协会 (ANSI) 和国际标准化组织 (ISO) 维护的国际标准。这意味着，无论你使用 MySQL、Oracle 还是 SQL Server，核心的 SQL 语法（如 <code>SELECT...FROM...WHERE</code>）都是通用的。</li>
<li><strong>方言</strong>: 尽管有标准，但每个 DBMS 厂商在标准 SQL 的基础上，都会实现一些自己独有的函数或语法扩展，以提供更丰富的功能。这些特定于某个 DBMS 的 SQL 语法被称为“方言”。<ul>
<li><strong>MySQL&#x2F;MariaDB</strong>: 使用 <code>LIMIT</code> 语句来限制返回的行数。</li>
<li><strong>SQL Server</strong>: 使用 <code>TOP</code> 关键字。</li>
<li><strong>Oracle</strong>: 使用 <code>ROWNUM</code>。</li>
<li>虽然实现方式不同，但它们要解决的问题是相似的。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h3><p>数据模型是数据库的骨架，它定义了数据如何被组织、存储、关联和处理。选择正确的数据模型对于应用程序的性能和可扩展性至关重要。</p>
<h4 id="1-2-1-关系模型"><a href="#1-2-1-关系模型" class="headerlink" title="1.2.1 关系模型"></a>1.2.1 关系模型</h4><p>这是最传统、最广泛使用的数据模型，是所有关系型数据库（RDBMS）的基础。</p>
<ul>
<li><strong>核心思想</strong>: 将现实世界中的实体和它们之间的关系，通过二维<strong>表格 (Table)</strong> 的形式来表示。数据被组织在预定义好的行和列中。</li>
<li><strong>关键概念</strong>:<ul>
<li><strong>表 (Table &#x2F; Relation)</strong>: 数据的集合。</li>
<li><strong>行 (Row &#x2F; Tuple)</strong>: 表中的一条记录。</li>
<li><strong>列 (Column &#x2F; Attribute)</strong>: 描述记录的某个特定字段。</li>
<li><strong>模式 (Schema)</strong>: 表的结构定义，包括列名、数据类型、约束等。在关系模型中，模式是<strong>预先定义且固定的 (Schema-on-write)</strong>，写入数据前必须先定义好表的结构。</li>
</ul>
</li>
<li><strong>优点</strong>:<ul>
<li><strong>强一致性</strong>: 通过 ACID 事务保证数据的准确性和可靠性。</li>
<li><strong>低冗余</strong>: 通过范式化设计，可以最大限度地减少数据冗余。</li>
<li><strong>强大的查询能力</strong>: SQL 语言非常成熟，能够进行复杂的连接和聚合查询。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>扩展性差</strong>: 在海量数据下，水平扩展（增加服务器）比较复杂。</li>
<li><strong>模式僵化</strong>: 修改表结构（如增加一列）通常是“重”操作，不够灵活。</li>
</ul>
</li>
<li><strong>典型数据库</strong>: MySQL, PostgreSQL, Oracle.</li>
</ul>
<hr>
<h4 id="1-2-2-键值模型"><a href="#1-2-2-键值模型" class="headerlink" title="1.2.2 键值模型"></a>1.2.2 键值模型</h4><p>这是最简单、最直观的 NoSQL 模型之一。</p>
<ul>
<li><strong>核心思想</strong>: 数据被存储为一个巨大的字典或哈希表，由唯一的<strong>键 (Key)</strong> 和与之对应的<strong>值 (Value)</strong> 组成。</li>
<li><strong>关键概念</strong>:<ul>
<li><strong>键 (Key)</strong>: 数据的唯一标识符。</li>
<li><strong>值 (Value)</strong>: 与键相关联的数据，可以是简单的字符串、数字，也可以是复杂的对象（如 JSON 字符串）。</li>
</ul>
</li>
<li><strong>优点</strong>:<ul>
<li><strong>极高的读写性能</strong>: 查询通常是 O(1) 的时间复杂度，速度飞快。</li>
<li><strong>极佳的可扩展性</strong>: 非常容易进行水平扩展。</li>
<li><strong>模型简单</strong>: API 非常简洁（通常只有 get, set, delete 等）。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>功能有限</strong>: 无法按“值”的内容进行查询或范围查询。</li>
<li><strong>数据关系不明确</strong>: 无法直接表示数据之间的复杂关系。</li>
</ul>
</li>
<li><strong>典型数据库</strong>: Redis.</li>
</ul>
<hr>
<h4 id="1-2-3-文档模型"><a href="#1-2-3-文档模型" class="headerlink" title="1.2.3 文档模型"></a>1.2.3 文档模型</h4><p>可以看作是键值模型的升级版，它对“值”的内容进行了结构化。</p>
<ul>
<li><strong>核心思想</strong>: 数据以独立的<strong>文档 (Document)</strong> 为单位进行存储，这些文档通常是自包含的、半结构化的格式，如 JSON 或 BSON。</li>
<li><strong>关键概念</strong>:<ul>
<li><strong>文档 (Document)</strong>: 一个独立的数据单元，通常是 JSON 格式，具有自我描述性。类似于编程语言中的对象。</li>
<li><strong>集合 (Collection)</strong>: 一组文档的集合，类似于关系模型中的表。</li>
</ul>
</li>
<li><strong>优点</strong>:<ul>
<li><strong>灵活的模式 (Schema-on-read)</strong>: 无需预先定义表结构，可以直接存入不同结构的文档。</li>
<li><strong>开发友好</strong>: JSON 格式与现代编程语言中的对象模型能很好地对应。</li>
<li><strong>读取性能好</strong>: 一次查询可以获取一个完整的文档，避免了多次连接查询。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>多文档事务支持较弱</strong>: 虽然现代文档数据库在不断改进，但跨多个文档的强一致性事务通常比 RDBMS 要复杂。</li>
<li><strong>数据冗余</strong>: 为了查询性能，常常会将一些数据冗余存储在多个文档中。</li>
</ul>
</li>
<li><strong>典型数据库</strong>: MongoDB.</li>
</ul>
<hr>
<h4 id="1-2-4-列式模型"><a href="#1-2-4-列式模型" class="headerlink" title="1.2.4 列式模型"></a>1.2.4 列式模型</h4><p>为处理海量数据集的分析和聚合查询而设计，它的数据存储方式与关系模型正好相反。</p>
<ul>
<li><strong>核心思想</strong>: 数据是按<strong>列 (Column)</strong> 而不是按行存储的。同一个列的数据被存放在一起。</li>
<li><strong>优点</strong>:<ul>
<li><strong>查询性能极高</strong>: 特别适合只涉及少数几列的聚合查询（OLAP 场景）。</li>
<li><strong>高压缩率</strong>: 因为同一列的数据类型相同，非常适合进行数据压缩。</li>
<li><strong>高可扩展性</strong>: 为分布式和海量数据而生。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>单行数据写入&#x2F;读取较慢</strong>: 如果需要频繁地更新或读取一整行数据，性能不如行式数据库。</li>
</ul>
</li>
<li><strong>典型数据库</strong>: Cassandra, HBase, Google Bigtable.</li>
</ul>
<hr>
<h4 id="1-2-5-图模型"><a href="#1-2-5-图模型" class="headerlink" title="1.2.5 图模型"></a>1.2.5 图模型</h4><p>专门用于处理数据之间复杂、丰富的<strong>关系</strong>。</p>
<ul>
<li><strong>核心思想</strong>: 将数据表示为由<strong>节点 (Node)</strong> 和<strong>边 (Edge)</strong> 组成的图。节点代表实体，边代表实体之间的关系。</li>
<li><strong>关键概念</strong>:<ul>
<li><strong>节点 (Node)</strong>: 代表实体，如人、商品、地点。</li>
<li><strong>边 (Edge)</strong>: 代表节点之间的关系，可以有方向和属性。</li>
</ul>
</li>
<li><strong>优点</strong>:<ul>
<li><strong>关系查询性能极高</strong>: 查询深度关联的数据（如多层好友关系）时，性能远超关系型数据库的 <code>JOIN</code> 操作。</li>
<li><strong>模型直观</strong>: 非常适合对高度互联的数据进行建模。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>不适合批量更新</strong>: 对全图进行大规模的扫描或更新操作效率不高。</li>
<li><strong>应用场景特定</strong>: 更适合关系密集型的应用，而不是通用的数据存储。</li>
</ul>
</li>
<li><strong>典型数据库</strong>: Neo4j, Amazon Neptune.</li>
</ul>
<hr>
<h3 id="1-3-数据库分类"><a href="#1-3-数据库分类" class="headerlink" title="1.3 数据库分类"></a>1.3 数据库分类</h3><h4 id="1-3-1-关系型数据库-Relational-Databases-RDBMS"><a href="#1-3-1-关系型数据库-Relational-Databases-RDBMS" class="headerlink" title="1.3.1 关系型数据库 (Relational Databases, RDBMS)"></a>1.3.1 关系型数据库 (Relational Databases, RDBMS)</h4><p>这是最经典、最成熟的数据库类型，至今仍是绝大多数应用的核心数据存储方案。</p>
<ul>
<li><strong>核心理念</strong>: 基于<strong>关系模型</strong>，所有数据都存储在预先定义好的二维表格中。数据之间的关系通过<strong>外键 (Foreign Key)</strong> 来维护。它的设计哲学强调<strong>数据的一致性和完整性</strong>。</li>
<li><strong>关键特征</strong>:<ul>
<li><strong>结构化数据 (Structured Data)</strong>: 在写入数据之前，必须先定义好表结构 (Schema)，包括列名、数据类型和约束。这被称为 <strong>Schema-on-Write</strong> (写入时定义模式)。</li>
<li><strong>ACID 事务</strong>: 强力保证事务的原子性 (Atomicity)、一致性 (Consistency)、隔离性 (Isolation) 和持久性 (Durability)，是金融级应用的首选。</li>
<li><strong>SQL 标准</strong>: 使用结构化查询语言 (SQL) 进行数据操作，这是一个强大且广泛接受的标准。</li>
<li><strong>连接 (JOIN) 操作</strong>: 通过 JOIN 可以方便地进行多表关联查询，获取复杂关系的数据。</li>
</ul>
</li>
<li><strong>优点</strong>:<ul>
<li><strong>数据完整性高</strong>: 强约束和事务保证了数据不会出错。</li>
<li><strong>适合复杂查询</strong>: 强大的 SQL 和 JOIN 操作可以应对各种复杂的查询需求。</li>
<li><strong>生态成熟</strong>: 拥有海量的工具、文档和经验丰富的开发者。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>扩展性受限</strong>: 在面对海量数据时，通常采用<strong>垂直扩展</strong> (升级服务器硬件)，而<strong>水平扩展</strong> (增加服务器数量) 相对复杂。</li>
<li><strong>模式僵化</strong>: 业务变更导致需要修改表结构时，流程复杂且可能影响线上服务。</li>
<li><strong>性能瓶颈</strong>: 高并发读写和复杂的多表 JOIN 在数据量巨大时可能成为性能瓶颈。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-2-NoSQL-数据库-Not-Only-SQL"><a href="#1-3-2-NoSQL-数据库-Not-Only-SQL" class="headerlink" title="1.3.2 NoSQL 数据库 (Not Only SQL)"></a>1.3.2 NoSQL 数据库 (Not Only SQL)</h4><p>NoSQL 是一个总称，泛指所有非关系型的数据库。它们的出现是为了解决 RDBMS 在某些场景下的不足，尤其是在<strong>大规模 (Scale)</strong>、<strong>高性能 (Performance)</strong> 和<strong>高可用性 (Availability)</strong> 方面的挑战。</p>
<ul>
<li><strong>核心理念</strong>: 放弃严格的关系模型和 ACID 事务，换取更高的性能、更好的可扩展性和更灵活的数据模型。它的设计哲学更倾向于<strong>可用性和性能</strong>。</li>
<li><strong>关键特征</strong>:<ul>
<li><strong>灵活的数据模型</strong>: 通常不需要预定义 Schema，数据结构可以随时改变。这被称为 <strong>Schema-on-Read</strong> (读取时解析模式)。</li>
<li><strong>水平扩展</strong>: 从设计之初就为分布式而生，可以轻松地通过增加服务器节点来线性提升性能和存储容量。</li>
<li><strong>BASE 理论</strong>: 通常遵循 BASE 理论（基本可用、软状态、最终一致性），而非强一致性的 ACID。</li>
<li><strong>多样化的 API</strong>: 没有统一的查询语言，不同的 NoSQL 数据库有各自的查询方式。</li>
</ul>
</li>
<li><strong>优点</strong>:<ul>
<li><strong>高并发读写</strong>: 简单的 K-V 模型或文档模型使得读写路径更短，性能极高。</li>
<li><strong>海量数据存储</strong>: 分布式架构使其能够轻松处理 PB 级别的数据。</li>
<li><strong>数据模型灵活</strong>: 快速迭代的业务无需频繁更改数据库结构。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>一致性较弱</strong>: 大多只支持最终一致性，不适合要求强一致性的场景（如支付）。</li>
<li><strong>功能相对单一</strong>: 通常不支持复杂的 JOIN 和事务操作。</li>
<li><strong>生态和标准化程度较低</strong>: 学习成本相对较高。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-MySQL-架构简介"><a href="#1-4-MySQL-架构简介" class="headerlink" title="1.4 MySQL 架构简介"></a>1.4 MySQL 架构简介</h3><h4 id="1-4-1-逻辑架构"><a href="#1-4-1-逻辑架构" class="headerlink" title="1.4.1 逻辑架构"></a>1.4.1 逻辑架构</h4><p>通常，MySQL 的逻辑架构可以分为三到四层，这里我们采用更清晰的四层模型进行讲解。</p>
<pre><code class="highlight mermaid">flowchart TD
    %% --- 样式定义 ---
    classDef client fill:#f9f9f9,stroke:#333,stroke-width:2px;
    classDef layer1 fill:#e3f2fd,stroke:#1565c0,stroke-width:2px;
    classDef layer2 fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px;
    classDef layer3 fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;
    classDef layer4 fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;
    classDef component fill:#fff,stroke:#666,stroke-width:1px;

    %% --- 外部客户端 ---
    Client((客户端应用&lt;br&gt;JDBC, ODBC, CLI)):::client

    %% --- 第一层：连接层 ---
    subgraph L1 [&quot;&lt;b&gt;第一层：连接层 (Connection Layer)&lt;/b&gt;&quot;]
        direction TB
        ConnHandler[&lt;b&gt;连接处理&lt;/b&gt;&lt;br&gt;TCP/IP, Socket通信]:::component
        ThreadPool[&lt;b&gt;线程管理&lt;/b&gt;&lt;br&gt;Thread Pool&lt;br&gt;一连接一线程]:::component
        AuthCheck[&lt;b&gt;认证与安全&lt;/b&gt;&lt;br&gt;用户鉴权 &amp; 权限校验]:::component
    end

    %% --- 第二层：服务层 ---
    subgraph L2 [&quot;&lt;b&gt;第二层：服务层 (Server Layer / Brain)&lt;/b&gt;&quot;]
        direction TB
        SQLInterface[&lt;b&gt;SQL 接口&lt;/b&gt;&lt;br&gt;接收 DML/DDL, 返回结果]:::component
        
        Q_Cache[(&quot;&lt;b&gt;查询缓存 (Query Cache)&lt;/b&gt;&lt;br&gt;Key-Value 存储&lt;br&gt;(MySQL 8.0 已移除)&quot;)]:::component
        
        Parser[&lt;b&gt;查询解析器&lt;/b&gt;&lt;br&gt;词法/语法分析 -&gt; 生成解析树 AST]:::component
        
        Optimizer[&lt;b&gt;查询优化器&lt;/b&gt;&lt;br&gt;生成执行计划, 索引选择]:::component
        
        Executor[&lt;b&gt;执行器&lt;/b&gt;&lt;br&gt;调用存储引擎 API]:::component
    end

    %% --- 第三层：存储引擎层 ---
    subgraph L3 [&quot;&lt;b&gt;第三层：存储引擎层 (Storage Engine Layer)&lt;/b&gt;&quot;]
        direction TB
        API[&lt;b&gt;可插拔存储引擎 API&lt;/b&gt;&lt;br&gt;Pluggable Storage Engine API]:::component
        
        subgraph Engines [常见引擎]
            InnoDB[&lt;b&gt;InnoDB&lt;/b&gt;&lt;br&gt;事务, 行锁, 外键]:::component
            MyISAM[&lt;b&gt;MyISAM&lt;/b&gt;&lt;br&gt;非事务, 表锁, 归档]:::component
            Memory[&lt;b&gt;Memory&lt;/b&gt;&lt;br&gt;内存存储]:::component
            OtherEngine[Archive / CSV 等]:::component
        end
    end

    %% --- 第四层：物理文件层 ---
    subgraph L4 [&quot;&lt;b&gt;第四层：物理文件层 (Physical File Layer)&lt;/b&gt;&quot;]
        direction TB
        
        subgraph LogFiles [&quot;&lt;b&gt;日志文件 (Logs)&lt;/b&gt;&quot;]
            Redo[&quot;Redo Log&lt;br&gt;(重做日志)&quot;]:::component
            Undo[&quot;Undo Log&lt;br&gt;(撤销日志)&quot;]:::component
            Binlog[&quot;Binlog&lt;br&gt;(二进制日志)&quot;]:::component
            ErrorLog[Error/Slow Log]:::component
        end
        
        subgraph DataFiles [&lt;b&gt;数据文件&lt;/b&gt;]
            IBD[&quot;.ibd 文件&lt;br&gt;(InnoDB 数据/索引)&quot;]:::component
            MY_Files[&quot;.MYD / .MYI&lt;br&gt;(MyISAM 数据/索引)&quot;]:::component
        end
        
        ConfigFile[配置文件 my.cnf]:::component
    end

    %% --- 关系连线 ---
    
    %% 客户端到连接层
    Client ==&gt; ConnHandler
    ConnHandler --&gt; ThreadPool
    ThreadPool &lt;--&gt; AuthCheck
    
    %% 连接层到服务层
    ThreadPool ==&gt; SQLInterface
    
    %% 服务层内部流程
    SQLInterface -.-&gt;|&quot;命中缓存 (Legacy)&quot;| Q_Cache
    SQLInterface --&gt; Parser
    Parser --&gt; Optimizer
    Optimizer --&gt; Executor
    
    %% 服务层到存储引擎层
    Executor ==&gt; API
    API --&gt; InnoDB
    API --&gt; MyISAM
    API --&gt; Memory
    API --&gt; OtherEngine
    
    %% 存储引擎到文件层
    InnoDB &lt;--&gt; Redo
    InnoDB &lt;--&gt; Undo
    InnoDB &lt;--&gt; IBD
    
    MyISAM &lt;--&gt; MY_Files
    
    %% Server层产生的日志
    Executor -.-&gt; Binlog
    L2 -.-&gt; ErrorLog

    %% 样式应用
    class L1 layer1;
    class L2 layer2;
    class L3 layer3;
    class L4 layer4;</code></pre>

<h5 id="第一层：连接层-Connection-Layer"><a href="#第一层：连接层-Connection-Layer" class="headerlink" title="第一层：连接层 (Connection Layer)"></a>第一层：连接层 (Connection Layer)</h5><p>这一层是 MySQL 的“前门”或“接待处”，主要负责处理客户端的连接请求。它并非 MySQL 独有，大多数 C&#x2F;S 架构的数据库系统都有类似的组件。</p>
<ul>
<li><strong>核心职责</strong>:<ul>
<li><strong>连接处理 (Connection Handling)</strong>: 监听来自客户端的连接请求（如通过 TCP&#x2F;IP、Unix Socket），为每个连接分配或管理一个线程。</li>
<li><strong>线程管理 (Thread Handling)</strong>: MySQL 采用“一个连接一个线程”的模式。当客户端连接时，服务器会从线程池中分配一个线程专门为其服务，直到连接断开。管理这些线程的创建、销毁和缓存。</li>
<li><strong>用户认证 (Authentication)</strong>: 验证客户端提供的用户名和密码是否正确。这通常会查询 <code>mysql</code> 数据库中的 <code>user</code> 表。</li>
<li><strong>权限校验 (Authorization)</strong>: 在用户成功登录后，验证该用户是否拥有执行特定查询（如 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 等）的权限。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="第二层：服务层-Server-Layer-Core-Services"><a href="#第二层：服务层-Server-Layer-Core-Services" class="headerlink" title="第二层：服务层 (Server Layer &#x2F; Core Services)"></a>第二层：服务层 (Server Layer &#x2F; Core Services)</h5><p>这是 MySQL 的核心，是真正的“大脑”。所有跨存储引擎的功能都在这一层实现，例如 SQL 解析、优化、缓存以及内置函数等。</p>
<ul>
<li><strong>核心组件与流程</strong>:<ol>
<li><strong>SQL 接口 (SQL Interface)</strong>: 接收来自客户端的 SQL 命令（如 DML, DDL, DQL 等），并返回查询结果。</li>
<li><strong>查询解析器 (Parser)</strong>:<ul>
<li><strong>词法与语法分析</strong>: 对 SQL 语句进行解析，检查语法是否正确。</li>
<li><strong>生成解析树</strong>: 如果语法正确，会生成一个“解析树”（Abstract Syntax Tree, AST），这是 SQL 语句的一种结构化表示。</li>
</ul>
</li>
<li><strong>查询优化器 (Optimizer)</strong>:<ul>
<li><strong>最重要的组件之一</strong>: 优化器是决定查询性能的关键。它接收解析树，并根据一系列复杂的算法和统计信息（如索引、数据分布等）生成一个最优的<strong>执行计划 (Execution Plan)</strong>。</li>
<li><strong>优化决策</strong>: 比如，决定使用哪个索引、表连接的顺序（<code>A join B</code> 还是 <code>B join A</code>）、是否将子查询转换为 <code>JOIN</code> 等。</li>
</ul>
</li>
<li><strong>查询缓存 (Query Cache)</strong>:<ul>
<li><strong>历史遗留组件</strong>: 在 MySQL 5.7 及之前版本存在，但在 <strong>MySQL 8.0 中已被完全移除</strong>。</li>
<li><strong>工作原理</strong>: 以查询语句的哈希值为 Key，查询结果为 Value。如果命中，则直接返回结果，跳过解析、优化和执行阶段。</li>
<li><strong>移除原因</strong>: 缓存的维护成本很高，任何对表的修改都会导致所有相关的缓存失效，在高并发写入场景下反而成为性能瓶颈。</li>
</ul>
</li>
<li><strong>执行器 (Executor)</strong>:<ul>
<li><strong>执行最终指令</strong>: 根据优化器生成的执行计划，调用存储引擎提供的接口（API）来执行操作。</li>
<li><strong>与存储引擎交互</strong>: 执行器通过 API 向存储引擎发出“获取下一行”之类的指令，然后由存储引擎完成底层的数据读取或写入，并将结果返回给执行器，最终由执行器汇总后返回给客户端。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5 id="第三层：存储引擎层-Storage-Engine-Layer"><a href="#第三层：存储引擎层-Storage-Engine-Layer" class="headerlink" title="第三层：存储引擎层 (Storage Engine Layer)"></a>第三层：存储引擎层 (Storage Engine Layer)</h5><p>这一层是 MySQL 的“双手和双脚”，真正负责数据的存储和提取。它像一个插件，可以根据业务需求选择不同的引擎。</p>
<ul>
<li><strong>核心特点 (Pluggable Architecture)</strong>: 这是 MySQL 的一大特色。你可以为同一个数据库中的不同表设置不同的存储引擎。</li>
<li><strong>核心职责</strong>:<ul>
<li><strong>数据存储</strong>: 将数据以特定的格式存储在物理磁盘上。</li>
<li><strong>数据读写</strong>: 提供 API 供上层执行器调用，以完成数据的增删改查。</li>
<li><strong>索引管理</strong>: 创建、使用和维护索引。</li>
<li><strong>事务支持</strong>: 实现事务的 ACID 特性（如 InnoDB 支持）。</li>
<li><strong>锁机制</strong>: 提供并发控制所需的锁（如 InnoDB 的行级锁，MyISAM 的表级锁）。</li>
</ul>
</li>
<li><strong>常见存储引擎</strong>:<ul>
<li><strong>InnoDB</strong>: <strong>默认且最常用</strong>。支持事务、行级锁、外键、崩溃恢复，是高并发、要求数据一致性的业务首选。</li>
<li><strong>MyISAM</strong>: MySQL 5.5 之前的默认引擎。不支持事务和外键，使用表级锁。读取速度快，适合读密集、非事务性的应用（如日志记录）。</li>
<li><strong>Memory</strong>: 将所有数据存储在内存中，速度极快。但数据库重启后数据会丢失。适合存储临时数据。</li>
<li><strong>Archive</strong>: 用于归档，只支持插入和查询，压缩比高，节省存储空间。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="第四层：物理文件层-Physical-File-Layer"><a href="#第四层：物理文件层-Physical-File-Layer" class="headerlink" title="第四层：物理文件层 (Physical File Layer)"></a>第四层：物理文件层 (Physical File Layer)</h5><p>这一层是真正存在于服务器硬盘上的物理文件，是数据库的物质基础。</p>
<ul>
<li><strong>主要文件类型</strong>:<ul>
<li><strong>数据文件</strong>: 存储表的数据和索引。例如 InnoDB 的 <code>.ibd</code> 文件，MyISAM 的 <code>.MYD</code> (数据) 和 <code>.MYI</code> (索引) 文件。</li>
<li><strong>日志文件</strong>:<ul>
<li><strong>Redo Log (重做日志)</strong>: InnoDB 特有，用于保证事务的持久性，实现崩溃恢复。</li>
<li><strong>Undo Log (撤销日志)</strong>: InnoDB 特有，用于事务回滚和实现多版本并发控制 (MVCC)。</li>
<li><strong>Binlog (二进制日志)</strong>: Server 层日志，记录所有对数据库的修改操作，主要用于主从复制和数据恢复。</li>
<li><strong>Error Log (错误日志)</strong>: 记录 MySQL 启动、运行和关闭过程中的错误信息。</li>
<li><strong>Slow Query Log (慢查询日志)</strong>: 记录执行时间超过阈值的 SQL 查询，用于性能优化。</li>
</ul>
</li>
<li><strong>配置文件</strong>: 如 <code>my.cnf</code> 或 <code>my.ini</code>，定义了 MySQL 服务器的各种配置参数。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-4-2-存储引擎"><a href="#1-4-2-存储引擎" class="headerlink" title="1.4.2 存储引擎"></a>1.4.2 存储引擎</h4><p>存储引擎是基于表的，而不是基于数据库的。这意味着，你可以在同一个数据库中，为不同的表使用不同的存储引擎，以适应各自独特的业务需求。这种<strong>可插拔式架构 (Pluggable Architecture)</strong> 是 MySQL 的一个核心特性。</p>
<h5 id="1-存储引擎的常见操作"><a href="#1-存储引擎的常见操作" class="headerlink" title="1. 存储引擎的常见操作"></a><strong>1. 存储引擎的常见操作</strong></h5><p>可以通过简单的 SQL 命令来查看和管理存储引擎。</p>
<ol>
<li><p><strong>查看当前数据库支持的存储引擎</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br></pre></td></tr></table></figure>

<p>这条命令会列出所有可用的引擎，以及它们是否被激活（<code>Support</code> 列）、是否为默认引擎（<code>DEFAULT</code>）和简要描述。</p>
</li>
<li><p><strong>查看默认存储引擎</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在 MySQL 5.5 版本之后，默认的存储引擎是 <code>InnoDB</code>。</p>
</li>
<li><p><strong>为表指定存储引擎</strong><br>在创建表的时候，可以在末尾通过 <code>ENGINE</code> 关键字来指定。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> my_innodb_table (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> my_myisam_table (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    log_data TEXT</span><br><span class="line">) ENGINE <span class="operator">=</span> MyISAM;</span><br></pre></td></tr></table></figure>

<p>如果你不指定，MySQL 会使用默认的存储引擎。</p>
</li>
<li><p><strong>修改表的存储引擎</strong><br>对于已存在的表，也可以进行修改。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> my_myisam_table ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 修改一个大表的存储引擎是一个非常耗时且消耗资源的操作，它会锁表并重构整个表的数据和索引。请在业务低峰期谨慎操作。</p>
</li>
</ol>
<hr>
<h5 id="2-核心存储引擎对比"><a href="#2-核心存储引擎对比" class="headerlink" title="2. 核心存储引擎对比"></a><strong>2. 核心存储引擎对比</strong></h5><table>
<thead>
<tr>
<th align="left">特性 (Feature)</th>
<th align="left">InnoDB</th>
<th align="left">MyISAM</th>
<th align="left">Memory (HEAP)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>事务支持 (ACID)</strong></td>
<td align="left"><strong>支持</strong></td>
<td align="left"><strong>不支持</strong></td>
<td align="left"><strong>不支持</strong></td>
</tr>
<tr>
<td align="left"><strong>锁粒度 (Locking)</strong></td>
<td align="left"><strong>行级锁 (Row-Level)</strong></td>
<td align="left"><strong>表级锁 (Table-Level)</strong></td>
<td align="left"><strong>表级锁 (Table-Level)</strong></td>
</tr>
<tr>
<td align="left"><strong>外键约束 (Foreign Key)</strong></td>
<td align="left"><strong>支持</strong></td>
<td align="left"><strong>不支持</strong></td>
<td align="left"><strong>不支持</strong></td>
</tr>
<tr>
<td align="left"><strong>崩溃恢复 (Crash Recovery)</strong></td>
<td align="left"><strong>支持</strong> (通过 Redo&#x2F;Undo Log)</td>
<td align="left"><strong>不支持</strong> (易损坏)</td>
<td align="left"><strong>不支持</strong> (数据在内存)</td>
</tr>
<tr>
<td align="left"><strong>MVCC (多版本并发控制)</strong></td>
<td align="left"><strong>支持</strong></td>
<td align="left"><strong>不支持</strong></td>
<td align="left"><strong>不支持</strong></td>
</tr>
<tr>
<td align="left"><strong>索引结构</strong></td>
<td align="left"><strong>聚簇索引 (Clustered Index)</strong></td>
<td align="left"><strong>非聚簇索引</strong></td>
<td align="left"><strong>哈希索引 (默认), B-Tree</strong></td>
</tr>
<tr>
<td align="left"><strong>物理存储文件</strong></td>
<td align="left"><code>*.frm</code>, <code>*.ibd</code></td>
<td align="left"><code>*.frm</code>, <code>*.MYD</code>, <code>*.MYI</code></td>
<td align="left">数据在内存，表结构在 <code>*.frm</code></td>
</tr>
<tr>
<td align="left"><strong>核心优势</strong></td>
<td align="left">可靠、高并发、事务安全</td>
<td align="left">读取速度快、简单</td>
<td align="left">极致的速度</td>
</tr>
<tr>
<td align="left"><strong>主要适用场景</strong></td>
<td align="left">绝大多数业务场景，尤其是高并发、要求数据一致性的 OLTP 系统</td>
<td align="left">日志、报表等读密集型、非核心业务</td>
<td align="left">临时表、缓存数据</td>
</tr>
</tbody></table>
<hr>
<h5 id="3-各存储引擎详解"><a href="#3-各存储引擎详解" class="headerlink" title="3. 各存储引擎详解"></a><strong>3. 各存储引擎详解</strong></h5><p><strong>InnoDB</strong></p>
<p>自 MySQL 5.5 起成为默认存储引擎，是目前<strong>最重要、使用最广泛</strong>的引擎。</p>
<ul>
<li><strong>核心特性</strong>:<ul>
<li><strong>事务 (ACID)</strong>: 提供了 <code>COMMIT</code>, <code>ROLLBACK</code> 和崩溃恢复能力，保证了数据的绝对安全和一致性。</li>
<li><strong>行级锁 (Row-Level Locking)</strong>: 在进行写操作时，只锁定需要修改的行，而不是整张表。这极大地提高了高并发环境下的读写性能。</li>
<li><strong>多版本并发控制 (MVCC)</strong>: 实现了非阻塞的读操作。读取数据时不会锁定表，从而做到“读写不冲突”。</li>
<li><strong>外键 (Foreign Key)</strong>: 支持外键约束，保证了多表之间的数据完整性。</li>
<li><strong>聚簇索引 (Clustered Index)</strong>: 数据文件本身就是按主键顺序组织的一个 B+Tree 索引，这使得基于主键的查询速度非常快。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>任何需要高可靠性、要求事务支持的应用，如电商、金融、社交等。</li>
<li>需要处理大量并发更新或插入的场景。</li>
<li><strong>一句话总结：除非你有非常明确的理由不使用它，否则 InnoDB 永远是你的首选。</strong></li>
</ul>
</li>
</ul>
<p><strong>MyISAM</strong></p>
<p>在 MySQL 5.5 之前是默认引擎，以其简单的结构和出色的读取性能而闻名。</p>
<ul>
<li><strong>核心特性</strong>:<ul>
<li><strong>表级锁 (Table-Level Locking)</strong>: 这是它最大的缺点。任何对表的写操作（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>）都会锁定整张表，导致其他写操作和读操作被阻塞，并发性能极差。</li>
<li><strong>读取速度快</strong>: 结构简单，没有事务开销，所以执行只读查询时速度通常比 InnoDB 更快。</li>
<li><strong>不支持事务和外键</strong>: 这使得它在数据一致性和完整性方面较弱。</li>
<li><strong>崩溃后易损坏</strong>: 如果服务器意外宕机，MyISAM 表非常容易损坏，需要手动修复。</li>
<li><strong>存储计数器</strong>: <code>COUNT(*)</code> 操作非常快，因为它内部直接存储了表的总行数。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>只读或读远多于写的应用，如报表系统、数据仓库。</li>
<li>对事务完整性没有要求的应用，如日志记录。</li>
<li><strong>现代应用中已很少使用 MyISAM 作为核心业务表的引擎。</strong></li>
</ul>
</li>
</ul>
<p>**Memory **</p>
<p>将所有数据都存储在内存中，以换取最快的访问速度。</p>
<ul>
<li><strong>核心特性</strong>:<ul>
<li><strong>速度极快</strong>: 所有数据都在内存中，读写速度接近内存访问速度。</li>
<li><strong>数据易失</strong>: 数据库服务重启或服务器宕机，Memory 表中的所有数据都会丢失。</li>
<li><strong>表级锁</strong>: 并发性能不佳。</li>
<li><strong>默认使用哈希索引</strong>: 这使得等值查询非常快，但范围查询较慢。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>存储需要快速访问的、非永久性的数据，如用户会话（Session）、在线用户列表等。</li>
<li>在复杂查询中用作临时表，加速中间结果的存储和计算。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-如何选择存储引擎？"><a href="#4-如何选择存储引擎？" class="headerlink" title="4. 如何选择存储引擎？"></a><strong>4. 如何选择存储引擎？</strong></h5><ul>
<li><strong>InnoDB</strong>: 你的默认和首选。适用于 99% 的应用场景，提供了数据安全、高并发和强大的功能。</li>
<li><strong>MyISAM</strong>: 除非你的应用是纯读取，且能容忍数据丢失的风险，否则不推荐。对于需要快速 <code>COUNT(*)</code> 的场景，可以考虑，但通常有更好的解决方案（如缓存）。</li>
<li><strong>Memory</strong>: 当你需要一个生命周期短、速度要求极致的临时数据存放地时，它是绝佳选择。</li>
</ul>
<hr>
<h3 id="1-5-核心优势"><a href="#1-5-核心优势" class="headerlink" title="1.5 核心优势"></a>1.5 核心优势</h3><p>我们为什么不直接把数据存放在 <code>.txt</code> 或 <code>.json</code> 文件里？因为数据库管理系统 (DBMS) 提供了四个无可替代的核心优势</p>
<p><strong>数据持久化 (Data Persistence)</strong></p>
<ul>
<li><p><strong>核心定义</strong>:</p>
<p>持久化意味着数据一旦被写入，就不会因为程序的关闭、服务器的重启或断电而丢失。数据被安全地存储在非易失性存储介质上（如硬盘或 SSD），实现了永久保存。</p>
</li>
</ul>
<p><strong>数据管理 (Data Management)</strong></p>
<ul>
<li><strong>核心定义</strong>:<br>数据库不仅是存储数据，更重要的是提供了一套<strong>高效、结构化</strong>的管理机制。它允许我们以一种有组织的方式定义数据、插入数据、查询数据和维护数据。</li>
</ul>
<p><strong>并发控制 (Concurrency Control)</strong></p>
<ul>
<li><strong>核心定义</strong>:<br>并发控制是指在多个用户或应用程序<strong>同时</strong>对数据库进行读写操作时，数据库系统有能力保证操作的正确性和数据的完整性，避免因同时操作而导致的数据混乱或错误。</li>
</ul>
<p><strong>数据一致性 (Data Consistency)</strong></p>
<ul>
<li><strong>核心定义</strong>:<br>数据一致性确保数据库中的数据始终处于一种逻辑上正确的、自洽的状态。这通常通过<strong>事务 (Transaction)</strong> 来保证，即一系列操作要么全部成功执行，要么全部失败回滚，不会停留在中间的某个“不完整”状态。</li>
</ul>
<hr>
<h2 id="2-SQL-语言核心"><a href="#2-SQL-语言核心" class="headerlink" title="2. SQL 语言核心"></a>2. SQL 语言核心</h2><h3 id="2-1-DDL（数据定义语言）"><a href="#2-1-DDL（数据定义语言）" class="headerlink" title="2.1 DDL（数据定义语言）"></a>2.1 DDL（数据定义语言）</h3><p>DDL 的核心作用是<strong>定义和管理数据库中的各种对象（Object）的结构</strong>，而不是操作它们里面的数据。</p>
<p><strong>关键特性</strong>：<strong>大多数 DDL 语句都包含一个隐式的事务提交（Implicit Commit）</strong>。这意味着执行一条 DDL 语句（如 <code>CREATE TABLE</code>）后，之前的未提交事务可能会被自动提交，且 DDL 语句本身无法回滚（在大多数数据库中）。</p>
<h4 id="2-1-1-CREATE-创建数据库对象"><a href="#2-1-1-CREATE-创建数据库对象" class="headerlink" title="2.1.1 CREATE - 创建数据库对象"></a>2.1.1 <code>CREATE</code> - 创建数据库对象</h4><h5 id="1-创建数据库-CREATE-DATABASE"><a href="#1-创建数据库-CREATE-DATABASE" class="headerlink" title="1. 创建数据库 (CREATE DATABASE)"></a>1. 创建数据库 (CREATE DATABASE)</h5><ul>
<li><p><strong>基本语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE database_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>高级选项（推荐使用）</strong></p>
<p>在创建数据库时，强烈建议明确指定其<strong>字符集（Character Set）和 排序规则（Collation）</strong>，以避免未来的乱码问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] database_name</span><br><span class="line"><span class="keyword">CHARACTER SET</span> utf8mb4	# 指定数据库默认的字符集为 `utf8mb4`</span><br><span class="line"><span class="keyword">COLLATE</span> utf8mb4_unicode_ci;	# 指定默认的排序规则。`_ci` 表示 &quot;case-insensitive&quot;，即在排序和比较时不区分大小写</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>IF NOT EXISTS</code>: 这是一个非常有用的安全选项。如果同名数据库已存在，该语句不会执行，也不会报错，而是会给出一个警告。在自动化脚本中尤其重要，可以防止因重复执行而导致的错误。</p>
</li>
<li><p><strong>字符集 (Character Set)</strong>: 决定了数据库能存储哪些字符。<code>utf8mb4</code> 是现代应用的事实标准，因为它能完整支持 Unicode，包括各种 emoji 表情。</p>
</li>
<li><p><strong>排序规则 (Collation)</strong>: 决定了字符串比较和排序的方式。<code>_ci</code> 表示不区分大小写，<code>_cs</code> 表示区分大小写，<code>_bin</code> 表示按二进制比较。</p>
</li>
<li><p><strong>示例</strong>:<br>创建一个名为 <code>my_app_db</code> 的数据库。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> my_app_db </span><br><span class="line">	<span class="keyword">CHARACTER SET</span> utf8mb4 </span><br><span class="line">	<span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-创建表-CREATE-TABLE"><a href="#2-创建表-CREATE-TABLE" class="headerlink" title="2. 创建表 (CREATE TABLE)"></a>2. 创建表 (CREATE TABLE)</h5><p>这是最核心的 DDL 命令，其完整语法包含了列定义、约束和表选项。</p>
<ul>
<li><p><strong>基本语法结构</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name (</span><br><span class="line">    column1_name data_type [constraints],</span><br><span class="line">    column2_name data_type [constraints],</span><br><span class="line">    ...</span><br><span class="line">    [table_level_constraints]</span><br><span class="line">) [table_options];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>核心组成部分详解</strong>:</p>
<ol>
<li><strong>列定义 (<code>column_name data_type [constraints]</code>)</strong>:<ul>
<li><code>column_name</code>: 列的名称，如 <code>id</code>, <code>username</code>, <code>created_at</code>。</li>
<li><code>data_type</code>: 数据类型，如 <code>INT</code>, <code>VARCHAR(100)</code>, <code>DATETIME</code>。这部分将在 <code>3.1 常用数据类型</code> 中详细展开。</li>
<li><code>constraints</code>: 列级约束，用于保证数据的完整性。<ul>
<li><code>NOT NULL</code>: 该列的值不能为空。</li>
<li><code>UNIQUE</code>: 该列的所有值必须唯一。</li>
<li><code>PRIMARY KEY</code>: 主键约束，等同于 <code>NOT NULL</code> + <code>UNIQUE</code>。每张表只能有一个主键，用于唯一标识一行数据。</li>
<li><code>DEFAULT value</code>: 当插入新行但未指定该列的值时，使用此默认值。</li>
<li><code>AUTO_INCREMENT</code>: 仅适用于整数类型的主键。每当插入新行时，该列的值会自动加 1，常用于生成唯一的ID。</li>
<li><code>COMMENT &#39;description&#39;</code>: 为列添加注释，非常有助于提高表结构的可读性。</li>
</ul>
</li>
</ul>
</li>
<li><strong>表级约束 (<code>table_level_constraints</code>)</strong>:<ul>
<li><code>PRIMARY KEY (column1, column2)</code>: 定义一个由多列组成的联合主键。</li>
<li><code>FOREIGN KEY (column_name) REFERENCES other_table(other_column)</code>: 定义外键，用于建立两张表之间的关联关系，确保引用完整性。</li>
<li><code>UNIQUE (column1, column2)</code>: 定义一个由多列组成的联合唯一键。</li>
<li><code>CHECK (expression)</code>: (MySQL 8.0.16+ 支持) 定义一个检查约束，确保插入或更新的数据满足某个表达式。</li>
</ul>
</li>
<li><strong>表选项 (<code>table_options</code>)</strong>:<ul>
<li><code>ENGINE = engine_name</code>: 指定表的存储引擎，如 <code>InnoDB</code> (默认), <code>MyISAM</code>。</li>
<li><code>DEFAULT CHARSET = character_set_name</code>: 指定表的默认字符集。</li>
<li><code>COLLATE = collation_name</code>: 指定表的默认排序规则。</li>
<li><code>COMMENT = &#39;description&#39;</code>: 为整个表添加注释。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>综合示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个名为 &#x27;users&#x27; 的表来存储用户信息</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `users` (</span><br><span class="line">  `id` <span class="type">INT</span> UNSIGNED <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户ID，主键&#x27;</span>,</span><br><span class="line">  `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;用户名，唯一且不为空&#x27;</span>,</span><br><span class="line">  `password_hash` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;加密后的密码&#x27;</span>,</span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;电子邮箱，唯一&#x27;</span>,</span><br><span class="line">  `status` TINYINT <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;用户状态: 1=正常, 2=禁用, 0=未激活&#x27;</span>,</span><br><span class="line">  `created_at` DATETIME <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `updated_at` DATETIME <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;最后更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  INDEX `idx_username` (`username`) <span class="comment">-- 为 username 创建一个普通索引以加快查询</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci COMMENT<span class="operator">=</span><span class="string">&#x27;用户信息表&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列级约束 vs 表级约束</strong>: 像 <code>NOT NULL</code>, <code>DEFAULT</code> 通常在列定义后直接写（列级），而 <code>PRIMARY KEY</code>, <code>FOREIGN KEY</code> 等可以涉及多个列的约束，可以在所有列定义完之后再写（表级）。</p>
</li>
</ul>
<hr>
<h5 id="3-创建索引-CREATE-INDEX"><a href="#3-创建索引-CREATE-INDEX" class="headerlink" title="3. 创建索引 (CREATE INDEX)"></a>3. <strong>创建索引 (CREATE INDEX)</strong></h5><p>虽然可以在 <code>CREATE TABLE</code> 中定义，但也可以独立创建索引，用于优化查询性能。</p>
<ul>
<li><p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column1 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], column2 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>UNIQUE</code>: 可选项，表示创建的是唯一索引，要求索引列的值组合必须唯一。</li>
<li><code>index_name</code>: 索引的名称。</li>
<li><code>table_name</code>: 要在其上创建索引的表名。</li>
<li><code>(column1, ...)</code>: 组成索引的一个或多个列。</li>
</ul>
</li>
<li><p><strong>示例</strong>:<br>为 <code>users</code> 表的 <code>email</code> 列创建一个唯一索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在已存在的表上创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_email <span class="keyword">ON</span> users (email);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建组合索引（多列索引）</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_age <span class="keyword">ON</span> users (username, age);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-创建视图-CREATE-VIEW"><a href="#4-创建视图-CREATE-VIEW" class="headerlink" title="4.创建视图 (CREATE VIEW)"></a>4.创建视图 (CREATE VIEW)</h5><p>视图是一个虚拟表，其内容由一个查询定义。它像一个真实的表一样，可以被查询、更新（在某些条件下）常用于简化复杂查询、提供数据安全性。</p>
<ul>
<li><p><strong>核心用途</strong>:</p>
<ul>
<li>简化复杂的 SQL 查询。</li>
<li>对数据库进行访问控制，只向用户暴露表的特定列或行。</li>
<li>提供数据的逻辑独立性，即使基表的结构改变，视图也可以保持不变。</li>
</ul>
</li>
<li><p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>OR REPLACE</code>: 如果同名视图已存在，则替换它。</li>
</ul>
</li>
<li><p><strong>示例</strong>:<br>创建一个只显示正常状态用户（<code>status=1</code>）基本信息的视图。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> active_users_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> id, username, email, created_at</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 之后可以像查询普通表一样查询视图</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> active_users_view <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;alice&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-1-2-ALTER-修改数据库对象"><a href="#2-1-2-ALTER-修改数据库对象" class="headerlink" title="2.1.2 ALTER - 修改数据库对象"></a>2.1.2 <code>ALTER</code> - 修改数据库对象</h4><p><code>ALTER</code> 命令用于修改已经存在的数据库对象的结构。对一个正在线上服务的大表执行 <code>ALTER</code> 操作是一项高风险任务，因为它可能会长时间锁定表，阻塞线上业务，并消耗大量系统资源。</p>
<h5 id="1-添加列-ADD-COLUMN"><a href="#1-添加列-ADD-COLUMN" class="headerlink" title="1. 添加列 (ADD COLUMN)"></a>1. 添加列 (ADD COLUMN)</h5><p>向表中添加一个新的字段。</p>
<ul>
<li><p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] column_name data_type [constraints] [<span class="keyword">FIRST</span> <span class="operator">|</span> AFTER existing_column];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>FIRST</code>: 将新列作为表的第一列。</li>
<li><code>AFTER existing_column</code>: 将新列添加到指定的 <code>existing_column</code> 之后。如果都不指定，新列默认添加到表的最后一列。</li>
</ul>
</li>
<li><p><strong>示例</strong>:<br>假设我们有上一节创建的 <code>users</code> 表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 users 表的最后一列添加一个 &#x27;last_login_ip&#x27; 字段</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> last_login_ip <span class="type">VARCHAR</span>(<span class="number">45</span>) <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;最后登录IP&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 &#x27;email&#x27; 字段后添加一个 &#x27;phone_number&#x27; 字段</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> phone_number <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> AFTER email COMMENT <span class="string">&#x27;手机号，唯一&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-修改列-MODIFY-COLUMN-CHANGE-COLUMN"><a href="#2-修改列-MODIFY-COLUMN-CHANGE-COLUMN" class="headerlink" title="2. 修改列 (MODIFY COLUMN &#x2F; CHANGE COLUMN)"></a>2. 修改列 (MODIFY COLUMN &#x2F; CHANGE COLUMN)</h5><p>修改现有列的定义，例如数据类型、约束或名称。这里有两个关键字：<code>MODIFY</code> 和 <code>CHANGE</code>。</p>
<ul>
<li><p><strong><code>MODIFY</code></strong>: 只能修改列的数据类型和约束，<strong>不能修改列名</strong>。</p>
<ul>
<li><strong>语法</strong>: <code>ALTER TABLE table_name MODIFY [COLUMN] column_name new_data_type [new_constraints];</code></li>
</ul>
</li>
<li><p><strong><code>CHANGE</code></strong>: 功能更强大，既可以修改数据类型和约束，也<strong>可以重命名列</strong>。</p>
<ul>
<li><strong>语法</strong>: <code>ALTER TABLE table_name CHANGE [COLUMN] old_column_name new_column_name new_data_type [new_constraints];</code></li>
<li>注意：即使不打算改名，也必须写两遍列名。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 MODIFY 将 last_login_ip 字段的长度扩大到 100</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> last_login_ip <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;最后登录IP，支持IPv6&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 CHANGE 将 phone_number 字段重命名为 mobile，并设置为 NOT NULL</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users</span><br><span class="line">CHANGE <span class="keyword">COLUMN</span> phone_number mobile <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;手机号，唯一且不能为空&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-删除列-DROP-COLUMN"><a href="#3-删除列-DROP-COLUMN" class="headerlink" title="3. 删除列 (DROP COLUMN)"></a>3. 删除列 (DROP COLUMN)</h5><p>从表中永久移除一个列及其所有数据。<strong>此操作不可逆，请极度谨慎！</strong></p>
<ul>
<li><p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] column_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除 last_login_ip 字段</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> last_login_ip;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-添加-删除约束和索引-ADD-DROP-CONSTRAINT-INDEX"><a href="#4-添加-删除约束和索引-ADD-DROP-CONSTRAINT-INDEX" class="headerlink" title="4. 添加&#x2F;删除约束和索引 (ADD&#x2F;DROP CONSTRAINT&#x2F;INDEX)"></a>4. 添加&#x2F;删除约束和索引 (ADD&#x2F;DROP CONSTRAINT&#x2F;INDEX)</h5><ul>
<li><p><strong>添加约束&#x2F;索引</strong>:</p>
<ul>
<li><p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加主键</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">PRIMARY KEY</span> (column_name);</span><br><span class="line"><span class="comment">-- 添加唯一索引/约束</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX index_name (column_name);</span><br><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">ADD CONSTRAINT</span> fk_name <span class="keyword">FOREIGN KEY</span> (column_name) <span class="keyword">REFERENCES</span> other_table(other_column);</span><br><span class="line"><span class="comment">-- 添加普通索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name (column_name);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>删除约束&#x2F;索引</strong>:</p>
<ul>
<li><p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除主键（前提是该列没有 AUTO_INCREMENT）</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">PRIMARY KEY</span>;</span><br><span class="line"><span class="comment">-- 删除唯一索引/普通索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br><span class="line"><span class="comment">-- 删除外键（需要先找到外键的约束名）</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">FOREIGN KEY</span> fk_constraint_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Tip</strong>: 如何查找外键约束名？使用 <code>SHOW CREATE TABLE table_name;</code>，在返回的 DDL 语句中找到 <code>CONSTRAINT</code> 后面跟着的名称。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为 users 表的 mobile 字段添加一个普通索引以加快查询</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">ADD</span> INDEX idx_mobile (mobile);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除这个索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">DROP</span> INDEX idx_mobile;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-重命名表-RENAME-TABLE"><a href="#5-重命名表-RENAME-TABLE" class="headerlink" title="5. 重命名表 (RENAME TABLE)"></a>5. 重命名表 (RENAME TABLE)</h5><ul>
<li><p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> old_table_name RENAME <span class="keyword">TO</span> new_table_name;</span><br><span class="line"><span class="comment">-- 或者使用专门的 RENAME 命令</span></span><br><span class="line">RENAME <span class="keyword">TABLE</span> old_table_name <span class="keyword">TO</span> new_table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将 users 表重命名为 system_users</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users RENAME <span class="keyword">TO</span> system_users;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-修改表选项-Table-Options"><a href="#6-修改表选项-Table-Options" class="headerlink" title="6. 修改表选项 (Table Options)"></a>6. 修改表选项 (Table Options)</h5><p>可以修改表的存储引擎、字符集等元信息。</p>
<ul>
<li><p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name</span><br><span class="line">ENGINE <span class="operator">=</span> new_engine_name</span><br><span class="line"><span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> new_charset</span><br><span class="line">COMMENT <span class="operator">=</span> <span class="string">&#x27;new_comment&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将一个表的存储引擎从 MyISAM 更改为 InnoDB（非常常见的操作）</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> my_log_table ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表的注释</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> system_users COMMENT <span class="operator">=</span> <span class="string">&#x27;系统核心用户信息表&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-性能考量与最佳实践"><a href="#7-性能考量与最佳实践" class="headerlink" title="7. 性能考量与最佳实践"></a>7. 性能考量与最佳实践</h5><ol>
<li><p><strong>高风险操作</strong>: <code>ALTER TABLE</code> 在内部通常会创建一个新结构的临时表，然后将旧表的数据逐行复制到新表，最后删除旧表并重命名新表。这个过程在表数据量大时，会非常耗时且占用大量磁盘 I&#x2F;O 和 CPU。</p>
</li>
<li><p><strong>锁表问题</strong>: 在上述数据复制过程中，原表通常会被锁定（锁的级别和时长取决于 MySQL 版本和具体操作），导致所有对该表的读写请求被阻塞，可能引发线上服务超时。</p>
</li>
<li><p><strong>最佳实践</strong>:</p>
<ul>
<li><strong>备份先行</strong>: 在执行任何 <code>ALTER</code> 操作之前，务必备份数据。</li>
<li><strong>低峰执行</strong>: 选择业务访问量最低的时间窗口进行操作（如深夜）。</li>
<li><strong>测试验证</strong>: 先在测试环境或预发环境，使用与生产相同的数据量进行测试，评估所需时间和影响。</li>
<li><strong>合并操作</strong>: 将多个 <code>ALTER</code> 操作合并到一条语句中执行，这样 MySQL 只会重构一次表，效率远高于分多条执行。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 推荐：合并执行</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users</span><br><span class="line">  <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> age TINYINT UNSIGNED,</span><br><span class="line">  MODIFY <span class="keyword">COLUMN</span> username <span class="type">VARCHAR</span>(<span class="number">60</span>),</span><br><span class="line">  <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> email;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不推荐：分条执行</span></span><br><span class="line"><span class="comment">-- ALTER TABLE users ADD COLUMN age TINYINT UNSIGNED;</span></span><br><span class="line"><span class="comment">-- ALTER TABLE users MODIFY COLUMN username VARCHAR(60);</span></span><br><span class="line"><span class="comment">-- ALTER TABLE users DROP COLUMN email;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用专业工具</strong>: 对于上亿行的大表，应避免直接使用 <code>ALTER</code>。可以采用 Percona Toolkit 中的 <code>pt-online-schema-change</code> 或 GitHub 的 <code>gh-ost</code> 等在线 DDL 工具。它们通过触发器和数据拷贝技术，可以在不锁表的情况下完成表结构变更，对线上服务影响极小。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-1-3-DROP-删除数据库对象"><a href="#2-1-3-DROP-删除数据库对象" class="headerlink" title="2.1.3 DROP - 删除数据库对象"></a>2.1.3 <code>DROP</code> - 删除数据库对象</h4><p><code>DROP</code> 命令用于从数据库中永久性地删除一个已经存在的对象，例如数据库、表、视图、索引等。这个操作是<strong>不可逆的</strong>，它不仅会删除对象的定义（元数据），还会删除其包含的所有数据。</p>
<p><strong>核心原则：极度谨慎 (Extreme Caution)</strong></p>
<ul>
<li><strong>不可恢复</strong>: 与 <code>DELETE</code>（DML命令，可回滚）不同，<code>DROP</code> 是一个 DDL 命令，它会立即提交，无法通过事务 <code>ROLLBACK</code> 来撤销。一旦执行，数据和结构就从物理层面被删除了。</li>
<li><strong>备份是唯一的“后悔药”</strong>: 在执行任何 <code>DROP</code> 操作，尤其是在生产环境中，必须确保有最新的、可用的备份。</li>
<li><strong>权限控制</strong>: 严格控制用户的 <code>DROP</code> 权限是数据库安全管理的重要一环。只有高级管理员或DBA才应拥有此权限。</li>
</ul>
<h5 id="1-删除数据库-DROP-DATABASE"><a href="#1-删除数据库-DROP-DATABASE" class="headerlink" title="1. 删除数据库 (DROP DATABASE)"></a>1. 删除数据库 (DROP DATABASE)</h5><p>此命令会删除整个数据库，包括其中的所有表、视图、索引、触发器、存储过程等，以及所有数据。这是最危险的 <code>DROP</code> 操作。</p>
<ul>
<li><p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] database_name;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>IF EXISTS</code>: 这是一个安全检查选项。如果指定的数据库存在，则删除它；如果不存在，则命令不会执行，也不会报错（只会产生一个警告）。这在自动化脚本中非常有用，可以避免因数据库不存在而导致的脚本中断。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 尝试删除名为 &#x27;old_project_db&#x27; 的数据库</span></span><br><span class="line"><span class="comment">-- 如果它存在，将被彻底删除；如果不存在，则什么也不做。</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> old_project_db;</span><br></pre></td></tr></table></figure>

<p><strong>警告</strong>: 在生产环境中执行此命令前，请确保你100%确定自 己在做什么，并且已经通知了所有相关方。</p>
</li>
</ul>
<hr>
<h5 id="2-删除表-DROP-TABLE"><a href="#2-删除表-DROP-TABLE" class="headerlink" title="2. 删除表 (DROP TABLE)"></a>2. 删除表 (DROP TABLE)</h5><p>此命令用于删除一个或多个表。</p>
<ul>
<li><p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] table_name1, table_name2, ...;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>IF EXISTS</code>: 同样用于防止因表不存在而报错。</li>
<li>可以一次性删除多个表，表名之间用逗号隔开。</li>
</ul>
</li>
<li><p><strong>连锁反应</strong>:</p>
<ul>
<li><strong>数据丢失</strong>: 表中的所有行数据都将被删除。</li>
<li><strong>对象依赖</strong>: 与该表相关的索引、触发器、约束（如外键引用）等也会被一并删除。</li>
<li><strong>外键问题</strong>: 如果一个表被其他表的外键所引用，直接 <code>DROP</code> 该表将会失败，并报错。你必须先删除引用它的外键约束，或者先删除引用它的表。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除一个名为 &#x27;temp_users&#x27; 的临时表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> temp_users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同时删除 &#x27;logs_2020&#x27; 和 &#x27;logs_2021&#x27; 两个归档表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> logs_2020, logs_2021;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-删除索引-DROP-INDEX"><a href="#3-删除索引-DROP-INDEX" class="headerlink" title="3. 删除索引 (DROP INDEX)"></a>3. 删除索引 (DROP INDEX)</h5><p>用于删除表上的一个索引。删除不再需要或效果不佳的索引可以节省存储空间，并减少写操作（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>）时的维护开销。</p>
<ul>
<li><p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>index_name</code>: 要删除的索引的名称。</li>
<li><code>table_name</code>: 索引所在的表名。</li>
<li><strong>注意</strong>: 主键索引不能通过 <code>DROP INDEX</code> 删除，必须使用 <code>ALTER TABLE ... DROP PRIMARY KEY</code>。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除在 &#x27;users&#x27; 表上为 &#x27;email&#x27; 字段创建的索引 &#x27;idx_email&#x27;</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_email <span class="keyword">ON</span> users;</span><br></pre></td></tr></table></figure>

<p><strong>Tip</strong>: 如果不确定索引名，可以使用 <code>SHOW INDEX FROM table_name;</code> 来查看。</p>
</li>
</ul>
<hr>
<h5 id="4-删除视图-DROP-VIEW"><a href="#4-删除视图-DROP-VIEW" class="headerlink" title="4. 删除视图 (DROP VIEW)"></a>4. 删除视图 (DROP VIEW)</h5><p>删除一个之前创建的视图。删除视图不会影响其引用的基表（即视图所查询的原始表）。</p>
<ul>
<li><p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] view_name1, view_name2, ...;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除之前创建的 &#x27;active_users_view&#x27; 视图</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> active_users_view;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-DROP-vs-TRUNCATE-vs-DELETE"><a href="#5-DROP-vs-TRUNCATE-vs-DELETE" class="headerlink" title="5. DROP vs TRUNCATE vs DELETE"></a>5. <code>DROP</code> vs <code>TRUNCATE</code> vs <code>DELETE</code></h5><p>这是一个非常经典的面试题。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>DROP TABLE</code></th>
<th align="left"><code>TRUNCATE TABLE</code></th>
<th align="left"><code>DELETE FROM table</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>命令类型</strong></td>
<td align="left"><strong>DDL</strong> (数据定义语言)</td>
<td align="left"><strong>DDL</strong></td>
<td align="left"><strong>DML</strong> (数据操作语言)</td>
</tr>
<tr>
<td align="left"><strong>操作对象</strong></td>
<td align="left"><strong>整个表</strong> (结构+数据)</td>
<td align="left"><strong>表中的所有数据</strong> (保留结构)</td>
<td align="left"><strong>一行或多行数据</strong> (可带<code>WHERE</code>)</td>
</tr>
<tr>
<td align="left"><strong>事务支持</strong></td>
<td align="left"><strong>隐式提交，不可回滚</strong></td>
<td align="left"><strong>隐式提交，不可回滚</strong></td>
<td align="left"><strong>可回滚</strong> (在事务中)</td>
</tr>
<tr>
<td align="left"><strong>执行速度</strong></td>
<td align="left">快</td>
<td align="left"><strong>非常快</strong> (通常是重建空表)</td>
<td align="left">慢 (逐行删除，记录日志)</td>
</tr>
<tr>
<td align="left"><strong>触发器</strong></td>
<td align="left">不会触发</td>
<td align="left"><strong>不会触发</strong></td>
<td align="left"><strong>会触发</strong> (逐行)</td>
</tr>
<tr>
<td align="left"><strong><code>AUTO_INCREMENT</code></strong></td>
<td align="left">计数器随表删除</td>
<td align="left"><strong>重置为初始值</strong></td>
<td align="left"><strong>不重置</strong></td>
</tr>
<tr>
<td align="left"><strong>空间回收</strong></td>
<td align="left"><strong>立即回收</strong></td>
<td align="left"><strong>立即回收</strong></td>
<td align="left">不一定立即回收 (取决于存储引擎)</td>
</tr>
<tr>
<td align="left"><strong>核心用途</strong></td>
<td align="left">彻底废弃一张表</td>
<td align="left">快速清空一张表，保留其结构</td>
<td align="left">按条件删除部分或全部数据</td>
</tr>
</tbody></table>
<p><strong>总结</strong>:</p>
<ul>
<li>想删除表结构和数据，用 <code>DROP</code>。</li>
<li>想保留表结构，但快速清空所有数据，用 <code>TRUNCATE</code>。</li>
<li>想删除表中的部分数据（或者全部，但不重置自增ID），并且希望操作能被回滚，用 <code>DELETE</code>。</li>
</ul>
<hr>
<h3 id="2-2-DML（数据操作语言）"><a href="#2-2-DML（数据操作语言）" class="headerlink" title="2.2 DML（数据操作语言）"></a>2.2 DML（数据操作语言）</h3><p>DML（Data Manipulation Language，数据操作语言）是 SQL 的核心组成部分之一，专门用于管理和操作数据库表中的数据记录（行）。与 DDL 负责定义和管理数据库对象（如表、索引）的结构不同，DML 关注的是表中的具体内容。</p>
<p>DML 主要包含以下三个核心命令：</p>
<ul>
<li><strong><code>INSERT</code></strong>：添加新数据</li>
<li><strong><code>UPDATE</code></strong>：修改已存在的数据</li>
<li><strong><code>DELETE</code></strong>：删除数据</li>
</ul>
<p>为了方便演示，我们先创建一个用于学习的 <code>students</code> 表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> students (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    enroll_date <span class="type">DATE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-1-INSERT-插入数据"><a href="#2-2-1-INSERT-插入数据" class="headerlink" title="2.2.1 INSERT - 插入数据"></a>2.2.1 <code>INSERT</code> - 插入数据</h4><p><code>INSERT</code> 语句用于向表中添加一行或多行新的数据。</p>
<h5 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h5><ul>
<li><p><strong>指定列插入</strong>：这是最常用和最推荐的方式，可以忽略有默认值或允许为 NULL 的列。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name (column1, column2, column3, ...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, value3, ...);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全列插入</strong>：如果不指定列名，则必须为表中的每一列按顺序提供一个值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, value3, ...);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>插入多行</strong>：一次性插入多条记录，效率更高。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name (column1, column2, ...)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (value1_row1, value2_row1, ...),</span><br><span class="line">    (value1_row2, value2_row2, ...),</span><br><span class="line">    (value1_row3, value3_row3, ...);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h5><ul>
<li><p><strong>向 <code>students</code> 表插入一条完整的记录：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> students (id, name, age, email, enroll_date)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;zhangsan@example.com&#x27;</span>, <span class="string">&#x27;2023-09-01&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>由于 <code>id</code> 是自增主键，我们通常可以省略它，让系统自动分配：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> students (name, age, email, enroll_date)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;李四&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;lisi@example.com&#x27;</span>, <span class="string">&#x27;2023-09-01&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>只插入部分列的数据（假设 <code>age</code> 和 <code>enroll_date</code> 可以为空）：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> students (name, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;wangwu@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>一次性插入多条记录：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> students (name, age, email, enroll_date)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;赵六&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;zhaoliu@example.com&#x27;</span>, <span class="string">&#x27;2023-09-02&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;孙七&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;sunqi@example.com&#x27;</span>, <span class="string">&#x27;2023-09-03&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-2-UPDATE-更新数据"><a href="#2-2-2-UPDATE-更新数据" class="headerlink" title="2.2.2 UPDATE - 更新数据"></a>2.2.2 <code>UPDATE</code> - 更新数据</h4><p><code>UPDATE</code> 语句用于修改表中的已存在记录。</p>
<h5 id="1-基本语法-1"><a href="#1-基本语法-1" class="headerlink" title="1. 基本语法"></a><strong>1. 基本语法</strong></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SET</code> 子句：指定要修改的列和它们的新值。</li>
<li><code>WHERE</code> 子句：指定要更新哪些行。<strong>这是 <code>UPDATE</code> 语句的灵魂</strong>，如果省略，将会更新表中的 <strong>所有行</strong>！</li>
</ul>
<p><strong>警告：</strong> 在生产环境中执行 <code>UPDATE</code> 操作前，强烈建议先用 <code>SELECT</code> 语句搭配相同的 <code>WHERE</code> 条件，检查将要被更新的记录是否正确。</p>
<h5 id="2-示例-1"><a href="#2-示例-1" class="headerlink" title="2. 示例"></a><strong>2. 示例</strong></h5><ul>
<li><p><strong>更新指定 <code>id</code> 的学生的年龄和邮箱：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students</span><br><span class="line"><span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">23</span>, email <span class="operator">=</span> <span class="string">&#x27;lisi_new@example.com&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>; <span class="comment">-- 精确匹配要更新的行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将所有入学日期早于 <code>2023-09-02</code> 的学生的年龄增加 1：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students</span><br><span class="line"><span class="keyword">SET</span> age <span class="operator">=</span> age <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> enroll_date <span class="operator">&lt;</span> <span class="string">&#x27;2023-09-02&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>危险操作：更新所有行的年龄（没有 <code>WHERE</code> 子句）：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这是一个危险的示例，请谨慎使用！</span></span><br><span class="line"><span class="keyword">UPDATE</span> students</span><br><span class="line"><span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">25</span>; <span class="comment">-- 这会将表中所有学生的年龄都改为 25</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-3-DELETE-删除数据"><a href="#2-2-3-DELETE-删除数据" class="headerlink" title="2.2.3 DELETE - 删除数据"></a>2.2.3 <code>DELETE</code> - 删除数据</h4><p><code>DELETE</code> 语句用于从表中删除一行或多行数据。</p>
<h5 id="1-基本语法-2"><a href="#1-基本语法-2" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>WHERE</code> 子句：指定要删除哪些行。与 <code>UPDATE</code> 一样，<strong>如果省略 <code>WHERE</code> 子句，将会删除表中的所有数据</strong>！</li>
</ul>
<p><strong>警告：</strong> 与 <code>UPDATE</code> 类似，在执行 <code>DELETE</code> 前，务必用 <code>SELECT</code> 和相同的 <code>WHERE</code> 条件确认要删除的数据范围。</p>
<h5 id="2-示例-2"><a href="#2-示例-2" class="headerlink" title="2. 示例"></a>2. 示例</h5><ul>
<li><p><strong>删除 <code>id</code> 为 1 的学生记录：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除所有年龄小于 20 岁的学生记录：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">&lt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>危险操作：删除表中的所有数据（没有 <code>WHERE</code> 子句）：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这是一个危险的示例，请谨慎使用！</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-3-DQL（数据查询语言）"><a href="#2-3-DQL（数据查询语言）" class="headerlink" title="2.3 DQL（数据查询语言）"></a>2.3 DQL（数据查询语言）</h3><p>DQL (Data Query Language) 是 SQL 中用于从数据库中检索数据的部分。它是数据库操作中使用最频繁的语言，其核心和唯一的命令就是 <code>SELECT</code>。<code>SELECT</code> 语句功能极其强大和灵活，能够满足从简单查询到复杂数据分析的各种需求。</p>
<h4 id="2-3-1-SELECT-语句的基本结构"><a href="#2-3-1-SELECT-语句的基本结构" class="headerlink" title="2.3.1 SELECT 语句的基本结构"></a>2.3.1 <code>SELECT</code> 语句的基本结构</h4><p>一个完整 <code>SELECT</code> 语句的语法结构（按书写顺序）如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] column_list <span class="comment">-- 5. 选择要显示的列或表达式</span></span><br><span class="line"><span class="keyword">FROM</span> table_name                 <span class="comment">-- 1. 从哪个表中获取数据</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>                  <span class="comment">-- 2. 过滤不满足条件的行</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> group_by_expression   <span class="comment">-- 3. 按指定列对行进行分组</span></span><br><span class="line"><span class="keyword">HAVING</span> group_condition           <span class="comment">-- 4. 过滤不满足条件的分组</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_list [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]  <span class="comment">-- 6. 对最终结果进行排序</span></span><br><span class="line">LIMIT count <span class="operator">|</span> [<span class="keyword">offset</span>,] count; <span class="comment">-- 7. 限制返回结果的数量</span></span><br></pre></td></tr></table></figure>

<p><strong>逻辑执行顺序</strong>：尽管书写顺序如上，但数据库内部的逻辑处理顺序通常是：<code>FROM</code> -&gt; <code>WHERE</code> -&gt; <code>GROUP BY</code> -&gt; <code>HAVING</code> -&gt; <code>SELECT</code> -&gt; <code>ORDER BY</code> -&gt; <code>LIMIT</code>。理解这个顺序对于编写和优化复杂查询至关重要。</p>
<p>为了方便演示，我们使用之前创建的 <code>students</code> 表，并多插入几条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 确保表中有足够的数据用于演示</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> students (name, age, email, enroll_date)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;zhangsan@example.com&#x27;</span>, <span class="string">&#x27;2023-09-01&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;李四&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;lisi@example.com&#x27;</span>, <span class="string">&#x27;2023-09-01&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;王五&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;wangwu@example.com&#x27;</span>, <span class="string">&#x27;2023-09-02&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;赵六&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;zhaoliu@example.com&#x27;</span>, <span class="string">&#x27;2023-09-02&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;孙七&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;sunqi@example.com&#x27;</span>, <span class="string">&#x27;2023-09-03&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;周八&#x27;</span>, <span class="number">20</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;2023-09-03&#x27;</span>); <span class="comment">-- email 为 NULL 的记录</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-2-各子句详解"><a href="#2-3-2-各子句详解" class="headerlink" title="2.3.2 各子句详解"></a>2.3.2 各子句详解</h4><h5 id="1-SELECT-FROM-选择列与数据源"><a href="#1-SELECT-FROM-选择列与数据源" class="headerlink" title="1. SELECT &amp; FROM - 选择列与数据源"></a>1. <code>SELECT</code> &amp; <code>FROM</code> - 选择列与数据源</h5><p>这是最基础的查询，指定从哪个表 (<code>FROM</code>) 获取哪些列 (<code>SELECT</code>) 的数据。</p>
<ul>
<li><p><strong>查询所有列</strong>：使用 <code>*</code> 通配符。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：在实际应用中，不推荐使用 <code>*</code>，因为它会返回所有列，可能导致不必要的网络开销和性能问题。明确指定你需要的列是更好的实践。</p>
</blockquote>
</li>
<li><p><strong>查询指定列</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, email <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用别名 (<code>AS</code>)</strong>：可以为列和表指定一个临时的、更具可读性的名字。<code>AS</code> 关键字可以省略。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">AS</span> <span class="string">&#x27;学生姓名&#x27;</span>, age <span class="string">&#x27;学生年龄&#x27;</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>去重 (<code>DISTINCT</code>)</strong>：返回唯一不同的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有学生所在的年龄，去除重复项</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> age <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-WHERE-行过滤"><a href="#2-WHERE-行过滤" class="headerlink" title="2. WHERE - 行过滤"></a>2. <code>WHERE</code> - 行过滤</h5><p><code>WHERE</code> 子句用于根据指定的条件过滤行。</p>
<ul>
<li><p><strong>常用操作符</strong>：</p>
<ul>
<li>比较运算符：<code>=</code>、<code>!=</code> (或 <code>&lt;&gt;</code>)、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></li>
<li>逻辑运算符：<code>AND</code>、<code>OR</code>、<code>NOT</code></li>
<li>范围运算符：<code>BETWEEN ... AND ...</code></li>
<li>集合运算符：<code>IN (...)</code>、<code>NOT IN (...)</code></li>
<li>模式匹配：<code>LIKE</code> (搭配 <code>%</code> 匹配任意多个字符, <code>_</code> 匹配单个字符)</li>
<li>空值判断：<code>IS NULL</code>、<code>IS NOT NULL</code></li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄为 20 岁的学生</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄大于 20 且入学日期在 2023-09-01 之后的学生</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">AND</span> enroll_date <span class="operator">&gt;</span> <span class="string">&#x27;2023-09-01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄是 20 或 22 岁的学生</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="number">20</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓“张”的学生</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;张%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 email 未填写的学生</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> email <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-GROUP-BY-分组"><a href="#3-GROUP-BY-分组" class="headerlink" title="3. GROUP BY - 分组"></a>3. <code>GROUP BY</code> - 分组</h5><p><code>GROUP BY</code> 子句通常与聚合函数一起使用，将具有相同值的行分为一组，然后对每组进行计算。</p>
<ul>
<li><p><strong>常用聚合函数</strong>：</p>
<ul>
<li><code>COUNT()</code>: 统计行数</li>
<li><code>SUM()</code>: 求和</li>
<li><code>AVG()</code>: 计算平均值</li>
<li><code>MAX()</code>: 找出最大值</li>
<li><code>MIN()</code>: 找出最小值</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 统计每个年龄段的学生人数</span></span><br><span class="line"><span class="keyword">SELECT</span> age, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> student_count</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age;</span><br></pre></td></tr></table></figure>

<p><strong>结果可能如下：</strong></p>
<table>
<thead>
<tr>
<th>age</th>
<th>student_count</th>
</tr>
</thead>
<tbody><tr>
<td>20</td>
<td>3</td>
</tr>
<tr>
<td>21</td>
<td>1</td>
</tr>
<tr>
<td>22</td>
<td>2</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h5 id="4-HAVING-分组过滤"><a href="#4-HAVING-分组过滤" class="headerlink" title="4. HAVING - 分组过滤"></a>4. <code>HAVING</code> - 分组过滤</h5><p><code>HAVING</code> 子句用于过滤由 <code>GROUP BY</code> 创建的分组。</p>
<ul>
<li><p><strong><code>WHERE</code> vs <code>HAVING</code></strong>：</p>
<ul>
<li><code>WHERE</code> 在分组 <strong>前</strong> 对原始行进行过滤。</li>
<li><code>HAVING</code> 在分组 <strong>后</strong> 对聚合结果进行过滤。</li>
<li><code>HAVING</code> 子句中可以使用聚合函数，而 <code>WHERE</code> 不能。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找出学生人数超过 1 人的年龄段</span></span><br><span class="line"><span class="keyword">SELECT</span> age, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> student_count</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> age</span><br><span class="line"><span class="keyword">HAVING</span> student_count <span class="operator">&gt;</span> <span class="number">1</span>; <span class="comment">-- 或者 HAVING COUNT(*) &gt; 1</span></span><br></pre></td></tr></table></figure>

<p><strong>结果可能如下：</strong></p>
<table>
<thead>
<tr>
<th>age</th>
<th>student_count</th>
</tr>
</thead>
<tbody><tr>
<td>20</td>
<td>3</td>
</tr>
<tr>
<td>22</td>
<td>2</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h5 id="5-ORDER-BY-排序"><a href="#5-ORDER-BY-排序" class="headerlink" title="5. ORDER BY - 排序"></a>5. <code>ORDER BY</code> - 排序</h5><p><code>ORDER BY</code> 子句用于对最终的结果集进行排序。</p>
<ul>
<li><p><code>ASC</code>：升序（默认）</p>
</li>
<li><p><code>DESC</code>：降序</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按年龄降序排列所有学生</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先按年龄升序，如果年龄相同，再按姓名升序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>, name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-LIMIT-限制结果数量"><a href="#6-LIMIT-限制结果数量" class="headerlink" title="6. LIMIT - 限制结果数量"></a>6. <code>LIMIT</code> - 限制结果数量</h5><p><code>LIMIT</code> 子句用于限制返回的行数，常用于分页查询。</p>
<ul>
<li><p><strong>语法</strong>：</p>
<ul>
<li><code>LIMIT n</code>: 返回前 <code>n</code> 条记录。</li>
<li><code>LIMIT offset, n</code>: 跳过 <code>offset</code> 条记录，然后返回接下来的 <code>n</code> 条记录。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄最大的前 3 名学生</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span> LIMIT <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分页查询：假设每页显示 2 条，查询第 2 页的数据</span></span><br><span class="line"><span class="comment">-- (页码 - 1) * 每页数量 = offset</span></span><br><span class="line"><span class="comment">-- (2 - 1) * 2 = 2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students LIMIT <span class="number">2</span>, <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-4-DCL（数据控制语言）"><a href="#2-4-DCL（数据控制语言）" class="headerlink" title="2.4 DCL（数据控制语言）"></a>2.4 DCL（数据控制语言）</h3><p>DCL (Data Control Language) 用于定义数据库的访问权限和安全级别，核心作用是<strong>控制哪个用户可以对哪些数据库对象（库、表、列等）执行哪些操作</strong>。DCL 是<strong>数据库管理员 (DBA)</strong> 用来管理用户和权限的重要工具（<strong>了解即可</strong>）。</p>
<p>在 MySQL 中，DCL 主要由 <code>GRANT</code> 和 <code>REVOKE</code> 两个命令构成，同时通常会配合用户管理的命令（如 <code>CREATE USER</code>, <code>DROP USER</code>）一起使用。</p>
<h4 id="2-4-1-核心命令"><a href="#2-4-1-核心命令" class="headerlink" title="2.4.1 核心命令"></a>2.4.1 核心命令</h4><h5 id="1-GRANT-授权"><a href="#1-GRANT-授权" class="headerlink" title="1. GRANT (授权)"></a>1. <code>GRANT</code> (授权)</h5><p><code>GRANT</code> 命令用于授予用户一个或多个权限。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privilege_type [(column_list)] [, privilege_type [(column_list)]] ...</span><br><span class="line"><span class="keyword">ON</span> [object_type] privilege_level</span><br><span class="line"><span class="keyword">TO</span> user_identity [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>] [, user_identity [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>]] ...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION];</span><br></pre></td></tr></table></figure>

<p><strong>语法解析：</strong></p>
<ul>
<li><code>privilege_type</code>: 权限类型，如 <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>ALL PRIVILEGES</code> (所有权限) 等。</li>
<li><code>column_list</code>: 可选，指定权限作用于哪些列。</li>
<li><code>object_type</code>: 可选，对象类型，如 <code>TABLE</code>, <code>FUNCTION</code>, <code>PROCEDURE</code>。</li>
<li><code>privilege_level</code>: 权限级别，指定权限作用的范围。<ul>
<li>全局级别: <code>*.*</code> (所有数据库的所有对象)</li>
<li>数据库级别: <code>database_name.*</code> (指定数据库的所有对象)</li>
<li>表级别: <code>database_name.table_name</code> (指定数据库的指定表)</li>
<li>列级别: 在 <code>privilege_type</code> 后面通过 <code>(column_list)</code> 指定。</li>
</ul>
</li>
<li><code>user_identity</code>: 用户身份，格式为 <code>&#39;username&#39;@&#39;hostname&#39;</code>。<ul>
<li><code>username</code>: 用户名。</li>
<li><code>hostname</code>: 允许用户登录的主机。可以是 <code>localhost</code> (本地)，具体的 IP 地址，或 <code>%</code> (任意主机)。</li>
</ul>
</li>
<li><code>IDENTIFIED BY &#39;password&#39;</code>: 可选，如果用户不存在，<code>GRANT</code> 会自动创建新用户并设置密码。<strong>（注意：在较新的 MySQL 版本中，这种隐式创建用户的方式已被弃用或移除，推荐先使用 <code>CREATE USER</code> 创建用户。）</strong></li>
<li><code>WITH GRANT OPTION</code>: 可选，如果加上此选项，被授权的用户可以将自己拥有的权限再授予其他用户。这是一个非常强大的权限，需要谨慎使用。</li>
</ul>
<p><strong>示例：</strong></p>
<ol>
<li><p><strong>授予用户对特定数据库的所有权限</strong></p>
<ul>
<li>场景：创建一个名为 <code>dev_user</code> 的用户，密码为 <code>DevPassword123</code>，允许他从任何主机 (<code>%</code>) 连接，并拥有 <code>my_project_db</code> 数据库的全部权限。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 推荐做法：先创建用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;dev_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;DevPassword123&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再授予权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> my_project_db.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;dev_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>授予用户对特定表的读写权限</strong></p>
<ul>
<li>场景：授予用户 <code>readonly_user</code> 对 <code>employees</code> 数据库的 <code>salaries</code> 表只有 <code>SELECT</code> (读取) 权限。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;readonly_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;ReadOnlyPass!&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> employees.salaries <span class="keyword">TO</span> <span class="string">&#x27;readonly_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>授予用户对特定表的部分操作权限</strong></p>
<ul>
<li>场景：授予用户 <code>app_user</code> 对 <code>sales</code> 数据库的 <code>orders</code> 表有 <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code> 权限，但没有 <code>DELETE</code> 权限。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;192.168.1.100&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;AppSecurePass&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span> <span class="keyword">ON</span> sales.orders <span class="keyword">TO</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;192.168.1.100&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>授予用户对特定列的权限</strong></p>
<ul>
<li>场景：HR 实习生 <code>hr_intern</code> 只能查看 <code>employees</code> 表的 <code>name</code> 和 <code>hire_date</code> 列，但不能看 <code>salary</code> 列。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;hr_intern&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;InternPass&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> (name, hire_date) <span class="keyword">ON</span> my_project_db.employees <span class="keyword">TO</span> <span class="string">&#x27;hr_intern&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="2-REVOKE-撤销权限"><a href="#2-REVOKE-撤销权限" class="headerlink" title="2. REVOKE (撤销权限)"></a>2. <code>REVOKE</code> (撤销权限)</h5><p><code>REVOKE</code> 命令是 <code>GRANT</code> 的反向操作，用于撤销已经授予用户的权限。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privilege_type [(column_list)] [, privilege_type [(column_list)]] ...</span><br><span class="line"><span class="keyword">ON</span> [object_type] privilege_level</span><br><span class="line"><span class="keyword">FROM</span> user_identity [, user_identity] ...;</span><br></pre></td></tr></table></figure>

<p><strong>语法解析：</strong></p>
<p><code>REVOKE</code> 的语法与 <code>GRANT</code> 非常相似，只是将 <code>TO</code> 关键字换成了 <code>FROM</code>。</p>
<p><strong>示例：</strong></p>
<ol>
<li><p><strong>撤销用户的 <code>DELETE</code> 权限</strong></p>
<ul>
<li>场景：<code>app_user</code> 之前被误授了 <code>DELETE</code> 权限，现在需要撤销。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> sales.orders <span class="keyword">FROM</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;192.168.1.100&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>撤销用户对数据库的所有权限</strong></p>
<ul>
<li>场景：<code>dev_user</code> 离职，需要撤销其在 <code>my_project_db</code> 上的所有权限。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> my_project_db.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;dev_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <code>REVOKE ALL PRIVILEGES</code> 只会撤销明确授予的权限，不会撤销 <code>GRANT OPTION</code>。需要单独撤销：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">GRANT</span> OPTION <span class="keyword">ON</span> my_project_db.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;dev_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="2-4-2-用户管理（与-DCL-密切相关）"><a href="#2-4-2-用户管理（与-DCL-密切相关）" class="headerlink" title="2.4.2 用户管理（与 DCL 密切相关）"></a>2.4.2 用户管理（与 DCL 密切相关）</h4><p>虽然严格来说 <code>CREATE USER</code>、<code>DROP USER</code> 等属于 DDL，但在实践中它们总是和 DCL 一起使用，共同完成权限管理。</p>
<ul>
<li><p><strong>创建用户 (<code>CREATE USER</code>)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除用户 (<code>DROP USER</code>)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改密码 (<code>ALTER USER</code> 或 <code>SET PASSWORD</code>)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 推荐方式 (MySQL 5.7.6+)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 旧版方式</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span> <span class="operator">=</span> PASSWORD(<span class="string">&#x27;new_password&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-4-3-查看权限"><a href="#2-4-3-查看权限" class="headerlink" title="2.4.3 查看权限"></a>2.4.3 查看权限</h4><p>管理权限后，验证权限是否正确配置至关重要。</p>
<ul>
<li><p><strong>查看当前用户的权限</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看指定用户的权限</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 app_user 的权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;192.168.1.100&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果会清晰地列出该用户被授予的所有权限。</p>
</li>
</ul>
<hr>
<h4 id="2-4-4-最佳实践"><a href="#2-4-4-最佳实践" class="headerlink" title="2.4.4 最佳实践"></a>2.4.4 最佳实践</h4><ol>
<li><strong>最小权限原则 (Principle of Least Privilege)</strong>：只授予用户完成其工作所必需的最小权限。不要为了方便而授予 <code>ALL PRIVILEGES</code>。</li>
<li><strong>精确控制主机 (<code>hostname</code>)</strong>：尽量不要使用 <code>%</code>，而是指定具体的 IP 地址或 <code>localhost</code>，限制用户只能从可信的来源连接数据库。</li>
<li><strong>禁止应用程序使用 <code>root</code> 账号</strong>：<code>root</code> 账号权限过高，一旦泄露，后果不堪设想。应为每个应用程序创建独立的、权限受限的数据库账号。</li>
<li><strong>定期审查权限</strong>：定期检查用户的权限设置，及时回收不再需要的权限，删除已离职或废弃的账号。</li>
<li><strong>谨慎使用 <code>WITH GRANT OPTION</code></strong>：此权限会打破权限的集中管理，可能导致权限失控，只在确实需要时才授予可信的用户。</li>
<li><strong>先 <code>CREATE USER</code>，后 <code>GRANT</code></strong>：遵循“显式优于隐式”的原则，先创建用户，再进行授权，这使得权限管理逻辑更清晰，也符合新版 MySQL 的推荐做法。</li>
</ol>
<hr>
<h3 id="2-5-TCL（事务控制语言）"><a href="#2-5-TCL（事务控制语言）" class="headerlink" title="2.5 TCL（事务控制语言）"></a>2.5 TCL（事务控制语言）</h3><p>TCL (Transaction Control Language) 用于管理数据库中的事务，确保一组操作要么<strong>全部成功</strong>，要么<strong>全部失败</strong>，从而保障数据的完整性和一致性。这在执行关键业务操作（如银行转账、订单创建）时至关重要。</p>
<p>一个<strong>事务 (Transaction)</strong> 是一个或多个 SQL 语句组成的逻辑工作单元 (Logical Unit of Work)。</p>
<h4 id="2-5-1-核心概念：autocommit"><a href="#2-5-1-核心概念：autocommit" class="headerlink" title="2.5.1 核心概念：autocommit"></a>2.5.1 核心概念：<code>autocommit</code></h4><p>在深入 TCL 命令之前，必须理解 MySQL 的 <code>autocommit</code>（自动提交）模式。</p>
<ul>
<li><p><strong>什么是 <code>autocommit</code>？</strong><br><code>autocommit</code> 是一个系统变量。当它开启时 (<code>ON</code> 或 <code>1</code>)，每一条 DML 语句（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>）在执行后都会被立即、自动地视为一个独立的事务并提交，使其更改永久生效。这是 MySQL 的默认行为。当它关闭时 (<code>OFF</code> 或 <code>0</code>)，所有 DML 语句都必须由一个明确的 <code>COMMIT</code> 命令来提交，或者由 <code>ROLLBACK</code> 来撤销。</p>
</li>
<li><p><strong>查看和设置 <code>autocommit</code></strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前的 autocommit 状态 (1 表示开启, 0 表示关闭)</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭当前会话的 autocommit</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重新开启当前会话的 autocommit</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>START TRANSACTION</code> 或 <code>BEGIN</code> 命令会自动关闭 <code>autocommit</code>，直到事务以 <code>COMMIT</code> 或 <code>ROLLBACK</code> 结束。</p>
</li>
</ul>
<hr>
<h4 id="2-5-2-核心命令"><a href="#2-5-2-核心命令" class="headerlink" title="2.5.2 核心命令"></a>2.5.2 核心命令</h4><h5 id="1-START-TRANSACTION-或-BEGIN-开始事务"><a href="#1-START-TRANSACTION-或-BEGIN-开始事务" class="headerlink" title="1. START TRANSACTION 或 BEGIN (开始事务)"></a>1. <code>START TRANSACTION</code> 或 <code>BEGIN</code> (开始事务)</h5><p>这两个命令作用相同，用于显式地开启一个事务。执行此命令后，后续的 DML 操作都将成为该事务的一部分，直到遇到 <code>COMMIT</code> 或 <code>ROLLBACK</code>。</p>
<p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-COMMIT-提交事务"><a href="#2-COMMIT-提交事务" class="headerlink" title="2. COMMIT (提交事务)"></a>2. <code>COMMIT</code> (提交事务)</h5><p><code>COMMIT</code> 命令用于<strong>永久性地保存</strong>自事务开始以来所做的所有更改。一旦提交，这些更改将对所有其他用户可见，并且无法再被回滚。</p>
<p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-ROLLBACK-回滚事务"><a href="#3-ROLLBACK-回滚事务" class="headerlink" title="3. ROLLBACK (回滚事务)"></a>3. <code>ROLLBACK</code> (回滚事务)</h5><p><code>ROLLBACK</code> 命令用于<strong>撤销</strong>自事务开始以来所做的所有未提交的更改，将数据恢复到事务开始前的状态。这通常在事务执行过程中发生错误或业务逻辑不满足时使用。</p>
<p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<h5 id="4-SAVEPOINT-设置保存点"><a href="#4-SAVEPOINT-设置保存点" class="headerlink" title="4. SAVEPOINT (设置保存点)"></a>4. <code>SAVEPOINT</code> (设置保存点)</h5><p>在一个较长的事务中，<code>SAVEPOINT</code> 允许你创建一个“书签”或“检查点”。这样，如果后续操作出现问题，你可以选择回滚到这个保存点，而不是回滚整个事务。</p>
<p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个保存点</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> savepoint_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到指定的保存点</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> savepoint_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除一个保存点 (不常用，COMMIT 或 ROLLBACK 会自动删除所有保存点)</span></span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> savepoint_name;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-5-3-综合示例：银行转账"><a href="#2-5-3-综合示例：银行转账" class="headerlink" title="2.5.3 综合示例：银行转账"></a>2.5.3 综合示例：银行转账</h4><p>这是理解事务最经典的例子。假设有一个 <code>accounts</code> 表，我们需要从 A 账户转 100 元到 B 账户。</p>
<p><strong>准备工作：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> accounts (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    balance <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> accounts (id, name, balance) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="number">1000.00</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="number">500.00</span>);</span><br></pre></td></tr></table></figure>

<p><strong>场景一：成功转账</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 步骤1：Alice 账户扣款 100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 步骤2：Bob 账户收款 100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查无误后，提交事务，使更改永久生效</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 验证结果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts;</span><br><span class="line"><span class="comment">-- Alice: 900.00, Bob: 600.00</span></span><br></pre></td></tr></table></figure>

<p>在这个过程中，两个 <code>UPDATE</code> 操作被捆绑在一起。如果 <code>COMMIT</code> 成功，它们将同时生效。</p>
<p><strong>场景二：转账失败（中途发生错误）</strong></p>
<p>假设在扣款后、收款前，系统发生故障或业务检查发现 Alice 余额不足。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 步骤1：Alice 账户扣款 1000 (假设她想转1000，但余额只有900)</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在应用层代码中，我们可能会检查 Alice 扣款后的余额是否为负</span></span><br><span class="line"><span class="comment">-- SELECT balance FROM accounts WHERE id = 1;</span></span><br><span class="line"><span class="comment">-- 发现余额为 -100，这是不允许的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 决定中止操作，回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 验证结果，数据恢复原状</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts;</span><br><span class="line"><span class="comment">-- Alice: 900.00, Bob: 600.00 (数据回到事务开始前的状态)</span></span><br></pre></td></tr></table></figure>

<p><strong>场景三：使用保存点</strong></p>
<p>在一个复杂的订单创建流程中，可能包含“创建订单 -&gt; 更新库存 -&gt; 创建优惠券”三个步骤。如果创建优惠券失败，我们只想撤销库存更新，但保留已创建的订单。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 步骤1: 创建订单 (成功)</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> orders (customer_id, order_date) <span class="keyword">VALUES</span> (<span class="number">101</span>, NOW());</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@order_id</span> <span class="operator">=</span> LAST_INSERT_ID();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置一个保存点</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> after_order_creation;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 步骤2: 更新库存 (成功)</span></span><br><span class="line"><span class="keyword">UPDATE</span> products <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">2</span> <span class="keyword">WHERE</span> product_id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 步骤3: 创建优惠券 (失败，例如优惠券服务不可用)</span></span><br><span class="line"><span class="comment">-- ... 模拟失败 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 发现步骤3失败，回滚到保存点，只撤销库存更新操作</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> after_order_creation;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最后，我们可能决定整个订单都不要了，完全回滚</span></span><br><span class="line"><span class="comment">-- ROLLBACK;</span></span><br><span class="line"><span class="comment">-- 或者，我们决定保留已创建的订单（不含库存更新），然后提交</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-5-4-关键注意事项"><a href="#2-5-4-关键注意事项" class="headerlink" title="2.5.4 关键注意事项"></a>2.5.4 关键注意事项</h4><ol>
<li><strong>存储引擎支持</strong>：事务功能并非所有 MySQL 存储引擎都支持。最常用的 <code>InnoDB</code> 引擎是完全支持事务的，而较老的 <code>MyISAM</code> 引擎则不支持。</li>
<li><strong>事务的范围</strong>：事务只对 DML 语句（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>）有效。DDL 语句（如 <code>CREATE TABLE</code>, <code>DROP TABLE</code>, <code>ALTER TABLE</code>）会导致隐式提交，即在执行 DDL 之前，MySQL 会自动提交当前正在进行的事务。</li>
<li><strong>保持事务简短</strong>：长事务会长时间锁定资源，降低数据库的并发性能，并增加死锁的风险。应尽量让事务包含必要的原子操作，并尽快提交或回滚。</li>
</ol>
<hr>
<h2 id="3-数据类型与约束"><a href="#3-数据类型与约束" class="headerlink" title="3. 数据类型与约束"></a>3. 数据类型与约束</h2><h3 id="3-1-常用数据类型"><a href="#3-1-常用数据类型" class="headerlink" title="3.1 常用数据类型"></a>3.1 常用数据类型</h3><p>在创建表时，为每一列选择正确的数据类型是数据库设计的基石。一个恰当的选择可以：</p>
<ul>
<li><strong>节省存储空间</strong>：使用最小但足够容纳数据的类型。</li>
<li><strong>提升查询性能</strong>：更小的数据类型意味着更快的数据处理和更高效的索引。</li>
<li><strong>保证数据完整性</strong>：类型本身就是一种约束，可以防止无效数据（如在日期列中存入文本）的插入。</li>
</ul>
<p>MySQL 的数据类型主要可以分为三大类：<strong>数值类型</strong>、<strong>字符串类型</strong>和<strong>日期与时间类型</strong>。</p>
<h4 id="3-1-1-数值类型-Numeric-Types"><a href="#3-1-1-数值类型-Numeric-Types" class="headerlink" title="3.1.1 数值类型 (Numeric Types)"></a>3.1.1 数值类型 (Numeric Types)</h4><h5 id="1-整数类型-Integer-Types"><a href="#1-整数类型-Integer-Types" class="headerlink" title="1. 整数类型 (Integer Types)"></a>1. 整数类型 (Integer Types)</h5><p>用于存储没有小数部分的数字，如 ID、数量、年龄等。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储空间</th>
<th>有符号 (Signed) 范围</th>
<th>无符号 (Unsigned) 范围</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>TINYINT</code></td>
<td>1 字节</td>
<td>-128 到 127</td>
<td>0 到 255</td>
<td>状态标志 (0&#x2F;1), 年龄, 非常小的枚举值</td>
</tr>
<tr>
<td><code>SMALLINT</code></td>
<td>2 字节</td>
<td>-32,768 到 32,767</td>
<td>0 到 65,535</td>
<td>较小编号, 物品数量</td>
</tr>
<tr>
<td><code>MEDIUMINT</code></td>
<td>3 字节</td>
<td>-8,388,608 到 8,388,607&#x3D;</td>
<td>0 到 16,777,215</td>
<td>中等大小的编号</td>
</tr>
<tr>
<td><code>INT</code></td>
<td>4 字节</td>
<td>-2,147,483,648 到 2,147,483,647</td>
<td>0 到 4,294,967,295</td>
<td><strong>最常用</strong>，主键 ID, 用户 ID, 计数器</td>
</tr>
<tr>
<td><code>BIGINT</code></td>
<td>8 字节</td>
<td>-9.22 x 10¹⁸ 到 9.22 x 10¹⁸</td>
<td>0 到 1.84 x 10¹⁹</td>
<td>超大表的主键 ID, 微博&#x2F;Twitter 消息 ID, 毫秒时间戳</td>
</tr>
</tbody></table>
<p><strong>关键点：<code>UNSIGNED</code> 属性</strong></p>
<ul>
<li>如果一列的值永远不会是负数（如主键 ID、数量、年龄），应始终使用 <code>UNSIGNED</code> 关键字。</li>
<li>这样做可以将正数范围扩大一倍，并更清晰地表达该列的业务含义。</li>
<li><strong>示例</strong>：<code>CREATE TABLE users (id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT, age TINYINT UNSIGNED);</code></li>
</ul>
<hr>
<h5 id="2-定点数与浮点数-Fixed-Point-and-Floating-Point"><a href="#2-定点数与浮点数-Fixed-Point-and-Floating-Point" class="headerlink" title="2. 定点数与浮点数 (Fixed-Point and Floating-Point)"></a>2. 定点数与浮点数 (Fixed-Point and Floating-Point)</h5><p>用于存储带有小数部分的数字。</p>
<ul>
<li><strong><code>DECIMAL(M, D)</code> &#x2F; <code>NUMERIC(M, D)</code></strong><ul>
<li><strong>类型</strong>：定点数，以字符串形式存储，用于<strong>精确</strong>计算。</li>
<li><strong>M</strong>：总位数（整数部分 + 小数部分）。</li>
<li><strong>D</strong>：小数位数。</li>
<li><strong>用途</strong>：<strong>必须用于</strong>对精度要求极高的场景，如<strong>货币、金融数据、费率</strong>。</li>
<li><strong>示例</strong>：<code>price DECIMAL(10, 2)</code> 可以存储从 -99,999,999.99 到 99,999,999.99 的值。</li>
</ul>
</li>
<li><strong><code>FLOAT(M, D)</code> 和 <code>DOUBLE(M, D)</code></strong><ul>
<li><strong>类型</strong>：浮点数，存储近似值，存在精度损失风险。</li>
<li><code>FLOAT</code>：单精度，约 7 位有效数字。</li>
<li><code>DOUBLE</code>：双精度，约 15 位有效数字。</li>
<li><strong>用途</strong>：科学计算、地理坐标 (GPS)，或当微小误差可以被接受时。</li>
<li><strong>警告</strong>：<strong>绝对不要</strong>用 <code>FLOAT</code> 或 <code>DOUBLE</code> 存储货币数据，否则会导致计算错误。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-1-2-字符串类型-String-Types"><a href="#3-1-2-字符串类型-String-Types" class="headerlink" title="3.1.2 字符串类型 (String Types)"></a>3.1.2 字符串类型 (String Types)</h4><h5 id="1-定长与变长字符串"><a href="#1-定长与变长字符串" class="headerlink" title="1. 定长与变长字符串"></a>1. 定长与变长字符串</h5><ul>
<li><strong><code>CHAR(N)</code></strong><ul>
<li><strong>类型</strong>：定长字符串。N 的范围是 0-255。</li>
<li><strong>工作方式</strong>：存储时，如果字符串长度小于 N，会用空格<strong>填充</strong>到 N 的长度。</li>
<li><strong>优点</strong>：处理速度快，因为长度固定。</li>
<li><strong>用途</strong>：适合存储长度<strong>固定</strong>的数据，如 MD5 哈希值 (<code>CHAR(32)</code>), 国家代码 (<code>CHAR(2)</code>), 邮政编码 (<code>CHAR(6)</code>), 性别 (‘M’&#x2F;‘F’)。</li>
</ul>
</li>
<li><strong><code>VARCHAR(N)</code></strong><ul>
<li><strong>类型</strong>：变长字符串。N 的范围是 0-65,535 (实际受行大小限制)。</li>
<li><strong>工作方式</strong>：只存储实际的字符内容，并额外使用 1-2 个字节来记录字符串的长度。</li>
<li><strong>优点</strong>：节省空间，非常灵活。</li>
<li><strong>用途</strong>：<strong>最常用</strong>的字符串类型，适合存储长度不定的数据，如用户名、标题、地址。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-文本类型-Text-Types"><a href="#2-文本类型-Text-Types" class="headerlink" title="2. 文本类型 (Text Types)"></a>2. 文本类型 (Text Types)</h5><p>用于存储非常长的文本数据。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>最大存储长度</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>TINYTEXT</code></td>
<td>255 字节</td>
<td>简短的描述、长评论</td>
</tr>
<tr>
<td><code>TEXT</code></td>
<td>64 KB</td>
<td>文章内容、博客正文</td>
</tr>
<tr>
<td><code>MEDIUMTEXT</code></td>
<td>16 MB</td>
<td>较长的文档、JSON 数据</td>
</tr>
<tr>
<td><code>LONGTEXT</code></td>
<td>4 GB</td>
<td>巨型文本文件、日志内容</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：<code>TEXT</code> 类型在性能上通常不如 <code>VARCHAR</code>，尤其是在排序和索引方面。应仅在确实需要存储超过 <code>VARCHAR</code> 长度限制的文本时使用。</p>
<hr>
<h5 id="3-二进制大对象-BLOB-Types"><a href="#3-二进制大对象-BLOB-Types" class="headerlink" title="3. 二进制大对象 (BLOB Types)"></a>3. 二进制大对象 (BLOB Types)</h5><p>用于存储大量的二进制数据，如图片、音频文件、PDF 或任何原始字节流。<code>BLOB</code> 类型与 <code>TEXT</code> 类型在存储容量上完全对应，但有本质区别。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>最大存储长度</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>TINYBLOB</code></td>
<td>255 字节</td>
<td>很小的二进制数据，如缩略图的原始数据</td>
</tr>
<tr>
<td><code>BLOB</code></td>
<td>64 KB</td>
<td>小型图片、图标、短音频</td>
</tr>
<tr>
<td><code>MEDIUMBLOB</code></td>
<td>16 MB</td>
<td>文档 (PDF, Word), 较长的音频、小型视频片段</td>
</tr>
<tr>
<td><code>LONGBLOB</code></td>
<td>4 GB</td>
<td>视频文件、大型软件安装包、数据库备份文件（不推荐）</td>
</tr>
</tbody></table>
<p><strong><code>BLOB</code> vs. <code>TEXT</code> 的核心区别：</strong></p>
<ol>
<li><strong>数据内容</strong>：<ul>
<li><code>BLOB</code>：存储的是<strong>二进制字节串</strong> (Binary String)。它没有字符集或排序规则的概念。</li>
<li><code>TEXT</code>：存储的是<strong>非二进制字符串</strong> (Character String)。它有字符集和排序规则，用于正确的字符表示、排序和比较。</li>
</ul>
</li>
<li><strong>处理方式</strong>：<ul>
<li>对 <code>BLOB</code> 进行排序和比较是基于其原始的<strong>数值字节值</strong>。</li>
<li>对 <code>TEXT</code> 进行排序和比较会遵循其列定义的<strong>排序规则</strong>（例如，不区分大小写比较）。</li>
</ul>
</li>
</ol>
<p><strong>选择准则：</strong></p>
<ul>
<li>如果要存储的是人类可读的文本内容（文章、评论、日志），<strong>使用 <code>TEXT</code></strong>。</li>
<li>如果要存储的是非文本的二进制文件（图片、音频、序列化对象），<strong>使用 <code>BLOB</code></strong>。</li>
</ul>
<p><strong>重要注意事项与行业最佳实践：</strong></p>
<ul>
<li><strong>谨慎使用</strong>：在数据库中存储大型文件（尤其是 <code>MEDIUMBLOB</code> 和 <code>LONGBLOB</code>）通常是<strong>反模式 (Anti-Pattern)</strong> 的。</li>
<li><strong>性能影响</strong>：<ul>
<li>会显著增加数据库的体积，导致<strong>备份和恢复时间</strong>急剧变长。</li>
<li><code>SELECT *</code> 这样的查询会变得非常缓慢和消耗内存，因为它需要传输大量数据。</li>
<li>数据库的内存缓存（如 InnoDB Buffer Pool）效率会降低，因为被大对象数据占据。</li>
</ul>
</li>
<li><strong>推荐的替代方案</strong>：<ul>
<li>将文件存储在专用的<strong>文件系统、对象存储服务 (如 AWS S3, 阿里云 OSS) 或内容分发网络 (CDN)</strong> 上。</li>
<li>在数据库中，只存储文件的<strong>元数据</strong> (metadata)，如文件名、大小、类型，以及一个指向文件存储位置的 <strong>URL 或路径</strong>（使用 <code>VARCHAR</code> 类型）。</li>
<li><strong>结论</strong>：除非存储的是非常小的二进制数据（如几十 KB 的小图标），否则强烈建议采用<strong>路径存储</strong>方案。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-1-3-日期与时间类型-Date-and-Time-Types"><a href="#3-1-3-日期与时间类型-Date-and-Time-Types" class="headerlink" title="3.1.3 日期与时间类型 (Date and Time Types)"></a>3.1.3 日期与时间类型 (Date and Time Types)</h4><table>
<thead>
<tr>
<th>类型</th>
<th>存储格式</th>
<th>范围</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>DATE</code></td>
<td>‘YYYY-MM-DD’</td>
<td>‘1000-01-01’ 到 ‘9999-12-31’</td>
<td>出生日期、注册日期</td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>‘HH:MM:SS’</td>
<td>‘-838:59:59’ 到 ‘838:59:59’</td>
<td>营业时间、持续时长</td>
</tr>
<tr>
<td><code>DATETIME</code></td>
<td>‘YYYY-MM-DD HH:MM:SS’</td>
<td>‘1000-01-01…’ 到 ‘9999-12-31…’</td>
<td>订单创建时间、事件发生时间</td>
</tr>
<tr>
<td><code>TIMESTAMP</code></td>
<td>‘YYYY-MM-DD HH:MM:SS’</td>
<td>‘1970-01-01…’ 到 ‘2038-01-19…’</td>
<td>记录的创建&#x2F;更新时间 (<code>created_at</code>, <code>updated_at</code>)</td>
</tr>
<tr>
<td><code>YEAR</code></td>
<td>YYYY</td>
<td>1901 到 2155</td>
<td>年份信息</td>
</tr>
</tbody></table>
<p><strong><code>DATETIME</code> vs <code>TIMESTAMP</code> 的重要区别：</strong></p>
<ol>
<li><strong>时区 (Timezone)</strong>：<ul>
<li><code>DATETIME</code>：<strong>与时区无关</strong>。存储的是你插入时的字面值，查询时也返回这个字面值。</li>
<li><code>TIMESTAMP</code>：<strong>与时区相关</strong>。存储时，MySQL 会将其从当前会话时区转换为 UTC (世界标准时间)；查询时，再从 UTC 转换回当前会话时区。这对于国际化应用至关重要。</li>
</ul>
</li>
<li><strong>范围</strong>：<code>DATETIME</code> 的范围远大于 <code>TIMESTAMP</code>。<code>TIMESTAMP</code> 会在 2038 年遇到“Y2K38”问题。</li>
<li><strong>默认值</strong>：<code>TIMESTAMP</code> 有特殊的自动更新行为，非常适合用作 <code>updated_at</code> 字段。<ul>
<li><code>... updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</code></li>
</ul>
</li>
</ol>
<p><strong>选择建议</strong>：</p>
<ul>
<li>用 <code>TIMESTAMP</code> 记录数据的创建和最后修改时间。</li>
<li>用 <code>DATETIME</code> 记录一个固定的、不应随服务器时区变化的具体时刻，如用户的生日活动时间。</li>
</ul>
<hr>
<h4 id="3-1-4-高级数据类型"><a href="#3-1-4-高级数据类型" class="headerlink" title="3.1.4 高级数据类型"></a>3.1.4 高级数据类型</h4><h5 id="1-JSON-类型-MySQL-5-7"><a href="#1-JSON-类型-MySQL-5-7" class="headerlink" title="1. JSON 类型 (MySQL 5.7+)"></a>1. JSON 类型 (MySQL 5.7+)</h5><ul>
<li><p><strong>核心定义</strong></p>
<ul>
<li>允许在一个字段中存储和操作 JSON 文档（对象或数组）。</li>
<li>与 <code>TEXT</code> 不同，MySQL 会验证其格式是否正确，并以一种优化的二进制格式存储，从而能高效地访问内部元素。</li>
</ul>
</li>
<li><p><strong>优势</strong></p>
<ul>
<li><strong>灵活的模式</strong>：无需预先定义所有字段，非常适合存储结构多变的数据（如商品属性、用户配置）。</li>
<li><strong>专用函数支持</strong>：提供了一整套函数（如 <code>JSON_EXTRACT</code>, <code>JSON_CONTAINS</code>）和操作符（<code>-&gt;</code>, <code>-&gt;&gt;</code>）进行高效查询和操作。</li>
<li><strong>可索引</strong>：可对 JSON 文档内的特定路径创建索引（通过<strong>生成列 (Generated Column)</strong>），以加速查询。</li>
</ul>
</li>
<li><p><strong>用途</strong></p>
<ul>
<li>电商商品规格参数、用户个性化配置、非结构化的日志数据。</li>
</ul>
</li>
<li><p><strong>示例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询品牌为 &#x27;Apple&#x27; 的产品</span></span><br><span class="line"><span class="comment">-- -&gt;&gt; 操作符提取的是不带引号的字符串，适合用于 WHERE 条件</span></span><br><span class="line"><span class="keyword">SELECT</span> name, details <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> details <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;$.brand&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Apple&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong></p>
<ul>
<li><strong>不要滥用</strong>：JSON 不是关系模型的替代品。核心的、结构固定的、需要频繁关联的字段仍应使用传统列。</li>
<li><strong>性能</strong>：对频繁查询的路径，应通过<strong>生成列</strong>并对其建立索引来优化，否则查询效率低下。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-空间数据类型-Spatial-Data-Types"><a href="#2-空间数据类型-Spatial-Data-Types" class="headerlink" title="2. 空间数据类型 (Spatial Data Types)"></a>2. 空间数据类型 (Spatial Data Types)</h5><ul>
<li><p><strong>核心定义</strong></p>
<ul>
<li>用于存储和处理地理空间数据，如点 (<code>POINT</code>)、线 (<code>LINESTRING</code>)、多边形 (<code>POLYGON</code>) 等。遵循 OpenGIS 规范。</li>
</ul>
</li>
<li><p><strong>优势</strong></p>
<ul>
<li><strong>专业地理计算</strong>：内置大量以 <code>ST_</code> 开头的函数，用于计算距离、判断包含&#x2F;相交关系等。</li>
<li><strong>空间索引 (<code>SPATIAL</code> INDEX)</strong>：可创建专用索引，极大提升基于地理位置的范围查询（如“附近的人”）效率。</li>
</ul>
</li>
<li><p><strong>用途</strong></p>
<ul>
<li><strong>LBS 应用</strong>（“附近的人”、“附近的餐厅”）、地图与物流（计算配送范围）、地理数据分析。</li>
</ul>
</li>
<li><p><strong>关键点</strong></p>
<ul>
<li><strong>必须创建空间索引</strong>：否则任何基于位置的范围查询都将是灾难性的全表扫描。</li>
<li><strong>坐标系 (SRID)</strong>：在 MySQL 8.0+ 中，强烈建议为空间数据指定 SRID (如 4326 代表 WGS 84 经纬度坐标系)，以确保距离计算的准确性。</li>
</ul>
</li>
<li><p><strong>示例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找距离北京特定坐标点 100 公里以内的所有地点</span></span><br><span class="line"><span class="comment">-- (需 MySQL 8.0+ 和 SRID 支持)</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> locations <span class="keyword">WHERE</span> ST_Distance_Sphere(coords, ST_GeomFromText(<span class="string">&#x27;POINT(116.40 39.90)&#x27;</span>, <span class="number">4326</span>)) <span class="operator">&lt;=</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-枚举与集合类型-ENUM-SET"><a href="#3-枚举与集合类型-ENUM-SET" class="headerlink" title="3. 枚举与集合类型 (ENUM &amp; SET)"></a>3. 枚举与集合类型 (ENUM &amp; SET)</h5><p>这两个类型将字符串值映射为内部的数字索引，从而在存储上非常高效，但也有明显缺点。</p>
<ul>
<li><strong><code>ENUM(&#39;value1&#39;, &#39;value2&#39;, ...)</code></strong><ul>
<li><strong>类型</strong>：枚举。值只能从一个预定义的列表中选择<strong>一个</strong>。</li>
<li><strong>用途</strong>：值非常固定且数量有限的场景，如订单状态 <code>status ENUM(&#39;pending&#39;, &#39;active&#39;, &#39;inactive&#39;)</code>、用户性别。</li>
</ul>
</li>
<li><strong><code>SET(&#39;value1&#39;, &#39;value2&#39;, ...)</code></strong><ul>
<li><strong>类型</strong>：集合。值可以从一个预定义的列表中选择<strong>零个或多个</strong>。</li>
<li><strong>用途</strong>：用户权限 <code>permissions SET(&#39;read&#39;, &#39;write&#39;, &#39;execute&#39;)</code>、文章标签。</li>
</ul>
</li>
<li><strong>警告与替代方案</strong><ul>
<li><strong>灵活性差</strong>：增加新选项需要执行 <code>ALTER TABLE</code>，在生产环境的大表上是高风险且成本高昂的操作。</li>
<li><strong>可移植性差</strong>：是 MySQL 特有的，不利于未来可能的数据库迁移。</li>
<li><strong>查询复杂</strong>：对 <code>SET</code> 类型的查询通常需要使用 <code>FIND_IN_SET()</code> 函数，无法有效利用索引。</li>
<li><strong>最佳实践</strong>：对于绝大多数场景，特别是选项可能变化的，<strong>强烈建议使用一个独立的查找表 (Lookup Table) 并通过外键关联</strong>。这是更规范、更具扩展性的数据库设计方法。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-1-5-其他常用类型"><a href="#3-1-5-其他常用类型" class="headerlink" title="3.1.5 其他常用类型"></a>3.1.5 其他常用类型</h4><h5 id="1-布尔类型-BOOLEAN-BOOL"><a href="#1-布尔类型-BOOLEAN-BOOL" class="headerlink" title="1. 布尔类型 (BOOLEAN &#x2F; BOOL)"></a>1. 布尔类型 (BOOLEAN &#x2F; BOOL)</h5><ul>
<li><strong>核心定义</strong>：在 MySQL 中，<code>BOOLEAN</code> 和 <code>BOOL</code> 是 <code>TINYINT(1)</code> 的<strong>同义词 (Synonym)</strong>。它们并不是一个独立的类型。</li>
<li><strong>存储约定</strong>：习惯上，使用 <code>0</code> 代表 <code>FALSE</code> (假)，使用 <code>1</code> (或任何非零值) 代表 <code>TRUE</code> (真)。</li>
<li><strong>典型用途</strong>：用于存储只有两种状态的标志位。</li>
<li><strong>示例</strong>：<code>is_active BOOLEAN DEFAULT TRUE</code>, <code>is_verified TINYINT(1) NOT NULL DEFAULT 0</code>。</li>
</ul>
<hr>
<h5 id="2-位类型-BIT"><a href="#2-位类型-BIT" class="headerlink" title="2. 位类型 (BIT)"></a>2. 位类型 (BIT)</h5><ul>
<li><strong>核心定义</strong>：<code>BIT(N)</code> 用于存储位值（0 或 1）。<code>N</code> 代表可以存储的位数，范围是 1 到 64。</li>
<li><strong>典型用途</strong>：当需要将多个布尔标志位压缩存储在单个列中以节省空间时。例如，一个 <code>BIT(8)</code> 的列可以存储 8 个独立的开关状态。</li>
<li><strong>与 <code>BOOLEAN</code> 的对比</strong>：<ul>
<li><code>BIT(1)</code> 在功能上可以替代 <code>BOOLEAN</code>。</li>
<li>但在实践中，<code>TINYINT(1)</code>（即 <code>BOOLEAN</code>）的可读性和客户端兼容性更好，通常是存储单个布尔值的首选。</li>
<li>仅在确实需要进行位运算或极致地压缩存储空间时才考虑使用 <code>BIT(N)</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-如何存储-UUID-通用唯一识别码"><a href="#3-如何存储-UUID-通用唯一识别码" class="headerlink" title="3. 如何存储 UUID (通用唯一识别码)"></a>3. 如何存储 UUID (通用唯一识别码)</h5><p>UUID 在分布式系统中非常常用作主键，但 MySQL（8.0 之前）没有原生的 <code>UUID</code> 类型。</p>
<ul>
<li><p><strong>方法一：错误的方式 (<code>CHAR(36)</code> &#x2F; <code>VARCHAR(36)</code>)</strong></p>
<ul>
<li><strong>做法</strong>：直接将 UUID 的字符串形式 <code>(&#39;550e8400-e29b-41d4-a716-446655440000&#39;)</code> 存储。</li>
<li><strong>缺点</strong>：<ol>
<li><strong>空间浪费</strong>：需要 36 个字节。</li>
<li><strong>索引性能差</strong>：字符串比较效率低；UUID v4 是随机的，作为主键（聚簇索引）会导致大量的页分裂和索引碎片，插入性能急剧下降。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>方法二：推荐的方式 (<code>BINARY(16)</code>)</strong></p>
<ul>
<li><p><strong>做法</strong>：UUID 的本质是一个 128 位的数字，恰好是 16 个字节。将其原始的二进制形式存入 <code>BINARY(16)</code> 列中。</p>
</li>
<li><p><strong>优点</strong>：</p>
<ol>
<li><strong>空间最优</strong>：仅需 16 字节，比字符串形式节省超过一半的空间。</li>
<li><strong>索引高效</strong>：作为固定长度的二进制类型，比较和查找速度更快。</li>
</ol>
</li>
<li><p><strong>如何使用 (MySQL 8.0+)</strong>：MySQL 提供了内置函数来轻松转换。</p>
<ul>
<li><code>UUID_TO_BIN()</code>：将 UUID 字符串转换为 <code>BINARY(16)</code>。</li>
<li><code>BIN_TO_UUID()</code>：将 <code>BINARY(16)</code> 转换回 UUID 字符串。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> products (</span><br><span class="line">    <span class="comment">-- 注意：UUID v1 包含时间戳，更有序，更适合做主键。</span></span><br><span class="line">    <span class="comment">-- MySQL 8.0 的 UUID_TO_BIN 第二个参数为 true 可以重排 v1 UUID，使其更有序</span></span><br><span class="line">    id <span class="type">BINARY</span>(<span class="number">16</span>) <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> products (id, name) <span class="keyword">VALUES</span> (UUID_TO_BIN(UUID()), <span class="string">&#x27;My Product&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据 (为了可读性进行转换)</span></span><br><span class="line"><span class="keyword">SELECT</span> BIN_TO_UUID(id) <span class="keyword">AS</span> uuid, name <span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-数据完整性约束"><a href="#3-2-数据完整性约束" class="headerlink" title="3.2 数据完整性约束"></a>3.2 数据完整性约束</h3><p>数据完整性约束 (Data Integrity Constraints) 是定义在表或列上的一系列规则，用于<strong>防止无效数据进入数据库</strong>。它们是确保数据质量的第一道防线，将业务规则强制施加于数据库层面，从而保证数据的准确性、一致性和可靠性。</p>
<ul>
<li><strong>级联操作 (Cascading Actions)：</strong> 外键可以定义当父表中的记录被删除 (<code>ON DELETE</code>) 或更新 (<code>ON UPDATE</code>) 时，子表中相关记录的行为。<ul>
<li><code>RESTRICT</code> (默认)：如果子表中有相关记录，则<strong>禁止</strong>删除或更新父表记录。</li>
<li><code>CASCADE</code>：父表记录被删除&#x2F;更新时，子表中的相关记录也<strong>自动被删除&#x2F;更新</strong>。</li>
<li><code>SET NULL</code>：父表记录被删除&#x2F;更新时，子表中的外键列被<strong>设置为 <code>NULL</code></strong> (前提是该列允许为 <code>NULL</code>)。</li>
<li><code>NO ACTION</code>：同 <code>RESTRICT</code>。</li>
</ul>
</li>
<li><strong>核心作用：</strong> 防止创建“孤儿数据”。例如，不能创建一个引用不存在的用户的订单。</li>
</ul>
<p>在 MySQL 中，主要有以下几种约束：</p>
<h4 id="3-2-1-主键约束-PRIMARY-KEY"><a href="#3-2-1-主键约束-PRIMARY-KEY" class="headerlink" title="3.2.1 主键约束 (PRIMARY KEY)"></a>3.2.1 主键约束 (PRIMARY KEY)</h4><p>主键是表中用于<strong>唯一标识</strong>每一行数据的列或列的组合。</p>
<ul>
<li><strong>核心特性：</strong><ul>
<li><strong>唯一性 (Unique)</strong>：主键列中的每个值都必须是唯一的，不允许重复。</li>
<li><strong>非空性 (Not Null)</strong>：主键列中的值不允许为 <code>NULL</code>。</li>
</ul>
</li>
<li><strong>规则：</strong><ul>
<li>一个表<strong>只能有一个</strong>主键。</li>
<li>主键可以由单个列组成（单列主键），也可以由多个列共同组成（复合主键）。</li>
</ul>
</li>
<li><strong>最佳实践：</strong> 推荐使用与业务无关的、自增的整数（如 <code>INT UNSIGNED AUTO_INCREMENT</code>）作为主键，这种键被称为“代理键”(Surrogate Key)。</li>
</ul>
<p><strong>语法示例：</strong></p>
<ol>
<li><p><strong>在 <code>CREATE TABLE</code> 时定义（单列主键）：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT, <span class="comment">-- 直接在列后声明</span></span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 <code>CREATE TABLE</code> 时定义（复合主键）：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> order_items (</span><br><span class="line">    order_id <span class="type">INT</span>,</span><br><span class="line">    product_id <span class="type">INT</span>,</span><br><span class="line">    quantity <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (order_id, product_id) <span class="comment">-- 在表末尾声明</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>ALTER TABLE</code> 添加主键：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> employees <span class="keyword">ADD</span> <span class="keyword">PRIMARY KEY</span> (employee_id);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="3-2-2-外键约束-FOREIGN-KEY"><a href="#3-2-2-外键约束-FOREIGN-KEY" class="headerlink" title="3.2.2 外键约束 (FOREIGN KEY)"></a>3.2.2 外键约束 (FOREIGN KEY)</h4><p>外键用于建立和加强两个表数据之间的链接，保证<strong>引用完整性 (Referential Integrity)</strong>。它是一张表（子表）中的一列，其值必须在另一张表（父表）的主键或唯一键中存在。</p>
<p><strong>语法示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> customers (</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> UNSIGNED <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    customer_id <span class="type">INT</span> UNSIGNED,</span><br><span class="line">    order_date <span class="type">DATE</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 定义外键约束</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_orders_customers <span class="comment">-- 给约束起一个名字，方便管理</span></span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (customer_id) <span class="keyword">REFERENCES</span> customers(id)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>  <span class="comment">-- 如果客户被删除，订单中的 customer_id 设为 NULL</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE;  <span class="comment">-- 如果客户 ID 更新，订单中的 customer_id 也跟着更新</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-3-唯一约束-UNIQUE"><a href="#3-2-3-唯一约束-UNIQUE" class="headerlink" title="3.2.3 唯一约束 (UNIQUE)"></a>3.2.3 唯一约束 (UNIQUE)</h4><p>唯一约束确保列（或列的组合）中的所有值都是唯一的，但与主键不同，它<strong>允许 <code>NULL</code> 值</strong>（并且可以有多个 <code>NULL</code>，因为 <code>NULL</code> 不等于任何值，包括另一个 <code>NULL</code>）。</p>
<ul>
<li><strong>核心作用：</strong> 防止业务上的数据重复，如用户名、邮箱、身份证号等。</li>
<li><strong>规则：</strong> 一个表可以有<strong>多个</strong>唯一约束。</li>
</ul>
<p><strong>语法示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span>, <span class="comment">-- 直接在列后声明</span></span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">CONSTRAINT</span> uq_email <span class="keyword">UNIQUE</span> (email) <span class="comment">-- 在表末尾声明并命名</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-4-非空约束-NOT-NULL"><a href="#3-2-4-非空约束-NOT-NULL" class="headerlink" title="3.2.4 非空约束 (NOT NULL)"></a>3.2.4 非空约束 (NOT NULL)</h4><p>非空约束强制列中不能存储 <code>NULL</code> 值，确保该字段必须有值。</p>
<ul>
<li><strong>核心作用：</strong> 保证关键数据（如名称、密码、状态等）的存在。</li>
</ul>
<p><strong>语法示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> products (</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT NULL</span>, <span class="comment">-- name 字段必须有值</span></span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    description TEXT <span class="comment">-- description 字段可以为 NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-5-默认值约束-DEFAULT"><a href="#3-2-5-默认值约束-DEFAULT" class="headerlink" title="3.2.5 默认值约束 (DEFAULT)"></a>3.2.5 默认值约束 (DEFAULT)</h4><p>严格来说，<code>DEFAULT</code> 不是一种强制性约束，但它为数据完整性提供了保障。它规定了当插入新行时，如果没有为该列提供值，则自动使用一个预设的默认值。</p>
<ul>
<li><strong>核心作用：</strong> 简化 <code>INSERT</code> 操作，并确保字段有一个合理的初始值。</li>
</ul>
<p><strong>语法示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> articles (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    status ENUM(<span class="string">&#x27;draft&#x27;</span>, <span class="string">&#x27;published&#x27;</span>, <span class="string">&#x27;archived&#x27;</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;draft&#x27;</span>, <span class="comment">-- 默认状态为 &#x27;draft&#x27;</span></span><br><span class="line">    created_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="comment">-- 默认创建时间为当前时间</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-6-检查约束-CHECK"><a href="#3-2-6-检查约束-CHECK" class="headerlink" title="3.2.6 检查约束 (CHECK)"></a>3.2.6 检查约束 (CHECK)</h4><p>检查约束用于规定列中的值必须满足一个布尔表达式，从而实现更复杂的业务规则校验。</p>
<ul>
<li><strong>重要提示：</strong> 在 <strong>MySQL 8.0.16</strong> 版本及之后，<code>CHECK</code> 约束才被真正地强制执行。在之前的版本中，虽然语法被接受，但约束会被忽略。</li>
</ul>
<p><strong>语法示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> products (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    sale_price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">CONSTRAINT</span> chk_price <span class="keyword">CHECK</span> (price <span class="operator">&gt;</span> <span class="number">0</span>), <span class="comment">-- 价格必须大于 0</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> chk_sale_price <span class="keyword">CHECK</span> (sale_price <span class="operator">&lt;</span> price) <span class="comment">-- 折扣价必须小于原价</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="二、SQL-进阶与查询优化"><a href="#二、SQL-进阶与查询优化" class="headerlink" title="二、SQL 进阶与查询优化"></a>二、SQL 进阶与查询优化</h1><h2 id="1-高级查询技巧"><a href="#1-高级查询技巧" class="headerlink" title="1. 高级查询技巧"></a>1. 高级查询技巧</h2><h3 id="1-1-聚合函数"><a href="#1-1-聚合函数" class="headerlink" title="1.1 聚合函数"></a>1.1 聚合函数</h3><h4 id="1-1-1-概述"><a href="#1-1-1-概述" class="headerlink" title="1.1.1 概述"></a>1.1.1 概述</h4><p>聚合函数（也常被称为“分组函数”或“集合函数”）。它们<strong>对一组值（一个列或一个表达式的结果集）进行计算，并返回一个单一的汇总值</strong>。</p>
<hr>
<h4 id="1-1-2-常用聚合函数"><a href="#1-1-2-常用聚合函数" class="headerlink" title="1.1.2 常用聚合函数"></a>1.1.2 常用聚合函数</h4><p>为了更好地演示，创建有一张 <code>employees</code> 表：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>department</th>
<th>salary</th>
<th>commission_pct</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>研发部</td>
<td>8000</td>
<td>0.1</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>研发部</td>
<td>9000</td>
<td>NULL</td>
</tr>
<tr>
<td>3</td>
<td>Charlie</td>
<td>销售部</td>
<td>6000</td>
<td>0.2</td>
</tr>
<tr>
<td>4</td>
<td>David</td>
<td>销售部</td>
<td>6500</td>
<td>0.25</td>
</tr>
<tr>
<td>5</td>
<td>Eve</td>
<td>市场部</td>
<td>7000</td>
<td>NULL</td>
</tr>
</tbody></table>
<hr>
<h5 id="1-COUNT-计数"><a href="#1-COUNT-计数" class="headerlink" title="1. COUNT(): 计数"></a>1. <code>COUNT()</code>: 计数</h5><ul>
<li><p><strong>功能说明</strong>: 计算指定列的行数。</p>
</li>
<li><p><strong>语法</strong>: <code>COUNT(column_name | *)</code></p>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li><p>计算公司总员工数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- 结果: 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>计算有佣金（commission_pct 不为 NULL）的员工数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(commission_pct) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- 结果: 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-SUM-求和"><a href="#2-SUM-求和" class="headerlink" title="2. SUM(): 求和"></a>2. <code>SUM()</code>: 求和</h5><ul>
<li><p><strong>功能说明</strong>: 计算数值列的总和。如果列中包含 <code>NULL</code> 值，<code>SUM()</code> 会忽略它们。</p>
</li>
<li><p><strong>语法</strong>: <code>SUM(numeric_column)</code></p>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li><p>计算公司每月总薪资支出：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- 结果: 36500 (8000 + 9000 + 6000 + 6500 + 7000)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-AVG-求平均值"><a href="#3-AVG-求平均值" class="headerlink" title="3. AVG(): 求平均值"></a>3. <code>AVG()</code>: 求平均值</h5><ul>
<li><p><strong>功能说明</strong>: 计算数值列的平均值。同样，<code>AVG()</code> 会忽略 <code>NULL</code> 值。</p>
</li>
<li><p><strong>语法</strong>: <code>AVG(numeric_column)</code></p>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li><p>计算公司员工的平均薪资：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- 结果: 7300 (36500 / 5)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-MAX-求最大值"><a href="#4-MAX-求最大值" class="headerlink" title="4. MAX(): 求最大值"></a>4. <code>MAX()</code>: 求最大值</h5><ul>
<li><p><strong>功能说明</strong>: 找出指定列中的最大值。可用于数值、字符串、日期等类型。</p>
</li>
<li><p><strong>语法</strong>: <code>MAX(column_name)</code></p>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li><p>查询公司最高薪资：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- 结果: 9000</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="5-MIN-求最小值"><a href="#5-MIN-求最小值" class="headerlink" title="5. MIN(): 求最小值"></a>5. <code>MIN()</code>: 求最小值</h5><ul>
<li><p><strong>功能说明</strong>: 找出指定列中的最小值。可用于数值、字符串、日期等类型。</p>
</li>
<li><p><strong>语法</strong>: <code>MIN(column_name)</code></p>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li><p>查询公司最低薪资：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- 结果: 6000</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-3-关键注意事项"><a href="#1-1-3-关键注意事项" class="headerlink" title="1.1.3 关键注意事项"></a>1.1.3 关键注意事项</h4><h5 id="1-COUNT-vs-COUNT-列名-vs-COUNT-DISTINCT-列名-vs-COUNT-常数-的区别"><a href="#1-COUNT-vs-COUNT-列名-vs-COUNT-DISTINCT-列名-vs-COUNT-常数-的区别" class="headerlink" title="1. COUNT(*) vs COUNT(列名) vs COUNT(DISTINCT 列名) vs COUNT(常数) 的区别"></a>1. <code>COUNT(*)</code> vs <code>COUNT(列名)</code> vs <code>COUNT(DISTINCT 列名)</code> vs <code>COUNT(常数)</code> 的区别</h5><ul>
<li><code>COUNT(*)</code>: 返回表中的<strong>总行数</strong>，无论行中是否包含 <code>NULL</code> 值。效率最高。</li>
<li><code>COUNT(列名)</code>: 返回指定列中<strong>非 <code>NULL</code> 值</strong>的行数。</li>
<li><code>COUNT(DISTINCT 列名)</code>: 返回指定列中<strong>唯一的、非 <code>NULL</code> 值</strong>的行数。</li>
<li><code>COUNT(常数)</code>: <code>COUNT(1)</code> 在功能上与 <code>COUNT(*)</code> 是<strong>等价的</strong>。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询总行数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees; <span class="comment">-- 结果: 5</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> employees; <span class="comment">-- 结果: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询有佣金记录的行数 (忽略了 Bob 和 Eve 的 NULL)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(commission_pct) <span class="keyword">FROM</span> employees; <span class="comment">-- 结果: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询公司有多少个不同的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> department) <span class="keyword">FROM</span> employees; <span class="comment">-- 结果: 3 (研发部, 销售部, 市场部)</span></span><br></pre></td></tr></table></figure>

<p><strong><code>COUNT(*)</code> vs <code>COUNT(1)</code> 的性能之争</strong></p>
<ul>
<li><strong>在旧的数据库版本中</strong>（比如旧版的 MySQL MyISAM 引擎），<code>COUNT(*)</code> 可能会因为需要解析元数据而比 <code>COUNT(1)</code> 慢一点点。</li>
<li><strong>在现代数据库中</strong>（如 MySQL InnoDB, PostgreSQL, SQL Server 等），查询优化器非常智能。它能识别出 <code>COUNT(*)</code> 和 <code>COUNT(1)</code> 的意图都是“计算总行数”，并会为它们生成完全相同的、最优的执行计划。</li>
<li><strong>结论</strong>：在今天，它们的性能没有差别。<strong>推荐使用 <code>COUNT(*)</code></strong>，因为它是 SQL 标准的写法，语义最清晰，最能准确表达“计算所有行”这个意图。</li>
</ul>
<hr>
<h5 id="2-NULL-值的处理"><a href="#2-NULL-值的处理" class="headerlink" title="2. NULL 值的处理"></a>2. <code>NULL</code> 值的处理</h5><p>除了 <code>COUNT(*)</code>，所有其他的聚合函数在进行计算时都会<strong>自动忽略 <code>NULL</code> 值</strong>。</p>
<p>例如，计算平均佣金比例时，分母是 3（Alice, Charlie, David），而不是 5。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(commission_pct) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- 结果: 0.1833... ((0.1 + 0.2 + 0.25) / 3)</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-4-与-GROUP-BY-和-HAVING-结合使用"><a href="#1-1-4-与-GROUP-BY-和-HAVING-结合使用" class="headerlink" title="1.1.4 与 GROUP BY 和 HAVING 结合使用"></a>1.1.4 与 <code>GROUP BY</code> 和 <code>HAVING</code> 结合使用</h4><p>聚合函数最强大的地方在于与 <code>GROUP BY</code> 子句结合，实现分组统计。</p>
<ul>
<li><strong><code>GROUP BY</code></strong>: 根据一个或多个列对结果集进行分组，然后对<strong>每个组</strong>应用聚合函数。</li>
<li><strong><code>HAVING</code></strong>: 用于在 <code>GROUP BY</code> 分组之后，对聚合函数的结果进行<strong>过滤</strong>。</li>
</ul>
<p><strong>核心区别</strong>:</p>
<ul>
<li><code>WHERE</code> 子句：在<strong>分组前</strong>过滤数据行。</li>
<li><code>HAVING</code> 子句：在<strong>分组后</strong>过滤结果组。</li>
</ul>
<p><strong>综合示例</strong>:</p>
<p>查询每个部门的员工人数、平均薪资，并且只显示那些平均薪资超过 7500 元的部门。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    department,                      <span class="comment">-- 部门名称</span></span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count,      <span class="comment">-- 每个部门的员工数 (AS 用于起别名)</span></span><br><span class="line">    <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary        <span class="comment">-- 每个部门的平均薪资</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    department                       <span class="comment">-- 按部门进行分组</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    avg_salary <span class="operator">&gt;</span> <span class="number">7500</span>;               <span class="comment">-- 对分组后的结果进行过滤</span></span><br></pre></td></tr></table></figure>

<p><strong>执行流程</strong>:</p>
<ol>
<li><code>FROM employees</code>: 首先确定数据来源是 <code>employees</code> 表。</li>
<li><code>GROUP BY department</code>: 将员工按“研发部”、“销售部”、“市场部”分成三组。</li>
<li><code>SELECT COUNT(*), AVG(salary)</code>: 对每一组分别执行聚合计算。<ul>
<li>研发部: 人数 2, 平均工资 (8000+9000)&#x2F;2 &#x3D; 8500</li>
<li>销售部: 人数 2, 平均工资 (6000+6500)&#x2F;2 &#x3D; 6250</li>
<li>市场部: 人数 1, 平均工资 7000&#x2F;1 &#x3D; 7000</li>
</ul>
</li>
<li><code>HAVING avg_salary &gt; 7500</code>: 过滤上一步产生的结果，只有“研发部”满足条件。</li>
</ol>
<p><strong>最终结果</strong>:</p>
<table>
<thead>
<tr>
<th>department</th>
<th>employee_count</th>
<th>avg_salary</th>
</tr>
</thead>
<tbody><tr>
<td>研发部</td>
<td>2</td>
<td>8500.0000</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-1-5-MySQL-特有的聚合函数：GROUP-CONCAT"><a href="#1-1-5-MySQL-特有的聚合函数：GROUP-CONCAT" class="headerlink" title="1.1.5 MySQL 特有的聚合函数：GROUP_CONCAT()"></a>1.1.5 MySQL 特有的聚合函数：<code>GROUP_CONCAT()</code></h4><ul>
<li><strong>功能说明</strong>: 将一个分组中的指定列的值用指定符号连接成一个字符串。非常实用。</li>
<li><strong>示例</strong>: 列出每个部门下的所有员工姓名。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    department,</span><br><span class="line">    GROUP_CONCAT(name <span class="keyword">ORDER</span> <span class="keyword">BY</span> id SEPARATOR <span class="string">&#x27;; &#x27;</span>) <span class="keyword">AS</span> employee_list</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    department;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>:</p>
<table>
<thead>
<tr>
<th>department</th>
<th>employee_list</th>
</tr>
</thead>
<tbody><tr>
<td>研发部</td>
<td>Alice; Bob</td>
</tr>
<tr>
<td>销售部</td>
<td>Charlie; David</td>
</tr>
<tr>
<td>市场部</td>
<td>Eve</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-2-分组查询"><a href="#1-2-分组查询" class="headerlink" title="1.2 分组查询"></a>1.2 分组查询</h3><h4 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h4><p>分组查询的核心思想是**“先分组，再聚合”**。它将表中的数据按照一个或多个列的值进行分组，将具有相同值的行划分到同一个组中，然后你可以对这些分组分别使用聚合函数进行计算。</p>
<hr>
<h4 id="1-2-2-GROUP-BY-子句的基本语法"><a href="#1-2-2-GROUP-BY-子句的基本语法" class="headerlink" title="1.2.2 GROUP BY 子句的基本语法"></a>1.2.2 <code>GROUP BY</code> 子句的基本语法</h4><p><code>GROUP BY</code> 子句通常跟在 <code>WHERE</code> 子句之后，<code>ORDER BY</code> 或 <code>HAVING</code> 子句之前。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    column_name1,</span><br><span class="line">    aggregate_function(column_name2)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    column_name1;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>: 让我们继续使用 <code>employees</code> 表，计算每个部门的员工人数。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>department</th>
<th>salary</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>研发部</td>
<td>8000</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>研发部</td>
<td>9000</td>
</tr>
<tr>
<td>3</td>
<td>Charlie</td>
<td>销售部</td>
<td>6000</td>
</tr>
<tr>
<td>4</td>
<td>David</td>
<td>销售部</td>
<td>6500</td>
</tr>
<tr>
<td>5</td>
<td>Eve</td>
<td>市场部</td>
<td>7000</td>
</tr>
</tbody></table>
<p><strong>查询</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    department,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    department;</span><br></pre></td></tr></table></figure>

<p><strong>工作流程</strong>:</p>
<ol>
<li><strong>扫描</strong>: SQL 从 <code>employees</code> 表开始。</li>
<li><strong>分组</strong>: <code>GROUP BY department</code> 指令会将数据按 <code>department</code> 列的值分成三组：<ul>
<li><strong>组1 (研发部)</strong>: Alice, Bob</li>
<li><strong>组2 (销售部)</strong>: Charlie, David</li>
<li><strong>组3 (市场部)</strong>: Eve</li>
</ul>
</li>
<li><strong>聚合</strong>: <code>COUNT(*)</code> 会在<strong>每个组内部</strong>独立执行：<ul>
<li>研发部组：<code>COUNT(*)</code> -&gt; 2</li>
<li>销售部组：<code>COUNT(*)</code> -&gt; 2</li>
<li>市场部组：<code>COUNT(*)</code> -&gt; 1</li>
</ul>
</li>
<li><strong>返回结果</strong>: 将分组列和聚合结果组合成最终输出。</li>
</ol>
<p><strong>结果</strong>:</p>
<table>
<thead>
<tr>
<th>department</th>
<th>employee_count</th>
</tr>
</thead>
<tbody><tr>
<td>研发部</td>
<td>2</td>
</tr>
<tr>
<td>销售部</td>
<td>2</td>
</tr>
<tr>
<td>市场部</td>
<td>1</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-2-3-重要规则与-WHERE-vs-HAVING"><a href="#1-2-3-重要规则与-WHERE-vs-HAVING" class="headerlink" title="1.2.3 重要规则与 WHERE vs. HAVING"></a>1.2.3 重要规则与 <code>WHERE</code> vs. <code>HAVING</code></h4><h5 id="1-SELECT-列表的严格规则"><a href="#1-SELECT-列表的严格规则" class="headerlink" title="1. SELECT 列表的严格规则"></a>1. <code>SELECT</code> 列表的严格规则</h5><p>容易犯错的地方：</p>
<p>当使用了 <code>GROUP BY</code> 子句后，<code>SELECT</code> 语句中只能出现：</p>
<ul>
<li><strong><code>GROUP BY</code> 子句中指定的列</strong> (如上例中的 <code>department</code>)。</li>
<li><strong>聚合函数</strong> (如 <code>COUNT(*)</code>, <code>AVG(salary)</code>)。</li>
</ul>
<p><strong>为什么？</strong> 想象一下，你执行 <code>SELECT name, COUNT(*) FROM employees GROUP BY department;</code>。对于“研发部”这个分组，它有两名员工（Alice, Bob）。<code>COUNT(*)</code> 知道结果是 2，但 <code>name</code> 应该显示 ‘Alice’ 还是 ‘Bob’ 呢？数据库无法确定，所以这种查询在标准的 SQL（以及新版 MySQL 的默认配置 <code>ONLY_FULL_GROUP_BY</code>）中是<strong>不合法</strong>的。</p>
<hr>
<h5 id="2-WHERE-和-HAVING-的本质区别"><a href="#2-WHERE-和-HAVING-的本质区别" class="headerlink" title="2. WHERE 和 HAVING 的本质区别"></a>2. <code>WHERE</code> 和 <code>HAVING</code> 的本质区别</h5><p><code>WHERE</code> 和 <code>HAVING</code> 都是用于过滤数据的，但它们作用的阶段完全不同。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>WHERE</code> 子句</th>
<th><code>HAVING</code> 子句</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用对象</strong></td>
<td>原始表中的<strong>单条记录 (行)</strong></td>
<td><code>GROUP BY</code> 分组后的<strong>结果组</strong></td>
</tr>
<tr>
<td><strong>执行时机</strong></td>
<td><strong>分组前 (FROM 之后, GROUP BY 之前)</strong></td>
<td><strong>分组后 (GROUP BY 之后, SELECT 之后)</strong></td>
</tr>
<tr>
<td><strong>使用内容</strong></td>
<td>可以使用表中任何字段，<strong>不能</strong>使用聚合函数。</td>
<td><strong>必须</strong>包含聚合函数，也可以使用分组字段。</td>
</tr>
</tbody></table>
<p><strong>记忆技巧</strong>:</p>
<ul>
<li><code>WHERE</code> 是<strong>入场券</strong>：先用 <code>WHERE</code> 筛选掉不符合条件的<strong>个人</strong>，再让他们去分组。</li>
<li><code>HAVING</code> 是<strong>分组后审查</strong>：等小组形成后，再用 <code>HAVING</code> 把不符合条件的<strong>小组</strong>淘汰掉。</li>
</ul>
<p><strong>综合示例</strong>: 查询公司中，薪资高于 6000 的员工里，各部门的平均薪资，并只显示那些平均薪资超过 8000 的部门。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    department,</span><br><span class="line">    <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    salary <span class="operator">&gt;</span> <span class="number">6000</span>         <span class="comment">-- 1. 分组前过滤：只考虑薪资高于 6000 的员工</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    department            <span class="comment">-- 2. 按部门分组</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    avg_salary <span class="operator">&gt;</span> <span class="number">8000</span>;    <span class="comment">-- 3. 分组后过滤：只保留平均薪资超过 8000 的组</span></span><br></pre></td></tr></table></figure>

<p><strong>执行分析</strong>:</p>
<ol>
<li><code>WHERE salary &gt; 6000</code>: 先把 <code>Charlie</code> (薪资 6000) 排除掉。剩下的员工有 Alice(8000), Bob(9000), David(6500), Eve(7000)。</li>
<li><code>GROUP BY department</code>: 对剩下的员工进行分组。<ul>
<li>研发部: Alice(8000), Bob(9000)</li>
<li>销售部: David(6500)</li>
<li>市场部: Eve(7000)</li>
</ul>
</li>
<li><strong>计算聚合值</strong>: 对每个新分组计算平均薪资。<ul>
<li>研发部: <code>AVG(salary)</code> -&gt; (8000 + 9000) &#x2F; 2 &#x3D; 8500</li>
<li>销售部: <code>AVG(salary)</code> -&gt; 6500 &#x2F; 1 &#x3D; 6500</li>
<li>市场部: <code>AVG(salary)</code> -&gt; 7000 &#x2F; 1 &#x3D; 7000</li>
</ul>
</li>
<li><code>HAVING avg_salary &gt; 8000</code>: 用计算出的聚合值进行过滤，只有“研发部”的 8500 满足条件。</li>
</ol>
<p><strong>最终结果</strong>:</p>
<table>
<thead>
<tr>
<th>department</th>
<th>avg_salary</th>
</tr>
</thead>
<tbody><tr>
<td>研发部</td>
<td>8500.0000</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-2-4-高级用法"><a href="#1-2-4-高级用法" class="headerlink" title="1.2.4 高级用法"></a>1.2.4 高级用法</h4><h5 id="1-按多个列分组"><a href="#1-按多个列分组" class="headerlink" title="1. 按多个列分组"></a>1. 按多个列分组</h5><p>可以同时按多个列进行分组，形成更细致的层级。</p>
<p>例如，先按部门分，部门内部再按职位分。</p>
<p><code>GROUP BY department, job_title</code></p>
<hr>
<h5 id="2-在-GROUP-BY-中使用表达式"><a href="#2-在-GROUP-BY-中使用表达式" class="headerlink" title="2. 在 GROUP BY 中使用表达式"></a>2. 在 <code>GROUP BY</code> 中使用表达式</h5><p>分组依据不一定是一个原始列，也可以是一个表达式。</p>
<p>例如，按员工入职的年份进行分组统计每年的入职人数。</p>
<p><code>GROUP BY YEAR(hire_date)</code></p>
<hr>
<h5 id="3-WITH-ROLLUP-MySQL-特有"><a href="#3-WITH-ROLLUP-MySQL-特有" class="headerlink" title="3. WITH ROLLUP (MySQL 特有)"></a>3. <code>WITH ROLLUP</code> (MySQL 特有)</h5><p><code>WITH ROLLUP</code> 是一个非常有用的修饰符，它会在分组统计结果的基础上，额外增加一个“超级聚合”行，即对所有分组结果的汇总。</p>
<p><strong>示例</strong>: 统计各部门人数，并计算总人数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    department,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    department <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>:</p>
<table>
<thead>
<tr>
<th>department</th>
<th>employee_count</th>
</tr>
</thead>
<tbody><tr>
<td>研发部</td>
<td>2</td>
</tr>
<tr>
<td>销售部</td>
<td>2</td>
</tr>
<tr>
<td>市场部</td>
<td>1</td>
</tr>
<tr>
<td><strong>NULL</strong></td>
<td><strong>5</strong></td>
</tr>
</tbody></table>
<p>最后一行中，<code>department</code> 为 <code>NULL</code>，表示这是对所有部门的汇总统计，总员工数是 5。</p>
<hr>
<h3 id="1-3-连接查询-Joins"><a href="#1-3-连接查询-Joins" class="headerlink" title="1.3 连接查询(Joins)"></a>1.3 连接查询(Joins)</h3><h4 id="1-3-1-概述"><a href="#1-3-1-概述" class="headerlink" title="1.3.1 概述"></a>1.3.1 概述</h4><ul>
<li><strong>目的</strong>：将两个或多个表中的行，基于它们之间相关的列（通常是主键和外键）进行匹配和组合。</li>
<li><strong>核心思想</strong>：通过一个共同的字段（连接键），将一张表的记录与另一张表的记录“缝合”在一起。</li>
</ul>
<p>为了更好地演示，创建两个示例表：<code>employees</code> (员工表) 和 <code>departments</code> (部门表)。</p>
<p><strong><code>employees</code> 表</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>dept_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张三</td>
<td>25</td>
<td>101</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>28</td>
<td>102</td>
</tr>
<tr>
<td>3</td>
<td>王五</td>
<td>32</td>
<td>101</td>
</tr>
<tr>
<td>4</td>
<td>赵六</td>
<td>29</td>
<td>NULL</td>
</tr>
</tbody></table>
<p><strong><code>departments</code> 表</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>101</td>
<td>技术部</td>
</tr>
<tr>
<td>102</td>
<td>市场部</td>
</tr>
<tr>
<td>103</td>
<td>财务部</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-3-2-INNER-JOIN-内连接"><a href="#1-3-2-INNER-JOIN-内连接" class="headerlink" title="1.3.2 INNER JOIN (内连接)"></a>1.3.2 INNER JOIN (内连接)</h4><ul>
<li><p><strong>概念</strong>：最常用的一种连接。它返回两个表中连接键相匹配的行，可以理解为取两个表的<strong>交集</strong>。如果某行在另一个表中没有匹配的行，那么这行就不会出现在结果中。</p>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2...</span><br><span class="line"><span class="keyword">FROM</span> table_a a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table_b b <span class="keyword">ON</span> a.join_column <span class="operator">=</span> b.join_column;</span><br></pre></td></tr></table></figure>

<p><code>INNER</code> 关键字通常可以省略，直接写 <code>JOIN</code> 默认就是内连接。</p>
</li>
<li><p><strong>示例</strong>：查询所有员工及其所在的部门名称。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    e.name,</span><br><span class="line">    d.dept_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">    departments d <span class="keyword">ON</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>dept_name</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>技术部</td>
</tr>
<tr>
<td>李四</td>
<td>市场部</td>
</tr>
<tr>
<td>王五</td>
<td>技术部</td>
</tr>
</tbody></table>
<p><em><strong>注意</strong>：赵六 (dept_id 为 NULL) 和财务部 (没有员工) 都没有出现在结果中。</em></p>
</li>
</ul>
<hr>
<h4 id="1-3-3-LEFT-JOIN-左外连接"><a href="#1-3-3-LEFT-JOIN-左外连接" class="headerlink" title="1.3.3 LEFT JOIN (左外连接)"></a>1.3.3 LEFT JOIN (左外连接)</h4><ul>
<li><p><strong>概念</strong>：以左表 (<code>FROM</code> 后面的第一个表) 为基准，返回左表的所有行。对于左表中的每一行，如果在右表中找到了匹配的行，则显示匹配行的数据；如果没找到，则右表的列显示为 <code>NULL</code>。</p>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2...</span><br><span class="line"><span class="keyword">FROM</span> table_a a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table_b b <span class="keyword">ON</span> a.join_column <span class="operator">=</span> b.join_column;</span><br></pre></td></tr></table></figure>

<p><code>LEFT OUTER JOIN</code> 和 <code>LEFT JOIN</code> 是等价的。</p>
</li>
<li><p><strong>示例</strong>：查询所有员工的信息，并显示他们所在的部门，即使某个员工没有部门。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    e.name,</span><br><span class="line">    d.dept_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">    departments d <span class="keyword">ON</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>dept_name</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>技术部</td>
</tr>
<tr>
<td>李四</td>
<td>市场部</td>
</tr>
<tr>
<td>王五</td>
<td>技术部</td>
</tr>
<tr>
<td>赵六</td>
<td><strong>NULL</strong></td>
</tr>
</tbody></table>
<p><em><strong>注意</strong>：左表 <code>employees</code> 的所有记录都被包含进来了，包括没有部门的赵六。</em></p>
</li>
</ul>
<hr>
<h4 id="1-3-4-RIGHT-JOIN-右外连接"><a href="#1-3-4-RIGHT-JOIN-右外连接" class="headerlink" title="1.3.4 RIGHT JOIN (右外连接)"></a>1.3.4 RIGHT JOIN (右外连接)</h4><ul>
<li><p><strong>概念</strong>：与 <code>LEFT JOIN</code> 相反。以右表 (<code>JOIN</code> 后面的表) 为基准，返回右表的所有行。对于右表中的每一行，如果在左表中找到了匹配的行，则显示匹配行的数据；如果没找到，则左表的列显示为 <code>NULL</code>。</p>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2...</span><br><span class="line"><span class="keyword">FROM</span> table_a a</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table_b b <span class="keyword">ON</span> a.join_column <span class="operator">=</span> b.join_column;</span><br></pre></td></tr></table></figure>

<p><code>RIGHT OUTER JOIN</code> 和 <code>RIGHT JOIN</code> 是等价的。</p>
</li>
<li><p><strong>示例</strong>：查询所有部门，并列出其中的员工，即使某个部门没有员工。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    e.name,</span><br><span class="line">    d.dept_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees e</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span></span><br><span class="line">    departments d <span class="keyword">ON</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>dept_name</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>技术部</td>
</tr>
<tr>
<td>王五</td>
<td>技术部</td>
</tr>
<tr>
<td>李四</td>
<td>市场部</td>
</tr>
<tr>
<td><strong>NULL</strong></td>
<td>财务部</td>
</tr>
</tbody></table>
<p><em><strong>注意</strong>：右表 <code>departments</code> 的所有记录都被包含进来了，包括没有员工的财务部。</em></p>
</li>
</ul>
<hr>
<h4 id="1-3-5-FULL-OUTER-JOIN-全外连接"><a href="#1-3-5-FULL-OUTER-JOIN-全外连接" class="headerlink" title="1.3.5 FULL OUTER JOIN (全外连接)"></a>1.3.5 FULL OUTER JOIN (全外连接)</h4><ul>
<li><p><strong>概念</strong>：返回左表和右表中的所有行。当某行在另一个表中没有匹配时，相关表的列显示为 <code>NULL</code>。可以看作是 <code>LEFT JOIN</code> 和 <code>RIGHT JOIN</code> 结果的并集。</p>
</li>
<li><p><strong>重要提示</strong>：<strong>MySQL 不直接支持 <code>FULL OUTER JOIN</code> 关键字</strong>。但可以通过 <code>LEFT JOIN</code> 和 <code>RIGHT JOIN</code> 的 <code>UNION</code> 操作来模拟实现。</p>
</li>
<li><p><strong>模拟语法</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2... <span class="keyword">FROM</span> table_a a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table_b b <span class="keyword">ON</span> a.join_column <span class="operator">=</span> b.join_column</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2... <span class="keyword">FROM</span> table_a a <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table_b b <span class="keyword">ON</span> a.join_column <span class="operator">=</span> b.join_column;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>示例</strong>：列出所有员工和所有部门。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.name, d.dept_name <span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.dept_id <span class="operator">=</span> d.id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.dept_name <span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>dept_name</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>技术部</td>
</tr>
<tr>
<td>李四</td>
<td>市场部</td>
</tr>
<tr>
<td>王五</td>
<td>技术部</td>
</tr>
<tr>
<td>赵六</td>
<td><strong>NULL</strong></td>
</tr>
<tr>
<td><strong>NULL</strong></td>
<td>财务部</td>
</tr>
</tbody></table>
</li>
</ul>
<p>​	<em><strong>注意</strong>：结果包含了没有部门的赵六，也包含了没有员工的财务部。</em></p>
<hr>
<h4 id="1-3-6-其他连接类型"><a href="#1-3-6-其他连接类型" class="headerlink" title="1.3.6 其他连接类型"></a>1.3.6 其他连接类型</h4><h5 id="1-CROSS-JOIN-交叉连接"><a href="#1-CROSS-JOIN-交叉连接" class="headerlink" title="1. CROSS JOIN (交叉连接)"></a>1. CROSS JOIN (交叉连接)</h5><ul>
<li><p><strong>概念</strong>：返回左表中的每一行与右表中每一行的组合，也称为<strong>笛卡尔积</strong>。结果集的行数是两个表行数的乘积 (<code>m * n</code>)。</p>
</li>
<li><p><strong>使用场景</strong>：通常用于生成测试数据或需要所有可能组合的场景，日常业务中较少使用。</p>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_a <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> table_b;</span><br><span class="line"><span class="comment">-- 或者使用隐式语法</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_a, table_b;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>警告</strong>：在处理大表时要极其小心，结果集可能非常庞大，导致性能问题。</p>
</li>
</ul>
<hr>
<h5 id="2-SELF-JOIN-自连接"><a href="#2-SELF-JOIN-自连接" class="headerlink" title="2. SELF JOIN (自连接)"></a>2. SELF JOIN (自连接)</h5><ul>
<li><p><strong>概念</strong>：这是一种特殊的连接方式，指一张表与它自身进行连接。它并不是一种新的 <code>JOIN</code> 类型，而是 <code>INNER JOIN</code> 或 <code>LEFT JOIN</code> 等的一种应用。</p>
</li>
<li><p><strong>使用场景</strong>：当表中有一列引用了同表中的另一列时，例如员工表中的 <code>manager_id</code> 指向同一个员工表中的 <code>id</code>。</p>
</li>
<li><p><strong>示例</strong>：查询每个员工及其对应的经理姓名。<br>我们需要将 <code>employees</code> 表看作两张独立的表：一张是员工表 <code>e</code>，另一张是经理表 <code>m</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    e.name <span class="keyword">AS</span> employee_name,</span><br><span class="line">    m.name <span class="keyword">AS</span> manager_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="comment">-- 使用 LEFT JOIN 以确保没有经理的员工（如CEO）也能被查出</span></span><br><span class="line">    employees m <span class="keyword">ON</span> e.manager_id <span class="operator">=</span> m.id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-3-7-连接条件与最佳实践"><a href="#1-3-7-连接条件与最佳实践" class="headerlink" title="1.3.7 连接条件与最佳实践"></a>1.3.7 连接条件与最佳实践</h4><ul>
<li><strong>ON vs WHERE</strong><ul>
<li><strong><code>ON</code></strong>: 定义连接条件，在生成临时连接表时使用。</li>
<li><strong><code>WHERE</code></strong>: 在连接完成后，对生成的临时结果集进行过滤。</li>
<li><strong>关键区别（尤其对于外连接）</strong>：<ul>
<li>对于 <code>INNER JOIN</code>，<code>ON</code> 和 <code>WHERE</code> 的过滤效果是等价的。</li>
<li>对于 <code>LEFT JOIN</code> &#x2F; <code>RIGHT JOIN</code>，效果完全不同：<ul>
<li>条件写在 <code>ON</code> 子句中，是在连接匹配阶段就进行过滤，即使右表（或左表）的行不满足 <code>ON</code> 中的附加条件，左表（或右表）的行仍然会保留。</li>
<li>条件写在 <code>WHERE</code> 子句中，是在连接已经生成结果集之后再进行过滤。如果过滤条件针对的是非基准表（如 <code>LEFT JOIN</code> 中的右表），并且该条件不满足时会排除 <code>NULL</code> 值，那么 <code>LEFT JOIN</code> 的效果会退化成 <code>INNER JOIN</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>最佳实践</strong><ol>
<li><strong>明确连接键</strong>：确保 <code>ON</code> 子句中的列是正确的关联字段，通常是主键和外键。</li>
<li><strong>为连接键创建索引</strong>：这是提升 <code>JOIN</code> 性能最关键的一步。在 <code>dept_id</code> 和 <code>id</code> 上创建索引会极大加快查询速度。</li>
<li><strong>使用表别名</strong>：当连接多个表时，为每个表指定一个简短的别名（如 <code>e</code> for <code>employees</code>）可以让 SQL 更简洁易读。</li>
<li><strong>选择正确的 JOIN 类型</strong>：根据业务需求仔细选择 <code>INNER JOIN</code> 还是 <code>LEFT JOIN</code>，避免查询出不想要的数据或遗漏数据。</li>
<li><strong>避免 <code>SELECT *</code></strong>：只选择你需要的列，可以减少网络传输和内存消耗。</li>
<li><strong>小表驱动大表</strong>：在 <code>JOIN</code> 操作中，通常用记录数较少的表（小表）去驱动记录数较多的表（大表），优化器通常会自动处理，但了解这个原则有助于写出更高效的 SQL。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="1-4-子查询-Subquery"><a href="#1-4-子查询-Subquery" class="headerlink" title="1.4 子查询(Subquery)"></a>1.4 子查询(Subquery)</h3><h4 id="1-4-1-概述"><a href="#1-4-1-概述" class="headerlink" title="1.4.1 概述"></a>1.4.1 概述</h4><p>子查询，也称为嵌套查询 (Nested Query) 或内部查询 (Inner Query)</p>
<ul>
<li><p><strong>核心思想</strong>：将一个查询问题分解成多个逻辑步骤，内部的查询先执行，其结果被外部的查询（主查询）使用。</p>
</li>
<li><p><strong>基本结构</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name operator (</span><br><span class="line">    <span class="keyword">SELECT</span> column_name(s)</span><br><span class="line">    <span class="keyword">FROM</span> table_name</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>继续使用之前的 <code>employees</code> 和 <code>departments</code> 表进行演示。</p>
<hr>
<h4 id="1-4-2-子查询的位置"><a href="#1-4-2-子查询的位置" class="headerlink" title="1.4.2 子查询的位置"></a>1.4.2 子查询的位置</h4><p>子查询几乎可以出现在 <code>SELECT</code> 语句的任何地方，最常见的位置有三个：</p>
<h5 id="1-在-WHERE-子句中"><a href="#1-在-WHERE-子句中" class="headerlink" title="1. 在 WHERE 子句中"></a>1. 在 <code>WHERE</code> 子句中</h5><p>这是最常见的用法，用于动态地生成过滤条件。</p>
<ul>
<li><p><strong>示例</strong>：查询所有在 “技术部” 工作的员工。</p>
<ul>
<li><p><strong>步骤 1 (子查询)</strong>：先找出 “技术部” 的部门 ID。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;技术部&#x27;</span>; <span class="comment">-- 结果是 101</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>步骤 2 (主查询)</strong>：利用上一步的结果来筛选员工。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> dept_id <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;技术部&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>25</td>
</tr>
<tr>
<td>王五</td>
<td>32</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h5 id="2-在-FROM-子句中"><a href="#2-在-FROM-子句中" class="headerlink" title="2. 在 FROM 子句中"></a>2. 在 <code>FROM</code> 子句中</h5><p>当子查询出现在 <code>FROM</code> 子句中时，其结果集被当作一个临时的、虚拟的表（称为派生表，Derived Table），主查询可以像操作普通表一样操作它。</p>
<ul>
<li><p><strong>重要</strong>：在 <code>FROM</code> 子句中的子查询必须指定一个别名。</p>
</li>
<li><p><strong>示例</strong>：查询每个部门的平均年龄。</p>
<ul>
<li><p><strong>步骤 1 (子查询)</strong>：先按部门 ID 分组，计算出每个部门的平均年龄。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dept_id, <span class="built_in">AVG</span>(age) <span class="keyword">AS</span> avg_age</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> dept_id <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>步骤 2 (主查询)</strong>：将上述结果集（派生表 <code>t</code>）与 <code>departments</code> 表连接，以显示部门名称。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    d.dept_name,</span><br><span class="line">    t.avg_age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    departments d</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> dept_id, <span class="built_in">AVG</span>(age) <span class="keyword">AS</span> avg_age <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> dept_id <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_id) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line">    d.id <span class="operator">=</span> t.dept_id;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>dept_name</th>
<th>avg_age</th>
</tr>
</thead>
<tbody><tr>
<td>技术部</td>
<td>28.5000</td>
</tr>
<tr>
<td>市场部</td>
<td>28.0000</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h5 id="3-在-SELECT-子句中"><a href="#3-在-SELECT-子句中" class="headerlink" title="3. 在 SELECT 子句中"></a>3. 在 <code>SELECT</code> 子句中</h5><p>当子查询出现在 <code>SELECT</code> 列表中时，它通常用于返回一个单一的值（即标量子查询），作为主查询结果集的一列。</p>
<ul>
<li><p><strong>示例</strong>：查询每个员工的姓名，并同时显示其部门名称（不使用 JOIN）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    e.name,</span><br><span class="line">    (<span class="keyword">SELECT</span> dept_name <span class="keyword">FROM</span> departments d <span class="keyword">WHERE</span> d.id <span class="operator">=</span> e.dept_id) <span class="keyword">AS</span> department_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees e;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>department_name</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>技术部</td>
</tr>
<tr>
<td>李四</td>
<td>市场部</td>
</tr>
<tr>
<td>王五</td>
<td>技术部</td>
</tr>
<tr>
<td>赵六</td>
<td>NULL</td>
</tr>
</tbody></table>
</li>
<li><p><strong>注意</strong>：这种子查询必须确保只返回一个值（一行一列），否则会报错。它通常是一种<strong>相关子查询</strong>（见下文）。</p>
</li>
</ul>
<hr>
<h4 id="1-4-3-子查询的分类"><a href="#1-4-3-子查询的分类" class="headerlink" title="1.4.3 子查询的分类"></a>1.4.3 子查询的分类</h4><h5 id="1-按返回结果集划分"><a href="#1-按返回结果集划分" class="headerlink" title="1. 按返回结果集划分"></a>1. 按返回结果集划分</h5><ul>
<li><p><strong>标量子查询 (Scalar Subquery)</strong>：返回单个值（一行一列）。可以用在 <code>SELECT</code> 列表、<code>WHERE</code> 子句、<code>ORDER BY</code> 子句中，几乎任何需要单个值的地方都可以。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- WHERE子句中的标量子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(age) <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多行子查询 (Multi-row Subquery)</strong>：返回一列多行。通常与 <code>IN</code>, <code>NOT IN</code>, <code>ANY</code>, <code>ALL</code> 等操作符结合使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与&#x27;张三&#x27;或&#x27;李四&#x27;在同一个部门的所有员工</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> dept_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> dept_id <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="keyword">IN</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多列子查询 (Multi-column Subquery)</strong>：返回多行多列。通常用在 <code>FROM</code> 子句中作为派生表，或在 <code>WHERE</code> 中进行行比较。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与&#x27;张三&#x27;部门和年龄都相同的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> (dept_id, age) <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> dept_id, age <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-按与主查询的关联性划分"><a href="#2-按与主查询的关联性划分" class="headerlink" title="2. 按与主查询的关联性划分"></a>2. 按与主查询的关联性划分</h5><ul>
<li><p><strong>非相关子查询 (Non-correlated Subquery)</strong></p>
<ul>
<li><p><strong>定义</strong>：子查询可以独立执行，不依赖于主查询。执行过程是“由内而外”：先执行子查询，得到一个结果集，然后主查询使用这个结果集。</p>
</li>
<li><p><strong>示例</strong>：前面 <code>WHERE</code> 子句中的例子都是非相关子查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 子查询可以独立运行并得到结果 &#123;101&#125;</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> dept_id <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;技术部&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>相关子查询 (Correlated Subquery)</strong></p>
<ul>
<li><p><strong>定义</strong>：子查询的执行依赖于主查询的当前行。主查询的每一行都会触发一次子查询的执行。</p>
</li>
<li><p><strong>执行过程</strong>：主查询先读取一行数据 -&gt; 将该行数据的值传给子查询 -&gt; 子查询执行并返回结果 -&gt; 主查询根据结果判断是否保留该行 -&gt; 主查询读取下一行，循环往复。</p>
</li>
<li><p><strong>示例</strong>：查询所有存在员工的部门。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dept_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> ( <span class="comment">-- EXISTS操作符专门用于相关子查询</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> employees e <span class="keyword">WHERE</span> e.dept_id <span class="operator">=</span> d.id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><em>解释</em>：对于 <code>departments</code> 表的每一行 <code>d</code>，内部查询都会检查 <code>employees</code> 表中是否存在 <code>dept_id</code> 与当前<code>d.id</code> 相同的记录。<code>EXISTS</code> 只关心是否存在，不关心具体内容，<code>SELECT 1</code> 是常见的性能优化写法。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-4-4-子查询-vs-JOIN"><a href="#1-4-4-子查询-vs-JOIN" class="headerlink" title="1.4.4 子查询 vs. JOIN"></a>1.4.4 子查询 vs. JOIN</h4><p>很多时候，子查询和 <code>JOIN</code> 可以实现相同的功能，但它们有不同的适用场景和性能特点。</p>
<ul>
<li><p><strong>可读性</strong>：对于一些复杂的逻辑，子查询分步解决问题的方式可能比复杂的 <code>JOIN</code> 更容易理解和编写。</p>
</li>
<li><p><strong>性能</strong>：</p>
<ul>
<li><strong><code>JOIN</code> 通常更优</strong>：数据库的查询优化器对 <code>JOIN</code> 的优化策略通常更成熟、更高效。<code>JOIN</code> 可以一次性将所有需要的数据加载到内存中进行匹配。</li>
<li><strong>子查询可能较慢</strong>：特别是相关子查询，因为它对主查询的每一行都要执行一次，当主查询结果集很大时，性能会急剧下降。非相关子查询（尤其是使用 <code>IN</code> 的）在某些版本的 MySQL 中也可能被优化器处理得不够好，导致性能问题。</li>
</ul>
</li>
<li><p><strong>转换示例</strong>：</p>
<ul>
<li><p><strong>子查询版本</strong> (<code>IN</code>)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> dept_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> departments);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>JOIN</code> 版本</strong> (<code>INNER JOIN</code>)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.name <span class="keyword">FROM</span> employees e <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-4-5-常用操作符"><a href="#1-4-5-常用操作符" class="headerlink" title="1.4.5 常用操作符"></a>1.4.5 常用操作符</h4><ul>
<li><strong><code>IN</code> &#x2F; <code>NOT IN</code></strong>：判断某个值是否存在于子查询返回的列表中。</li>
<li><strong><code>ANY</code> &#x2F; <code>SOME</code></strong>：<code>= ANY</code> 等同于 <code>IN</code>。<code>&gt; ANY</code> 表示大于子查询结果中的任意一个（即大于最小值）。</li>
<li><strong><code>ALL</code></strong>：<code>&gt; ALL</code> 表示大于子查询结果中的所有值（即大于最大值）。</li>
<li><strong><code>EXISTS</code> &#x2F; <code>NOT EXISTS</code></strong>：判断子查询是否返回任何行。它不关心返回的内容，只关心“有”还是“没有”。通常比 <code>IN</code> 更高效，因为它找到一个匹配项后就会立即停止。</li>
</ul>
<hr>
<h4 id="1-4-6-最佳实践"><a href="#1-4-6-最佳实践" class="headerlink" title="1.4.6 最佳实践"></a>1.4.6 最佳实践</h4><ol>
<li><strong>优先考虑 <code>JOIN</code></strong>：如果一个查询既可以用子查询实现，也可以用 <code>JOIN</code> 实现，优先尝试 <code>JOIN</code>，并分析其执行计划。</li>
<li><strong>谨慎使用相关子查询</strong>：在处理大表时，要特别注意相关子查询可能带来的性能瓶颈。</li>
<li><strong>使用 <code>EXISTS</code> 代替 <code>IN</code></strong>：当只关心是否存在匹配行，而不关心具体值时，<code>EXISTS</code> 通常比 <code>IN</code> 的效率更高。</li>
<li><strong>确保子查询返回正确的结果集</strong>：标量子查询必须只返回一个值，否则会报错。注意处理可能返回 <code>NULL</code> 的情况。</li>
</ol>
<hr>
<h3 id="1-5-集合操作"><a href="#1-5-集合操作" class="headerlink" title="1.5 集合操作"></a>1.5 集合操作</h3><p>与 <code>JOIN</code> 在水平方向上（按列）组合数据不同，集合操作是在垂直方向上（按行）组合两个或多个 <code>SELECT</code> 语句的结果集。</p>
<h4 id="1-5-1-概述"><a href="#1-5-1-概述" class="headerlink" title="1.5.1 概述"></a>1.5.1 概述</h4><ul>
<li><strong>目的</strong>：将来自不同查询的、结构相似的行合并到一个结果集中。</li>
<li><strong>核心思想</strong>：像操作数学集合一样操作查询结果。</li>
<li><strong>基本规则</strong>：<ol>
<li>所有 <code>SELECT</code> 语句必须有<strong>相同数量的列</strong>。</li>
<li>对应列的<strong>数据类型必须兼容</strong>（或可以被数据库隐式转换）。</li>
<li>结果集中的列名由第一个 <code>SELECT</code> 语句决定。</li>
</ol>
</li>
</ul>
<p>为了演示，我们创建两个简单的示例表：<code>set_a</code> 和 <code>set_b</code>。</p>
<p><strong><code>set_a</code> 表</strong></p>
<table>
<thead>
<tr>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
</tr>
<tr>
<td>李四</td>
</tr>
<tr>
<td>王五</td>
</tr>
</tbody></table>
<p><strong><code>set_b</code> 表</strong></p>
<table>
<thead>
<tr>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>李四</td>
</tr>
<tr>
<td>王五</td>
</tr>
<tr>
<td>赵六</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-5-2-UNION-合并-并集，去重"><a href="#1-5-2-UNION-合并-并集，去重" class="headerlink" title="1.5.2 UNION - 合并 (并集，去重)"></a>1.5.2 UNION - 合并 (并集，去重)</h4><ul>
<li><p><strong>概念</strong>：合并两个或多个 <code>SELECT</code> 语句的结果集，并自动<strong>去除重复的行</strong>。可以理解为取两个集合的<strong>并集</strong>。</p>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2... <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2... <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>示例</strong>：获取 <code>set_a</code> 和 <code>set_b</code> 中所有出现过的名字，不重复。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> set_a</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> set_b;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
</tr>
<tr>
<td>李四</td>
</tr>
<tr>
<td>王五</td>
</tr>
<tr>
<td>赵六</td>
</tr>
</tbody></table>
<p><em><strong>注意</strong>：’李四’ 和 ‘王五’ 在两个表中都存在，但结果中只显示一次。<code>UNION</code> 为了去重，会进行一次类似 <code>DISTINCT</code> 的操作，这可能涉及内部排序，当数据量大时会有性能开销。</em></p>
</li>
</ul>
<hr>
<h4 id="1-5-3-UNION-ALL-合并所有-并集-不去重"><a href="#1-5-3-UNION-ALL-合并所有-并集-不去重" class="headerlink" title="1.5.3 UNION ALL - 合并所有 (并集, 不去重)"></a>1.5.3 UNION ALL - 合并所有 (并集, 不去重)</h4><ul>
<li><p><strong>概念</strong>：合并两个或多个 <code>SELECT</code> 语句的结果集，但<strong>保留所有行，包括重复的行</strong>。</p>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2... <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2... <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>示例</strong>：获取 <code>set_a</code> 和 <code>set_b</code> 中所有的名字记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> set_a</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> set_b;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
</tr>
<tr>
<td>李四</td>
</tr>
<tr>
<td>王五</td>
</tr>
<tr>
<td>李四</td>
</tr>
<tr>
<td>王五</td>
</tr>
<tr>
<td>赵六</td>
</tr>
</tbody></table>
</li>
<li><p><strong>性能</strong>：因为 <code>UNION ALL</code> 省略了去重（通常是排序或哈希）的步骤，所以它的执行效率比 <code>UNION</code> 更高。如果业务逻辑允许重复，或者你确定两个结果集没有交集，<strong>应优先使用 <code>UNION ALL</code></strong>。</p>
</li>
</ul>
<hr>
<h4 id="1-5-4-INTERSECT-交集-MySQL-模拟实现"><a href="#1-5-4-INTERSECT-交集-MySQL-模拟实现" class="headerlink" title="1.5.4 INTERSECT - 交集 (MySQL 模拟实现)"></a>1.5.4 INTERSECT - 交集 (MySQL 模拟实现)</h4><ul>
<li><strong>概念</strong>：返回两个查询结果中<strong>都存在</strong>的行。可以理解为取两个集合的<strong>交集</strong>。</li>
<li><strong>重要提示</strong>：<strong>MySQL 不支持 <code>INTERSECT</code> 关键字</strong>。但我们可以通过其他方式模拟实现。</li>
</ul>
<h5 id="模拟方法-1：使用-IN"><a href="#模拟方法-1：使用-IN" class="headerlink" title="模拟方法 1：使用 IN"></a>模拟方法 1：使用 <code>IN</code></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> set_a</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">IN</span> (<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> set_b);</span><br></pre></td></tr></table></figure>

<h5 id="模拟方法-2：使用-INNER-JOIN-通常性能更好"><a href="#模拟方法-2：使用-INNER-JOIN-通常性能更好" class="headerlink" title="模拟方法 2：使用 INNER JOIN (通常性能更好)"></a>模拟方法 2：使用 <code>INNER JOIN</code> (通常性能更好)</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.name</span><br><span class="line"><span class="keyword">FROM</span> set_a a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> set_b b <span class="keyword">ON</span> a.name <span class="operator">=</span> b.name;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>示例结果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>李四</td>
</tr>
<tr>
<td>王五</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h4 id="1-5-5-EXCEPT-差集-MySQL-模拟实现"><a href="#1-5-5-EXCEPT-差集-MySQL-模拟实现" class="headerlink" title="1.5.5 EXCEPT - 差集 (MySQL 模拟实现)"></a>1.5.5 EXCEPT - 差集 (MySQL 模拟实现)</h4><ul>
<li><strong>概念</strong>：返回第一个查询结果中存在，但在第二个查询结果中<strong>不存在</strong>的行。可以理解为取两个集合的<strong>差集</strong>。</li>
<li><strong>重要提示</strong>：<strong>MySQL 也不支持 <code>EXCEPT</code> 关键字</strong> (在其他数据库如 PostgreSQL, SQL Server 中支持)。同样需要模拟实现。</li>
</ul>
<h5 id="模拟方法-1：使用-LEFT-JOIN-WHERE-IS-NULL"><a href="#模拟方法-1：使用-LEFT-JOIN-WHERE-IS-NULL" class="headerlink" title="模拟方法 1：使用 LEFT JOIN ... WHERE IS NULL"></a>模拟方法 1：使用 <code>LEFT JOIN ... WHERE IS NULL</code></h5><p>这是一个非常常用且高效的技巧，用于查找“不存在”的记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.name</span><br><span class="line"><span class="keyword">FROM</span> set_a a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> set_b b <span class="keyword">ON</span> a.name <span class="operator">=</span> b.name</span><br><span class="line"><span class="keyword">WHERE</span> b.name <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><em>解释</em>：我们尝试将 <code>set_a</code> 中的每一行与 <code>set_b</code> 进行匹配。如果 <code>set_b</code> 中没有匹配的行（即 <code>b.name</code> 为 <code>NULL</code>），就说明这一行是 <code>set_a</code> 独有的。</p>
<h5 id="模拟方法-2：使用-NOT-IN"><a href="#模拟方法-2：使用-NOT-IN" class="headerlink" title="模拟方法 2：使用 NOT IN"></a>模拟方法 2：使用 <code>NOT IN</code></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> set_a</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> set_b);</span><br></pre></td></tr></table></figure>

<p><em>注意</em>：<code>NOT IN</code> 在处理子查询结果中包含 <code>NULL</code> 值时可能会出现意想不到的结果，通常 <code>LEFT JOIN</code> 或 <code>NOT EXISTS</code> 是更安全的选择。</p>
<ul>
<li><p><strong>示例结果</strong> (<code>set_a</code> 减去 <code>set_b</code>)：</p>
<table>
<thead>
<tr>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h4 id="1-5-6-使用注意事项与最佳实践"><a href="#1-5-6-使用注意事项与最佳实践" class="headerlink" title="1.5.6 使用注意事项与最佳实践"></a>1.5.6 使用注意事项与最佳实践</h4><ol>
<li><p><strong>列的对应关系</strong>：集合操作是按列的位置进行匹配的，而不是列名。第一个 <code>SELECT</code> 语句的列名将作为最终结果的列名。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正确示例，列名不同但位置和类型对应</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_name <span class="keyword">AS</span> name, hire_date <span class="keyword">AS</span> event_date <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> customer_name <span class="keyword">AS</span> name, order_date <span class="keyword">AS</span> event_date <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能考量</strong>：再次强调，<code>UNION ALL</code> 的性能远高于 <code>UNION</code>。只有在明确需要去重的场景下才使用 <code>UNION</code>。</p>
</li>
<li><p><strong><code>ORDER BY</code> 和 <code>LIMIT</code></strong>：</p>
<ul>
<li>如果需要对最终的集合结果进行排序或限制行数，<code>ORDER BY</code> 和 <code>LIMIT</code> 子句必须放在<strong>最后一个 <code>SELECT</code> 语句的末尾</strong>。</li>
<li>如果想对每个子查询单独排序，需要将子查询用括号括起来（但这种用法较少见）。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对最终结果排序</span></span><br><span class="line">(<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> set_a)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> set_b)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> name <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-6-窗口函数-Window-Functions"><a href="#1-6-窗口函数-Window-Functions" class="headerlink" title="1.6 窗口函数(Window Functions)"></a>1.6 窗口函数(Window Functions)</h3><h4 id="1-6-1-概述"><a href="#1-6-1-概述" class="headerlink" title="1.6.1 概述"></a>1.6.1 概述</h4><p>窗 口函数（在 MySQL 8.0 及更高版本中受支持）是一种特殊的函数，它对与当前行相关的<strong>一组</strong>（一个“窗口”）查询行执行计算。与普通聚合函数（如 <code>SUM()</code>, <code>COUNT()</code>）不同，窗口函数<strong>不会将多行压缩为一行</strong>，而是为结果集中的<strong>每一行</strong>返回一个值。</p>
<ul>
<li><strong>核心思想</strong>：想象你在多行数据上打开一扇“窗户”，在不离开当前行的情况下，你可以看到并计算这个窗户内的其他行的数据。</li>
<li><strong>与 <code>GROUP BY</code> 的关键区别</strong>：<ul>
<li><code>GROUP BY</code> 聚合：将多行<strong>折叠</strong>成一行，原始的行细节丢失。</li>
<li><code>窗口函数</code>：为每一行计算一个值，同时<strong>保留</strong>所有原始行。</li>
</ul>
</li>
</ul>
<p><strong><code>employees</code> 表</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>department</th>
<th>salary</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>技术部</td>
<td>8000</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>技术部</td>
<td>9500</td>
</tr>
<tr>
<td>3</td>
<td>Carol</td>
<td>技术部</td>
<td>9500</td>
</tr>
<tr>
<td>4</td>
<td>Dave</td>
<td>市场部</td>
<td>7000</td>
</tr>
<tr>
<td>5</td>
<td>Eve</td>
<td>市场部</td>
<td>7500</td>
</tr>
<tr>
<td>6</td>
<td>Frank</td>
<td>财务部</td>
<td>6000</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-6-2-核心语法"><a href="#1-6-2-核心语法" class="headerlink" title="1.6.2 核心语法"></a>1.6.2 核心语法</h4><p>窗口函数的基本语法结构是 <code>FUNCTION_NAME() OVER (...)</code>。关键在于 <code>OVER()</code> 子句，它定义了计算的“窗口”。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">column</span>(s),</span><br><span class="line">    FUNCTION_NAME() <span class="keyword">OVER</span> (</span><br><span class="line">        [<span class="keyword">PARTITION</span> <span class="keyword">BY</span> partition_expression, ... ]</span><br><span class="line">        [<span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_expression [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ... ]</span><br><span class="line">        [frame_clause]</span><br><span class="line">    ) <span class="keyword">AS</span> window_column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<p><code>OVER()</code> 子句包含三个主要部分：</p>
<ol>
<li><strong><code>PARTITION BY</code> (分区)</strong>：<ul>
<li><strong>作用</strong>：将数据行分成多个逻辑组或“分区”。窗口函数将独立地应用于每个分区。</li>
<li><strong>类比</strong>：类似于 <code>GROUP BY</code>，但它不合并行。如果省略，整个结果集被视为一个单一分区。</li>
</ul>
</li>
<li><strong><code>ORDER BY</code> (排序)</strong>：<ul>
<li><strong>作用</strong>：定义分区内行的顺序。这对于排名函数（如 <code>ROW_NUMBER()</code>）和需要顺序的计算（如累计求和）至关重要。</li>
</ul>
</li>
<li><strong><code>frame_clause</code> (窗口框架)</strong>：<ul>
<li><strong>作用</strong>：进一步定义分区内的一个子集（“框架”），即当前行周围的行范围。例如，“从分区开始到当前行”或“当前行及前后各一行”。</li>
<li><strong>语法</strong>：<code>ROWS | RANGE BETWEEN &lt;start&gt; AND &lt;end&gt;</code></li>
<li>如果省略，默认框架通常是 <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>（取决于 <code>ORDER BY</code>）。<ul>
<li><code>UNBOUNDED PRECEDING</code>: 帧的起点是当前分区的<strong>第一行</strong>。</li>
<li><code>CURRENT ROW</code>: 帧的终点是<strong>当前行</strong>。</li>
<li><strong><code>RANGE</code> (关键点)</strong>: <code>RANGE</code> 不是根据物理行来定义 <code>CURRENT ROW</code>，而是根据 <strong><code>ORDER BY</code> 子句中的值</strong>。所有与当前行有相同值的行（也称为**“伙伴行”或“对等行” (Peers)**）都会被包含在窗口帧内。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>窗口帧</strong>: 在 <code>OVER()</code> 子句中加入了 <strong><code>ORDER BY</code></strong> 时，数据库不仅对分区内的数据进行排序，还会为<strong>每一行</strong>定义一个更小的计算范围，这个范围就叫做“窗口帧”。</p>
<hr>
<h4 id="1-6-3-常见的窗口函数类型"><a href="#1-6-3-常见的窗口函数类型" class="headerlink" title="1.6.3 常见的窗口函数类型"></a>1.6.3 常见的窗口函数类型</h4><h5 id="1-排名函数-Ranking-Functions"><a href="#1-排名函数-Ranking-Functions" class="headerlink" title="1. 排名函数 (Ranking Functions)"></a>1. 排名函数 (Ranking Functions)</h5><ul>
<li><strong><code>ROW_NUMBER()</code></strong>：为分区内的每一行分配一个唯一的、连续的整数，从 1 开始。</li>
<li><strong><code>RANK()</code></strong>：为分区内的每一行分配排名。如果存在相同的值（并列），它们将获得相同的排名，但随后的排名会<strong>跳过</strong>相应的数字。</li>
<li><strong><code>DENSE_RANK()</code></strong>：与 <code>RANK()</code> 类似，但并列排名后的下一个排名是<strong>连续的</strong>，不会跳过。</li>
</ul>
<p><strong>示例</strong>：按部门为员工的薪资排名。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    department,</span><br><span class="line">    salary,</span><br><span class="line">    <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> row_num,</span><br><span class="line">    <span class="built_in">RANK</span>()       <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> rnk,</span><br><span class="line">    <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> dense_rnk</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>department</th>
<th>salary</th>
<th>row_num</th>
<th>rnk</th>
<th>dense_rnk</th>
</tr>
</thead>
<tbody><tr>
<td>Frank</td>
<td>财务部</td>
<td>6000</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Eve</td>
<td>市场部</td>
<td>7500</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Dave</td>
<td>市场部</td>
<td>7000</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>Bob</td>
<td>技术部</td>
<td>9500</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Carol</td>
<td>技术部</td>
<td>9500</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Alice</td>
<td>技术部</td>
<td>8000</td>
<td>3</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<p><em>观察</em>：在技术部，Bob 和 Carol 薪资并列。<code>RANK()</code> 给了他们排名 1，下一个排名跳到了 3。而 <code>DENSE_RANK()</code> 给了他们排名 1，下一个排名是连续的 2。</p>
<hr>
<h5 id="2-聚合函数-Aggregate-Functions"><a href="#2-聚合函数-Aggregate-Functions" class="headerlink" title="2. 聚合函数 (Aggregate Functions)"></a>2. 聚合函数 (Aggregate Functions)</h5><p>我们熟悉的 <code>SUM()</code>, <code>AVG()</code>, <code>COUNT()</code>, <code>MAX()</code>, <code>MIN()</code> 都可以用作窗口函数。</p>
<p><strong>示例</strong>：计算每个员工的薪资，以及他们所在部门的平均薪资和累计薪资。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    department,</span><br><span class="line">    salary,</span><br><span class="line">    <span class="comment">-- 计算部门平均薪资</span></span><br><span class="line">    <span class="built_in">AVG</span>(salary) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department) <span class="keyword">AS</span> dept_avg_salary,</span><br><span class="line">    <span class="comment">-- 计算部门内按薪资升序的累计薪资</span></span><br><span class="line">    <span class="built_in">SUM</span>(salary) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>) <span class="keyword">AS</span> cumulative_salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>department</th>
<th>salary</th>
<th>dept_avg_salary</th>
<th>cumulative_salary</th>
</tr>
</thead>
<tbody><tr>
<td>Frank</td>
<td>财务部</td>
<td>6000</td>
<td>6000.0000</td>
<td>6000</td>
</tr>
<tr>
<td>Dave</td>
<td>市场部</td>
<td>7000</td>
<td>7250.0000</td>
<td>7000</td>
</tr>
<tr>
<td>Eve</td>
<td>市场部</td>
<td>7500</td>
<td>7250.0000</td>
<td>14500</td>
</tr>
<tr>
<td>Alice</td>
<td>技术部</td>
<td>8000</td>
<td>9000.0000</td>
<td>8000</td>
</tr>
<tr>
<td>Bob</td>
<td>技术部</td>
<td>9500</td>
<td>9000.0000</td>
<td>27000</td>
</tr>
<tr>
<td>Carol</td>
<td>技术部</td>
<td>9500</td>
<td>9000.0000</td>
<td>27000</td>
</tr>
</tbody></table>
<hr>
<h5 id="3-值函数-Value-Functions"><a href="#3-值函数-Value-Functions" class="headerlink" title="3. 值函数 (Value Functions)"></a>3. 值函数 (Value Functions)</h5><ul>
<li><strong><code>LAG(expr, offset, default)</code></strong>：获取分区内，当前行<strong>之前</strong>第 <code>offset</code> 行的 <code>expr</code> 值。</li>
<li><strong><code>LEAD(expr, offset, default)</code></strong>：获取分区内，当前行<strong>之后</strong>第 <code>offset</code> 行的 <code>expr</code> 值。</li>
<li><strong><code>FIRST_VALUE(expr)</code></strong>：获取分区内第一行的 <code>expr</code> 值。</li>
<li><strong><code>LAST_VALUE(expr)</code></strong>：获取分区内最后一行的 <code>expr</code> 值。</li>
</ul>
<p><strong>示例</strong>：查询每个员工的薪资，并显示同部门中薪资比他低一位的员工薪资。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    department,</span><br><span class="line">    salary,</span><br><span class="line">    <span class="built_in">LAG</span>(salary, <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>) <span class="keyword">AS</span> previous_salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>department</th>
<th>salary</th>
<th>previous_salary</th>
</tr>
</thead>
<tbody><tr>
<td>Frank</td>
<td>财务部</td>
<td>6000</td>
<td>0</td>
</tr>
<tr>
<td>Dave</td>
<td>市场部</td>
<td>7000</td>
<td>0</td>
</tr>
<tr>
<td>Eve</td>
<td>市场部</td>
<td>7500</td>
<td>7000</td>
</tr>
<tr>
<td>Alice</td>
<td>技术部</td>
<td>8000</td>
<td>0</td>
</tr>
<tr>
<td>Bob</td>
<td>技术部</td>
<td>9500</td>
<td>8000</td>
</tr>
<tr>
<td>Carol</td>
<td>技术部</td>
<td>9500</td>
<td>8000</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-6-4-典型应用场景"><a href="#1-6-4-典型应用场景" class="headerlink" title="1.6.4 典型应用场景"></a>1.6.4 典型应用场景</h4><ol>
<li><p><strong>分组排名</strong>：找出“每个部门薪资最高的 N 名员工”。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用子查询或 CTE 过滤窗口函数的结果</span></span><br><span class="line"><span class="keyword">WITH</span> RankedEmployees <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        name,</span><br><span class="line">        department,</span><br><span class="line">        salary,</span><br><span class="line">        <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">as</span> rn</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> name, department, salary <span class="keyword">FROM</span> RankedEmployees <span class="keyword">WHERE</span> rn <span class="operator">&lt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>累计计算</strong>：计算“年度至今的销售总额”、“用户随时间的累计积分”。</p>
</li>
<li><p><strong>同比&#x2F;环比分析</strong>：使用 <code>LAG()</code> 函数轻松计算与上一个时间周期（如上个月、去年同期）的数据差异。</p>
</li>
</ol>
<hr>
<h4 id="1-6-5-使用注意事项"><a href="#1-6-5-使用注意事项" class="headerlink" title="1.6.5 使用注意事项"></a>1.6.5 使用注意事项</h4><ol>
<li><strong>不能在 <code>WHERE</code> 或 <code>GROUP BY</code> 子句中使用</strong>：窗口函数是在 <code>WHERE</code>, <code>GROUP BY</code>, <code>HAVING</code> 子句处理完之后才执行的。如果你需要根据窗口函数的结果进行过滤，必须使用<strong>子查询</strong>或<strong>通用表表达式 (CTE)</strong>。</li>
<li><strong>性能</strong>：窗口函数非常强大，但也可能消耗大量资源，尤其是在大数据集上进行复杂的 <code>PARTITION BY</code> 和 <code>ORDER BY</code> 操作时。确保分区键和排序列上有合适的索引。</li>
<li><strong>版本支持</strong>：窗口函数是 <strong>MySQL 8.0</strong> 引入的核心功能，早期版本不支持</li>
</ol>
<hr>
<h3 id="1-7-通用表表达式-CTE"><a href="#1-7-通用表表达式-CTE" class="headerlink" title="1.7 通用表表达式(CTE)"></a>1.7 通用表表达式(CTE)</h3><h4 id="1-7-1-概述"><a href="#1-7-1-概述" class="headerlink" title="1.7.1 概述"></a>1.7.1 概述</h4><p><strong>简介</strong></p>
<p>通用表表达式（CTE）是一个在 <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, 或 <code>DELETE</code> 语句开头定义的、命名的临时结果集。</p>
<p><strong>核心优势</strong></p>
<ol>
<li><strong>可读性 (Readability)</strong>：将复杂的子查询或 <code>JOIN</code> 逻辑从主查询中分离出来，并赋予其一个有意义的名称，使整个 SQL 语句像讲故事一样清晰。</li>
<li><strong>可维护性 (Maintainability)</strong>：当查询逻辑需要修改时，你只需要在 CTE 的定义处修改，而不是在多个地方修改冗长的子查询。</li>
<li><strong>可重用性 (Reusability)</strong>：一个 CTE 可以在同一个查询中被多次引用，避免了重复编写相同的子查询。</li>
<li><strong>递归查询 (Recursion)</strong>：CTE 是在 SQL 中实现递  归查询的标准方式，这是普通子查询无法做到的。例如，处理组织架构、物料清单 (BOM) 等层次结构数据。</li>
</ol>
<hr>
<h4 id="1-7-2-核心语法"><a href="#1-7-2-核心语法" class="headerlink" title="1.7.2 核心语法"></a>1.7.2 核心语法</h4><p>CTE 使用 <code>WITH</code> 关键字来定义。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cte_name_1 [(column_name_1, column_name_2, ...)] <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- CTE 1 的 SELECT 查询</span></span><br><span class="line">    <span class="keyword">SELECT</span> ...</span><br><span class="line">),</span><br><span class="line">cte_name_2 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- CTE 2 的 SELECT 查询，可以引用 cte_name_1</span></span><br><span class="line">    <span class="keyword">SELECT</span> ...</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 主查询，可以引用 cte_name_1 和 cte_name_2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cte_name_1 <span class="keyword">JOIN</span> cte_name_2 <span class="keyword">ON</span> ...;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>WITH</code>: 标志着一个或多个 CTE 的开始。</li>
<li><code>cte_name</code>: 你为这个临时结果集起的名字。</li>
<li><code>AS (...)</code>: 括号内是定义这个 CTE 的 <code>SELECT</code> 语句。</li>
<li>主查询: 在 CTE 定义之后，紧跟着一个 <code>SELECT</code> (或其他 DML) 语句，该语句可以使用前面定义的 CTE，就像它们是普通的表或视图一样。</li>
</ul>
<hr>
<h4 id="1-7-3-非递归-CTE-Non-Recursive-CTE"><a href="#1-7-3-非递归-CTE-Non-Recursive-CTE" class="headerlink" title="1.7.3 非递归 CTE (Non-Recursive CTE)"></a>1.7.3 非递归 CTE (Non-Recursive CTE)</h4><p>这是最常见的 CTE 用法，用于分解复杂查询。</p>
<p><strong>场景</strong>：找出每个部门中，薪资高于该部门平均薪资的员工。</p>
<p><strong>使用子查询的写法 (可能比较混乱)</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    e.name,</span><br><span class="line">    e.salary,</span><br><span class="line">    e.department</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees e</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> department, <span class="built_in">AVG</span>(salary) <span class="keyword">as</span> avg_sal <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department) <span class="keyword">AS</span> dept_avg</span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line">    e.department <span class="operator">=</span> dept_avg.department</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    e.salary <span class="operator">&gt;</span> dept_avg.avg_sal;</span><br></pre></td></tr></table></figure>

<p><strong>使用 CTE 的写法 (逻辑清晰)</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> department_avg_salary <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 第一步：计算每个部门的平均薪资</span></span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        department,</span><br><span class="line">        <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_sal</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        employees</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">        department</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 第二步：将员工表与上面的结果连接，进行筛选</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    e.name,</span><br><span class="line">    e.salary,</span><br><span class="line">    e.department</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees e</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">    department_avg_salary das <span class="keyword">ON</span> e.department <span class="operator">=</span> das.department</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    e.salary <span class="operator">&gt;</span> das.avg_sal;</span><br></pre></td></tr></table></figure>

<p>通过 CTE，我们将 “计算部门平均薪资” 这个逻辑步骤独立出来并命名为 <code>department_avg_salary</code>，主查询的意图变得非常清晰：“从员工表中，找出薪资高于部门平均薪资的员工”。</p>
<hr>
<h4 id="1-7-4-递归-CTE-Recursive-CTE"><a href="#1-7-4-递归-CTE-Recursive-CTE" class="headerlink" title="1.7.4 递归 CTE (Recursive CTE)"></a>1.7.4 递归 CTE (Recursive CTE)</h4><p>递归 CTE 是一种可以自我引用的 CTE，专门用于处理具有层次或树状结构的数据。</p>
<p><strong>核心结构</strong>：一个递归 CTE 必须包含两个部分，并通过 <code>UNION ALL</code> 连接。</p>
<ol>
<li><strong>锚点成员 (Anchor Member)</strong>：一个不引用 CTE 自身的 <code>SELECT</code> 语句。这是递归的起点。</li>
<li><strong>递归成员 (Recursive Member)</strong>：一个引用 CTE 自身的 <code>SELECT</code> 语句。它会与上一步的结果进行 <code>JOIN</code> 操作，生成下一层级的数据。</li>
</ol>
<p><strong>场景</strong>：在一个员工表中，查询某个经理（及其下属）的所有层级的员工。</p>
<p><strong><code>employees_hierarchy</code> 表</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>manager_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>NULL</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>Carol</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>Dave</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>Eve</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>Frank</td>
<td>3</td>
</tr>
</tbody></table>
<p><strong>查询</strong>：找出 Bob (id&#x3D;2) 和他管理的所有下属。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> employee_path <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 1. 锚点成员：找到起始点，即 Bob 自己</span></span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        id,</span><br><span class="line">        name,</span><br><span class="line">        manager_id,</span><br><span class="line">        <span class="number">1</span> <span class="keyword">AS</span> level <span class="comment">-- 增加一个层级字段</span></span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        employees_hierarchy</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">        id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 2. 递归成员：将员工表与 CTE 自身连接</span></span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        e.id,</span><br><span class="line">        e.name,</span><br><span class="line">        e.manager_id,</span><br><span class="line">        ep.level <span class="operator">+</span> <span class="number">1</span> <span class="comment">-- 层级加 1</span></span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        employees_hierarchy e</span><br><span class="line">    <span class="keyword">JOIN</span></span><br><span class="line">        employee_path ep <span class="keyword">ON</span> e.manager_id <span class="operator">=</span> ep.id <span class="comment">-- 关键：找到上一轮结果的直接下属</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 3. 主查询：从递归 CTE 中查询所有结果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee_path;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>manager_id</th>
<th>level</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>Bob</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>Dave</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>Eve</td>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p><em>执行过程</em>：</p>
<ol>
<li><strong>锚点</strong>执行，<code>employee_path</code> 中有了 Bob (id&#x3D;2, level&#x3D;1) 的记录。</li>
<li><strong>递归</strong>执行，<code>employees_hierarchy</code> 表 <code>JOIN employee_path</code> (此时只有 Bob)，找到 <code>manager_id</code> 为 2 的员工 Dave 和 Eve，将他们 (level&#x3D;2) 加入结果集。</li>
<li><strong>递归</strong>再次执行，<code>employees_hierarchy</code> 表 <code>JOIN employee_path</code> (此时有 Dave 和 Eve)，但找不到 <code>manager_id</code> 为 4 或 5 的员工，<code>JOIN</code> 失败。</li>
<li>递归结束，返回所有结果。</li>
</ol>
<hr>
<h3 id="1-8-视图-View"><a href="#1-8-视图-View" class="headerlink" title="1.8 视图(View)"></a>1.8 视图(View)</h3><h4 id="1-8-1-概述"><a href="#1-8-1-概述" class="headerlink" title="1.8.1 概述"></a>1.8.1 概述</h4><p>视图（View）在 SQL 中是一个<strong>虚拟表</strong>，其内容由查询定义。通过视图我们可以看到或操作来自一个或多个基础表的数据。</p>
<ul>
<li><strong>虚拟性</strong>：视图本身不包含任何数据。它所显示的数据是从基础表中动态生成的。当基础表的数据发生变化时，通过视图看到的数据也会相应更新。</li>
<li><strong>查询封装</strong>：视图的本质是一条被命名的、预定义的 <code>SELECT</code> 语句。</li>
</ul>
<p>可以通俗地理解为：视图就是一个<strong>存储起来的查询</strong>，你可以像查询普通表一样查询它，但它本身不占用实际的存储空间（物化视图除外，但 MySQL 标准版不支持）。</p>
<hr>
<h4 id="1-8-2-优势"><a href="#1-8-2-优势" class="headerlink" title="1.8.2 优势"></a>1.8.2 优势</h4><ol>
<li><strong>简化复杂查询</strong><ul>
<li><strong>场景</strong>：当一个查询需要连接多张表，或者包含复杂的子查询和计算时，每次编写都非常繁琐且容易出错。</li>
<li><strong>解决方案</strong>：可以将这个复杂的查询定义为一个视图。之后，只需简单地 <code>SELECT * FROM a_simple_view_name</code> 即可，大大简化了操作。</li>
</ul>
</li>
<li><strong>增强数据安全性</strong><ul>
<li><strong>场景</strong>：你希望某个用户只能访问 <code>employees</code> 表中的姓名和邮箱，而不能看到敏感的薪资信息。</li>
<li><strong>解决方案</strong>：可以创建一个只包含 <code>employee_name</code> 和 <code>email</code> 列的视图，然后只授予用户访问该视图的权限，而不是整个 <code>employees</code> 表的权限。这样就实现了列级别的权限控制。同样，也可以通过 <code>WHERE</code> 子句实现行级别的权限控制（例如，部门经理只能看到自己部门的员工信息）。</li>
</ul>
</li>
<li><strong>提高逻辑数据独立性</strong><ul>
<li><strong>场景</strong>：你的数据库表结构可能因为业务发展而需要调整，比如将一个大表拆分成两个小表。</li>
<li><strong>解决方案</strong>：如果应用程序直接查询的是表，那么表结构的变化会导致大量应用代码需要修改。但如果应用查询的是视图，你可以在表结构变化后，修改视图的定义来适应新的表结构，而应用程序的代码无需任何改动。视图在应用和底层表之间提供了一个抽象层。</li>
</ul>
</li>
<li><strong>代码重用与维护</strong><ul>
<li><strong>场景</strong>：多个报表或业务逻辑都需要一个相同的、关于“本月活跃用户”的查询。</li>
<li><strong>解决方案</strong>：将其定义成一个视图 <code>v_monthly_active_users</code>。所有需要这个逻辑的地方都直接使用该视图。当“活跃用户”的定义需要修改时，只需修改视图的定义一次，所有引用的地方都会自动更新，极大地提高了代码的可维护性。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-8-3-视图的基本操作-语法"><a href="#1-8-3-视图的基本操作-语法" class="headerlink" title="1.8.3 视图的基本操作 (语法)"></a>1.8.3 视图的基本操作 (语法)</h4><h5 id="1-创建视图-CREATE-VIEW"><a href="#1-创建视图-CREATE-VIEW" class="headerlink" title="1. 创建视图 (CREATE VIEW)"></a>1. 创建视图 (CREATE VIEW)</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>OR REPLACE</code>：如果同名视图已存在，则替换它；如果不存在，则创建。</li>
<li><code>column_list</code>：可选，为视图的列指定新的名称。</li>
</ul>
<p><strong>示例：</strong></p>
<p>假设我们有 <code>employees</code> 表和 <code>departments</code> 表，现在创建一个视图来显示员工姓名、邮箱及其所在的部门名称。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_employee_details <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    e.first_name,</span><br><span class="line">    e.last_name,</span><br><span class="line">    e.email,</span><br><span class="line">    d.department_name</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    employees e</span><br><span class="line"><span class="keyword">JOIN</span> </span><br><span class="line">    departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure>

<h5 id="2-查询视图"><a href="#2-查询视图" class="headerlink" title="2. 查询视图"></a>2. 查询视图</h5><p>查询视图的方法与查询普通表完全一样。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有员工及其部门信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> v_employee_details;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 &#x27;IT&#x27; 部门的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, email <span class="keyword">FROM</span> v_employee_details <span class="keyword">WHERE</span> department_name <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-修改视图-ALTER-VIEW"><a href="#3-修改视图-ALTER-VIEW" class="headerlink" title="3. 修改视图 (ALTER VIEW)"></a>3. 修改视图 (ALTER VIEW)</h5><p>修改视图的定义，通常是改变其底层的 <code>SELECT</code> 语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> ...;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<p>为上面的视图增加一个 <code>job_title</code> 字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> v_employee_details <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    e.first_name,</span><br><span class="line">    e.last_name,</span><br><span class="line">    e.email,</span><br><span class="line">    j.job_title, <span class="comment">-- 新增字段</span></span><br><span class="line">    d.department_name</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    employees e</span><br><span class="line"><span class="keyword">JOIN</span> </span><br><span class="line">    departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">    jobs j <span class="keyword">ON</span> e.job_id <span class="operator">=</span> j.job_id;</span><br></pre></td></tr></table></figure>

<h5 id="4-删除视图-DROP-VIEW-1"><a href="#4-删除视图-DROP-VIEW-1" class="headerlink" title="4. 删除视图 (DROP VIEW)"></a>4. 删除视图 (DROP VIEW)</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] view_name;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>IF EXISTS</code>：避免因视图不存在而报错。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> v_employee_details;</span><br></pre></td></tr></table></figure>

<h5 id="5-查看视图定义"><a href="#5-查看视图定义" class="headerlink" title="5. 查看视图定义"></a>5. 查看视图定义</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure>

<p>此命令会显示创建该视图的完整 SQL 语句。</p>
<hr>
<h4 id="1-8-4-视图的重要特性与限制"><a href="#1-8-4-视图的重要特性与限制" class="headerlink" title="1.8.4 视图的重要特性与限制"></a>1.8.4 视图的重要特性与限制</h4><h5 id="1-可更新性-Updatability"><a href="#1-可更新性-Updatability" class="headerlink" title="1. 可更新性 (Updatability)"></a>1. 可更新性 (Updatability)</h5><p>视图不仅仅是可读的，在某些情况下，你也可以通过视图来执行 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作，这些操作会直接影响到基础表。这样的视图称为<strong>可更新视图</strong>。</p>
<p>但是，<strong>并非所有视图都是可更新的</strong>。如果视图的定义包含以下任何一种情况，它通常是<strong>不可更新的</strong>：</p>
<ul>
<li>聚合函数（<code>SUM()</code>, <code>COUNT()</code>, <code>AVG()</code> 等）</li>
<li><code>DISTINCT</code></li>
<li><code>GROUP BY</code> 或 <code>HAVING</code></li>
<li><code>UNION</code> 或 <code>UNION ALL</code></li>
<li><code>SELECT</code> 列表中包含子查询</li>
<li><code>FROM</code> 子句中包含不可更新的视图</li>
<li><code>JOIN</code> 操作（部分简单的 JOIN 可能是可更新的，但复杂情况通常不行）</li>
<li><code>SELECT</code> 列表中包含字面量值（如 <code>SELECT &#39;Constant&#39; ...</code>）</li>
</ul>
<h5 id="2-WITH-CHECK-OPTION"><a href="#2-WITH-CHECK-OPTION" class="headerlink" title="2. WITH CHECK OPTION"></a>2. <code>WITH CHECK OPTION</code></h5><p>用于可更新的视图。它能确保通过视图进行的 <code>INSERT</code> 或 <code>UPDATE</code> 操作所产生的新行，必须满足视图 <code>WHERE</code> 子句中的条件。</p>
<p><strong>示例：</strong></p>
<p>创建一个只包含 ‘Sales’ 部门员工的视图。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_sales_employees <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, first_name, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">50</span>; <span class="comment">-- 假设 50 是 &#x27;Sales&#x27; 部门的 ID</span></span><br></pre></td></tr></table></figure>

<p>现在，通过这个视图，我们可以将一个销售员工的部门改成其他部门：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这个操作会成功，但更新后该员工将不再从 v_sales_employees 视图中可见</span></span><br><span class="line"><span class="keyword">UPDATE</span> v_sales_employees <span class="keyword">SET</span> department_id <span class="operator">=</span> <span class="number">80</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">101</span>;</span><br></pre></td></tr></table></figure>

<p>为了防止这种情况，我们可以使用 <code>WITH CHECK OPTION</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> v_sales_employees <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, first_name, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure>

<p>现在，再尝试执行上面的 <code>UPDATE</code> 语句将会失败，因为新的行 (<code>department_id = 80</code>) 不满足视图的 <code>WHERE department_id = 50</code> 条件。</p>
<h5 id="3-性能问题"><a href="#3-性能问题" class="headerlink" title="3. 性能问题"></a>3. 性能问题</h5><p>虽然视图简化了查询，但它并不能自动提高性能。MySQL 处理视图的方式通常是“查询合并”（Query Merging），即把对视图的查询和视图本身的定义合并成一个对基础表的复杂查询，然后进行优化。</p>
<ul>
<li>对于简单的视图，这种方式效率很高。</li>
<li>对于复杂的视图（如多层嵌套视图），优化器可能无法生成最优的执行计划，导致性能下降。因此，滥用复杂视图可能会成为性能瓶颈。</li>
</ul>
<hr>
<h3 id="1-9-存储过程-Stored-Procedure-与函数-Function"><a href="#1-9-存储过程-Stored-Procedure-与函数-Function" class="headerlink" title="1.9 存储过程(Stored Procedure)与函数(Function)"></a>1.9 存储过程(Stored Procedure)与函数(Function)</h3><h4 id="1-9-1-概述"><a href="#1-9-1-概述" class="headerlink" title="1.9.1 概述"></a>1.9.1 概述</h4><p>存储过程和函数是预先编译好并存储在数据库中的一组 SQL 语句的集合。它们被赋予一个名称，可以被应用程序或其他 SQL 语句调用。</p>
<p>可以把它们理解为数据库中的<strong>自定义代码块</strong>或<strong>微服务</strong>，用于封装复杂的业务逻辑、重复性的任务或数据校验规则。</p>
<ul>
<li><strong>存储过程 (Stored Procedure)</strong>: 主要用于执行一个操作或一系列操作。它可以接收输入参数，也可以返回输出参数，但它本身没有“返回值”的概念。</li>
<li><strong>函数 (User-Defined Function, UDF)</strong>: 主要用于计算和返回一个<strong>单一的值</strong>。它必须有一个返回值，并且可以像数据库内置函数（如 <code>NOW()</code>, <code>SUM()</code>）一样，直接在 SQL 查询语句中使用。</li>
</ul>
<hr>
<h4 id="1-9-2-优势"><a href="#1-9-2-优势" class="headerlink" title="1.9.2 优势"></a>1.9.2 优势</h4><ol>
<li><strong>封装与代码重用</strong><ul>
<li>将复杂的业务逻辑（例如，创建一个新订单，这可能涉及更新库存、记录交易、通知用户等多步操作）封装在一个单元中。应用程序只需调用这个单元，而无需关心内部细节。</li>
</ul>
</li>
<li><strong>减少网络流量，提升性能</strong><ul>
<li><strong>不使用时</strong>：应用程序需要向数据库发送多条独立的 SQL 语句。每一条语句都有网络往返的开销。</li>
<li><strong>使用时</strong>：应用程序只需发送一条 <code>CALL</code> 语句。所有的逻辑都在数据库服务器内部执行，大大减少了网络通信。</li>
</ul>
</li>
<li><strong>增强安全性</strong><ul>
<li>可以不授予用户对基础表的直接访问权限（<code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>），而只授予他们执行（<code>EXECUTE</code>）特定存储过程的权限。这样，用户只能通过你预设好的逻辑来操作数据，防止了不规范或恶意的操作。</li>
</ul>
</li>
<li><strong>简化应用开发与维护</strong><ul>
<li>将数据相关的业务逻辑集中在数据库层，使应用层代码更简洁。</li>
<li>当业务逻辑变更时，通常只需修改存储过程或函数，而无需重新编译和部署应用程序。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-9-3-存储过程-Stored-Procedure-详解"><a href="#1-9-3-存储过程-Stored-Procedure-详解" class="headerlink" title="1.9.3 存储过程 (Stored Procedure) 详解"></a>1.9.3 存储过程 (Stored Procedure) 详解</h4><p><strong>特点:</strong></p>
<ul>
<li>可以包含 DDL, DML, DCL, TCL 等几乎所有类型的 SQL 语句。</li>
<li>可以通过 <code>OUT</code> 或 <code>INOUT</code> 类型的参数返回多个结果。</li>
<li>通过 <code>CALL</code> 关键字来调用。</li>
</ul>
<p><strong>语法与示例</strong></p>
<p>在编写存储过程时，需要临时修改语句结束符，因为过程体内部本身就包含分号 <code>;</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 临时修改结束符为 $$</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sp_get_employee_by_dept(</span><br><span class="line">    <span class="keyword">IN</span> p_dept_name <span class="type">VARCHAR</span>(<span class="number">50</span>),  <span class="comment">-- 输入参数：部门名称</span></span><br><span class="line">    <span class="keyword">OUT</span> p_employee_count <span class="type">INT</span>      <span class="comment">-- 输出参数：该部门的员工数量</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 声明一个局部变量来存储部门ID</span></span><br><span class="line">    <span class="keyword">DECLARE</span> v_dept_id <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 第一步：根据部门名称查找部门ID</span></span><br><span class="line">    <span class="keyword">SELECT</span> department_id <span class="keyword">INTO</span> v_dept_id</span><br><span class="line">    <span class="keyword">FROM</span> departments </span><br><span class="line">    <span class="keyword">WHERE</span> department_name <span class="operator">=</span> p_dept_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 第二步：计算该部门的员工数量，并赋值给输出参数</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> p_employee_count</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> department_id <span class="operator">=</span> v_dept_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 第三步：查询并返回该部门所有员工的详细信息（作为一个结果集）</span></span><br><span class="line">    <span class="keyword">SELECT</span> employee_id, first_name, last_name, email</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> department_id <span class="operator">=</span> v_dept_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将结束符恢复为 ;</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>如何调用：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="comment">-- @count 是一个用户会话变量，用于接收 OUT 参数的值</span></span><br><span class="line"><span class="keyword">CALL</span> sp_get_employee_by_dept(<span class="string">&#x27;IT&#x27;</span>, <span class="variable">@count</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 OUT 参数的结果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@count</span> <span class="keyword">AS</span> it_department_employee_count;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong>：</p>
<ol>
<li>首先会返回一个结果集，包含所有 ‘IT’ 部门员工的 <code>employee_id</code>, <code>first_name</code> 等信息。</li>
<li>然后，通过 <code>SELECT @count;</code> 可以得到 ‘IT’ 部门的员工总数。</li>
</ol>
<hr>
<h4 id="1-9-4-函数-Function-详解"><a href="#1-9-4-函数-Function-详解" class="headerlink" title="1.9.4 函数 (Function) 详解"></a>1.9.4 函数 (Function) 详解</h4><p><strong>特点:</strong></p>
<ul>
<li>必须返回一个单一的值（<code>RETURNS</code> 关键字定义）。</li>
<li>主要用于计算，通常在 <code>SELECT</code> 语句的列、<code>WHERE</code> 子句或 <code>ORDER BY</code> 子句中使用。</li>
<li>默认情况下，函数体内不允许执行修改数据的 DML 语句（如 <code>INSERT</code>, <code>UPDATE</code>）。</li>
<li>只能有 <code>IN</code> 类型的参数。</li>
</ul>
<p><strong>语法与示例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> fn_get_employee_fullname(</span><br><span class="line">    p_employee_id <span class="type">INT</span>  <span class="comment">-- 输入参数：员工ID</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="comment">-- 定义返回值类型</span></span><br><span class="line"><span class="keyword">DETERMINISTIC</span> <span class="comment">-- 提示优化器：对于相同的输入，总是产生相同的输出</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 声明一个局部变量用于存储全名</span></span><br><span class="line">    <span class="keyword">DECLARE</span> v_full_name <span class="type">VARCHAR</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 查询并拼接姓名</span></span><br><span class="line">    <span class="keyword">SELECT</span> CONCAT(first_name, <span class="string">&#x27; &#x27;</span>, last_name) <span class="keyword">INTO</span> v_full_name</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> p_employee_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 返回结果</span></span><br><span class="line">    <span class="keyword">RETURN</span> v_full_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>DETERMINISTIC</strong> vs <strong>NOT DETERMINISTIC</strong>:</p>
<ul>
<li><code>DETERMINISTIC</code>: 确定性函数，输入相同，输出永远相同（如 <code>CONCAT()</code>）。</li>
<li><code>NOT DETERMINISTIC</code>: 非确定性函数，输入相同，输出可能不同（如 <code>NOW()</code>）。正确声明有助于 MySQL 优化。</li>
</ul>
<p><strong>如何调用：</strong></p>
<p>函数就像内置函数一样直接在 SQL 中使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 SELECT 列表中使用</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    employee_id,</span><br><span class="line">    fn_get_employee_fullname(employee_id) <span class="keyword">AS</span> full_name,</span><br><span class="line">    email</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 WHERE 子句中使用</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, email</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> fn_get_employee_fullname(employee_id) <span class="operator">=</span> <span class="string">&#x27;Steven King&#x27;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-9-5-存储过程-vs-函数-核心区别总结"><a href="#1-9-5-存储过程-vs-函数-核心区别总结" class="headerlink" title="1.9.5 存储过程 vs. 函数 (核心区别总结)"></a>1.9.5 存储过程 vs. 函数 (核心区别总结)</h4><table>
<thead>
<tr>
<th align="left">特性 (Feature)</th>
<th align="left">存储过程 (Procedure)</th>
<th align="left">函数 (Function)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>返回值</strong></td>
<td align="left">没有直接返回值；可通过<code>OUT</code>&#x2F;<code>INOUT</code>参数返回多个值</td>
<td align="left"><strong>必须</strong>返回一个单一的值</td>
</tr>
<tr>
<td align="left"><strong>调用方式</strong></td>
<td align="left"><code>CALL procedure_name();</code></td>
<td align="left">直接在SQL语句中使用，如<code>SELECT function_name();</code></td>
</tr>
<tr>
<td align="left"><strong>参数类型</strong></td>
<td align="left">支持 <code>IN</code>, <code>OUT</code>, <code>INOUT</code></td>
<td align="left">只支持 <code>IN</code></td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">执行一系列操作、封装复杂业务逻辑</td>
<td align="left">进行计算、格式化数据并返回结果</td>
</tr>
<tr>
<td align="left"><strong>数据操作</strong></td>
<td align="left">可以执行 DML (INSERT&#x2F;UPDATE&#x2F;DELETE) 等所有SQL操作</td>
<td align="left">通常是只读的，不允许修改数据（有例外但非标准）</td>
</tr>
<tr>
<td align="left"><strong>结果集</strong></td>
<td align="left">可以返回一个或多个结果集</td>
<td align="left">不可以返回结果集</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-9-6-基本管理操作"><a href="#1-9-6-基本管理操作" class="headerlink" title="1.9.6 基本管理操作"></a>1.9.6 基本管理操作</h4><p><strong>查看定义:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sp_get_employee_by_dept;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> fn_get_employee_fullname;</span><br></pre></td></tr></table></figure>

<p><strong>查看列表:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库中所有的存储过程和函数</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> STATUS <span class="keyword">WHERE</span> Db <span class="operator">=</span> <span class="string">&#x27;your_database_name&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FUNCTION</span> STATUS <span class="keyword">WHERE</span> Db <span class="operator">=</span> <span class="string">&#x27;your_database_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> sp_get_employee_by_dept;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> IF <span class="keyword">EXISTS</span> fn_get_employee_fullname;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-9-7-使用场景与注意事项-缺点"><a href="#1-9-7-使用场景与注意事项-缺点" class="headerlink" title="1.9.7 使用场景与注意事项 (缺点)"></a>1.9.7 使用场景与注意事项 (缺点)</h4><ul>
<li><strong>优点是双刃剑</strong>：虽然将逻辑移到数据库能提升性能，但也会<strong>增加数据库服务器的 CPU 负载</strong>。</li>
<li><strong>可移植性差</strong>：存储过程和函数的语法在不同数据库（如 MySQL, PostgreSQL, Oracle）之间存在很大差异，如果未来需要迁移数据库，成本会很高。</li>
<li><strong>调试困难</strong>：相比于现代应用层的开发语言，数据库存储过程的调试工具通常比较原始，排查问题相对困难。</li>
<li><strong>版本控制</strong>：存储过程和函数的代码通常不方便像应用代码一样纳入 Git 等版本控制系统进行管理。</li>
</ul>
<p><strong>结论</strong>：在决定是否使用存储过程&#x2F;函数时，需要权衡其带来的性能和安全优势与可维护性、可移植性等方面的挑战。一般用于<strong>性能要求极高</strong>、<strong>逻辑相对固定</strong>或<strong>需要强制安全策略</strong>的场景。</p>
<hr>
<h3 id="1-10-触发器-Trigger"><a href="#1-10-触发器-Trigger" class="headerlink" title="1.10 触发器(Trigger)"></a>1.10 触发器(Trigger)</h3><h4 id="1-10-1-什么是触发器？"><a href="#1-10-1-什么是触发器？" class="headerlink" title="1.10.1 什么是触发器？"></a>1.10.1 什么是触发器？</h4><p>触发器（Trigger）是与表关联的、特殊类型的存储过程。它不像普通存储过程那样需要手动 <code>CALL</code> 来执行，而是由数据库在特定事件发生时<strong>自动</strong>、<strong>隐式地</strong>调用。可以把它想象成一个设置在表上的“事件监听器”或“自动化规则”。当满足预设条件时（例如，向表中插入一行数据），它就会自动执行预定义的一系列操作。</p>
<hr>
<h4 id="1-10-2-触发器的三大核心要素"><a href="#1-10-2-触发器的三大核心要素" class="headerlink" title="1.10.2 触发器的三大核心要素"></a>1.10.2 触发器的三大核心要素</h4><p>每个触发器都由三个主要部分定义：</p>
<ol>
<li><strong>事件 (Event)</strong>：什么操作会“触发”它？<ul>
<li><code>INSERT</code>: 当向表中插入新行时。</li>
<li><code>UPDATE</code>: 当表中的某行被更新时。</li>
<li><code>DELETE</code>: 当从表中删除某行时。</li>
</ul>
</li>
<li><strong>时机 (Timing)</strong>：触发器在事件发生之前还是之后执行？<ul>
<li><code>BEFORE</code>: 在事件实际执行<strong>之前</strong>触发。这允许你检查或修改即将要写入的数据，甚至可以阻止该操作的发生。</li>
<li><code>AFTER</code>: 在事件已经成功执行<strong>之后</strong>触发。这通常用于记录操作日志、更新其他相关的表等后续处理。</li>
</ul>
</li>
<li><strong>操作 (Action)</strong>：触发器被激活时，具体执行什么 SQL 代码？<ul>
<li>这是一段 <code>BEGIN ... END</code> 代码块，里面可以包含多条 SQL 语句，实现你想要的逻辑。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-10-3-NEW-和-OLD-伪行"><a href="#1-10-3-NEW-和-OLD-伪行" class="headerlink" title="1.10.3 NEW 和 OLD 伪行"></a>1.10.3 <code>NEW</code> 和 <code>OLD</code> 伪行</h4><p>在触发器的操作代码块中，你可以使用两个特殊的关键字 <code>NEW</code> 和 <code>OLD</code> 来访问受事件影响的行数据。它们被称为“伪行”（Pseudo-rows）。</p>
<ul>
<li><code>OLD</code>: 代表操作<strong>前</strong>的行数据。<ul>
<li>在 <code>UPDATE</code> 事件中，<code>OLD</code> 包含了被修改<strong>之前</strong>的字段值。</li>
<li>在 <code>DELETE</code> 事件中，<code>OLD</code> 包含了被删除的那一行的所有数据。</li>
<li>在 <code>INSERT</code> 事件中不可用，因为插入前没有“旧”数据。</li>
</ul>
</li>
<li><code>NEW</code>: 代表操作<strong>后</strong>的行数据。<ul>
<li>在 <code>INSERT</code> 事件中，<code>NEW</code> 包含了即将被插入的新行的所有数据。</li>
<li>在 <code>UPDATE</code> 事件中，<code>NEW</code> 包含了修改<strong>之后</strong>的新字段值。</li>
<li>在 <code>DELETE</code> 事件中不可用，因为删除后没有“新”数据。</li>
</ul>
</li>
</ul>
<p><strong>使用示例</strong>: <code>NEW.column_name</code> 或 <code>OLD.column_name</code>。</p>
<hr>
<h4 id="1-10-4-经典用例"><a href="#1-10-4-经典用例" class="headerlink" title="1.10.4 经典用例"></a>1.10.4 经典用例</h4><ol>
<li><strong>数据审计与日志记录</strong><ul>
<li><strong>场景</strong>：记录对敏感表（如 <code>salaries</code> 表）的每一次修改，包括谁改的、什么时间、改前是什么值、改后是什么值。</li>
<li><strong>实现</strong>：创建一个 <code>AFTER UPDATE</code> 触发器，将 <code>OLD</code> 和 <code>NEW</code> 的值以及当前用户、时间等信息插入到一个审计日志表中。</li>
</ul>
</li>
<li><strong>强制复杂的业务规则与数据校验</strong><ul>
<li><strong>场景</strong>：业务规定，员工的工资只能增加，不能减少。标准的 <code>CHECK</code> 约束无法实现这种前后状态的比较。</li>
<li><strong>实现</strong>：创建一个 <code>BEFORE UPDATE</code> 触发器，在触发器内部判断 <code>IF NEW.salary &lt; OLD.salary THEN ...</code>，如果条件成立，则使用 <code>SIGNAL</code> 语句主动抛出错误，阻止本次 <code>UPDATE</code> 操作。</li>
</ul>
</li>
<li><strong>维护衍生数据或数据同步 (反范式设计)</strong><ul>
<li><strong>场景</strong>：有一个 <code>orders</code> 表和一个 <code>customers</code> 表，<code>customers</code> 表中有一个 <code>total_spent</code> 字段，用于记录该客户的总消费金额。</li>
<li><strong>实现</strong>：在 <code>orders</code> 表上创建一个 <code>AFTER INSERT</code> 触发器。每当一个新订单被插入时，触发器会自动将订单金额累加到 <code>customers</code> 表中对应客户的 <code>total_spent</code> 字段上。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-10-5-语法与完整示例"><a href="#1-10-5-语法与完整示例" class="headerlink" title="1.10.5 语法与完整示例"></a>1.10.5 语法与完整示例</h4><p><strong>场景</strong>：为 <code>employees</code> 表创建一个审计日志，记录每次薪资变动。</p>
<p><strong>第一步：创建审计日志表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> employee_salary_audit (</span><br><span class="line">    audit_id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    employee_id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    old_salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    new_salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    changed_by <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    changed_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>第二步：创建触发器</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 临时修改结束符</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trg_after_employee_salary_update</span><br><span class="line">AF TER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> employees <span class="comment">-- 时机：之后；事件：更新；关联表：employees</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span>    <span class="comment">-- 这是一个行级触发器，对每一行受影响的数据都会执行一次</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 只有当薪水字段发生变化时才记录日志</span></span><br><span class="line">    IF OLD.salary <span class="operator">&lt;&gt;</span> NEW.salary <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">INSERT INTO</span> employee_salary_audit (</span><br><span class="line">            employee_id, </span><br><span class="line">            old_salary, </span><br><span class="line">            new_salary, </span><br><span class="line">            changed_by</span><br><span class="line">        ) </span><br><span class="line">        <span class="keyword">VALUES</span> (</span><br><span class="line">            OLD.employee_id,  <span class="comment">-- 员工ID (用 OLD 或 NEW 都可以)</span></span><br><span class="line">            OLD.salary,       <span class="comment">-- 旧薪水</span></span><br><span class="line">            NEW.salary,       <span class="comment">-- 新薪水</span></span><br><span class="line">            <span class="keyword">USER</span>()            <span class="comment">-- 内置函数，获取当前执行操作的用户名</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 恢复结束符</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：测试触发器</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设员工 101 的当前薪水是 17000</span></span><br><span class="line"><span class="comment">-- 执行一个薪资更新操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">18000</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看审计日志表，会发现多了一条记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee_salary_audit;</span><br></pre></td></tr></table></figure>

<p>查询结果会显示员工 101 的薪水从 17000 变为了 18000，以及操作人和时间。</p>
<hr>
<h4 id="1-10-6-触发器的管理"><a href="#1-10-6-触发器的管理" class="headerlink" title="1.10.6 触发器的管理"></a>1.10.6 触发器的管理</h4><ul>
<li><p><strong>查看所有触发器</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看特定触发器的创建语句</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除触发器</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [IF <span class="keyword">EXISTS</span>] trigger_name;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-10-7-注意事项"><a href="#1-10-7-注意事项" class="headerlink" title="1.10.7 注意事项"></a>1.10.7 注意事项</h4><p>触发器是一把双刃剑，功能强大，但也极易被滥用，带来灾难性后果。</p>
<ol>
<li><strong>性能开销</strong>：每次对表进行 DML 操作都会额外执行触发器的代码。如果触发器逻辑复杂或涉及多表查询，会严重影响主操作的性能，使其响应变慢。</li>
<li><strong>隐藏的业务逻辑</strong>：业务逻辑被隐藏在数据库底层，应用程序开发者可能完全不知道它的存在。这会导致调试极其困难，当出现意外的数据问题时，很难定位到是触发器导致的。</li>
<li><strong>复杂性与可维护性</strong>：触发器可以调用触发器（级联触发），形成复杂的调用链。这会使系统行为变得难以预测和维护。</li>
<li><strong>事务性</strong>：触发器内的所有操作都包含在触发它的 DML 语句所在的事务中。如果触发器失败，整个原始操作（<code>INSERT</code>&#x2F;<code>UPDATE</code>&#x2F;<code>DELETE</code>）也会回滚。</li>
</ol>
<p><strong>最佳实践</strong>：</p>
<ul>
<li><strong>优先考虑在应用层实现业务逻辑</strong>。这是最清晰、最易于维护和扩展的方式。</li>
<li><strong>仅在万不得已时使用触发器</strong>，比如：<ul>
<li>需要强制执行一个无论通过何种途径（应用A、应用B、数据库客户端）修改数据都必须遵守的底层规则。</li>
<li>为了实现对旧系统或第三方系统的数据变更进行审计，而你无法修改这些系统的代码。</li>
</ul>
</li>
<li><strong>保持触发器逻辑的极度简单</strong>。最好只做一些简单的记录或校验，避免复杂的查询和跨表更新。</li>
</ul>
<hr>
<h2 id="2-索引-The-Index"><a href="#2-索引-The-Index" class="headerlink" title="2. 索引 (The Index)"></a>2. 索引 (The Index)</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><h4 id="2-1-1-什么是索引"><a href="#2-1-1-什么是索引" class="headerlink" title="2.1.1 什么是索引"></a>2.1.1 什么是索引</h4><p>索引（Index）是帮助数据库管理系统<strong>高效获取数据的数据结构</strong>。</p>
<ul>
<li><strong>工作原理</strong>：数据库将原本无序存储的数据列进行<strong>排序</strong>，并存储“<strong>值 + 对应数据行的指针</strong>”。</li>
<li><strong>核心作用</strong>：当查询条件命中索引时，数据库可直接通过算法（如二分查找）定位数据，从而避免低效的<strong>全表扫描（Full Table Scan）</strong>，将检索效率提升数个数量级。</li>
</ul>
<hr>
<h4 id="2-1-2-为什么需要索引"><a href="#2-1-2-为什么需要索引" class="headerlink" title="2.1.2 为什么需要索引"></a>2.1.2 为什么需要索引</h4><p>核心目的是<strong>解决海量数据下的查询性能瓶颈</strong>。</p>
<ul>
<li><strong>空间换时间</strong>：这是索引的本质。通过牺牲少量的磁盘存储空间，换取极大的查询时间缩减。</li>
<li><strong>减少 I&#x2F;O 开销</strong>：数据库的性能瓶颈通常在磁盘 I&#x2F;O，索引能大幅减少读取磁盘的次数。</li>
</ul>
<hr>
<h4 id="2-1-3-索引优缺点"><a href="#2-1-3-索引优缺点" class="headerlink" title="2.1.3 索引优缺点"></a>2.1.3 索引优缺点</h4><p><strong>优点 (Pros):</strong></p>
<ol>
<li><strong>检索快（核心）</strong>：将查询的时间复杂度从 $O(N)$ 降至 $O(log⁡N)$，极大提升查询速度。</li>
<li><strong>排序&#x2F;分组快</strong>：索引本身是有序的，利用此特性可直接满足 <code>ORDER BY</code> 和 <code>GROUP BY</code> 需求，避免消耗 CPU 进行临时排序。</li>
<li><strong>连接快</strong>：加速多表 <code>JOIN</code> 操作时的匹配速度。</li>
<li><strong>数据约束</strong>：通过<strong>唯一索引</strong>，可以在数据库层面保证数据的唯一性。</li>
</ol>
<p><strong>缺点 (Cons):</strong></p>
<ol>
<li><strong>占用空间</strong>：索引文件需要占据物理磁盘空间（数据量越大，索引越占地）。</li>
<li><strong>降低写入性能</strong>：进行 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作时，数据库不仅要修改数据，还要同步维护和调整索引结构，导致写操作变慢。</li>
<li><strong>维护成本</strong>：随着数据量的增加，构建和维护索引的时间成本也会增加。</li>
</ol>
<hr>
<h3 id="2-2-底层数据结构"><a href="#2-2-底层数据结构" class="headerlink" title="2.2 底层数据结构"></a>2.2 底层数据结构</h3><p>在 MySQL 的 <strong>InnoDB</strong> 存储引擎中，索引最核心的数据结构是 <strong>B+树 (B+ Tree)</strong>。</p>
<h4 id="2-2-1-为什么选择-B-树？"><a href="#2-2-1-为什么选择-B-树？" class="headerlink" title="2.2.1 为什么选择 B+ 树？"></a>2.2.1 为什么选择 B+ 树？</h4><ul>
<li><strong>哈希表 (Hash Table)</strong>：<ul>
<li><strong>特点</strong>：等值查询（<code>=</code>）极快，$O(1)$。</li>
<li><strong>致命伤</strong>：<strong>不支持范围查询</strong>（<code>&gt;</code>, <code>&lt;</code>, <code>BETWEEN</code>）。哈希值是无序的，范围查询会导致全表扫描。</li>
</ul>
</li>
<li><strong>有序数组 (Sorted Array)</strong>：<ul>
<li><strong>特点</strong>：支持二分查找，查询效率高。</li>
<li><strong>致命伤</strong>：<strong>写操作成本太高</strong>。插入中间位置需要移动大量元素（$O(N)$），仅适合静态数据。</li>
</ul>
</li>
<li><strong>二叉查找树 (BST) &#x2F; 平衡二叉树 (AVL&#x2F;红黑树)</strong><ul>
<li><strong>特点</strong>：逻辑上查询效率为 $O(logN)$。</li>
<li><strong>致命伤</strong>：<strong>树的高度太高</strong>。每个节点只存两个子节点，导致树变得“瘦高”。</li>
<li><strong>瓶颈</strong>：数据库数据存储在磁盘，访问一个节点 &#x3D; 一次 I&#x2F;O。树越高，I&#x2F;O 次数越多，性能越差。</li>
</ul>
</li>
</ul>
<p><strong>结论</strong>：数据库需要一种**“矮胖”**的树，即每个节点能存很多数据（多叉树），从而将树的高度压低（通常 3-4 层），这就是 B+ 树。</p>
<hr>
<h4 id="2-2-2-B-树-B-Tree"><a href="#2-2-2-B-树-B-Tree" class="headerlink" title="2.2.2 B-树 (B-Tree)"></a>2.2.2 B-树 (B-Tree)</h4><p><em>注：B-Tree 读作 B Tree，中间的杠是连接符，不要与 Binary Tree 混淆，这里的 B 代表 Balance。</em></p>
<ul>
<li><strong>结构</strong>：多路平衡查找树。</li>
<li><strong>特点</strong>：每个节点（包括根、内部、叶子）<strong>既存索引键（Key），也存真实数据（Data）</strong>。</li>
<li><strong>局限</strong>：因为节点要存 Data，导致每个页能存的 Key 变少，树的高度相对 B+ 树更高，I&#x2F;O 次数更多。</li>
</ul>
<hr>
<h4 id="2-2-3-B-树-B-Tree"><a href="#2-2-3-B-树-B-Tree" class="headerlink" title="2.2.3 B+树 (B+ Tree)"></a>2.2.3 B+树 (B+ Tree)</h4><p>B+ 树是 B- 树的变种，专为磁盘存储优化。</p>
<p><strong>核心特征（与 B- 树的区别）：</strong></p>
<ol>
<li><strong>非叶子节点只存 Key，不存 Data</strong>：<ul>
<li><strong>优势</strong>：节点空间利用率更高，能容纳更多 Key，让树变得更“矮胖”，极大减少 I&#x2F;O。</li>
</ul>
</li>
<li><strong>所有 Data 都存储在叶子节点</strong>：<ul>
<li><strong>优势</strong>：查询稳定性高（所有查询都要走到叶子），且便于管理。</li>
</ul>
</li>
<li><strong>叶子节点通过双向链表连接</strong>：<ul>
<li><strong>优势</strong>：<strong>范围查询无敌</strong>。定位到起点后，只需顺着链表遍历即可，无需回溯树结构。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-2-4-B-树的数据组织方法"><a href="#2-2-4-B-树的数据组织方法" class="headerlink" title="2.2.4 B+ 树的数据组织方法"></a>2.2.4 B+ 树的数据组织方法</h4><p>InnoDB 以 <strong>页 (Page)</strong> 为单位管理存储（默认 16KB）。</p>
<h5 id="1-节点类型"><a href="#1-节点类型" class="headerlink" title="1. 节点类型"></a>1. 节点类型</h5><ul>
<li><strong>内部节点 (Index Page)</strong>：<ul>
<li><strong>存储内容</strong>：索引键（<strong>Key</strong>）+ 指向下一层节点的指针（<strong>Pointer</strong>）。</li>
<li>作用是“路标”，引导查询路径。</li>
</ul>
</li>
<li><strong>叶子节点 (Data Page)</strong>：<ul>
<li><strong>存储内容</strong>： 索引键（<strong>Key</strong>）+ <strong>完整的行数据</strong>（对于主键索引）&#x2F; <strong>主键值</strong>（对于二级索引）。</li>
<li>作用是存储真实数据，并通过双向链表串联。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-整体结构图"><a href="#2-整体结构图" class="headerlink" title="2. 整体结构图"></a>2. 整体结构图</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                          +-----------------------------------------+</span><br><span class="line">                          |                 Root Page               |  (内部节点)</span><br><span class="line">                          |    (Key: 50, P1)   (Key: 100, P2)       |</span><br><span class="line">                          +-----------------------------------------+</span><br><span class="line">                                 /                           \</span><br><span class="line">                                /                             \</span><br><span class="line">           +-------------------------+                     +-------------------------+</span><br><span class="line">           |      Internal Page 1    |                     |      Internal Page 2    | (内部节点)</span><br><span class="line">           | (10, P3) (25, P4)       |                     | (120, P5) (150, P6)     |</span><br><span class="line">           +-------------------------+                     +-------------------------+</span><br><span class="line">                 /          \                                      /          \</span><br><span class="line">                /            \                                    /            \</span><br><span class="line">+----------------+  &lt;--&gt;  +----------------+  &lt;--&gt;  +----------------+  &lt;--&gt;  +----------------+</span><br><span class="line">| Leaf Page 3    |        | Leaf Page 4    |        | Leaf Page 5    |        | Leaf Page 6    | (叶子节点)</span><br><span class="line">| (1, data...)   |        | (25, data...)  |        | (120, data...) |        | (150, data...) |</span><br><span class="line">| (5, data...)   |        | (30, data...)  |        | (135, data...) |        | (160, data...) |</span><br><span class="line">+----------------+        +----------------+        +----------------+        +----------------+</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查找过程</strong>：例如查找键值为 <code>30</code> 的记录。<ol>
<li>从 <strong>Root Page</strong> 开始，<code>30</code> 小于 <code>50</code>，所以访问指针 <code>P1</code> 指向的 <strong>Internal Page 1</strong>。</li>
<li>在 <strong>Internal Page 1</strong> 中，<code>30</code> 大于等于 <code>25</code>，所以访问指针 <code>P4</code> 指向的 <strong>Leaf Page 4</strong>。</li>
<li>在 <strong>Leaf Page 4</strong> 中，通过二分查找（页内记录是有序的）找到键为 <code>30</code> 的记录及其完整的行数据。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="3-两类索引的物理存储"><a href="#3-两类索引的物理存储" class="headerlink" title="3. 两类索引的物理存储"></a>3. 两类索引的物理存储</h5><ul>
<li><strong>聚簇索引 (Clustered Index)</strong>：<ul>
<li>通常是<strong>主键索引</strong>。</li>
<li>叶子节点存储：<strong>主键 + 完整的行数据</strong>。</li>
<li>一张表<strong>只能有一个</strong>聚簇索引。</li>
</ul>
</li>
<li><strong>二级索引 (Secondary Index &#x2F; 非聚簇索引)</strong>：<ul>
<li>叶子节点存储：<strong>索引列的值 + 主键值</strong>。</li>
<li><strong>回表 (Backing to table)</strong>：查二级索引拿到主键 -&gt; 再去聚簇索引查完整数据。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-5-页分裂（Page-Split）"><a href="#2-2-5-页分裂（Page-Split）" class="headerlink" title="2.2.5 页分裂（Page Split）"></a>2.2.5 页分裂（Page Split）</h4><p><strong>定义</strong>：向已满的叶子节点插入新数据时，为维持 B+ 树平衡而触发的操作。</p>
<p><strong>场景设想</strong>：</p>
<ul>
<li><strong>约束</strong>：单页最大记录数为 4。</li>
<li><strong>现状</strong>：<code>Page A</code> 已满，包含 <code>(10, 20, 30, 40)</code>。</li>
<li><strong>操作</strong>：插入新记录 <code>(35)</code>。</li>
</ul>
<h5 id="1-分裂前状态"><a href="#1-分裂前状态" class="headerlink" title="1. 分裂前状态"></a>1. 分裂前状态</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Parent Node</span><br><span class="line">[ ... Key: 50, Ptr -&gt; Page A ... ]</span><br><span class="line">            |</span><br><span class="line">   +-----------------+</span><br><span class="line">   |     Page A      | (已满)</span><br><span class="line">   | 10, 20, 30, 40  |</span><br><span class="line">   +-----------------+</span><br></pre></td></tr></table></figure>

<h5 id="2-执行步骤"><a href="#2-执行步骤" class="headerlink" title="2. 执行步骤"></a>2. 执行步骤</h5><ol>
<li><strong>创建新页</strong>：分配一个新的叶子节点 <code>Page B</code>。</li>
<li><strong>数据迁移与插入</strong>：<ul>
<li>将 <code>Page A</code> 后半部分数据迁移至 <code>Page B</code>。</li>
<li>将新记录 <code>(35)</code> 按顺序插入对应页面。</li>
<li><strong>结果</strong>：<code>Page A</code> 留存 <code>(10, 20)</code>；<code>Page B</code> 持有 <code>(30, 35, 40)</code>。</li>
</ul>
</li>
<li><strong>更新链表</strong>：将 <code>Page B</code> 插入 <code>Page A</code> 之后，维持双向链表结构 (<code>Page A &lt;-&gt; Page B</code>)。</li>
<li><strong>索引上报</strong>：将 <code>Page B</code> 的最小键值 <code>(30)</code> 及页指针作为新索引项，插入 <strong>父节点</strong>。</li>
</ol>
<h5 id="3-分裂后状态"><a href="#3-分裂后状态" class="headerlink" title="3. 分裂后状态"></a>3. 分裂后状态</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">               Parent Node (更新)</span><br><span class="line">[ ... (Key: 30, Ptr -&gt; B), (Key: 50, Ptr -&gt; A) ... ]</span><br><span class="line">         /                 \</span><br><span class="line"> +----------------+   +----------------+</span><br><span class="line"> |     Page A     |   |     Page B     |</span><br><span class="line"> | 10, 20         |   | 30, 35, 40     |</span><br><span class="line"> +----------------+   +----------------+</span><br></pre></td></tr></table></figure>

<h5 id="4-连锁反应（向上传播）"><a href="#4-连锁反应（向上传播）" class="headerlink" title="4. 连锁反应（向上传播）"></a>4. 连锁反应（向上传播）</h5><p>若父节点插入新索引项后也已满，则父节点触发分裂。此过程可递归至根节点。<strong>最坏情况</strong>：根节点分裂，树的高度 +1。</p>
<hr>
<h4 id="2-2-6-页合并（Page-Merge）"><a href="#2-2-6-页合并（Page-Merge）" class="headerlink" title="2.2.6 页合并（Page Merge）"></a>2.2.6 页合并（Page Merge）</h4><p><strong>定义</strong>：删除数据导致节点填充率低于阈值（通常为 50%）时，为优化空间利用率而触发的操作。</p>
<p><strong>场景设想</strong>：</p>
<ul>
<li><strong>约束</strong>：合并阈值 50%。</li>
<li><strong>现状</strong>：删除数据后，<code>Page B</code> 填充率不足。</li>
</ul>
<h5 id="1-合并前状态"><a href="#1-合并前状态" class="headerlink" title="1. 合并前状态"></a>1. 合并前状态</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              Parent Node</span><br><span class="line">[ ... (Key: 30, Ptr -&gt; B), (Key: 50, Ptr -&gt; A) ... ]</span><br><span class="line">         /                 \</span><br><span class="line"> +----------------+   +----------------+</span><br><span class="line"> |     Page A     |   |     Page B     |</span><br><span class="line"> | 10, 20         |   | 30 (数据过少)   |</span><br><span class="line"> +----------------+   +----------------+</span><br></pre></td></tr></table></figure>

<h5 id="2-执行步骤-1"><a href="#2-执行步骤-1" class="headerlink" title="2. 执行步骤"></a>2. 执行步骤</h5><ol>
<li><strong>定位兄弟节点</strong>：锁定相邻节点（如左兄弟 <code>Page A</code>）。</li>
<li><strong>容量校验</strong>：判断 <code>Page A</code> 数据量 + <code>Page B</code> 数据量是否 &lt;&#x3D; 单页容量。</li>
<li><strong>执行合并</strong>（若校验通过）：<ul>
<li>将 <code>Page B</code> 所有数据迁移至 <code>Page A</code>。</li>
<li>更新双向链表，剔除 <code>Page B</code>。</li>
<li>释放 <code>Page B</code> 空间。</li>
</ul>
</li>
<li><strong>更新父节点</strong>：删除父节点中指向 <code>Page B</code> 的索引项 <code>(Key: 30)</code>。</li>
</ol>
<h5 id="3-合并后状态"><a href="#3-合并后状态" class="headerlink" title="3. 合并后状态"></a>3. 合并后状态</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          Parent Node (更新)</span><br><span class="line">[ ... Key: 50, Ptr -&gt; Page A ... ]</span><br><span class="line">            |</span><br><span class="line">   +-----------------+</span><br><span class="line">   |     Page A      | (已合并)</span><br><span class="line">   | 10, 20, 30      |</span><br><span class="line">   +-----------------+</span><br></pre></td></tr></table></figure>

<h5 id="4-特殊情况处理"><a href="#4-特殊情况处理" class="headerlink" title="4. 特殊情况处理"></a>4. 特殊情况处理</h5><ul>
<li><strong>连锁反应</strong>：父节点删除索引项后若填充率过低，将触发父节点的合并，直至根节点。若根节点仅剩一个子节点，树的高度 -1。</li>
<li><strong>再平衡（Rebalancing）</strong>：若兄弟节点数据过多无法合并，则执行“借位”操作（旋转），从兄弟节点移动部分数据以平衡填充率，避免频繁的合并与分裂。</li>
</ul>
<hr>
<h4 id="2-2-7-总结：B-树-vs-B-树"><a href="#2-2-7-总结：B-树-vs-B-树" class="headerlink" title="2.2.7 总结：B+ 树 vs B- 树"></a>2.2.7 总结：B+ 树 vs B- 树</h4><table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">B- 树 (B-Tree)</th>
<th align="left">B+ 树 (B+ Tree)</th>
<th align="left">核心差异点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据存储</strong></td>
<td align="left">所有节点存 Data</td>
<td align="left"><strong>仅叶子节点</strong>存 Data</td>
<td align="left">B+ 树更矮胖，I&#x2F;O 更少</td>
</tr>
<tr>
<td align="left"><strong>查询性能</strong></td>
<td align="left">不稳定 (可能在根节点找到)</td>
<td align="left"><strong>稳定</strong> (必须走到叶子)</td>
<td align="left">B+ 树查询时间可控</td>
</tr>
<tr>
<td align="left"><strong>范围查询</strong></td>
<td align="left">慢 (需中序遍历回溯)</td>
<td align="left"><strong>极快</strong> (叶子双向链表)</td>
<td align="left">数据库最看重的特性</td>
</tr>
<tr>
<td align="left"><strong>全表扫描</strong></td>
<td align="left">慢 (需遍历整棵树)</td>
<td align="left"><strong>快</strong> (遍历叶子链表)</td>
<td align="left">适合批量处理</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-3-索引类型与原理"><a href="#2-3-索引类型与原理" class="headerlink" title="2.3 索引类型与原理"></a>2.3 索引类型与原理</h3><h4 id="2-3-1-按物理存储划分"><a href="#2-3-1-按物理存储划分" class="headerlink" title="2.3.1 按物理存储划分"></a>2.3.1 按物理存储划分</h4><p>上一节中简单介绍了在 InnoDB 存储引擎中，索引根据其物理存储方式分为两大类：<strong>聚簇索引</strong>和<strong>二级索引</strong>。</p>
<h5 id="1-聚簇索引-Clustered-Index"><a href="#1-聚簇索引-Clustered-Index" class="headerlink" title="1. 聚簇索引 (Clustered Index)"></a>1. 聚簇索引 (Clustered Index)</h5><ul>
<li><strong>本质</strong>：它<strong>不是</strong>一种单独的索引类型，而是一种<strong>数据存储方式</strong>。它决定了表数据在磁盘上的物理排列顺序。</li>
<li><strong>结构</strong>：B+ 树的<strong>叶子节点存储完整的用户数据行</strong>。</li>
<li><strong>特征</strong>：<ul>
<li><strong>唯一性</strong>：一张表<strong>只能有一个</strong>聚簇索引（物理存储顺序只能有一种）。</li>
<li><strong>默认规则</strong>：<ol>
<li>优先使用<strong>主键</strong> (<code>PRIMARY KEY</code>)。</li>
<li>无主键时，使用第一个 <code>UNIQUE NOT NULL</code> 索引。</li>
<li>都无时，InnoDB 自动创建一个名为 <code>GEN_CLUST_INDEX</code> 的 6 字节的隐藏列 <code>ROW_ID</code>。</li>
</ol>
</li>
</ul>
</li>
<li><strong>优缺点</strong>：<ul>
<li><strong>查询极快</strong>：找到索引就找到了数据，无需二次查找。</li>
<li><strong>范围查询强</strong>：数据物理连续，适合 <code>BETWEEN</code> 等操作。</li>
<li><strong>写入代价大</strong>：若主键无序（如 UUID），会导致频繁的页分裂和磁盘移动。<strong>建议使用自增 ID</strong>。</li>
</ul>
</li>
</ul>
<h5 id="2-二级索引-Secondary-Index-非聚簇索引"><a href="#2-二级索引-Secondary-Index-非聚簇索引" class="headerlink" title="2. 二级索引 (Secondary Index &#x2F; 非聚簇索引)"></a>2. 二级索引 (Secondary Index &#x2F; <strong>非聚簇索引</strong>)</h5><ul>
<li><strong>本质</strong>：除聚簇索引外的所有索引。</li>
<li><strong>结构</strong>：B+ 树的<strong>叶子节点存储：索引列的值 + 主键值</strong>（用于回查数据）。</li>
<li><strong>关键过程：回表 (Backing to Table)</strong><ul>
<li><strong>定义</strong>：先查二级索引拿到主键，再拿着主键去聚簇索引查完整数据。</li>
<li><strong>代价</strong>：<strong>回表 &#x3D; 多扫描一棵 B+ 树</strong>。这是 SQL 优化的主要对象（尽量避免回表）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-2-按逻辑功能划分-应用层面"><a href="#2-3-2-按逻辑功能划分-应用层面" class="headerlink" title="2.3.2 按逻辑功能划分 (应用层面)"></a>2.3.2 按逻辑功能划分 (应用层面)</h4><p>这是我们在 <code>CREATE TABLE</code> 时根据业务需求定义的索引类型。</p>
<table>
<thead>
<tr>
<th align="left">索引类型</th>
<th align="left">关键字</th>
<th align="left">描述</th>
<th align="left">允许 NULL</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>主键索引</strong></td>
<td align="left"><code>PRIMARY KEY</code></td>
<td align="left"><strong>约束最强</strong>。唯一标识，物理上通常是聚簇索引。</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left"><strong>唯一索引</strong></td>
<td align="left"><code>UNIQUE</code></td>
<td align="left">保证列值唯一。</td>
<td align="left">允许</td>
</tr>
<tr>
<td align="left"><strong>普通索引</strong></td>
<td align="left"><code>INDEX</code> &#x2F; <code>KEY</code></td>
<td align="left">无约束，仅为了加速查询。</td>
<td align="left">允许</td>
</tr>
<tr>
<td align="left"><strong>全文索引</strong></td>
<td align="left"><code>FULLTEXT</code></td>
<td align="left">针对大文本的关键词搜索（底层是倒排索引，非 B+ 树）。</td>
<td align="left">允许</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-3-3-按字段数量划分-构建策略"><a href="#2-3-3-按字段数量划分-构建策略" class="headerlink" title="2.3.3 按字段数量划分 (构建策略)"></a>2.3.3 按字段数量划分 (构建策略)</h4><p><strong>1. 单列索引</strong></p>
<ul>
<li>一个索引只包含一个列。</li>
</ul>
<p><strong>2. 组合索引 &#x2F; 联合索引 (Composite Index)</strong></p>
<ul>
<li><strong>定义</strong>：一个索引包含多个列，如 <code>KEY idx_name_age (name, age)</code>。</li>
<li><strong>核心法则：最左前缀原则 (Leftmost Prefix Principle)</strong><ul>
<li><strong>原理</strong>：B+ 树是按照从左到右的顺序建立索引的。先按 <code>name</code> 排序，<code>name</code> 相同才按 <code>age</code> 排序。</li>
<li><strong>生效场景</strong>：<ul>
<li><code>WHERE name = &#39;A&#39;</code> (匹配最左)</li>
<li><code>WHERE name = &#39;A&#39; AND age = 18</code> (全匹配)</li>
</ul>
</li>
<li><strong>失效场景</strong>：<ul>
<li><code>WHERE age = 18</code> (跳过最左列，索引失效，全表扫描)</li>
<li><code>WHERE name = &#39;A&#39; AND address = &#39;X&#39;</code> (只有 name 走索引)</li>
</ul>
</li>
<li><strong>类比</strong>：查字典必须先查首字母。如果你只知道第二个字母，是没法查目录的。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-4-覆盖索引-Covering-Index"><a href="#2-3-4-覆盖索引-Covering-Index" class="headerlink" title="2.3.4 覆盖索引 (Covering Index)"></a>2.3.4 覆盖索引 (Covering Index)</h4><p><strong>覆盖索引不是一种“物理索引”，而是一种“查询状态”。</strong> 它是 SQL 性能优化的最高境界之一。</p>
<ul>
<li><strong>定义</strong>：查询语句中所需的<strong>所有字段</strong>（<code>SELECT</code> + <code>WHERE</code>），都恰好包含在<strong>二级索引</strong>中。</li>
<li><strong>效果</strong>：<strong>无需回表</strong>。</li>
<li><strong>流程对比</strong>：<ul>
<li><strong>非覆盖索引</strong>：查二级索引 -&gt; 拿主键 -&gt; <strong>查聚簇索引 (回表)</strong> -&gt; 拿数据。</li>
<li><strong>覆盖索引</strong>：查二级索引 -&gt; <strong>直接拿数据 (完成)</strong>。</li>
</ul>
</li>
<li><strong>实战案例</strong>：<ul>
<li>索引：<code>idx_name_age (name, age)</code></li>
<li>查询：<code>SELECT age FROM users WHERE name = &#39;Alice&#39;;</code></li>
<li><strong>分析</strong>：我们要查 <code>age</code>，条件是 <code>name</code>。这两个字段都在索引树上，数据库不需要去聚簇索引翻原始行数据，性能极高。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-4-索引失效"><a href="#2-4-索引失效" class="headerlink" title="2.4 索引失效"></a>2.4 索引失效</h3><p><strong>核心定义</strong>：索引失效并非指索引损坏，而是指 MySQL 优化器（Optimizer）基于<strong>成本模型（Cost Model）评估后，认为全表扫描（Full Table Scan）的成本低于索引扫描（Index Scan）</strong>，从而放弃使用索引。</p>
<p><strong>前置环境</strong>：</p>
<p>假设表 <code>users</code> 存在组合索引 <code>idx_name_age_status (name, age, status)</code>。</p>
<ul>
<li><strong>索引结构</strong>：先按 <code>name</code> 排序，<code>name</code> 相同按 <code>age</code> 排序，依次类推。</li>
</ul>
<h4 id="2-4-1-违反最左前缀原则"><a href="#2-4-1-违反最左前缀原则" class="headerlink" title="2.4.1 违反最左前缀原则"></a>2.4.1 违反最左前缀原则</h4><p>B+ 树的有序性是建立在从左到右的列顺序之上的。跳过前导列，后续列即为无序状态。</p>
<ul>
<li><strong>有效场景</strong>：<ul>
<li>完整匹配：<code>WHERE name=&#39;A&#39; AND age=20 AND status=1</code></li>
<li>部分匹配（前缀）：<code>WHERE name=&#39;A&#39; AND age=20</code> 或 <code>WHERE name=&#39;A&#39;</code></li>
</ul>
</li>
<li><strong>失效场景</strong>：<ul>
<li><strong>跳过首列</strong>：<code>WHERE age=20</code>（<code>name</code> 未知，<code>age</code> 全局无序，必须全表扫描）。</li>
<li><strong>跳过中间列</strong>：<code>WHERE name=&#39;A&#39; AND status=1</code>（索引仅在 <code>name</code> 处生效，<code>status</code> 无法利用索引查找，因为在 <code>name</code> 确定的情况下，跳过 <code>age</code>，<code>status</code> 是无序的）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-4-2-索引列“不纯”"><a href="#2-4-2-索引列“不纯”" class="headerlink" title="2.4.2 索引列“不纯”"></a>2.4.2 索引列“不纯”</h4><p>索引存储的是列的<strong>原始值</strong>。若在索引列上进行任何运算，B+ 树中存储的值将无法与查询条件直接匹配。</p>
<ul>
<li><strong>失效场景</strong>：<ol>
<li><strong>函数计算</strong>：<code>WHERE LEFT(name, 3) = &#39;Ali&#39;</code>（索引存的是全名，不是前3个字符）。</li>
<li><strong>数学运算</strong>：<code>WHERE age - 1 = 19</code>（优化器不支持自动代数变换，应改为 <code>age = 20</code>）。</li>
<li><strong>隐式类型转换</strong>：<code>WHERE name = 123</code>（若 <code>name</code> 为 varchar，数据库隐式执行 <code>CAST(name AS signed)</code>，等同于函数计算）。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-4-3-模糊查询通配符前置"><a href="#2-4-3-模糊查询通配符前置" class="headerlink" title="2.4.3 模糊查询通配符前置"></a>2.4.3 模糊查询通配符前置</h4><ul>
<li><strong>有效场景</strong>：<code>WHERE name LIKE &#39;Ali%&#39;</code>（前缀固定，可利用 B+ 树定位范围）。</li>
<li><strong>失效场景</strong>：<code>WHERE name LIKE &#39;%ice&#39;</code> 或 <code>%lic%</code>。</li>
<li><strong>原因</strong>：B+ 树的查找依赖从左开始的字符匹配。首字符不确定，无法定位索引树的起始位置。</li>
</ul>
<hr>
<h4 id="2-4-4-逻辑-OR-连接"><a href="#2-4-4-逻辑-OR-连接" class="headerlink" title="2.4.4 逻辑 OR 连接"></a>2.4.4 逻辑 <code>OR</code> 连接</h4><ul>
<li><strong>失效条件</strong>：<code>OR</code> 两边的条件列，只要有<strong>任意一列</strong>没有索引，索引即失效。</li>
<li><strong>原因</strong>：<ul>
<li>查询 <code>A or B</code>。即使 <code>A</code> 能走索引，但 <code>B</code> 无索引需全表扫描。既然必须扫描全表来获取 <code>B</code> 的数据，优化器通常会选择直接扫描全表以避免两次 I&#x2F;O 开销。</li>
</ul>
</li>
<li><strong>特例</strong>：若两边都有索引，MySQL 5.0+ 可能触发 <strong>Index Merge</strong>（索引合并），但并不保证发生。</li>
</ul>
<hr>
<h4 id="2-4-5-低选择性操作"><a href="#2-4-5-低选择性操作" class="headerlink" title="2.4.5 低选择性操作"></a>2.4.5 低选择性操作</h4><p>包括 <code>!=</code>, <code>&lt;&gt;</code>, <code>NOT IN</code>, <code>NOT EXISTS</code> 等否定查询。</p>
<ul>
<li><strong>逻辑</strong>：优化器评估认为，否定条件返回的结果集通常很大（例如全表的 90%）。</li>
<li><strong>成本对比</strong>：<ul>
<li><strong>走索引</strong>：扫描索引树 -&gt; 获取主键 -&gt; <strong>回表</strong>（随机 I&#x2F;O，成本高）。</li>
<li><strong>全表扫描</strong>：顺序读取数据页（顺序 I&#x2F;O，成本低）。</li>
<li><strong>结论</strong>：当回表成本 &gt; 全表扫描成本时，索引失效。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-4-6-数据分布与成本估算"><a href="#2-4-6-数据分布与成本估算" class="headerlink" title="2.4.6 数据分布与成本估算"></a>2.4.6 数据分布与成本估算</h4><p>这是上述所有失效场景的底层逻辑。MySQL 优化器是**基于成本（Cost-Based）**的。</p>
<ul>
<li><strong>表数据量极少</strong>：全表扫描都在内存中瞬间完成，建索引反而增加了维护成本，优化器直接全表扫描。</li>
<li><strong>结果集占比过大</strong>：若 <code>WHERE</code> 条件（即使是 <code>=</code>）筛选出超过一定比例（如 30%）的数据，优化器倾向于放弃索引，避免大量回表操作。</li>
</ul>
<hr>
<h3 id="2-5-设计原则"><a href="#2-5-设计原则" class="headerlink" title="2.5 设计原则"></a>2.5 设计原则</h3><h4 id="2-5-1-核心原则：选择性（Selectivity）"><a href="#2-5-1-核心原则：选择性（Selectivity）" class="headerlink" title="2.5.1 核心原则：选择性（Selectivity）"></a>2.5.1 核心原则：选择性（Selectivity）</h4><p><strong>索引的选择性</strong>是指索引列中不重复值的数量（基数，Cardinality）与表中总行数的比值。比值越接近 1，说明该列的唯一性越好，选择性越高。</p>
<ul>
<li><strong>公式</strong>：<code>Selectivity = Cardinality / Total Rows</code></li>
<li><strong>原则</strong>：<strong>选择性越高的列，越适合创建索引</strong>。</li>
<li><strong>示例</strong>：<ul>
<li><strong>高选择性列（适合）</strong>：<code>user_id</code>、<code>email</code>、<code>id_card</code>。这些列的值几乎都是唯一的，通过索引能快速筛选掉绝大多数无关数据。</li>
<li><strong>低选择性列（不适合）</strong>：<code>gender</code>（性别，通常只有男、女、未知）、<code>status</code>（状态，可能只有几个固定值）。为这些列创建索引，即使使用了索引，也需要扫描大量的数据行，优化效果甚微，优化器很可能会放弃使用。</li>
</ul>
</li>
<li><strong>查询基数</strong>：可以使用 <code>SHOW INDEX FROM table_name;</code> 或 <code>SELECT COUNT(DISTINCT column_name) FROM table_name;</code> 来查看列的基数。</li>
</ul>
<hr>
<h4 id="2-5-2-组合索引的艺术：最左前缀原则的应用"><a href="#2-5-2-组合索引的艺术：最左前缀原则的应用" class="headerlink" title="2.5.2 组合索引的艺术：最左前缀原则的应用"></a>2.5.2 组合索引的艺术：最左前缀原则的应用</h4><p>组合索引是优化的利器，但设计时需要深思熟虑。</p>
<ul>
<li><strong>1. 将选择性高的列放在最左边</strong>：<ul>
<li>在创建组合索引 <code>(col1, col2, ...)</code> 时，应优先将选择性最高的列放在最前面。这样可以最大化地利用索引快速过滤掉大部分数据。</li>
</ul>
</li>
<li><strong>2. 将查询最频繁的列放在最左边</strong>：<ul>
<li>如果多个列的选择性都很高，那么应该将 <code>WHERE</code> 子句中最常用于筛选的列放在前面，以满足更多的查询场景。</li>
</ul>
</li>
<li><strong>3. 考虑排序和分组</strong>：<ul>
<li>如果查询中有 <code>ORDER BY</code> 或 <code>GROUP BY</code> 子句，将这些列加入组合索引，并保持与 <code>WHERE</code> 子句中的列顺序一致，可以利用索引来避免额外的文件排序（<code>filesort</code>）操作，大幅提升性能。</li>
<li>例如，对于查询 <code>SELECT ... FROM ... WHERE name = &#39;Alice&#39; ORDER BY age;</code>，创建 <code>(name, age)</code> 的组合索引会比 <code>(age, name)</code> 更好。</li>
</ul>
</li>
<li><strong>4. 覆盖索引</strong>：<ul>
<li>在设计组合索引时，可以有意识地将查询中 <code>SELECT</code> 的列也包含进来，以实现覆盖索引，避免回表。</li>
<li>例如，对于查询 <code>SELECT id, name, age FROM users WHERE name = &#39;Alice&#39;;</code>，如果经常执行，创建一个 <code>(name, age)</code> 的索引，并将 <code>id</code>（主键）包含进来（虽然主键默认就会在二级索引中），或者直接创建 <code>(name)</code> 索引然后期望回表，不如直接创建一个 <code>(name, age)</code> 的索引，这样查询就可以直接从索引中获取所有需要的数据。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-5-3-避免冗余和重复索引"><a href="#2-5-3-避免冗余和重复索引" class="headerlink" title="2.5.3 避免冗余和重复索引"></a>2.5.3 避免冗余和重复索引</h4><ul>
<li><strong>冗余索引</strong>：<ul>
<li>如果已经有了组合索引 <code>(name, age)</code>，那么再单独创建一个 <code>(name)</code> 索引就是冗余的，因为 <code>(name, age)</code> 已经可以满足对 <code>name</code> 列的索引需求。</li>
<li>主键 <code>(id)</code> 已经是索引了，再创建一个 <code>UNIQUE (id)</code> 也是冗余的。</li>
</ul>
</li>
<li><strong>危害</strong>：冗余索引会占用额外的磁盘空间，并增加数据写入（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>）时的维护成本。</li>
<li><strong>检查</strong>：定期审查数据库中的索引，找出并删除不必要的冗余索引。</li>
</ul>
<hr>
<h4 id="2-5-4-索引并非越多越好（成本与收益的权衡）"><a href="#2-5-4-索引并非越多越好（成本与收益的权衡）" class="headerlink" title="2.5.4 索引并非越多越好（成本与收益的权衡）"></a>2.5.4 索引并非越多越好（成本与收益的权衡）</h4><ul>
<li><strong>写操作成本</strong>：每个额外的索引都会增加数据插入、更新和删除的开销，因为数据库需要同时维护数据表和相关的索引树。</li>
<li><strong>空间成本</strong>：索引本身需要占用磁盘空间。</li>
<li><strong>优化器成本</strong>：过多的索引会增加优化器选择索引的复杂度和时间。在某些情况下，优化器可能会选错索引。</li>
<li><strong>原则</strong>：<strong>只为真正需要提高查询性能的列&#x2F;列组合创建索引</strong>。通常是 <code>WHERE</code>、<code>JOIN</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 子句中频繁使用的列。对于不常查询的列或写操作远多于读操作的表，要谨慎创建索引。</li>
</ul>
<hr>
<h4 id="2-5-5-其他实用原则"><a href="#2-5-5-其他实用原则" class="headerlink" title="2.5.5 其他实用原则"></a>2.5.5 其他实用原则</h4><ul>
<li><strong>使用短索引&#x2F;前缀索引</strong>：<ul>
<li>对于 <code>VARCHAR</code> 或 <code>TEXT</code> 等长字符串列，如果直接创建完整索引，会非常占用空间且效率不高。可以只对字符串的前缀部分创建索引。</li>
<li>语法：<code>CREATE INDEX idx_name_prefix ON users (name(10));</code> 表示只对 <code>name</code> 字段的前 10 个字符创建索引。</li>
<li><strong>权衡</strong>：前缀长度需要仔细选择，既要保证足够的选择性，又要控制索引大小。可以通过 <code>SELECT COUNT(DISTINCT LEFT(column, length)) / COUNT(*) FROM table;</code> 来测试不同长度的选择性。</li>
</ul>
</li>
<li><strong>选择合适的主键</strong>：<ul>
<li>在 InnoDB 中，推荐使用与业务无关的、短小的、单调递增的数值类型（如 <code>INT</code> 或 <code>BIGINT</code> 的 <code>AUTO_INCREMENT</code>）作为主键。</li>
<li><strong>原因</strong>：<ol>
<li><strong>避免页分裂</strong>：自增主键保证了新插入的数据总是在 B+树的末尾，减少了因数据插入导致的页分裂和数据移动。</li>
<li><strong>节省空间</strong>：二级索引的叶子节点存储的是主键值，主键越短，二级索引占用的空间就越小。</li>
</ol>
</li>
</ul>
</li>
<li><strong>定期维护索引</strong>：<ul>
<li>随着数据的增删改，索引可能会产生碎片，导致性能下降。可以使用 <code>OPTIMIZE TABLE table_name;</code> 或 <code>ANALYZE TABLE table_name;</code> 来分析和优化表，重建索引。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-查询性能分析"><a href="#3-查询性能分析" class="headerlink" title="3. 查询性能分析"></a>3. <strong>查询性能分析</strong></h2><h3 id="3-1-执行计划"><a href="#3-1-执行计划" class="headerlink" title="3.1 执行计划"></a>3.1 执行计划</h3><h4 id="3-1-1-概念"><a href="#3-1-1-概念" class="headerlink" title="3.1.1 概念"></a>3.1.1 概念</h4><p>执行计划是数据库的 <strong>查询优化器 (Query Optimizer)</strong> 为一条 SQL 查询语句生成的“执行路线图”。详细描述了数据库为了获取查询结果，决定采用的数据检索方式、表连接顺序、索引使用情况等一系列步骤。</p>
<p>简单来说，当你向数据库发出一条 <code>SELECT</code> 查询时，数据库并不会马上执行。它会先分析多种可能的执行路径，然后选择一个它认为<strong>成本最低、效率最高</strong>的方案，这个方案就是执行计划。</p>
<hr>
<h4 id="3-1-2-获取"><a href="#3-1-2-获取" class="headerlink" title="3.1.2 获取"></a>3.1.2 获取</h4><p>在 MySQL 中，获取执行计划的主要工具是 <code>EXPLAIN</code> 命令。</p>
<p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> emp_no <span class="operator">=</span> <span class="number">10001</span>;</span><br></pre></td></tr></table></figure>

<p>执行后， MySQL 不会返回查询结果，而是返回一个表格，这个表格就是该查询的执行计划。</p>
<hr>
<h4 id="3-1-3-核心列"><a href="#3-1-3-核心列" class="headerlink" title="3.1.3 核心列"></a>3.1.3 核心列</h4><p><code>EXPLAIN</code> 的输出结果包含多个列，理解这些列的含义是分析性能问题的关键。我们重点关注以下几个核心列：</p>
<table>
<thead>
<tr>
<th align="left">列名</th>
<th align="left">含义</th>
<th align="left">关键解读</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>id</code></strong></td>
<td align="left">查询的序列号，标识执行的先后顺序</td>
<td align="left"><code>id</code> 相同，从上到下执行；<code>id</code> 不同，<code>id</code> 值越大，优先级越高，越先执行。</td>
</tr>
<tr>
<td align="left"><strong><code>select_type</code></strong></td>
<td align="left">查询的类型</td>
<td align="left">用于区分是简单查询、联合查询、子查询等。常见值：<code>SIMPLE</code>, <code>PRIMARY</code>, <code>SUBQUERY</code>, <code>UNION</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>table</code></strong></td>
<td align="left">操作的表名</td>
<td align="left">显示这一步正在访问哪个表。</td>
</tr>
<tr>
<td align="left"><strong><code>type</code></strong></td>
<td align="left"><strong>[最重要的列]</strong> 访问类型&#x2F;连接类型</td>
<td align="left">描述了 MySQL 如何查找表中的行。这是<strong>评估查询性能好坏的首要指标</strong>。</td>
</tr>
<tr>
<td align="left"><strong><code>possible_keys</code></strong></td>
<td align="left">可能使用的索引</td>
<td align="left">显示哪些索引可能被用于此查询。</td>
</tr>
<tr>
<td align="left"><strong><code>key</code></strong></td>
<td align="left"><strong>[第二重要的列]</strong> 实际使用的索引</td>
<td align="left">如果为 <code>NULL</code>，则表示没有使用索引，性能通常很差。</td>
</tr>
<tr>
<td align="left"><strong><code>key_len</code></strong></td>
<td align="left">实际使用索引的长度（字节）</td>
<td align="left">长度越短通常越好。可以用来判断联合索引是否被完全利用。</td>
</tr>
<tr>
<td align="left"><strong><code>ref</code></strong></td>
<td align="left">显示哪些列或常量被用于查找索引</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong><code>rows</code></strong></td>
<td align="left"><strong>[第三重要的列]</strong> 预估扫描的行数</td>
<td align="left">这个数值越小越好。它是一个估算值，但能很好地反映查询的开销。</td>
</tr>
<tr>
<td align="left"><strong><code>filtered</code></strong></td>
<td align="left">按表条件过滤的行百分比</td>
<td align="left">（<code>rows</code> × <code>filtered</code> &#x2F; 100）表示将与下一张表连接的行数。</td>
</tr>
<tr>
<td align="left"><strong><code>Extra</code></strong></td>
<td align="left"><strong>[第四重要的列]</strong> 额外的重要信息</td>
<td align="left">包含了很多关键信息，尤其是性能警告。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-4-深入关键指标"><a href="#3-1-4-深入关键指标" class="headerlink" title="3.1.4 深入关键指标"></a>3.1.4 深入关键指标</h4><h5 id="1-type-访问类型（性能好坏的风向标）"><a href="#1-type-访问类型（性能好坏的风向标）" class="headerlink" title="1. type - 访问类型（性能好坏的风向标）"></a>1. <code>type</code> - 访问类型（性能好坏的风向标）</h5><p><code>type</code> 的值从优到劣的顺序如下，我们的目标是让查询的 <code>type</code> 级别尽可能高（靠前）：</p>
<ul>
<li><strong><code>system</code></strong>: 表中只有一行数据，是 <code>const</code> 的特例。性能最佳。</li>
<li><strong><code>const</code></strong>: 通过主键或唯一索引，一次就能找到匹配的行。例如 <code>... WHERE id = 1</code>。</li>
<li><strong><code>eq_ref</code></strong>: 在连接查询中，驱动表（前一张表）的每一行，在被驱动表（后一张表）中都只通过主键或唯一索引匹配到一行。非常高效的连接方式。</li>
<li><strong><code>ref</code></strong>: 非唯一的索引扫描，返回匹配某个单独值的所有行。性能也不错。</li>
<li><strong><code>range</code></strong>: 使用索引进行范围查询。例如 <code>... WHERE id &gt; 100</code> 或 <code>... WHERE age BETWEEN 20 AND 30</code>。</li>
<li><strong><code>index</code></strong>: 全索引扫描。遍历整个索引树来查找数据。比 <code>ALL</code> 快，因为索引通常比表数据小。</li>
<li><strong><code>ALL</code></strong>: <strong>全表扫描 (Full Table Scan)</strong>。这是<strong>最坏的情况</strong>，意味着 MySQL 需要遍历表中的每一行来找到匹配项。必须尽力避免！</li>
</ul>
<p><strong>优化目标：</strong> 至少要达到 <code>range</code> 级别，最好是 <code>ref</code> 或 <code>eq_ref</code>。如果看到 <code>ALL</code>，通常意味着需要添加索引或优化查询逻辑。</p>
<hr>
<h5 id="2-Extra-额外信息（性能问题的警报器）"><a href="#2-Extra-额外信息（性能问题的警报器）" class="headerlink" title="2. Extra - 额外信息（性能问题的警报器）"></a>2. <code>Extra</code> - 额外信息（性能问题的警报器）</h5><p><code>Extra</code> 列提供了非常有价值的补充信息，需要特别关注以下几个值：</p>
<ul>
<li><strong><code>Using index</code> (好)</strong>:<ul>
<li>表示查询直接从索引中就获取到了所有需要的数据，而无需回表（访问原始数据行）。这被称为“<strong>覆盖索引 (Covering Index)</strong>”，是性能极高的表现。</li>
</ul>
</li>
<li><strong><code>Using where</code> (中性&#x2F;常见)</strong>:<ul>
<li>表示在存储引擎层获取数据后，MySQL 服务器层还需要进行一次过滤。</li>
</ul>
</li>
<li><strong><code>Using temporary</code> (差！)</strong>:<ul>
<li>表示 MySQL 为了处理查询，需要创建一个临时表。这通常发生在 <code>GROUP BY</code> 或 <code>ORDER BY</code> 的列没有索引时。创建临时表会消耗大量 I&#x2F;O 和 CPU，严重影响性能。</li>
</ul>
</li>
<li><strong><code>Using filesort</code> (差！)</strong>:<ul>
<li>表示 MySQL 无法利用索引完成排序操作，必须在内存或磁盘中进行额外的排序。这同样是性能杀手。<code>ORDER BY</code> 的列上没有合适的索引是主因。</li>
</ul>
</li>
</ul>
<p><strong>优化目标：</strong> 尽量消除 <code>Using temporary</code> 和 <code>Using filesort</code>。可以通过在排序列和分组列上创建合适的索引来解决。</p>
<hr>
<h4 id="3-1-5-实战分析案例"><a href="#3-1-5-实战分析案例" class="headerlink" title="3.1.5 实战分析案例"></a>3.1.5 实战分析案例</h4><p>假设我们有一个 <code>orders</code> 表，<code>customer_id</code> 列上没有索引。</p>
<p><strong>优化前：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> customer_id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date;</span><br></pre></td></tr></table></figure>

<p><strong>可能的执行计划输出（简化版）：</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>orders</td>
<td><strong>ALL</strong></td>
<td>NULL</td>
<td>NULL</td>
<td>100000</td>
<td>Using where; <strong>Using filesort</strong></td>
</tr>
</tbody></table>
<p><strong>分析：</strong></p>
<ol>
<li><strong><code>type</code> 是 <code>ALL</code></strong>：全表扫描！MySQL 遍历了 100,000 行数据。这是最大的性能问题。</li>
<li><strong><code>key</code> 是 <code>NULL</code></strong>：没有使用任何索引，印证了全表扫描。</li>
<li><strong><code>Extra</code> 中有 <code>Using filesort</code></strong>：在找到 <code>customer_id = 123</code> 的所有订单后，MySQL 还需要对这些结果进行一次额外的排序操作。</li>
</ol>
<p><strong>优化措施：</strong></p>
<p>为 <code>customer_id</code> 和 <code>order_date</code> 创建一个联合索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_cust_date <span class="keyword">ON</span> orders(customer_id, order_date);</span><br></pre></td></tr></table></figure>

<p><strong>优化后：</strong></p>
<p>再次执行 <code>EXPLAIN</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> customer_id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date;</span><br></pre></td></tr></table></figure>

<p><strong>新的执行计划输出（简化版）：</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>orders</td>
<td><strong>ref</strong></td>
<td>idx_cust_date</td>
<td>idx_cust_date</td>
<td>15</td>
<td>Using where</td>
</tr>
</tbody></table>
<p><strong>分析：</strong></p>
<ol>
<li><strong><code>type</code> 变成了 <code>ref</code></strong>：性能从“极差”提升到“良好”，MySQL 通过索引快速定位到了 <code>customer_id = 123</code> 的数据。</li>
<li><strong><code>key</code> 显示 <code>idx_cust_date</code></strong>：明确表示使用了我们新建的索引。</li>
<li><strong><code>rows</code> 预估扫描行数从 100,000 降到了 15</strong>：这是一个巨大的提升！</li>
<li><strong><code>Extra</code> 中的 <code>Using filesort</code> 消失了</strong>：因为联合索引 <code>(customer_id, order_date)</code> 的顺序天然满足了 <code>ORDER BY order_date</code> 的要求，无需额外排序。</li>
</ol>
<hr>
<h3 id="3-2-慢查询日志"><a href="#3-2-慢查询日志" class="headerlink" title="3.2 慢查询日志"></a>3.2 慢查询日志</h3><h4 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h4><p>慢查询日志是 MySQL 提供的一种日志功能，它专门用来<strong>记录执行时间超过指定阈值的 SQL 查询语句</strong>。</p>
<p>可以把它想象成一个“性能问题捕获器”。你设定一个标准（比如，“任何执行超过2秒的查询都算慢”），MySQL 就会自动将所有触及这个标准的查询，连同其执行上下文信息（如执行时间、扫描行数等）都记录到一个专门的日志文件中。</p>
<p><strong>它与 <code>EXPLAIN</code> 的关系：</strong></p>
<ul>
<li><strong><code>EXPLAIN</code> 是主动的、针对性的分析</strong>：你需要对一个<em>已知</em>的、你怀疑有问题的 SQL 语句使用 <code>EXPLAIN</code> 来分析其执行计划。</li>
<li><strong>慢查询日志是被动的、全局的监控</strong>：你不知道哪些查询会变慢，通过开启慢查询日志，让系统自动帮你<strong>发现并捕获</strong>那些在生产环境中实际发生的、未知的性能问题 SQL。</li>
</ul>
<p>发现问题（慢查询日志） -&gt; 分析问题（<code>EXPLAIN</code>） -&gt; 解决问题（优化），这是一个经典的性能优化流程。</p>
<hr>
<h4 id="3-2-2-开启与配置"><a href="#3-2-2-开启与配置" class="headerlink" title="3.2.2 开启与配置"></a>3.2.2 开启与配置</h4><p>慢查询日志默认是关闭的，需要手动开启和配置。主要涉及以下几个系统变量：</p>
<table>
<thead>
<tr>
<th align="left">变量名</th>
<th align="left">含义</th>
<th align="left">建议值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>slow_query_log</code></strong></td>
<td align="left">慢查询日志的开关。<code>ON</code> 为开启，<code>OFF</code> 为关闭。</td>
<td align="left"><code>ON</code></td>
</tr>
<tr>
<td align="left"><strong><code>slow_query_log_file</code></strong></td>
<td align="left">慢查询日志文件的存放路径和文件名。</td>
<td align="left">(默认即可，或指定到专门的日志目录)</td>
</tr>
<tr>
<td align="left"><strong><code>long_query_time</code></strong></td>
<td align="left"><strong>[核心]</strong> 定义“慢”的阈值，单位为秒。执行时间超过此值的查询会被记录。</td>
<td align="left">生产环境建议从 <code>1</code> 或 <code>2</code> 秒开始，后续根据业务情况调整。</td>
</tr>
<tr>
<td align="left"><code>log_queries_not_using_indexes</code></td>
<td align="left">是否记录没有使用索引的查询。</td>
<td align="left">建议开启 (<code>ON</code>)，这能帮助发现潜在的全表扫描问题，即使它们执行很快。</td>
</tr>
<tr>
<td align="left"><code>log_output</code></td>
<td align="left">日志输出格式。可以是 <code>FILE</code>（文件）或 <code>TABLE</code>（mysql.slow_log 表）。</td>
<td align="left">推荐使用 <code>FILE</code>，便于后续工具分析。<code>TABLE</code> 格式会给数据库自身带来额外开销。</td>
</tr>
</tbody></table>
<h5 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h5><p><strong>1. 查看当前配置：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看开关和阈值</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2. 临时开启（MySQL 服务重启后失效）：</strong></p>
<p>这对于临时排查问题非常有用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启慢查询日志</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置慢查询阈值为 1 秒</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启未走索引的查询记录</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_queries_not_using_indexes <span class="operator">=</span> <span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <code>SET GLOBAL</code> 只对新建立的连接生效。要对当前会话也生效，可以再执行一次 <code>SET SESSION ...</code>。</p>
<p><strong>3. 永久开启（推荐）：</strong></p>
<p>修改 MySQL 的配置文件（通常是 <code>my.cnf</code> 或 <code>my.ini</code>），在 <code>[mysqld]</code> 部分添加或修改以下配置，然后重启 MySQL 服务。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/log/mysql/mysql-slow.log</span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">log_queries_not_using_indexes</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-3-解读慢查询日志条目"><a href="#3-2-3-解读慢查询日志条目" class="headerlink" title="3.2.3 解读慢查询日志条目"></a>3.2.3 解读慢查询日志条目</h4><p>一个典型的慢查询日志条目如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Time: 2023-10-27T10:30:05.123456Z</span><br><span class="line"># User@Host: webuser[webuser] @ localhost []  Id: 12345</span><br><span class="line"># Query_time: 2.567890  Lock_time: 0.000123  Rows_sent: 5  Rows_examined: 890432</span><br><span class="line">SET timestamp=1698399005;</span><br><span class="line">SELECT p.product_name, c.category_name, o.order_date</span><br><span class="line">FROM products p</span><br><span class="line">JOIN categories c ON p.category_id = c.id</span><br><span class="line">JOIN order_items oi ON p.id = oi.product_id</span><br><span class="line">JOIN orders o ON oi.order_id = o.id</span><br><span class="line">WHERE p.product_description LIKE &#x27;%expensive%&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>核心字段解读：</strong></p>
<ul>
<li><code># Time</code>: 查询执行完毕的时间点。</li>
<li><code># User@Host</code>: 执行该查询的用户名和主机。</li>
<li><code># Query_time</code>: <strong>[最关键]</strong> 查询总共花费的时间，单位秒。这是判断慢查询的首要依据。</li>
<li><code># Lock_time</code>: 等待表锁所花费的时间。如果这个值很高，说明存在严重的锁竞争问题。</li>
<li><code># Rows_sent</code>: 发送给客户端的实际行数。</li>
<li><code># Rows_examined</code>: <strong>[第二关键]</strong> 查询过程中，存储引擎层实际扫描和检查的行数。</li>
<li><code>SET timestamp=...;</code>: 查询执行时的时间戳。</li>
<li><code>SELECT ...;</code>: 实际执行的慢 SQL 语句。</li>
</ul>
<p><strong>分析要点：</strong></p>
<p><code>Rows_examined</code> 和 <code>Rows_sent</code> 的比值非常重要。如果 <code>Rows_examined</code> 远远大于 <code>Rows_sent</code>（如上例中扫描了 89 万行，却只返回 5 行），这通常意味着查询效率极低，做了大量的无效工作，极有可能是索引缺失或索引使用不当导致的。</p>
<hr>
<h4 id="3-2-4-分析工具"><a href="#3-2-4-分析工具" class="headerlink" title="3.2.4 分析工具"></a>3.2.4 分析工具</h4><p>当慢查询日志文件变得很大时，手动查看效率极低。我们需要使用专门的工具来汇总和分析。</p>
<h5 id="1-mysqldumpslow"><a href="#1-mysqldumpslow" class="headerlink" title="1. mysqldumpslow"></a><strong>1. <code>mysqldumpslow</code></strong></h5><p>这是 MySQL 官方自带的、最基础的分析工具，一个 Perl 脚本。它能将日志中重复的 SQL 语句进行分组、汇总和排序。</p>
<p><strong>常用命令示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出执行时间最长的前 10 条 SQL</span></span><br><span class="line">mysqldumpslow -s t -t 10 /var/log/mysql/mysql-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出扫描行数最多（最消耗资源）的前 10 条 SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/log/mysql/mysql-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出访问次数最多的前 10 条 SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /var/log/mysql/mysql-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合 -g 参数进行正则匹配，比如只分析包含 &quot;products&quot; 表的查询</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g <span class="string">&quot;products&quot;</span> /var/log/mysql/mysql-slow.log</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li><code>-s</code>: 排序方式。<code>t</code> (query time), <code>r</code> (rows examined), <code>c</code> (count)。</li>
<li><code>-t</code>: 返回结果集的前 N 条。</li>
<li><code>-g</code>: 使用正则表达式过滤。</li>
</ul>
<hr>
<h5 id="2-Percona-Toolkit-pt-query-digest"><a href="#2-Percona-Toolkit-pt-query-digest" class="headerlink" title="2. Percona Toolkit (pt-query-digest)"></a><strong>2. Percona Toolkit (pt-query-digest)</strong></h5><p><code>pt-query-digest</code> 是一个功能远比 <code>mysqldumpslow</code> 强大的第三方工具。它能生成非常详尽的分析报告，是 DBA 和高级开发人员进行性能分析的利器。</p>
<p><strong>特点：</strong></p>
<ul>
<li>分析更全面：提供最大&#x2F;最小&#x2F;平均值、95% 百分位等统计信息。</li>
<li>输出报告详尽：为每一种类型的慢查询生成详细的报告，包括执行计划示例。</li>
<li>支持多种数据源：可以直接分析慢查询日志、<code>SHOW PROCESSLIST</code> 输出，甚至可以通过抓取网络包来分析。</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对慢查询日志进行分析，并输出到报告文件</span></span><br><span class="line">pt-query-digest /var/log/mysql/mysql-slow.log &gt; slow_query_report.txt</span><br></pre></td></tr></table></figure>

<p>生成的报告会清晰地列出排名最高的几个“问题 SQL”，并给出详尽的统计数据，让你能快速定位到最需要优化的查询。</p>
<hr>
<h4 id="3-2-5-慢查询优化闭环"><a href="#3-2-5-慢查询优化闭环" class="headerlink" title="3.2.5 慢查询优化闭环"></a>3.2.5 慢查询优化闭环</h4><ol>
<li><strong>开启日志</strong>：在开发、测试和生产环境中配置并开启慢查询日志。</li>
<li><strong>收集数据</strong>：让系统运行一段时间，收集真实的慢查询数据。</li>
<li><strong>分析报告</strong>：定期使用 <code>mysqldumpslow</code> 或 <code>pt-query-digest</code> 分析日志，找出“元凶”（Top N 慢查询）。</li>
<li><strong>定位根因</strong>：针对找出的慢 SQL，使用 <code>EXPLAIN</code> 分析其执行计划，找到性能瓶颈（如全表扫描、未使用索引、filesort 等）。</li>
<li><strong>实施优化</strong>：根据执行计划的分析结果，进行优化，例如：<ul>
<li>创建或修改索引。</li>
<li>改写 SQL 语句，避免复杂的子查询或不合理的 Join。</li>
<li>调整业务逻辑。</li>
</ul>
</li>
<li><strong>验证效果</strong>：优化后，再次使用 <code>EXPLAIN</code> 确认执行计划是否改善，并持续监控慢查询日志，确保问题已解决。</li>
<li><strong>持续监控</strong>：这是一个持续循环的过程。</li>
</ol>
<hr>
<h3 id="3-3-常见-SQL-优化技巧"><a href="#3-3-常见-SQL-优化技巧" class="headerlink" title="3.3 常见 SQL 优化技巧"></a>3.3 常见 SQL 优化技巧</h3><h4 id="3-3-1-索引优化：最核心的手段"><a href="#3-3-1-索引优化：最核心的手段" class="headerlink" title="3.3.1  索引优化：最核心的手段"></a>3.3.1  索引优化：最核心的手段</h4><p>绝大多数 SQL 性能问题都可以通过索引来解决。</p>
<h5 id="1-避免索引失"><a href="#1-避免索引失" class="headerlink" title="1. 避免索引失"></a>1. 避免索引失</h5><ul>
<li><p><strong>WHERE 子句中使用函数或表达式</strong><br>对索引列使用函数、进行计算或任何形式的转换，都会导致索引失效。</p>
<ul>
<li><p>**反例 **: <code>SELECT * FROM orders WHERE YEAR(order_date) = 2023;</code></p>
<blockquote>
<p><strong>原因</strong>: 数据库需要对 <code>order_date</code> 列的每一行都执行 <code>YEAR()</code> 函数，然后将结果与 <code>2023</code> 比较。这使得索引无法直接定位。</p>
</blockquote>
</li>
<li><p>**正解 **: <code>SELECT * FROM orders WHERE order_date &gt;= &#39;2023-01-01&#39; AND order_date &lt; &#39;2024-01-01&#39;;</code></p>
<blockquote>
<p><strong>原因</strong>: 直接使用原始列进行范围比较，可以完美利用 <code>order_date</code> 上的索引。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>LIKE 以通配符 <code>%</code> 开头</strong></p>
<ul>
<li><p>**反例 **: <code>SELECT * FROM users WHERE name LIKE &#39;%John&#39;;</code></p>
<blockquote>
<p><strong>原因</strong>: 索引的 B-Tree 结构是按从左到右的顺序排序的。从中间或末尾开始匹配，无法利用索引的有序性进行快速查找。</p>
</blockquote>
</li>
<li><p>**正解 **: <code>SELECT * FROM users WHERE name LIKE &#39;John%&#39;;</code></p>
<blockquote>
<p><strong>原因</strong>: 从左侧开始匹配，可以利用索引快速定位到以 “John” 开头的记录范围。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>隐式类型转换</strong><br>如果查询条件中列的类型与值的类型不匹配，MySQL 可能会进行隐式转换，这通常会导致索引失效。</p>
<ul>
<li><p><strong>场景</strong>: <code>phone</code> 字段是 <code>VARCHAR(20)</code> 类型。</p>
</li>
<li><p>**反例 **: <code>SELECT * FROM users WHERE phone = 13800138000;</code> (用数字类型查询字符串列)</p>
<blockquote>
<p><strong>原因</strong>: MySQL 为了比较，会尝试将表中所有的 <code>phone</code> 字符串值转换为数字，相当于对列使用了函数 <code>CAST(phone AS INT)</code>，导致索引失效。</p>
</blockquote>
</li>
<li><p>**正解 **: <code>SELECT * FROM users WHERE phone = &#39;13800138000&#39;;</code> (使用字符串进行匹配)</p>
</li>
</ul>
</li>
<li><p><strong>OR 连接的条件中包含非索引列</strong><br>如果 <code>OR</code> 两边的条件，有一个无法使用索引，那么整个查询很可能放弃使用索引。</p>
<ul>
<li><p><strong>场景</strong>: <code>user_id</code> 有索引, <code>user_email</code> 没有索引。</p>
</li>
<li><p>**反例 **: <code>SELECT * FROM users WHERE user_id = 123 OR user_email = &#39;test@example.com&#39;;</code></p>
<blockquote>
<p><strong>原因</strong>: 优化器认为全表扫描一次，比先走 <code>user_id</code> 索引再全表扫描找 <code>user_email</code> 更高效。</p>
</blockquote>
</li>
<li><p>**正解 **: 如果业务上需要频繁这样查询，应为 <code>user_email</code> 也建立索引。或者，可以考虑使用 <code>UNION ALL</code> 改写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">123</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_email <span class="operator">=</span> <span class="string">&#x27;test@example.com&#x27;</span> <span class="keyword">AND</span> user_id <span class="operator">&lt;&gt;</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-使用覆盖索引（Covering-Index）"><a href="#2-使用覆盖索引（Covering-Index）" class="headerlink" title="2. 使用覆盖索引（Covering Index）"></a>2. 使用覆盖索引（Covering Index）</h5><p>当一个查询需要的所有数据都能直接从索引中获取，而无需回到主表（聚簇索引）中再次查找数据时，这个索引就被称为“覆盖索引”。这是性能极高的优化方式。</p>
<ul>
<li><p><strong>场景</strong>: <code>users</code> 表有联合索引 <code>idx_name_age(name, age)</code>。</p>
</li>
<li><p><strong>普通查询</strong>: <code>SELECT name, age, email FROM users WHERE name = &#39;Alice&#39;;</code></p>
<blockquote>
<p><strong>过程</strong>: 1. 通过 <code>idx_name_age</code> 找到 <code>name</code> 为 ‘Alice’ 的索引条目。2. 获取主键 ID。3. <strong>回表</strong>，用主键 ID 去主表中查找 <code>email</code> 字段。</p>
</blockquote>
</li>
<li><p>**覆盖索引查询 **: <code>SELECT name, age FROM users WHERE name = &#39;Alice&#39;;</code></p>
<blockquote>
<p><strong>过程</strong>: 1. 通过 <code>idx_name_age</code> 找到 <code>name</code> 为 ‘Alice’ 的索引条目。2. 索引中已经包含了 <code>name</code> 和 <code>age</code> 两个字段，直接返回结果，<strong>无需回表</strong>。<br><strong>效果</strong>: 在 <code>EXPLAIN</code> 的 <code>Extra</code> 列会显示 <code>Using index</code>。</p>
</blockquote>
</li>
</ul>
<hr>
<h5 id="3-遵循最左前缀原则（Leftmost-Prefix-Principle）"><a href="#3-遵循最左前缀原则（Leftmost-Prefix-Principle）" class="headerlink" title="3. 遵循最左前缀原则（Leftmost Prefix Principle）"></a>3. 遵循最左前缀原则（Leftmost Prefix Principle）</h5><p>对于联合索引（例如 <code>INDEX(col1, col2, col3)</code>），查询必须从索引的最左边的列开始，并且不能跳过中间的列。</p>
<ul>
<li><strong>场景</strong>: 索引 <code>idx_a_b_c(a, b, c)</code>。</li>
<li>**有效查询 **:<ul>
<li><code>WHERE a = 1</code></li>
<li><code>WHERE a = 1 AND b = 2</code></li>
<li><code>WHERE a = 1 AND b = 2 AND c = 3</code></li>
<li><code>WHERE a = 1 AND c = 3</code> (只能用到 <code>a</code> 部分的索引)</li>
</ul>
</li>
<li>**无效查询 **:<ul>
<li><code>WHERE b = 2</code></li>
<li><code>WHERE c = 3</code></li>
<li><code>WHERE b = 2 AND c = 3</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-2-查询语句改写"><a href="#3-3-2-查询语句改写" class="headerlink" title="3.3.2  查询语句改写"></a>3.3.2  查询语句改写</h4><h5 id="1-减少-SELECT-的使用"><a href="#1-减少-SELECT-的使用" class="headerlink" title="1. 减少 SELECT * 的使用"></a>1. 减少 <code>SELECT *</code> 的使用</h5><ul>
<li><strong>原因</strong>:<ol>
<li><strong>增加网络开销</strong>: 传输了不需要的数据。</li>
<li><strong>无法利用覆盖索引</strong>: 如上所述，即使有合适的索引，<code>SELECT *</code> 也会强制回表获取所有列。</li>
<li><strong>可读性差</strong>: 无法清晰看出查询的目的。</li>
</ol>
</li>
<li><strong>建议</strong>: 明确指定需要的列名，<code>SELECT id, name, status FROM ...</code>。</li>
</ul>
<hr>
<h5 id="2-用-JOIN-代替部分子查询"><a href="#2-用-JOIN-代替部分子查询" class="headerlink" title="2. 用 JOIN 代替部分子查询"></a>2. 用 <code>JOIN</code> 代替部分子查询</h5><p>现代 MySQL 优化器已经对子查询做了很多优化，但显式的 <code>JOIN</code> 通常更直观，且优化器更容易生成高效的执行计划。</p>
<ul>
<li>**反例 (IN 子查询) **: <code>SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE country = &#39;USA&#39;);</code></li>
<li>**正解 (JOIN) **: <code>SELECT o.* FROM orders o JOIN customers c ON o.customer_id = c.id WHERE c.country = &#39;USA&#39;;</code></li>
</ul>
<hr>
<h5 id="3-LIMIT-分页查询优化"><a href="#3-LIMIT-分页查询优化" class="headerlink" title="3. LIMIT 分页查询优化"></a>3. <code>LIMIT</code> 分页查询优化</h5><p>在数据量巨大时，传统的分页查询 <code>LIMIT offset, count</code> 会非常慢。</p>
<ul>
<li><p>**反例 **: <code>SELECT * FROM articles ORDER BY created_at DESC LIMIT 1000000, 20;</code></p>
<blockquote>
<p><strong>原因</strong>: MySQL 必须先扫描并排序 1,000,020 条记录，然后丢弃前面的 1,000,000 条，只返回最后 20 条，开销巨大。</p>
</blockquote>
</li>
<li><p>**正解 (Seek Method &#x2F; 书签法) **: 记录上一页最后一条记录的 ID 或排序键的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设上一页最后一条记录的 created_at 是 &#x27;2023-01-01 12:00:00&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles</span><br><span class="line"><span class="keyword">WHERE</span> created_at <span class="operator">&lt;</span> <span class="string">&#x27;2023-01-01 12:00:00&#x27;</span> <span class="comment">-- 从上一页结束的位置继续</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>优点</strong>: 每次查询都是从一个确定的位置开始，向后扫描少量数据即可，避免了巨大的 <code>offset</code> 扫描。</p>
</blockquote>
</li>
</ul>
<hr>
<h5 id="4-使用-UNION-ALL-代替-UNION"><a href="#4-使用-UNION-ALL-代替-UNION" class="headerlink" title="4. 使用 UNION ALL 代替 UNION"></a>4. 使用 <code>UNION ALL</code> 代替 <code>UNION</code></h5><ul>
<li><code>UNION</code>: 会对结果集进行合并、排序和去重，这个过程可能会使用临时表，开销较大。</li>
<li><code>UNION ALL</code>: 仅仅是简单地合并结果集，不做任何去重处理。</li>
<li><strong>建议</strong>: 如果你明确知道两个结果集没有重复数据，或者业务上允许重复，请务必使用 <code>UNION ALL</code>，性能会好很多。</li>
</ul>
<hr>
<h4 id="3-3-3-其他通用优化技巧"><a href="#3-3-3-其他通用优化技巧" class="headerlink" title="3.3.3 其他通用优化技巧"></a>3.3.3 其他通用优化技巧</h4><h5 id="1-批量操作"><a href="#1-批量操作" class="headerlink" title="1. 批量操作"></a>1. 批量操作</h5><p>在应用层，避免在循环中执行单条 <code>INSERT</code> 或 <code>UPDATE</code> 语句。</p>
<ul>
<li><p>**反例 (循环单次插入) **:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">    userDao.insert(user); <span class="comment">// 每次执行一条 SQL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**正解 (批量插入) **:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users (name, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;a@a.com&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;b@b.com&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;c@c.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>原因</strong>: 大幅减少了网络通信的次数和数据库事务的开销。</p>
</blockquote>
</li>
</ul>
<hr>
<h5 id="2-小表驱动大表"><a href="#2-小表驱动大表" class="headerlink" title="2. 小表驱动大表"></a>2. 小表驱动大表</h5><p>在多表连接查询时，让数据量小的表作为驱动表（放在前面），数据量大的表作为被驱动表。</p>
<ul>
<li><strong>原则</strong>: 优化器通常会自动选择，但有时需要手动调整。<code>STRAIGHT_JOIN</code> 关键字可以强制指定连接顺序。</li>
<li><strong>对于 <code>IN</code> 和 <code>EXISTS</code></strong>:<ul>
<li><code>IN</code>: 适用于子查询结果集较小的情况。<code>SELECT * FROM A WHERE id IN (SELECT id FROM B)</code>。</li>
<li><code>EXISTS</code>: 适用于外层表 A 较小的情况。<code>SELECT * FROM A WHERE EXISTS (SELECT 1 FROM B WHERE B.id = A.id)</code>。</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="三、数据库设计与应用开发"><a href="#三、数据库设计与应用开发" class="headerlink" title="三、数据库设计与应用开发"></a>三、数据库设计与应用开发</h1><h2 id="1-数据库设计"><a href="#1-数据库设计" class="headerlink" title="1. 数据库设计"></a>1. 数据库设计</h2><h3 id="1-1-设计流程"><a href="#1-1-设计流程" class="headerlink" title="1.1 设计流程"></a>1.1 设计流程</h3><h4 id="阶段一：需求分析-Requirements-Analysis"><a href="#阶段一：需求分析-Requirements-Analysis" class="headerlink" title="阶段一：需求分析 (Requirements Analysis)"></a><strong>阶段一：需求分析 (Requirements Analysis)</strong></h4><p><strong>目标</strong>：将模糊的业务需求转化为具体的数据需求，确定系统“存什么”和“怎么用”。</p>
<ul>
<li><strong>核心任务</strong>：<ol>
<li><strong>数据收集</strong>：识别业务核心对象（如：用户、商品、订单）。</li>
<li><strong>操作分析</strong>：明确数据的读写模式与频率（例如：商品是“多读少写”，订单是“高频写入”）。</li>
<li><strong>规则定义</strong>：确定数据完整性约束（例如：库存非负、用户名唯一）。</li>
<li><strong>非功能需求</strong>：确立性能指标（QPS&#x2F;TPS）、并发量级及安全性要求。</li>
</ol>
</li>
<li><strong>产出物</strong>：<ul>
<li><strong>数据字典 (Data Dictionary)</strong>：对数据项的名称、类型、长度、取值范围的元数据定义。</li>
<li><strong>数据流图 (DFD)</strong>：描述数据在系统中的流动方向。</li>
</ul>
</li>
</ul>
<h4 id="阶段二：概念设计-Conceptual-Design"><a href="#阶段二：概念设计-Conceptual-Design" class="headerlink" title="阶段二：概念设计 (Conceptual Design)"></a><strong>阶段二：概念设计 (Conceptual Design)</strong></h4><p><strong>目标</strong>：构建独立于具体数据库软件（DBMS）的信息模型，通常使用 <strong>E-R 模型</strong>。</p>
<ul>
<li><strong>核心任务</strong>：<ol>
<li><strong>实体 (Entity) 建模</strong>：抽象业务对象（如 <code>User</code>, <code>Order</code>）。</li>
<li><strong>属性 (Attribute) 定义</strong>：确定实体的特征（如 <code>User</code> 包含 <code>id</code>, <code>email</code>）。</li>
<li><strong>关系 (Relationship) 梳理</strong>：<ul>
<li><strong>1:1</strong>：用户 - 用户详情。</li>
<li><strong>1:N</strong>：用户 - 订单（最常见）。</li>
<li><strong>M:N</strong>：订单 - 商品（需关注后续转化）。</li>
</ul>
</li>
</ol>
</li>
<li><strong>产出物</strong>：<strong>E-R 图 (Entity-Relationship Diagram)</strong>，作为系统的逻辑蓝图。</li>
</ul>
<h4 id="阶段三：逻辑设计-Logical-Design"><a href="#阶段三：逻辑设计-Logical-Design" class="headerlink" title="阶段三：逻辑设计 (Logical Design)"></a><strong>阶段三：逻辑设计 (Logical Design)</strong></h4><p><strong>目标</strong>：将 E-R 图转换为<strong>关系模型</strong>（即表结构），并进行规范化处理。</p>
<ul>
<li><strong>核心任务</strong>：<ol>
<li><strong>模型转化</strong>：<ul>
<li><strong>实体转表</strong>：每个 Entity 对应一张 Table。</li>
<li><strong>属性转列</strong>：Attribute 对应 Column。</li>
<li><strong>标识符转主键</strong>：确定 Primary Key (PK)。</li>
</ul>
</li>
<li><strong>关系映射</strong>：<ul>
<li><strong>1:1 &amp; 1:N</strong>：在“多”的一方建立<strong>外键 (Foreign Key)</strong> 指向“一”的一方。</li>
<li><strong>M:N</strong>：必须创建<strong>中间表 (Junction Table)</strong>，包含双方主键作为联合主键或复合索引。</li>
</ul>
</li>
<li><strong>规范化 (Normalization)</strong>：应用<strong>三大范式 (3NF)</strong>，消除冗余，避免更新异常。</li>
</ol>
</li>
<li><strong>产出物</strong>：数据库逻辑模式（Table Schema），包含表名、列名、主外键定义。</li>
</ul>
<h4 id="阶段四：物理设计-Physical-Design"><a href="#阶段四：物理设计-Physical-Design" class="headerlink" title="阶段四：物理设计 (Physical Design)"></a><strong>阶段四：物理设计 (Physical Design)</strong></h4><p><strong>目标</strong>：基于特定的 DBMS（如 MySQL）进行底层实现设计，核心在于<strong>性能权衡</strong>。</p>
<ul>
<li><strong>核心任务</strong>：<ol>
<li><strong>字段选型</strong>：选择最紧凑的数据类型（如 <code>TINYINT</code> vs <code>INT</code>，<code>VARCHAR</code> vs <code>CHAR</code>）。</li>
<li><strong>存储引擎选择</strong>：通常选用 <code>InnoDB</code>（支持事务、行锁、外键）。</li>
<li><strong>索引规划</strong>：根据查询频率和方式（<code>WHERE</code>, <code>JOIN</code>, <code>ORDER BY</code>）设计索引策略。</li>
<li><strong>性能优化策略</strong>：<ul>
<li><strong>反范式 (Denormalization)</strong>：在高频读取场景下，适当增加冗余字段以减少 JOIN。</li>
<li><strong>分区&#x2F;分表</strong>：针对海量数据预设 Partitioning 或 Sharding 方案。</li>
</ul>
</li>
</ol>
</li>
<li><strong>产出物</strong>：物理数据模型，包含具体的 DDL 脚本草案。</li>
</ul>
<h4 id="阶段五：数据库实施-Implementation"><a href="#阶段五：数据库实施-Implementation" class="headerlink" title="阶段五：数据库实施 (Implementation)"></a><strong>阶段五：数据库实施 (Implementation)</strong></h4><p><strong>目标</strong>：在服务器上部署数据库结构并加载数据。</p>
<ul>
<li><strong>核心任务</strong>：<ol>
<li><strong>执行 DDL</strong>：运行 <code>CREATE DATABASE</code>, <code>CREATE TABLE</code>, <code>CREATE INDEX</code> 脚本。</li>
<li><strong>数据装载</strong>：导入初始化字典数据或迁移历史数据。</li>
<li><strong>权限控制 (DCL)</strong>：创建用户并遵循“最小权限原则”分配 <code>GRANT</code>。</li>
</ol>
</li>
<li><strong>产出物</strong>：正式运行的数据库实例。</li>
</ul>
<h4 id="阶段六：运维与优化-Maintenance-and-Optimization"><a href="#阶段六：运维与优化-Maintenance-and-Optimization" class="headerlink" title="阶段六：运维与优化 (Maintenance and Optimization)"></a><strong>阶段六：运维与优化 (Maintenance and Optimization)</strong></h4><p><strong>目标</strong>：监控系统运行状态，根据实际负载进行迭代优化。</p>
<ul>
<li><strong>核心任务</strong>：<ol>
<li><strong>监控告警</strong>：跟踪 CPU、I&#x2F;O、连接数、死锁情况。</li>
<li><strong>SQL 调优</strong>：分析慢查询日志 (Slow Query Log)，调整索引或重写 SQL。</li>
<li><strong>模式演进</strong>：使用 <code>ALTER TABLE</code> 应对业务变更（需注意在线 DDL 对锁的影响）。</li>
<li><strong>备份恢复</strong>：执行全量&#x2F;增量备份策略，确保数据灾备能力。</li>
</ol>
</li>
<li><strong>产出物</strong>：性能分析报告、优化方案、备份日志。</li>
</ul>
<hr>
<h3 id="1-2-三大范式"><a href="#1-2-三大范式" class="headerlink" title="1.2 三大范式"></a>1.2 三大范式</h3><p>范式化（Normalization）是数据库设计的一套理论和指导原则，旨在通过一系列的规范（范式）来优化数据表结构，其主要目标是：</p>
<ul>
<li><strong>减少数据冗余</strong>：确保相同的数据不会在多个地方重复存储。</li>
<li><strong>避免数据异常</strong>：防止因数据冗余而导致的插入、更新和删除操作的问题。</li>
<li><strong>保证数据一致性</strong>：数据冗余减少后，修改数据时只需在一处进行，从而保证了数据的一致性。</li>
</ul>
<p>最常用的范式是第一范式（1NF）、第二范式（2NF）和第三范式（3NF）。它们是递进关系，即满足 2NF 必须先满足 1NF，满足 3NF 必须先满足 2NF。</p>
<hr>
<h4 id="1-2-1-第一范式-1NF-First-Normal-Form"><a href="#1-2-1-第一范式-1NF-First-Normal-Form" class="headerlink" title="1.2.1 第一范式 (1NF - First Normal Form)"></a>1.2.1 第一范式 (1NF - First Normal Form)</h4><p><strong>定义</strong>：确保数据表中的每一列（字段）都是 <strong>原子性的、不可再分的</strong>。</p>
<p><strong>通俗解释</strong>：</p>
<p>“一格只填一件事”。表中的每个单元格都应该只包含一个单一的值，而不能是集合、列表或者多个值的组合。这是关系型数据库的最基本要求。</p>
<p><strong>示例</strong>：</p>
<p>假设我们有一个未规范化的订单表：</p>
<p><strong>不符合 1NF 的表：<code>Bad_Order_Table</code></strong></p>
<table>
<thead>
<tr>
<th align="left">OrderID</th>
<th align="left">CustomerID</th>
<th align="left">Products</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1001</td>
<td align="left">C01</td>
<td align="left">‘iPhone 14, USB-C Cable’</td>
</tr>
<tr>
<td align="left">1002</td>
<td align="left">C02</td>
<td align="left">‘Monitor’</td>
</tr>
<tr>
<td align="left">1003</td>
<td align="left">C01</td>
<td align="left">‘Keyboard, Mouse’</td>
</tr>
</tbody></table>
<p><strong>问题分析</strong>：</p>
<p><code>Products</code> 这一列违反了原子性。它包含了多个商品信息，是一个“列表”。这会导致：</p>
<ul>
<li><strong>查询困难</strong>：无法简单地查询购买了 ‘Mouse’ 的所有订单。</li>
<li><strong>更新复杂</strong>：如果想把 ‘Keyboard’ 从订单 1003 中移除，需要进行复杂的字符串操作。</li>
<li><strong>无法利用索引</strong>：无法为单个商品建立索引。</li>
</ul>
<p><strong>如何修正以符合 1NF</strong>：</p>
<p>将 <code>Products</code> 列拆分，确保每一行只代表一个商品和订单的关系。</p>
<p><strong>符合 1NF 的表：<code>Order_Items_Table</code></strong></p>
<table>
<thead>
<tr>
<th align="left">OrderID</th>
<th align="left">CustomerID</th>
<th align="left">Product</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1001</td>
<td align="left">C01</td>
<td align="left">‘iPhone 14’</td>
</tr>
<tr>
<td align="left">1001</td>
<td align="left">C01</td>
<td align="left">‘USB-C Cable’</td>
</tr>
<tr>
<td align="left">1002</td>
<td align="left">C02</td>
<td align="left">‘Monitor’</td>
</tr>
<tr>
<td align="left">1003</td>
<td align="left">C01</td>
<td align="left">‘Keyboard’</td>
</tr>
<tr>
<td align="left">1003</td>
<td align="left">C01</td>
<td align="left">‘Mouse’</td>
</tr>
</tbody></table>
<p>现在，每一列都是原子性的，满足了第一范式。</p>
<hr>
<h4 id="1-2-2-第二范式-2NF-Second-Normal-Form"><a href="#1-2-2-第二范式-2NF-Second-Normal-Form" class="headerlink" title="1.2.2 第二范式 (2NF - Second Normal Form)"></a>1.2.2 第二范式 (2NF - Second Normal Form)</h4><p><strong>定义</strong>：在满足 1NF 的基础上，表中所有非主键列都必须 <strong>完全函数依赖于整个主键</strong>，而不能只依赖于主键的一部分。</p>
<p><strong>通俗解释</strong>：</p>
<p>“一张表只说一件事”。如果一个表的主键是<strong>复合主键</strong>（由多个列组成），那么表中的其他列必须依赖于这个复合主键的<strong>全部</strong>，而不是其中某一个部分。这个范式主要是针对复合主键的表。</p>
<p><strong>示例</strong>：</p>
<p>我们继续使用上面的例子，并增加更多信息。假设 <code>(OrderID, Product)</code> 是复合主键。</p>
<p><strong>符合 1NF 但不符合 2NF 的表：<code>Order_Items_Table_V2</code></strong></p>
<table>
<thead>
<tr>
<th align="left">OrderID</th>
<th align="left">Product</th>
<th align="left">Quantity</th>
<th align="left">ProductPrice</th>
<th align="left">OrderDate</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1001</strong></td>
<td align="left"><strong>‘iPhone 14’</strong></td>
<td align="left">1</td>
<td align="left">5999</td>
<td align="left">2023-10-26</td>
</tr>
<tr>
<td align="left"><strong>1001</strong></td>
<td align="left"><strong>‘USB-C Cable’</strong></td>
<td align="left">2</td>
<td align="left">89</td>
<td align="left">2023-10-26</td>
</tr>
<tr>
<td align="left"><strong>1002</strong></td>
<td align="left"><strong>‘Monitor’</strong></td>
<td align="left">1</td>
<td align="left">1299</td>
<td align="left">2023-10-27</td>
</tr>
</tbody></table>
<p><strong>问题分析</strong>：</p>
<p>主键是 <code>(OrderID, Product)</code>。</p>
<ul>
<li><code>Quantity</code>（数量）依赖于 <code>OrderID</code> 和 <code>Product</code>，因为特定订单中的特定商品有一个确定的数量。<strong>（完全依赖）</strong></li>
<li><code>ProductPrice</code>（商品单价）只依赖于 <code>Product</code>，与 <code>OrderID</code> 无关。<strong>（部分依赖）</strong></li>
<li><code>OrderDate</code>（订单日期）只依赖于 <code>OrderID</code>，与 <code>Product</code> 无关。<strong>（部分依赖）</strong></li>
</ul>
<p>这种部分依赖会导致：</p>
<ul>
<li><strong>数据冗余</strong>：如果 ‘iPhone 14’ 出现在 100 个订单里，它的价格 5999 就会存储 100 次。</li>
<li><strong>更新异常</strong>：如果 ‘iPhone 14’ 价格调整，你需要修改所有包含它的订单记录，很容易遗漏。</li>
<li><strong>插入异常</strong>：如果一个新商品尚未被任何订单购买，我们无法将其价格信息存入数据库，因为没有 <code>OrderID</code>。</li>
<li><strong>删除异常</strong>：如果删除了唯一包含 ‘Monitor’ 的订单 1002，那么 ‘Monitor’ 的价格信息也随之丢失了。</li>
</ul>
<p><strong>如何修正以符合 2NF</strong>：</p>
<p>进行“分表”，将描述不同实体的属性拆分到不同的表中。</p>
<ol>
<li><p><strong>订单表 (Orders)</strong>：存放只与 <code>OrderID</code> 相关的信息。</p>
<table>
<thead>
<tr>
<th align="left">OrderID (PK)</th>
<th align="left">OrderDate</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1001</td>
<td align="left">2023-10-26</td>
</tr>
<tr>
<td align="left">1002</td>
<td align="left">2023-10-27</td>
</tr>
</tbody></table>
</li>
<li><p><strong>商品表 (Products)</strong>：存放只与 <code>Product</code> 相关的信息。</p>
<table>
<thead>
<tr>
<th align="left">Product (PK)</th>
<th align="left">ProductPrice</th>
</tr>
</thead>
<tbody><tr>
<td align="left">‘iPhone 14’</td>
<td align="left">5999</td>
</tr>
<tr>
<td align="left">‘USB-C Cable’</td>
<td align="left">89</td>
</tr>
<tr>
<td align="left">‘Monitor’</td>
<td align="left">1299</td>
</tr>
</tbody></table>
</li>
<li><p><strong>订单详情表 (Order_Items)</strong>：存放订单和商品的关系。</p>
<table>
<thead>
<tr>
<th align="left">OrderID (FK)</th>
<th>Product (FK)</th>
<th align="left">Quantity</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1001</td>
<td>‘iPhone 14’</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1001</td>
<td>‘USB-C Cable’</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">1002</td>
<td>‘Monitor’</td>
<td align="left">1</td>
</tr>
</tbody></table>
</li>
</ol>
<p>现在，每个表都只描述一个实体，消除了部分依赖，满足了第二范式。</p>
<hr>
<h4 id="1-2-3-第三范式-3NF-Third-Normal-Form"><a href="#1-2-3-第三范式-3NF-Third-Normal-Form" class="headerlink" title="1.2.3 第三范式 (3NF - Third Normal Form)"></a>1.2.3 第三范式 (3NF - Third Normal Form)</h4><p><strong>定义</strong>：在满足 2NF 的基础上，表中所有非主键列都不能有 <strong>传递依赖</strong> 关系。</p>
<p><strong>通俗解释</strong>：</p>
<p>“非主键列之间不能有依赖关系”。一个非主键列不能依赖于另一个非主键列。换句话说，任何非主键列都必须直接依赖于主键，而不能通过其他非主键列间接依赖于主键。</p>
<p><strong>示例</strong>：</p>
<p>我们在 2NF 的 <code>订单表</code> 中增加客户信息。</p>
<p><strong>符合 2NF 但不符合 3NF 的表：<code>Orders_Table_V2</code></strong></p>
<table>
<thead>
<tr>
<th align="left">OrderID (PK)</th>
<th align="left">OrderDate</th>
<th align="left">CustomerID</th>
<th align="left">CustomerName</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1001</td>
<td align="left">2023-10-26</td>
<td align="left">C01</td>
<td align="left">‘张三’</td>
</tr>
<tr>
<td align="left">1002</td>
<td align="left">2023-10-27</td>
<td align="left">C02</td>
<td align="left">‘李四’</td>
</tr>
<tr>
<td align="left">1003</td>
<td align="left">2023-10-28</td>
<td align="left">C01</td>
<td align="left">‘张三’</td>
</tr>
</tbody></table>
<p><strong>问题分析</strong>：</p>
<p>主键是 <code>OrderID</code>。</p>
<ul>
<li><code>OrderDate</code> 和 <code>CustomerID</code> 直接依赖于主键 <code>OrderID</code>。</li>
<li>但是，<code>CustomerName</code> 依赖于 <code>CustomerID</code>，而 <code>CustomerID</code> 依赖于 <code>OrderID</code>。这就形成了传递依赖： <code>OrderID</code> -&gt; <code>CustomerID</code> -&gt; <code>CustomerName</code>。</li>
</ul>
<p>这种传递依赖会导致：</p>
<ul>
<li><strong>数据冗余</strong>：客户 ‘张三’ (C01) 下了两个订单，他的名字就被存储了两次。</li>
<li><strong>更新异常</strong>：如果 ‘张三’ 改名为 ‘张三丰’，你需要修改所有他下过的订单记录。</li>
<li><strong>插入&#x2F;删除异常</strong>：同 2NF。</li>
</ul>
<p><strong>如何修正以符合 3NF</strong>：</p>
<p>将存在传递依赖的列再次拆分出去，形成新的表。</p>
<ol>
<li><p><strong>客户表 (Customers)</strong>：</p>
<table>
<thead>
<tr>
<th align="left">CustomerID (PK)</th>
<th align="left">CustomerName</th>
</tr>
</thead>
<tbody><tr>
<td align="left">C01</td>
<td align="left">‘张三’</td>
</tr>
<tr>
<td align="left">C02</td>
<td align="left">‘李四’</td>
</tr>
</tbody></table>
</li>
<li><p><strong>订单表 (Orders)</strong>：</p>
<table>
<thead>
<tr>
<th align="left">OrderID (PK)</th>
<th align="left">OrderDate</th>
<th align="left">CustomerID (FK)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1001</td>
<td align="left">2023-10-26</td>
<td align="left">C01</td>
</tr>
<tr>
<td align="left">1002</td>
<td align="left">2023-10-27</td>
<td align="left">C02</td>
</tr>
<tr>
<td align="left">1003</td>
<td align="left">2023-10-28</td>
<td align="left">C01</td>
</tr>
</tbody></table>
</li>
</ol>
<p>现在，<code>Orders</code> 表中的所有非主键列 (<code>OrderDate</code>, <code>CustomerID</code>) 都直接且完全地依赖于主键 <code>OrderID</code>，消除了传递依赖，满足了第三范式。</p>
<hr>
<h4 id="1-2-4-总结"><a href="#1-2-4-总结" class="headerlink" title="1.2.4 总结"></a>1.2.4 总结</h4><table>
<thead>
<tr>
<th align="left">范式</th>
<th align="left">核心要求</th>
<th align="left">解决的问题</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>第一范式 (1NF)</strong></td>
<td align="left"><strong>列的原子性</strong>（字段不可再分）</td>
<td align="left">数据项的结构化，便于查询和操作</td>
</tr>
<tr>
<td align="left"><strong>第二范式 (2NF)</strong></td>
<td align="left"><strong>消除部分依赖</strong>（非主键列完全依赖于整个主键）</td>
<td align="left">减少因复合主键导致的数据冗余和操作异常</td>
</tr>
<tr>
<td align="left"><strong>第三范式 (3NF)</strong></td>
<td align="left"><strong>消除传递依赖</strong>（非主键列之间无依赖）</td>
<td align="left">进一步减少数据冗余，确保数据表的单一职责</td>
</tr>
</tbody></table>
<p>在绝大多数的业务场景中，数据库设计遵循**第三范式（3NF）**就已经足够。过度追求更高阶的范式（如BCNF, 4NF, 5NF）可能会导致表被拆分得过细，从而在查询时需要进行大量的 <code>JOIN</code> 操作，反而影响性能。</p>
<hr>
<h3 id="1-3-反范式设计"><a href="#1-3-反范式设计" class="headerlink" title="1.3 反范式设计"></a>1.3 反范式设计</h3><h4 id="1-3-1-概述-1"><a href="#1-3-1-概述-1" class="headerlink" title="1.3.1 概述"></a>1.3.1 概述</h4><p>反范式设计（Denormalization）是与范式化（Normalization）相对立的一种设计策略。它通过<strong>故意</strong>增加数据冗余或将数据分组，来提高数据库的<strong>读性能</strong>。其核心思想是**“以空间换时间”**，通过增加存储空间的占用和牺牲部分数据一致性的维护成本，来减少查询时需要的表连接（JOIN）次数，从而提升查询速度。</p>
<p><strong>核心理念：</strong> 反范式设计<strong>不是</strong>糟糕的设计，而是在充分理解业务需求和性能瓶颈后，对高度规范化设计的一种<strong>有目的的、可控的“破坏”</strong>。它通常发生在数据库设计的后期优化阶段。</p>
<hr>
<h4 id="1-3-2-为什么需要反范式设计？"><a href="#1-3-2-为什么需要反范式设计？" class="headerlink" title="1.3.2 为什么需要反范式设计？"></a>1.3.2 为什么需要反范式设计？</h4><p>我们在进行数据库设计时，通常会遵循三大范式来创建结构优良、冗余度低的表。一个高度范式化的数据库具有以下优点：</p>
<ul>
<li>数据冗余少，节省存储空间。</li>
<li>数据一致性高，更新操作快且不易出错。</li>
</ul>
<p>然而，当数据量巨大、查询请求非常频繁时，高度范式化设计的弊端就会显现：</p>
<ul>
<li><strong>查询性能下降</strong>：为了获取完整的信息，常常需要连接（JOIN）多张表。当表的数据量很大时，JOIN 操作会消耗大量的 CPU 和 I&#x2F;O 资源，导致查询响应变慢。</li>
<li><strong>查询复杂度高</strong>：复杂的查询需要编写层层嵌套的 JOIN 语句，增加了开发的复杂度和维护成本。</li>
</ul>
<p>在很多互联网应用场景中，用户的读请求（查询）数量远远大于写请求（增删改）。因此，为了提升用户体验，牺牲一部分写操作的性能和增加一点存储空间，来换取查询速度的巨大提升，是非常值得的。这就是反范式设计的根本动机。</p>
<hr>
<h4 id="1-3-3-优缺点"><a href="#1-3-3-优缺点" class="headerlink" title="1.3.3 优缺点"></a>1.3.3 优缺点</h4><h5 id="1-优点："><a href="#1-优点：" class="headerlink" title="1. 优点："></a>1. 优点：</h5><ol>
<li><strong>减少表的连接（JOIN）操作</strong>：<ul>
<li>这是反范式设计最主要的目的。数据库中，<code>JOIN</code> 操作，特别是多表连接，是非常消耗性能的。通过在表中增加冗余字段，可以避免或减少 <code>JOIN</code>，让查询变得更简单、更快速。</li>
</ul>
</li>
<li><strong>简化查询逻辑</strong>：<ul>
<li>查询语句不再需要复杂的 <code>JOIN</code> 和子查询，使得 SQL 语句更短、更易于理解和维护。</li>
</ul>
</li>
<li><strong>提高数据统计和报表生成的效率</strong>：<ul>
<li>对于需要频繁计算或汇总的数据（如订单总价、帖子评论数），可以预先计算好并作为一个字段存储起来。这样在生成报表或进行数据分析时，可以直接读取，而无需实时计算，极大地提升了响应速度。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-缺点："><a href="#2-缺点：" class="headerlink" title="2. 缺点："></a>2. 缺点：</h5><ol>
<li><strong>数据冗余</strong>：<ul>
<li>同样的数据在多个地方存储，会浪费一定的磁盘存储空间。在当今存储成本较低的时代，这通常是次要问题，但仍需考虑。</li>
</ul>
</li>
<li><strong>数据一致性维护成本高</strong>：<ul>
<li>这是反范式设计<strong>最大的挑战</strong>。当冗余数据发生变更时（例如，产品名称从“iPhone 13”修改为“iPhone 13 Pro”），必须<strong>同时更新所有</strong>存储了该冗余数据的表和行。</li>
<li><strong>更新异常</strong>：如果只更新了产品主表而忘记更新订单表中的冗余字段，就会导致数据不一致。</li>
<li>这增加了应用程序在数据插入（<code>INSERT</code>）、更新（<code>UPDATE</code>）和删除（<code>DELETE</code>）时的复杂性，通常需要通过<strong>事务、触发器或应用层逻辑</strong>来保证所有冗余数据同步更新。</li>
</ul>
</li>
<li><strong>维护成本增加</strong>：<ul>
<li>数据库的结构变得不那么“纯粹”，业务逻辑的耦合度增加，后期维护和修改的复杂度也会相应提高。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-3-4-常见的反范式设计技术与实例"><a href="#1-3-4-常见的反范式设计技术与实例" class="headerlink" title="1.3.4 常见的反范式设计技术与实例"></a>1.3.4 常见的反范式设计技术与实例</h4><h5 id="1-增加冗余字段-Adding-Redundant-Fields"><a href="#1-增加冗余字段-Adding-Redundant-Fields" class="headerlink" title="1.增加冗余字段 (Adding Redundant Fields)"></a>1.<strong>增加冗余字段 (Adding Redundant Fields)</strong></h5><p>这是最常用的一种技术。将经常需要通过 JOIN 查询的字段，直接冗余到主表中。</p>
<ul>
<li><p><strong>范式化设计</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 订单表 (Orders)</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    order_date <span class="type">DATE</span>,</span><br><span class="line">    customer_id <span class="type">INT</span>, <span class="comment">-- 外键</span></span><br><span class="line">    ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 客户表 (Customers)</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> customers (</span><br><span class="line">    customer_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    customer_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查询订单及客户名：<code>SELECT o.order_id, c.customer_name FROM orders o JOIN customers c ON o.customer_id = c.customer_id;</code></p>
</li>
<li><p><strong>反范式设计</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 订单表 (Orders)</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    order_date <span class="type">DATE</span>,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    customer_name <span class="type">VARCHAR</span>(<span class="number">50</span>), <span class="comment">-- 冗余字段</span></span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查询订单及客户名：<code>SELECT order_id, customer_name FROM orders;</code> <strong>（无需 JOIN，性能大幅提升）</strong></p>
</li>
<li><p><strong>代价</strong>：当客户修改姓名时，除了要更新 <code>customers</code> 表，还必须更新该客户所有历史订单中的 <code>customer_name</code> 字段（虽然在很多业务中，历史订单的快照信息是不需要更新的）。</p>
</li>
</ul>
<hr>
<h5 id="2-创建汇总-派生表-Creating-Summary-Derived-Tables"><a href="#2-创建汇总-派生表-Creating-Summary-Derived-Tables" class="headerlink" title="2. 创建汇总&#x2F;派生表 (Creating Summary&#x2F;Derived Tables)"></a>2. 创建汇总&#x2F;派生表 (Creating Summary&#x2F;Derived Tables)</h5><p>对于需要频繁进行聚合计算（如 <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>）的场景，可以预先计算好结果并存储在一张汇总表中。</p>
<ul>
<li><p><strong>场景</strong>：一个论坛需要显示每个帖子的回复数量。</p>
</li>
<li><p><strong>范式化做法</strong>：每次显示帖子时，执行 <code>SELECT COUNT(*) FROM replies WHERE post_id = ?;</code>。当回复量巨大时，此操作非常耗时。</p>
</li>
<li><p><strong>反范式做法</strong>：在 <code>posts</code> 表中增加一个 <code>reply_count</code> 字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> posts (</span><br><span class="line">    post_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    content TEXT,</span><br><span class="line">    reply_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="comment">-- 汇总字段</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>操作</strong>：每当有新回复插入时，通过触发器或在应用层逻辑中，对 <code>posts</code> 表的 <code>reply_count</code> 执行 <code>+1</code> 操作。删除回复时则 <code>-1</code>。</li>
<li><strong>查询</strong>：直接从 <code>posts</code> 表读取 <code>reply_count</code> 即可，速度极快。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-重新组合表-Re-combining-Tables"><a href="#3-重新组合表-Re-combining-Tables" class="headerlink" title="3. 重新组合表 (Re-combining Tables)"></a>3. 重新组合表 (Re-combining Tables)</h5><p>如果两张表总是一起被查询（例如严格的 1:1 关系），并且拆分它们并没有带来明显的好处，可以考虑将它们合并，以消除 JOIN。</p>
<ul>
<li><strong>场景</strong>：<code>users</code> 表和 <code>user_profiles</code> 表，其中 <code>user_profiles</code> 存放用户的简介、头像等信息。</li>
<li><strong>反范式做法</strong>：如果系统每次获取用户信息时都必然要获取其简介和头像，那么可以将这两个表合并成一个 <code>users</code> 表。</li>
</ul>
<hr>
<h4 id="1-3-5-反范式设计的风险与权衡"><a href="#1-3-5-反范式设计的风险与权衡" class="headerlink" title="1.3.5 反范式设计的风险与权衡"></a>1.3.5 反范式设计的风险与权衡</h4><ul>
<li><p><strong>数据一致性维护</strong>：这是最大的挑战。由于数据冗余，你需要额外的机制（如应用层代码、触发器、定时任务）来保证所有副本数据的一致性。这个过程增加了系统的复杂性，也可能引入 bug。</p>
</li>
<li><p><strong>写操作开销增加</strong>：原来只需要更新一张表的一个字段，现在可能需要更新多张表或多个字段，导致写操作的性能下降，逻辑也更复杂。</p>
</li>
<li><p><strong>存储空间增加</strong>：冗余数据会占用更多的磁盘空间。不过在当今硬件成本下，这通常是次要考虑因素。</p>
</li>
</ul>
<p><strong>黄金法则</strong></p>
<blockquote>
<p><strong>先范式化，后反范式化 (Normalize First, Denormalize Later)</strong></p>
</blockquote>
<p>一个稳健的数据库设计流程应该是：</p>
<ol>
<li><strong>首先</strong>，严格按照三大范式进行逻辑设计，得到一个清晰、规范、无冗余的数据库模型。</li>
<li><strong>然后</strong>，在开发和测试阶段，通过性能分析工具（如慢查询日志、<code>EXPLAIN</code>）找出性能瓶颈所在的查询。</li>
<li><strong>最后</strong>，针对性地对这些瓶颈进行优化。如果索引优化等手段已无法满足需求，再审慎地、局部地引入反范式设计。</li>
</ol>
<hr>
<h3 id="1-4-命名规范"><a href="#1-4-命名规范" class="headerlink" title="1.4 命名规范"></a>1.4 命名规范</h3><h4 id="1-4-1-通用核心原则"><a href="#1-4-1-通用核心原则" class="headerlink" title="1.4.1 通用核心原则"></a>1.4.1 通用核心原则</h4><ol>
<li><strong>可读性与意义性 (Readability &amp; Meaningfulness)</strong>：名称应清晰、易于理解，能准确描述其代表的实体或功能。避免使用无意义的缩写或模糊的名称（如 <code>a1</code>, <code>temp_table</code>）。</li>
<li><strong>一致性 (Consistency)</strong>：在整个项目或团队中，遵循同一套命名标准。例如，要么都用单数，要么都用复数；要么都用蛇形命名法，要么都用驼峰命名法。</li>
<li><strong>避免使用关键字 (Avoid Keywords)</strong>：不要使用 SQL 的保留关键字作为名称（如 <code>SELECT</code>, <code>TABLE</code>, <code>GROUP</code>, <code>ORDER</code>）。如果必须使用，请用引号&#96;&#96;&#96;&#96;或<code>[]</code>括起来，但这通常是不推荐的做法。</li>
<li><strong>使用英文单词 (Use English)</strong>：在专业开发中，强烈推荐使用英文。避免使用拼音或中英混合，这会给不同文化背景的协作者带来困扰。</li>
<li><strong>大小写策略 (Casing Strategy)</strong>：推荐统一使用 <strong>小写字母</strong>。因为某些数据库（如 Windows 上的 MySQL）不区分大小写，而另一些（如 Linux 上的 MySQL）则默认区分。全部使用小写可以避免因环境不同导致的问题。</li>
<li><strong>分隔符 (Delimiter)</strong>：推荐使用下划线 <code>_</code> 作为单词间的分隔符（即 <strong>蛇形命名法, snake_case</strong>），因为它在 SQL 中具有最好的可读性和兼容性。不推荐使用连字符 <code>-</code>，因为它在 SQL 中通常被解析为减号。</li>
</ol>
<hr>
<h4 id="1-4-2-具体对象命名规范"><a href="#1-4-2-具体对象命名规范" class="headerlink" title="1.4.2 具体对象命名规范"></a>1.4.2 具体对象命名规范</h4><h4 id="1-4-1-数据库-Database"><a href="#1-4-1-数据库-Database" class="headerlink" title="1.4.1 数据库 (Database)"></a>1.4.1 数据库 (Database)</h4><ul>
<li><strong>格式</strong>: <code>项目名_环境标识</code></li>
<li><strong>说明</strong>:<ul>
<li>使用项目或应用的名称作为前缀。</li>
<li>使用环境后缀（如 <code>_dev</code>, <code>_test</code>, <code>_prod</code>）来区分开发、测试和生产环境。</li>
</ul>
</li>
<li><strong>示例</strong>:<ul>
<li><code>my_project_dev</code></li>
<li><code>erp_system_test</code></li>
<li><code>main_website_prod</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-4-2-表-Table"><a href="#1-4-2-表-Table" class="headerlink" title="1.4.2 表 (Table)"></a>1.4.2 表 (Table)</h4><ul>
<li><strong>格式</strong>: <code>[业务模块_]名词复数</code> 或 <code>[业务模块_]名词单数</code></li>
<li><strong>说明</strong>:<ul>
<li><strong>单数 vs 复数 (Singular vs. Plural)</strong>：这是一个经典争论。<ul>
<li><strong>推荐使用复数 (Plural)</strong>：如 <code>users</code>, <code>products</code>, <code>orders</code>。这更符合自然语言的直觉（”SELECT … FROM users” 读起来像 “从用户们中查询”）。大多数现代框架（如 Rails, Django）也推荐复数形式。</li>
<li><strong>单数 (Singular)</strong>：如 <code>user</code>, <code>product</code>, <code>order</code>。这种观点认为表是单个实体的蓝图或集合。</li>
<li><strong>关键在于团队统一</strong>。如果非要选一个，<strong>复数</strong>是更主流的选择。</li>
</ul>
</li>
<li><strong>前缀 (Prefix)</strong>：<ul>
<li>通常 <strong>不推荐</strong> 为表添加 <code>tbl_</code> 或 <code>t_</code> 这样的前缀，因为这增加了冗余，现代 IDE 都能轻松区分对象类型。</li>
<li>如果项目模块划分清晰，可以使用业务模块作为前缀，用下划线分隔。例如，用户中心的表可以命名为 <code>uc_users</code>。</li>
</ul>
</li>
<li><strong>关联表&#x2F;中间表 (Junction Table)</strong>：对于多对多关系的中间表，将两个关联的表名按字母顺序组合。</li>
</ul>
</li>
<li><strong>示例</strong>:<ul>
<li><code>users</code> (用户信息表)</li>
<li><code>products</code> (产品表)</li>
<li><code>order_details</code> (订单详情表)</li>
<li><code>roles_users</code> (角色与用户的关联表，<code>roles</code> 在 <code>users</code> 前)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-4-3-字段-列-Column-Field"><a href="#1-4-3-字段-列-Column-Field" class="headerlink" title="1.4.3 字段&#x2F;列 (Column &#x2F; Field)"></a>1.4.3 字段&#x2F;列 (Column &#x2F; Field)</h4><ul>
<li><strong>格式</strong>: <code>名词</code> 或 <code>形容词_名词</code></li>
<li><strong>命名法</strong>: 强制使用 <strong>蛇形命名法 (snake_case)</strong>。</li>
<li><strong>说明</strong>:<ul>
<li><strong>通用字段</strong>: 名称应清晰描述字段内容。<ul>
<li>示例: <code>first_name</code>, <code>email_address</code>, <code>last_login_ip</code></li>
</ul>
</li>
<li><strong>主键 (Primary Key)</strong>:<ul>
<li>推荐直接使用 <code>id</code>。这非常简洁，并且是许多 ORM 框架的默认约定。</li>
<li>或者使用 <code>表名单数_id</code> 的形式，如 <code>user_id</code>，在多表连接时更具可读性。</li>
</ul>
</li>
<li><strong>外键 (Foreign Key)</strong>:<ul>
<li><strong>标准格式</strong>: <code>关联表名词单数_id</code>。这是 <strong>极其重要</strong> 的规范。</li>
<li>例如，在 <code>orders</code> 表中，关联 <code>users</code> 表的外键应命名为 <code>user_id</code>。这样任何人看到 <code>user_id</code> 字段，都能立刻明白它指向 <code>users</code> 表的 <code>id</code>。</li>
</ul>
</li>
<li><strong>布尔值 (Boolean)</strong>:<ul>
<li>使用 <code>is_</code> 或 <code>has_</code> 作为前缀，使其在 <code>WHERE</code> 子句中非常易读。</li>
<li>示例: <code>is_active</code>, <code>is_deleted</code>, <code>has_license</code></li>
</ul>
</li>
<li><strong>时间&#x2F;日期 (Date&#x2F;Time)</strong>:<ul>
<li>使用 <code>_at</code> 或 <code>_time</code> 作为后缀表示精确时间点。</li>
<li>使用 <code>_date</code> 作为后缀表示日期。</li>
<li>示例: <code>created_at</code>, <code>updated_at</code>, <code>login_at</code>, <code>publish_date</code></li>
</ul>
</li>
<li><strong>避免字段前缀</strong>: 不要使用 <code>col_</code> 或其他无意义的前缀。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-4-4-视图-View"><a href="#1-4-4-视图-View" class="headerlink" title="1.4.4 视图 (View)"></a>1.4.4 视图 (View)</h4><ul>
<li><strong>格式</strong>: <code>v_</code> 或 <code>vw_</code> + <code>描述性名称</code></li>
<li><strong>说明</strong>: 使用前缀 <code>v_</code> (view) 或 <code>vw_</code> (view) 来明确标识这是一个视图，以便与表区分开。</li>
<li><strong>示例</strong>:<ul>
<li><code>v_active_users</code> (活跃用户视图)</li>
<li><code>vw_product_sales_summary</code> (产品销售汇总视图)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-4-5-索引-Index"><a href="#1-4-5-索引-Index" class="headerlink" title="1.4.5 索引 (Index)"></a>1.4.5 索引 (Index)</h4><ul>
<li><strong>格式</strong>: <code>idx_表名_字段名</code> 或 <code>uk_表名_字段名</code></li>
<li><strong>说明</strong>:<ul>
<li><code>idx_</code> (index) 用于普通索引。</li>
<li><code>uk_</code> (unique key) 或 <code>uidx_</code> 用于唯一索引。</li>
<li>名称中包含表名和列名，可以快速定位索引的作用。如果索引包含多个列，可以将它们都列出。</li>
</ul>
</li>
<li><strong>示例</strong>:<ul>
<li><code>idx_users_email</code> (在 <code>users</code> 表的 <code>email</code> 字段上的索引)</li>
<li><code>uk_users_username</code> (在 <code>users</code> 表的 <code>username</code> 字段上的唯一索引)</li>
<li><code>idx_orders_user_id_created_at</code> (在 <code>orders</code> 表上的联合索引)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-4-6-约束-Constraint"><a href="#1-4-6-约束-Constraint" class="headerlink" title="1.4.6 约束 (Constraint)"></a>1.4.6 约束 (Constraint)</h4><ul>
<li><strong>格式</strong>: <code>类型前缀_表名_字段名</code></li>
<li><strong>说明</strong>: 为约束明确命名，便于后期管理和调试。<ul>
<li><code>pk_</code> (Primary Key): 主键约束</li>
<li><code>fk_</code> (Foreign Key): 外键约束</li>
<li><code>chk_</code> (Check): 检查约束</li>
<li><code>uq_</code> (Unique): 唯一约束（同唯一索引）</li>
</ul>
</li>
<li><strong>示例</strong>:<ul>
<li><code>pk_users</code> (users 表的主键)</li>
<li><code>fk_orders_user_id</code> (orders 表关联 users 表的外键)</li>
<li><code>chk_products_price</code> (检查 products 表 price 字段的约束)</li>
<li><code>uq_users_email</code> (users 表 email 字段的唯一约束)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-4-7-存储过程-Stored-Procedure"><a href="#1-4-7-存储过程-Stored-Procedure" class="headerlink" title="1.4.7 存储过程 (Stored Procedure)"></a>1.4.7 存储过程 (Stored Procedure)</h4><ul>
<li><strong>格式</strong>: <code>usp_动词_名词</code> 或 <code>sp_动词_名词</code></li>
<li><strong>说明</strong>:<ul>
<li>使用前缀 <code>usp_</code> (user stored procedure) 或 <code>sp_</code>。<strong>注意</strong>：在 SQL Server 中，<code>sp_</code> 是系统存储过程的前缀，为避免冲突和性能问题，推荐使用 <code>usp_</code>。</li>
<li>采用 “动词+名词” 结构，清晰描述其功能。</li>
</ul>
</li>
<li><strong>示例</strong>:<ul>
<li><code>usp_get_user_by_id</code></li>
<li><code>usp_update_order_status</code></li>
<li><code>usp_archive_old_logs</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-4-8-触发器-Trigger"><a href="#1-4-8-触发器-Trigger" class="headerlink" title="1.4.8 触发器 (Trigger)"></a>1.4.8 触发器 (Trigger)</h4><ul>
<li><strong>格式</strong>: <code>trg_表名_时机_事件</code></li>
<li><strong>说明</strong>:<ul>
<li>前缀 <code>trg_</code> (trigger)。</li>
<li>包含表名、触发时机（<code>before</code>, <code>after</code>）和触发事件（<code>insert</code>, <code>update</code>, <code>delete</code>）。</li>
</ul>
</li>
<li><strong>示例</strong>:<ul>
<li><code>trg_users_after_update</code></li>
<li><code>trg_order_details_before_insert</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-事务与并发控制"><a href="#2-事务与并发控制" class="headerlink" title="2. 事务与并发控制"></a>2. 事务与并发控制</h2><h3 id="2-1-事务的四大特性-ACID"><a href="#2-1-事务的四大特性-ACID" class="headerlink" title="2.1 事务的四大特性 (ACID)"></a>2.1 事务的四大特性 (ACID)</h3><h4 id="2-1-1-A-原子性-Atomicity"><a href="#2-1-1-A-原子性-Atomicity" class="headerlink" title="2.1.1 A - 原子性 (Atomicity)"></a>2.1.1 A - 原子性 (Atomicity)</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>原子性指事务是一个<strong>不可分割</strong>的工作单元。事务中的所有操作，要么全部成功提交，要么全部失败回滚。</p>
<p><strong>通俗解释</strong>：“<strong>要么不做，要么做全套</strong>”。</p>
<p><strong>银行转账示例</strong>：</p>
<p>转账操作包含“A 减钱”和“B 加钱”。</p>
<ul>
<li><strong>成功情况</strong>：两个操作都成功执行，事务提交，转账完成。</li>
<li><strong>失败情况</strong>：在“A 减钱”成功后，系统突然崩溃，导致“B 加钱”未能执行。此时，由于原子性的保证，整个事务会<strong>自动回滚 (Rollback)</strong>，系统会将“A 减钱”的操作撤销，A 的账户余额将恢复到转账前的状态。最终结果是，转账失败，数据库回到初始状态，资金没有损失。</li>
</ul>
<p><strong>MySQL (InnoDB) 如何保证</strong>：</p>
<p>主要通过 <strong>Undo Log (撤销日志)</strong> 来实现。当事务对数据进行修改时，InnoDB 会在 Undo Log 中记录下修改前的旧数据。如果事务需要回滚，系统就可以利用 Undo Log 中的信息将数据恢复到事务开始前的状态。</p>
<hr>
<h4 id="2-1-2-C-一致性-Consistency"><a href="#2-1-2-C-一致性-Consistency" class="headerlink" title="2.1.2 C - 一致性 (Consistency)"></a>2.1.2 C - 一致性 (Consistency)</h4><p><strong>定义</strong>：</p>
<p>一致性指事务的执行不能破坏数据库的<strong>完整性约束</strong>。一个事务必须使数据库从一个<strong>一致性状态</strong>转变到另一个<strong>一致性状态</strong>。</p>
<p><strong>通俗解释</strong>：</p>
<p>“<strong>账得是平的</strong>”。事务的执行结果必须是符合所有预设规则和约束的。这些规则可以是数据库层面的（如字段类型、非空约束、唯一键、外键），也可以是业务层面的（如银行账户余额不能为负数）。</p>
<p><strong>银行转账示例</strong>：</p>
<p>假设银行系统有一个业务规则：所有账户的总金额在任何转账操作后都应该保持不变。</p>
<ul>
<li><strong>一致的状态</strong>：转账前，A 有 1000 元，B 有 500 元，总额 1500 元。</li>
<li><strong>事务执行</strong>：A 转 100 元给 B。</li>
<li><strong>另一个一致的状态</strong>：转账后，A 有 900 元，B 有 600 元，总额仍然是 1500 元。数据库状态是有效的、一致的。</li>
<li><strong>不一致的场景</strong>：如果因程序 Bug，导致 A 减了 100 元，B 却加了 110 元，总额变为 1510 元，这就破坏了一致性。数据库不允许这样的事务提交。</li>
</ul>
<p><strong>重要说明</strong></p>
<p>一致性是事务的最终<strong>目标</strong>。原子性、隔离性和持久性这三个特性，都是为了保证一致性而存在的<strong>技术手段</strong>。</p>
<hr>
<h4 id="2-1-3-I-隔离性-Isolation"><a href="#2-1-3-I-隔离性-Isolation" class="headerlink" title="2.1.3  I - 隔离性 (Isolation)"></a>2.1.3  I - 隔离性 (Isolation)</h4><p><strong>定义</strong>：</p>
<p>隔离性指多个并发事务之间应该<strong>相互隔离</strong>，互不干扰。一个事务的执行不应被其他并发事务的执行所影响。从某个事务的角度看，它就好像是系统中唯一运行的事务。</p>
<p><strong>通俗解释</strong>：</p>
<p>“<strong>各干各的，互不打扰</strong>”。当多个人同时操作数据库时，数据库要保证他们每个人都感觉自己是在独立操作，看不到别人操作到一半的数据。</p>
<p><strong>银行转账示例</strong>：</p>
<p>假设 A 的账户有 1000 元。</p>
<ul>
<li><strong>事务 T1</strong>：A 向 B 转账 100 元。</li>
<li><strong>事务 T2</strong>：另一个程序正在查询银行所有账户的总额。</li>
</ul>
<p>如果没有隔离性，T2 在 T1 执行“A 减钱”之后、“B 加钱”之前进行查询，就会发现总额少了 100 元，得到了一个错误的、临时的“脏数据”。</p>
<p>隔离性保证了 T2 要么在 T1 <strong>开始之前</strong>查询（看到 A 有 1000 元），要么在 T1 <strong>提交之后</strong>查询（看到 A 有 900 元），而不会看到 T1 执行过程中的中间状态。</p>
<p><strong>MySQL (InnoDB) 如何保证</strong>：</p>
<p>主要通过 <strong>锁机制 (Locking)</strong> 和 <strong>多版本并发控制 (MVCC - Multi-Version Concurrency Control)</strong> 来实现。通过对数据加锁，防止其他事务同时修改。而 MVCC 则通过为数据行保存多个历史版本，使得读操作不会被写操作阻塞，从而在不加锁或少加锁的情况下实现高效的并发读。隔离性的强度分为多个<strong>隔离级别</strong>（将在 <code>2.3 节</code> 详细讨论）。</p>
<hr>
<h4 id="2-1-4-D-持久性-Durability"><a href="#2-1-4-D-持久性-Durability" class="headerlink" title="2.1.4 D - 持久性 (Durability)"></a>2.1.4 D - 持久性 (Durability)</h4><p><strong>定义</strong>：</p>
<p>持久性指一旦事务成功<strong>提交 (Commit)</strong>，它对数据库的修改就是<strong>永久性</strong>的。即使随后发生系统崩溃（如断电、服务器宕机），这些修改也不会丢失。</p>
<p><strong>通俗解释</strong>：</p>
<p>“<strong>一诺千金，板上钉钉</strong>”。只要系统告诉你“操作成功”，那这个结果就一定被永久保存下来了，无论发生什么意外。</p>
<p><strong>银行转账示例</strong>：</p>
<p>A 向 B 转账 100 元的事务成功提交后，系统提示“转账成功”。就在此时，银行服务器机房突然断电。当服务器重启后，A 的账户必须显示为 900 元，B 的账户必须显示为 600 元。这个已经提交的转账结果不能因为断电而丢失。</p>
<p><strong>MySQL (InnoDB) 如何保证</strong>：主要通过 <strong>Redo Log (重做日志)</strong> 来实现。当事务提交时，InnoDB 会先将事务的所有修改操作写入到 Redo Log 文件中，并确保 Redo Log 已落盘。这个过程称为<strong>预写式日志 (Write-Ahead Logging, WAL)</strong>。即使数据还没来得及写入磁盘中的数据文件（因为随机 I&#x2F;O 很慢），只要 Redo Log（顺序 I&#x2F;O，很快）写入成功，事务就被视为已提交。当系统崩溃后重启时，InnoDB 会检查 Redo Log，将那些已经提交但尚未完全写入数据文件的事务重新执行一遍，从而保证了数据的持久性。</p>
<hr>
<h3 id="2-2-并发问题"><a href="#2-2-并发问题" class="headerlink" title="2.2 并发问题"></a>2.2 并发问题</h3><h4 id="2-2-1-脏读-Dirty-Read"><a href="#2-2-1-脏读-Dirty-Read" class="headerlink" title="2.2.1 脏读 (Dirty Read)"></a>2.2.1 脏读 (Dirty Read)</h4><p><strong>定义</strong>：</p>
<p>一个事务（T1）读取到了另一个并发事务（T2）<strong>已经修改但尚未提交</strong>的数据。如果 T2 最终<strong>回滚 (Rollback)</strong> 而不是提交，那么 T1 读取到的数据就是“脏”的、无效的、从未正式存在过的数据。</p>
<p><strong>场景示例</strong>：</p>
<p>还是银行转账的例子，A 有 1000 元。</p>
<ol>
<li><strong>事务 T1 开始</strong>：A 准备给 B 转账 100 元。T1 执行 <code>UPDATE accounts SET balance = 900 WHERE name = &#39;A&#39;;</code>。（此时事务 T1 <strong>未提交</strong>）</li>
<li><strong>事务 T2 开始</strong>：T2 读取 A 的账户余额，读到了 900 元。T2 可能基于这个数据进行其他操作，比如认为 A 的余额充足。</li>
<li><strong>事务 T1 发生错误</strong>：由于某种原因（比如 B 账户不存在），T1 <strong>回滚</strong>了。数据库恢复 A 的余额到 1000 元。</li>
<li><strong>问题</strong>：事务 T2 读取并可能使用了 900 元这个“脏”数据，而这个数据在数据库中从未被正式确认过。这会导致业务逻辑上的严重错误。</li>
</ol>
<p><strong>危害</strong>：数据极度不可靠，可能导致基于临时、错误数据的业务决策。这是最严重的数据一致性问题，在任何生产环境中都应避免。</p>
<hr>
<h4 id="2-2-2-不可重复读-Non-Repeatable-Read"><a href="#2-2-2-不可重复读-Non-Repeatable-Read" class="headerlink" title="2.2.2 不可重复读 (Non-Repeatable Read)"></a>2.2.2 不可重复读 (Non-Repeatable Read)</h4><p><strong>定义</strong>：</p>
<p>一个事务（T1）内，对<strong>同一行数据</strong>先后执行了两次或多次查询，但在这期间，另一个并发事务（T2）<strong>修改了这行数据并提交了</strong>，导致 T1 的两次查询结果不一致。</p>
<p><strong>场景示例</strong>：</p>
<p>HR 小王正在处理员工薪资。</p>
<ol>
<li><strong>事务 T1 开始</strong>：小王查询员工 Bob 的薪资，结果为 5000 元。她基于 5000 元开始计算奖金。</li>
<li><strong>事务 T2 开始</strong>：财务部门对 Bob 的薪资进行了调整，执行 <code>UPDATE employees SET salary = 6000 WHERE name = &#39;Bob&#39;;</code> 并<strong>提交</strong>。</li>
<li><strong>事务 T1 继续</strong>：小王为了核对，再次查询 Bob 的薪资，结果变成了 6000 元。</li>
<li><strong>问题</strong>：在 T1 这个单一的业务流程（事务）中，前后两次读取到的同一条记录竟然不同，导致小王的数据前后矛盾，无法完成一致性的计算。</li>
</ol>
<p><strong>核心</strong>：不可重复读的重点在于<strong>修改 (UPDATE)</strong> 或 <strong>删除 (DELETE)</strong>。你回头去读“刚才读过的那条记录”，发现它变了或者没了。</p>
<hr>
<h4 id="2-2-3-幻读-Phantom-Read"><a href="#2-2-3-幻读-Phantom-Read" class="headerlink" title="2.2.3 幻读 (Phantom Read)"></a>2.2.3 幻读 (Phantom Read)</h4><p><strong>定义</strong>：</p>
<p>一个事务（T1）内，按照<strong>某个范围条件</strong>执行了两次或多次查询，但在这期间，另一个并发事务（T2）<strong>插入 (INSERT) 或删除了</strong>符合该范围条件的新数据并提交了，导致 T1 的两次查询返回的<strong>结果集行数不一致</strong>。那些“凭空”出现或消失的行，就像幻影一样，因此称为幻读。</p>
<p><strong>场景示例</strong>：</p>
<p>一个财务系统正在统计某部门（如 ‘Sales’）的总人数。</p>
<ol>
<li><strong>事务 T1 开始</strong>：系统执行 <code>SELECT COUNT(*) FROM employees WHERE department = &#39;Sales&#39;;</code>，得到结果为 20 人。</li>
<li><strong>事务 T2 开始</strong>：HR 部门恰好录入了一名新的销售员工，执行 <code>INSERT INTO employees (name, department) VALUES (&#39;Charlie&#39;, &#39;Sales&#39;);</code> 并<strong>提交</strong>。</li>
<li><strong>事务 T1 继续</strong>：系统为了后续操作，再次执行了同样的查询 <code>SELECT * FROM employees WHERE department = &#39;Sales&#39;;</code>，这次却返回了 21 条记录。</li>
<li><strong>问题</strong>：在 T1 看来，明明刚刚才确认过只有 20 人，现在却多出来一个“幻影”员工，导致后续的批量操作或者统计逻辑出现偏差。</li>
</ol>
<p><strong>不可重复读 vs. 幻读：关键区别</strong></p>
<p>这是一个常见的混淆点，务必区分清楚：</p>
<ul>
<li><strong>不可重复读</strong>：侧重于<strong>单行数据的值被修改</strong>。你第一次读和第二次读，是<strong>同一条记录</strong>，但它的内容变了。<ul>
<li><strong>关键词</strong>：<code>UPDATE</code>, <code>DELETE</code>，值变了。</li>
</ul>
</li>
<li><strong>幻读</strong>：侧重于<strong>一个范围内的记录行数发生变化</strong>。你第二次查询发现结果集里多了一些“新”的记录，或者少了一些记录。<ul>
<li><strong>关键词</strong>：<code>INSERT</code>，行数变了。</li>
</ul>
</li>
</ul>
<p><strong>一个比喻</strong>：</p>
<ul>
<li><strong>不可重复读</strong>：你第一次读一本书的第 10 页，上面写着“MySQL 很简单”。过了一会儿你再读第 10 页，发现被别人改成“MySQL 有点难”了。</li>
<li><strong>幻读</strong>：你第一次数书架上关于“数据库”的书，有 5 本。过了一会儿你再数，发现有人新放了一本进来，现在有 6 本了。</li>
</ul>
<hr>
<h4 id="2-2-4-更新丢失-Lost-Update"><a href="#2-2-4-更新丢失-Lost-Update" class="headerlink" title="2.2.4 更新丢失 (Lost Update)"></a>2.2.4 更新丢失 (Lost Update)</h4><p>虽然这个概念有时不与前三者并列，但它也是一个核心的并发问题。</p>
<p><strong>定义</strong>：</p>
<p>当两个或多个事务选择同一行数据，然后基于最初选定的值进行计算和更新时，由于每个事务都不知道其他事务的存在，就会导致最后的更新覆盖了前面的更新，造成数据丢失。</p>
<p><strong>场景示例</strong>：</p>
<p>商品库存管理，某商品仅剩 1 件库存。</p>
<ol>
<li><strong>用户 A</strong> (事务 T1) 读取商品库存为 1。</li>
<li><strong>用户 B</strong> (事务 T2) 几乎同时读取该商品库存，也为 1。</li>
<li><strong>用户 A</strong> 完成购买，系统执行 <code>UPDATE products SET stock = stock - 1;</code> (即 1 - 1 &#x3D; 0)，并<strong>提交</strong>。此时库存变为 0。</li>
<li><strong>用户 B</strong> 也完成购买，系统也执行 <code>UPDATE products SET stock = stock - 1;</code> (也是 1 - 1 &#x3D; 0)，并<strong>提交</strong>。库存最终还是 0。</li>
<li><strong>问题</strong>：一件商品被卖了两次，用户 A 的更新操作被用户 B 的更新操作覆盖了，这就是“更新丢失”。</li>
</ol>
<p><strong>解决方案</strong>：</p>
<p>现代数据库通常通过<strong>加锁机制</strong>来解决这个问题。当 T1 读取并准备更新库存时，会对该行数据加一个<strong>排他锁</strong>，T2 此时无法读取或修改，必须等待 T1 提交或回滚后才能继续。这样就保证了操作的串行性，避免了更新丢失。</p>
<hr>
<h3 id="2-3-事务隔离级别"><a href="#2-3-事务隔离级别" class="headerlink" title="2.3 事务隔离级别"></a>2.3 事务隔离级别</h3><h4 id="2-3-1-概念"><a href="#2-3-1-概念" class="headerlink" title="2.3.1 概念"></a>2.3.1 概念</h4><p>在上一节我们讨论了并发环境下可能出现的<strong>脏读、不可重复读、幻读</strong>等问题。事务的<strong>隔离性 (Isolation)</strong> 就是为了解决这些问题。</p>
<p>然而，隔离的强度与系统的并发性能是相互矛盾的。</p>
<ul>
<li><strong>隔离性越强</strong>：数据一致性越高，越能避免并发问题，但事务之间需要互相等待（通过加锁等机制），<strong>并发性能就越差</strong>。</li>
<li><strong>隔离性越弱</strong>：事务之间干扰越少，并发性能就越好，但可能引发的<strong>并发问题就越多</strong>。</li>
</ul>
<p>为了让开发者能够在<strong>性能</strong>和<strong>一致性</strong>之间做出权衡，SQL 标准定义了四种不同的事务隔离级别。开发者可以根据具体的业务场景需求，选择最合适的级别。</p>
<hr>
<h4 id="2-3-2-四大隔离级别（从低到高）"><a href="#2-3-2-四大隔离级别（从低到高）" class="headerlink" title="2.3.2 四大隔离级别（从低到高）"></a>2.3.2 四大隔离级别（从低到高）</h4><h5 id="1-读未提交-Read-Uncommitted"><a href="#1-读未提交-Read-Uncommitted" class="headerlink" title="1. 读未提交 (Read Uncommitted)"></a>1. 读未提交 (Read Uncommitted)</h5><ul>
<li><strong>定义</strong>：最低的隔离级别。一个事务可以读取到其他事务<strong>尚未提交</strong>的修改。</li>
<li><strong>解决了什么问题</strong>：无。</li>
<li><strong>存在什么问题</strong>：<strong>脏读 (Dirty Read)</strong>、<strong>不可重复读 (Non-Repeatable Read)</strong>、<strong>幻读 (Phantom Read)</strong>。</li>
<li><strong>工作方式</strong>：读取数据时不加任何锁，因此性能最高，但数据一致性最差。</li>
<li><strong>应用场景</strong>：几乎从不用于实际生产环境。只可能在一些对数据一致性要求极低，且追求极致性能的报表统计类应用中考虑。</li>
</ul>
<p><strong>示例（脏读）</strong>：</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">事务 A (ID:1, 等级: 读未提交)</th>
<th align="left">事务 B (ID:2)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left"><code>START TRANSACTION;</code></td>
<td align="left"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left"></td>
<td align="left"><code>UPDATE products SET stock=99 WHERE id=1;</code></td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left"><code>SELECT stock FROM products WHERE id=1;</code> <strong>(结果: 99)</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left"></td>
<td align="left"><code>ROLLBACK;</code> (操作撤销)</td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left"><code>SELECT stock FROM products WHERE id=1;</code> <strong>(结果: 100)</strong></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>在 T3，事务 A 读到了事务 B 未提交的临时数据 <code>99</code>，这就是脏读。</p>
<hr>
<h5 id="2-读已提交-Read-Committed"><a href="#2-读已提交-Read-Committed" class="headerlink" title="2. 读已提交 (Read Committed)"></a>2. 读已提交 (Read Committed)</h5><ul>
<li><strong>定义</strong>：一个事务只能读取到其他事务<strong>已经提交</strong>的数据。</li>
<li><strong>解决了什么问题</strong>：<strong>脏读 (Dirty Read)</strong>。</li>
<li><strong>存在什么问题</strong>：<strong>不可重复读 (Non-Repeatable Read)</strong>、<strong>幻读 (Phantom Read)</strong>。</li>
<li><strong>工作方式 (InnoDB)</strong>：通过 MVCC (多版本并发控制) 实现。每次 <code>SELECT</code> 都会生成一个新的 Read View (读视图&#x2F;快照)，确保只能看到已提交版本的数据。</li>
<li><strong>应用场景</strong>：大多数主流数据库（如 Oracle, PostgreSQL）的<strong>默认隔离级别</strong>。在很多业务场景下，它提供了足够的的数据一致性保障和良好的并发性能。</li>
</ul>
<p><strong>示例（不可重复读）</strong>：</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">事务 A (ID:1, 等级: 读已提交)</th>
<th align="left">事务 B (ID:2)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left"><code>START TRANSACTION;</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left"><code>SELECT stock FROM products WHERE id=1;</code> <strong>(结果: 100)</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left"></td>
<td align="left"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left"></td>
<td align="left"><code>UPDATE products SET stock=99 WHERE id=1;</code></td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left"></td>
<td align="left"><code>COMMIT;</code></td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left"><code>SELECT stock FROM products WHERE id=1;</code> <strong>(结果: 99)</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left"><code>COMMIT;</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>在 T2 和 T6，事务 A 内两次读取同一行数据，结果却不一致，这就是不可重复读。</p>
<hr>
<h5 id="3-可重复读-Repeatable-Read"><a href="#3-可重复读-Repeatable-Read" class="headerlink" title="3. 可重复读 (Repeatable Read)"></a>3. 可重复读 (Repeatable Read)</h5><ul>
<li><strong>定义</strong>：在一个事务开始后，多次读取同一行数据，结果保证是一致的。其他事务的修改在该事务提交前，对该事务是不可见的。</li>
<li><strong>解决了什么问题</strong>：<strong>脏读 (Dirty Read)</strong>、<strong>不可重复读 (Non-Repeatable Read)</strong>。</li>
<li><strong>存在什么问题</strong>：标准的 SQL 定义下，仍然存在<strong>幻读 (Phantom Read)</strong>。</li>
<li><strong>工作方式 (InnoDB)</strong>：同样基于 MVCC。关键区别在于，Read View 是在事务<strong>第一次执行 <code>SELECT</code> 语句时</strong>创建的，并且<strong>整个事务期间都复用这同一个 Read View</strong>。</li>
<li><strong>MySQL (InnoDB) 的特别之处</strong>：<br>InnoDB 存储引擎在“可重复读”级别下，通过<strong>间隙锁 (Gap Lock)</strong> 和 <strong>Next-Key Lock</strong> 机制，<strong>在很大程度上解决了幻读问题</strong>。因此，MySQL 的默认隔离级别 <code>Repeatable Read</code> 能够提供比标准定义更强的保护。</li>
<li><strong>应用场景</strong>：这是 <strong>MySQL (InnoDB) 的默认隔离级别</strong>。它在数据一致性和并发性能之间取得了很好的平衡。</li>
</ul>
<p><strong>示例（避免了不可重复读）</strong>：</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">事务 A (ID:1, 等级: 可重复读)</th>
<th align="left">事务 B (ID:2)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left"><code>START TRANSACTION;</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left"><code>SELECT stock FROM products WHERE id=1;</code> <strong>(结果: 100)</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left"></td>
<td align="left"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left"></td>
<td align="left"><code>UPDATE products SET stock=99 WHERE id=1;</code></td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left"></td>
<td align="left"><code>COMMIT;</code></td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left"><code>SELECT stock FROM products WHERE id=1;</code> <strong>(结果: 100)</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left"><code>COMMIT;</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>在 T6，即使事务 B 已经提交了修改，事务 A 凭借其事务开始时创建的快照，依然读取到 <code>100</code>，保证了可重复读。</p>
<hr>
<h5 id="4-可串行化-Serializable"><a href="#4-可串行化-Serializable" class="headerlink" title="4. 可串行化 (Serializable)"></a>4. 可串行化 (Serializable)</h5><ul>
<li><strong>定义</strong>：最高的隔离级别。强制所有事务<strong>串行执行</strong>，即一个接一个地执行，完全避免了并发。</li>
<li><strong>解决了什么问题</strong>：<strong>脏读、不可重复读、幻读</strong>等所有并发问题。</li>
<li><strong>存在什么问题</strong>：无数据一致性问题，但<strong>并发性能极差</strong>。</li>
<li><strong>工作方式 (InnoDB)</strong>：会对所有读取的行都加上<strong>共享锁 (Shared Lock)</strong>。当其他事务尝试修改这些行时，会被阻塞，直到当前事务提交。</li>
<li><strong>应用场景</strong>：用于对数据一致性要求极度严格，且可以接受牺牲性能的场景。例如，涉及银行账户余额的修改、库存的最终确认等关键业务，且并发量不高的操作。</li>
</ul>
<hr>
<h4 id="2-3-3-总结与实践"><a href="#2-3-3-总结与实践" class="headerlink" title="2.3.3 总结与实践"></a>2.3.3 总结与实践</h4><p><strong>隔离级别与并发问题关系总结表</strong>：</p>
<table>
<thead>
<tr>
<th align="left">隔离级别 (Isolation Level)</th>
<th align="left">脏读 (Dirty Read)</th>
<th align="left">不可重复读 (Non-Repeatable Read)</th>
<th align="left">幻读 (Phantom Read)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>读未提交</strong> (Read Uncommitted)</td>
<td align="left">(可能发生)</td>
<td align="left">(可能发生)</td>
<td align="left">(可能发生)</td>
</tr>
<tr>
<td align="left"><strong>读已提交</strong> (Read Committed)</td>
<td align="left">(已解决)</td>
<td align="left">(可能发生)</td>
<td align="left">(可能发生)</td>
</tr>
<tr>
<td align="left"><strong>可重复读</strong> (Repeatable Read)</td>
<td align="left">(已解决)</td>
<td align="left">(已解决)</td>
<td align="left">(基本解决)</td>
</tr>
<tr>
<td align="left"><strong>可串行化</strong> (Serializable)</td>
<td align="left">(已解决)</td>
<td align="left">(已解决)</td>
<td align="left">(已解决)</td>
</tr>
</tbody></table>
<p><em>注：在 MySQL InnoDB 中，由于 Next-Key Lock 机制，幻读问题基本被解决。</em></p>
<p><strong>在 MySQL 中的操作</strong>：</p>
<ol>
<li><p><strong>查看当前隔离级别</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看全局隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.transaction_isolation;</span><br><span class="line"><span class="comment">-- 查看当前会话隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.transaction_isolation;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction_isolation</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置隔离级别</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置全局隔离级别 (对新建立的连接生效)</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置当前会-话隔离级别 (只对当前连接生效)</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 通常我们只在必要时修改会话级别的隔离级别，很少去改动全局设置。MySQL 默认的 <code>REPEATABLE READ</code> 对绝大多数应用来说都是最佳选择。</p>
</li>
</ol>
<hr>
<h3 id="2-4-锁机制"><a href="#2-4-锁机制" class="headerlink" title="2.4 锁机制"></a>2.4 锁机制</h3><h4 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h4><p>在数据库中，<strong>锁 (Lock)</strong> 是一种并发控制机制，用于管理多个事务对共享资源的并发访问。当一个事务需要访问某个资源（如一行数据、一个数据页或一张表）时，它会先尝试获取该资源的锁。如果成功获取，它就可以进行操作；如果资源已被其他不兼容的事务所锁定，那么当前事务就必须<strong>等待</strong>，直到锁被释放。</p>
<hr>
<h4 id="2-4-2-锁的分类"><a href="#2-4-2-锁的分类" class="headerlink" title="2.4.2 锁的分类"></a>2.4.2 锁的分类</h4><h5 id="1-按锁的粒度-Granularity"><a href="#1-按锁的粒度-Granularity" class="headerlink" title="1. 按锁的粒度 (Granularity)"></a>1. 按锁的粒度 (Granularity)</h5><p>锁的粒度指的是锁定的资源范围大小。粒度越大，加锁开销越小，但并发度越低；粒度越小，加锁开销越大，但并发度越高。</p>
<ol>
<li><strong>表锁 (Table Lock)</strong><ul>
<li><strong>特点</strong>：锁定整张数据表。是开销最小、加锁最快的锁。</li>
<li><strong>优点</strong>：实现简单，不会出现死锁。</li>
<li><strong>缺点</strong>：锁定粒度大，并发冲突的概率最高，并发性能最差。</li>
<li><strong>引擎</strong>：<code>MyISAM</code> 存储引擎主要使用表锁。<code>InnoDB</code> 在执行特定 DDL 语句（如 <code>ALTER TABLE</code>）时也会使用表锁。</li>
</ul>
</li>
<li><strong>页锁 (Page Lock)</strong><ul>
<li><strong>特点</strong>：锁定数据库中的一个数据页（Page，通常为 16KB）。</li>
<li><strong>优缺点</strong>：粒度和开销介于表锁和行锁之间，并发度也居中。</li>
<li><strong>引擎</strong>：BDB 存储引擎使用。在 MySQL 中不常用。</li>
</ul>
</li>
<li><strong>行锁 (Row Lock)</strong><ul>
<li><strong>特点</strong>：锁定单行或多行数据。是锁定粒度最小的锁。</li>
<li><strong>优点</strong>：能最大程度地支持并发处理。</li>
<li><strong>缺点</strong>：加锁开销最大，实现复杂，并且可能会出现死锁。</li>
<li><strong>引擎</strong>：<code>InnoDB</code> 存储引擎的<strong>核心特性</strong>。<strong>注意</strong>：InnoDB 的行锁是基于<strong>索引</strong>实现的。如果 SQL 查询没有命中任何索引，行锁可能会退化为表锁。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-按锁的模式-Mode-兼容性"><a href="#2-按锁的模式-Mode-兼容性" class="headerlink" title="2. 按锁的模式 (Mode) &#x2F; 兼容性"></a>2. 按锁的模式 (Mode) &#x2F; 兼容性</h5><p>这是最核心的分类，描述了锁的共享和排他属性。</p>
<ol>
<li><strong>共享锁 (Shared Lock, S Lock)</strong><ul>
<li>也称为<strong>读锁</strong>。</li>
<li><strong>作用</strong>：一个事务获取了某行数据的 S 锁后，其他事务<strong>可以继续获取</strong>该行的 S 锁（即允许多个事务同时读取同一行数据），但<strong>不能获取</strong>该行的 X 锁（即不允许其他事务修改或删除该行）。</li>
<li><strong>SQL 操作</strong>：<code>SELECT ... LOCK IN SHARE MODE;</code></li>
</ul>
</li>
<li><strong>排他锁 (Exclusive Lock, X Lock)</strong><ul>
<li>也称为<strong>写锁</strong>。</li>
<li><strong>作用</strong>：一个事务获取了某行数据的 X 锁后，其他任何事务都<strong>不能再获取</strong>该行的任何锁（S 锁或 X 锁），直到当前事务释放该锁。</li>
<li><strong>SQL 操作</strong>：<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 操作会自动为涉及的行加上 X 锁。也可以手动加锁：<code>SELECT ... FOR UPDATE;</code></li>
</ul>
</li>
</ol>
<p><strong>锁模式兼容性矩阵</strong>：</p>
<table>
<thead>
<tr>
<th align="left">-</th>
<th align="center">S (共享锁)</th>
<th align="center">X (排他锁)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S (共享锁)</td>
<td align="center"><strong>兼容</strong></td>
<td align="center"><strong>不兼容</strong></td>
</tr>
<tr>
<td align="left">X (排他锁)</td>
<td align="center"><strong>不兼容</strong></td>
<td align="center"><strong>不兼容</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>兼容</strong>：表示多个事务可以同时持有该锁。</li>
<li><strong>不兼容</strong>：表示当一个事务持有该锁时，其他事务必须等待。</li>
</ul>
<hr>
<h5 id="3-InnoDB-特有的行锁算法"><a href="#3-InnoDB-特有的行锁算法" class="headerlink" title="3. InnoDB 特有的行锁算法"></a>3. InnoDB 特有的行锁算法</h5><p>InnoDB 为了在 <code>REPEATABLE READ</code> 隔离级别下解决幻读问题，实现了三种特殊的行锁算法：</p>
<ol>
<li><strong>记录锁 (Record Lock)</strong><ul>
<li>这是最简单的行锁，它<strong>只锁定单个索引记录</strong>。例如 <code>SELECT * FROM products WHERE id = 1 FOR UPDATE;</code> 会在 <code>id=1</code> 这条索引记录上加一个记录锁。</li>
</ul>
</li>
<li><strong>间隙锁 (Gap Lock)</strong><ul>
<li><strong>核心功能</strong>：锁定一个<strong>索引记录之间的间隙</strong>，但不包括记录本身。它的唯一目的就是<strong>防止其他事务在这个间隙中插入新的记录</strong>，从而防止幻读。</li>
<li><strong>作用范围</strong>：只在 <code>REPEATABLE READ</code> 或更高的隔离级别下生效。</li>
<li><strong>示例</strong>：假设 <code>products</code> 表中 <code>id</code> 有 <code>5, 10, 15</code>。一个事务执行 <code>UPDATE products SET stock=0 WHERE id &gt; 10 AND id &lt; 15;</code>，即使这个范围没有记录，InnoDB 也会在 <code>(10, 15)</code> 这个开区间上加一个间隙锁。此时，任何想 <code>INSERT</code> 一条 <code>id=12</code> 的新记录的事务都会被阻塞。</li>
</ul>
</li>
<li><strong>临键锁 (Next-Key Lock)</strong><ul>
<li><strong>定义</strong>：它是 <strong>记录锁 + 间隙锁</strong> 的组合。它会锁定一个索引记录本身，以及该记录之前的那个间隙。</li>
<li><strong>工作方式</strong>：这是 InnoDB 在 <code>REPEATABLE READ</code> 隔离级别下，进行范围查询和更新时<strong>默认使用</strong>的锁定机制。</li>
<li><strong>示例</strong>：假设 <code>id</code> 有 <code>5, 10, 15</code>。当一个事务锁定 <code>id=10</code> 的记录时，Next-Key Lock 会锁定 <code>(5, 10]</code> 这个左开右闭的区间。这既锁定了 <code>id=10</code> 这条记录（记录锁），也锁定了 <code>(5, 10)</code> 这个间隙（间隙锁）。</li>
<li><strong>意义</strong>：通过 Next-Key Lock，InnoDB 能够锁定一个范围，有效防止了幻读的发生。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-意向锁-Intention-Lock"><a href="#4-意向锁-Intention-Lock" class="headerlink" title="4. 意向锁 (Intention Lock)"></a>4. 意向锁 (Intention Lock)</h5><p>意向锁是一种<strong>表级锁</strong>，但它并不会阻塞除了全表扫描以外的任何请求。它的存在是为了协调<strong>表锁</strong>和<strong>行锁</strong>之间的关系，提高加表锁的效率。</p>
<ul>
<li><strong>意向共享锁 (IS Lock)</strong>: 事务打算给数据行加 S 锁，必须先在表上获得 IS 锁。</li>
<li><strong>意向排他锁 (IX Lock)</strong>: 事务打算给数据行加 X 锁，必须先在表上获得 IX 锁。</li>
</ul>
<p><strong>工作流程</strong>：</p>
<ol>
<li>事务 A 想要给 <code>products</code> 表中的一行数据加 X 锁。</li>
<li>它会先在 <code>products</code> 表上申请一个 <strong>IX 锁</strong>，这个操作非常快。</li>
<li>然后，它再为具体的数据行申请 <strong>X 锁</strong>。</li>
<li>此时，如果事务 B 想要给整个 <code>products</code> 表加一个<strong>表级的 X 锁</strong>，它会先检查表上是否有意向锁。</li>
<li>事务 B 发现表上已经有了一个 IX 锁，就知道表里肯定有某些行被加了行锁，于是它就<strong>不必再去逐行检查</strong>是否有行锁了，直接进入等待状态。</li>
</ol>
<p>如果没有意向锁，事务 B 就必须遍历表中的每一行，去检查是否有行锁存在，效率极低。</p>
<hr>
<h3 id="2-5-死锁"><a href="#2-5-死锁" class="headerlink" title="2.5 死锁"></a>2.5 死锁</h3><h4 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1 概述"></a>2.5.1 概述</h4><p><strong>定义</strong>：死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务相互等待对方释放锁时，谁也无法继续执行，系统便陷入了永久等待的状态。</p>
<p>死锁的产生通常需要满足四个必要条件：</p>
<ol>
<li><strong>互斥条件</strong>：资源在同一时刻只能被一个事务持有。</li>
<li><strong>请求与保持条件</strong>：一个事务因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：事务已获得的资源，在未使用完之前，不能被强行剥夺。</li>
<li><strong>循环等待条件</strong>：若干事务之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<hr>
<h4 id="2-5-2-死锁的典型场景"><a href="#2-5-2-死锁的典型场景" class="headerlink" title="2.5.2 死锁的典型场景"></a>2.5.2 死锁的典型场景</h4><p>假设有一个银行转账业务，用户A要给用户B转账100元，同时用户B也要给用户A转账50元。我们使用 <code>accounts</code> 表来存储用户余额。</p>
<p><strong>数据表结构</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> accounts (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  balance <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT INTO</span> accounts <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1000</span>), (<span class="number">2</span>, <span class="number">2000</span>); <span class="comment">-- 用户A(id=1), 用户B(id=2)</span></span><br></pre></td></tr></table></figure>

<p><strong>并发执行流程</strong>：</p>
<table>
<thead>
<tr>
<th align="left">时间点</th>
<th align="left">事务 A (T1) - A转B</th>
<th align="left">事务 B (T2) - B转A</th>
<th align="left">状态分析</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1</strong></td>
<td align="left"><code>BEGIN;</code></td>
<td align="left"></td>
<td align="left">事务A开启</td>
</tr>
<tr>
<td align="left"><strong>2</strong></td>
<td align="left"><code>UPDATE accounts SET balance = balance - 100 WHERE id = 1;</code></td>
<td align="left"></td>
<td align="left">事务A成功，对<code>id=1</code>的行加了<strong>排他锁 (X Lock)</strong></td>
</tr>
<tr>
<td align="left"><strong>3</strong></td>
<td align="left"></td>
<td align="left"><code>BEGIN;</code></td>
<td align="left">事务B开启</td>
</tr>
<tr>
<td align="left"><strong>4</strong></td>
<td align="left"></td>
<td align="left"><code>UPDATE accounts SET balance = balance - 50 WHERE id = 2;</code></td>
<td align="left">事务B成功，对<code>id=2</code>的行加了<strong>排他锁 (X Lock)</strong></td>
</tr>
<tr>
<td align="left"><strong>5</strong></td>
<td align="left"><code>UPDATE accounts SET balance = balance + 100 WHERE id = 2;</code></td>
<td align="left"></td>
<td align="left">事务A尝试对<code>id=2</code>的行加锁，但该行已被事务B锁定，<strong>事务A进入等待状态</strong>。</td>
</tr>
<tr>
<td align="left"><strong>6</strong></td>
<td align="left"></td>
<td align="left"><code>UPDATE accounts SET balance = balance + 50 WHERE id = 1;</code></td>
<td align="left">事务B尝试对<code>id=1</code>的行加锁，但该行已被事务A锁定，<strong>事务B进入等待状态</strong>。</td>
</tr>
</tbody></table>
<p><strong>结论</strong>：此时，事务 A 在等待事务 B 释放 <code>id=2</code> 的锁，而事务 B 在等待事务 A 释放 <code>id=1</code> 的锁。二者形成<strong>循环等待</strong>，死锁发生。</p>
<hr>
<h4 id="2-5-3-MySQL-InnoDB-的死锁处理机制"><a href="#2-5-3-MySQL-InnoDB-的死锁处理机制" class="headerlink" title="2.5.3 MySQL (InnoDB) 的死锁处理机制"></a>2.5.3 MySQL (InnoDB) 的死锁处理机制</h4><p>InnoDB 存储引擎提供了自动的死锁检测机制。</p>
<ol>
<li><strong>死锁检测</strong>：InnoDB 内部维护一个“等待图”（wait-for graph）。当检测到图中出现<strong>环路</strong>时，就判断发生了死锁。</li>
<li><strong>选择牺牲品</strong>：一旦检测到死锁，InnoDB 会选择一个<strong>回滚成本最小</strong>的事务作为“牺牲品”（victim）。回滚成本通常是根据事务产生的 undo log 大小来计算的。</li>
<li><strong>事务回滚</strong>：将“牺牲品”事务进行<strong>回滚 (ROLLBACK)</strong>，释放它持有的所有锁资源，从而打破死锁的循环，让其他事务能够继续执行。</li>
<li><strong>返回错误</strong>：被回滚的事务，其客户端会收到一个错误信息：<code>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</code>。</li>
</ol>
<hr>
<h4 id="2-5-4-如何排查与避免死锁"><a href="#2-5-4-如何排查与避免死锁" class="headerlink" title="2.5.4 如何排查与避免死锁"></a>2.5.4 如何排查与避免死锁</h4><p>虽然 InnoDB 能自动处理死锁，但频繁的死锁会严重影响系统性能，因为事务回滚和重试是有代价的。因此，核心在于如何从设计和编码层面避免死锁。</p>
<h5 id="1-排查死锁"><a href="#1-排查死锁" class="headerlink" title="1. 排查死锁"></a>1. 排查死锁</h5><p>当应用出现死锁错误时，可以通过以下命令查看最近一次死锁的详细日志：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure>

<p>在输出结果中找到 <code>LATEST DETECTED DEADLOCK</code> 部分。它会详细记录：</p>
<ul>
<li>死锁发生的时间。</li>
<li><code>TRANSACTION 1</code>：第一个事务正在执行的SQL、持有的锁、正在等待的锁。</li>
<li><code>TRANSACTION 2</code>：第二个事务正在执行的SQL、持有的锁、正在等待的锁。</li>
<li><code>WE ROLL BACK TRANSACTION (1)</code>：InnoDB 决定回滚哪个事务。</li>
</ul>
<p>通过分析这个日志，可以清晰地定位到导致死锁的具体 SQL 语句和加锁顺序。</p>
<hr>
<h5 id="2-避免与减少死锁的策略"><a href="#2-避免与减少死锁的策略" class="headerlink" title="2. 避免与减少死锁的策略"></a>2. 避免与减少死锁的策略</h5><ul>
<li><strong>统一加锁顺序</strong>：<br>这是最根本、最有效的避免死锁的方法。确保不同的事务总是以相同的顺序来请求资源。例如，在转账场景中，可以规定<strong>总是先锁定ID较小的账户，再锁定ID较大的账户</strong>。这样所有事务都遵循同一顺序，就不会形成循环等待。</li>
<li><strong>缩短事务范围，及时提交</strong>：<br>事务持有锁的时间越长，与其他事务发生冲突的概率就越大。应尽量将不必要的逻辑（如复杂的计算、外部API调用）移出事务之外，让事务尽可能简短。</li>
<li><strong>使用合适的索引</strong>：<br>如果 <code>WHERE</code> 条件中的字段没有索引，MySQL 可能会进行全表扫描，锁定大量不必要的行，甚至升级为表锁，这会大大增加死锁的概率。为更新和删除操作的条件字段创建合适的索引，可以实现精确的行级锁定，减少冲突。</li>
<li><strong>使用较低的隔离级别</strong>：<br>在业务允许的情况下，可以考虑使用比“可重复读”（Repeatable Read）更低的隔离级别，如“读已提交”（Read Committed）。在此级别下，Gap Lock（间隙锁）会被禁用（某些情况除外），能减少锁的范围和冲突。但需注意，这可能会带来不可重复读和幻读的问题。</li>
<li><strong>谨慎使用 <code>SELECT ... FOR UPDATE</code></strong>：<br>在事务中手动加锁时，要特别注意加锁的顺序。如果必须锁定多行，确保遵循一致的顺序规则。</li>
<li><strong>在应用层添加重试机制</strong>：<br>对于高并发系统，完全避免死锁有时是不现实的。因此，应用层代码应该具备处理死锁错误的能力。当捕获到死锁异常（如 MySQL 的 <code>1213</code> 错误码）时，可以等待一个随机的短暂时间后，自动重试该事务</li>
</ul>
<hr>
<h2 id="3-应用层交互"><a href="#3-应用层交互" class="headerlink" title="3. 应用层交互"></a>3. 应用层交互</h2><h3 id="3-1-N-1-查询问题"><a href="#3-1-N-1-查询问题" class="headerlink" title="3.1 N+1 查询问题"></a>3.1 N+1 查询问题</h3><h4 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1 概述"></a>3.1.1 概述</h4><p><strong>N+1 查询问题</strong> 指的是在查询一个主实体列表（<strong>1</strong> 次查询）时，如果在遍历这个列表的过程中，又为列表中的<strong>每</strong>一个实体都单独执行了一次查询来获取其关联的子实体（<strong>N</strong> 次查询），那么最终执行的查询总数就是 <code>1 + N</code> 次。</p>
<p>这种模式会导致数据库交互次数随着主实体数量 <code>N</code> 的增长而线性增长，造成大量的数据库往返开销和性能急剧下降。</p>
<hr>
<h4 id="3-1-2-代码示例"><a href="#3-1-2-代码示例" class="headerlink" title="3.1.2 代码示例"></a>3.1.2 代码示例</h4><p>假设我们有两个实体：<strong>班级(Classes)</strong> 和 <strong>学生(Student)</strong>。一个班级可以包含多名学生，这是一个典型的一对多关系。</p>
<p><strong>数据库表结构:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 班级表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `classes` (</span><br><span class="line">  `id` <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> <span class="comment">-- 班级名称</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 学生表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `students` (</span><br><span class="line">  `id` <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>, <span class="comment">-- 学生姓名</span></span><br><span class="line">  `class_id` <span class="type">INT</span>, <span class="comment">-- 外键，关联到班级表的ID</span></span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`class_id`) <span class="keyword">REFERENCES</span> `classes`(`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> classes (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;一班&#x27;</span>), (<span class="string">&#x27;二班&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> students (name, class_id) <span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;李四&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;王五&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;赵六&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Java 实体类:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer classId;</span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Classes.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Classes</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students; <span class="comment">// 一个班级包含一个学生列表</span></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们想查询所有班级以及每个班级下的所有学生信息。一种直观但错误的做法是：</p>
<p><strong>第1步：定义查询所有班级的 Mapper 方法和 SQL</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassesMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassesMapper</span> &#123;</span><br><span class="line">    List&lt;Classes&gt; <span class="title function_">findAllClasses</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ClassesMapper.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAllClasses&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.Classes&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, name FROM classes</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第2步：定义根据班级ID查询学生的 Mapper 方法和 SQL</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StudentMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    List&lt;Student&gt; <span class="title function_">findStudentsByClassId</span><span class="params">(Integer classId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- StudentMapper.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentsByClassId&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.Student&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, name, class_id FROM students WHERE class_id = #&#123;classId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第3步：在业务层代码中组装数据（错误的方式）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service Layer</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ClassesMapper classesMapper;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StudentMapper studentMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Classes&gt; <span class="title function_">getClassesWithStudents</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 第 &quot;1&quot; 次查询：获取所有班级列表</span></span><br><span class="line">    List&lt;Classes&gt; classesList = classesMapper.findAllClasses(); <span class="comment">// SQL: SELECT id, name FROM classes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历班级列表</span></span><br><span class="line">    <span class="keyword">for</span> (Classes c : classesList) &#123;</span><br><span class="line">        <span class="comment">// 接下来 &quot;N&quot; 次查询：为每个班级单独查询其学生列表</span></span><br><span class="line">        List&lt;Student&gt; students = studentMapper.findStudentsByClassId(c.getId()); <span class="comment">// SQL: SELECT ... FROM students WHERE class_id = ?</span></span><br><span class="line">        c.setStudents(students);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classesList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析执行过程:</strong></p>
<ol>
<li>执行 <code>classesMapper.findAllClasses()</code>，向数据库发送了 <strong>1</strong> 次 <code>SELECT</code> 请求，获取了2个班级（一班，二班）。</li>
<li>进入 <code>for</code> 循环，第一次循环 <code>c</code> 是一班。</li>
<li>执行 <code>studentMapper.findStudentsByClassId(1)</code>，向数据库发送第 <strong>2</strong> 次 <code>SELECT</code> 请求。</li>
<li>第二次循环 <code>c</code> 是二班。</li>
<li>执行 <code>studentMapper.findStudentsByClassId(2)</code>，向数据库发送第 <strong>3</strong> 次 <code>SELECT</code> 请求。</li>
</ol>
<p>总共执行了 <code>1 + 2 = 3</code> 次查询。如果有一百个班级，就会执行 <code>1 + 100 = 101</code> 次查询！这就是典型的 N+1 问题。</p>
<hr>
<h4 id="3-1-3-解决方案"><a href="#3-1-3-解决方案" class="headerlink" title="3.1.3 解决方案"></a>3.1.3 解决方案</h4><p>核心思想是：<strong>通过一次查询或有限次数的查询，获取所有需要的数据</strong>。</p>
<p><strong>解决方案：使用 JOIN 查询和 Mybatis 的 <code>&lt;resultMap&gt;</code></strong></p>
<p>我们可以使用 <code>LEFT JOIN</code> 将 <code>classes</code> 表和 <code>students</code> 表连接起来，一次性获取所有数据，然后通过 Mybatis 强大的 <code>&lt;resultMap&gt;</code> 将扁平化的结果集映射成嵌套的 Java 对象。</p>
<p><strong>第1步：修改 <code>ClassesMapper.xml</code></strong></p>
<p>定义一个复杂的 <code>resultMap</code> 来处理一对多的映射关系。</p>
<ul>
<li><code>&lt;resultMap&gt;</code>：定义了最终的映射规则。</li>
<li><code>&lt;id&gt;</code> 和 <code>&lt;result&gt;</code>：映射 <code>Classes</code> 自己的属性。</li>
<li><code>&lt;collection&gt;</code>：用于映射集合属性（一对多关系）。<ul>
<li><code>property=&quot;students&quot;</code>：对应 <code>Classes</code> 类中的 <code>students</code> 属性。</li>
<li><code>ofType=&quot;com.example.model.Student&quot;</code>：集合中元素的类型。</li>
<li>内部的 <code>&lt;id&gt;</code> 和 <code>&lt;result&gt;</code>：映射 <code>Student</code> 对象的属性。</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ClassesMapper.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.ClassesMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;ClassesWithStudentsResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.model.Classes&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 映射 Classes 自身的主键和属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;class_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;class_name&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 映射 &#x27;一对多&#x27; 关系中的 &#x27;多&#x27; (学生列表) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.model.Student&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 映射 Student 对象的主键和属性 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;student_id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;student_name&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;classId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;class_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用 JOIN 查询，一次性获取所有数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAllWithStudents&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ClassesWithStudentsResultMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT </span><br><span class="line">            c.id AS class_id,</span><br><span class="line">            c.name AS class_name,</span><br><span class="line">            s.id AS student_id,</span><br><span class="line">            s.name AS student_name</span><br><span class="line">        FROM </span><br><span class="line">            classes c</span><br><span class="line">        LEFT JOIN </span><br><span class="line">            students s ON c.id = s.class_id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第2步：修改 <code>ClassesMapper.java</code> 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassesMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassesMapper</span> &#123;</span><br><span class="line">    List&lt;Classes&gt; <span class="title function_">findAllWithStudents</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第3步：在业务层代码中调用</strong></p>
<p>现在业务代码变得非常简洁，只需一次调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service Layer</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ClassesMapper classesMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Classes&gt; <span class="title function_">getClassesWithStudents</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 只执行一次数据库查询！</span></span><br><span class="line">    <span class="keyword">return</span> classesMapper.findAllWithStudents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，Mybatis 会执行一条 <code>JOIN</code> SQL，获取所有班级和学生的数据，然后在内存中根据 <code>resultMap</code> 的规则，自动将结果组装成 <code>List&lt;Classes&gt;</code>，每个 <code>Classes</code> 对象内部都填充好了对应的 <code>List&lt;Student&gt;</code>。<strong>从根本上解决了 N+1 查询问题</strong>。</p>
<hr>
<h4 id="3-1-4-如何预防"><a href="#3-1-4-如何预防" class="headerlink" title="3.1.4 如何预防"></a>3.1.4 如何预防</h4><ol>
<li><strong>开启 SQL 日志</strong>：在开发和测试阶段，务必开启 ORM 框架的 SQL 日志（如在 Mybatis 的配置文件或 <code>application.yml</code> 中设置日志级别为 <code>DEBUG</code>），观察控制台打印的 SQL 语句。如果你看到在一次操作中，出现了大量重复模式的查询，就要警惕 N+1 问题。</li>
<li><strong>性能压测</strong>：在压测环境中，N+1 问题会导致数据库连接被迅速耗尽，响应时间急剧增加，很容易被发现。</li>
<li><strong>代码审查 (Code Review)</strong>：在审查处理关联关系的代码时，要特别关注数据加载方式。看到循环中包含数据库查询，就要高度警惕。</li>
<li><strong>熟悉 ORM 框架的数据加载策略</strong>：深入理解所使用的 ORM 框架的**懒加载（Lazy Loading）<strong>和</strong>预加载&#x2F;即时加载（Eager Loading）**机制。N+1 问题往往是由于不恰当的懒加载或默认的加载策略导致的。解决问题的本质就是将多次查询变为一次或少数几次预加载。</li>
</ol>
<hr>
<h3 id="3-2-SQL-注入"><a href="#3-2-SQL-注入" class="headerlink" title="3.2 SQL 注入"></a>3.2 SQL 注入</h3><h4 id="3-2-1-什么是-SQL-注入？"><a href="#3-2-1-什么是-SQL-注入？" class="headerlink" title="3.2.1 什么是 SQL 注入？"></a>3.2.1 什么是 SQL 注入？</h4><p><strong>SQL 注入</strong>是一种常见的网络攻击技术，攻击者通过在应用程序的用户输入接口（如网页表单、URL参数等）中<strong>注入恶意的 SQL 代码片段</strong>，欺骗应用程序执行非预期的数据库操作。</p>
<p>简单来说，当应用程序将用户输入的内容<strong>直接拼接</strong>到 SQL 查询语句中时，攻击者就可以构造特殊的输入，篡改原有的 SQL 语义，从而达到窃取数据、篡改数据、甚至控制整个数据库服务器的目的。</p>
<p><strong>核心原则：永远不要信任用户的任何输入！</strong></p>
<hr>
<h4 id="3-2-2-SQL-注入的危害"><a href="#3-2-2-SQL-注入的危害" class="headerlink" title="3.2.2 SQL 注入的危害"></a>3.2.2 SQL 注入的危害</h4><p>SQL 注入的危害是极其严重的，它可能导致：</p>
<ol>
<li><strong>数据泄露</strong>：攻击者可以绕过认证，查询并窃取数据库中的敏感信息，如用户个人资料、密码、银行卡信息等。</li>
<li><strong>数据篡改</strong>：攻击者可以修改、添加或删除数据库中的数据，破坏数据的完整性。</li>
<li><strong>权限提升</strong>：如果数据库账户权限过高，攻击者可能通过执行特定命令读取服务器文件，甚至写入后门（webshell），最终完全控制服务器。</li>
<li><strong>拒绝服务 (DoS)</strong>：攻击者可以执行耗时很长的查询（如 <code>BENCHMARK()</code>, <code>SLEEP()</code>），耗尽数据库资源，导致网站或应用无法正常服务。</li>
</ol>
<hr>
<h4 id="3-2-3-SQL-注入是如何发生的？-一个经典的登录场景"><a href="#3-2-3-SQL-注入是如何发生的？-一个经典的登录场景" class="headerlink" title="3.2.3 SQL 注入是如何发生的？(一个经典的登录场景)"></a>3.2.3 SQL 注入是如何发生的？(一个经典的登录场景)</h4><p>假设我们有一个用户登录功能，后台的验证逻辑是根据用户名和密码查询数据库。</p>
<h5 id="存在漏洞的代码-Java-JDBC-示例"><a href="#存在漏洞的代码-Java-JDBC-示例" class="headerlink" title="存在漏洞的代码 (Java + JDBC 示例):"></a><strong>存在漏洞的代码 (Java + JDBC 示例):</strong></h5><p>这里的关键问题是<strong>使用字符串拼接 <code>+</code> 来构造 SQL 语句</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="comment">// 危险：直接将用户输入拼接到 SQL 语句中</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; AND password = &#x27;&quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">         <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">         <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果能查到记录，说明用户名和密码匹配</span></span><br><span class="line">        <span class="keyword">return</span> rs.next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// ... 异常处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击过程分析"><a href="#攻击过程分析" class="headerlink" title="攻击过程分析:"></a><strong>攻击过程分析:</strong></h5><ol>
<li><p><strong>正常用户登录:</strong></p>
<ul>
<li>用户输入 <code>username</code>: <code>jason</code></li>
<li>用户输入 <code>password</code>: <code>123456</code></li>
<li>最终执行的 SQL: <code>SELECT * FROM users WHERE username = &#39;jason&#39; AND password = &#39;123456&#39;</code></li>
<li><strong>结果</strong>: 正常，如果用户名密码正确，查询会返回一条记录，登录成功。</li>
</ul>
</li>
<li><p><strong>攻击者进行 SQL 注入:</strong></p>
<ul>
<li><p>攻击者在 <code>username</code> 输入框中输入: <code>admin&#39; -- </code>(注意 <code>admin</code> 后面有一个单引号和一个空格，然后是两个减号和一个空格)</p>
</li>
<li><p>在 <code>password</code> 输入框中随意输入，例如: <code>whatever</code></p>
</li>
<li><p>应用程序将这些输入拼接到 SQL 语句中，最终生成的 SQL 是:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="comment">-- &#x27; AND password = &#x27;whatever&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SQL 语法分析</strong>:</p>
<ul>
<li>在 SQL 中，<code>-- </code>(两个减号加一个空格) 是<strong>行注释符</strong>。</li>
<li>这意味着从 <code>--</code> 开始到该行结束的所有内容都会被数据库忽略。</li>
<li>因此，数据库实际执行的 SQL 是: <code>SELECT * FROM users WHERE username = &#39;admin&#39;</code></li>
</ul>
</li>
<li><p><strong>结果</strong>: 查询条件变成了“只要用户名是 admin”，密码验证部分被注释掉了！攻击者成功绕过密码验证，以 <code>admin</code> 用户的身份登录系统。</p>
</li>
</ul>
</li>
<li><p><strong>更危险的万能密码攻击:</strong></p>
<ul>
<li><p>攻击者在 <code>username</code> 输入框输入: <code>&#39; OR &#39;1&#39;=&#39;1</code></p>
</li>
<li><p><code>password</code> 输入框输入: <code>&#39; OR &#39;1&#39;=&#39;1</code></p>
</li>
<li><p>最终生成的 SQL:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SQL 语法分析</strong>:</p>
<ul>
<li><code>&#39;1&#39;=&#39;1&#39;</code> 这个条件永远为 <code>TRUE</code>。</li>
<li>由于 <code>OR</code> 的存在，整个 <code>WHERE</code> 子句的结果永远为 <code>TRUE</code>。</li>
<li>这个查询会返回 <code>users</code> 表中的<strong>所有记录</strong>，<code>rs.next()</code> 会为 <code>true</code>，导致登录成功（通常是表中的第一个用户）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-2-4-如何防止-SQL-注入？-核心防御手段"><a href="#3-2-4-如何防止-SQL-注入？-核心防御手段" class="headerlink" title="3.2.4 如何防止 SQL 注入？(核心防御手段)"></a>3.2.4 如何防止 SQL 注入？(核心防御手段)</h4><p>防御 SQL 注入的根本方法是<strong>确保用户输入永远被当作“数据”处理，而不是被当作“SQL指令”的一部分来执行。</strong></p>
<h5 id="1-使用参数化查询-Parameterized-Queries-PreparedStatement"><a href="#1-使用参数化查询-Parameterized-Queries-PreparedStatement" class="headerlink" title="1. 使用参数化查询 (Parameterized Queries &#x2F; PreparedStatement)"></a><strong>1. 使用参数化查询 (Parameterized Queries &#x2F; PreparedStatement)</strong></h5><p>这是<strong>最有效、最推荐</strong>的防御方法。</p>
<p><strong>原理</strong>：<br>它将 SQL 语句的“结构”和“数据”分离开来。</p>
<ol>
<li><strong>模板编译</strong>：先把 SQL 语句的模板（包含 <code>?</code> 占位符）发送给数据库进行预编译。</li>
<li><strong>参数绑定</strong>：再把用户输入的数据作为参数传递给编译好的模板。<br>此时，无论用户输入什么（即使是 <code>&#39; OR &#39;1&#39;=&#39;1</code>），数据库都会把它<strong>仅仅当作一个普通的字符串</strong>来处理，而不是当作 SQL 指令。</li>
</ol>
<p><strong>安全的代码 (使用 <code>PreparedStatement</code>):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 使用 &#x27;?&#x27; 作为参数占位符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">         <span class="comment">// 2. 创建 PreparedStatement 对象</span></span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 为占位符绑定参数。setString 会自动处理转义，确保输入被视为纯文本</span></span><br><span class="line">        ps.setString(<span class="number">1</span>, username); <span class="comment">// 第一个 &#x27;?&#x27;</span></span><br><span class="line">        ps.setString(<span class="number">2</span>, password); <span class="comment">// 第二个 &#x27;?&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">return</span> rs.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// ... 异常处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当攻击者输入 <code>&#39; OR &#39;1&#39;=&#39;1</code> 时，<code>ps.setString(1, &quot;&#39; OR &#39;1&#39;=&#39;1&quot;)</code> 会将整个字符串安全地填入，数据库会去寻找一个用户名<strong>字面上就等于</strong> <code>&#39; OR &#39;1&#39;=&#39;1</code> 的用户，这显然是不存在的，因此查询失败，成功抵御攻击。</p>
<hr>
<h5 id="2-使用-ORM-框架-如-Mybatis"><a href="#2-使用-ORM-框架-如-Mybatis" class="headerlink" title="2. 使用 ORM 框架 (如 Mybatis)"></a><strong>2. 使用 ORM 框架 (如 Mybatis)</strong></h5><p>现代 ORM 框架在底层已经为我们封装好了参数化查询。</p>
<ul>
<li><p>在 Mybatis 中，使用 <code>#{}</code> 语法包裹参数，Mybatis 会自动将其转换为 <code>PreparedStatement</code> 来执行，因此是<strong>安全</strong>的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM users WHERE username = #&#123;username&#125; AND password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>警惕</strong>：Mybatis 中还有一种 <code>${}</code> 语法，它进行的是<strong>纯粹的字符串替换</strong>，等同于手动拼接，会<strong>导致 SQL 注入</strong>！<code>${}</code> 只应用于那些不能使用占位符的地方，如动态表名、<code>ORDER BY</code> 的列名，并且在使用时必须由程序严格校验其合法性。</p>
</li>
</ul>
<hr>
<h5 id="3-输入验证与过滤"><a href="#3-输入验证与过滤" class="headerlink" title="3. 输入验证与过滤"></a><strong>3. 输入验证与过滤</strong></h5><p>作为辅助防御手段（纵深防御）：</p>
<ul>
<li><strong>白名单验证</strong>：对用户输入进行格式校验，例如，如果需要的是一个数字ID，就验证输入是否只包含数字。如果需要的是邮箱，就用正则表达式验证其格式。</li>
<li><strong>黑名单过滤</strong>：过滤掉一些已知的危险字符（如 <code>&#39;</code>, <code>--</code>, <code>;</code> 等）。但这种方法容易被绕过，不推荐作为主要防御手段。</li>
</ul>
<hr>
<h5 id="4-最小权限原则"><a href="#4-最小权限原则" class="headerlink" title="4. 最小权限原则"></a><strong>4. 最小权限原则</strong></h5><p>为数据库连接账户授予<strong>尽可能小</strong>的权限。例如，一个只负责查询商品信息的 Web 应用，其数据库账户就不应该有删除表（<code>DROP</code>）、修改表结构（<code>ALTER</code>）的权限。这样即使被注入，攻击者能造成的破坏也有限。</p>
<hr>
<hr>
<h1 id="四、超越关系型数据库"><a href="#四、超越关系型数据库" class="headerlink" title="四、超越关系型数据库"></a>四、超越关系型数据库</h1><h2 id="1-NoSQL核心思想"><a href="#1-NoSQL核心思想" class="headerlink" title="1. NoSQL核心思想"></a>1. NoSQL核心思想</h2><h3 id="1-1-CAP-定理"><a href="#1-1-CAP-定理" class="headerlink" title="1.1 CAP 定理"></a>1.1 CAP 定理</h3><h4 id="1-1-1-概述-1"><a href="#1-1-1-概述-1" class="headerlink" title="1.1.1 概述"></a>1.1.1 概述</h4><p>CAP 定理，又称布鲁尔定理 (Brewer’s Theorem)，由计算机科学家埃里克·布鲁尔 (Eric Brewer) 在 2000 年提出。它指出，对于一个<strong>分布式计算系统</strong>，不可能同时满足以下三项基本要求，最多只能满足其中两项。</p>
<p>这三项基本要求分别是：</p>
<ul>
<li><strong>C - Consistency (一致性)</strong></li>
<li><strong>A - Availability (可用性)</strong></li>
<li><strong>P - Partition Tolerance (分区容错性)</strong></li>
</ul>
<p>这个定理是理解 NoSQL 数据库设计哲学和权衡取舍的基石。</p>
<hr>
<h4 id="1-1-2-CAP-三个核心概念详解"><a href="#1-1-2-CAP-三个核心概念详解" class="headerlink" title="1.1.2 CAP 三个核心概念详解"></a>1.1.2 CAP 三个核心概念详解</h4><h5 id="1-C-一致性-Consistency"><a href="#1-C-一致性-Consistency" class="headerlink" title="1. C - 一致性 (Consistency)"></a>1. C - 一致性 (Consistency)</h5><ul>
<li><strong>定义</strong>：这里的一致性指的是<strong>强一致性</strong> (Strong Consistency) 或线性一致性。它要求在分布式系统中的所有数据备份，在同一时刻拥有相同的值。换句话说，任何读操作都应该能读取到在此之前已完成的最新写操作的结果。</li>
<li><strong>通俗理解</strong>：当一个节点成功写入一条新数据后，任何其他节点立即对该数据的读取请求，都必须返回这条新数据。不允许读到旧的、过时的数据。</li>
<li><strong>举例</strong>：在银行转账场景中，你向账户A转账100元。一旦系统提示转账成功，无论你从哪个ATM机或App查询，都必须立刻看到账户A的余额已经增加。这就是对一致性的强要求。</li>
</ul>
<hr>
<h5 id="2-A-可用性-Availability"><a href="#2-A-可用性-Availability" class="headerlink" title="2. A - 可用性 (Availability)"></a>2. A - 可用性 (Availability)</h5><ul>
<li><strong>定义</strong>：系统提供的服务必须一直处于可用的状态。对于用户的每一个操作请求，系统总能在有限的时间内返回一个（非错误的）结果。</li>
<li><strong>通俗理解</strong>：系统永远在线，服务不中断。只要客户端向系统中的<strong>任何一个健康节点</strong>发出请求，这个节点都必须响应，而不能因为其他节点故障或网络问题就拒绝服务。</li>
<li><strong>举例</strong>：在一个电商网站，即使后台某个数据库节点宕机，用户依然可以正常浏览商品、添加购物车。系统不会因为局部故障而整体瘫痪。</li>
</ul>
<hr>
<h5 id="3-P-分区容错性-Partition-Tolerance"><a href="#3-P-分区容错性-Partition-Tolerance" class="headerlink" title="3. P - 分区容错性 (Partition Tolerance)"></a>3. P - 分区容错性 (Partition Tolerance)</h5><ul>
<li><strong>定义</strong>：分布式系统中的不同节点分布在不同的网络位置（机房、城市、国家等）。节点间的网络通信可能随时中断，导致整个系统被分割成多个无法互相通信的“网络分区”。分区容错性要求系统在出现网络分区的情况下，依然能够继续对外提供服务。</li>
<li><strong>通俗理解</strong>：系统能够容忍“网络断了”这种情况。一部分节点和另一部分节点之间暂时失联，但各自区域内的服务还能正常运行。</li>
<li><strong>核心要点</strong>：在现代的分布式系统中，网络故障是常态，而不是意外。因此，<strong>分区容错性 (P) 是一个必须满足的基本要求，而不是一个可选项</strong>。因为我们无法保证网络100%可靠。</li>
</ul>
<hr>
<h4 id="1-1-3-CAP-的核心权衡：为什么是“三选二”？"><a href="#1-1-3-CAP-的核心权衡：为什么是“三选二”？" class="headerlink" title="1.1.3 CAP 的核心权衡：为什么是“三选二”？"></a>1.1.3 CAP 的核心权衡：为什么是“三选二”？</h4><p>既然分区容错性 (P) 在分布式系统中是必须保证的，那么 CAP 定理的真正含义就变成了：<strong>当网络分区发生时，你必须在一致性 (C) 和可用性 (A) 之间做出选择。</strong></p>
<p>让我们通过一个场景来理解这个权衡：</p>
<p><strong>场景</strong>：假设一个分布式数据库有两个节点 N1 和 N2，它们互相备份数据 <code>v=0</code>。</p>
<ol>
<li><strong>正常情况</strong>：客户端向 N1 发起写请求，将数据 <code>v</code> 从 0 更新为 1。N1 更新自己的数据后，立刻将这个变更同步给 N2，两者数据再次保持一致。此时 C, A, P 都是满足的。</li>
<li><strong>网络分区发生</strong>：N1 和 N2 之间的网络突然中断，形成两个独立的分区。</li>
<li><strong>抉择时刻</strong>：此时，一个新的写请求到达了 N1，要求将 <code>v</code> 更新为 2。系统必须做出选择：<ul>
<li><strong>选择 C (放弃 A) -&gt; 构建 CP 系统</strong><ul>
<li>为了保证<strong>一致性 (C)</strong>，N1 必须将数据变更同步到 N2。但由于网络分区，它无法联系到 N2。</li>
<li>为了避免数据不一致（N1 的 <code>v=2</code> 而 N2 的 <code>v=1</code>），N1 必须拒绝这个写请求，或者阻塞该请求直到网络恢复。</li>
<li>此时，对于客户端来说，系统是“不可用”的。因此，系统<strong>牺牲了可用性 (A)</strong> 来保证一致性。</li>
<li><strong>结论</strong>：在网络分区 (P) 发生时，为了保证一致性 (C)，我们牺牲了可用性 (A)。这样的系统被称为 <strong>CP 系统</strong>。</li>
</ul>
</li>
<li><strong>选择 A (放弃 C) -&gt; 构建 AP 系统</strong><ul>
<li>为了保证<strong>可用性 (A)</strong>，N1 必须立即响应客户端的写请求，并将本地数据更新为 <code>v=2</code>。</li>
<li>由于网络分区，N1 无法将这个变更同步给 N2。此时，N1 的数据是 <code>v=2</code>，而 N2 的数据仍然是 <code>v=1</code>。系统出现了数据不一致。</li>
<li>此时，系统虽然是可用的（两个分区都在独立工作），但它<strong>牺牲了强一致性 (C)</strong>。它只能承诺在未来某个时刻（网络恢复后）通过数据同步等机制，让数据最终达成一致，这也就是<strong>最终一致性 (Eventual Consistency)</strong>。</li>
<li><strong>结论</strong>：在网络分区 (P) 发生时，为了保证可用性 (A)，我们牺牲了强一致性 (C)。这样的系统被称为 <strong>AP 系统</strong>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>关于 CA 系统</strong>：</p>
<p>一个 CA (Consistency + Availability) 系统理论上是存在的，但它无法容忍任何网络分区。这意味着它只能运行在单个节点或一个绝对可靠的网络环境中。在实践中，这等同于一个单机系统，而非分布式系统。</p>
<hr>
<h4 id="1-1-4-真实世界中的数据库选择"><a href="#1-1-4-真实世界中的数据库选择" class="headerlink" title="1.1.4 真实世界中的数据库选择"></a>1.1.4 真实世界中的数据库选择</h4><ul>
<li><strong>CP 系统 (选择一致性)</strong><ul>
<li><strong>场景</strong>：金融、银行、订单系统等对数据一致性要求极高的场景。数据的错误比服务暂时的不可用更致命。</li>
<li><strong>典型代表</strong>：Zookeeper、HBase、MongoDB (在特定配置下)、传统关系型数据库的集群模式 (如 Oracle RAC) 通常也倾向于 C。</li>
</ul>
</li>
<li><strong>AP 系统 (选择可用性)</strong><ul>
<li><strong>场景</strong>：社交网络、电商商品浏览、信息流推荐等。允许短暂的数据不一致，但要求服务永远在线，用户体验至上。一个点赞晚几秒显示出来是可以接受的。</li>
<li><strong>典型代表</strong>：Cassandra、DynamoDB (AWS)、CouchDB、Redis (在集群模式下部分倾向 AP)。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-BASE理论"><a href="#1-2-BASE理论" class="headerlink" title="1.2 BASE理论"></a>1.2 BASE理论</h3><h4 id="1-2-1-什么是-BASE-理论？"><a href="#1-2-1-什么是-BASE-理论？" class="headerlink" title="1.2.1 什么是 BASE 理论？"></a><strong>1.2.1 什么是 BASE 理论？</strong></h4><p>BASE 理论是 eBay 的架构师 Dan Pritchett 在对大规模分布式系统实践进行总结时提出的。如果说 CAP 定理是分布式系统设计的理论基础，那么 BASE 理论就是面向高可用、可扩展的分布式系统，在实践中对 CAP 理论进行权衡取舍后产生的<strong>设计哲学</strong>。</p>
<p>BASE 是三个词的缩写：</p>
<ul>
<li><strong>BA - Basically Available (基本可用)</strong></li>
<li><strong>S - Soft State (软状态)</strong></li>
<li><strong>E - Eventually Consistent (最终一致性)</strong></li>
</ul>
<p>BASE 理论的核心思想是：即使无法做到强一致性 (Strong Consistency)，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性 (Eventually Consistent)。它强调牺牲部分一致性来换取系统的<strong>可用性</strong>和<strong>分区容错性</strong>，是 CAP 定理中选择 <strong>AP</strong> (Availability + Partition Tolerance) 策略的实践范式。</p>
<p>与传统数据库强调的 <strong>ACID</strong> 特性相比，BASE 理论是反 ACID 的。</p>
<hr>
<h4 id="1-2-2-BASE-三个核心概念详解"><a href="#1-2-2-BASE-三个核心概念详解" class="headerlink" title="1.2.2 BASE 三个核心概念详解"></a><strong>1.2.2 BASE 三个核心概念详解</strong></h4><h5 id="1-BA-基本可用-Basically-Available"><a href="#1-BA-基本可用-Basically-Available" class="headerlink" title="1. BA - 基本可用 (Basically Available)"></a>1. BA - 基本可用 (Basically Available)</h5><ul>
<li><strong>定义</strong>：指分布式系统在出现不可预知故障的时候，允许损失部分可用性，但不等于系统完全不可用。</li>
<li><strong>通俗理解</strong>：这是一种“降级”哲学。系统不是非黑即白（要么100%可用，要么0%可用），而是允许在极端情况下提供有损服务。</li>
<li><strong>举例</strong>：<ul>
<li><strong>响应时间损失</strong>：在双十一购物节，流量洪峰到来时，电商网站为了保证核心的下单功能，可能会暂时增加页面加载时间，或者延迟一些非核心数据的展示。用户依然能购物，但体验有所下降。</li>
<li><strong>功能损失</strong>：一个视频网站在服务器压力过大时，可能会暂时关闭“弹幕”或“评论”功能，但保证用户依然可以正常观看视频。核心功能可用，非核心功能降级。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-S-软状态-Soft-State"><a href="#2-S-软状态-Soft-State" class="headerlink" title="2. S - 软状态 (Soft State)"></a>2. S - 软状态 (Soft State)</h5><ul>
<li><strong>定义</strong>：指系统的状态允许在一定时间内存在中间状态，并且该中间状态不会影响系统整体的可用性。即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</li>
<li><strong>通俗理解</strong>：“状态”可以暂时是“软”的、不确定的，而不是像传统数据库那样是“硬”的、确定的。数据最终会趋于一致，但在同步完成之前，不同节点看到的数据可能是不同的。</li>
<li><strong>举例</strong>：<ul>
<li><strong>订单状态</strong>：你下单后，订单状态可能是“支付中”。这个状态就是一个中间状态（软状态）。系统在和支付网关通信，过一会儿这个状态会变成“支付成功”或“支付失败”。</li>
<li><strong>社交媒体点赞数</strong>：你在一个热门视频下点赞，总点赞数可能不会立即 <code>+1</code>。系统后台需要一个同步过程，将你的点赞行为聚合到总数中。在此期间，你看到的是 <code>N+1</code>，而其他地区的用户可能暂时还看到的是 <code>N</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-E-最终一致性-Eventually-Consistent"><a href="#3-E-最终一致性-Eventually-Consistent" class="headerlink" title="3. E - 最终一致性 (Eventually Consistent)"></a>3. E - 最终一致性 (Eventually Consistent)</h5><ul>
<li><strong>定义</strong>：这是 BASE 理论的基石。它强调系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。不需要实时保证系统数据的强一致性。</li>
<li><strong>通俗理解</strong>：给系统一点时间，它自己会把数据同步对。在数据达到一致之前，存在一个“不一致窗口期”。业务只要能容忍这个窗口期，就可以采用最终一致性。</li>
<li><strong>举例</strong>：<ul>
<li><strong>微博&#x2F;朋友圈发布</strong>：你发布一条新的动态，你的粉丝不会在同一瞬间全部看到。系统会逐步将这条动态推送到所有粉丝的信息流中。可能北京的朋友马上看到了，但远在纽约的朋友需要几秒甚至几十秒后才能看到。但最终，所有粉丝都能看到这条动态。</li>
<li><strong>跨国DNS记录同步</strong>：当你修改一个域名的解析记录时，全球的 DNS 服务器需要时间来同步这个变更，这个过程可能长达数小时，但最终全球的解析结果会是一致的。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-3-BASE-理论与-CAP、ACID-的关系"><a href="#1-2-3-BASE-理论与-CAP、ACID-的关系" class="headerlink" title="1.2.3 BASE 理论与 CAP、ACID 的关系"></a><strong>1.2.3 BASE 理论与 CAP、ACID 的关系</strong></h4><h5 id="1-与-CAP-的关系"><a href="#1-与-CAP-的关系" class="headerlink" title="1. 与 CAP 的关系"></a>1. 与 CAP 的关系</h5><ul>
<li>BASE 理论是 CAP 定理在现实世界中的应用延伸。</li>
<li>当一个分布式系统选择 <strong>P (分区容错性)</strong> 时，它必须在 <strong>C (一致性)</strong> 和 <strong>A (可用性)</strong> 之间做选择。</li>
<li>BASE 理论就是选择了 <strong>A (可用性)</strong> 而适度放弃了强一致性 <strong>C</strong> 的结果。它用<strong>基本可用 (BA)</strong> 和<strong>软状态 (S)</strong> 来定义系统如何对外服务，并用<strong>最终一致性 (E)</strong> 来替代强一致性 (C)。</li>
</ul>
<hr>
<h5 id="2-与-ACID-的关系"><a href="#2-与-ACID-的关系" class="headerlink" title="2. 与 ACID 的关系"></a>2. 与 ACID 的关系</h5><p>ACID 和 BASE 代表了两种截然相反的设计哲学，分别对应了传统关系型数据库和大部分 NoSQL 数据库。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><strong>ACID (关系型数据库, 如 MySQL)</strong></th>
<th align="left"><strong>BASE (NoSQL 数据库, 如 Cassandra)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心关注点</strong></td>
<td align="left">数据的一致性和完整性，事务的正确性。</td>
<td align="left">系统的高可用性、容错能力和可扩展性。</td>
</tr>
<tr>
<td align="left"><strong>一致性模型</strong></td>
<td align="left"><strong>强一致性 (Strong Consistency)</strong>：事务提交后，任何后续读取都能看到新数据。</td>
<td align="left"><strong>最终一致性 (Eventually Consistent)</strong>：允许短暂的数据不一致，但保证最终会一致。</td>
</tr>
<tr>
<td align="left"><strong>可用性模型</strong></td>
<td align="left">为了保证一致性，可能在网络分区时拒绝服务，<strong>可用性较低</strong>。</td>
<td align="left">追求<strong>基本可用 (Basically Available)</strong>，即使在故障时也尽量提供降级服务。</td>
</tr>
<tr>
<td align="left"><strong>典型场景</strong></td>
<td align="left">金融、银行、会计、订单系统等对数据精确度要求极高的场景。</td>
<td align="left">社交网络、大型电商网站、物联网、内容分发等需要处理海量数据和高并发请求的场景。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-使用场景"><a href="#1-3-使用场景" class="headerlink" title="1.3 使用场景"></a>1.3 使用场景</h3><h4 id="1-3-1-海量数据存储与高可扩展性需求-Big-Data-Scalability"><a href="#1-3-1-海量数据存储与高可扩展性需求-Big-Data-Scalability" class="headerlink" title="1.3.1 海量数据存储与高可扩展性需求 (Big Data &amp; Scalability)"></a><strong>1.3.1 海量数据存储与高可扩展性需求 (Big Data &amp; Scalability)</strong></h4><ul>
<li><strong>场景描述</strong>：<ul>
<li>物联网（IoT）设备持续上传的传感器数据。</li>
<li>社交网络中数以亿计的用户个人资料、帖子、图片。</li>
<li>电商网站的海量商品信息和用户行为日志。</li>
</ul>
</li>
<li><strong>传统 RDBMS 的挑战</strong>：<ul>
<li><strong>垂直扩展 (Scale-up) 昂贵</strong>：当数据量和并发量增长时，RDBMS 通常依赖于升级单个服务器的硬件（CPU、内存、磁盘），这种方式成本高昂且存在物理极限。</li>
<li><strong>水平扩展 (Scale-out) 复杂</strong>：虽然 RDBMS 也可以通过分库分表（Sharding）来实现水平扩展，但这通常需要应用层做大量改造，管理和维护非常复杂。</li>
</ul>
</li>
<li><strong>NoSQL 的解决方案 (基于 P - 分区容错性)</strong>：<ul>
<li>NoSQL 数据库从设计之初就为<strong>水平扩展</strong>而生。它们天然就是分布式的，可以轻松地通过增加更多的廉价服务器节点来线性地提升系统的存储能力和处理能力。</li>
<li>数据的分片和路由对应用层通常是透明的，极大地降低了运维的复杂度。</li>
<li><strong>典型数据库</strong>：HBase, Cassandra, MongoDB (通过 Sharding)。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-2-高并发读写与高可用性需求-High-Concurrency-Availability"><a href="#1-3-2-高并发读写与高可用性需求-High-Concurrency-Availability" class="headerlink" title="1.3.2 高并发读写与高可用性需求 (High Concurrency &amp; Availability)"></a><strong>1.3.2 高并发读写与高可用性需求 (High Concurrency &amp; Availability)</strong></h4><ul>
<li><strong>场景描述</strong>：<ul>
<li>社交媒体信息流的刷新、点赞、评论（写操作远多于传统应用）。</li>
<li>双十一、黑五等大促活动的商品库存扣减、瞬时抢购。</li>
<li>新闻客户端的内容分发和阅读。</li>
</ul>
</li>
<li><strong>传统 RDBMS 的挑战</strong>：<ul>
<li><strong>写性能瓶颈</strong>：在高并发写操作下，RDBMS 的行锁、表锁机制容易产生严重的锁竞争，导致性能急剧下降。</li>
<li><strong>单点故障</strong>：传统的主从架构中，主库（Master）一旦宕机，会导致整个系统在切换期间无法写入，损失了<strong>可用性 (A)</strong>。</li>
</ul>
</li>
<li><strong>NoSQL 的解决方案 (基于 A - 可用性 和 E - 最终一致性)</strong>：<ul>
<li>许多 NoSQL 数据库采用无主（Leaderless）或多主（Multi-Master）架构，任何节点都可以处理写请求，避免了单点瓶颈。</li>
<li>数据被复制到多个节点，当某个节点故障时，系统可以无缝地将请求路由到其他健康节点，实现了<strong>基本可用 (BA)</strong>。</li>
<li>为了换取高写入性能，系统接受写操作后立即返回，数据在后台异步复制到其他节点，这期间存在<strong>软状态 (S)</strong>，但最终会达到<strong>最终一致性 (E)</strong>。</li>
<li><strong>典型数据库</strong>：Redis, Cassandra, DynamoDB。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-3-灵活的数据模型需求-Flexible-Schema"><a href="#1-3-3-灵活的数据模型需求-Flexible-Schema" class="headerlink" title="1.3.3 灵活的数据模型需求 (Flexible Schema)"></a><strong>1.3.3 灵活的数据模型需求 (Flexible Schema)</strong></h4><ul>
<li><strong>场景描述</strong>：<ul>
<li>一个产品系统，不同类别的商品属性千差万别（如衣服有颜色尺码，手机有屏幕内存）。</li>
<li>用户画像系统，需要为每个用户贴上不同且随时可能变化的标签。</li>
<li>内容管理系统，文章、视频、图集等内容的结构各不相同。</li>
</ul>
</li>
<li><strong>传统 RDBMS 的挑战</strong>：<ul>
<li><strong>固定表结构 (Rigid Schema)</strong>：必须预先定义好表的字段和类型。如果业务需求变更需要增加或修改字段，<code>ALTER TABLE</code> 操作在大数据表上可能是灾难性的，会长时间锁表。</li>
<li><strong>稀疏数据</strong>：为了兼容所有可能的属性，可能需要设计一张包含大量 <code>NULL</code> 值的“大宽表”，浪费存储空间且不直观。</li>
</ul>
</li>
<li><strong>NoSQL 的解决方案 (Schema-less)</strong>：<ul>
<li><strong>文档数据库 (Document Store)</strong>：允许将一个完整的数据对象（例如一个 JSON 文档）存入数据库，每个文档的结构都可以不同。这使得数据模型能够与应用程序的领域模型完美匹配，开发迭代速度极快。</li>
<li><strong>键值数据库 (Key-Value Store)</strong> 和 <strong>列式数据库 (Column-family Store)</strong> 也提供了类似的高度灵活性。</li>
<li><strong>典型数据库</strong>：MongoDB, Couchbase, Elasticsearch。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-4-特定数据结构与计算场景"><a href="#1-3-4-特定数据结构与计算场景" class="headerlink" title="1.3.4 特定数据结构与计算场景"></a><strong>1.3.4 特定数据结构与计算场景</strong></h4><p>除了上述通用场景，某些 NoSQL 数据库被设计用来高效处理特定的数据结构和查询模式。</p>
<ul>
<li><strong>高速缓存与会话管理 (Caching &amp; Session Store)</strong><ul>
<li><strong>场景</strong>：缓存热点数据（如首页内容、用户信息），存储用户登录状态（Session）。</li>
<li><strong>需求</strong>：极低的读写延迟（亚毫秒级）。</li>
<li><strong>解决方案</strong>：基于内存的<strong>键值数据库</strong>。它们的 K-V 模型简单直接，内存读写速度远超基于磁盘的数据库。</li>
<li><strong>典型数据库</strong>：<strong>Redis, Memcached</strong>。</li>
</ul>
</li>
<li><strong>关系网络与推荐系统 (Graph &amp; Recommendation)</strong><ul>
<li><strong>场景</strong>：社交网络的好友关系，金融风控的欺诈网络分析，知识图谱，路径规划。</li>
<li><strong>需求</strong>：高效地查询和遍历复杂的关系（如“我朋友的朋友”）。</li>
<li><strong>解决方案</strong>：<strong>图数据库</strong>。它们专门存储节点（实体）和边（关系），进行关系遍历的性能比 RDBMS 使用多层 <code>JOIN</code> 查询高出几个数量级。</li>
<li><strong>典型数据库</strong>：<strong>Neo4j, JanusGraph</strong>。</li>
</ul>
</li>
<li><strong>全文搜索与日志分析 (Full-text Search &amp; Log Analysis)</strong><ul>
<li><strong>场景</strong>：站内搜索引擎，电商商品搜索，ELK (Elasticsearch, Logstash, Kibana) 日志分析平台。</li>
<li><strong>需求</strong>：快速地对非结构化文本进行分词、索引和相关性排序查询。</li>
<li><strong>解决方案</strong>：<strong>搜索引擎&#x2F;文档数据库</strong>。它们使用倒排索引等技术，专为文本搜索和聚合分析优化。</li>
<li><strong>典型数据库</strong>：<strong>Elasticsearch, Solr</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-5-反向思考：何时不应优先选择-NoSQL？"><a href="#1-3-5-反向思考：何时不应优先选择-NoSQL？" class="headerlink" title="1.3.5 反向思考：何时不应优先选择 NoSQL？"></a>1.3.5 反向思考：何时不应优先选择 NoSQL？</h4><p>为了形成完整的认知，了解不适合的场景同样重要：</p>
<ol>
<li><strong>需要强事务与ACID保证</strong>：如银行转账、金融交易、订单管理等，任何数据的不一致都可能导致严重后果。这些是 RDBMS 的核心优势领域。</li>
<li><strong>数据模型稳定且关系复杂</strong>：如果你的业务数据结构非常固定，且需要通过复杂的 <code>JOIN</code> 查询来保证数据的引用完整性（如 ERP 系统），RDBMS 的关系模型和约束机制通常是更好的选择。</li>
<li><strong>团队技术栈与运维成本</strong>：引入一种新的数据库技术需要团队学习和适应，并且分布式系统的运维复杂度通常高于单机数据库。如果业务规模尚未达到 RDBMS 的瓶颈，盲目采用 NoSQL 可能会得不偿失。</li>
</ol>
<hr>
<h2 id="2-主流NoSQL数据库实践"><a href="#2-主流NoSQL数据库实践" class="headerlink" title="2. 主流NoSQL数据库实践"></a>2. 主流NoSQL数据库实践</h2><h3 id="2-1-Redis（后续章节详讲）"><a href="#2-1-Redis（后续章节详讲）" class="headerlink" title="2.1 Redis（后续章节详讲）"></a>2.1 Redis（后续章节详讲）</h3><p><strong>Redis</strong>（Remote Dictionary Server）是一个开源的、高性能的<strong>键值对内存数据库</strong>。它通常被用作数据库、缓存和消息中间件。</p>
<ul>
<li><strong>核心特点</strong>:<ul>
<li><strong>内存存储</strong>：数据主要存储在内存中，读写速度极快（可达10万次&#x2F;秒以上）。</li>
<li><strong>丰富的数据结构</strong>：支持字符串（Strings）、哈希（Hashes）、列表（Lists）、集合（Sets）、有序集合（Sorted Sets）等，使其能应用于更复杂的场景，而不仅仅是简单的键值缓存。</li>
<li><strong>持久化</strong>：提供 RDB（快照）和 AOF（追加式操作日志）两种方式将内存数据持久化到磁盘，防止数据丢失。</li>
<li><strong>高可用与分布式</strong>：通过 Redis Sentinel（哨兵）模式实现高可用，通过 Redis Cluster（集群）模式实现数据分片和分布式存储。</li>
</ul>
</li>
<li><strong>主要应用场景</strong>:<ul>
<li><strong>缓存</strong>：最常见的用途，缓存热点数据，极大减轻后端数据库（如MySQL）的压力。</li>
<li><strong>会话缓存</strong>（Session Store）：集中管理用户会话信息。</li>
<li><strong>排行榜&#x2F;计数器</strong>：利用有序集合轻松实现实时排名功能。</li>
<li><strong>消息队列</strong>：利用其发布订阅（Pub&#x2F;Sub）功能或列表结构实现简单的消息队列。</li>
<li><strong>分布式锁</strong>：在分布式系统中实现互斥访问。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-MongoDB（后续章节详讲）"><a href="#2-2-MongoDB（后续章节详讲）" class="headerlink" title="2.2 MongoDB（后续章节详讲）"></a>2.2 MongoDB（后续章节详讲）</h3><p><strong>MongoDB</strong> 是一个开源的、面向文档的 <strong>NoSQL 数据库</strong>。它将数据存储为类似JSON的BSON格式文档，模式非常灵活。</p>
<ul>
<li><strong>核心特点</strong>:<ul>
<li><strong>文档模型</strong>：数据以文档（Document）和集合（Collection）的形式组织，文档可以嵌套，非常适合表示复杂、层次化的数据结构。</li>
<li><strong>模式自由</strong>（Schema-less）：同一个集合中的文档可以拥有不同的字段结构，便于快速迭代开发。</li>
<li><strong>强大的查询语言</strong>：支持丰富的查询、过滤和聚合操作，功能上接近关系型数据库。</li>
<li><strong>水平扩展</strong>（分片）：通过分片（Sharding）技术可以轻松地在多台服务器上进行水平扩展，以处理海量数据和高吞吐量。</li>
</ul>
</li>
<li><strong>主要应用场景</strong>:<ul>
<li><strong>内容管理系统</strong>（CMS）：存储文章、评论、标签等灵活多变的内容。</li>
<li><strong>大数据和物联网</strong>（IoT）：存储设备产生的海量非结构化或半结构化数据。</li>
<li><strong>实时分析</strong>：结合聚合框架，对数据进行实时分析。</li>
<li><strong>社交和移动应用</strong>：存储用户动态、个人资料等信息。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-Elasticsearch"><a href="#2-3-Elasticsearch" class="headerlink" title="2.3 Elasticsearch"></a>2.3 <strong>Elasticsearch</strong></h3><p><strong>Elasticsearch</strong> 是一个开源的、分布式、RESTful 风格的<strong>搜索和分析引擎</strong>。它建立在 Apache Lucene 之上，以其强大的全文搜索能力而闻名。</p>
<ul>
<li><strong>核心特点</strong>:<ul>
<li><strong>全文搜索</strong>：提供强大的、基于倒排索引的全文搜索功能，支持模糊查询、同义词、高亮等。</li>
<li><strong>近实时搜索</strong>（NRT）：数据从被索引到可搜索仅需毫秒级延迟。</li>
<li><strong>分布式和高可用</strong>：天生就是分布式的，能够处理PB级数据，并通过分片和副本机制实现高可用和横向扩展。</li>
<li><strong>聚合分析</strong>：除了搜索，还提供了强大的数据聚合（Aggregation）功能，用于进行复杂的数据分析和统计。</li>
</ul>
</li>
<li><strong>主要应用场景</strong>:<ul>
<li><strong>应用程序搜索</strong>：为网站或应用提供搜索框功能（如电商网站的商品搜索）。</li>
<li><strong>日志处理与分析</strong>（ELK Stack）：与 Logstash 和 Kibana 组成著名的 ELK 栈，用于集中式日志收集、存储、分析和可视化。</li>
<li><strong>企业搜索</strong>：索引公司内部的各种文档、数据，提供统一的搜索入口。</li>
<li><strong>指标分析</strong>：监控和分析应用性能指标（APM）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-4-HBase"><a href="#2-4-HBase" class="headerlink" title="2.4 HBase"></a>2.4 HBase</h3><p><strong>HBase</strong> 是一个开源的、分布式的、面向列的 <strong>NoSQL 数据库</strong>。它模仿 Google 的 BigTable，运行在 Hadoop HDFS 之上，为大数据场景提供随机、实时的读写访问。</p>
<ul>
<li><strong>核心特点</strong>:<ul>
<li><strong>建立在HDFS之上</strong>：继承了HDFS的高可靠性和存储能力。</li>
<li><strong>面向列</strong>：数据按列族（Column Family）存储，非常适合稀疏数据，且查询时可以只读取指定的列，效率很高。</li>
<li><strong>强一致性</strong>：针对单行数据的读写是强一致性的。</li>
<li><strong>线性与模块化扩展</strong>：通过增加RegionServer节点可以轻松扩展集群的存储和处理能力。</li>
<li><strong>海量数据存储</strong>：专为存储数十亿行、数百万列的超大规模数据集而设计。</li>
</ul>
</li>
<li><strong>主要应用场景</strong>:<ul>
<li><strong>大数据平台</strong>：作为Hadoop生态系统的核心组件，存储海量明细数据，供后续的MapReduce、Spark等进行分析。</li>
<li><strong>实时查询</strong>：对存储在HBase中的超大表进行随机、实时的读写访问（如查询某个用户的订单历史）。</li>
<li><strong>时序数据</strong>：存储设备监控指标、金融交易记录等时间序列数据。</li>
<li><strong>消息服务</strong>：用于存储消息流数据（如Facebook的早期消息系统曾使用HBase）。</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="五、运维、架构与安全"><a href="#五、运维、架构与安全" class="headerlink" title="五、运维、架构与安全"></a>五、运维、架构与安全</h1><h2 id="1-数据库高可用架构"><a href="#1-数据库高可用架构" class="headerlink" title="1. 数据库高可用架构"></a>1. 数据库高可用架构</h2><h3 id="1-1-主从复制"><a href="#1-1-主从复制" class="headerlink" title="1.1 主从复制"></a>1.1 主从复制</h3><h4 id="1-1-1-核心概念"><a href="#1-1-1-核心概念" class="headerlink" title="1.1.1 核心概念"></a>1.1.1 核心概念</h4><p>MySQL 主从复制是一种<strong>数据同步机制</strong>，它允许将一台 MySQL 数据库服务器（称为 <strong>主库 Master</strong>）的数据实时、异步地复制到一个或多个其他的 MySQL 数据库服务器（称为 <strong>从库 Slave</strong>）。</p>
<ul>
<li><strong>主库 (Master)</strong>：负责处理所有<strong>写操作</strong>（INSERT, UPDATE, DELETE）。主库会将所有改变数据的操作记录到其二进制日志（Binary Log）中。</li>
<li><strong>从库 (Slave)</strong>：负责从主库<strong>读取</strong>二进制日志，并在本地<strong>重放</strong>（Replay）这些操作，从而使自己的数据与主库保持一致。从库通常用于处理读操作。</li>
</ul>
<p>这是一个单向的数据流，即数据只能从 Master 流向 Slave。一个 Master 可以有多个 Slave，但一个 Slave 通常只对应一个 Master。</p>
<hr>
<h4 id="1-1-2-核心作用-优势"><a href="#1-1-2-核心作用-优势" class="headerlink" title="1.1.2 核心作用&#x2F;优势"></a>1.1.2 核心作用&#x2F;优势</h4><p>主从复制是构建高性能、高可用数据库架构的基础，主要有以下三大优势：</p>
<ol>
<li><strong>读写分离 (Read-Write Splitting)</strong><ul>
<li><strong>场景</strong>：在读多写少的应用中（如新闻网站、电商平台），大量的读请求会给数据库带来巨大压力。</li>
<li><strong>实现</strong>：将写操作全部路由到 Master，将读操作分发到多个 Slave。这样，Master 的压力被大大减轻，可以更高效地处理写请求；同时，通过增加 Slave 节点的数量，可以线性地扩展系统的读性能。</li>
</ul>
</li>
<li><strong>高可用性 (High Availability) &#x2F; 故障转移 (Failover)</strong><ul>
<li><strong>场景</strong>：当 Master 服务器因硬件故障、网络问题或维护而宕机时，整个服务将陷入瘫痪。</li>
<li><strong>实现</strong>：主从复制架构下，如果 Master 宕机，可以迅速将一个数据最完整的 Slave 提升（Promote）为新的 Master，让应用连接到新的 Master 上，从而在短时间内恢复服务，极大地减少了服务中断时间。</li>
</ul>
</li>
<li><strong>数据备份与数据分析 (Backup &amp; Analytics)</strong><ul>
<li><strong>数据备份</strong>：可以在不影响主库性能的情况下，在从库上进行数据备份（例如使用 <code>mysqldump</code>）。因为备份操作会产生锁和大量的 I&#x2F;O，在从库上执行可以避免对线上写服务造成冲击。</li>
<li><strong>数据分析</strong>：一些复杂、耗时的报表查询或数据分析任务，可以放在从库上执行，避免这些慢查询拖垮主库，影响核心业务。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-1-3-工作原理"><a href="#1-1-3-工作原理" class="headerlink" title="1.1.3 工作原理"></a>1.1.3 工作原理</h4><p>MySQL 主从复制的核心是基于主库的<strong>二进制日志 (Binary Log, binlog)</strong>。整个过程主要涉及三个线程：</p>
<ul>
<li><strong>Master 的 <code>Binlog Dump</code> 线程</strong></li>
<li><strong>Slave 的 <code>I/O</code> 线程</strong></li>
<li><strong>Slave 的 <code>SQL</code> 线程</strong></li>
</ul>
<p><strong>复制过程分为三个步骤：</strong></p>
<ol>
<li><strong>Master 记录变更</strong>：<ul>
<li>当 Master 数据库执行一个写操作时（如 UPDATE），它会将这个操作的“事件”（Event）写入到自己的 <code>binlog</code> 文件中。</li>
<li><code>binlog</code> 是一个记录了所有数据更改逻辑的日志文件，是复制的基础。</li>
</ul>
</li>
<li><strong>Slave 请求并接收 binlog</strong>：<ul>
<li>Slave 服务器上有一个 <strong>I&#x2F;O 线程</strong>，它会主动连接到 Master 服务器。</li>
<li>Master 服务器接收到连接请求后，会为其创建一个 <strong><code>Binlog Dump</code> 线程</strong>。</li>
<li><code>Binlog Dump</code> 线程会读取 Master 上的 <code>binlog</code> 文件，并将 <code>binlog</code> 的内容发送给 Slave 的 <strong>I&#x2F;O 线程</strong>。</li>
<li>Slave 的 <strong>I&#x2F;O 线程</strong> 接收到 <code>binlog</code> 内容后，将其写入到 Slave 自己的<strong>中继日志 (Relay Log)</strong> 文件中。</li>
</ul>
</li>
<li><strong>Slave 重放 SQL 事件</strong>：<ul>
<li>Slave 服务器上有另一个核心线程——<strong>SQL 线程</strong>。</li>
<li><strong>SQL 线程</strong>会持续读取<strong>中继日志 (Relay Log)</strong> 中的事件。</li>
<li>然后，它会像一个客户端一样，在 Slave 数据库上<strong>原样执行</strong>这些事件，从而实现数据的同步。</li>
</ul>
</li>
</ol>
<p><strong>简易流程图：</strong></p>
<p><code>Master 写操作 -&gt; 写入 Master binlog -&gt; Master dump 线程发送 binlog -&gt; Slave I/O 线程接收并写入 Relay log -&gt; Slave SQL 线程读取 Relay log 并执行 -&gt; 数据同步完成</code></p>
<hr>
<h4 id="1-1-4-复制模式-格式-binlog-format"><a href="#1-1-4-复制模式-格式-binlog-format" class="headerlink" title="1.1.4 复制模式&#x2F;格式 (binlog_format)"></a>1.1.4 复制模式&#x2F;格式 (binlog_format)</h4><p><code>binlog</code> 记录事件的格式决定了复制的效率和准确性，主要有三种模式：</p>
<ol>
<li><strong>STATEMENT (基于语句的复制)</strong><ul>
<li><strong>原理</strong>：直接记录导致数据改变的原始 SQL 语句（如 <code>UPDATE my_table SET a=1 WHERE b=2</code>）。</li>
<li><strong>优点</strong>：日志文件体积小，节省网络 I&#x2F;O 和磁盘空间。</li>
<li><strong>缺点</strong>：可能存在<strong>数据不一致</strong>的风险。例如，使用 <code>UUID()</code>、<code>NOW()</code> 等非确定性函数，或者 <code>UPDATE ... LIMIT 1</code>（没有 <code>ORDER BY</code>）这类语句，在主从库上执行的结果可能不同。</li>
</ul>
</li>
<li><strong>ROW (基于行的复制)</strong><ul>
<li><strong>原理</strong>：不记录 SQL 语句，而是记录被修改的<strong>每一行数据</strong>的变更细节（修改前的值和修改后的值）。</li>
<li><strong>优点</strong>：非常安全，能保证主从数据绝对一致。</li>
<li><strong>缺点</strong>：日志文件体积可能非常大。例如，一条 <code>UPDATE</code> 语句更新了 100 万行数据，<code>binlog</code> 就会记录 100 万行的变更，导致 I&#x2F;O 和网络开销剧增。</li>
</ul>
</li>
<li><strong>MIXED (混合模式复制)</strong><ul>
<li><strong>原理</strong>：是 STATEMENT 和 ROW 模式的结合。默认情况下使用 STATEMENT 模式，当遇到不安全的 SQL 语句（如包含非确定性函数）时，自动切换到 ROW 模式。</li>
<li><strong>优点</strong>：兼顾了两种模式的优点，既保证了数据的一致性，又能在大多数情况下节省日志空间。这是 <strong>MySQL 5.7+ 版本的默认格式</strong>，也是目前最推荐的模式。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-1-5-同步模式"><a href="#1-1-5-同步模式" class="headerlink" title="1.1.5 同步模式"></a>1.1.5 同步模式</h4><ol>
<li><strong>异步复制 (Asynchronous)</strong><ul>
<li><strong>机制</strong>：Master 执行完写操作、写入 <code>binlog</code> 后，就立即向客户端返回成功，<strong>不会等待</strong> Slave 是否接收或执行成功。</li>
<li><strong>优点</strong>：性能最高，对主库的影响最小。</li>
<li><strong>缺点</strong>：数据一致性最弱。如果 Master 写入 <code>binlog</code> 后突然宕机，而 <code>binlog</code> 还没来得及传到任何一个 Slave，这部分数据就会永久丢失。</li>
</ul>
</li>
<li><strong>半同步复制 (Semi-synchronous)</strong><ul>
<li><strong>机制</strong>：Master 执行完写操作后，会<strong>等待至少一个 Slave</strong> 接收到 <code>binlog</code> 并写入自己的 Relay Log 后，才向客户端返回成功。</li>
<li><strong>优点</strong>：大大提高了数据一致性。只要 Master 发生宕机，至少会有一个 Slave 拥有最新的数据，可以被提升为新主库，从而避免数据丢失。</li>
<li><strong>缺点</strong>：会增加写操作的延迟（多了一个网络来回的时间）。如果所有 Slave 都出现故障或网络延迟严重，Master 的写操作会被阻塞（有超时机制 <code>rpl_semi_sync_master_timeout</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-1-6-常见问题与挑战"><a href="#1-1-6-常见问题与挑战" class="headerlink" title="1.1.6 常见问题与挑战"></a>1.1.6 常见问题与挑战</h4><ul>
<li><strong>主从延迟 (Replication Lag)</strong><ul>
<li><strong>现象</strong>：从库的数据同步进度落后于主库。</li>
<li><strong>原因</strong>：从库硬件性能差、网络延迟、从库上有慢查询、主库并发写入量远大于从库单线程重放能力（MySQL 5.6 之后支持多线程并行复制，有所缓解）。</li>
<li><strong>监控</strong>：通过 <code>SHOW SLAVE STATUS\G</code> 命令查看 <code>Seconds_Behind_Master</code> 的值。</li>
</ul>
</li>
<li><strong>数据不一致</strong><ul>
<li><strong>原因</strong>：使用了不安全的 STATEMENT 格式、人为在从库上执行了写操作、主从版本不一致等。</li>
<li><strong>解决</strong>：使用 ROW&#x2F;MIXED 格式，严格禁止对从库的写操作，并使用 <code>pt-table-checksum</code> 等工具定期校验数据。</li>
</ul>
</li>
<li><strong>主库单点故障 (SPOF - Single Point of Failure)</strong><ul>
<li>主从复制本身不提供自动故障转移。当主库宕机时，需要DBA手动或借助第三方高可用方案（如 MHA, Orchestrator, Keepalived）来完成 Slave 的提升和应用切换。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-读写分离"><a href="#1-2-读写分离" class="headerlink" title="1.2 读写分离"></a>1.2 读写分离</h3><h4 id="1-2-1-核心概念"><a href="#1-2-1-核心概念" class="headerlink" title="1.2.1 核心概念"></a>1.2.1 核心概念</h4><p>读写分离是一种数据库架构模式，它通过将数据库的<strong>读操作</strong>和<strong>写操作</strong>分发到不同的数据库服务器上来提高系统的整体性能和可用性。这个架构是<strong>基于主从复制</strong>实现的。</p>
<ul>
<li><strong>写操作 (Write Operations)</strong>：所有的增、删、改操作（<code>INSERT</code>, <code>DELETE</code>, <code>UPDATE</code>）都只在<strong>主库 (Master)</strong> 上进行。</li>
<li><strong>读操作 (Read Operations)</strong>：所有的查询操作（<code>SELECT</code>）都被分发到一台或多台<strong>从库 (Slave)</strong> 上进行。</li>
</ul>
<p>通过这种方式，原本集中在一台服务器上的读写压力被分散开，主库可以专注于处理高负载的写请求，而从库集群则可以水平扩展以应对海量的读请求。</p>
<hr>
<h4 id="1-2-2-核心作用-优势"><a href="#1-2-2-核心作用-优势" class="headerlink" title="1.2.2 核心作用&#x2F;优势"></a>1.2.2 核心作用&#x2F;优势</h4><ol>
<li><strong>性能提升与负载均衡 (Performance Improvement &amp; Load Balancing)</strong><ul>
<li><strong>分摊负载</strong>：将大量的读请求从主库剥离，避免了读写请求之间的资源竞争（如 CPU、I&#x2F;O、锁等）。</li>
<li><strong>提升并发</strong>：主库处理写的效率更高，从库可以并行处理大量读请求，整个数据库集群的并发处理能力得到显著提升。</li>
</ul>
</li>
<li><strong>可伸缩性 (Scalability)</strong><ul>
<li>当应用读请求量增长时，可以通过<strong>简单地增加从库节点</strong>来线性地扩展系统的读性能，这种方式被称为“水平扩展”（Horizontal Scaling），成本相对较低且易于实现。</li>
</ul>
</li>
<li><strong>提高可用性 (Increased Availability)</strong><ul>
<li>即使某个从库节点宕机，读请求可以被路由到其他健康的从库上，不会影响应用的整体读取功能。</li>
<li>结合主从复制的故障转移能力，当主库宕机时，可以快速切换到从库，进一步保障了整个系统的高可用性。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-2-3-实现方案"><a href="#1-2-3-实现方案" class="headerlink" title="1.2.3 实现方案"></a>1.2.3 实现方案</h4><p>读写分离并不是 MySQL 数据库自带的功能，它需要借助额外的组件或在应用层面进行逻辑控制。主要有两种实现方式：</p>
<ol>
<li><strong>应用层实现 (Application Level)</strong><ul>
<li><strong>原理</strong>：在应用程序的代码中实现数据库连接的管理和请求路由逻辑。应用内部会维护两个数据源（或连接池），一个指向主库（用于写），一个指向从库（用于读）。在执行数据库操作前，根据 SQL 语句的类型（如 <code>SELECT</code> 或 <code>UPDATE</code>）来决定使用哪个数据源。</li>
<li><strong>优点</strong>：<ul>
<li>实现简单直接，不依赖任何第三方组件。</li>
<li>灵活性高，可以根据业务需求进行精细化控制。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>代码侵入性强</strong>，业务代码与数据访问逻辑高度耦合。</li>
<li><strong>维护成本高</strong>，如果数据库地址变更或增减从库，需要修改所有相关应用的配置并重新部署。</li>
<li><strong>重复造轮子</strong>，每个项目或团队可能都需要自己实现一套读写分离逻辑。</li>
</ul>
</li>
</ul>
</li>
<li><strong>中间件代理层实现 (Middleware Proxy Level)</strong><ul>
<li><strong>原理</strong>：在应用服务器和数据库服务器之间引入一个独立的代理层。应用将所有 SQL 请求都发送给这个代理，代理负责解析 SQL 语句，然后根据其类型将写请求转发给主库，将读请求转发给从库集群。</li>
<li><strong>优点</strong>：<ul>
<li><strong>对应用透明</strong>，应用开发者无需关心后端的数据库架构，像连接单个数据库一样连接代理即可。</li>
<li><strong>易于维护</strong>，数据库的增减、主从切换等操作都可以在代理层统一配置，无需改动应用代码。</li>
<li><strong>功能强大</strong>，专业的中间件通常还提供负载均衡、健康检查、故障自动转移、分库分表等高级功能。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>架构复杂化</strong>，引入了新的组件，需要额外的部署和运维成本。</li>
<li><strong>可能成为性能瓶颈</strong>，所有流量都经过代理，代理自身的性能和稳定性至关重要。</li>
<li><strong>存在单点故障风险</strong>，代理层本身也需要做高可用部署（如 Keepalived+ProxySQL 双机热备）。</li>
</ul>
</li>
<li><strong>主流中间件</strong>：<ul>
<li><strong>ProxySQL</strong>：功能强大，性能优秀，是目前非常流行的选择。</li>
<li><strong>MyCAT</strong>：功能丰富，支持分库分表，是国内广泛使用的开源中间件。</li>
<li><strong>ShardingSphere-Proxy</strong>：Apache 顶级项目，提供了一整套分布式数据库解决方案，读写分离是其核心功能之一。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-2-4-核心挑战与注意事项"><a href="#1-2-4-核心挑战与注意事项" class="headerlink" title="1.2.4 核心挑战与注意事项"></a>1.2.4 核心挑战与注意事项</h4><p>实现读写分离后，会引入一个新的核心问题——<strong>数据一致性问题</strong>。</p>
<ol>
<li><strong>主从延迟 (Replication Lag)</strong><ul>
<li><strong>问题描述</strong>：由于主从复制是异步的，主库上的写操作传输到从库并应用需要一定时间，这个时间差就是主从延迟。如果在延迟期间，应用去从库读取数据，可能会读到<strong>旧的（过期的）数据</strong>。</li>
<li><strong>经典场景</strong>：用户注册后，立即进行登录，写操作在主库完成，但读（验证用户信息）操作被路由到尚未同步新用户数据的从库，导致登录失败。用户修改密码后，马上用新密码登录，也可能遇到同样问题。</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>强制读主 (Force Master Read)</strong>：对于数据一致性要求非常高的场景（如支付、用户权限验证），可以在执行完写操作后，将紧随其后的读请求强制路由到主库，确保能读到最新的数据。</li>
<li><strong>会话一致性 (Session Consistency)</strong>：在一次用户会话（Session）中，如果发生了写操作，那么该会话后续的所有读请求都在一定时间内被强制路由到主库。</li>
<li><strong>等待同步</strong>：在写操作后，业务代码可以短暂地等待（sleep）一下，或者通过检查从库的同步位点来确认数据已同步，但这种方式会增加响应时间。</li>
</ul>
</li>
</ul>
</li>
<li><strong>事务处理</strong><ul>
<li><strong>问题描述</strong>：一个事务中如果既包含读操作又包含写操作，必须保证整个事务内的所有 SQL 都被发送到<strong>主库</strong>执行，否则会破坏事务的原子性。</li>
<li><strong>解决方案</strong>：数据库中间件通常能智能识别事务（<code>BEGIN/COMMIT</code>），并将事务内的所有请求都路由到主库。在应用层实现时也需要特别处理这一点。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-3-分库分表"><a href="#1-3-分库分表" class="headerlink" title="1.3 分库分表"></a>1.3 分库分表</h3><h4 id="1-3-1-核心概念"><a href="#1-3-1-核心概念" class="headerlink" title="1.3.1 核心概念"></a>1.3.1 核心概念</h4><p>分库分表是一种将<strong>数据分散</strong>存储到多个数据库或多张表中的技术，用以解决单一数据库或单张数据表因数据量过大而导致的性能瓶颈问题。它与主从复制有本质区别：</p>
<ul>
<li><strong>主从复制</strong>：是数据的<strong>完整冗余</strong>，每个节点都拥有完整的数据副本。</li>
<li><strong>分库分表</strong>：是数据的<strong>分片</strong>（Partitioning），每个节点只存储完整数据的一部分。</li>
</ul>
<p>当业务发展到一定规模，读写分离架构中的<strong>主库</strong>会面临巨大的<strong>写压力</strong>，并且单表数据量过大（例如，达到数千万或上亿行）会导致查询、索引维护、DDL 操作（如加字段）等都变得极其缓慢。此时，就需要分库分表来分散压力。</p>
<hr>
<h4 id="1-3-2-为什么需要分库分表"><a href="#1-3-2-为什么需要分库分表" class="headerlink" title="1.3.2 为什么需要分库分表"></a>1.3.2 为什么需要分库分表</h4><p>当单一数据库实例遇到以下瓶颈时，就需要考虑分库分表：</p>
<ol>
<li><strong>I&#x2F;O 瓶颈</strong>：单机的磁盘读写速率达到上限。</li>
<li><strong>CPU 瓶颈</strong>：大量的查询和计算（如排序、聚合）耗尽了 CPU 资源。</li>
<li><strong>内存瓶颈</strong>：海量数据导致索引大小和缓存数据远超内存容量，缓存命中率急剧下降。</li>
<li><strong>连接数瓶颈</strong>：数据库的连接数有限，高并发请求可能导致连接耗尽。</li>
<li><strong>单表数据量过大</strong>：<ul>
<li><strong>查询性能下降</strong>：即使有索引，B+Tree 的层级也会变深，查询效率降低。</li>
<li><strong>索引维护成本高</strong>：对大表的 <code>INSERT</code> 和 <code>UPDATE</code> 操作会导致索引频繁重排，性能开销大。</li>
<li><strong>DDL 操作困难</strong>：对一张亿级数据的表执行 <code>ALTER TABLE</code> 可能会锁表数小时，引发生产事故。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-3-3-拆分策略"><a href="#1-3-3-拆分策略" class="headerlink" title="1.3.3 拆分策略"></a>1.3.3 拆分策略</h4><p>拆分主要分为<strong>垂直拆分</strong>和<strong>水平拆分</strong>两种方式，它们可以独立使用，也可以结合使用。</p>
<ol>
<li><strong>垂直拆分 (Vertical Sharding)</strong><ul>
<li><strong>核心思想</strong>：按业务或功能维度进行拆分。</li>
<li><strong>垂直分库</strong>：将一个业务耦合度较高的数据库，按业务模块拆分成多个独立的数据库。例如，将一个电商数据库拆分为 <code>用户库</code>、<code>商品库</code>、<code>订单库</code>。<ul>
<li><strong>优点</strong>：业务解耦，不同业务的数据库可以独立部署和扩容，避免了业务间的相互影响。</li>
<li><strong>缺点</strong>：无法解决单表数据量过大的问题，可能会引入跨库 JOIN 和分布式事务。</li>
</ul>
</li>
<li><strong>垂直分表</strong>：将一张包含很多列的宽表，拆分成多张窄表。例如，将 <code>user</code> 表拆分为 <code>user_base</code>（存储登录信息）和 <code>user_profile</code>（存储详细信息）。<ul>
<li><strong>优点</strong>：可以使核心数据表变得更小，提高缓存命中率，提升查询性能。</li>
<li><strong>缺点</strong>：需要通过 JOIN 进行关联查询，增加了编码复杂性。</li>
</ul>
</li>
</ul>
</li>
<li><strong>水平拆分 (Horizontal Sharding)</strong><ul>
<li><strong>核心思想</strong>：按某种规则将一张表的数据行拆分到多张结构相同的表中。这是<strong>解决单表数据量过大</strong>问题的核心手段。</li>
<li><strong>水平分库</strong>：将数据分散到多个不同的数据库实例中。例如，<code>user_db_01</code>、<code>user_db_02</code>。</li>
<li><strong>水平分表</strong>：在同一个数据库中，将一张大表拆分成多张小表。例如，<code>order_00</code>, <code>order_01</code>, …, <code>order_99</code>。</li>
<li><strong>优点</strong>：<ul>
<li>彻底解决了单表数据量过大的问题。</li>
<li>数据被分散到不同库&#x2F;表中，写压力被有效均摊。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>架构复杂度急剧增加。</li>
<li>引入了诸多技术挑战（见下文）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>通常，实践中采用的策略是<strong>先垂直拆分（按业务）</strong>，当某个业务的单表数据量依然过大时，再对该业务进行<strong>水平拆分</strong>。</p>
<hr>
<h4 id="1-3-4-水平拆分的路由算法-Sharding-Rule"><a href="#1-3-4-水平拆分的路由算法-Sharding-Rule" class="headerlink" title="1.3.4 水平拆分的路由算法 (Sharding Rule)"></a>1.3.4 水平拆分的路由算法 (Sharding Rule)</h4><p>如何决定一条数据应该被存放到哪个分片（哪个库的哪张表）？这由<strong>分片键 (Shard Key)</strong> 和<strong>路由算法</strong>决定。</p>
<ol>
<li><strong>范围路由 (Range Sharding)</strong><ul>
<li><strong>规则</strong>：根据分片键的范围来划分。例如，按时间（<code>2023年Q1的数据放分片1，Q2的数据放分片2</code>）或按ID区间（<code>ID 1-1000万放分片1，1001-2000万放分片2</code>）。</li>
<li><strong>优点</strong>：便于范围查询和数据扩展。</li>
<li><strong>缺点</strong>：容易导致<strong>数据倾斜</strong>（热点问题）。例如，新注册用户的 ID 总是落在最后一个分片，导致该分片负载过高。</li>
</ul>
</li>
<li><strong>哈希路由 (Hash Sharding)</strong><ul>
<li><strong>规则</strong>：根据分片键的哈希值来决定分片。最简单的是取模算法：<code>shard_index = hash(shard_key) % N</code>（N为分片总数）。</li>
<li><strong>优点</strong>：数据分布比较均匀，不容易出现热点问题。</li>
<li><strong>缺点</strong>：<ul>
<li><strong>范围查询不友好</strong>：需要查询所有分片，然后在内存中聚合排序。</li>
<li><strong>扩容困难</strong>：当分片数量 N 变化时（如从 2 个扩容到 3 个），大部分数据的 <code>hash % N</code> 结果都会改变，导致大规模的数据迁移。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-3-5-引入的挑战与解决方案"><a href="#1-3-5-引入的挑战与解决方案" class="headerlink" title="1.3.5 引入的挑战与解决方案"></a>1.3.5 引入的挑战与解决方案</h4><p>分库分表虽然强大，但也带来了巨大的复杂性：</p>
<ol>
<li><strong>分布式事务</strong><ul>
<li><strong>问题</strong>：一个操作可能需要同时修改多个分库的数据，如何保证其原子性？例如，用户 A 向用户 B 转账，A 和 B 的数据在不同的分库中。</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>两阶段提交 (2PC&#x2F;XA)</strong>：数据库层面的强一致性方案，但性能差，且存在单点故障和阻塞风险。</li>
<li><strong>柔性事务 (BASE理论)</strong>：通过 TCC（Try-Confirm-Cancel）、Saga（长事务）、本地消息表等方案实现最终一致性。</li>
</ul>
</li>
</ul>
</li>
<li><strong>跨库 JOIN 查询</strong><ul>
<li><strong>问题</strong>：无法直接在不同数据库实例之间执行 <code>JOIN</code> 操作。</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>字段冗余</strong>：将需要关联的字段冗余存储一份，避免 JOIN。</li>
<li><strong>数据同步</strong>：将一些基础表（如字典表）在每个分库中都同步一份。</li>
<li><strong>应用层聚合</strong>：分别查询各个分库，然后在应用代码层面进行数据组装。</li>
</ul>
</li>
</ul>
</li>
<li><strong>全局唯一 ID</strong><ul>
<li><strong>问题</strong>：数据库自带的 <code>AUTO_INCREMENT</code> 无法在分库分表后保证全局唯一和趋势递增。</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>UUID</strong>：简单，但无序且字符串形式占用空间大，不适合做主键。</li>
<li><strong>雪花算法 (Snowflake)</strong>：Twitter 开源的分布式 ID 生成算法，生成的 ID 是趋势递增的 64 位整数，性能高。</li>
<li><strong>号段模式 (Segment)</strong>：从一个中心化的发号服务中批量获取一段 ID，在本地使用，用完再取。</li>
</ul>
</li>
</ul>
</li>
<li><strong>分页与排序</strong><ul>
<li><strong>问题</strong>：<code>ORDER BY ... LIMIT</code> 这类操作无法在单个分片上完成。</li>
<li><strong>解决方案</strong>：需要在所有分片上执行查询，将结果在代理层或应用层进行<strong>内存排序和聚合</strong>，然后返回最终的分页结果。数据量大时性能极差。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-3-6-实现方案"><a href="#1-3-6-实现方案" class="headerlink" title="1.3.6 实现方案"></a>1.3.6 实现方案</h4><p>与读写分离类似，分库分表也可以通过两种方式实现：</p>
<ol>
<li><strong>客户端&#x2F;SDK 层</strong><ul>
<li><strong>代表</strong>：<code>Sharding-JDBC</code> (现已并入 <code>Apache ShardingSphere</code>)。</li>
<li><strong>原理</strong>：以 <code>jar</code> 包形式集成在应用中，应用在执行 SQL 时，SDK 会对 SQL 进行拦截、解析、路由和结果归并。</li>
<li><strong>优点</strong>：轻量，无额外部署，性能损耗小。</li>
<li><strong>缺点</strong>：对应用代码有侵入，与特定编程语言绑定，升级维护麻烦。</li>
</ul>
</li>
<li><strong>中间件代理层</strong><ul>
<li><strong>代表</strong>：<code>MyCAT</code>, <code>ProxySQL</code> (部分支持), <code>ShardingSphere-Proxy</code>。</li>
<li><strong>原理</strong>：部署一个独立的代理服务，应用像连接普通 MySQL 一样连接代理，代理负责后续的分片逻辑。</li>
<li><strong>优点</strong>：对应用透明，支持多语言，维护和治理方便。</li>
<li><strong>缺点</strong>：增加了架构复杂度和网络延迟，代理自身可能成为性能瓶颈和单点，需要做高可用。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-4-数据库中间件"><a href="#1-4-数据库中间件" class="headerlink" title="1.4 数据库中间件"></a>1.4 数据库中间件</h3><h4 id="1-4-1-核心概念"><a href="#1-4-1-核心概念" class="headerlink" title="1.4.1 核心概念"></a>1.4.1 核心概念</h4><p>数据库中间件是一个独立的、介于<strong>应用程序</strong>和<strong>数据库服务器</strong>之间的<strong>代理服务</strong>。对于应用程序而言，它表现得就像一个单一、强大的数据库；而实际上，它在底层管理着一个复杂的、由多个数据库实例组成的集群。</p>
<p><strong>核心思想</strong>：通过引入一个代理层，将后端数据库集群的复杂性（如主从关系、分片规则）对上层应用<strong>屏蔽</strong>掉。应用程序只需将所有 SQL 请求发送给中间件，由中间件负责解析、路由、执行和结果聚合，从而实现对应用的<strong>透明化</strong>。</p>
<p><strong>简单比喻</strong>：数据库中间件就像一个智能的 SQL 路由器或交通指挥官。它检查每一条 SQL “车辆”，根据其目的地（读&#x2F;写）和特征（分片键），将其精确地导向正确的数据库 “道路”（主库、从库或某个分片），最后再将结果汇总返回。</p>
<hr>
<h4 id="1-4-2-核心功能"><a href="#1-4-2-核心功能" class="headerlink" title="1.4.2 核心功能"></a>1.4.2 核心功能</h4><p>数据库中间件的核心功能正是为了解决和实现前几节提到的架构挑战：</p>
<ol>
<li><strong>数据路由 (Data Routing)</strong><ul>
<li><strong>读写分离路由</strong>：自动解析 SQL 语句。将 <code>SELECT</code> 请求根据负载均衡策略（如轮询、权重）路由到从库集群；将 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 请求路由到主库。</li>
<li><strong>分库分表路由</strong>：根据预设的<strong>分片规则</strong>，解析 SQL 中的<strong>分片键 (Shard Key)</strong>，计算出该 SQL 应该被路由到哪个（或哪些）具体的数据库分片和物理表。</li>
</ul>
</li>
<li><strong>结果归并 (Result Merging)</strong><ul>
<li>当一个查询需要跨多个分片执行时（例如，没有带分片键的查询，或范围查询），中间件会将查询下发到所有相关的分片。</li>
<li>待所有分片返回结果后，中间件会在内存中对这些结果集进行<strong>合并</strong>、<strong>排序</strong>、<strong>分页</strong>（<code>LIMIT</code>）、<strong>聚合</strong>（<code>GROUP BY</code>, <code>AVG()</code>）等操作，最后将一个完整、正确的结果集返回给应用程序。</li>
</ul>
</li>
<li><strong>连接管理与负载均衡 (Connection Management &amp; Load Balancing)</strong><ul>
<li>中间件自身维护了与后端所有数据库实例的连接池，减少了应用端频繁创建和销毁连接的开销。</li>
<li>对从库集群的读请求进行负载均衡，避免单个从库压力过大。</li>
</ul>
</li>
<li><strong>高可用与故障转移 (High Availability &amp; Failover)</strong><ul>
<li>通过<strong>健康检查</strong>机制实时监控后端数据库实例的存活状态。</li>
<li>当检测到主库宕机时，能够（通常结合其他高可用组件）实现<strong>自动或半自动的主从切换</strong>，将流量平滑地切换到新的主库，对应用层无感知。</li>
<li>当某个从库宕机时，能自动将其从读请求的路由列表中剔除。</li>
</ul>
</li>
<li><strong>其他增值功能</strong><ul>
<li><strong>SQL 审计与日志</strong>：记录所有经过中间件的 SQL，便于问题排查和安全审计。</li>
<li><strong>访问控制与黑白名单</strong>：提供一层额外的安全防护。</li>
<li><strong>监控与统计</strong>：提供丰富的性能监控指标，如 QPS、TPS、慢查询等。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-4-3-架构模式"><a href="#1-4-3-架构模式" class="headerlink" title="1.4.3 架构模式"></a>1.4.3 架构模式</h4><p>实现数据库中间件主要有两种主流的架构模式：</p>
<ol>
<li><strong>代理模式 (Proxy Model)</strong><ul>
<li><strong>代表产品</strong>：<code>MyCAT</code>, <code>ProxySQL</code>, <code>Apache ShardingSphere-Proxy</code>。</li>
<li><strong>工作方式</strong>：以一个独立的服务进程部署在服务器上。应用程序像连接一个普通的 MySQL 数据库一样连接到 Proxy 的 IP 和端口。</li>
<li><strong>优点</strong>：<ul>
<li>对应用<strong>完全透明</strong>，无需修改应用代码。</li>
<li>支持<strong>多语言</strong>，任何能连接 MySQL 的客户端都可以使用。</li>
<li>便于<strong>集中管理</strong>和维护。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>增加了一次网络跳转，会带来轻微的<strong>性能延迟</strong>。</li>
<li>Proxy 自身可能成为<strong>性能瓶颈</strong>和<strong>单点故障</strong>，需要对其进行高可用部署（如 LVS&#x2F;Keepalived + 多 Proxy 实例）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>客户端模式 (Client&#x2F;SDK Model)</strong><ul>
<li><strong>代表产品</strong>：<code>Apache ShardingSphere-JDBC</code> (原 <code>Sharding-JDBC</code>)。</li>
<li><strong>工作方式</strong>：以一个 <code>jar</code> 包或库的形式被集成到应用程序中。它会重写应用的 JDBC 接口，在应用内部完成 SQL 的解析、路由和结果归并。</li>
<li><strong>优点</strong>：<ul>
<li><strong>性能最优</strong>，因为没有额外的网络开销，应用直连数据库。</li>
<li>架构简单，没有额外的部署环节。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>对应用代码有<strong>侵入性</strong>。</li>
<li>与<strong>特定编程语言绑定</strong>（如 ShardingSphere-JDBC 主要服务于 Java）。</li>
<li>升级和维护较为困难，需要所有引用它的应用同步升级。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-4-4-主流数据库中间件选介"><a href="#1-4-4-主流数据库中间件选介" class="headerlink" title="1.4.4 主流数据库中间件选介"></a>1.4.4 主流数据库中间件选介</h4><ol>
<li><strong>Apache ShardingSphere</strong><ul>
<li>一个功能全面的生态系统，提供了一整套分布式数据库解决方案。</li>
<li>包含 <code>ShardingSphere-JDBC</code> (客户端模式) 和 <code>ShardingSphere-Proxy</code> (代理模式) 两种形态，可按需选择。</li>
<li>功能非常强大，除了读写分离、分库分表，还支持分布式事务、数据脱敏、影子库等高级特性。</li>
</ul>
</li>
<li><strong>MyCAT</strong><ul>
<li>一款成熟、稳定、社区活跃的开源中间件，在国内有广泛应用。</li>
<li>基于 Proxy 模式，专注于分库分表场景。</li>
<li>功能丰富，支持 SQL 拦截、多种分片算法、全局序列号等。</li>
</ul>
</li>
<li><strong>ProxySQL</strong><ul>
<li>一款轻量级、高性能的数据库代理。</li>
<li>其最大优势在于其<strong>强大而灵活的路由规则</strong>和<strong>出色的读写分离与故障转移</strong>能力。</li>
<li>虽然也支持分片，但其核心优势场景更多是读写分离和连接管理。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-运维与安全"><a href="#2-运维与安全" class="headerlink" title="2. 运维与安全"></a>2. 运维与安全</h2><h3 id="2-1-备份与恢复"><a href="#2-1-备份与恢复" class="headerlink" title="2.1 备份与恢复"></a>2.1 备份与恢复</h3><h4 id="2-1-1-备份与恢复的重要性"><a href="#2-1-1-备份与恢复的重要性" class="headerlink" title="2.1.1 备份与恢复的重要性"></a>2.1.1 备份与恢复的重要性</h4><p>数据是企业的核心资产。任何数据的丢失都可能导致巨大的经济损失和声誉损害。备份与恢复是应对以下灾难场景的根本保障：</p>
<ul>
<li><strong>硬件故障</strong>：如磁盘损坏、服务器宕机。</li>
<li><strong>人为误操作</strong>：如 <code>DELETE</code>&#x2F;<code>UPDATE</code> 忘记加 <code>WHERE</code> 条件、<code>DROP TABLE</code> 等。</li>
<li><strong>软件 Bug</strong>：应用程序或数据库本身的缺陷导致数据损坏或丢失。</li>
<li><strong>恶意攻击</strong>：如黑客删库、勒索病毒加密数据。</li>
<li><strong>自然灾害</strong>：如火灾、地震导致机房损毁。</li>
<li><strong>合规性要求</strong>：某些行业法规要求数据必须保留特定年限，需要历史备份。</li>
</ul>
<blockquote>
<p><strong>一句话总结：没有经过恢复测试的备份，都不能称之为有效的备份。</strong></p>
</blockquote>
<hr>
<h4 id="2-1-2-备份类型"><a href="#2-1-2-备份类型" class="headerlink" title="2.1.2 备份类型"></a>2.1.2 备份类型</h4><p>我们可以从不同维度对备份进行分类：</p>
<h5 id="1-按备份内容划分：逻辑备份-vs-物理备份"><a href="#1-按备份内容划分：逻辑备份-vs-物理备份" class="headerlink" title="1. 按备份内容划分：逻辑备份 vs. 物理备份"></a>1. 按备份内容划分：逻辑备份 vs. 物理备份</h5><ul>
<li><strong>逻辑备份 (Logical Backup)</strong><ul>
<li><strong>原理</strong>：将数据库中的数据导出为一系列 SQL 语句（如 <code>CREATE TABLE</code>, <code>INSERT INTO</code>）或特定格式的文本文件（如 CSV）。</li>
<li><strong>代表工具</strong>：<code>mysqldump</code>。</li>
<li><strong>优点</strong>：<ul>
<li><strong>可读性强</strong>：备份文件是文本格式，易于查看和编辑。</li>
<li><strong>平台无关</strong>：可以在不同 MySQL 版本、不同操作系统甚至不同数据库（如 PostgreSQL）之间进行迁移。</li>
<li><strong>灵活性高</strong>：可以只备份指定的库或表。</li>
<li><strong>占用空间小</strong>：备份文件通常经过压缩，体积较小。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>恢复速度慢</strong>：恢复时需要逐条执行 SQL 语句，重新插入数据、构建索引，对于大数据量，过程非常漫长。</li>
<li><strong>备份时对数据库有一定性能影响</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>物理备份 (Physical Backup)</strong><ul>
<li><strong>原理</strong>：直接复制数据库的原始数据文件（如 <code>.ibd</code>, <code>.frm</code> 文件）、日志文件等。</li>
<li><strong>代表工具</strong>：<code>Percona XtraBackup</code>、文件系统工具（如 <code>cp</code>, <code>rsync</code>，但只能用于冷备）。</li>
<li><strong>优点</strong>：<ul>
<li><strong>恢复速度极快</strong>：恢复过程只是将文件复制回原位，无需执行 SQL 和重建索引。</li>
<li><strong>备份过程对业务性能影响小</strong>（特别是使用 <code>XtraBackup</code> 进行热备时）。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>平台依赖性强</strong>：通常要求 MySQL 版本、操作系统、架构等与备份时一致。</li>
<li><strong>占用空间大</strong>：备份的是整个数据目录，体积较大。</li>
<li><strong>灵活性差</strong>：通常只能进行全库级别的备份和恢复。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-按数据库状态划分：热备、温备、冷备"><a href="#2-按数据库状态划分：热备、温备、冷备" class="headerlink" title="2. 按数据库状态划分：热备、温备、冷备"></a>2. 按数据库状态划分：热备、温备、冷备</h5><ul>
<li><strong>冷备份 (Cold Backup)</strong>：在<strong>关闭数据库</strong>服务的情况下进行备份。数据绝对一致，但业务会中断。</li>
<li><strong>温备份 (Warm Backup)</strong>：在数据库运行时进行，但会对要备份的数据<strong>加锁</strong>（如全局读锁），导致业务只能读不能写。</li>
<li><strong>热备份 (Hot Backup)</strong>：在数据库<strong>正常运行</strong>的情况下进行，对业务的读写操作几乎没有影响。这是生产环境中最理想的备份方式。<code>Percona XtraBackup</code> 是实现 InnoDB 热备的最佳工具。</li>
</ul>
<hr>
<h5 id="3-按数据范围划分：全量、增量、差异备份"><a href="#3-按数据范围划分：全量、增量、差异备份" class="headerlink" title="3. 按数据范围划分：全量、增量、差异备份"></a>3. 按数据范围划分：全量、增量、差异备份</h5><ul>
<li><strong>全量备份 (Full Backup)</strong>：备份整个数据库的完整数据。</li>
<li><strong>增量备份 (Incremental Backup)</strong>：仅备份自<strong>上一次备份</strong>（无论是全量还是增量）以来发生变化的数据。</li>
<li><strong>差异备份 (Differential Backup)</strong>：仅备份自<strong>上一次全量备份</strong>以来发生变化的数据。</li>
</ul>
<hr>
<h4 id="2-1-3-核心备份工具"><a href="#2-1-3-核心备份工具" class="headerlink" title="2.1.3 核心备份工具"></a>2.1.3 核心备份工具</h4><h5 id="1-mysqldump-逻辑备份工具"><a href="#1-mysqldump-逻辑备份工具" class="headerlink" title="1. mysqldump (逻辑备份工具)"></a>1. <code>mysqldump</code> (逻辑备份工具)</h5><ul>
<li><p>MySQL 官方自带，使用最广泛的逻辑备份工具。</p>
</li>
<li><p><strong>常用命令示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份单个数据库</span></span><br><span class="line">mysqldump -u root -p db_name &gt; db_name_backup.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份所有数据库</span></span><br><span class="line">mysqldump -u root -p --all-databases &gt; all_databases_backup.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产环境推荐：使用单事务模式进行热备 (仅对 InnoDB 有效)</span></span><br><span class="line"><span class="comment"># --master-data=2 会在备份文件中记录下备份时刻的 binlog 位点，对时间点恢复至关重要</span></span><br><span class="line">mysqldump -u root -p --single-transaction --master-data=2 db_name &gt; db_name_backup.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>恢复命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录 MySQL 后执行</span></span><br><span class="line"><span class="built_in">source</span> /path/to/backup.sql;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或在 Shell 中直接执行</span></span><br><span class="line">mysql -u root -p db_name &lt; /path/to/backup.sql</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-Percona-XtraBackup-物理热备工具"><a href="#2-Percona-XtraBackup-物理热备工具" class="headerlink" title="2. Percona XtraBackup (物理热备工具)"></a>2. <code>Percona XtraBackup</code> (物理热备工具)</h5><ul>
<li>业界公认的、开源的、针对 InnoDB 存储引擎的物理热备解决方案。</li>
<li><strong>工作流程（简化版）</strong>：<ol>
<li><strong>备份 (Backup)</strong>：使用 <code>xtrabackup</code> 命令创建备份。它会复制 InnoDB 数据文件，并持续跟踪备份期间产生的 redo log (重做日志)。</li>
<li><strong>准备 (Prepare)</strong>：在恢复前，对备份文件执行 “准备” 操作。此步骤会将备份期间产生的 redo log 应用到数据文件中，使其达到数据一致的状态。</li>
<li><strong>恢复 (Restore)</strong>：将准备好的数据文件复制回 MySQL 的数据目录，修改文件权限，然后启动 MySQL 服务。</li>
</ol>
</li>
<li><strong>优点</strong>：实现了真正的 InnoDB 热备，备份速度快，恢复速度极快，对生产环境影响极小。</li>
</ul>
<hr>
<h4 id="2-1-4-基于-Binlog-的时间点恢复-Point-in-Time-Recovery-PITR"><a href="#2-1-4-基于-Binlog-的时间点恢复-Point-in-Time-Recovery-PITR" class="headerlink" title="2.1.4 基于 Binlog 的时间点恢复 (Point-in-Time Recovery - PITR)"></a><strong>2.1.4 基于 Binlog 的时间点恢复 (Point-in-Time Recovery - PITR)</strong></h4><p>这是数据库恢复的 “终极武器”，可以将数据库恢复到<strong>任意一个精确的时间点</strong>（例如，恢复到误操作发生前一秒）。</p>
<ul>
<li><p><strong>前提</strong>：必须开启二进制日志 (<code>binlog</code>)。</p>
</li>
<li><p><strong>恢复步骤</strong>：</p>
<ol>
<li>找到离故障时间点最近的一次<strong>全量备份</strong>（物理或逻辑备份皆可）。</li>
<li>将这个全量备份<strong>恢复</strong>到一个临时的 MySQL 实例中。</li>
<li>从全量备份文件中找到备份结束时的 <code>binlog</code> 文件名和位置点（position）。</li>
<li>使用 <code>mysqlbinlog</code> 工具，将从该位点开始到指定恢复时间点之间的所有 <code>binlog</code> 日志提取出来。</li>
<li>将提取出的 <code>binlog</code> SQL 语句应用到已恢复的临时实例中。</li>
<li>至此，数据库就恢复到了指定的时间点。</li>
</ol>
<p><strong>示例场景</strong>：周日凌晨做了一次全量备份。周一下午 14:30 发生了误删表操作。<br><strong>恢复流程</strong>：先恢复周日的全量备份，然后将周日备份结束到周一下午 14:29:59 之间的所有 <code>binlog</code> 应用一遍。</p>
</li>
</ul>
<hr>
<h4 id="2-1-5-制定备份策略"><a href="#2-1-5-制定备份策略" class="headerlink" title="2.1.5 制定备份策略"></a><strong>2.1.5 制定备份策略</strong></h4><p>一个健壮的备份策略应综合考虑 RPO（恢复点目标，能容忍丢失多少数据）和 RTO（恢复时间目标，能容忍服务中断多久）。</p>
<ul>
<li><strong>备份周期</strong>：<ul>
<li><strong>全量备份</strong>：每周一次（如周日凌晨）。</li>
<li><strong>增量&#x2F;差异备份</strong>：每天一次（如每日凌晨）。</li>
<li><strong><code>binlog</code></strong>：实时产生，应定期备份到安全的存储位置。</li>
</ul>
</li>
<li><strong>备份存储</strong>：<ul>
<li><strong>本地存储</strong>：用于快速恢复。</li>
<li><strong>异地存储</strong>：将备份文件传输到远程服务器或云存储（如 AWS S3），防止机房级灾难。</li>
<li>遵循 <strong>3-2-1 原则</strong>：至少三份数据副本，存储在两种不同类型的介质上，其中一份必须在异地。</li>
</ul>
</li>
<li><strong>验证与演练</strong>：<ul>
<li>定期（如每季度）进行<strong>恢复演练</strong>，验证备份文件的可用性，并熟悉恢复流程，确保在真正发生灾难时能够从容应对。</li>
</ul>
</li>
<li><strong>监控与告警</strong>：<ul>
<li>对备份任务进行监控，确保其每日成功执行。如果备份失败，应立即发送告警。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-监控"><a href="#2-2-监控" class="headerlink" title="2.2 监控"></a>2.2 监控</h3><h4 id="2-2-1-监控的核心目标"><a href="#2-2-1-监控的核心目标" class="headerlink" title="2.2.1 监控的核心目标"></a>2.2.1 监控的核心目标</h4><p>数据库监控并非简单地收集数据和绘制图表，其根本目标在于：</p>
<ol>
<li><strong>主动发现问题 (Proactive Problem Detection)</strong>：在问题影响到业务之前，通过监控指标的异常变化提前预警，防患于未然。</li>
<li><strong>性能分析与调优 (Performance Analysis &amp; Tuning)</strong>：通过监控数据找到系统瓶颈（如慢查询、锁竞争、I&#x2F;O瓶颈），为优化提供数据支撑。</li>
<li><strong>容量规划 (Capacity Planning)</strong>：根据资源使用率（CPU、磁盘、内存）和业务增长趋势，预测未来的资源需求，提前进行扩容。</li>
<li><strong>故障排查与根因分析 (Troubleshooting &amp; Root Cause Analysis)</strong>：当故障发生时，历史监控数据是快速定位问题根源的最重要依据。</li>
</ol>
<hr>
<h4 id="2-2-2-监控的维度与核心指标"><a href="#2-2-2-监控的维度与核心指标" class="headerlink" title="2.2.2 监控的维度与核心指标"></a>2.2.2 监控的维度与核心指标</h4><p>一个全面的 MySQL 监控体系应覆盖从底层硬件到上层应用的全链路。主要分为以下几个维度：</p>
<h5 id="1-系统层监控-OS-Level"><a href="#1-系统层监控-OS-Level" class="headerlink" title="1. 系统层监控 (OS Level)"></a>1. 系统层监控 (OS Level)</h5><p>这是数据库稳定运行的基础。</p>
<ul>
<li><strong>CPU</strong>：<ul>
<li><code>CPU 使用率</code>：整体使用率，以及用户态(us)、系统态(sy)、I&#x2F;O等待(wa)的细分。<code>iowait</code> 过高通常意味着磁盘I&#x2F;O是瓶颈。</li>
</ul>
</li>
<li><strong>内存 (Memory)</strong>：<ul>
<li><code>内存使用率</code>：包括已用、可用、缓存(cache&#x2F;buffer)等。</li>
<li><code>Swap 使用情况</code>：如果 Swap 频繁发生换入换出，说明物理内存严重不足，这将极大地影响 MySQL 性能。</li>
</ul>
</li>
<li><strong>磁盘 (Disk)</strong>：<ul>
<li><code>磁盘空间使用率</code>：防止因数据或日志写满磁盘导致数据库崩溃。</li>
<li><code>磁盘 I/O</code>：<code>IOPS</code> (每秒读写次数) 和 <code>吞吐量</code> (MB&#x2F;s)。监控磁盘 I&#x2F;O 是否达到瓶颈。</li>
</ul>
</li>
<li><strong>网络 (Network)</strong>：<ul>
<li><code>网络流量</code> (进&#x2F;出)：监控流量是否异常。</li>
<li><code>TCP 连接状态</code>：如 <code>TIME_WAIT</code> 连接数过多等问题。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-MySQL-服务层监控"><a href="#2-MySQL-服务层监控" class="headerlink" title="2. MySQL 服务层监控"></a>2. MySQL 服务层监控</h5><ul>
<li><strong>服务可用性</strong>：MySQL 进程是否存在，端口是否可达。</li>
<li><strong>连接数</strong>：<ul>
<li><code>Threads_connected</code>：当前打开的连接数。</li>
<li><code>Threads_running</code>：<strong>（核心指标）</strong> 正在活动（执行查询）的线程数。此值持续过高通常意味着有大量慢查询或CPU瓶颈。</li>
<li><code>Max_connections</code>：最大连接数配置，<code>Threads_connected</code> 接近此值时，新连接将无法建立。</li>
</ul>
</li>
<li><strong>QPS &amp; TPS (Queries&#x2F;Transactions Per Second)</strong>：<ul>
<li><code>QPS</code> (每秒查询数): <code>(Questions / Uptime)</code>。反映数据库的繁忙程度。</li>
<li><code>TPS</code> (每秒事务数): <code>((Com_commit + Com_rollback) / Uptime)</code>。反映数据库的事务处理能力。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-InnoDB-存储引擎层监控（核心）"><a href="#3-InnoDB-存储引擎层监控（核心）" class="headerlink" title="3. InnoDB 存储引擎层监控（核心）"></a>3. InnoDB 存储引擎层监控（核心）</h5><ul>
<li><strong>Buffer Pool (缓冲池)</strong>：<ul>
<li><code>Innodb_buffer_pool_wait_free</code>：因无法立即申请到空闲页而等待的次数。此值不为0说明 Buffer Pool 可能偏小或 I&#x2F;O 有压力。</li>
<li><code>Buffer Pool 命中率</code>：<code>1 - Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests</code>。命中率应尽可能高（通常 &gt; 99%），过低说明 Buffer Pool 太小或存在大量全表扫描。</li>
</ul>
</li>
<li><strong>日志与 I&#x2F;O</strong>：<ul>
<li><code>Innodb_log_waits</code>：因 redo log buffer 不足而等待的次数，非零表示 <code>innodb_log_buffer_size</code> 可能需要调大。</li>
<li><code>Innodb_data_fsyncs</code>：数据同步到磁盘的次数，反映了磁盘写入的压力。</li>
</ul>
</li>
<li><strong>锁信息</strong>：<ul>
<li><code>Innodb_row_lock_waits</code>：行锁等待次数。</li>
<li><code>Innodb_row_lock_time_avg</code>：平均行锁等待时长。这两个指标持续过高说明存在严重的锁竞争问题。</li>
</ul>
</li>
</ul>
<p><strong>4. 复制 (Replication) 监控</strong></p>
<ul>
<li><code>Seconds_Behind_Master</code>：<strong>（核心指标）</strong> 从库落后于主库的秒数。此值过大表明存在主从延迟。</li>
<li><code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code>：这两个状态都必须为 <code>Yes</code>，否则表示复制已中断。</li>
</ul>
<hr>
<h4 id="2-2-3-监控工具与方案"><a href="#2-2-3-监控工具与方案" class="headerlink" title="2.2.3 监控工具与方案"></a>2.2.3 监控工具与方案</h4><h5 id="1-MySQL-自带工具-命令行"><a href="#1-MySQL-自带工具-命令行" class="headerlink" title="1. MySQL 自带工具 (命令行)"></a>1. MySQL 自带工具 (命令行)</h5><ul>
<li><code>SHOW GLOBAL STATUS;</code>：查看 MySQL 服务器自启动以来的全局状态变量，是获取 QPS、TPS、连接数等指标的原始数据源。</li>
<li><code>SHOW PROCESSLIST;</code>：实时查看当前所有连接的线程状态，是排查慢查询和死锁的利器。</li>
<li><code>SHOW ENGINE INNODB STATUS;</code>：输出非常详细的 InnoDB 状态信息，包括事务、锁、Buffer Pool、日志等，是深入排查 InnoDB 问题的首选。</li>
<li><code>Performance Schema</code> &amp; <code>Sys Schema</code>：MySQL 5.6+ 提供的更强大、更细粒度的性能监控工具集，可以精确分析到具体 SQL、用户、客户端的资源消耗。</li>
</ul>
<hr>
<h5 id="2-开源监控系统-业界主流方案"><a href="#2-开源监控系统-业界主流方案" class="headerlink" title="2. 开源监控系统 (业界主流方案)"></a>2. 开源监控系统 (业界主流方案)</h5><p>单一使用命令行工具效率低下且无法形成历史趋势。现代化的监控通常采用集数据采集、存储、展示、告警于一体的系统。</p>
<ul>
<li><strong>Prometheus + Grafana 体系</strong>：<ul>
<li><strong><code>Prometheus</code></strong>: 一个强大的时序数据库，用于存储监控指标。</li>
<li><strong><code>mysqld_exporter</code></strong>: 一个采集器（Exporter），负责从 MySQL 收集各种状态指标，并以 Prometheus 要求的格式暴露出来。</li>
<li><strong><code>Grafana</code></strong>: 一个功能强大的可视化平台，用于将 Prometheus 中的数据以丰富的图表（Dashboard）形式展示出来。</li>
<li><strong><code>Alertmanager</code></strong>: Prometheus 的告警组件，根据预设的规则（如“主从延迟超过60秒”）发送告警通知（邮件、钉钉、微信等）。<br>这是目前最流行、最灵活的开源监控解决方案。</li>
</ul>
</li>
<li><strong>Percona Monitoring and Management (PMM)</strong>：<ul>
<li>Percona 公司出品的、专门针对 MySQL、MongoDB、PostgreSQL 的<strong>一站式</strong>监控管理平台。</li>
<li>它集成了 Prometheus, Grafana, VictoriaMetrics 等组件，并内置了大量预设好的 Dashboard 和告警规则，开箱即用，对 DBA 非常友好。</li>
</ul>
</li>
<li><strong>Zabbix</strong>：<ul>
<li>一款老牌、功能全面的企业级监控系统，也可以通过 agent 或脚本来监控 MySQL。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-4-从监控到告警-Alerting"><a href="#2-2-4-从监控到告警-Alerting" class="headerlink" title="2.2.4 从监控到告警 (Alerting)"></a>2.2.4 从监控到告警 (Alerting)</h4><p>监控的最终目的是为了<strong>行动</strong>。因此，必须建立告警机制。</p>
<ul>
<li><strong>告警规则</strong>：对核心指标设置合理的阈值。</li>
<li><strong>告警示例</strong>：<ul>
<li><strong>服务可用性</strong>：MySQL 进程不存在或端口不通，立即告警。</li>
<li><strong>主从复制</strong>：<code>Seconds_Behind_Master &gt; 300</code> (5分钟) 或 <code>Slave_SQL_Running != Yes</code>，立即告警。</li>
<li><strong>磁盘空间</strong>：<code>磁盘使用率 &gt; 85%</code>，触发告警。</li>
<li><strong>活动线程</strong>：<code>Threads_running &gt; 50</code> 持续 3 分钟，触发告警。</li>
</ul>
</li>
<li><strong>告警分级</strong>：根据问题的严重性设置不同级别的告警（如：警告、严重、紧急），并通知到不同的人员。</li>
</ul>
<hr>
<h3 id="2-3-账户与权限安全"><a href="#2-3-账户与权限安全" class="headerlink" title="2.3 账户与权限安全"></a>2.3 账户与权限安全</h3><h4 id="2-3-1-核心原则"><a href="#2-3-1-核心原则" class="headerlink" title="2.3.1 核心原则"></a>2.3.1 核心原则</h4><p>数据库权限管理应遵循以下两大核心安全原则：</p>
<ol>
<li><strong>最小权限原则 (Principle of Least Privilege)</strong><ul>
<li><strong>核心思想</strong>：只授予用户或应用程序<strong>完成其工作所必需的最小权限集</strong>。绝不多给任何一点额外的权限。</li>
<li><strong>目的</strong>：即使某个账户被攻破或滥用，其可能造成的损害也被限制在最小范围内。例如，一个只负责数据查询的报表应用，绝不应该被授予 <code>DELETE</code> 或 <code>DROP</code> 权限。</li>
</ul>
</li>
<li><strong>职责分离原则 (Separation of Duties)</strong><ul>
<li><strong>核心思想</strong>：将数据库管理的职责分散给不同的角色和账户。</li>
<li><strong>目的</strong>：避免权力过于集中，防止单点风险。例如，DBA 负责管理数据库结构和性能，开发人员只拥有对自己业务库的 DML 权限，审计人员只有只读权限。任何一方都无法独立完成所有高危操作。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-3-2-账户管理"><a href="#2-3-2-账户管理" class="headerlink" title="2.3.2 账户管理"></a>2.3.2 账户管理</h4><ol>
<li><p><strong>创建用户 (CREATE USER)</strong></p>
<ul>
<li>MySQL 的用户账户由两部分组成：<code>&#39;username&#39;@&#39;host&#39;</code>。</li>
<li><code>username</code>：用户名。</li>
<li><code>host</code>：指定了该用户可以从哪些主机或 IP 地址连接到 MySQL 服务器。<code>%</code> 表示任意主机，<code>localhost</code> 表示本机，也可以指定具体的 IP 或网段。</li>
<li><strong>最佳实践</strong>：为每个应用、每个开发者创建<strong>独立</strong>的账户，并严格限制其来源 <code>host</code>。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个只能从 192.168.1.100 主机连接的用户 app_user</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;192.168.1.100&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;a_very_strong_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个只能从本地连接的备份用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;backup_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;another_secure_password&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除用户 (DROP USER)</strong></p>
<ul>
<li>当用户离职或应用下线时，应立即删除其数据库账户。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;192.168.1.100&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重命名用户 (RENAME USER)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">USER</span> <span class="string">&#x27;old_user&#x27;</span>@<span class="string">&#x27;host&#x27;</span> <span class="keyword">TO</span> <span class="string">&#x27;new_user&#x27;</span>@<span class="string">&#x27;host&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>密码管理</strong></p>
<ul>
<li><p><strong>设置强密码</strong>：密码应足够复杂，包含大小写字母、数字和特殊字符。</p>
</li>
<li><p><strong>定期更换密码</strong>：制定策略，要求定期修改密码。</p>
</li>
<li><p><strong>使用密码插件</strong>：MySQL 提供了密码验证插件（<code>validate_password</code>），可以强制执行密码复杂度策略。</p>
</li>
<li><p><strong>修改密码</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为当前用户修改密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">USER</span>() IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_strong_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为指定用户修改密码 (需要有相应权限)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;192.168.1.100&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_strong_password&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-3-3-权限管理"><a href="#2-3-3-权限管理" class="headerlink" title="2.3.3 权限管理"></a>2.3.3 权限管理</h4><p><strong>1. 权限的类型与范围</strong></p>
<ul>
<li><strong>权限类型 (Privilege Types)</strong>：<ul>
<li><code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>：数据操作权限 (DML)。</li>
<li><code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>：结构操作权限 (DDL)。</li>
<li><code>ALL PRIVILEGES</code>：代表所有权限，应极度谨慎授予。</li>
<li><code>USAGE</code>：表示只能连接，没有任何其他权限。</li>
<li><code>PROCESS</code>, <code>REPLICATION SLAVE</code>, <code>RELOAD</code>：管理类权限，通常只授予 DBA 或特殊用途账户。</li>
</ul>
</li>
<li><strong>权限范围 (Privilege Levels)</strong>：<ul>
<li><strong>全局 (<code>\*.\*</code>)</strong>：权限应用于所有数据库的所有对象。</li>
<li><strong>数据库 (<code>database.\*</code>)</strong>：权限应用于指定数据库的所有对象。</li>
<li><strong>表 (<code>database.table</code>)</strong>：权限应用于指定数据库的指定表。</li>
<li><strong>列</strong>：可以对表的特定列授予 <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code> 权限。</li>
</ul>
</li>
</ul>
<p><strong>2. 授予权限 (GRANT)</strong></p>
<ul>
<li><p><strong>语法</strong>：<code>GRANT privilege_type ON privilege_level TO &#39;user&#39;@&#39;host&#39;;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 授予 app_user 对 my_app_db 数据库中所有表的 SELECT, INSERT, UPDATE, DELETE 权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> `my_app_db`.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;192.168.1.100&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予 report_user 只能查询 users 表的 id 和 email 字段</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> (id, email) <span class="keyword">ON</span> `my_app_db`.`users` <span class="keyword">TO</span> <span class="string">&#x27;report_user&#x27;</span>@<span class="string">&#x27;analytics.server.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予一个用户创建存储过程的权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> ROUTINE <span class="keyword">ON</span> `my_app_db`.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;dev_user&#x27;</span>@<span class="string">&#x27;dev.machine&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 刷新权限使之生效</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3. 撤销权限 (REVOKE)</strong></p>
<ul>
<li><p><strong>语法</strong>：<code>REVOKE privilege_type ON privilege_level FROM &#39;user&#39;@&#39;host&#39;;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 撤销 app_user 的 DELETE 权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> `my_app_db`.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;192.168.1.100&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 撤销用户的所有权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES, <span class="keyword">GRANT</span> OPTION <span class="keyword">FROM</span> <span class="string">&#x27;user_to_be_revoked&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p><code>GRANT OPTION</code> 是一个特殊权限，允许用户将自己拥有的权限再授予其他用户，非常危险，通常不应授予普通用户。</p>
</li>
</ul>
<p><strong>4. 查看权限 (SHOW GRANTS)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;192.168.1.100&#x27;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-4-安全实践清单"><a href="#2-3-4-安全实践清单" class="headerlink" title="2.3.4 安全实践清单"></a>2.3.4 安全实践清单</h4><ol>
<li><strong>禁止 root 用户远程登录</strong>：<ul>
<li>默认的 <code>root@&#39;%&#39;</code> 账户应被删除或重命名。</li>
<li><code>root</code> 用户应只允许从 <code>localhost</code> 登录，用于本地管理。</li>
</ul>
</li>
<li><strong>删除匿名用户</strong>：<ul>
<li>MySQL 安装后可能存在 <code>&#39;&#39;@&#39;localhost&#39;</code> 这样的匿名用户，应立即删除。</li>
</ul>
</li>
<li><strong>移除 <code>test</code> 数据库</strong>：<ul>
<li>默认的 <code>test</code> 数据库对所有用户都是可访问的，存在安全风险，在生产环境中应删除。</li>
</ul>
</li>
<li><strong>应用程序使用低权限账户</strong>：<ul>
<li>应用程序连接数据库的账户应严格遵循最小权限原则。例如，一个前端展示页面，其后端服务可能只需要对某些表有 <code>SELECT</code> 权限。</li>
</ul>
</li>
<li><strong>定期审计</strong>：<ul>
<li>定期审查所有数据库账户及其权限，清理不再使用的账户，检查是否存在权限过高的情况。</li>
</ul>
</li>
<li><strong>开启审计日志 (Audit Log)</strong>：<ul>
<li>对于安全要求高的系统，可以开启 MySQL 的审计插件，记录所有用户的登录、查询和操作，以便事后追溯和审计。</li>
</ul>
</li>
<li><strong>网络安全</strong>：<ul>
<li>使用防火墙限制对 MySQL 端口（默认为 3306）的访问，只允许受信任的 IP 地址连接。</li>
<li>在不信任的网络中，应使用 SSL&#x2F;TLS 对数据库连接进行加密。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B9%9D%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B9%9D%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">九、并发编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:40:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:40:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-25 10:24:21" itemprop="dateModified" datetime="2025-11-25T10:24:21+08:00">2025-11-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="九、并发编程"><a href="#九、并发编程" class="headerlink" title="九、并发编程"></a>九、并发编程</h1><p>并发编程是硬件发展与软件需求共同驱动的技术演进。随着摩尔定律在物理极限（功耗与散热）下失效，多核处理器成为主流，开发者必须编写并发代码才能充分利用硬件性能。同时，I&#x2F;O密集型应用（如网络服务）和用户体验优化（如避免界面卡顿）也推动了并发的广泛应用。</p>
<p>并发能显著提升资源利用率、程序吞吐量和响应性，并使某些多任务问题的建模更自然。然而，它也带来了高昂的复杂度：包括资源竞争（如竞态条件、死锁）、上下文切换开销，以及难以调试和测试的非确定性行为。</p>
<p>因此，并发虽已成为开发现代高性能、高响应应用的必备能力，但也要求开发者谨慎处理其复杂性，并借助语言和框架提供的高级抽象（如协程、Actor模型等）降低实现难度。</p>
<h2 id="1-并发编程的基石-线程"><a href="#1-并发编程的基石-线程" class="headerlink" title="1. 并发编程的基石 - 线程"></a>1. 并发编程的基石 - 线程</h2><h3 id="1-1-线程与进程"><a href="#1-1-线程与进程" class="headerlink" title="1.1 线程与进程"></a>1.1 线程与进程</h3><h4 id="1-1-1-进程"><a href="#1-1-1-进程" class="headerlink" title="1.1.1 进程"></a>1.1.1 进程</h4><p><strong>进程（Process）是操作系统进行资源分配和调度的基本单位。</strong></p>
<p>可以把一个进程看作是一个正在运行的应用程序的实例。当你双击打开一个程序（例如 Chrome 浏览器、Word 文档），操作系统就会为其创建一个进程。</p>
<p><strong>核心特征：</strong></p>
<ol>
<li><strong>资源容器</strong>：操作系统会为每个进程分配一套独立的资源，这包括：<ul>
<li><strong>独立的内存地址空间</strong>：每个进程都有自己的虚拟内存，一个进程无法直接访问另一个进程的内存。这提供了极好的隔离性和安全性。</li>
<li><strong>文件句柄</strong>：打开的文件、网络连接等。</li>
<li><strong>系统资源</strong>：如CPU时间片、硬件设备等。</li>
</ul>
</li>
<li><strong>独立性</strong>：进程之间是相互独立的。一个进程的崩溃通常不会影响到其他进程的正常运行（除非存在进程间通信的依赖）。</li>
<li><strong>重量级</strong>：创建、销毁和切换进程的开销（Context Switch）很大。因为操作系统需要分配和回收上述所有独立资源，并保存和恢复大量的状态信息。</li>
</ol>
<hr>
<h4 id="1-1-2-线程"><a href="#1-1-2-线程" class="headerlink" title="1.1.2 线程"></a>1.1.2 线程</h4><p><strong>线程（Thread）是CPU调度的基本单位，它被包含在进程之中，是进程中实际执行任务的实体。</strong></p>
<p>一个进程可以包含一个或多个线程。一个进程至少有一个主线程（Main Thread），负责程序的启动和执行。开发者可以在这个主线程的基础上创建更多的子线程来执行并发任务。</p>
<p><strong>核心特征：</strong></p>
<ol>
<li><strong>执行单元</strong>：线程是真正“干活”的单位，它拥有执行程序代码所需的最少资源，包括：<ul>
<li><strong>程序计数器（PC）</strong>：记录下一条要执行的指令地址。</li>
<li><strong>虚拟机栈（Stack）</strong>：存储局部变量、方法参数和调用信息。每个线程都有自己独立的栈。</li>
<li><strong>本地方法栈</strong>：为Native方法服务。</li>
</ul>
</li>
<li><strong>资源共享</strong>：同一进程内的所有线程共享该进程的绝大部分资源，包括：<ul>
<li><strong>堆内存（Heap）</strong>：所有对象实例都存放在这里。</li>
<li><strong>方法区（Method Area）</strong>：存储类信息、静态变量、常量等。</li>
<li><strong>文件句柄、网络连接等</strong>。</li>
</ul>
</li>
<li><strong>轻量级</strong>：与进程相比，线程的创建、销毁和切换开销要小得多。因为它们共享了大部分资源，切换时只需保存和恢复少量线程私有的状态（如程序计数器和栈）。</li>
</ol>
<hr>
<h4 id="1-1-3-对比"><a href="#1-1-3-对比" class="headerlink" title="1.1.3 对比"></a>1.1.3 对比</h4><table>
<thead>
<tr>
<th>对比维度</th>
<th>进程 (Process)</th>
<th>线程 (Thread)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基本单位</strong></td>
<td>操作系统<strong>资源分配</strong>的基本单位。</td>
<td>CPU<strong>调度</strong>的基本单位，是程序执行的最小单位。</td>
</tr>
<tr>
<td><strong>资源拥有</strong></td>
<td>拥有独立的内存地址空间和系统资源，是资源的“容器”。</td>
<td>自身基本不拥有资源，与同进程的其他线程共享资源。</td>
</tr>
<tr>
<td><strong>开销</strong></td>
<td>创建、销毁、切换的开销<strong>大</strong>，是“重量级”的。</td>
<td>创建、销毁、切换的开销<strong>小</strong>，是“轻量级”的。</td>
</tr>
<tr>
<td><strong>通信方式</strong></td>
<td>进程间通信（IPC）复杂，需要借助管道、消息队列、共享内存等机制。</td>
<td>线程间通信简单，可以直接读写共享变量（如堆内存中的对象）。</td>
</tr>
<tr>
<td><strong>隔离性&#x2F;健壮性</strong></td>
<td>进程间相互隔离，一个进程崩溃不影响其他进程。</td>
<td>一个线程的崩溃（如未捕获的异常）会导致整个进程退出。</td>
</tr>
<tr>
<td><strong>地址空间</strong></td>
<td>每个进程都有独立的地址空间。</td>
<td>同一进程的所有线程共享同一地址空间。</td>
</tr>
<tr>
<td><strong>关系</strong></td>
<td>进程是线程的容器，一个进程至少包含一个线程。</td>
<td>线程是进程的一部分，是进程中执行任务的路径。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-2-线程的生命周期"><a href="#1-2-线程的生命周期" class="headerlink" title="1.2 线程的生命周期"></a>1.2 线程的生命周期</h3><pre><code class="highlight mermaid">graph TD
    %% 1. 定义所有节点及其形状
    New(&quot;新建状态&quot;)
    Runnable&#123;&quot;可运行状态&quot;&#125;
    Running[&quot;运行中&quot;]
    Blocked(&quot;阻塞状态&quot;)
    Waiting(&quot;等待状态&quot;)
    TimedWaiting(&quot;计时等待状态&quot;)
    Terminated(&quot;终止状态&quot;)

    %% 2. 定义状态转换的箭头和标签
    New -- &quot;调用start方法&quot; --&gt; Runnable
    Runnable -- &quot;等待CPU调度&quot; --&gt; Running
    Running -- &quot;yield或时间片用完&quot; --&gt; Runnable
    
    Runnable -- &quot;等待同步锁&quot; --&gt; Blocked
    Blocked -- &quot;获取到同步锁&quot; --&gt; Runnable
    
    Running -- &quot;调用wait/join方法&quot; --&gt; Waiting
    Waiting -- &quot;notify/notifyAll&lt;br/&gt;或join的线程终止&quot; --&gt; Runnable
    
    Running -- &quot;调用sleep/wait&lt;br/&gt;带有超时参数的方法&quot; --&gt; TimedWaiting
    TimedWaiting -- &quot;超时时间到&lt;br/&gt;或被notify/notifyAll&quot; --&gt; Runnable
    
    Running -- &quot;执行完成或异常退出&quot; --&gt; Terminated

    %% 3. 定义并应用样式以匹配原图颜色
    classDef newStyle fill:#e0f2fe,stroke:#3b82f6,stroke-width:2px,color:black
    classDef runnableStyle fill:#dcfce7,stroke:#22c55e,stroke-width:2px,color:black
    classDef runningStyle fill:#bbf7d0,stroke:#16a34a,stroke-width:2px,color:black
    classDef blockedStyle fill:#fef3c7,stroke:#f59e0b,stroke-width:2px,color:black
    classDef waitingStyle fill:#ffedd5,stroke:#f97316,stroke-width:2px,color:black
    classDef timedWaitingStyle fill:#fef9c3,stroke:#eab308,stroke-width:2px,color:black
    classDef terminatedStyle fill:#fee2e2,stroke:#ef4444,stroke-width:2px,color:black

    class New newStyle
    class Runnable runnableStyle
    class Running runningStyle
    class Blocked blockedStyle
    class Waiting waitingStyle
    class TimedWaiting timedWaitingStyle
    class Terminated terminatedStyle</code></pre>

<h4 id="1-2-1-NEW-新建"><a href="#1-2-1-NEW-新建" class="headerlink" title="1.2.1 NEW (新建)"></a>1.2.1 <code>NEW</code> (新建)</h4><ul>
<li><p><strong>定义</strong>：当一个<code>Thread</code>对象被创建，但<code>start()</code>方法还<strong>没有被调用</strong>时，该线程就处于<code>NEW</code>状态。</p>
</li>
<li><p><strong>特征</strong>：这时的线程仅仅是一个普通的Java对象，操作系统内核中还没有为其创建对应的线程实体。它只占用了JVM中的一些内存，没有消耗任何CPU资源。</p>
</li>
<li><p><strong>状态切换</strong>：</p>
<ul>
<li><code>NEW</code> -&gt; <code>RUNNABLE</code>: 当线程对象的<code>start()</code>方法被调用时。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ... some task</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 此时, thread.getState() 的结果是 NEW</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-2-RUNNABLE-可运行"><a href="#1-2-2-RUNNABLE-可运行" class="headerlink" title="1.2.2 RUNNABLE (可运行)"></a>1.2.2 <code>RUNNABLE</code> (可运行)</h4><ul>
<li><strong>定义</strong>：这是一个复合状态，它包含了操作系统线程状态中的 <strong>Ready（就绪）</strong> 和 <strong>Running（运行中）</strong>。<ul>
<li><strong>就绪 (Ready)</strong>：线程已经准备好运行，获取了除CPU时间片之外的所有资源，正在等待操作系统的线程调度器分配CPU时间。</li>
<li><strong>运行中 (Running)</strong>：线程已经获得了CPU时间片，正在执行<code>run()</code>方法中的代码。</li>
</ul>
</li>
<li><strong>特征</strong>：处于<code>RUNNABLE</code>状态的线程可能正在运行，也可能在等待CPU。Java虚拟机（JVM）层面不区分这两种情况，统一视为<code>RUNNABLE</code>。</li>
<li><strong>状态切换</strong>：<ul>
<li><code>NEW</code> -&gt; <code>RUNNABLE</code>: 调用<code>start()</code>方法。</li>
<li><code>RUNNABLE</code> -&gt; <code>BLOCKED</code>: 线程试图进入一个<code>synchronized</code>同步块，但该锁被其他线程持有。</li>
<li><code>RUNNABLE</code> -&gt; <code>WAITING</code>: 线程调用了<code>Object.wait()</code>, <code>Thread.join()</code>, 或 <code>LockSupport.park()</code>。</li>
<li><code>RUNNABLE</code> -&gt; <code>TIMED_WAITING</code>: 线程调用了<code>Thread.sleep(long)</code>, <code>Object.wait(long)</code>, <code>Thread.join(long)</code>, <code>LockSupport.parkNanos()</code> 或 <code>LockSupport.parkUntil()</code>。</li>
<li><code>RUNNABLE</code> -&gt; <code>TERMINATED</code>: 线程的<code>run()</code>方法执行完毕，或者因未捕获的异常而退出。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-3-BLOCKED-阻塞"><a href="#1-2-3-BLOCKED-阻塞" class="headerlink" title="1.2.3 BLOCKED (阻塞)"></a>1.2.3 <code>BLOCKED</code> (阻塞)</h4><ul>
<li><p><strong>定义</strong>：线程正在等待获取一个<strong>监视器锁 (Monitor Lock)</strong>。这<strong>专指</strong>线程在进入<code>synchronized</code>修饰的方法或代码块时，因为锁被其他线程占用而导致的等待状态。</p>
</li>
<li><p><strong>特征</strong>：处于<code>BLOCKED</code>状态的线程会暂停执行，直到它获得了它所等待的锁。</p>
</li>
<li><p><strong>状态切换</strong>：</p>
<ul>
<li><code>RUNNABLE</code> -&gt; <code>BLOCKED</code>: 线程请求<code>synchronized</code>锁失败。</li>
<li><code>BLOCKED</code> -&gt; <code>RUNNABLE</code>: 持有锁的线程释放了该锁，并且线程调度器选择了这个线程来获取锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// 线程A持有锁，长时间运行</span></span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 线程B在这里会进入 BLOCKED 状态，直到线程A释放锁</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-4-WAITING-无限期等待"><a href="#1-2-4-WAITING-无限期等待" class="headerlink" title="1.2.4 WAITING (无限期等待)"></a>1.2.4 <code>WAITING</code> (无限期等待)</h4><ul>
<li><strong>定义</strong>：线程正在无限期地等待另一个线程执行一个特定的动作。线程不会自己醒来，必须被其他线程显式地唤醒。</li>
<li><strong>特征</strong>：处于此状态的线程不消耗CPU时间，并会释放它之前可能持有的锁（特指因调用<code>Object.wait()</code>而进入此状态的情况）。</li>
<li><strong>导致此状态的操作</strong>：<ol>
<li>调用<code>Object.wait()</code> (无参)</li>
<li>调用<code>Thread.join()</code> (无参)</li>
<li>调用<code>LockSupport.park()</code></li>
</ol>
</li>
<li><strong>状态切换</strong>：<ul>
<li><code>RUNNABLE</code> -&gt; <code>WAITING</code>: 调用上述任一方法。</li>
<li><code>WAITING</code> -&gt; <code>RUNNABLE</code>:<ul>
<li>对于<code>Object.wait()</code>: 其他线程调用了该锁对象的<code>notify()</code>或<code>notifyAll()</code>。</li>
<li>对于<code>Thread.join()</code>: 目标线程执行完毕。</li>
<li>对于<code>LockSupport.park()</code>: 其他线程调用了<code>LockSupport.unpark(thread)</code>。</li>
<li><strong>任何时候</strong>，其他线程调用了该线程的<code>interrupt()</code>方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-5-TIMED-WAITING-限时等待"><a href="#1-2-5-TIMED-WAITING-限时等待" class="headerlink" title="1.2.5 TIMED_WAITING (限时等待)"></a>1.2.5 <code>TIMED_WAITING</code> (限时等待)</h4><ul>
<li><strong>定义</strong>：与<code>WAITING</code>类似，但它有等待时间的上限。线程会在指定时间后自动被唤醒，无需其他线程显式唤醒。</li>
<li><strong>特征</strong>：同样不消耗CPU时间，并且在因<code>Object.wait(long)</code>进入此状态时会释放锁。</li>
<li><strong>导致此状态的操作</strong>：<ol>
<li><code>Thread.sleep(long)</code></li>
<li><code>Object.wait(long)</code></li>
<li><code>Thread.join(long)</code></li>
<li><code>LockSupport.parkNanos(long)</code></li>
<li><code>LockSupport.parkUntil(long)</code></li>
</ol>
</li>
<li><strong>状态切换</strong>：<ul>
<li><code>RUNNABLE</code> -&gt; <code>TIMED_WAITING</code>: 调用上述任一方法。</li>
<li><code>TIMED_WAITING</code> -&gt; <code>RUNNABLE</code>:<ul>
<li>等待时间结束。</li>
<li>在等待时间内，被其他线程通过<code>notify()</code>, <code>notifyAll()</code>, <code>unpark()</code>唤醒，或目标线程执行完毕(<code>join</code>)。</li>
<li><strong>任何时候</strong>，其他线程调用了该线程的<code>interrupt()</code>方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-6-TERMINATED-终止"><a href="#1-2-6-TERMINATED-终止" class="headerlink" title="1.2.6 TERMINATED (终止)"></a>1.2.6 <code>TERMINATED</code> (终止)</h4><ul>
<li><strong>定义</strong>：线程的<code>run()</code>方法已经正常执行完毕，或者因为一个未被捕获的异常而提前结束。</li>
<li><strong>特征</strong>：线程的生命周期结束，它所占用的资源被回收。一个处于<code>TERMINATED</code>状态的线程无法再次通过<code>start()</code>方法启动，否则会抛出<code>IllegalThreadStateException</code>。</li>
<li><strong>状态切换</strong>：<ul>
<li><code>RUNNABLE</code> -&gt; <code>TERMINATED</code>: <code>run()</code>方法执行完成或抛出未捕获异常。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-7-核心状态切换详解与辨析"><a href="#1-2-7-核心状态切换详解与辨析" class="headerlink" title="1.2.7 核心状态切换详解与辨析"></a>1.2.7 核心状态切换详解与辨析</h4><p><strong><code>BLOCKED</code> vs. <code>WAITING</code> &#x2F; <code>TIMED_WAITING</code> 的关键区别</strong></p>
<p>这是最容易混淆的地方，也是面试高频点。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>BLOCKED</code> (阻塞)</th>
<th><code>WAITING</code> &#x2F; <code>TIMED_WAITING</code> (等待)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>触发原因</strong></td>
<td><strong>被动</strong>：因争抢<code>synchronized</code>锁失败而进入。</td>
<td><strong>主动</strong>：由代码<strong>主动调用</strong><code>wait()</code>, <code>join()</code>, <code>park()</code>等方法进入。</td>
</tr>
<tr>
<td><strong>锁的持有</strong></td>
<td>线程<strong>不持有</strong>它正在等待的那个<code>synchronized</code>锁。</td>
<td>如果是因为<code>Object.wait()</code>进入等待，它会<strong>释放</strong>已经持有的<code>synchronized</code>锁。如果是<code>park()</code>则不涉及锁。</td>
</tr>
<tr>
<td><strong>唤醒方式</strong></td>
<td><strong>被动</strong>：当持有锁的线程释放锁后，由JVM唤醒并参与竞争。</td>
<td><strong>主动</strong>：必须由其他线程调用<code>notify()</code>, <code>notifyAll()</code>, <code>unpark()</code>或<code>interrupt()</code>来显式唤醒（或超时）。</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td><code>synchronized</code>同步机制。</td>
<td>线程间协作&#x2F;通信，如生产者-消费者模式 (<code>wait/notify</code>)，或等待异步任务完成 (<code>join</code>)。</td>
</tr>
</tbody></table>
<p><strong><code>sleep()</code> vs. <code>wait()</code> 的经典对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>Thread.sleep(long millis)</code></th>
<th><code>Object.wait(long timeout)</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所属类</strong></td>
<td><code>Thread</code></td>
<td><code>Object</code></td>
</tr>
<tr>
<td><strong>是否释放锁</strong></td>
<td><strong>不释放</strong>。如果<code>sleep()</code>在<code>synchronized</code>块中调用，它会一直持有锁，其他线程无法进入。</td>
<td><strong>释放</strong>。线程会释放对象的监视器锁，允许其他线程获取该锁。</td>
</tr>
<tr>
<td><strong>使用前提</strong></td>
<td>无需在同步块中使用。</td>
<td><strong>必须</strong>在<code>synchronized</code>方法或代码块中使用，因为它操作的是锁对象的等待队列。</td>
</tr>
<tr>
<td><strong>唤醒条件</strong></td>
<td>时间到期或被<code>interrupt()</code>。</td>
<td>时间到期、被<code>notify()</code>&#x2F;<code>notifyAll()</code>或被<code>interrupt()</code>。</td>
</tr>
<tr>
<td><strong>目的</strong></td>
<td>让线程暂停执行，通常用于模拟耗时操作或降低CPU使用率。</td>
<td>线程间通信与协作。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-线程的创建于启动"><a href="#1-3-线程的创建于启动" class="headerlink" title="1.3 线程的创建于启动"></a>1.3 线程的创建于启动</h3><h4 id="1-3-1-继承Thread类"><a href="#1-3-1-继承Thread类" class="headerlink" title="1.3.1 继承Thread类"></a>1.3.1 继承<code>Thread</code>类</h4><p>这是最直观的方式，通过创建一个继承自<code>java.lang.Thread</code>的子类来定义一个线程。</p>
<p><strong>核心步骤：</strong></p>
<ol>
<li>定义一个类，继承<code>Thread</code>类。</li>
<li>重写<code>run()</code>方法，这个方法就是线程需要执行的任务逻辑。</li>
<li>创建该子类的实例。</li>
<li>调用实例的<code>start()</code>方法来启动线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + getName() + <span class="string">&quot;正在运行&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyThread t1=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        MyThread t2=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">		</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        </span><br><span class="line">     	<span class="comment">// 注意：是调用 start() 方法，而不是 run() 方法！</span></span><br><span class="line">        <span class="comment">// 调用 start() 会启动一个新的线程，并由JVM调用该线程的 run() 方法。</span></span><br><span class="line">        <span class="comment">// 直接调用 run() 只是在主线程中执行一个普通方法。</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">...</span><br><span class="line">线程线程<span class="number">2</span>正在运行<span class="number">24</span></span><br><span class="line">线程线程<span class="number">1</span>正在运行<span class="number">4</span></span><br><span class="line">线程线程<span class="number">2</span>正在运行<span class="number">27</span></span><br><span class="line">线程线程<span class="number">1</span>正在运行<span class="number">6</span></span><br><span class="line">线程线程<span class="number">1</span>正在运行<span class="number">7</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：实现简单，代码直观。可以直接在<code>run()</code>方法中使用<code>this</code>来获取当前线程对象。</li>
<li><strong>缺点</strong>：<ol>
<li><strong>单继承局限性</strong>：Java是单继承的，如果你的类已经继承了另一个类，就无法再继承<code>Thread</code>类了。</li>
<li><strong>紧耦合</strong>：任务（<code>run</code>方法中的逻辑）与线程（<code>Thread</code>对象）高度耦合，不符合面向对象的设计原则（任务和执行者应该分离）。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="1-3-2-实现Runnable接口"><a href="#1-3-2-实现Runnable接口" class="headerlink" title="1.3.2 实现Runnable接口"></a>1.3.2 实现<code>Runnable</code>接口</h4><p>这是最常用、最推荐的方式，它将任务和线程的执行解耦。</p>
<p><strong>核心步骤：</strong></p>
<ol>
<li>定义一个类，实现<code>java.lang.Runnable</code>接口。</li>
<li>实现接口中的<code>run()</code>方法。</li>
<li>创建该实现类的实例，这个实例就是“任务”。</li>
<li>创建一个<code>Thread</code>对象，并将上一步创建的“任务”实例作为构造函数参数传入。</li>
<li>调用<code>Thread</code>对象的<code>start()</code>方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            Thread t= Thread.currentThread();</span><br><span class="line">            System.out.println(t.getName()+<span class="string">&quot;正在运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyThread m1=<span class="keyword">new</span> <span class="title class_">MyThread</span>(); <span class="comment">// 1. 创建任务</span></span><br><span class="line">        MyThread m2=<span class="keyword">new</span> <span class="title class_">MyThread</span>(); </span><br><span class="line"></span><br><span class="line">        Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(m1); <span class="comment">// 2. 创建线程并关联任务</span></span><br><span class="line">        Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(m2);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>); </span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start(); <span class="comment">// 3. 启动线程</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">...</span><br><span class="line">线程<span class="number">2</span>正在运行</span><br><span class="line">线程<span class="number">2</span>正在运行</span><br><span class="line">线程<span class="number">1</span>正在运行</span><br><span class="line">线程<span class="number">2</span>正在运行</span><br><span class="line">线程<span class="number">1</span>正在运行</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：<ol>
<li><strong>解耦</strong>：任务（<code>Runnable</code>）和线程（<code>Thread</code>）分离，<code>Runnable</code>对象可以被多个<code>Thread</code>对象共享，适用于多个线程执行相同任务的场景。</li>
<li><strong>无继承限制</strong>：你的任务类可以自由地继承其他任何类。</li>
<li><strong>符合面向对象思想</strong>：更清晰地划分了职责。</li>
</ol>
</li>
<li><strong>缺点</strong>：<code>run()</code>方法没有返回值，也不能抛出受检异常（Checked Exception）。</li>
</ul>
<hr>
<h4 id="1-3-3-实现Callable接口-配合-FutureTask"><a href="#1-3-3-实现Callable接口-配合-FutureTask" class="headerlink" title="1.3.3 实现Callable接口 (配合 FutureTask)"></a>1.3.3 实现<code>Callable</code>接口 (配合 <code>FutureTask</code>)</h4><p>这种方式是<code>Runnable</code>的增强版，解决了<code>Runnable</code>无法返回结果和抛出异常的痛点。</p>
<p><code>Callable</code>是<code>Executor</code>框架的一部分。</p>
<p><strong>核心步骤：</strong></p>
<ol>
<li>定义一个类，实现<code>java.util.concurrent.Callable&lt;V&gt;</code>接口，<code>V</code>是返回值的类型。</li>
<li>实现接口中的<code>call()</code>方法，这个方法可以有返回值，并且可以<code>throws Exception</code>。</li>
<li>创建该实现类的实例。</li>
<li>使用<code>java.util.concurrent.FutureTask&lt;V&gt;</code>来包装<code>Callable</code>对象。<code>FutureTask</code>本身实现了<code>Runnable</code>接口，所以可以被<code>Thread</code>接受。</li>
<li>创建<code>Thread</code>对象，并将<code>FutureTask</code>实例作为参数传入。</li>
<li>启动线程。</li>
<li>通过<code>FutureTask</code>的<code>get()</code>方法来获取线程执行的返回结果（<code>get()</code>方法会阻塞，直到任务执行完毕）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时计算</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程名: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务执行完毕，返回结果！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">callableTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        <span class="comment">// 使用FutureTask包装MyCallable实例，FutureTask是Runnable和Future的实现类</span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callableTask);</span><br><span class="line">        <span class="comment">// 创建线程并传入FutureTask实例，FutureTask可以作为Runnable被线程执行</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        <span class="comment">// 启动线程执行任务</span></span><br><span class="line">        thread.start();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行其他任务...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get()方法会阻塞当前线程，直到call()方法执行完成并返回结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get(); </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程获取到异步任务结果: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：<ol>
<li><strong>有返回值</strong>：可以获取异步任务的执行结果。</li>
<li><strong>可抛出异常</strong>：可以在<code>call()</code>方法中抛出异常，并在主线程中通过<code>get()</code>捕获和处理。</li>
<li>功能强大，是现代并发编程（尤其是线程池）的基础。</li>
</ol>
</li>
<li><strong>缺点</strong>：编码比<code>Runnable</code>稍复杂。</li>
</ul>
<hr>
<h4 id="1-3-4-start-与-run-的区别"><a href="#1-3-4-start-与-run-的区别" class="headerlink" title="1.3.4 start() 与 run() 的区别"></a>1.3.4 <code>start()</code> 与 <code>run()</code> 的区别</h4><ul>
<li><strong><code>thread.start()</code></strong>:<ul>
<li><strong>作用</strong>：<strong>启动一个新线程</strong>。</li>
<li><strong>过程</strong>：它会请求JVM，JVM再请求操作系统，为这个线程分配必要的资源，并将其置于**可运行（RUNNABLE）**状态。当该线程获得CPU时间片后，JVM会自动调用其 <code>run()</code> 方法。</li>
<li><strong>结果</strong>：实现了真正的多线程并发执行。调用 <code>start()</code> 的线程（如主线程）会立即返回，不会等待新线程的 <code>run()</code> 方法执行完毕。</li>
</ul>
</li>
<li><strong><code>thread.run()</code></strong>:<ul>
<li><strong>作用</strong>：<strong>仅仅是调用一个普通的方法</strong>。</li>
<li><strong>过程</strong>：它不会创建新线程。<code>run()</code> 方法中的代码会在<strong>调用它的那个线程</strong>（例如，主线程）中同步执行。</li>
<li><strong>结果</strong>：程序依然是单线程的，没有实现并发。只有当 <code>run()</code> 方法执行完毕后，调用者才能继续执行下面的代码。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-线程核心API"><a href="#1-4-线程核心API" class="headerlink" title="1.4 线程核心API"></a>1.4 线程核心API</h3><p><code>java.lang.Thread</code> 类提供了一系列静态方法和实例方法来控制和查询线程的状态与行为。</p>
<h4 id="1-4-1-启动与执行"><a href="#1-4-1-启动与执行" class="headerlink" title="1.4.1 启动与执行"></a>1.4.1 启动与执行</h4><p><strong><code>void start()</code></strong></p>
<ul>
<li><strong>描述</strong>：启动一个新线程，使其进入 <code>RUNNABLE</code> 状态。JVM会调用该线程的 <code>run()</code> 方法。这是实现并发的唯一正确方式。</li>
<li><strong>注意</strong>：一个线程对象只能调用一次 <code>start()</code>。</li>
</ul>
<p><strong><code>void run()</code></strong></p>
<ul>
<li><strong>描述</strong>：线程要执行的任务逻辑。如果直接调用 <code>run()</code>，它将作为普通方法在当前线程中同步执行，不会创建新线程。</li>
</ul>
<hr>
<h4 id="1-4-2-控制线程执行"><a href="#1-4-2-控制线程执行" class="headerlink" title="1.4.2 控制线程执行"></a>1.4.2 控制线程执行</h4><p><strong><code>static void sleep(long millis)</code></strong></p>
<ul>
<li><p><strong>描述</strong>：使<strong>当前</strong>正在执行的线程暂停执行指定的毫秒数。这是一个<strong>静态方法</strong>。</p>
</li>
<li><p><strong>核心特点</strong>：</p>
<ol>
<li><strong>让出CPU</strong>：线程会从 <code>RUNNABLE</code> 状态进入 <code>TIMED_WAITING</code> 状态，暂时让出CPU执行权。</li>
<li><strong>不释放锁</strong>：如果当前线程持有一个锁（例如在 <code>synchronized</code> 块内调用 <code>sleep</code>），它在睡眠期间<strong>不会释放这个锁</strong>。这可能导致其他需要该锁的线程长时间阻塞。</li>
<li><strong>响应中断</strong>：<code>sleep</code> 期间如果其他线程调用了该线程的 <code>interrupt()</code> 方法，<code>sleep</code>会立即终止，并抛出 <code>InterruptedException</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;主线程开始...&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 让主线程休眠2秒</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 如果在休眠期间被中断，会进入这里</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;主线程结束。&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>void join()</code> &#x2F; <code>void join(long millis)</code></strong></p>
<ul>
<li><p><strong>描述</strong>：<strong>等待</strong>该线程执行终止。调用 <code>t.join()</code> 的线程（例如主线程）会被阻塞，直到线程 <code>t</code> 的 <code>run()</code> 方法执行完毕。</p>
</li>
<li><p><strong>核心特点</strong>：</p>
<ol>
<li><strong>线程协同</strong>：用于实现线程之间的同步。常用于主线程等待子线程完成任务后再继续执行的场景。</li>
<li><strong>阻塞调用者</strong>：<code>t.join()</code> 阻塞的是<strong>调用它的线程</strong>，而不是线程<code>t</code>本身。</li>
<li><strong>响应中断</strong>：等待期间，如果调用 <code>join()</code> 的线程被中断，<code>join()</code> 方法会抛出 <code>InterruptedException</code>。</li>
<li><strong>超时版本</strong>：<code>join(long millis)</code> 提供了一个超时机制，如果在指定时间内目标线程还未结束，等待的线程将自动恢复执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程开始执行...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程执行完毕。&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">worker.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;主线程等待工作线程完成...&quot;</span>);</span><br><span class="line">worker.join(); <span class="comment">// 主线程在此处阻塞，直到 worker 线程执行完毕</span></span><br><span class="line">System.out.println(<span class="string">&quot;主线程继续执行。&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>static void yield()</code></strong></p>
<ul>
<li><strong>描述</strong>：一个<strong>提示性</strong>的静态方法，建议线程调度器可以将CPU让给其他同优先级的线程。</li>
<li><strong>核心特点</strong>：<ol>
<li><strong>不保证生效</strong>：<code>yield()</code> 只是一个“建议”，调度器完全可以忽略它。</li>
<li><strong>不进入阻塞</strong>：线程只是从“运行中”状态转回“就绪”状态，仍在 <code>RUNNABLE</code> 状态，随时可能再次被调度。</li>
<li><strong>不释放锁</strong>：和 <code>sleep</code> 一样，<code>yield</code> 期间<strong>不会释放锁</strong>。</li>
</ol>
</li>
<li><strong>用途</strong>：由于其不确定性，在实际开发中很少使用。主要用于调试或测试场景。</li>
</ul>
<hr>
<h4 id="1-4-3-线程中断机制-推荐的线程终止方式"><a href="#1-4-3-线程中断机制-推荐的线程终止方式" class="headerlink" title="1.4.3 线程中断机制 (推荐的线程终止方式)"></a>1.4.3 线程中断机制 (推荐的线程终止方式)</h4><p>中断是一种协作式的线程终止机制。它不像 <code>stop()</code> 方法那样强制停止，而是向目标线程发送一个“中断请求”信号，由目标线程自行决定如何响应。</p>
<p><strong><code>void interrupt()</code></strong></p>
<ul>
<li><strong>描述</strong>：设置目标线程的**中断标志位 (interrupt flag)**为 <code>true</code>。</li>
<li><strong>特殊效果</strong>：如果目标线程正处于 <code>sleep()</code>, <code>wait()</code>, <code>join()</code> 等阻塞状态，调用 <code>interrupt()</code> 会立即唤醒它，并使其抛出 <code>InterruptedException</code>。抛出异常后，<strong>中断标志位会被清除（重置为 <code>false</code>）</strong>。</li>
</ul>
<p><strong><code>boolean isInterrupted()</code></strong></p>
<ul>
<li><strong>描述</strong>：一个<strong>实例方法</strong>，用于检查<strong>目标线程</strong>的中断标志位是否为 <code>true</code>。</li>
<li><strong>核心特点</strong>：<strong>不清除</strong>中断标志位。即连续多次调用会返回相同的结果。</li>
</ul>
<p><strong><code>static boolean interrupted()</code></strong></p>
<ul>
<li><strong>描述</strong>：一个<strong>静态方法</strong>，用于检查<strong>当前线程</strong>的中断标志位是否为 <code>true</code>。</li>
<li><strong>核心特点</strong>：这是一个有副作用的方法，它在返回中断状态后，会<strong>立即清除</strong>中断标志位（将其重置为 <code>false</code>）。</li>
</ul>
<p><strong>正确使用中断的示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">interruptibleTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// isInterrupted() 是循环的退出条件</span></span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务正在运行...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// sleep可以响应中断</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 当 sleep 被中断时，会抛出此异常，并清除中断标志位</span></span><br><span class="line">            System.out.println(<span class="string">&quot;任务在休眠中被中断！&quot;</span>);</span><br><span class="line">            <span class="comment">// 需要重新设置中断标志位，以便循环条件能正确退出</span></span><br><span class="line">            Thread.currentThread().interrupt(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务已终止。&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">interruptibleTask.start();</span><br><span class="line">Thread.sleep(<span class="number">3000</span>); <span class="comment">// 让任务运行3秒</span></span><br><span class="line">System.out.println(<span class="string">&quot;主线程请求中断任务...&quot;</span>);</span><br><span class="line">interruptibleTask.interrupt(); <span class="comment">// 发送中断信号</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-4-4-获取线程信息"><a href="#1-4-4-获取线程信息" class="headerlink" title="1.4.4 获取线程信息"></a>1.4.4 获取线程信息</h4><p><strong><code>static Thread currentThread()</code></strong></p>
<ul>
<li><strong>描述</strong>：返回当前正在执行的线程对象的引用。</li>
</ul>
<p><strong><code>String getName()</code> &#x2F; <code>void setName(String name)</code></strong></p>
<ul>
<li><strong>描述</strong>：获取或设置线程的名称。为线程设置一个有意义的名称是调试并发问题的良好实践。</li>
</ul>
<p><strong><code>long getId()</code></strong></p>
<ul>
<li><strong>描述</strong>：返回线程的唯一标识符（ID）。</li>
</ul>
<p><strong><code>Thread.State getState()</code></strong></p>
<ul>
<li><strong>描述</strong>：返回线程当前的生命周期状态（<code>NEW</code>, <code>RUNNABLE</code>, <code>BLOCKED</code>…）。</li>
</ul>
<hr>
<h4 id="1-4-5-守护线程与优先级"><a href="#1-4-5-守护线程与优先级" class="headerlink" title="1.4.5 守护线程与优先级"></a>1.4.5 守护线程与优先级</h4><p>这部分将在后续章节详细讲解，这里先做API介绍。</p>
<p><strong><code>void setDaemon(boolean on)</code></strong></p>
<ul>
<li><strong>描述</strong>：将线程标记为守护线程或用户线程。必须在 <code>start()</code> 方法调用之前设置。</li>
</ul>
<p><strong><code>void setPriority(int newPriority)</code></strong></p>
<ul>
<li><strong>描述</strong>：设置线程的优先级。范围是1-10，默认为5。但这只是给操作系统的一个“建议”，不保证严格按优先级执行。</li>
</ul>
<hr>
<h4 id="1-4-6-已废弃的危险方法-不要使用！"><a href="#1-4-6-已废弃的危险方法-不要使用！" class="headerlink" title="1.4.6 已废弃的危险方法 (不要使用！)"></a>1.4.6 已废弃的危险方法 (不要使用！)</h4><p><strong><code>void stop()</code></strong>: 强行终止线程。<strong>极其危险</strong>，因为它会立即释放线程持有的所有锁，可能导致共享数据处于不一致的“脏”状态。</p>
<p><strong><code>void suspend()</code> &#x2F; <code>void resume()</code></strong>: 暂停和恢复线程。<strong>容易导致死锁</strong>。如果一个线程在持有锁时被 <code>suspend()</code>，它将永远不会释放锁，其他等待该锁的线程将永久阻塞。</p>
<hr>
<h4 id="1-4-7-总结表格"><a href="#1-4-7-总结表格" class="headerlink" title="1.4.7 总结表格"></a>1.4.7 总结表格</h4><table>
<thead>
<tr>
<th>方法签名</th>
<th>类型</th>
<th>作用</th>
<th>是否释放锁</th>
<th>关键说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void start()</code></td>
<td>实例方法</td>
<td>启动新线程，异步调用<code>run()</code></td>
<td>-</td>
<td>只能调用一次</td>
</tr>
<tr>
<td><code>void run()</code></td>
<td>实例方法</td>
<td>线程执行体，同步调用</td>
<td>-</td>
<td>直接调用等于普通方法调用</td>
</tr>
<tr>
<td><code>static void sleep(long)</code></td>
<td>静态方法</td>
<td>使<strong>当前</strong>线程休眠指定时间</td>
<td><strong>否</strong></td>
<td>会抛出<code>InterruptedException</code></td>
</tr>
<tr>
<td><code>void join()</code> &#x2F; <code>void join(long)</code></td>
<td>实例方法</td>
<td>使<strong>调用者</strong>线程等待该线程结束</td>
<td>-</td>
<td>阻塞调用者，用于线程协同</td>
</tr>
<tr>
<td><code>void interrupt()</code></td>
<td>实例方法</td>
<td>设置目标线程的中断标志位</td>
<td>-</td>
<td>可唤醒阻塞状态的线程（并抛出<code>InterruptedException</code>）</td>
</tr>
<tr>
<td><code>boolean isInterrupted()</code></td>
<td>实例方法</td>
<td>检查目标线程的中断状态</td>
<td>-</td>
<td><strong>不</strong>清除中断标志位</td>
</tr>
<tr>
<td><code>static boolean interrupted()</code></td>
<td>静态方法</td>
<td>检查<strong>当前</strong>线程的中断状态</td>
<td>-</td>
<td><strong>会</strong>清除中断标志位</td>
</tr>
<tr>
<td><code>static void yield()</code></td>
<td>静态方法</td>
<td>建议调度器让出CPU</td>
<td><strong>否</strong></td>
<td>仅为提示，不保证生效</td>
</tr>
<tr>
<td><code>static Thread currentThread()</code></td>
<td>静态方法</td>
<td>获取当前执行的线程对象</td>
<td>-</td>
<td>非常常用</td>
</tr>
<tr>
<td><code>void stop()</code> &#x2F; <code>suspend()</code> &#x2F; <code>resume()</code></td>
<td>实例方法</td>
<td><strong>已废弃，绝对不要使用</strong></td>
<td>危险操作</td>
<td>导致数据不一致或死锁</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-5-守护线程"><a href="#1-5-守护线程" class="headerlink" title="1.5 守护线程"></a>1.5 守护线程</h3><h4 id="1-5-1-概念"><a href="#1-5-1-概念" class="headerlink" title="1.5.1 概念"></a>1.5.1 概念</h4><p>守护线程（Daemon Thread）是一种特殊的线程，它在后台运行，为其他线程（即用户线程）提供服务。可以将其理解为程序的“服务员”或“后台工作者”。</p>
<p>守护线程最核心的特性是：<strong>它的生命周期与JVM的生命周期“绑定”在一起，但它不会阻止JVM的退出</strong>。换句话说，当程序中所有的<strong>用户线程</strong>（User Thread，也称非守护线程）都执行完毕后，JVM就会自动退出，而无论此时是否还有守护线程在运行。JVM在退出时会直接、粗暴地终止所有守护线程，不会等待它们执行完毕。</p>
<p>Java程序中最典型的守护线程就是<strong>垃圾回收器（Garbage Collector, GC）</strong>。只要我们的主程序还在运行，GC就会在后台默默地回收内存；一旦主程序结束（所有用户线程都结束了），GC线程也会随之被终止。</p>
<hr>
<h4 id="1-5-2-守护线程与用户线程的区别"><a href="#1-5-2-守护线程与用户线程的区别" class="headerlink" title="1.5.2 守护线程与用户线程的区别"></a>1.5.2 守护线程与用户线程的区别</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">用户线程 (User Thread)</th>
<th align="left">守护线程 (Daemon Thread)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>角色</strong></td>
<td align="left">程序的主体，执行核心业务逻辑。</td>
<td align="left">后台服务者，为用户线程提供支持。</td>
</tr>
<tr>
<td align="left"><strong>JVM退出</strong></td>
<td align="left">只要有一个用户线程还在运行，JVM就不会退出。</td>
<td align="left">守护线程不会影响JVM的退出。</td>
</tr>
<tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left">独立，执行完毕后才算结束。</td>
<td align="left">依赖于所有用户线程，当用户线程全部结束后，它会被强制终止。</td>
</tr>
<tr>
<td align="left"><strong>资源清理</strong></td>
<td align="left">能够保证<code>finally</code>代码块的执行，可以进行可靠的资源清理。</td>
<td align="left">被强制终止时，<strong>不保证<code>finally</code>代码块会被执行</strong>，因此不适合执行关键的资源清理操作。</td>
</tr>
<tr>
<td align="left"><strong>默认状态</strong></td>
<td align="left"><code>main</code>线程和默认创建的线程都是用户线程。</td>
<td align="left">需要显式设置。</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-5-3-创建与使用"><a href="#1-5-3-创建与使用" class="headerlink" title="1.5.3 创建与使用"></a>1.5.3 创建与使用</h4><p>我们可以通过 <code>Thread</code> 类的 <code>setDaemon(boolean on)</code> 方法来设置一个线程是否为守护线程。</p>
<p><strong>核心API:</strong></p>
<ul>
<li><code>void setDaemon(boolean on)</code>: 将线程标记为守护线程或用户线程。如果参数为 <code>true</code>，则为守护线程；<code>false</code> 则为用户线程。</li>
<li><code>boolean isDaemon()</code>: 判断该线程是否为守护线程。</li>
</ul>
<p><strong>关键规则：<code>setDaemon(true)</code> 方法必须在调用 <code>thread.start()</code> 方法之前设置，否则会抛出 <code>IllegalThreadStateException</code> 异常。</strong></p>
<p><strong>代码示例：</strong></p>
<p>下面是一个监控程序运行状态的守护线程示例。主线程（用户线程）模拟一个耗时5秒的任务，守护线程在后台每秒打印一次监控信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonThreadExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个任务作为守护线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;守护线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 开始运行...&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 无限循环，模拟持续监控</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;守护线程正在监控...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 守护线程在被终止时，sleep会抛出InterruptedException</span></span><br><span class="line">                System.out.println(<span class="string">&quot;守护线程被中断。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 这个 finally 块中的代码不保证会被执行！</span></span><br><span class="line">                System.out.println(<span class="string">&quot;守护线程的 finally 块执行了。&quot;</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Daemon-Monitor&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 将该线程设置为守护线程</span></span><br><span class="line">        <span class="comment">// 必须在 start() 之前调用</span></span><br><span class="line">        daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 启动守护线程</span></span><br><span class="line">        daemonThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程（用户线程）开始执行任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 开始运行...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟主线程工作5秒</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 运行结束。&quot;</span>);</span><br><span class="line">        <span class="comment">// 当 main 线程结束后，程序中没有其他用户线程，JVM即将退出</span></span><br><span class="line">        <span class="comment">// 守护线程 daemonThread 将被强制终止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主线程 main 开始运行...</span><br><span class="line">守护线程 Daemon-Monitor 开始运行...</span><br><span class="line">守护线程正在监控...</span><br><span class="line">守护线程正在监控...</span><br><span class="line">守护线程正在监控...</span><br><span class="line">守护线程正在监控...</span><br><span class="line">守护线程正在监控...</span><br><span class="line">主线程 main 运行结束。</span><br><span class="line"><span class="comment">// 程序到此结束，&quot;守护线程的 finally 块执行了。&quot; 这句话大概率不会被打印出来。</span></span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，当 <code>main</code> 线程结束后，整个程序就退出了，守护线程被立即终止，甚至来不及执行它的<code>finally</code>代码块。</p>
<hr>
<h4 id="1-5-4-注意事项与最佳实践"><a href="#1-5-4-注意事项与最佳实践" class="headerlink" title="1.5.4 注意事项与最佳实践"></a>1.5.4 注意事项与最佳实践</h4><ol>
<li><strong>设置时机</strong>: <code>setDaemon(true)</code> 必须在线程启动（调用 <code>start()</code>）之前完成。一旦线程启动，其守护状态就不能再改变。</li>
<li><strong>不适合关键任务</strong>: 由于守护线程的终止是突然且不可预测的，它不保证会执行 <code>finally</code> 块中的代码。因此，<strong>绝对不要在守护线程中执行任何涉及资源操作（如I&#x2F;O读写、数据库连接关闭、锁的释放等）的逻辑</strong>，否则可能导致资源泄露或数据不一致。</li>
<li><strong>继承性</strong>: 一个线程创建的新线程，其守护状态<strong>默认与创建它的线程（父线程）保持一致</strong>。例如，如果一个守护线程创建了一个新线程，那么这个新线程默认也是一个守护线程。由于 <code>main</code> 线程是用户线程，所以由 <code>main</code> 线程创建的线程默认也都是用户线程。</li>
<li><strong>典型应用场景</strong>:<ul>
<li><strong>后台监控</strong>: 监控系统健康状况、内存使用情况等。</li>
<li><strong>日志记录</strong>: 后台线程负责将日志信息异步写入文件。</li>
<li><strong>缓存管理</strong>: 定时清理过期的缓存数据。</li>
<li><strong>Java自带的守护线程</strong>: 垃圾回收（GC）、JMX（Java Management Extensions）等。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-并发编程的理论基石"><a href="#2-并发编程的理论基石" class="headerlink" title="2. 并发编程的理论基石"></a>2. 并发编程的理论基石</h2><h3 id="2-1-Java内存模型-JMM"><a href="#2-1-Java内存模型-JMM" class="headerlink" title="2.1 Java内存模型(JMM)"></a>2.1 Java内存模型(JMM)</h3><h4 id="2-1-1-概念"><a href="#2-1-1-概念" class="headerlink" title="2.1.1 概念"></a>2.1.1 概念</h4><p>在早期的单核CPU时代，所有线程都在同一个CPU上执行，共享同一份内存，内存的读写操作都是相对可预测的。然而，现代计算机系统几乎都是多核CPU架构。为了弥补CPU与主内存之间巨大的速度差异，每个CPU核心都有自己的高速缓存（如L1, L2, L3 Cache）。</p>
<p>这带来了并发编程中的一个核心挑战：<strong>数据一致性问题</strong>。当多个线程在不同的CPU核心上运行时，它们会各自将共享变量从主内存（Main Memory）加载到自己的工作内存（Working Memory，即高速缓存）中进行操作。一个线程对变量的修改，如果没能及时同步回主内存，那么其他线程就无法看到这个最新的值，从而导致数据不一致。</p>
<p>此外，为了提升性能，编译器和处理器还会对指令进行<strong>重排序（Reordering）</strong>。在单线程环境下，重排序不会影响最终结果，但在多线程环境下，这种“无序”的执行可能会导致程序出现意想不到的错误。</p>
<p><strong>JMM</strong> 的诞生就是为了解决这些问题。它不是一个物理存在，而是一套<strong>抽象的概念或规范</strong>，并不是真实的物理硬件。它描述了 Java 程序中各种变量（线程共享变量）的访问规则，以及在 JVM 中将变量存储到内存和从内存中读取变量的底层细节。旨在：</p>
<ol>
<li><strong>屏蔽底层硬件和操作系统的内存访问差异</strong>：保证 Java 程序在不同平台上（Windows, Linux, Mac）对内存的访问行为一致。</li>
<li><strong>解决并发问题</strong>：它定义了多线程之间如何通过内存进行通信，规定了<strong>原子性、可见性、有序性</strong>的行为。</li>
</ol>
<hr>
<h4 id="2-1-2-JMM的抽象模型"><a href="#2-1-2-JMM的抽象模型" class="headerlink" title="2.1.2 JMM的抽象模型"></a>2.1.2 JMM的抽象模型</h4><p>JMM定义了一个抽象的、逻辑上的内存结构，它将内存分为两部分：</p>
<ul>
<li><strong>主内存 (Main Memory)</strong>:<ul>
<li>所有线程共享。</li>
<li>存储实例对象、静态变量、数组对象等（堆内存区域）。</li>
</ul>
</li>
<li><strong>工作内存 (Working Memory)</strong>:<ul>
<li>每个线程私有（栈&#x2F;寄存器&#x2F;高速缓存的抽象）。</li>
<li>存储了该线程使用到的变量的主内存副本。</li>
</ul>
</li>
</ul>
<p><strong>线程间变量交互的过程如下：</strong></p>
<ol>
<li><strong>Read &amp; Load</strong>: 线程A要使用共享变量X，首先会从主内存中读取X的值，并加载（Load）到自己的工作内存A中，形成一个副本。</li>
<li><strong>Use &amp; Assign</strong>: 线程A在自己的工作内存中对变量X的副本进行操作（Use），并将结果赋值（Assign）给这个副本。</li>
<li><strong>Store &amp; Write</strong>: 当线程A需要将修改后的值同步回主内存时，它会先将工作内存中的副本存储（Store）起来，然后写入（Write）到主内存中。</li>
</ol>
<p><strong>关键问题</strong>: 如果线程A修改了变量X但没有及时写回主内存，那么线程B读取到的仍然是主内存中的旧值，这就是<strong>可见性问题</strong>的根源。</p>
<hr>
<h4 id="2-1-3-并发编程的三大特性"><a href="#2-1-3-并发编程的三大特性" class="headerlink" title="2.1.3 并发编程的三大特性"></a>2.1.3 并发编程的三大特性</h4><p>JMM主要是为了在并发编程中保证以下三个特性，从而确保程序的正确性。</p>
<h5 id="1-原子性-Atomicity"><a href="#1-原子性-Atomicity" class="headerlink" title="1. 原子性 (Atomicity)"></a>1. 原子性 (Atomicity)</h5><p>原子性指一个或多个操作，要么全部执行成功，要么全部不执行，中间不会被任何其他因素（如线程切换）中断。</p>
<ul>
<li><strong>基本类型原子性</strong>: 在Java中，对基本数据类型（<code>long</code>和<code>double</code>除外）的变量的读取和赋值操作是原子性的。例如 <code>int i = 10;</code> 是原子操作。</li>
<li><strong><code>long</code>和<code>double</code>的非原子性</strong>: 对于64位的<code>long</code>和<code>double</code>，JMM允许JVM将其读&#x2F;写操作拆分为两个32位的操作。在32位系统上，这可能导致一个线程只修改了高32位，就被另一个线程读取，造成“撕裂读”（Torn Read）。不过，现代商用JVM基本都实现了对<code>long</code>和<code>double</code>的原子性读写。</li>
<li><strong>复合操作的非原子性</strong>: 像 <code>count++</code> 这样的操作不是原子的。它包含三个步骤：1) 读取<code>count</code>的值；2) 将值加1；3) 将新值写回。在多线程环境下，这三个步骤之间可能被其他线程打断，导致结果错误。</li>
<li><strong>如何保证原子性</strong>: JMM提供了<code>synchronized</code>关键字和<code>java.util.concurrent.locks</code>（如<code>ReentrantLock</code>）来保证一个代码块的原子性。<code>java.util.concurrent.atomic</code>包下的原子类（如<code>AtomicInteger</code>）则通过CAS操作来保证单个变量操作的原子性。</li>
</ul>
<hr>
<h5 id="2-可见性-Visibility"><a href="#2-可见性-Visibility" class="headerlink" title="2. 可见性 (Visibility)"></a>2. 可见性 (Visibility)</h5><p>可见性指当一个线程修改了共享变量的值，其他线程能立即看到修改后的值。</p>
<ul>
<li><strong>问题根源</strong>: CPU缓存、编译器优化和处理器优化都可能导致可见性问题。一个线程在自己的工作内存中修改了变量，但未刷新到主内存，导致其他线程不可见。</li>
<li><strong>如何保证可见性</strong>:<ul>
<li><strong><code>volatile</code></strong>: 使用<code>volatile</code>关键字修饰的变量，JMM会保证每次修改后都立即写回主内存，并且每次读取前都从主内存刷新。这强制实现了缓存一致性。</li>
<li><strong><code>synchronized</code>和<code>Lock</code></strong>: 对一个变量执行<code>unlock</code>操作之前，必须将该变量同步回主内存。而执行<code>lock</code>操作时，会清空工作内存中共享变量的副本，强制从主内存中重新加载。</li>
<li><strong><code>final</code></strong>: 被<code>final</code>修饰的字段在构造函数中一旦初始化完成，并且构造函数没有把<code>this</code>引用泄露出去，那么在其他线程中就能保证看到<code>final</code>字段的正确初始化值。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-有序性-Ordering"><a href="#3-有序性-Ordering" class="headerlink" title="3. 有序性 (Ordering)"></a>3. 有序性 (Ordering)</h5><p>有序性指程序代码的执行顺序与代码的书写顺序一致。</p>
<ul>
<li><strong>问题根源</strong>: 为了提高性能，编译器和处理器可能会对指令进行重排序。<ul>
<li><strong>编译器优化重排序</strong>: 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li><strong>指令级并行重排序</strong>: 现代处理器采用指令级并行技术，将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
</ul>
</li>
<li><strong>如何保证有序性</strong>:<ul>
<li><strong><code>volatile</code></strong>: 禁止特定类型的指令重排序（通过内存屏障 Memory Barrier）。</li>
<li><strong><code>synchronized</code>和<code>Lock</code></strong>: <code>synchronized</code>和<code>Lock</code>保证了同一时刻只有一个线程能进入临界区，这使得临界区内的代码在宏观上是串行执行的，从而保证了有序性。</li>
<li><strong>Happens-Before原则</strong>: 这是JMM中最重要的一个概念，是判断数据是否存在竞争、线程是否安全的主要依据。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-4-Happens-Before-原则"><a href="#2-1-4-Happens-Before-原则" class="headerlink" title="2.1.4 Happens-Before 原则"></a>2.1.4 Happens-Before 原则</h4><p>这是判断数据是否存在竞争、线程是否安全的主要依据。如果两个操作不满足 Happens-Before 规则，JVM 可以随意重排序。</p>
<p><strong>定义</strong>: 如果操作A happens-before 操作B，那么A操作的执行结果对B操作是可见的，并且A操作的执行顺序在B操作之前。</p>
<p>这两个操作可以在同一个线程内，也可以在不同线程之间。JMM天然定义了以下几条Happens-Before规则，无需开发者额外处理：</p>
<ol>
<li><strong>程序次序规则 (Program Order Rule)</strong>: 在一个线程内，按照代码的先后顺序，书写在前面的操作happens-before书写在后面的操作。</li>
<li><strong>管程锁定规则 (Monitor Lock Rule)</strong>: 一个<code>unlock</code>操作happens-before后续对<strong>同一个锁</strong>的<code>lock</code>操作。</li>
<li><strong><code>volatile</code>变量规则 (Volatile Variable Rule)</strong>: 对一个<code>volatile</code>变量的<strong>写</strong>操作happens-before后续对这个<code>volatile</code>变量的<strong>读</strong>操作。</li>
<li><strong>线程启动规则 (Thread Start Rule)</strong>: <code>Thread</code>对象的<code>start()</code>方法happens-before此线程的任何一个动作。</li>
<li><strong>线程终止规则 (Thread Termination Rule)</strong>: 线程中的所有操作都happens-before对此线程的终止检测，例如可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回<code>false</code>等手段检测到线程已经终止执行。</li>
<li><strong>线程中断规则 (Thread Interruption Rule)</strong>: 对线程<code>interrupt()</code>方法的调用happens-before被中断线程的代码检测到中断事件的发生。</li>
<li><strong>对象终结规则 (Finalizer Rule)</strong>: 一个对象的初始化完成（构造函数执行结束）happens-before它的<code>finalize()</code>方法的开始。</li>
<li><strong>传递性 (Transitivity)</strong>: 如果操作A happens-before 操作B，操作B happens-before 操作C，那么可以得出操作A happens-before 操作C。</li>
</ol>
<hr>
<h3 id="2-2-关键字与底层实现"><a href="#2-2-关键字与底层实现" class="headerlink" title="2.2 关键字与底层实现"></a>2.2 关键字与底层实现</h3><h4 id="2-2-1-synchronized：重量级的内置锁"><a href="#2-2-1-synchronized：重量级的内置锁" class="headerlink" title="2.2.1 synchronized：重量级的内置锁"></a>2.2.1 <code>synchronized</code>：重量级的内置锁</h4><p><code>synchronized</code> 是 Java 中最经典、最常用的同步机制。它是一种<strong>悲观锁</strong>，总是在操作数据前先加锁，确保同一时间只有一个线程能访问被保护的代码块或方法。</p>
<h5 id="1-核心作用"><a href="#1-核心作用" class="headerlink" title="1. 核心作用"></a>1. 核心作用</h5><p><code>synchronized</code> 提供了两大核心保证：</p>
<ol>
<li><strong>原子性 (Atomicity)</strong>：<code>synchronized</code> 关键字包裹的代码块（称为“同步块”或“临界区”）是原子的。一个线程一旦进入同步块，就会持有锁，直到执行完毕或抛出异常才会释放锁。在此期间，其他任何线程都无法进入该同步块。</li>
<li><strong>可见性 (Visibility)</strong>：根据JMM的管程锁定规则（Happens-Before），对一个锁的 <code>unlock</code> 操作 happens-before 后续对同一个锁的 <code>lock</code> 操作。这意味着：<ul>
<li><strong>释放锁时</strong>：线程必须将工作内存中修改过的共享变量值刷新到主内存。</li>
<li><strong>获取锁时</strong>：线程会清空工作内存，强制从主内存中重新加载共享变量的最新值。</li>
<li>通过这一进一出的机制，<code>synchronized</code> 保证了线程间的可见性。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-使用方式"><a href="#2-使用方式" class="headerlink" title="2. 使用方式"></a>2. 使用方式</h5><p><code>synchronized</code> 有三种主要的使用方式：</p>
<ol>
<li><p><strong>修饰实例方法</strong>：锁对象是当前实例对象 (<code>this</code>)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 同步代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修饰静态方法</strong>：锁对象是当前类的 <code>Class</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 同步代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修饰代码块</strong>：可以显式指定任何对象作为锁对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blockMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 锁对象是 lock</span></span><br><span class="line">        <span class="comment">// 同步代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">// 锁对象是 this</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="3-底层实现原理：Monitor-与锁升级"><a href="#3-底层实现原理：Monitor-与锁升级" class="headerlink" title="3. 底层实现原理：Monitor 与锁升级"></a>3. 底层实现原理：Monitor 与锁升级</h5><p><code>synchronized</code> 的底层实现经历了从“重”到“轻”的演变，核心依赖于 <strong>JVM（HotSpot）</strong> 的对象头结构和 <strong>操作系统</strong> 的互斥量（Mutex）。理解它主要围绕两个维度：<strong>字节码层面的指令</strong> 和 <strong>运行时的锁升级机制</strong>。</p>
<p><strong>重量级锁的基石：<code>ObjectMonitor</code></strong></p>
<p>在锁膨胀为<strong>重量级锁</strong>时，Java 对象会关联一个 JVM 内部的 C++ 对象 <code>ObjectMonitor</code>。它类似于一个“管程”，核心组件如下：</p>
<ul>
<li><strong><code>_owner</code></strong>：指向当前持有锁的线程。</li>
<li><strong><code>_EntryList</code> (入口队列)</strong>：<strong>阻塞等待</strong>队列。竞争锁失败的线程会被封装成 <code>ObjectWaiter</code> 节点放入此处，进入 <code>BLOCKED</code> 状态，不再消耗 CPU。</li>
<li><strong><code>_WaitSet</code> (等待队列)</strong>：<strong>条件等待</strong>队列。持有锁的线程调用 <code>wait()</code> 后，会释放锁并进入此处，状态变为 <code>WAITING</code>，等待 <code>notify/notifyAll</code> 唤醒。</li>
<li><strong><code>_recursions</code></strong>：重入计数器。记录锁被同一线程重入的次数。</li>
<li><strong><code>_cxq</code> (Contention Queue)</strong>：实际上线程获取锁失败后，通常先进入这个栈结构，之后才会被移动到 <code>_EntryList</code>，这涉及到具体的排队策略。</li>
</ul>
<hr>
<p><strong>字节码层面的体现</strong></p>
<p>Java 编译器（javac）会将 <code>synchronized</code> 编译为不同的指令，具体取决于修饰的是代码块还是方法：</p>
<ul>
<li><strong>同步代码块 (Synchronized Block)</strong><ul>
<li><strong>指令</strong>：<code>monitorenter</code> 和 <code>monitorexit</code>。</li>
<li><strong>流程</strong>：<ul>
<li><strong>加锁</strong>：执行 <code>monitorenter</code> 时，线程尝试获取对象关联的 Monitor 所有权。</li>
<li><strong>释放</strong>：执行 <code>monitorexit</code> 时，释放所有权。</li>
<li><strong>异常处理</strong>：为了保证异常发生时也能释放锁，编译器会生成<strong>两个</strong> <code>monitorexit</code> 指令：<ol>
<li>一个在代码块正常结束时执行。</li>
<li>另一个配合 <strong>Exception Table（异常表）</strong>，当代码块抛出异常时跳转执行，起到类似 <code>try-finally</code> 的作用。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>同步方法 (Synchronized Method)</strong><ul>
<li><strong>标志</strong>：字节码中<strong>没有</strong>显式的 <code>monitorenter/exit</code> 指令。</li>
<li><strong>机制</strong>：在方法的常量池方法表结构（Method_Info）中，设置了 <strong><code>ACC_SYNCHRONIZED</code></strong> 访问标志。</li>
<li><strong>执行</strong>：JVM 调用方法时检查此标志，如果设置了，线程在执行方法前会自动获取 Monitor，方法返回（无论正常或异常）时自动释放。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>锁状态的载体：Mark Word</strong></p>
<p>锁升级的基础是 <strong>Java 对象头（Object Header）</strong> 中的 <strong>Mark Word</strong>。它是一个高度复用的 64 位（在 64 位 JVM 中）数据结构。</p>
<p><strong>Mark Word 状态一览表：</strong></p>
<table>
<thead>
<tr>
<th align="left">锁状态</th>
<th align="center">偏向锁标识</th>
<th align="center">锁标志位</th>
<th align="left">存储内容 (核心信息)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>无锁</strong></td>
<td align="center">0</td>
<td align="center"><strong>01</strong></td>
<td align="left">HashCode (31bit) | 分代年龄 | …</td>
</tr>
<tr>
<td align="left"><strong>偏向锁</strong></td>
<td align="center">1</td>
<td align="center"><strong>01</strong></td>
<td align="left"><strong>线程ID (54bit)</strong> | Epoch | 分代年龄</td>
</tr>
<tr>
<td align="left"><strong>轻量级锁</strong></td>
<td align="center">-</td>
<td align="center"><strong>00</strong></td>
<td align="left"><strong>指向栈中 Lock Record 的指针</strong> (62bit)</td>
</tr>
<tr>
<td align="left"><strong>重量级锁</strong></td>
<td align="center">-</td>
<td align="center"><strong>10</strong></td>
<td align="left"><strong>指向堆外 ObjectMonitor 的指针</strong> (62bit)</td>
</tr>
<tr>
<td align="left"><strong>GC 标记</strong></td>
<td align="center">-</td>
<td align="center"><strong>11</strong></td>
<td align="left">(空，用于垃圾回收)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>：偏向锁和无锁的锁标志位都是 <code>01</code>，主要靠倒数第三位的“偏向锁标识”来区分。</p>
</blockquote>
<hr>
<p><strong>锁升级</strong></p>
<p>JDK 1.6 引入了锁升级，旨在解决重量级锁频繁涉及<strong>用户态与内核态切换</strong>带来的性能开销。锁主要沿 <code>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</code> 的方向升级，<strong>一般不可降级</strong>（但在 GC 期间可能发生降级）。</p>
<ol>
<li><strong>无锁状态 (No Lock)</strong><br>对象被创建时，默认处于无锁状态。Mark Word 的锁标志位为 <code>01</code>，且偏向锁标志位为 <code>0</code>。</li>
<li><strong>偏向锁 (Biased Locking)</strong><ul>
<li><strong>场景</strong>：锁总是被<strong>同一个线程</strong>多次访问，不存在竞争。</li>
<li><strong>原理</strong>：<ul>
<li>第一次获取锁时，使用 <strong>CAS</strong> 将<strong>当前线程 ID</strong> 记录到对象头的 Mark Word 中，并将是否偏向锁状态设为 1。</li>
<li>后续该线程再次进入，只需对比 Mark Word 中的线程 ID，<strong>无需任何 CAS 操作</strong>，性能极高。</li>
</ul>
</li>
<li><strong>撤销 (Revocation)</strong>：<ul>
<li>一旦有<strong>其他线程</strong>尝试获取锁，偏向模式立即结束。</li>
<li>需等待<strong>全局安全点 (Safepoint)</strong>，暂停持有偏向锁的线程，判断其是否存活或是否仍在同步块中，决定是退回无锁还是升级为轻量级锁。</li>
</ul>
</li>
<li><em>细节</em>：JDK 8 中偏向锁默认有 4 秒启动延迟；<strong>JDK 15 之后已默认禁用偏向锁</strong>。</li>
</ul>
</li>
<li><strong>轻量级锁 (Lightweight Locking)</strong><ul>
<li><strong>场景</strong>：多线程<strong>交替执行</strong>同步块，或者竞争非常短暂。</li>
<li><strong>升级触发</strong>：当有第二个线程尝试获取已被偏向的锁，且偏向锁撤销后，锁就会升级为轻量级锁。</li>
<li><strong>原理</strong>：<ul>
<li>JVM 会在当前线程的栈帧中创建一个名为 <strong>锁记录（Lock Record）</strong> 的空间。</li>
<li>将对象头中的 Mark Word 复制到 Lock Record 中（称为 Displaced Mark Word）。</li>
<li>JVM 使用 <strong>CAS (Compare And Swap)</strong> 操作尝试将对象头的 Mark Word 更新为指向 Lock Record 的指针。</li>
<li><strong>成功</strong>：当前线程获得锁，Mark Word 锁标志位变为 <code>00</code>。</li>
<li><strong>失败</strong>：说明有其他线程也在竞争。当前线程会尝试 <strong>自旋（Spinning）</strong>。</li>
</ul>
</li>
<li><strong>自旋锁 (Spin Lock)</strong>：<br>线程不立即阻塞（挂起），而是执行一个空循环（自旋），看看持有锁的线程是否很快就会释放锁。<ul>
<li><strong>适应性自旋</strong>：JDK 1.6 引入了适应性自旋。自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果上次自旋成功了，这次会多自旋几次；如果经常失败，可能直接省略自旋或减少自旋次数。</li>
</ul>
</li>
</ul>
</li>
<li><strong>重量级锁 (Heavyweight Locking)</strong><ul>
<li><strong>场景</strong>：自旋失败（竞争激烈）或并发度高，持有锁时间长。</li>
<li><strong>升级触发</strong>：当自旋超过一定次数（默认10次，或自适应判断），或者在自旋期间又有第三个线程来竞争，轻量级锁就会膨胀为重量级锁。</li>
<li><strong>原理</strong>：<ul>
<li>锁膨胀为 <code>ObjectMonitor</code>。Mark Word 指向 Monitor 地址。</li>
<li>未获取锁的线程不再自旋，而是被操作系统挂起（<strong>阻塞&#x2F;Park</strong>），放入 <code>_EntryList</code>。</li>
<li>线程挂起和唤醒需要内核介入，成本最高。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>其它锁优化技术</strong></p>
<ol>
<li><strong>锁消除 (Lock Elimination)</strong>：<br>JIT 编译器在编译运行时，通过<strong>逃逸分析</strong>，如果发现某些对象只在线程内部使用，根本不会被其他线程访问，那么它会将该对象上的 <code>synchronized</code> 锁直接去除。<br><em>例如：在方法内部定义 <code>StringBuffer</code> 并 append，因为属于局部变量，不会逃逸，锁会被消除。</em></li>
<li><strong>锁粗化 (Lock Coarsening)</strong>：<br>如果检测到一连串的操作都在对同一个对象反复加锁解锁（例如在循环体内），JVM 会将锁的范围扩展（粗化）到整个操作序列的外部，只加一次锁。</li>
</ol>
<hr>
<p><strong>避坑指南：打破锁升级的特殊情况</strong></p>
<ol>
<li><strong>HashCode 的计算</strong>：<ul>
<li>如果对象处于<strong>无锁</strong>状态，HashCode 存在 Mark Word 中。</li>
<li>如果对象计算过 HashCode，则<strong>无法进入偏向锁</strong>状态（因为偏向锁 Mark Word 没地方存 HashCode），会直接跳到轻量级锁。</li>
<li>如果对象处于<strong>偏向锁</strong>状态，此时调用 <code>hashCode()</code>，偏向锁会被撤销，强制升级为<strong>重量级锁</strong>（重量级锁的 Monitor 对象里有字段可以存 Mark Word 的原始信息，包括 HashCode）。</li>
<li>如果处于<strong>轻量级锁</strong>，HashCode 存在栈帧的 Lock Record 中。</li>
</ul>
</li>
<li><strong>wait() 方法</strong>：<ul>
<li><code>wait()</code> 和 <code>notify()</code> 依赖于 Monitor 的 <code>_WaitSet</code>。</li>
<li>因此，一旦调用 <code>wait()</code>，无论当前是什么锁，都会直接膨胀为<strong>重量级锁</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-2-2-volatile：轻量级的同步机制"><a href="#2-2-2-volatile：轻量级的同步机制" class="headerlink" title="2.2.2 volatile：轻量级的同步机制"></a>2.2.2 <code>volatile</code>：轻量级的同步机制</h4><p><code>volatile</code> 是一个变量修饰符。与 <code>synchronized</code> 相比，它更轻量级，因为它不会导致线程上下文切换和调度。</p>
<h5 id="1-核心作用-1"><a href="#1-核心作用-1" class="headerlink" title="1. 核心作用"></a>1. 核心作用</h5><p><code>volatile</code> 提供了两大核心保证，但<strong>不保证原子性</strong>。</p>
<ol>
<li><strong>可见性 (Visibility)</strong><ul>
<li><strong>机制</strong>：保证不同线程对共享变量操作的可见性。</li>
<li><strong>写操作</strong>：当线程修改 <code>volatile</code> 变量时，JMM 会强制将修改后的值立即<strong>刷新（Flush）到主内存</strong>中。</li>
<li><strong>读操作</strong>：当线程读取 <code>volatile</code> 变量时，JMM 会把该线程本地内存中的缓存<strong>置为无效（Invalidate）</strong>，从而强制从主内存中重新读取最新值。</li>
<li><em>底层原理：基于缓存一致性协议（如 MESI），通过总线嗅探机制实现。</em></li>
</ul>
</li>
<li><strong>有序性 (Ordering)</strong><ul>
<li><strong>机制</strong>：禁止指令重排序优化。</li>
<li><strong>Happens-Before 原则</strong>：JMM 规定，对一个 <code>volatile</code> 变量的写操作，<strong>Happens-Before</strong> 于后续对这个变量的读操作。</li>
<li><strong>屏障效果</strong>：<code>volatile</code> 读写就像一道墙。<ul>
<li>墙之前的代码不能跑到墙后面。</li>
<li>墙之后的代码不能跑到墙前面。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-底层实现原理：内存屏障"><a href="#2-底层实现原理：内存屏障" class="headerlink" title="2. 底层实现原理：内存屏障"></a>2. 底层实现原理：内存屏障</h5><p><code>volatile</code> 的底层实现主要依赖于 <strong>内存屏障（Memory Barriers &#x2F; Memory Fences）</strong>。</p>
<ul>
<li><strong>内存屏障</strong>: 是一种CPU指令，它有两个作用：<ol>
<li>确保特定操作的执行顺序，防止编译器和处理器为了性能优化而对指令进行重排序。</li>
<li>强制将对缓存的修改操作立即写入主内存，并使其他CPU核心的缓存失效。</li>
</ol>
</li>
</ul>
<p><strong>JMM 定义的四类屏障策略（逻辑层面）：</strong></p>
<table>
<thead>
<tr>
<th align="left">屏障类型</th>
<th align="left">插入位置</th>
<th align="left">作用描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>StoreStore</strong></td>
<td align="left">在 volatile <strong>写前</strong></td>
<td align="left">禁止<strong>上面的所有写操作</strong>（普通&#x2F;Volatile）与当前的 volatile 写重排序。<br><em>(保证在 volatile 写之前，前面的所有数据修改都已经对内存可见)</em></td>
</tr>
<tr>
<td align="left"><strong>StoreLoad</strong></td>
<td align="left">在 volatile <strong>写后</strong></td>
<td align="left">禁止当前的 volatile 写与<strong>后面的所有读操作</strong>（包括 volatile 读）重排序。<br><em>(强制刷写缓冲区，<strong>性能开销最大</strong>，防止 <code>volatile写</code> 与 <code>volatile读</code> 发生乱序)</em></td>
</tr>
<tr>
<td align="left"><strong>LoadLoad</strong></td>
<td align="left">在 volatile <strong>读后</strong></td>
<td align="left">禁止当前的 volatile 读与<strong>后面的所有读操作</strong>重排序。<br><em>(确保先读完当前 volatile 变量，再读后面的数据)</em></td>
</tr>
<tr>
<td align="left"><strong>LoadStore</strong></td>
<td align="left">在 volatile <strong>读后</strong></td>
<td align="left">禁止当前的 volatile 读与<strong>后面的所有写操作</strong>重排序。<br/><em>(禁止下面的写操作“飘”到 volatile 读之前执行)</em></td>
</tr>
</tbody></table>
<p><strong>硬件层面的落地 (以 x86 架构为例)：</strong></p>
<p>虽然 JMM 定义了四种屏障，但在实际的 x86 处理器中，JVM 通常会使用 <strong>Lock 前缀指令</strong>（如 <code>lock addl $0x0,(%rsp)</code>）来实现 <code>StoreLoad</code> 屏障。</p>
<ul>
<li><code>lock</code> 指令本身就具备内存屏障的效果。</li>
<li>它会锁定总线或缓存行，确保“写操作”立即刷回主存，并利用 <strong>MESI 协议</strong> 使其他 CPU 的缓存失效。</li>
</ul>
<hr>
<h5 id="3-经典案例：双重检查锁定-DCL"><a href="#3-经典案例：双重检查锁定-DCL" class="headerlink" title="3. 经典案例：双重检查锁定 (DCL)"></a>3. 经典案例：双重检查锁定 (DCL)</h5><p><code>volatile</code> 最著名的应用场景是单例模式中的 <strong>Double-Checked Locking</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 必须添加 volatile 关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查：避免不必要的同步，提高性能</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查：防止并发创建</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; </span><br><span class="line">                    <span class="comment">// 2. 问题的根源</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要用 <code>volatile</code>？</strong></p>
<p><code>instance = new Singleton()</code> 这一行代码在汇编层面分为三步：</p>
<ol>
<li><code>memory = allocate()</code>：分配内存空间。</li>
<li><code>ctorInstance(memory)</code>：在内存上初始化对象。</li>
<li><code>instance = memory</code>：将引用指向内存地址（此时 <code>instance != null</code>）。</li>
</ol>
<p>如果没有 <code>volatile</code>，编译器或处理器可能进行<strong>指令重排序</strong>，将执行顺序变为 <strong>1 -&gt; 3 -&gt; 2</strong>。</p>
<ul>
<li><strong>后果</strong>：线程 A 执行完第 3 步（instance 指向了地址，但对象还没初始化），此时线程 B 进来，在“第一次检查”时发现 <code>instance != null</code>，于是直接返回了这个<strong>未初始化完全的半成品对象</strong>，导致程序崩溃。</li>
<li><code>volatile</code> 禁止了 2 和 3 的重排序，保证了初始化的安全性。</li>
</ul>
<hr>
<h4 id="2-2-3-深度对比：Synchronized-vs-Volatile"><a href="#2-2-3-深度对比：Synchronized-vs-Volatile" class="headerlink" title="2.2.3 深度对比：Synchronized vs Volatile"></a>2.2.3 深度对比：Synchronized vs Volatile</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>volatile</code></th>
<th align="left"><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>原子性</strong></td>
<td align="left"><strong>不保证</strong> (仅保证单次读写)</td>
<td align="left"><strong>保证</strong> (通过互斥锁实现)</td>
</tr>
<tr>
<td align="left"><strong>可见性</strong></td>
<td align="left"><strong>保证</strong> (立即刷新主存)</td>
<td align="left"><strong>保证</strong> (解锁前刷新主存)</td>
</tr>
<tr>
<td align="left"><strong>有序性</strong></td>
<td align="left"><strong>保证</strong> (禁止指令重排序)</td>
<td align="left"><strong>保证</strong> (块内串行化)</td>
</tr>
<tr>
<td align="left"><strong>阻塞性</strong></td>
<td align="left"><strong>非阻塞</strong> (不会造成线程挂起)</td>
<td align="left"><strong>阻塞</strong> (竞争失败会挂起)</td>
</tr>
<tr>
<td align="left"><strong>作用范围</strong></td>
<td align="left">仅修饰<strong>变量</strong></td>
<td align="left">修饰<strong>方法</strong>或<strong>代码块</strong></td>
</tr>
<tr>
<td align="left"><strong>底层原理</strong></td>
<td align="left">内存屏障 (Memory Barrier)</td>
<td align="left">对象监视器 (Monitor) + 操作系统 Mutex</td>
</tr>
<tr>
<td align="left"><strong>编译器优化</strong></td>
<td align="left">禁止特定优化</td>
<td align="left">可能会被粗化或消除 (Lock Elision)</td>
</tr>
</tbody></table>
<blockquote>
<p><em><strong>注：关于 Synchronized 的有序性</strong></em></p>
<p><code>synchronized</code> 保证的有序性是“宏观”的（一个线程执行完，另一个才能进）。但在同步块<strong>内部</strong>，JVM 依然可以进行指令重排序，只要不影响单线程执行结果（As-If-Serial）。而 <code>volatile</code> 是严格禁止与之相关的指令重排。</p>
</blockquote>
<hr>
<h2 id="3-锁的深入剖析与-J-U-C"><a href="#3-锁的深入剖析与-J-U-C" class="headerlink" title="3. 锁的深入剖析与 J.U.C"></a>3. <strong>锁的深入剖析与 J.U.C</strong></h2><h3 id="3-1-锁的分类与概念"><a href="#3-1-锁的分类与概念" class="headerlink" title="3.1 锁的分类与概念"></a>3.1 锁的分类与概念</h3><p>为了应对不同的并发场景、优化性能，锁被设计出了多种类型和特性。</p>
<h4 id="3-1-1-乐观锁-Optimistic-Lock-vs-悲观锁-Pessimistic-Lock"><a href="#3-1-1-乐观锁-Optimistic-Lock-vs-悲观锁-Pessimistic-Lock" class="headerlink" title="3.1.1 乐观锁 (Optimistic Lock) vs. 悲观锁 (Pessimistic Lock)"></a>3.1.1 乐观锁 (Optimistic Lock) vs. 悲观锁 (Pessimistic Lock)</h4><p>这是从<strong>对并发冲突的态度</strong>角度进行的划分，是两种最基本的设计思想。</p>
<h5 id="1-悲观锁-Pessimistic-Lock"><a href="#1-悲观锁-Pessimistic-Lock" class="headerlink" title="1. 悲观锁 (Pessimistic Lock)"></a>1. 悲观锁 (Pessimistic Lock)</h5><ul>
<li><strong>概念</strong>: 总是假设最坏的情况，认为数据在被访问时总会发生并发冲突。因此，在每次对数据进行操作之前，都会先<strong>加锁</strong>，确保在自己操作数据的整个过程中，其他线程无法进行修改，操作完成后再<strong>解锁</strong>。</li>
<li><strong>实现方式</strong>: Java 中的 <code>synchronized</code> 关键字和 <code>java.util.concurrent.locks.Lock</code> 接口的所有实现类（如 <code>ReentrantLock</code>）都是典型的悲观锁。</li>
<li><strong>优点</strong>: 实现简单，数据一致性强，适用于<strong>写多读少</strong>、<strong>并发冲突激烈</strong>的场景。</li>
<li><strong>缺点</strong>: 无论是否存在竞争，都会进行加锁和解锁操作，这会带来额外的开销，尤其是在低竞争环境下，会降低系统吞吐量。线程阻塞和唤醒涉及上下文切换，成本较高。</li>
</ul>
<hr>
<h5 id="2-乐观锁-Optimistic-Lock"><a href="#2-乐观锁-Optimistic-Lock" class="headerlink" title="2. 乐观锁 (Optimistic Lock)"></a>2. 乐观锁 (Optimistic Lock)</h5><ul>
<li><strong>概念</strong>: 总是假设最好的情况，认为数据在被访问时不会发生并发冲突。因此，它<strong>不会加锁</strong>，而是在<strong>更新数据时</strong>去判断，在此期间是否有其他线程修改了数据。</li>
<li><strong>实现方式</strong>: 通常通过 <strong>CAS (Compare-And-Swap) 机制</strong>实现。</li>
<li><strong>实现举例</strong>: J.U.C 包中的原子类（如 <code>AtomicInteger</code>）就是通过 CAS 实现的乐观锁。</li>
<li><strong>优点</strong>: 避免了线程阻塞和唤醒的开销，在<strong>读多写少</strong>、<strong>并发冲突不激烈</strong>的场景下，性能远超悲观锁。</li>
<li><strong>缺点</strong>: 如果并发冲突频繁（写操作多），会导致 CAS 操作不断失败并重试（自旋），这会<strong>消耗大量的 CPU 资源</strong>。此外，CAS 只能保证单个共享变量的原子操作，对于多个变量的原子性保证比较复杂（可以使用 <code>AtomicReference</code> 解决）。</li>
</ul>
<hr>
<h5 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p><strong>场景设定</strong></p>
<p>我们以一个经典的“银行账户取款”场景为例。假设一个账户初始有 1000 元，两个线程（比如两个人 A 和 B）同时从中各取 800 元。</p>
<ul>
<li><strong>正确结果</strong>：一个人取款成功，账户余额变为 200 元；另一个人取款失败，因为余额不足。</li>
<li><strong>错误结果（无锁）</strong>：A 读取余额 1000，B 也读取余额 1000。A 计算新余额 200，B 也计算新余额 200。A 写入 200，B 也写入 200。最终账户余额为 200，但实际上取走了 1600，导致数据不一致（“丢掉的更新”问题）。</li>
</ul>
<p><strong>悲观锁实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 悲观锁示例</span></span><br><span class="line"><span class="comment"> * 使用 synchronized 关键字实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PessimisticAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PessimisticAccount</span><span class="params">(<span class="type">int</span> initialBalance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = initialBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 关键字对整个方法加锁</span></span><br><span class="line">    <span class="comment">// 任何线程在执行此方法前，必须先获得该对象的锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印当前线程尝试取款的信息</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;线程 %s 尝试取款 %d, 当前余额: %d\n&quot;</span>, Thread.currentThread().getName(), amount, <span class="built_in">this</span>.balance);</span><br><span class="line">        <span class="comment">// 检查余额是否足够</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt;= amount) &#123;</span><br><span class="line">            <span class="comment">// 模拟一些业务处理耗时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 扣除金额并打印成功信息</span></span><br><span class="line">            <span class="built_in">this</span>.balance -= amount;</span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 %s 取款成功, 剩余余额: %d\n&quot;</span>, Thread.currentThread().getName(), <span class="built_in">this</span>.balance);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 打印失败信息</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 %s 取款失败, 余额不足, 剩余余额: %d\n&quot;</span>, Thread.currentThread().getName(), <span class="built_in">this</span>.balance);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 悲观锁演示类</span></span><br><span class="line"><span class="comment"> * 展示了在多线程环境下如何使用悲观锁机制保证数据一致性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PessimisticLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个初始余额为1000的账户</span></span><br><span class="line">        <span class="type">PessimisticAccount</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PessimisticAccount</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建一个包含2个线程的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义取款任务：每个线程尝试取款800</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; account.withdraw(<span class="number">800</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交两个取款任务到线程池</span></span><br><span class="line">        executor.submit(task);</span><br><span class="line">        executor.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池并等待所有任务完成</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印最终账户余额</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n最终账户余额: &quot;</span> + account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 尝试取款 <span class="number">800</span>, 当前余额: <span class="number">1000</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 取款成功, 剩余余额: <span class="number">200</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 尝试取款 <span class="number">800</span>, 当前余额: <span class="number">200</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 取款失败, 余额不足, 剩余余额: <span class="number">200</span></span><br><span class="line"></span><br><span class="line">最终账户余额: <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p><strong>乐观锁实现</strong></p>
<p>这里我们模拟数据库中常用的版本号（version）机制。每次更新数据时，版本号加一。更新前，检查当前版本号是否与自己之前读取的一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乐观锁示例</span></span><br><span class="line"><span class="comment"> * 使用 &quot;版本号&quot; 机制，版本号本身用原子类 AtomicInteger 保证线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OptimisticAccount</span> &#123;</span><br><span class="line">    <span class="comment">// 账户余额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">    <span class="comment">// 使用原子类作为版本号，保证版本号自身的原子性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">version</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化账户余额</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialBalance 初始余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OptimisticAccount</span><span class="params">(<span class="type">int</span> initialBalance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = initialBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乐观锁取款操作</span></span><br><span class="line"><span class="comment">     * 通过版本号机制实现线程安全的取款操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount 取款金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 取款是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;线程 %s 准备取款 %d...\n&quot;</span>, Thread.currentThread().getName(), amount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自旋（spin）的方式不断重试</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 读取当前余额和版本号 (Read)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentBalance</span> <span class="operator">=</span> <span class="built_in">this</span>.balance;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentVersion</span> <span class="operator">=</span> <span class="built_in">this</span>.version.get();</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 %s 读取数据 - 余额: %d, 版本: %d\n&quot;</span>, Thread.currentThread().getName(), currentBalance, currentVersion);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查余额是否足够</span></span><br><span class="line">            <span class="keyword">if</span> (currentBalance &lt; amount) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;线程 %s 发现余额不足, 退出操作\n&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟业务计算耗时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 尝试更新 (Compare And Swap)</span></span><br><span class="line">            <span class="comment">// 比较版本号是否被其他线程修改过</span></span><br><span class="line">            <span class="comment">// 如果 version.compareAndSet 成功，说明从读取到准备更新的期间，数据没有被其他线程动过</span></span><br><span class="line">            <span class="keyword">if</span> (version.compareAndSet(currentVersion, currentVersion + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 版本号未变，可以安全地更新余额</span></span><br><span class="line">                <span class="built_in">this</span>.balance = currentBalance - amount;</span><br><span class="line">                System.out.printf(<span class="string">&quot;线程 %s 取款成功! 余额: %d, 版本更新为: %d\n&quot;</span>, Thread.currentThread().getName(), <span class="built_in">this</span>.balance, <span class="built_in">this</span>.version.get());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 版本号变了，说明数据已经被其他线程修改，本次操作失败，进行重试</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;线程 %s 操作失败, 数据已被修改 (版本从 %d 变为 %d), 进行重试...\n&quot;</span>,</span><br><span class="line">                        Thread.currentThread().getName(), currentVersion, <span class="built_in">this</span>.version.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前账户余额</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乐观锁演示类</span></span><br><span class="line"><span class="comment"> * 展示了在多线程环境下如何使用乐观锁机制保证数据一致性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimisticLockDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主函数，启动两个线程同时进行取款操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 命令行参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 线程中断异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建账户，初始余额1000</span></span><br><span class="line">        <span class="type">OptimisticAccount</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptimisticAccount</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建固定大小为2的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个线程同时取款 800</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; account.withdraw(<span class="number">800</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交两个取款任务</span></span><br><span class="line">        executor.submit(task);</span><br><span class="line">        executor.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池并等待所有任务完成</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终账户余额</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n最终账户余额: &quot;</span> + account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 准备取款 <span class="number">800.</span>..</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 读取数据 - 余额: <span class="number">1000</span>, 版本: <span class="number">0</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 准备取款 <span class="number">800.</span>..</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 读取数据 - 余额: <span class="number">1000</span>, 版本: <span class="number">0</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 取款成功! 余额: <span class="number">200</span>, 版本更新为: <span class="number">1</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 操作失败, 数据已被修改 (版本从 <span class="number">0</span> 变为 <span class="number">1</span>), 进行重试...</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 读取数据 - 余额: <span class="number">200</span>, 版本: <span class="number">1</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 发现余额不足, 退出操作</span><br><span class="line"></span><br><span class="line">最终账户余额: <span class="number">200</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">悲观锁 (<code>synchronized</code>)</th>
<th align="left">乐观锁 (CAS + 版本号)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心思想</strong></td>
<td align="left">假定会发生冲突，先加锁再操作</td>
<td align="left">假定不发生冲突，操作时不加锁，提交时验证</td>
</tr>
<tr>
<td align="left"><strong>数据一致性</strong></td>
<td align="left">强一致性，通过阻塞其他线程来保证</td>
<td align="left">最终一致性，通过重试机制来保证</td>
</tr>
<tr>
<td align="left"><strong>性能开销</strong></td>
<td align="left">线程阻塞和唤醒的开销较大，尤其是在低冲突环境下</td>
<td align="left">在低冲突环境下，无锁操作性能很高；但在高冲突环境下，反复重试会消耗大量 CPU</td>
</tr>
<tr>
<td align="left"><strong>死锁风险</strong></td>
<td align="left">有可能产生死锁（例如，多个锁嵌套）</td>
<td align="left">一般不会产生死锁</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>写多读少</strong>的场景。冲突频繁，加锁的成本相对较低。</td>
<td align="left"><strong>读多写少</strong>的场景。冲突较少，可以避免加锁带来的性能损耗。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-2-公平锁-Fair-Lock-vs-非公平锁-Unfair-Lock"><a href="#3-1-2-公平锁-Fair-Lock-vs-非公平锁-Unfair-Lock" class="headerlink" title="3.1.2 公平锁 (Fair Lock) vs. 非公平锁 (Unfair Lock)"></a>3.1.2 公平锁 (Fair Lock) vs. 非公平锁 (Unfair Lock)</h4><p>这是从<strong>线程获取锁的排队策略</strong>角度进行的划分。</p>
<h5 id="1-公平锁-Fair-Lock"><a href="#1-公平锁-Fair-Lock" class="headerlink" title="1. 公平锁 (Fair Lock)"></a>1. 公平锁 (Fair Lock)</h5><ul>
<li><strong>概念</strong>: 遵循<strong>先来后到 (FIFO)</strong> 的原则。多个线程请求锁时，会进入一个等待队列，等待时间最长的线程会优先获得锁。</li>
<li><strong>实现方式</strong>: <code>ReentrantLock</code> 可以通过构造函数 <code>new ReentrantLock(true)</code> 创建公平锁。</li>
<li><strong>优点</strong>: 所有线程都能获得执行机会，可以<strong>避免线程饥饿</strong>。</li>
<li><strong>缺点</strong>: 需要维护一个等待队列，并进行复杂的调度，导致上下文切换频繁，系统<strong>吞吐量较低</strong>。</li>
</ul>
<hr>
<h5 id="2-非公平锁-Unfair-Lock"><a href="#2-非公平锁-Unfair-Lock" class="headerlink" title="2. 非公平锁 (Unfair Lock)"></a>2. 非公平锁 (Unfair Lock)</h5><ul>
<li><strong>概念</strong>: 不遵循先来后到原则，允许“插队”。当一个线程请求锁时，如果恰好锁是可用的，它会直接尝试获取锁，而不管等待队列中是否有其他线程在等待。</li>
<li><strong>实现方式</strong>: <code>synchronized</code> 就是一种非公平锁。<code>ReentrantLock</code> 默认也是非公平锁 (<code>new ReentrantLock()</code>)。</li>
<li><strong>优点</strong>: 减少了线程挂起和唤醒的开销。如果一个线程刚释放锁，恰好它又需要再次获取，它可以立即获得，<strong>减少了上下文切换，提高了系统吞吐量</strong>。</li>
<li><strong>缺点</strong>: 可能会导致等待队列中的线程长时间无法获取锁，造成<strong>线程饥饿</strong>。</li>
</ul>
<blockquote>
<p><strong>为什么非公平锁性能更高？</strong></p>
<p>因为它减少了CPU进行线程上下文切换的次数。当线程A释放锁后，如果线程A马上又要获取锁，它可以立即获取，无需唤醒队列中的线程B。而公平锁则必须先将线程A挂起，再唤醒线程B，这个过程开销很大。</p>
</blockquote>
<hr>
<h5 id="3-代码示例-1"><a href="#3-代码示例-1" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁的公平性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairnessLockDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 程序入口点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 命令行参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 当线程被中断时抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 演示公平锁：线程将按照请求锁的顺序获得锁</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--- Fair Lock Demo ---&quot;</span>);</span><br><span class="line">        runDemo(<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>)); <span class="comment">// 构造函数传入 true 创建公平锁</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Non-Fair Lock Demo ---&quot;</span>);</span><br><span class="line">        runDemo(<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>)); <span class="comment">// 构造函数传入 false 或不传参数，创建非公平锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行一个演示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lock 要使用的锁（公平或非公平）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 当线程被中断时抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runDemo</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建5个线程去竞争同一个锁</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Job</span>(lock), <span class="string">&quot;Thread-&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次启动线程</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个简单的任务，它会循环两次获取和释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Job</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Lock lock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造函数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> lock 要使用的锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Job</span><span class="params">(Lock lock)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程执行的任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 每个线程循环2次，以便观察锁的分配模式</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 标准的锁使用模式：在try-finally块中加锁和解锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;线程 [%s] 获得了锁 (第 %d 次)\n&quot;</span>, threadName, i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 模拟工作耗时</span></span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 处理中断异常</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 确保锁最终会被释放</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- Fair Lock Demo ---</span><br><span class="line">线程 [Thread-<span class="number">0</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">1</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">2</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">3</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">4</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">0</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">1</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">2</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">3</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">4</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line"></span><br><span class="line">--- Non-Fair Lock Demo ---</span><br><span class="line">线程 [Thread-<span class="number">0</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">0</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">1</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">2</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">2</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">4</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">4</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">3</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">3</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">1</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a>4. 总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">公平锁 (<code>ReentrantLock(true)</code>)</th>
<th align="left">非公平锁 (<code>ReentrantLock(false)</code>, <code>synchronized</code>)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>获取顺序</strong></td>
<td align="left">先来后到 (FIFO)</td>
<td align="left">抢占式，无固定顺序</td>
</tr>
<tr>
<td align="left"><strong>线程饥饿</strong></td>
<td align="left">不会发生</td>
<td align="left">可能发生</td>
</tr>
<tr>
<td align="left"><strong>吞吐量</strong></td>
<td align="left">较低</td>
<td align="left">较高（因为减少了上下文切换）</td>
</tr>
<tr>
<td align="left"><strong>实现</strong></td>
<td align="left"><code>new ReentrantLock(true)</code></td>
<td align="left"><code>new ReentrantLock()</code> 或 <code>synchronized</code></td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-3-独占锁-Exclusive-Lock-vs-共享锁-Shared-Lock"><a href="#3-1-3-独占锁-Exclusive-Lock-vs-共享锁-Shared-Lock" class="headerlink" title="3.1.3 独占锁 (Exclusive Lock) vs. 共享锁 (Shared Lock)"></a>3.1.3 独占锁 (Exclusive Lock) vs. 共享锁 (Shared Lock)</h4><p>这是从<strong>锁的并发访问模式</strong>角度进行的划分。</p>
<h5 id="1-独占锁-Exclusive-Lock"><a href="#1-独占锁-Exclusive-Lock" class="headerlink" title="1. 独占锁 (Exclusive Lock)"></a>1. 独占锁 (Exclusive Lock)</h5><ul>
<li><strong>概念</strong>: 该锁一次只能被一个线程所持有。如果一个线程获取了独占锁，其他任何线程（无论是读还是写）都必须等待，直到该锁被释放。</li>
<li><strong>实现方式</strong>: <code>synchronized</code> 和 <code>ReentrantLock</code> 都是独占锁。</li>
</ul>
<hr>
<h5 id="2-共享锁-Shared-Lock"><a href="#2-共享锁-Shared-Lock" class="headerlink" title="2. 共享锁 (Shared Lock)"></a>2. 共享锁 (Shared Lock)</h5><ul>
<li><strong>概念</strong>: 该锁可以被多个线程同时持有。它通常区分读写操作，允许多个线程同时进行读操作，但只允许一个线程进行写操作，且写操作会阻塞所有的读写。也称为<strong>读写锁 (Read-Write Lock)</strong>。</li>
<li><strong>实现方式</strong>: <code>ReentrantReadWriteLock</code> 是典型的共享锁实现。</li>
<li><strong>优点</strong>: 在<strong>读多写少</strong>的场景下，可以极大地提高程序的并发能力和吞吐量。</li>
</ul>
<hr>
<h5 id="3-代码示例-2"><a href="#3-代码示例-2" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p><strong>场景设定</strong></p>
<p>我们来模拟一个<strong>缓存系统</strong>的场景：</p>
<ul>
<li><strong>读取缓存 (get)</strong>：这是一个读操作，应该是并发的，允许多个线程同时进行。</li>
<li><strong>写入&#x2F;更新缓存 (put)</strong>：这是一个写操作，必须是独占的，写入时不允许任何其他读或写操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 ReentrantReadWriteLock 实现的简单缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedDataCache</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存数据存储结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 创建一个可重入的读写锁，用于控制并发访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 从读写锁中分离出读锁（共享锁），允许多个线程同时读取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> rwLock.readLock();</span><br><span class="line">    <span class="comment">// 从读写锁中分离出写锁（独占锁），确保写操作的独占性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取缓存 - 使用共享锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取读锁，允许多个线程同时读取</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 [%s] 正在读取数据...\n&quot;</span>, threadName);</span><br><span class="line">            <span class="comment">// 模拟读取耗时，让并发效果更明显</span></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 [%s] 读取完成, 值为: %s\n&quot;</span>, threadName, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 处理线程中断异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 释放读锁，确保锁一定会被释放</span></span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入缓存 - 使用独占锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   缓存键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 缓存值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取写锁，确保写操作的独占性</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 [%s] 正在写入数据 (key=%s, value=%s)...\n&quot;</span>, threadName, key, value);</span><br><span class="line">            <span class="comment">// 模拟写入耗时，让并发效果更明显</span></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 [%s] 写入完成.\n&quot;</span>, threadName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 处理线程中断异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 释放写锁，确保锁一定会被释放</span></span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedExclusiveLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建共享数据缓存实例</span></span><br><span class="line">        <span class="type">SharedDataCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedDataCache</span>();</span><br><span class="line">        <span class="comment">// 创建固定大小的线程池，用于执行读写任务</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动一个写线程，向缓存中写入数据</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writerTask</span> <span class="operator">=</span> () -&gt; cache.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        executor.submit(writerTask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 稍微等待，让写线程先开始执行</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动多个读线程，从缓存中读取数据</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">readerTask</span> <span class="operator">=</span> () -&gt; cache.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        executor.submit(readerTask); <span class="comment">// Reader 1</span></span><br><span class="line">        executor.submit(readerTask); <span class="comment">// Reader 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再启动一个写线程，向缓存中写入另一条数据</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writerTask2</span> <span class="operator">=</span> () -&gt; cache.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        executor.submit(writerTask2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再启动两个读线程，从缓存中读取数据</span></span><br><span class="line">        executor.submit(readerTask); <span class="comment">// Reader 3</span></span><br><span class="line">        executor.submit(readerTask); <span class="comment">// Reader 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池，不再接受新任务</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="comment">// 等待所有任务执行完成，最多等待1分钟</span></span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个写线程获取了独占锁，开始写入</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">1</span>] 正在写入数据 (key=key1, value=value1)...</span><br><span class="line"><span class="comment">// Reader1 和 Reader2 尝试获取读锁，但因为写锁被占用，它们必须等待</span></span><br><span class="line"><span class="comment">// Writer2 尝试获取写锁，也必须等待</span></span><br><span class="line"><span class="comment">// 第一个写线程完成并释放锁</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">1</span>] 写入完成.</span><br><span class="line"><span class="comment">// 写锁释放后，所有等待的读线程（Reader1, Reader2）可以同时获取读锁，并发执行</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">2</span>] 正在读取数据...</span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">3</span>] 正在读取数据...</span><br><span class="line"><span class="comment">// 两个读线程几乎同时完成</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">2</span>] 读取完成, 值为: value1</span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">3</span>] 读取完成, 值为: value1</span><br><span class="line"><span class="comment">// 所有读锁都释放后，等待的写线程（Writer2）才能获取独占锁</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">4</span>] 正在写入数据 (key=key2, value=value2)...</span><br><span class="line"><span class="comment">// Reader3, Reader4 尝试获取读锁，但因为写锁被占用，它们必须等待</span></span><br><span class="line"><span class="comment">// 第二个写线程完成并释放锁</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">4</span>] 写入完成.</span><br><span class="line"><span class="comment">// 写锁释放后，等待的读线程（Reader3, Reader4）可以同时获取读锁，并发执行</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">5</span>] 正在读取数据...</span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">3</span>] 正在读取数据...  &lt;-- 注意这里可能是之前等待的线程复用</span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">5</span>] 读取完成, 值为: value1</span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">3</span>] 读取完成, 值为: value1</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-总结-2"><a href="#4-总结-2" class="headerlink" title="4. 总结"></a>4. 总结</h5><table>
<thead>
<tr>
<th align="left">锁类型</th>
<th align="left">别名</th>
<th align="left">特性</th>
<th align="left">Java 实现</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>独占锁</strong></td>
<td align="left">写锁, 排他锁</td>
<td align="left">一次只能被一个线程持有。</td>
<td align="left"><code>ReentrantReadWriteLock.writeLock()</code></td>
<td align="left">数据修改操作，如 <code>update</code>, <code>delete</code>, <code>insert</code>。</td>
</tr>
<tr>
<td align="left"><strong>共享锁</strong></td>
<td align="left">读锁</td>
<td align="left">可以被多个线程同时持有。</td>
<td align="left"><code>ReentrantReadWriteLock.readLock()</code></td>
<td align="left">数据读取操作，如 <code>select</code>, <code>get</code>。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-4-可重入锁-Reentrant-Lock-vs-不可重入锁-Non-Reentrant-Lock"><a href="#3-1-4-可重入锁-Reentrant-Lock-vs-不可重入锁-Non-Reentrant-Lock" class="headerlink" title="3.1.4 可重入锁 (Reentrant Lock) vs. 不可重入锁 (Non-Reentrant Lock)"></a>3.1.4 可重入锁 (Reentrant Lock) vs. 不可重入锁 (Non-Reentrant Lock)</h4><p>这是从<strong>同一个线程对同一个锁的重复获取</strong>角度进行的划分。</p>
<h5 id="1-可重入锁-Reentrant-Lock"><a href="#1-可重入锁-Reentrant-Lock" class="headerlink" title="1. 可重入锁 (Reentrant Lock)"></a>1. 可重入锁 (Reentrant Lock)</h5><ul>
<li><strong>概念</strong>: 也称为<strong>递归锁</strong>。指同一个线程在外层方法获取了锁之后，在内层方法仍然可以再次自动获取该锁，而不会因为之前已经获取过锁而被自己阻塞。</li>
<li><strong>原理</strong>: 锁内部维护一个计数器和一个指向持有者线程的引用。当线程请求锁时，如果持有者是自己，则计数器加1；释放锁时，计数器减1。当计数器为0时，锁才被真正释放。</li>
<li><strong>实现方式</strong>: <code>synchronized</code> 和 <code>ReentrantLock</code> 都是可重入锁。</li>
<li><strong>优点</strong>: <strong>可以避免死锁</strong>。例如，在一个 <code>synchronized</code> 方法中调用了另一个 <code>synchronized</code> 方法，如果不是可重入锁，就会造成自己死锁。</li>
</ul>
<hr>
<h5 id="2-不可重入锁"><a href="#2-不可重入锁" class="headerlink" title="2. 不可重入锁"></a>2. 不可重入锁</h5><ul>
<li><strong>概念</strong>: 一个线程获取了锁之后，如果再次尝试获取该锁，就会被阻塞。</li>
<li><strong>缺点</strong>: 容易造成死锁。在现代并发编程中已很少使用。</li>
</ul>
<hr>
<h5 id="3-代码示例-3"><a href="#3-代码示例-3" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p><strong>场景设定</strong></p>
<p>我们将创建一个场景：一个线程调用一个 <code>outer()</code> 方法，该方法会获取锁；在 <code>outer()</code> 方法内部，再调用一个 <code>inner()</code> 方法，该方法会<strong>尝试再次获取同一个锁</strong>。</p>
<ul>
<li><strong>对于可重入锁</strong>：<code>inner()</code> 方法会成功获取锁，程序正常执行完毕。</li>
<li><strong>对于不可重入锁</strong>：<code>inner()</code> 方法在尝试获取锁时会失败，导致线程永久等待，程序被挂起（死锁）。</li>
</ul>
<p><strong>不可重入锁的实现与演示</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的不可重入锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="comment">// 标记锁是否被持有</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 记录持有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Thread</span> <span class="variable">lockedBy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果锁已经被持有，则当前线程等待</span></span><br><span class="line">        <span class="keyword">while</span> (isLocked) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待，直到被唤醒</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 恢复中断状态</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="comment">// 由于中断，提前退出</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功获得锁</span></span><br><span class="line">        isLocked = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 记录持有锁的线程</span></span><br><span class="line">        lockedBy = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 只有持有锁的线程才能释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == lockedBy) &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            isLocked = <span class="literal">false</span>;</span><br><span class="line">            lockedBy = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 唤醒一个正在等待的线程</span></span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 其他 Lock 接口的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123; </span><br><span class="line">        <span class="comment">// 可中断地获取锁，这里未实现完整逻辑</span></span><br><span class="line">        <span class="comment">/* ... */</span> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 尝试非阻塞地获取锁，这里未实现完整逻辑</span></span><br><span class="line">        <span class="comment">/* ... */</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123; </span><br><span class="line">        <span class="comment">// 在给定时间内尝试获取锁，这里未实现完整逻辑</span></span><br><span class="line">        <span class="comment">/* ... */</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 返回一个与该锁关联的条件变量，这里未实现完整逻辑</span></span><br><span class="line">        <span class="comment">/* ... */</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonReentrantLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建不可重入锁实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入 outer() 方法&quot;</span>);</span><br><span class="line">            <span class="comment">// 在持有锁的情况下，调用 inner() 方法</span></span><br><span class="line">            inner();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试再次获取锁（对于不可重入锁，这会导致死锁）</span></span><br><span class="line">        lock.lock(); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入 inner() 方法&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NonReentrantLockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonReentrantLockDemo</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 不可重入锁演示 ---&quot;</span>);</span><br><span class="line">        <span class="comment">// 在一个新线程中运行，以防主线程被阻塞</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::outer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- 不可重入锁演示 ---</span><br><span class="line">进入 outer() 方法</span><br></pre></td></tr></table></figure>

<p><strong>可重入锁的演示</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Java 标准库提供的可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层方法，首先获取锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入 outer() 方法, lock count: &quot;</span> + ((ReentrantLock) lock).getHoldCount());</span><br><span class="line">            <span class="comment">// 在持有锁的情况下，调用 inner() 方法</span></span><br><span class="line">            inner();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;离开 outer() 方法, lock count: &quot;</span> + ((ReentrantLock) lock).getHoldCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内层方法，演示可重入特性，可以再次获取已被当前线程持有的锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 再次获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入 inner() 方法, lock count: &quot;</span> + ((ReentrantLock) lock).getHoldCount());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;离开 inner() 方法, lock count: &quot;</span> + ((ReentrantLock) lock).getHoldCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantLockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLockDemo</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 可重入锁演示 ---&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个新线程来执行 outer() 方法，展示可重入锁的工作原理</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::outer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- 可重入锁演示 ---</span><br><span class="line">进入 outer() 方法, lock count: <span class="number">1</span></span><br><span class="line">进入 inner() 方法, lock count: <span class="number">2</span></span><br><span class="line">离开 inner() 方法, lock count: <span class="number">1</span></span><br><span class="line">离开 outer() 方法, lock count: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-总结-3"><a href="#4-总结-3" class="headerlink" title="4. 总结"></a>4. 总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">可重入锁 (<code>ReentrantLock</code>, <code>synchronized</code>)</th>
<th align="left">不可重入锁 (我们自己实现的)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心机制</strong></td>
<td align="left">记录锁的持有者和重入次数</td>
<td align="left">仅用一个布尔标记锁是否被占用</td>
</tr>
<tr>
<td align="left"><strong>嵌套调用</strong></td>
<td align="left">安全。同一个线程可以多次获取锁。</td>
<td align="left"><strong>危险</strong>。同一个线程再次获取锁会导致死锁。</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">绝大多数并发场景。</td>
<td align="left">极少数特殊场景，或者作为教学示例来理解锁的原理。</td>
</tr>
<tr>
<td align="left"><strong>实现复杂度</strong></td>
<td align="left">较复杂，需要维护计数器和所有者。</td>
<td align="left">较简单，一个布尔值即可。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-5-自旋锁-Spin-Lock-vs-互斥锁-Mutex-Lock"><a href="#3-1-5-自旋锁-Spin-Lock-vs-互斥锁-Mutex-Lock" class="headerlink" title="3.1.5 自旋锁 (Spin Lock) vs. 互斥锁(Mutex Lock)"></a>3.1.5 自旋锁 (Spin Lock) vs. 互斥锁(Mutex Lock)</h4><h5 id="1-自旋锁"><a href="#1-自旋锁" class="headerlink" title="1. 自旋锁"></a>1. 自旋锁</h5><ul>
<li><strong>概念</strong>: 当一个线程尝试获取锁但失败时，它不会立即被挂起（进入阻塞状态），而是会执行一个<strong>忙循环（自旋）</strong>，不断地尝试获取锁。</li>
<li><strong>实现原理</strong>：通常基于硬件层面的 <strong>CAS</strong> 指令来实现。</li>
<li><strong>优点</strong>：<ul>
<li><strong>避免了上下文切换</strong>：线程一直处于用户态，不需要在用户态和内核态之间切换，也不需要操作系统进行调度。</li>
<li><strong>响应速度快</strong>：一旦锁被释放，等待的线程能立刻感知并获取锁。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>占用 CPU</strong>：如果锁被占用的时间很长，等待的线程会一直空耗 CPU 资源，导致 CPU 使用率飙升。</li>
<li><strong>竞争激烈时性能下降</strong>：如果线程很多，会有大量线程在空转。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>预计<strong>锁占用时间非常短</strong>的代码块。</li>
<li><strong>CPU 核心数足够</strong>（多核环境），能让等待线程和持有锁的线程并行执行。</li>
</ul>
</li>
<li><strong>Java中的应用</strong>:<ul>
<li><code>synchronized</code> 在 JDK 1.6 引入锁升级后，在<strong>轻量级锁</strong>阶段就采用了自旋策略。</li>
<li>J.U.C 包中的原子类 (<code>AtomicInteger</code> 等) 的 <code>getAndAdd</code> 等操作，底层就是基于 CAS 的自旋。</li>
<li><strong>自适应自旋</strong>: JDK 1.6 后引入的更智能的自旋，自旋的次数不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-互斥锁"><a href="#2-互斥锁" class="headerlink" title="2. 互斥锁"></a>2. 互斥锁</h5><ul>
<li><strong>概念</strong>：如果线程 A 持有锁，线程 B 想要获取锁。线程 B 发现锁被占用，会主动（或被动）让出 CPU，请求操作系统将自己<strong>挂起</strong>（放入等待队列）。等到线程 A 释放锁后，操作系统会<strong>唤醒</strong>线程 B。</li>
<li><strong>实现原理</strong>：依赖于操作系统的内核对象（如 Linux 的 <code>pthread_mutex</code>）。当获取锁失败时，线程会从<strong>用户态</strong>切换到<strong>内核态</strong>，将自己从“运行状态”变为“阻塞状态”，并在内核的等待队列中排队。</li>
<li><strong>优点</strong>：<ul>
<li><strong>节省 CPU</strong>：等待期间线程不占用 CPU 资源，CPU 可以去处理其他任务。</li>
<li><strong>适合长耗时任务</strong>：即使锁要被占用很久，也不会拖垮系统性能。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>上下文切换开销大</strong>：线程的挂起（Park）和唤醒（Unpark）涉及用户态到内核态的切换，这需要消耗大约几千个 CPU 时钟周期。如果同步块执行极快（比如就一行 <code>i++</code>），那么切换的开销可能比执行代码的开销还大。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>预计<strong>锁占用时间较长</strong>（如涉及 IO 操作、复杂计算）。</li>
<li><strong>单核处理器</strong>（单核上自旋没有意义，因为你占着 CPU 别人就没法释放锁）。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-Java中的混合使用"><a href="#3-Java中的混合使用" class="headerlink" title="3. Java中的混合使用"></a>3. Java中的混合使用</h5><p>在现代 JVM（JDK 1.6+）中，为了解决单一机制的缺点，引入了<strong>适应性自旋（Adaptive Spinning）</strong>，将两者结合起来：</p>
<p><strong>智能策略</strong>：</p>
<ol>
<li>当线程抢锁失败时，<strong>先尝试自旋</strong>一段时间（比如转10圈）。</li>
<li>如果在这期间抢到了锁，皆大欢喜（省去了挂起的开销）。</li>
<li>如果自旋了一会儿还是没抢到（说明锁竞争很激烈或持有时间长），<strong>立刻停止自旋，申请挂起</strong>（升级为互斥锁&#x2F;重量级锁），避免白白浪费 CPU。</li>
</ol>
<p><strong>“适应性”的含义</strong>：</p>
<p>JVM 会根据上一次在这个锁上的自旋情况来决定这次自旋多久。</p>
<ul>
<li>如果上次自旋成功了，这次就多转几圈（认为很有希望）。</li>
<li>如果上次自旋失败了，这次可能直接跳过自旋去睡觉（认为希望渺茫）。</li>
</ul>
<hr>
<h5 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h5><p><strong>自旋锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSpinLock</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有持有锁的线程才能将 owner 设置为自己，默认是 null</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// CAS 核心：如果不为空（被别人占了），就死循环（自旋）</span></span><br><span class="line">        <span class="comment">// expect: null, update: currentThread</span></span><br><span class="line">        <span class="keyword">while</span> (!owner.compareAndSet(<span class="literal">null</span>, currentThread)) &#123;</span><br><span class="line">            <span class="comment">// 这里的循环体就是“忙等待”</span></span><br><span class="line">            <span class="comment">// 在实际生产中，这里可能会加入 Thread.onSpinWait() 来优化 CPU 流水线</span></span><br><span class="line">            <span class="comment">// System.out.println(currentThread.getName() + &quot; 正在自旋等待...&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(currentThread.getName() + <span class="string">&quot; 拿到锁了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 只有持有锁的线程才能解锁</span></span><br><span class="line">        <span class="keyword">if</span> (owner.compareAndSet(currentThread, <span class="literal">null</span>)) &#123;</span><br><span class="line">            System.out.println(currentThread.getName() + <span class="string">&quot; 释放锁了。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>互斥锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMutexLock</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果被锁住了，就去睡觉（阻塞）</span></span><br><span class="line">        <span class="keyword">while</span> (isLocked) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(currentThread.getName() + <span class="string">&quot; 抢锁失败，准备挂起（Wait）...&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.wait(); <span class="comment">// 关键点：释放 CPU，进入等待队列</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 醒来后（或一开始没锁），标记为占用</span></span><br><span class="line">        isLocked = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(currentThread.getName() + <span class="string">&quot; 拿到锁了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        isLocked = <span class="literal">false</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁，并唤醒（Notify）其他人。&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.notify(); <span class="comment">// 关键点：唤醒一个在 wait 的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>main测试方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 切换这里测试不同的锁： new SimpleSpinLock() 或 new SimpleMutexLock()</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">SimpleSpinLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSpinLock</span>(); </span><br><span class="line">        <span class="comment">// final SimpleMutexLock lock = new SimpleMutexLock();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">// 模拟业务处理 1秒</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;线程B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-6-总结"><a href="#3-1-6-总结" class="headerlink" title="3.1.6 总结"></a>3.1.6 总结</h4><table>
<thead>
<tr>
<th align="left">分类维度</th>
<th align="left">类型A</th>
<th align="left">类型B</th>
<th align="left">核心区别</th>
<th align="left">Java中的例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>冲突态度</strong></td>
<td align="left">悲观锁</td>
<td align="left">乐观锁</td>
<td align="left">操作前加锁 vs 更新时检查</td>
<td align="left"><code>synchronized</code>, <code>ReentrantLock</code> vs <code>Atomic*</code>类(CAS)</td>
</tr>
<tr>
<td align="left"><strong>排队策略</strong></td>
<td align="left">公平锁</td>
<td align="left">非公平锁</td>
<td align="left">先来后到 vs 允许插队</td>
<td align="left"><code>ReentrantLock(true)</code> vs <code>synchronized</code>, <code>ReentrantLock()</code></td>
</tr>
<tr>
<td align="left"><strong>访问模式</strong></td>
<td align="left">独占锁</td>
<td align="left">共享锁</td>
<td align="left">单线程持有 vs 多线程持有</td>
<td align="left"><code>ReentrantLock</code> vs <code>ReentrantReadWriteLock</code></td>
</tr>
<tr>
<td align="left"><strong>重复获取</strong></td>
<td align="left">可重入锁</td>
<td align="left">不可重入锁</td>
<td align="left">同一线程可重复获取 vs 不可</td>
<td align="left"><code>synchronized</code>, <code>ReentrantLock</code> vs 自定义实现的锁</td>
</tr>
<tr>
<td align="left"><strong>等待策略</strong></td>
<td align="left">自旋锁</td>
<td align="left">互斥&#x2F;阻塞锁</td>
<td align="left">忙循环等待 vs 挂起等待</td>
<td align="left">CAS操作, 轻量级锁 vs 重量级锁</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-2-JUC-Lock接口与实现"><a href="#3-2-JUC-Lock接口与实现" class="headerlink" title="3.2 JUC-Lock接口与实现"></a>3.2 JUC-Lock接口与实现</h3><p><code>synchronized</code> 关键字是 Java 中最基础的内置锁，它简单易用，能够满足大部分并发场景。但它也存在一些局限性，例如：无法中断一个正在等待获取锁的线程、无法实现公平锁、无法绑定多个条件等。</p>
<p>为了解决这些问题，<code>java.util.concurrent.locks</code> 包（通常简称为 JUC Lock）提供了一套更为强大和灵活的锁机制。它的核心是 <code>Lock</code> 接口。</p>
<h4 id="3-2-1-Lock-接口核心-API"><a href="#3-2-1-Lock-接口核心-API" class="headerlink" title="3.2.1 Lock 接口核心 API"></a>3.2.1 Lock 接口核心 API</h4><p><code>Lock</code> 接口是 <code>synchronized</code> 的一种替代方案，它提供了对锁的更多控制。与 <code>synchronized</code> 自动释放锁不同，<code>Lock</code> <strong>必须手动释放</strong>。通常的使用范式是在 <code>try-finally</code> 块中进行，以确保锁一定会被释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... 临界区代码 ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 在 finally 块中释放锁，保证一定执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Lock</code> 接口的主要方法：</p>
<ul>
<li><strong><code>void lock()</code></strong>: 获取锁。如果锁已被其他线程持有，则当前线程将被阻塞，直到获取到锁。这是最常用的方法。</li>
<li><strong><code>void lockInterruptibly() throws InterruptedException</code></strong>: 可中断地获取锁。与 <code>lock()</code> 类似，但如果当前线程在等待锁的过程中被中断（<code>Thread.interrupt()</code>），它会抛出 <code>InterruptedException</code> 并停止等待。这为处理死锁等问题提供了可能性。</li>
<li><strong><code>boolean tryLock()</code></strong>: 尝试非阻塞地获取锁。该方法会立即返回，如果获取成功，返回 <code>true</code>；如果锁已被其他线程持有，立即返回 <code>false</code>，当前线程不会被阻塞。</li>
<li><strong><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code></strong>: 带超时的尝试获取锁。在指定的时间内尝试获取锁，如果在超时前获取成功，返回 <code>true</code>；如果在超时前锁仍未被释放或等待过程中被中断，返回 <code>false</code>。</li>
<li><strong><code>void unlock()</code></strong>: 释放锁。</li>
<li><strong><code>Condition newCondition()</code></strong>: 创建一个新的 <code>Condition</code> 对象，它与当前 <code>Lock</code> 实例绑定。<code>Condition</code> 提供了比 <code>Object</code> 的 <code>wait()</code>&#x2F;<code>notify()</code>&#x2F;<code>notifyAll()</code> 更强大、更灵活的线程协作机制。</li>
</ul>
<hr>
<h4 id="3-2-2-ReentrantLock-重入锁"><a href="#3-2-2-ReentrantLock-重入锁" class="headerlink" title="3.2.2 ReentrantLock (重入锁)"></a>3.2.2 ReentrantLock (重入锁)</h4><p><code>ReentrantLock</code> 是 <code>Lock</code> 接口最常见和最主要的实现。正如其名，它是一个<strong>可重入</strong>的互斥锁，功能上与 <code>synchronized</code> 非常相似，但提供了更多高级特性。</p>
<p><strong>核心特性：</strong></p>
<ol>
<li><p><strong>可重入性 (Reentrancy)</strong></p>
<ul>
<li>与 <code>synchronized</code> 一样，一个已经持有锁的线程可以再次成功获取该锁而不会被阻塞。</li>
<li>内部维护了一个计数器，每次加锁，计数器加一；每次解锁，计数器减一。当计数器为 0 时，锁才被真正释放。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... do something ...</span></span><br><span class="line">        innerMethod();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 同一线程再次获取锁，成功</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... do something else ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>公平性 (Fairness)</strong></p>
<ul>
<li><code>ReentrantLock</code> 允许我们选择锁的公平策略。</li>
<li><strong>公平锁 (Fair Lock)</strong>：线程获取锁的顺序按照它们发出请求的顺序。就像排队买票，先到先得。</li>
<li><strong>非公平锁 (Non-fair Lock)</strong>：允许“插队”。新来的线程可能比已经在等待队列中的线程先获取到锁。这是 <strong>默认</strong> 策略。</li>
<li><strong>构造函数</strong>: <code>new ReentrantLock()</code> (默认非公平), <code>new ReentrantLock(true)</code> (公平)。</li>
<li><strong>为什么默认非公平？</strong> 因为非公平锁的性能（吞吐量）通常优于公平锁。减少了线程挂起和唤醒的开销，系统总的吞吐量更高。但可能导致某些线程长时间无法获取锁（饥饿）。</li>
</ul>
</li>
<li><p><strong>条件变量 (Condition)</strong></p>
<ul>
<li><code>ReentrantLock</code> 可以通过 <code>newCondition()</code> 方法创建多个 <code>Condition</code> 对象。</li>
<li>每个 <code>Condition</code> 对象都拥有一套自己的等待&#x2F;通知机制 (<code>await()</code> &#x2F; <code>signal()</code> &#x2F; <code>signalAll()</code>)，可以实现对不同条件的线程进行分组和精确唤醒。</li>
<li>相比之下，<code>synchronized</code> 只有一个与之关联的条件队列，<code>notify()</code> 唤醒哪个线程是不确定的，<code>notifyAll()</code> 则会唤醒所有等待的线程，效率较低。</li>
</ul>
</li>
</ol>
<p><strong><code>ReentrantLock</code> 与 <code>synchronized</code> 对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>synchronized</code></th>
<th><code>ReentrantLock</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现层面</strong></td>
<td>Java 关键字，由 JVM 实现</td>
<td>JUC 包中的一个类，基于 AQS (AbstractQueuedSynchronizer) 实现</td>
</tr>
<tr>
<td><strong>锁的释放</strong></td>
<td>自动释放（代码块结束或异常）</td>
<td><strong>必须手动释放</strong>（通常在 <code>finally</code> 块中调用 <code>unlock()</code>）</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>简单，功能固定</td>
<td>功能丰富，可中断、可超时、可选择公平性</td>
</tr>
<tr>
<td><strong>公平性</strong></td>
<td>非公平锁</td>
<td>可选择公平或非公平（默认非公平）</td>
</tr>
<tr>
<td><strong>线程协作</strong></td>
<td><code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code></td>
<td><code>Condition</code> 接口 (<code>await()</code>, <code>signal()</code>, <code>signalAll()</code>), 可绑定多个 <code>Condition</code></td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>Java 1.6 后优化显著，与 <code>ReentrantLock</code> 性能相当</td>
<td>在高竞争下通常有更好的性能表现，但具体取决于场景</td>
</tr>
<tr>
<td><strong>使用建议</strong></td>
<td>竞争不激烈，功能简单时首选，代码更简洁。</td>
<td>需要高级功能（如公平性、可中断、超时</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-2-3-ReentrantReadWriteLock-读写锁"><a href="#3-2-3-ReentrantReadWriteLock-读写锁" class="headerlink" title="3.2.3 ReentrantReadWriteLock (读写锁)"></a>3.2.3 ReentrantReadWriteLock (读写锁)</h4><p>在很多业务场景中，读操作的频率远高于写操作，例如缓存、配置中心等。如果对这类资源使用 <code>ReentrantLock</code>，即使是多个读操作也必须互斥，这会极大地降低并发性能。</p>
<p><code>ReentrantReadWriteLock</code> 就是为了解决这个问题而设计的。它内部维护了两个锁：一个<strong>读锁</strong>和一个<strong>写锁</strong>。</p>
<p><strong>核心规则：</strong></p>
<ol>
<li><strong>读锁 (Read Lock)</strong>：是<strong>共享锁</strong>。多个线程可以同时持有读锁，只要没有线程持有写锁。</li>
<li><strong>写锁 (Write Lock)</strong>：是<strong>独占锁&#x2F;排他锁</strong>。当一个线程持有写锁时，其他任何线程（无论是读还是写）都必须等待。</li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li><strong>读读共享</strong>：多个线程可以同时读取资源。</li>
<li><strong>读写互斥</strong>：读操作和写操作不能同时进行。</li>
<li><strong>写写互斥</strong>：写操作和写操作不能同时进行。</li>
<li><strong>锁降级</strong>：允许一个持有写锁的线程，在不释放写锁的情况下，继续获取读锁。反之（从读锁升级到写锁）则不允许。</li>
</ul>
<p><strong>使用场景示例（缓存实现）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock <span class="type">read</span> <span class="variable">Lock</span> <span class="operator">=</span> rwl.readLock(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                <span class="comment">// 必须释放读锁，否则写锁无法获取（锁升级不允许）</span></span><br><span class="line">                readLock.unlock();</span><br><span class="line">                writeLock.lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 再次检查，防止其他线程已更新</span></span><br><span class="line">                    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                        data = <span class="string">&quot;Some data from database&quot;</span>; <span class="comment">// 模拟从DB获取数据</span></span><br><span class="line">                        cacheValid = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 在释放写锁前，获取读锁（锁降级）</span></span><br><span class="line">                    <span class="comment">// 保证数据一致性，防止其他写线程修改</span></span><br><span class="line">                    readLock.lock(); </span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    writeLock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此处已持有读锁</span></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-4-StampedLock-Java-8"><a href="#3-2-4-StampedLock-Java-8" class="headerlink" title="3.2.4 StampedLock (Java 8+)"></a>3.2.4 StampedLock (Java 8+)</h4><p><code>StampedLock</code> 是 Java 8 引入的一种新的锁机制，可以看作是 <code>ReentrantReadWriteLock</code> 的性能增强版。它支持三种模式：<strong>写锁、悲观读锁、乐观读</strong>。</p>
<ul>
<li><strong>写锁 (Writing)</strong>：与 <code>ReentrantReadWriteLock</code> 的写锁类似，是独占的。<code>writeLock()</code> 返回一个“戳”（stamp），用于 <code>unlockWrite()</code>。</li>
<li><strong>悲观读锁 (Pessimistic Reading)</strong>：与 <code>ReentrantReadWriteLock</code> 的读锁类似，是共享的，会阻塞写。<code>readLock()</code> 返回一个“戳”，用于 <code>unlockRead()</code>。</li>
<li><strong>乐观读 (Optimistic Reading)</strong>：<ul>
<li>这是 <code>StampedLock</code> 的核心优化。它假设读操作期间很少有写操作发生。</li>
<li><code>tryOptimisticRead()</code> 方法会返回一个非 0 的“戳”，然后线程可以去读取共享变量。</li>
<li>读取后，通过 <code>validate(stamp)</code> 方法校验之前获取的“戳”是否仍然有效。</li>
<li>如果有效，说明期间没有写操作发生，读取成功，避免了加锁的开销。</li>
<li>如果无效，说明有写操作修改了数据，此时需要升级为悲观读锁，重新读取数据。</li>
</ul>
</li>
</ul>
<p><strong>注意点：</strong></p>
<ul>
<li><code>StampedLock</code> <strong>不可重入</strong>。如果一个线程已经持有了写锁，再尝试获取写锁会导致死锁。</li>
<li>所有获取锁的方法都会返回一个 long 类型的 stamp，解锁时需要传入这个 stamp。</li>
<li>使用起来比 <code>ReentrantReadWriteLock</code> 更复杂，适用于读多写少的极致性能优化场景。</li>
</ul>
<hr>
<h3 id="3-3-JUC-并发编程的原子基石：CAS-与-AQS"><a href="#3-3-JUC-并发编程的原子基石：CAS-与-AQS" class="headerlink" title="3.3 JUC - 并发编程的原子基石：CAS 与 AQS"></a>3.3 JUC - 并发编程的原子基石：CAS 与 AQS</h3><p>如果说 <code>Lock</code> 接口定义了锁的行为，那么 <code>CAS</code> 和 <code>AQS</code> 就是构建这些高级锁（如 <code>ReentrantLock</code>, <code>ReentrantReadWriteLock</code> 等）的底层核心技术。它们是整个 JUC 框架的基石。</p>
<h4 id="3-3-1-CAS-CompareAndSwap-比较并交换"><a href="#3-3-1-CAS-CompareAndSwap-比较并交换" class="headerlink" title="3.3.1 CAS (CompareAndSwap) - 比较并交换"></a>3.3.1 CAS (CompareAndSwap) - 比较并交换</h4><p>CAS 是一条 CPU 的<strong>原子指令</strong>，是并发编程中<strong>无锁（Lock-Free）机制的基石。它体现了一种乐观锁</strong>的思想：假设没有冲突，直接尝试修改；如果冲突，则重试或放弃，通常都是硬件提供。</p>
<h5 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p>CAS 操作包含三个操作数：</p>
<ol>
<li><strong>V (Memory Value)</strong>：内存中的实际值。</li>
<li><strong>A (Expected Value)</strong>：预期值。</li>
<li><strong>B (New Value)</strong>：要更新的新值。</li>
</ol>
<pre><code class="highlight mermaid">flowchart TD
    A[线程尝试修改 V] --&gt; B&#123;比较 V 和 A?&#125;
    B --&gt;|YES 相等| C[把 V 更新为 B]
    B --&gt;|NO 不等| D[不做修改]
    C --&gt; E[返回 true]
    D --&gt; F[返回 false]</code></pre>

<hr>
<h5 id="2-Java-中的底层实现"><a href="#2-Java-中的底层实现" class="headerlink" title="2. Java 中的底层实现"></a>2. Java 中的底层实现</h5><p>Java 语言本身无法直接访问硬件，它是通过 <code>JNI (Java Native Interface)</code> 调用 C++ 代码实现的。</p>
<ul>
<li><strong>关键类</strong>：<code>sun.misc.Unsafe</code><br>JUC 包下的原子类（如 <code>AtomicInteger</code>）底层都依赖这个类。它提供了直接操作内存的能力。</li>
<li><strong>关键方法</strong>：<ul>
<li><code>compareAndSwapInt(...)</code></li>
<li><code>compareAndSwapLong(...)</code></li>
<li><em>(注：JDK 9 之后引入了 <code>VarHandle</code> 来逐渐替代 Unsafe)</em></li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-经典范式：CAS-自旋"><a href="#3-经典范式：CAS-自旋" class="headerlink" title="3. 经典范式：CAS+自旋"></a>3. 经典范式：CAS+自旋</h5><p>单纯的 CAS 只能尝试一次，失败就结束了。为了实现“直到成功为止”的效果，通常配合**自旋（Spin）**使用。</p>
<p><strong>伪代码演示 (AtomicInteger 源码逻辑)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋循环 (Do-While 结构)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前内存中的最新值 (预期值 A)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="built_in">this</span>.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 计算目标值 (新值 B)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. CAS 原子性尝试</span></span><br><span class="line">        <span class="comment">// 如果内存里的值还是 current，就把它改成 next，返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> next; <span class="comment">// 成功则返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 失败则继续循环 (自旋)，重新获取 current 再试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-CAS-的三大缺陷与解决方案"><a href="#4-CAS-的三大缺陷与解决方案" class="headerlink" title="4. CAS 的三大缺陷与解决方案"></a>4. CAS 的三大缺陷与解决方案</h5><table>
<thead>
<tr>
<th align="left">缺陷</th>
<th align="left">描述</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. ABA 问题</strong></td>
<td align="left"><strong>现象</strong>：值从 A 变为 B，又变回 A。CAS 检查时发现值没变，误认为没发生过修改。<br><strong>隐患</strong>：在堆栈操作或链表节点复用中，可能导致逻辑崩溃。</td>
<td align="left"><strong>加版本号 (Version)</strong><br>使用 <code>AtomicStampedReference</code>。<br>比较时不仅检查引用是否相等，还要检查<strong>版本戳 (Stamp)</strong> 是否一致。<br>操作：<code>1A -&gt; 2B -&gt; 3A</code></td>
</tr>
<tr>
<td align="left"><strong>2. 自旋开销大</strong></td>
<td align="left"><strong>现象</strong>：在高并发写场景下，大量线程 CAS 失败并不断自旋，导致 <strong>CPU 使用率飙升</strong>。</td>
<td align="left"><strong>1. 分散热点 (LongAdder)</strong><br>JDK 8 引入 <code>LongAdder</code>，将一个变量分解为多个单元（Cell 数组），线程只竞争自己 Cell 里的值，最后求和。大幅减少冲突。<br><strong>2. 适应性自旋</strong><br>JVM 智能调整自旋次数，甚至挂起线程。</td>
</tr>
<tr>
<td align="left"><strong>3. 只能保证单个变量</strong></td>
<td align="left"><strong>现象</strong>：CAS 原生只能保证一个内存地址的原子性，无法同时锁住 <code>x</code> 和 <code>y</code> 两个变量。</td>
<td align="left"><strong>封装对象</strong><br>将多个变量封装成一个对象（如 <code>User {age, name}</code>），利用 <code>AtomicReference</code> 来保证引用的原子性更新。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-3-2-AQS-AbstractQueuedSynchronizer-抽象队列同步器"><a href="#3-3-2-AQS-AbstractQueuedSynchronizer-抽象队列同步器" class="headerlink" title="3.3.2 AQS (AbstractQueuedSynchronizer) - 抽象队列同步器"></a>3.3.2 AQS (AbstractQueuedSynchronizer) - 抽象队列同步器</h4><h5 id="1-核心定位"><a href="#1-核心定位" class="headerlink" title="1. 核心定位"></a>1. 核心定位</h5><p>AQS 是一个用来构建锁和同步器的<strong>顶层抽象框架</strong>。JUC 包中几乎所有的锁和同步工具（<code>ReentrantLock</code>, <code>Semaphore</code>, <code>CountDownLatch</code>, <code>CyclicBarrier</code> 等）核心逻辑都依赖于它。</p>
<ul>
<li><strong>核心思想</strong>：如果资源空闲，则抢占；如果资源被占用，则<strong>排队</strong>（阻塞等待）。</li>
<li><strong>设计模式</strong>：<strong>模板方法模式 (Template Method)</strong>。AQS 解决了“排队、阻塞、唤醒”等繁琐的底层机制，子类只需实现“如何尝试抓取&#x2F;释放资源”的逻辑。</li>
</ul>
<hr>
<h5 id="2-AQS-的三大核心组件"><a href="#2-AQS-的三大核心组件" class="headerlink" title="2. AQS 的三大核心组件"></a>2. AQS 的三大核心组件</h5><p>AQS 的内部架构可以概括为：<strong>状态 (State) + 队列 (CLH Queue) + 线程阻塞 (LockSupport)</strong>。</p>
<ol>
<li><h5 id="资源状态：state"><a href="#资源状态：state" class="headerlink" title="资源状态：state"></a>资源状态：<code>state</code></h5><ul>
<li><strong>定义</strong>：<code>private volatile int state;</code></li>
<li><strong>作用</strong>：标记资源的可用状态。</li>
<li><strong>操作</strong>：通过 <code>getState()</code>, <code>setState()</code>, <code>compareAndSetState()</code> (CAS) 进行原子操作。</li>
<li><strong>多态含义</strong>：<ul>
<li><code>ReentrantLock</code>: 0&#x3D;无锁, 1&#x3D;持有, &gt;1&#x3D;重入次数。</li>
<li><code>CountDownLatch</code>: 初始值 N, 每次 countDown 减 1, 0&#x3D;任务完成。</li>
<li><code>Semaphore</code>: 剩余许可证数量。</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="等待队列：CLH-变体"><a href="#等待队列：CLH-变体" class="headerlink" title="等待队列：CLH 变体"></a>等待队列：CLH 变体</h5><p>AQS 维护了一个<strong>双向链表</strong>（FIFO队列）。未能获取资源的线程会被封装成 <code>Node</code> 节点加入队尾。</p>
<p><strong>队列结构图解</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      +------+  prev  +-----+  prev  +-----+</span><br><span class="line">Head  | Node | &lt;----  | Node| &lt;----  | Node|  Tail</span><br><span class="line">      | (空) |  ----&gt; | T1  | ----&gt;  | T2  |</span><br><span class="line">      +------+  next  +-----+  next  +-----+</span><br><span class="line">     (当前持有锁)      (等待中)       (等待中)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Head 节点</strong>：通常是一个虚拟节点（Dummy Node）或代表当前持有锁的线程。</li>
<li><strong>Node 节点</strong>：封装了 <strong>线程引用</strong> + <strong>等待状态 (waitStatus)</strong> + <strong>前驱&#x2F;后继指针</strong>。</li>
</ul>
</li>
<li><h5 id="节点状态：waitStatus-关键细节"><a href="#节点状态：waitStatus-关键细节" class="headerlink" title="节点状态：waitStatus (关键细节)"></a>节点状态：<code>waitStatus</code> (关键细节)</h5><p><code>Node</code> 类中有一个 <code>int waitStatus</code> 字段，用于表示当前线程的状态，决定了它能否被唤醒：</p>
<ul>
<li><strong>0 (INITIAL)</strong>: 初始状态。</li>
<li><strong>-1 (SIGNAL)</strong>: <strong>非常重要</strong>。表示“我后面的兄弟睡着了，我释放锁后必须叫醒他”。</li>
<li><strong>1 (CANCELLED)</strong>: 线程因为超时或中断被取消，不再参与竞争。</li>
<li><strong>-2 (CONDITION)</strong>: 线程在 Condition 等待队列中（用于 <code>await</code>&#x2F;<code>signal</code>）。</li>
<li><strong>-3 (PROPAGATE)</strong>: 共享模式下，前驱节点唤醒后，需要向后传播唤醒动作。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-两种资源共享模式"><a href="#3-两种资源共享模式" class="headerlink" title="3. 两种资源共享模式"></a>3. 两种资源共享模式</h5><table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
<th align="left">典型实现</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>独占模式 (Exclusive)</strong></td>
<td align="left">资源一次只能被一个线程持有。</td>
<td align="left"><code>ReentrantLock</code></td>
</tr>
<tr>
<td align="left"><strong>共享模式 (Shared)</strong></td>
<td align="left">资源可以被多个线程同时持有。</td>
<td align="left"><code>Semaphore</code>, <code>CountDownLatch</code>, <code>ReadWriteLock(读锁)</code></td>
</tr>
</tbody></table>
<hr>
<h5 id="4-AQS-的模板方法模式"><a href="#4-AQS-的模板方法模式" class="headerlink" title="4. AQS 的模板方法模式"></a>4. AQS 的模板方法模式</h5><p>AQS 定义了顶层逻辑（如 <code>acquire()</code>, <code>release()</code>），这些方法是 <code>final</code> 的，不可修改。子类只需要重写以下 <strong>“钩子 (Hook)”</strong> 方法：</p>
<ul>
<li><strong>独占式</strong>：<ul>
<li><code>tryAcquire(int arg)</code>: 尝试获取锁（成功返回 true）。</li>
<li><code>tryRelease(int arg)</code>: 尝试释放锁。</li>
</ul>
</li>
<li><strong>共享式</strong>：<ul>
<li><code>tryAcquireShared(int arg)</code>: 尝试获取共享资源（返回剩余量，&lt;0失败）。</li>
<li><code>tryReleaseShared(int arg)</code>: 尝试释放共享资源。</li>
</ul>
</li>
<li><strong>其他</strong>：<ul>
<li><code>isHeldExclusively()</code>: 判断当前线程是否独占资源。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="5-源码分析：ReentrantLock-lock-的工作流程"><a href="#5-源码分析：ReentrantLock-lock-的工作流程" class="headerlink" title="5. 源码分析：ReentrantLock.lock() 的工作流程"></a>5. 源码分析：<code>ReentrantLock.lock()</code> 的工作流程</h5><p>以 <strong>非公平锁 (NonfairSync)</strong> 为例，流程如下：</p>
<p><strong>Step 1: 刚进门先抢一把 (CAS)</strong></p>
<p>调用 <code>lock()</code> 后，不管队列里有没有人，先执行一次 CAS 尝试把 <code>state</code> 从 0 改成 1。</p>
<ul>
<li><strong>成功</strong>：运气好，直接拿锁走人（这就是“非公平”的体现）。</li>
<li><strong>失败</strong>：进入标准的 AQS 流程 <code>acquire(1)</code>。</li>
</ul>
<p><strong>Step 2: 再次尝试 (tryAcquire)</strong></p>
<p>进入 <code>tryAcquire</code> 逻辑：</p>
<ol>
<li><strong>State &#x3D;&#x3D; 0</strong>? 再 CAS 抢一次（也许刚才持有锁的人正好释放了）。</li>
<li><strong>是自己持有的</strong>? <code>state + 1</code>（锁重入）。</li>
<li><strong>失败</strong>：返回 false，准备排队。</li>
</ol>
<p><strong>Step 3: 入队 (addWaiter)</strong></p>
<p>将当前线程封装成 <code>Node</code>，通过 CAS 也就是“自旋”的方式，安全地拼接到队列的<strong>尾部 (Tail)</strong>。</p>
<p><strong>Step 4: 阻塞与自旋 (acquireQueued)</strong></p>
<p>这是一个死循环（自旋）：</p>
<ol>
<li><strong>检查前驱</strong>：如果是 Head 的后继节点（排第二），再试着抢一次锁（也许 Head 刚释放）。</li>
<li><strong>阻塞</strong>：如果抢不到，或者前驱不是 Head，就检查前驱的 <code>waitStatus</code>。如果是 <code>SIGNAL</code>，调用 <code>LockSupport.park()</code> <strong>挂起当前线程</strong>（进入内核态等待，不再耗 CPU）。</li>
</ol>
<p><strong>Step 5: 释放与唤醒</strong></p>
<p>当持有锁的线程 <code>unlock()</code> -&gt; <code>release()</code> -&gt; <code>tryRelease()</code>：</p>
<ol>
<li><code>state</code> 减 1。如果减到 0，表示锁彻底释放。</li>
<li>找到 Head 节点的下一个有效节点（非 Cancelled），调用 <code>LockSupport.unpark(nextThread)</code> <strong>唤醒它</strong>。</li>
<li>被唤醒的线程在 Step 4 的循环中醒来，继续抢锁。</li>
</ol>
<hr>
<h2 id="4-JUC-核心工具类"><a href="#4-JUC-核心工具类" class="headerlink" title="4. JUC 核心工具类"></a>4. JUC 核心工具类</h2><h3 id="4-1-原子操作类"><a href="#4-1-原子操作类" class="headerlink" title="4.1 原子操作类"></a>4.1 原子操作类</h3><h4 id="4-1-1-概述与原理"><a href="#4-1-1-概述与原理" class="headerlink" title="4.1.1 概述与原理"></a>4.1.1 概述与原理</h4><p>在多线程环境下，对共享变量进行 <code>i++</code> 这样的操作并不是原子的，它包含了“读取-修改-写入”三个步骤，任何一步都可能被其他线程打断，导致数据不一致。虽然 <code>synchronized</code> 和 <code>Lock</code> 可以解决这个问题，但它们属于悲观锁，在高并发场景下可能引起线程阻塞和上下文切换，开销较大。</p>
<p><code>java.util.concurrent.atomic</code> (J.U.C.atomic) 包提供了一系列原子操作类，它们是基于前一节提到的 <strong>CAS (Compare-And-Swap)</strong> 机制实现的。这些类提供了一种性能更高、开销更小的“无锁”（Lock-Free）方式来保证对单个变量操作的原子性。</p>
<p><strong>核心原理：</strong></p>
<p>原子操作类内部通常组合使用了 <code>volatile</code> 关键字和 <code>CAS</code> 操作。</p>
<ul>
<li><code>volatile</code>：保证了多线程之间变量的<strong>可见性</strong>，即一个线程修改了变量的值，其他线程能立刻看到。</li>
<li><code>CAS</code>：保证了“比较并更新”这个操作的<strong>原子性</strong>。</li>
</ul>
<p>通过“CAS + 自旋”的方式，原子类实现了非阻塞的线程安全。</p>
<p><strong>核心 API (以 <code>AtomicInteger</code> 为例):</strong></p>
<ul>
<li><code>get()</code>: 获取当前值。</li>
<li><code>set(int newValue)</code>: 设置新值。</li>
<li><code>getAndSet(int newValue)</code>: 设置新值并返回旧值。</li>
<li><code>compareAndSet(int expect, int update)</code>: CAS 核心方法。如果当前值等于 <code>expect</code>，则原子性地更新为 <code>update</code>，并返回 <code>true</code>；否则返回 <code>false</code>。</li>
<li><code>getAndIncrement()</code>: 原子性地将当前值加 1，并返回旧值 (类似 <code>i++</code>)。</li>
<li><code>incrementAndGet()</code>: 原子性地将当前值加 1，并返回新值 (类似 <code>++i</code>)。</li>
<li><code>getAndDecrement()</code> &#x2F; <code>decrementAndGet()</code>: 类似的减 1 操作。</li>
<li><code>getAndAdd(int delta)</code> &#x2F; <code>addAndGet(int delta)</code>: 原子性地增加一个指定的值。</li>
</ul>
<hr>
<h4 id="4-1-2-原子类的分类"><a href="#4-1-2-原子类的分类" class="headerlink" title="4.1.2 原子类的分类"></a>4.1.2 原子类的分类</h4><h5 id="1-基本类型原子类"><a href="#1-基本类型原子类" class="headerlink" title="1. 基本类型原子类"></a>1. 基本类型原子类</h5><p>这是最常用的一类，用于对基本数据类型进行原子操作。</p>
<ul>
<li><code>AtomicInteger</code>: 原子更新整型。</li>
<li><code>AtomicLong</code>: 原子更新长整型。</li>
<li><code>AtomicBoolean</code>: 原子更新布尔值。</li>
</ul>
<p><strong>使用示例（线程安全的计数器）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 AtomicInteger 代替 int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet(); <span class="comment">// 原子操作，线程安全</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果总是 20000，不会出现线程安全问题</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + counter.getCount()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-引用类型原子类"><a href="#2-引用类型原子类" class="headerlink" title="2. 引用类型原子类"></a>2. 引用类型原子类</h5><p>用于对对象的引用进行原子操作。</p>
<ul>
<li><code>AtomicReference&lt;V&gt;</code>: 原子更新引用类型。</li>
<li><code>AtomicStampedReference&lt;V&gt;</code>: 解决 <strong>CAS 的 ABA 问题</strong>。它在内部维护了一个“版本号”（stamp），更新时不仅要比较值，还要比较版本号。只有两者都相同时才能更新成功。</li>
<li><code>AtomicMarkableReference&lt;V&gt;</code>: 与 <code>AtomicStampedReference</code> 类似，但版本号是一个布尔值（mark），用于表示数据是否被修改过。更轻量，适用于只关心“变过&#x2F;没变过”的场景。</li>
</ul>
<hr>
<h5 id="3-数组类型原子类"><a href="#3-数组类型原子类" class="headerlink" title="3. 数组类型原子类"></a>3. 数组类型原子类</h5><p>对数组中的某个元素进行原子操作。</p>
<ul>
<li><code>AtomicIntegerArray</code>: 原子更新整型数组里的元素。</li>
<li><code>AtomicLongArray</code>: 原子更新长整型数组里的元素。</li>
<li><code>AtomicReferenceArray&lt;E&gt;</code>: 原子更新引用类型数组里的元素。</li>
</ul>
<p><strong>注意</strong>：这些类保证的是对数组中<strong>单个元素</strong>的操作是原子的，而不是对整个数组的操作是原子的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">AtomicIntegerArray</span> <span class="variable">atomicArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(values);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子地将索引为 0 的元素加 10</span></span><br><span class="line">atomicArray.getAndAdd(<span class="number">0</span>, <span class="number">10</span>); </span><br><span class="line"><span class="comment">// 原子地将索引为 1 的元素与期望值 2 比较，如果相等则更新为 20</span></span><br><span class="line">atomicArray.compareAndSet(<span class="number">1</span>, <span class="number">2</span>, <span class="number">20</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(atomicArray); <span class="comment">// 输出 [11, 20, 3]</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-字段更新器"><a href="#4-字段更新器" class="headerlink" title="4. 字段更新器"></a>4. 字段更新器</h5><p>以一种更轻量、基于反射的方式，对一个对象的<strong>某个 <code>volatile</code> 字段</strong>进行原子操作。当你不想为了一个字段就引入一个完整的原子类包装时，或者操作的类不能被修改时，这是一个很好的选择。</p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>: 原子更新对象的 <code>volatile int</code> 字段。</li>
<li><code>AtomicLongFieldUpdater</code>: 原子更新对象的 <code>volatile long</code> 字段。</li>
<li><code>AtomicReferenceFieldUpdater</code>: 原子更新对象的 <code>volatile</code> 引用字段。</li>
</ul>
<p><strong>使用要求：</strong></p>
<ol>
<li>字段必须是 <code>volatile</code> 类型。</li>
<li>字段的访问修饰符不能是 <code>private</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 字段必须是 volatile</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldUpdaterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        </span><br><span class="line">        AtomicIntegerFieldUpdater&lt;User&gt; updater = </span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 使用 updater 对 user 对象的 age 字段进行原子操作</span></span><br><span class="line">        updater.compareAndSet(user, <span class="number">0</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;User age: &quot;</span> + user.age); <span class="comment">// 输出 18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-累加器-Adder-Accumulator-Java-8"><a href="#5-累加器-Adder-Accumulator-Java-8" class="headerlink" title="5. 累加器 (Adder&#x2F;Accumulator - Java 8+)"></a>5. 累加器 (Adder&#x2F;Accumulator - Java 8+)</h5><p><code>AtomicLong</code> 在高并发下的竞争非常激烈，因为所有线程都在对同一个变量进行 CAS 操作，失败的线程会不断自旋，消耗 CPU。为了解决这个问题，Java 8 引入了 <code>LongAdder</code> 和 <code>DoubleAdder</code>。</p>
<ul>
<li><code>LongAdder</code> &#x2F; <code>DoubleAdder</code>: 高性能的原子累加器。</li>
<li><code>LongAccumulator</code> &#x2F; <code>DoubleAccumulator</code>: <code>LongAdder</code> 的更通用版本，可以自定义累加规则。</li>
</ul>
<p><strong><code>LongAdder</code> 的核心思想（分段锁&#x2F;分散热点）：</strong></p>
<p><code>LongAdder</code> 内部维护了一个 <code>base</code> 变量和一个 <code>Cell[]</code> 数组。</p>
<ul>
<li><strong>低并发</strong>：当没有竞争时，数据会直接累加到 <code>base</code> 上，与 <code>AtomicLong</code> 类似。</li>
<li><strong>高并发</strong>：当对 <code>base</code> 的 CAS 更新失败时，线程会尝试在 <code>Cell</code> 数组的一个槽（Cell）中进行累加。每个线程通过哈希等算法映射到自己的槽位，从而将对单个变量的竞争<strong>分散</strong>到多个变量上。</li>
<li><strong>获取总和</strong>：调用 <code>sum()</code> 方法时，会把 <code>base</code> 的值和所有 <code>Cell</code> 数组中的值相加，返回最终结果。</li>
</ul>
<p><strong><code>AtomicLong</code> vs <code>LongAdder</code></strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>AtomicLong</code></th>
<th><code>LongAdder</code> (Java 8+)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现原理</strong></td>
<td>对单个 <code>value</code> 变量进行 CAS 操作</td>
<td>“分段锁”思想，<code>base</code> + <code>Cell[]</code> 数组，分散竞争压力</td>
</tr>
<tr>
<td><strong>高并发写性能</strong></td>
<td>性能较差，因为所有线程竞争同一个变量</td>
<td><strong>性能极高</strong>，因为竞争被分散到多个 <code>Cell</code> 中</td>
</tr>
<tr>
<td><strong>读性能</strong></td>
<td>性能高，直接返回 <code>value</code></td>
<td>性能稍低，需要累加 <code>base</code> 和所有 <code>Cell</code></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>读多写少，或并发度不高。需要完整的 CAS 功能。</td>
<td><strong>写多读少</strong>的高并发场景，如监控统计、计数器等。</td>
</tr>
<tr>
<td><strong>一致性</strong></td>
<td>强一致性</td>
<td>调用 <code>sum()</code> 时是<strong>最终一致性</strong>，可能不是最新的精确值。</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>功能全面，支持 <code>compareAndSet</code> 等丰富的原子操作。</td>
<td>功能单一，主要用于 <code>add()</code> 和 <code>sum()</code>，没有 <code>compareAndSet</code>。</td>
</tr>
</tbody></table>
<p>在 JDK 8+ 的环境下，如果你的需求仅仅是高并发下的<strong>累加计数</strong>，优先选择 <code>LongAdder</code> 而不是 <code>AtomicLong</code>。</p>
<hr>
<h3 id="4-2-并发容器"><a href="#4-2-并发容器" class="headerlink" title="4.2 并发容器"></a>4.2 并发容器</h3><p>并发容器还记得不，在第四章集合中介绍过一部分了这里再简单提一下</p>
<p>标准的集合类如 <code>ArrayList</code>、<code>HashMap</code> 等都不是线程安全的。如果在多线程环境下对它们进行读写操作，可能会导致数据不一致、<code>ConcurrentModificationException</code> 等问题。</p>
<p>虽然可以通过 <code>Collections.synchronizedMap()</code>、<code>Collections.synchronizedList()</code> 等工具类将它们包装成线程安全的版本，但这种方式的性能较差。因为它仅仅是在每个方法上加了一把全局锁（<code>synchronized</code>），相当于一个时刻只允许一个线程访问该容器，大大降低了并发性。</p>
<p>JUC 包提供了一系列高性能的并发容器，它们通过更精细的锁机制（如分段锁、CAS）或特殊的数据结构来提升并发性能。</p>
<hr>
<h4 id="4-2-1-ConcurrentHashMap"><a href="#4-2-1-ConcurrentHashMap" class="headerlink" title="4.2.1 ConcurrentHashMap"></a>4.2.1 ConcurrentHashMap</h4><p><code>ConcurrentHashMap</code> 是线程安全的 <code>HashMap</code>，也是 JUC 中最重要、最常用的并发容器之一。它通过巧妙的设计，在保证线程安全的同时，提供了极高的并发性能。</p>
<h5 id="1-核心思想演进"><a href="#1-核心思想演进" class="headerlink" title="1 核心思想演进"></a>1 核心思想演进</h5><ul>
<li><strong>JDK 1.7 - 分段锁 (Segment)</strong><ul>
<li><code>ConcurrentHashMap</code> 内部由一个 <code>Segment</code> 数组构成，每个 <code>Segment</code> 本身就像一个小型的 <code>HashMap</code>（内部是 <code>HashEntry</code> 数组）。</li>
<li>当需要对数据进行操作时，不是锁住整个 <code>Map</code>，而是根据 key 的 hash 值定位到对应的 <code>Segment</code>，然后只锁住那一个 <code>Segment</code>。</li>
<li><code>Segment</code> 继承自 <code>ReentrantLock</code>，因此可以实现细粒度的加锁。默认有 16 个 <code>Segment</code>，意味着理论上最多可以支持 16 个线程同时对 <code>Map</code> 进行写操作（只要它们操作的不是同一个 <code>Segment</code>）。</li>
<li>这种设计大大提高了并发度，<code>get</code> 操作大多数情况下甚至不需要加锁。</li>
</ul>
</li>
<li><strong>JDK 1.8 - CAS + synchronized + 红黑树</strong><ul>
<li>JDK 1.8 对 <code>ConcurrentHashMap</code> 进行了重大重构，摒弃了 <code>Segment</code> 的设计，锁的粒度更细。</li>
<li><strong>数据结构</strong>：与 <code>HashMap</code> 在 JDK 1.8 的实现类似，采用 <strong>数组 + 链表&#x2F;红黑树</strong> 的结构。</li>
<li><strong>锁粒度</strong>：锁的粒度从 <code>Segment</code> 级别降低到了 <strong>数组桶（bucket）的头节点</strong> 级别。</li>
<li><strong>加锁方式</strong>：<ol>
<li><strong>初始化&#x2F;插入首节点</strong>：当向一个空的 bucket 插入第一个节点时，使用 <strong>CAS</strong> 操作，不加锁，乐观地尝试写入。</li>
<li><strong>发生哈希冲突</strong>：如果 bucket 中已经有节点（链表或红黑树），则使用 <code>synchronized</code> 锁住该 bucket 的<strong>头节点</strong>。这样，只有在操作同一个 bucket 的线程之间才会产生竞争和阻塞，不同 bucket 之间的操作完全不受影响。</li>
</ol>
</li>
<li><strong>性能优化</strong>：当链表长度超过一定阈值（默认为 8）且数组长度大于 64 时，链表会转化为<strong>红黑树</strong>，将查找时间复杂度从 O(n) 降为 O(log n)。</li>
</ul>
</li>
</ul>
<h5 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h5><p><code>ConcurrentHashMap</code> 是 <code>Hashtable</code> 和 <code>Collections.synchronizedMap</code> 的完美替代品，在需要线程安全 Map 的场景下，几乎总是首选。</p>
<hr>
<h4 id="4-2-2-CopyOnWriteArrayList-CopyOnWriteArraySet"><a href="#4-2-2-CopyOnWriteArrayList-CopyOnWriteArraySet" class="headerlink" title="4.2.2 CopyOnWriteArrayList &#x2F; CopyOnWriteArraySet"></a>4.2.2 CopyOnWriteArrayList &#x2F; CopyOnWriteArraySet</h4><p><code>CopyOnWrite</code>（写时复制）是一种用于实现并发优化的策略。</p>
<ul>
<li><strong>核心思想</strong>:<ul>
<li><strong>读操作</strong>：不加锁，直接读取底层数组的数据。这使得读操作非常快且完全无阻塞。</li>
<li><strong>写操作（add, set, remove）</strong>：加锁，并且不是在原数组上修改，而是：<ol>
<li>复制一份底层数组的<strong>全新副本</strong>。</li>
<li>在新副本上进行修改操作。</li>
<li>将指向旧数组的引用，原子性地切换到指向新数组。</li>
</ol>
</li>
</ul>
</li>
<li><strong>特点</strong>:<ul>
<li><strong>读写分离</strong>：读和写操作在不同的数据结构上进行，读操作不会被写操作阻塞。</li>
<li><strong>缺点1：内存开销大</strong>：每次写操作都会复制整个数组，如果容器很大，会占用大量内存。</li>
<li><strong>缺点2：数据一致性问题</strong>：读操作读取的是某个时间点的快照。在一个写操作发生后，其他线程可能在一段时间内仍然读取到旧的数据。它只能保证数据的<strong>最终一致性</strong>，而不是实时一致性。</li>
<li><strong>迭代器</strong>：它的迭代器是安全的（不会抛出 <code>ConcurrentModificationException</code>），因为它遍历的是创建迭代器那一刻的数组快照，后续的修改不会反映在迭代器中。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li><strong>读多写少</strong>的场景。例如：黑白名单、系统配置、监听器列表等。如果写操作频繁，其性能会急剧下降。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-2-3-BlockingQueue-阻塞队列"><a href="#4-2-3-BlockingQueue-阻塞队列" class="headerlink" title="4.2.3 BlockingQueue - 阻塞队列"></a>4.2.3 BlockingQueue - 阻塞队列</h4><p><code>BlockingQueue</code> 是 JUC 中非常重要的一个接口，它在标准 <code>Queue</code> 的基础上增加了两个核心特性：</p>
<ol>
<li>当队列满时，尝试<strong>入队</strong>（<code>put</code>）的线程会被<strong>阻塞</strong>，直到队列有空闲空间。</li>
<li>当队列空时，尝试<strong>出队</strong>（<code>take</code>）的线程会被<strong>阻塞</strong>，直到队列中有元素。</li>
</ol>
<p>阻塞队列是<strong>生产者-消费者</strong>模式的经典实现，也是线程池等高级并发工具的核心组件。</p>
<h5 id="1-核心方法"><a href="#1-核心方法" class="headerlink" title="1. 核心方法"></a>1. 核心方法</h5><table>
<thead>
<tr>
<th>操作类型</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>阻塞</th>
<th>超时阻塞</th>
</tr>
</thead>
<tbody><tr>
<td><strong>入队</strong></td>
<td><code>add(e)</code></td>
<td><code>offer(e)</code></td>
<td><code>put(e)</code></td>
<td><code>offer(e, time, unit)</code></td>
</tr>
<tr>
<td><strong>出队</strong></td>
<td><code>remove()</code></td>
<td><code>poll()</code></td>
<td><code>take()</code></td>
<td><code>poll(time, unit)</code></td>
</tr>
<tr>
<td><strong>检查队头</strong></td>
<td><code>element()</code></td>
<td><code>peek()</code></td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<hr>
<h5 id="2-主要实现类"><a href="#2-主要实现类" class="headerlink" title="2. 主要实现类"></a>2. 主要实现类</h5><ul>
<li><strong><code>ArrayBlockingQueue</code></strong>:<ul>
<li>基于<strong>数组</strong>实现的<strong>有界</strong>阻塞队列。</li>
<li>创建时必须指定容量。</li>
<li>内部使用一个 <code>ReentrantLock</code> 和两个 <code>Condition</code>（<code>notEmpty</code>, <code>notFull</code>）来控制并发。</li>
<li>支持公平&#x2F;非公平策略（默认非公平）。</li>
</ul>
</li>
<li><strong><code>LinkedBlockingQueue</code></strong>:<ul>
<li>基于<strong>链表</strong>实现的阻塞队列。</li>
<li>容量是<strong>可选的</strong>，如果不指定，默认为 <code>Integer.MAX_VALUE</code>，相当于一个无界队列。</li>
<li>内部采用<strong>读写锁分离</strong>的思想，使用两个锁（<code>putLock</code>, <code>takeLock</code>）分别控制入队和出队操作，在高并发的生产者-消费者场景下，性能优于 <code>ArrayBlockingQueue</code>。</li>
</ul>
</li>
<li><strong><code>SynchronousQueue</code></strong>:<ul>
<li>一个<strong>不存储元素</strong>的阻塞队列，容量为 0。</li>
<li>每个 <code>put</code> 操作必须等待一个 <code>take</code> 操作，反之亦然。它更像是一个线程之间传递元素的“通道”或“手递手”的交接点。</li>
<li>常用于线程池 <code>Executors.newCachedThreadPool()</code> 中。</li>
</ul>
</li>
<li><strong><code>PriorityBlockingQueue</code></strong>:<ul>
<li>支持<strong>优先级</strong>的<strong>无界</strong>阻塞队列。</li>
<li>存入的元素必须实现 <code>Comparable</code> 接口或在构造时传入 <code>Comparator</code>。队列会根据元素的优先级进行排序。</li>
</ul>
</li>
<li><strong><code>DelayQueue</code></strong>:<ul>
<li>支持<strong>延时获取</strong>元素的<strong>无界</strong>阻塞队列。</li>
<li>队列中的元素必须实现 <code>Delayed</code> 接口，该接口定义了 <code>getDelay()</code> 方法。</li>
<li>只有当元素的延时时间到了，才能从队列中取出。</li>
<li>常用于实现定时任务、缓存过期等场景。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-2-4-ConcurrentLinkedQueue"><a href="#4-2-4-ConcurrentLinkedQueue" class="headerlink" title="4.2.4 ConcurrentLinkedQueue"></a>4.2.4 ConcurrentLinkedQueue</h4><ul>
<li>一个基于<strong>链表</strong>的<strong>无界</strong>、<strong>非阻塞</strong>的线程安全队列。</li>
<li>它使用 <strong>CAS</strong> 原子操作来实现元素的入队和出队，性能非常高。</li>
<li>由于是非阻塞的，当队列为空时，<code>poll()</code> 方法会立即返回 <code>null</code> 而不会等待。</li>
<li>适用于需要高吞吐量，并且不希望线程在队列操作上被阻塞的场景。</li>
</ul>
<hr>
<h4 id="4-2-5-ConcurrentSkipListMap-ConcurrentSkipListSet"><a href="#4-2-5-ConcurrentSkipListMap-ConcurrentSkipListSet" class="headerlink" title="4.2.5 ConcurrentSkipListMap &#x2F; ConcurrentSkipListSet"></a>4.2.5 ConcurrentSkipListMap &#x2F; ConcurrentSkipListSet</h4><ul>
<li><code>ConcurrentSkipListMap</code> 是一个线程安全的、<strong>有序的</strong> <code>Map</code>。</li>
<li>底层数据结构是<strong>跳表 (Skip List)</strong>。跳表是一种可以与平衡树（如红黑树）相媲美的、通过增加多级索引来提高查找效率的链表结构，且实现相对简单。</li>
<li><strong>特点</strong>:<ul>
<li><strong>有序性</strong>：key 是自然排序或根据指定的 <code>Comparator</code> 排序的。</li>
<li><strong>高并发性</strong>：通过 CAS 操作实现，提供了较好的并发性能。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>需要一个线程安全的、并且<strong>有序</strong>的 Map&#x2F;Set 时。例如，在一个排行榜应用中，需要根据分数动态排序并保证线程安全。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-3-线程同步工具"><a href="#4-3-线程同步工具" class="headerlink" title="4.3 线程同步工具"></a>4.3 线程同步工具</h3><p>除了锁和原子类提供的原子性保证外，JUC 还提供了一些用于多线程协作的同步工具，它们可以帮助我们更精细地控制线程的执行时机和流程。这些工具通常用于解决“一个或多个线程等待其他线程完成某项操作”的场景。</p>
<h4 id="4-3-1-CountDownLatch-倒计时门闩"><a href="#4-3-1-CountDownLatch-倒计时门闩" class="headerlink" title="4.3.1 CountDownLatch - 倒计时门闩"></a>4.3.1 CountDownLatch - 倒计时门闩</h4><p><code>CountDownLatch</code> 就像一个倒数计时器。它允许一个或多个线程等待，直到其他线程完成一系列操作后，再继续执行。</p>
<ul>
<li><p><strong>核心思想</strong>:<br><code>CountDownLatch</code> 在初始化时会设置一个计数值。线程可以通过调用 <code>await()</code> 方法来阻塞等待，直到计数值被减到 0。其他线程则可以通过调用 <code>countDown()</code> 方法来将计数值减 1。这个过程是<strong>一次性</strong>的，一旦计数值变为 0，<code>CountDownLatch</code> 就不能再被重置或重复使用。</p>
</li>
<li><p><strong>核心 API</strong>:</p>
<ul>
<li><code>CountDownLatch(int count)</code>: 构造方法，设置初始计数值。</li>
<li><code>void await()</code>: 阻塞当前线程，直到计数值变为 0。</li>
<li><code>boolean await(long timeout, TimeUnit unit)</code>: 带超时的等待。</li>
<li><code>void countDown()</code>: 将计数值减 1。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ol>
<li><strong>主线程等待所有子任务完成</strong>：启动多个线程执行子任务，主线程调用 <code>await()</code> 等待所有子任务执行完毕后再汇总结果或继续下一步。</li>
<li><strong>实现最大并行性</strong>：多个线程在 <code>CountDownLatch</code> 上等待，直到某个启动信号发出（调用 <code>countDown()</code>），所有线程才同时开始执行，用于模拟并发测试。</li>
</ol>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 设置计数值为 3</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：等待所有运动员准备就绪...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;运动员 &quot;</span> + num + <span class="string">&quot; 准备好了&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">2000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown(); <span class="comment">// 准备完毕，计数减 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await(); <span class="comment">// 主线程阻塞，直到计数值为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有运动员准备完毕，比赛开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-3-2-CyclicBarrier-循环屏障"><a href="#4-3-2-CyclicBarrier-循环屏障" class="headerlink" title="4.3.2 CyclicBarrier - 循环屏障"></a>4.3.2 CyclicBarrier - 循环屏障</h4><p><code>CyclicBarrier</code> 意为“循环的屏障”。它让一组线程互相等待，直到所有线程都到达一个公共的屏障点（barrier point），然后这些线程再<strong>同时</strong>继续执行。</p>
<ul>
<li><strong>核心思想</strong>:<br>与 <code>CountDownLatch</code> 不同，<code>CyclicBarrier</code> 是<strong>可重用</strong>的。当所有等待的线程都到达屏障后，屏障会被重置，可以用于下一轮的等待。它还可以在所有线程到达屏障时，选择性地执行一个 <code>Runnable</code> 任务</li>
<li><strong>核心 API</strong>:<ul>
<li><code>CyclicBarrier(int parties)</code>: 构造方法，<code>parties</code> 指的是需要等待的线程数量。</li>
<li><code>CyclicBarrier(int parties, Runnable barrierAction)</code>: 构造方法，增加一个 <code>barrierAction</code>，当所有线程都到达屏障时，会优先执行这个 <code>Runnable</code> 任务。</li>
<li><code>int await()</code>: 线程调用此方法表示已到达屏障，并开始阻塞等待其他线程。</li>
</ul>
</li>
<li><strong>应用场景</strong>:<ol>
<li><strong>多线程数据处理</strong>：在进行大规模数据计算时，可以分阶段进行。用 <code>CyclicBarrier</code> 保证所有线程都完成了当前阶段的计算，才能进入下一阶段。</li>
<li><strong>模拟并发场景</strong>：与 <code>CountDownLatch</code> 类似，可以确保多个线程在同一时刻开始执行任务。</li>
</ol>
</li>
<li><strong><code>CountDownLatch</code> vs <code>CyclicBarrier</code></strong></li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>CountDownLatch</code></th>
<th><code>CyclicBarrier</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用对象</strong></td>
<td>一个或多个线程等待<strong>其他</strong>线程完成操作</td>
<td>一组线程<strong>互相等待</strong></td>
</tr>
<tr>
<td><strong>可重用性</strong></td>
<td><strong>不可重用</strong>，计数值减到0后就失效了</td>
<td><strong>可重用</strong>（循环的）</td>
</tr>
<tr>
<td><strong>核心方法</strong></td>
<td><code>countDown()</code> 和 <code>await()</code></td>
<td><code>await()</code></td>
</tr>
<tr>
<td><strong>功能扩展</strong></td>
<td>无</td>
<td>可以在屏障点执行一个 <code>Runnable</code> 任务</td>
</tr>
<tr>
<td><strong>内部实现</strong></td>
<td>基于 AQS 的共享模式</td>
<td>基于 <code>ReentrantLock</code> 和 <code>Condition</code></td>
</tr>
</tbody></table>
<hr>
<h4 id="4-3-3-Semaphore-信号量"><a href="#4-3-3-Semaphore-信号量" class="headerlink" title="4.3.3 Semaphore - 信号量"></a>4.3.3 Semaphore - 信号量</h4><p><code>Semaphore</code> 用于控制<strong>同时访问</strong>特定资源的线程数量，它通过协调各个线程，以保证合理地使用公共资源。</p>
<ul>
<li><p><strong>核心思想</strong>:<br><code>Semaphore</code> 内部维护了一组“许可”（permits）。线程可以通过 <code>acquire()</code> 方法获取一个许可，如果许可已经用完，线程将被阻塞。当线程使用完资源后，必须通过 <code>release()</code> 方法归还许可。</p>
</li>
<li><p><strong>核心 API</strong>:</p>
<ul>
<li><code>Semaphore(int permits)</code>: 构造方法，设置许可的数量。</li>
<li><code>Semaphore(int permits, boolean fair)</code>: 可选择公平&#x2F;非公平模式。</li>
<li><code>void acquire()</code>: 获取一个许可，若无可用许可则阻塞。</li>
<li><code>void acquire(int n)</code>: 获取 n 个许可。</li>
<li><code>void release()</code>: 释放一个许可。</li>
<li><code>void release(int n)</code>: 释放 n 个许可。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ol>
<li><strong>流量控制</strong>：例如，控制同时访问数据库连接的线程数，防止数据库因连接过多而崩溃。</li>
<li><strong>资源池管理</strong>：如连接池、对象池，限制池中资源的最大并发使用数。</li>
<li><strong>服务限流</strong>：在网关或服务入口，限制某个接口的并发请求量。</li>
</ol>
</li>
<li><p><strong>代码示例 (模拟抢车位)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3个车位</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6辆车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">carNum</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 抢占车位</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;汽车 &quot;</span> + carNum + <span class="string">&quot; 抢到了车位&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 停车2秒</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;汽车 &quot;</span> + carNum + <span class="string">&quot; 离开了车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release(); <span class="comment">// 释放车位</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-3-4-Exchanger-数据交换器"><a href="#4-3-4-Exchanger-数据交换器" class="headerlink" title="4.3.4 Exchanger - 数据交换器"></a>4.3.4 Exchanger - 数据交换器</h4><p><code>Exchanger</code> 是一个用于两个线程之间交换数据的工具。它提供了一个同步点，在这个同步点，两个线程可以交换彼此的数据。</p>
<ul>
<li><strong>核心思想</strong>:<br>当一个线程调用 <code>exchange(V x)</code> 方法时，它会阻塞等待，直到另一个线程也调用了 <code>exchange()</code> 方法。当两个线程都到达同步点时，它们会交换传递给 <code>exchange()</code> 方法的数据，然后各自返回，拿到对方的数据。</li>
<li><strong>应用场景</strong>（相对较少）:<ol>
<li><strong>数据校对</strong>：两个线程分别从不同来源加载数据到缓冲区，然后通过 <code>Exchanger</code> 交换缓冲区，进行数据比对。</li>
<li><strong>生产者-消费者</strong>：一个线程生产数据到 buffer，另一个线程消费数据。它们可以通过 <code>Exchanger</code> 交换满的 buffer 和空的 buffer，提高效率。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-4-线程池"><a href="#4-4-线程池" class="headerlink" title="4.4 线程池"></a>4.4 线程池</h3><h4 id="4-4-1-概述"><a href="#4-4-1-概述" class="headerlink" title="4.4.1 概述"></a>4.4.1 概述</h4><p>在并发编程中，如果每次需要执行异步任务时都 <code>new Thread()</code>，会存在以下问题：</p>
<ol>
<li><strong>资源消耗</strong>：频繁地创建和销毁线程会消耗大量的系统资源（如内存），因为线程的创建和销毁是有成本的。</li>
<li><strong>性能瓶颈</strong>：创建和销毁线程的开销可能会大于任务本身执行的开销，导致系统响应变慢。</li>
<li><strong>缺乏管理</strong>：无限制地创建线程可能会耗尽系统资源（如内存或 CPU），导致系统崩溃或 <code>OutOfMemoryError</code>。无法对线程进行统一的管理、监控和调优。</li>
</ol>
<p><strong>线程池</strong>就是为了解决这些问题而生的。它是一种池化技术，核心思想是<strong>复用已经创建好的线程</strong>，从而避免频繁创建和销-毁带来的开销。</p>
<p><strong>线程池的好处：</strong></p>
<ul>
<li><strong>降低资源消耗</strong>：通过复用线程，减少了线程创建和销毁的开销。</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>
<li><strong>提高线程的可管理性</strong>：可以对线程进行统一分配、调优和监控，控制最大并发数，防止资源耗尽。</li>
<li><strong>提供更多功能</strong>：支持定时执行、周期性执行、单线程执行、并发数控制等。</li>
</ul>
<hr>
<h4 id="4-4-2-线程池的核心体系-Executor-框架"><a href="#4-4-2-线程池的核心体系-Executor-框架" class="headerlink" title="4.4.2 线程池的核心体系 - Executor 框架"></a>4.4.2 线程池的核心体系 - <code>Executor</code> 框架</h4><pre><code class="highlight mermaid">graph
    A[Executor] --&gt; B[ExecutorService]
    B --&gt; C[AbstractExecutorService]
    C --&gt; D[ThreadPoolExecutor]
    B --&gt; E[ScheduledExecutorService]
    E --&gt; F[ScheduledThreadPoolExecutor]</code></pre>

<p><strong>第一层：顶层接口 (定义标准)</strong></p>
<ul>
<li><strong><code>Executor</code></strong><ul>
<li><strong>定位</strong>：最顶层的接口，甚至有点“简陋”。</li>
<li><strong>功能</strong>：只定义了一个方法 <code>void execute(Runnable command)</code>。</li>
<li><strong>意义</strong>：它只关注**“执行”**，不关注任务怎么运行（同步还是异步）、不关注线程怎么调度，实现了提交与执行的解耦。</li>
</ul>
</li>
</ul>
<p><strong>第二层：增强接口 (生命周期管理)</strong></p>
<ul>
<li><strong><code>ExecutorService</code></strong><ul>
<li><strong>定位</strong>：<strong>真正被广泛使用的接口</strong>。</li>
<li><strong>功能</strong>：在 <code>Executor</code> 的基础上，扩展了两个核心能力：<ol>
<li><strong>生命周期管理</strong>：提供了 <code>shutdown()</code> (平滑关闭), <code>shutdownNow()</code> (暴力关闭), <code>isTerminated()</code> 等方法。</li>
<li><strong>异步返回值</strong>：提供了 <code>submit()</code> 方法，支持 <code>Callable</code>，并返回 <code>Future</code> 对象用于获取结果。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>第三层：核心实现 (落地干活)</strong></p>
<ul>
<li><strong><code>ThreadPoolExecutor</code> (重点)</strong><ul>
<li><strong>定位</strong>：<strong>线程池的核心实现类</strong>，也是面试和开发中的绝对主角。</li>
<li><strong>功能</strong>：实现了复杂的线程池逻辑（核心线程、最大线程、队列、拒绝策略等）。</li>
</ul>
</li>
<li><strong><code>ScheduledThreadPoolExecutor</code></strong><ul>
<li><strong>定位</strong>：定时任务线程池。</li>
<li><strong>功能</strong>：继承自 <code>ThreadPoolExecutor</code>，实现了 <code>ScheduledExecutorService</code> 接口，用于替代古老的 <code>Timer</code> 类，支持延迟执行和周期性执行。</li>
</ul>
</li>
</ul>
<p><strong>第四层：辅助工具 (语法糖)</strong></p>
<ul>
<li><strong><code>Executors</code></strong><ul>
<li><strong>定位</strong>：<strong>工具工厂类</strong>（类似于 <code>Collections</code> 之于集合）。</li>
<li><strong>功能</strong>：提供了 <code>newFixedThreadPool</code>、<code>newCachedThreadPool</code> 等静态方法快捷创建线程池。</li>
<li><strong>注意</strong>：<strong>生产环境中通常禁止使用此类</strong>，因为它隐藏了复杂的参数配置，容易导致 OOM（内存溢出）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-4-3-ThreadPoolExecutor-的核心参数"><a href="#4-4-3-ThreadPoolExecutor-的核心参数" class="headerlink" title="4.4.3 ThreadPoolExecutor 的核心参数"></a>4.4.3 <code>ThreadPoolExecutor</code> 的核心参数</h4><p><code>ThreadPoolExecutor</code> 是最核心的实现类，理解它的构造函数参数至关重要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong><code>corePoolSize</code> (核心线程数)</strong><ul>
<li>线程池中长期保持的线程数量，即使它们处于空闲状态，也不会被销毁（除非设置了 <code>allowCoreThreadTimeOut</code>）。</li>
<li>这是线程池处理任务的主力军。</li>
</ul>
</li>
<li><strong><code>maximumPoolSize</code> (最大线程数)</strong><ul>
<li>线程池能够容纳同时执行的线程最大数量。</li>
<li>当工作队列满了，并且当前线程数小于最大线程数时，线程池会创建新的非核心线程来处理任务。</li>
</ul>
</li>
<li><strong><code>keepAliveTime</code> (空闲线程存活时间)</strong><ul>
<li>当线程池中的线程数量<strong>超过 <code>corePoolSize</code></strong> 时，如果一个非核心线程空闲时间达到 <code>keepAliveTime</code>，它就会被销毁，直到线程数缩减回 <code>corePoolSize</code>。</li>
</ul>
</li>
<li><strong><code>unit</code> (时间单位)</strong><ul>
<li><code>keepAliveTime</code> 的时间单位（如 <code>TimeUnit.SECONDS</code>）。</li>
</ul>
</li>
<li><strong><code>workQueue</code> (工作队列&#x2F;任务队列)</strong><ul>
<li>一个阻塞队列，用于存放<strong>等待执行</strong>的任务。当核心线程都在忙时，新提交的任务会被放入这个队列中。</li>
<li>常用的队列类型：<ul>
<li><code>ArrayBlockingQueue</code>: 基于数组的有界阻塞队列。</li>
<li><code>LinkedBlockingQueue</code>: 基于链表的阻塞队列。如果不指定容量，默认为 <code>Integer.MAX_VALUE</code>，可能导致内存溢出。</li>
<li><code>SynchronousQueue</code>: 不存储元素的阻塞队列，任务直接提交给线程，没有则创建新线程，直到达到 <code>maximumPoolSize</code>。</li>
<li><code>PriorityBlockingQueue</code>: 带有优先级的无界阻塞队列。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>threadFactory</code> (线程工厂)</strong><ul>
<li>用于创建新线程的工厂。可以自定义线程的名称、是否为守护线程、优先级等。</li>
</ul>
</li>
<li><strong><code>handler</code> (拒绝策略)</strong><ul>
<li>当<strong>队列已满</strong>且<strong>线程数已达到 <code>maximumPoolSize</code></strong> 时，线程池会采取的拒绝策略。</li>
<li>内置策略：<ul>
<li><code>AbortPolicy</code> (默认): 直接抛出 <code>RejectedExecutionException</code> 异常，阻止系统正常运行。</li>
<li><code>CallerRunsPolicy</code>: “调用者运行”策略。既不抛弃任务，也不抛出异常，而是将任务回退给调用者（提交任务的线程）来执行。</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务，不予处理也不抛异常。</li>
<li><code>DiscardOldestPolicy</code>: 丢弃队列最前面的任务，然后重新尝试执行当前任务。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-4-4-线程池的工作流程"><a href="#4-4-4-线程池的工作流程" class="headerlink" title="4.4.4 线程池的工作流程"></a>4.4.4 线程池的工作流程</h4><p>当一个新任务通过 <code>execute()</code> 方法提交时：</p>
<ol>
<li><strong>判断核心线程池是否已满？</strong><ul>
<li>如果当前运行的线程数 &lt; <code>corePoolSize</code>，则<strong>创建新核心线程</strong>来执行任务，即使其他核心线程是空闲的。</li>
</ul>
</li>
<li><strong>判断工作队列是否已满？</strong><ul>
<li>如果核心线程池已满（线程数 &gt;&#x3D; <code>corePoolSize</code>），则将任务放入<strong>工作队列 <code>workQueue</code></strong> 中等待。</li>
</ul>
</li>
<li><strong>判断最大线程池是否已满？</strong><ul>
<li>如果工作队列也满了，则判断当前运行的线程数是否 &lt; <code>maximumPoolSize</code>。</li>
<li>如果是，则<strong>创建新的非核心线程</strong>来执行任务。</li>
</ul>
</li>
<li><strong>触发拒绝策略</strong><ul>
<li>如果当前线程数已经达到 <code>maximumPoolSize</code>，则由 <code>RejectedExecutionHandler</code> 来处理这个任务。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-4-5-Executors-工具类与潜在风险"><a href="#4-4-5-Executors-工具类与潜在风险" class="headerlink" title="4.4.5 Executors 工具类与潜在风险"></a>4.4.5 <code>Executors</code> 工具类与潜在风险</h4><p><code>Executors</code> 提供了一些方便的静态方法来创建线程池，但阿里巴巴《Java开发手册》中<strong>强烈建议</strong>开发者通过 <code>ThreadPoolExecutor</code> 的构造函数手动创建线程池，因为 <code>Executors</code> 创建的线程池可能存在资源耗尽的风险。</p>
<ul>
<li><strong><code>Executors.newFixedThreadPool(int nThreads)</code></strong>:<ul>
<li><strong>特点</strong>: 创建一个固定大小的线程池。<code>corePoolSize</code> 和 <code>maximumPoolSize</code> 相等。</li>
<li><strong>队列</strong>: 使用 <code>LinkedBlockingQueue</code> (无界队列)。</li>
<li><strong>风险</strong>: 由于队列是无界的，如果任务提交速度远大于处理速度，会导致大量任务堆积在队列中，可能引发 <strong>OOM (OutOfMemoryError)</strong>。</li>
</ul>
</li>
<li><strong><code>Executors.newSingleThreadExecutor()</code></strong>:<ul>
<li><strong>特点</strong>: 创建一个只有一个线程的线程池。</li>
<li><strong>队列</strong>: 使用 <code>LinkedBlockingQueue</code> (无界队列)。</li>
<li><strong>风险</strong>: 与 <code>newFixedThreadPool</code> 类似，存在 <strong>OOM</strong> 风险。</li>
</ul>
</li>
<li><strong><code>Executors.newCachedThreadPool()</code></strong>:<ul>
<li><strong>特点</strong>: 创建一个可缓存的线程池。<code>corePoolSize</code> 为 0，<code>maximumPoolSize</code> 为 <code>Integer.MAX_VALUE</code>。</li>
<li><strong>队列</strong>: 使用 <code>SynchronousQueue</code>。</li>
<li><strong>工作方式</strong>: 来一个任务，如果没有空闲线程，就创建一个新线程来处理。空闲线程存活 60 秒。</li>
<li><strong>风险</strong>: <code>maximumPoolSize</code> 设置为几乎无限大，如果短时间内有大量任务涌入，会创建大量线程，可能耗尽系统资源，导致 <strong>OOM</strong>。</li>
</ul>
</li>
<li><strong><code>Executors.newScheduledThreadPool(int corePoolSize)</code></strong>:<ul>
<li><strong>特点</strong>: 创建一个支持定时及周期性任务执行的线程池。</li>
<li><strong>风险</strong>: 与 <code>newCachedThreadPool</code> 类似，<code>maximumPoolSize</code> 也是 <code>Integer.MAX_VALUE</code>，存在 <strong>OOM</strong> 风险。</li>
</ul>
</li>
</ul>
<p><strong>最佳实践</strong>：根据业务场景，明确线程池的核心参数，<strong>手动创建 <code>ThreadPoolExecutor</code></strong>。这样可以避免资源耗尽的风险，让线程池的行为更加可控。</p>
<p><strong>如何合理配置线程池参数？</strong></p>
<ul>
<li><strong>CPU密集型任务</strong> (大量计算): <code>corePoolSize</code> &#x3D; CPU核心数 + 1。这能保证 CPU 的高效利用，+1 是为了防止线程因偶尔的页错误或其他原因阻塞时，CPU能有其他线程顶上。</li>
<li><strong>I&#x2F;O密集型任务</strong> (网络请求、文件读写): <code>corePoolSize</code> 可以设置得更大，通常是 CPU 核心数的数倍。因为线程在执行 I&#x2F;O 操作时会阻塞，CPU 处于空闲状态，可以切换到其他线程执行任务。一个经验公式是：<code>CPU核心数 * (1 + 平均等待时间 / 平均计算时间)</code>。</li>
</ul>
<hr>
<h4 id="4-4-6-关闭线程池"><a href="#4-4-6-关闭线程池" class="headerlink" title="4.4.6 关闭线程池"></a>4.4.6 关闭线程池</h4><ul>
<li><strong><code>shutdown()</code></strong>: 平滑关闭。不再接受新任务，但会等待已提交到队列中的任务执行完毕。</li>
<li><strong><code>shutdownNow()</code></strong>: 立即关闭。尝试停止所有正在执行的任务（通过 <code>Thread.interrupt()</code>），并返回队列中未执行的任务列表。不保证正在执行的任务一定能成功停止。</li>
</ul>
<hr>
<h3 id="4-5-ThreadLocal"><a href="#4-5-ThreadLocal" class="headerlink" title="4.5 ThreadLocal"></a>4.5 ThreadLocal</h3><h4 id="4-5-1-概述"><a href="#4-5-1-概述" class="headerlink" title="4.5.1. 概述"></a>4.5.1. 概述</h4><p><code>ThreadLocal</code>，直译为“线程本地变量”，它提供了一种创建<strong>线程私有变量</strong>的机制。对于一个 <code>ThreadLocal</code> 变量，每个使用该变量的线程都会拥有一个独立的、私有的副本。一个线程无法访问或修改其他线程的 <code>ThreadLocal</code> 变量副本。</p>
<p><strong>核心思想</strong>：</p>
<p><code>ThreadLocal</code> 并非用于解决多线程共享变量的并发问题，恰恰相反，它通过“<strong>空间换时间</strong>”的方式，为每个线程都提供一份变量的副本，从而避免了多线程之间的竞争和同步开销。它是一种<strong>线程隔离</strong>的解决方案。</p>
<p><strong>与 <code>synchronized</code> 的对比</strong>：</p>
<ul>
<li><code>synchronized</code>：通过加锁来保证在同一时间只有一个线程能访问共享变量，是一种“<strong>时间换空间</strong>”的策略，多个线程排队访问同一个变量。</li>
<li><code>ThreadLocal</code>：为每个线程创建独立的变量副本，线程之间互不干扰，是一种“<strong>空间换时间</strong>”的策略，多个线程同时访问各自的变量。</li>
</ul>
<hr>
<h4 id="4-5-2-核心API"><a href="#4-5-2-核心API" class="headerlink" title="4.5.2 核心API"></a>4.5.2 核心API</h4><p><code>ThreadLocal</code> 的使用非常简单，主要有以下几个方法：</p>
<ul>
<li><code>void set(T value)</code>: 为当前线程设置一个线程本地变量的值。</li>
<li><code>T get()</code>: 获取当前线程对应的线程本地变量的值。如果当前线程是第一次调用 <code>get</code>，它会通过调用 <code>initialValue()</code> 方法来获取初始值。</li>
<li><code>void remove()</code>: 移除当前线程的线程本地变量的值。<strong>这是一个非常重要的方法，用于防止内存泄漏。</strong></li>
<li><code>protected T initialValue()</code>: 返回该线程局部变量的初始值。该方法是一个 <code>protected</code> 方法，一般是开发人员在使用时通过匿名内部类的方式覆盖它，指定初始值。默认实现是返回 <code>null</code>。</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 ThreadLocal 变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; userContext = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以通过覆盖 initialValue() 来设置默认值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; idContext = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            userContext.set(<span class="string">&quot;User-&quot;</span> + threadName); <span class="comment">// 2. 为当前线程设置值</span></span><br><span class="line">            idContext.set((<span class="type">int</span>)(Math.random() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(threadName + <span class="string">&quot; 的 user 是: &quot;</span> + userContext.get());</span><br><span class="line">            System.out.println(threadName + <span class="string">&quot; 的 id 是: &quot;</span> + idContext.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 使用完毕后，务必调用 remove()</span></span><br><span class="line">            userContext.remove();</span><br><span class="line">            idContext.remove();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出（顺序可能不同）：</span></span><br><span class="line"><span class="comment">// Thread-A 的 user 是: User-Thread-A</span></span><br><span class="line"><span class="comment">// Thread-A 的 id 是: ...</span></span><br><span class="line"><span class="comment">// Thread-B 的 user 是: User-Thread-B</span></span><br><span class="line"><span class="comment">// Thread-B 的 id 是: ...</span></span><br></pre></td></tr></table></figure>

<p>从输出可以看出，<code>Thread-A</code> 和 <code>Thread-B</code> 各自拥有独立的 <code>userContext</code> 和 <code>idContext</code> 副本，互不影响。</p>
<hr>
<h4 id="4-5-3-ThreadLocal-的实现原理"><a href="#4-5-3-ThreadLocal-的实现原理" class="headerlink" title="4.5.3 ThreadLocal 的实现原理"></a>4.5.3 ThreadLocal 的实现原理</h4><p>要理解 <code>ThreadLocal</code> 的原理，关键在于 <code>Thread</code>、<code>ThreadLocal</code> 和 <code>ThreadLocalMap</code> 这三者的关系。</p>
<ol>
<li><p><strong><code>Thread</code> 类</strong>:<br>每个 <code>Thread</code> 对象内部都有一个成员变量 <code>threadLocals</code>，它的类型是 <code>ThreadLocal.ThreadLocalMap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>这个 <code>threadLocals</code> 变量存储了该线程所有 <code>ThreadLocal</code> 变量的副本。</p>
</li>
<li><p><strong><code>ThreadLocalMap</code> 类</strong>:<br><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的一个静态内部类，它是一个定制版的 <code>HashMap</code>。</p>
<ul>
<li><strong>Key</strong>: <code>ThreadLocal</code> 对象本身，并且是一个<strong>弱引用 (WeakReference)</strong>。</li>
<li><strong>Value</strong>: 线程需要存储的变量副本。</li>
</ul>
</li>
<li><p><strong>工作流程</strong>:</p>
<ul>
<li><strong><code>set(value)</code></strong>: 当一个线程调用 <code>threadLocal.set(value)</code> 时，实际上是：<ol>
<li>获取当前线程 <code>Thread.currentThread()</code>。</li>
<li>通过当前线程获取其内部的 <code>ThreadLocalMap</code> 对象 <code>threadLocals</code>。</li>
<li>如果 <code>threadLocals</code> 为 null，则创建一个新的 <code>ThreadLocalMap</code> 并赋给当前线程。</li>
<li>以 <code>threadLocal</code> 对象本身作为 key，<code>value</code> 作为值，存入 <code>threadLocals</code> 这个 Map 中。</li>
</ol>
</li>
<li><strong><code>get()</code></strong>: 调用 <code>threadLocal.get()</code> 时：<ol>
<li>获取当前线程的 <code>ThreadLocalMap</code>。</li>
<li>以 <code>threadLocal</code> 对象为 key，从 Map 中查找对应的 Entry。</li>
<li>如果找到，返回 Entry 的 value；如果找不到（或 Map 为 null），则返回 <code>initialValue()</code> 的值。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p><strong>总结关系</strong>：每个 <code>Thread</code> 持有一个 <code>ThreadLocalMap</code>，这个 Map 的 Key 是 <code>ThreadLocal</code> 实例，Value 是线程私有的变量副本。<code>ThreadLocal</code> 本身不存储任何数据，它只是一个“钥匙”，用来从当前线程的 Map 中存取数据。</p>
<hr>
<h4 id="4-5-4-内存泄漏问题"><a href="#4-5-4-内存泄漏问题" class="headerlink" title="4.5.4 内存泄漏问题"></a>4.5.4 内存泄漏问题</h4><p><strong>什么是内存泄漏？</strong></p>
<p>一个对象已经不再被使用，但由于存在其他对象的强引用，导致垃圾回收器（GC）无法回收它，这个对象所占用的内存就泄漏了。</p>
<p><strong>ThreadLocal 为什么会内存泄漏？</strong></p>
<p>前面提到，<code>ThreadLocalMap</code> 的 <strong>key</strong> 是对 <code>ThreadLocal</code> 对象的<strong>弱引用</strong>。</p>
<ul>
<li><strong>弱引用 (WeakReference)</strong>: 当一个对象只被弱引用指向时，下一次垃圾回收发生时，无论内存是否充足，这个对象都会被回收。</li>
</ul>
<p><strong>泄漏过程分析</strong>：</p>
<ol>
<li>当 <code>threadLocal</code> 对象在外部作用域不再被使用时（例如，<code>threadLocal = null</code>），它会变成一个只有 <code>ThreadLocalMap</code> 中的弱引用指向的对象。</li>
<li>下一次 GC 发生时，这个 <code>ThreadLocal</code> 对象（作为 key）就会被回收。此时，<code>ThreadLocalMap</code> 中就会出现 <strong>key 为 null</strong> 的 Entry。</li>
<li><strong>问题来了</strong>：虽然 key 被回收了，但 Entry 中的 <strong>value</strong> 仍然存在一条从 <code>Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value</code> 的<strong>强引用链</strong>。</li>
<li>只要这个线程不消亡，这个强引用链就一直存在，导致 <strong>value 对象无法被回收</strong>，从而造成内存泄漏。</li>
</ol>
<p><strong>为什么 Key 要设计成弱引用？</strong></p>
<p>这是一个权衡。如果 key 是强引用，那么即使 <code>threadLocal</code> 对象在外部被置为 null，<code>ThreadLocalMap</code> 依然持有它的强引用，<code>ThreadLocal</code> 对象本身也无法被回收。相比之下，弱引用至少能保证 <code>ThreadLocal</code> 对象本身被回收。<code>ThreadLocalMap</code> 在其 <code>set</code>, <code>get</code>, <code>remove</code> 方法中，会顺便检查并清理那些 key 为 null 的 Entry，这是一种<strong>补偿机制</strong>。</p>
<p><strong>如何避免内存泄漏？</strong></p>
<p>最根本、最有效的解决方法是：<strong>在每次使用完 <code>ThreadLocal</code> 后，手动调用 <code>remove()</code> 方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Object&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    tl.set(<span class="keyword">new</span> <span class="title class_">MyObject</span>());</span><br><span class="line">    <span class="comment">// ... use tl.get() ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    tl.remove(); <span class="comment">// 保证在任何情况下都能清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>remove()</code> 方法会把当前线程的 <code>ThreadLocalMap</code> 中对应的 Entry（包括 key 和 value）都移除，从而彻底断开引用链，避免内存泄漏。特别是在使用<strong>线程池</strong>的场景下，这一点尤为重要，因为线程池中的线程是会被复用的，如果不清理 <code>ThreadLocal</code> 变量，上一个任务的脏数据可能会被下一个任务读取到，并且内存泄漏会不断累积。</p>
<hr>
<h4 id="4-5-6-InheritableThreadLocal"><a href="#4-5-6-InheritableThreadLocal" class="headerlink" title="4.5.6 InheritableThreadLocal"></a>4.5.6 InheritableThreadLocal</h4><p><code>ThreadLocal</code> 的一个问题是，父线程中设置的值，在子线程中无法获取。<code>InheritableThreadLocal</code> 类解决了这个问题。</p>
<p>当父线程创建一个子线程时，<code>InheritableThreadLocal</code> 会将父线程中存储的本地变量值复制一份给子线程。注意，这只是在<strong>创建子线程时</strong>的一次性复制，之后父子线程的变量副本就是独立的了。</p>
<p><strong>应用场景</strong>：</p>
<p>在一些需要将上下文信息（如用户身份、请求ID、事务信息等）从父线程传递到子线程的场景中非常有用。例如，在使用线程池异步处理任务时，希望子线程也能获取到主线程的上下文信息。</p>
<hr>
<h2 id="5-实践与总结"><a href="#5-实践与总结" class="headerlink" title="5. 实践与总结"></a>5. 实践与总结</h2><h3 id="5-1-死锁"><a href="#5-1-死锁" class="headerlink" title="5.1 死锁"></a>5.1 死锁</h3><h4 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h4><p><strong>死锁</strong> 是指在并发环境中，两个或多个线程（或进程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干预，它们都将无法继续向前推进。</p>
<p>一个经典的死锁场景可以这样描述：</p>
<blockquote>
<p><strong>线程 A 持有锁 1，并且正在尝试获取锁 2；与此同时，线程 B 持有锁 2，并正在尝试获取锁 1。</strong></p>
</blockquote>
<p>由于两个线程都在等待对方释放自己需要的锁，但它们自己又都持有对方需要的锁不肯释放，这就形成了一个**“僵局”**，导致两个线程都永远地阻塞下去。</p>
<hr>
<h4 id="5-1-2-死锁的四个必要条件"><a href="#5-1-2-死锁的四个必要条件" class="headerlink" title="5.1.2 死锁的四个必要条件"></a>5.1.2 死锁的四个必要条件</h4><p>死锁的发生必须<strong>同时满足</strong>以下四个条件。只要破坏其中任意一个，就可以预防死锁的发生。</p>
<ol>
<li><strong>互斥条件 (Mutual Exclusion)</strong><ul>
<li><strong>定义</strong>：一个资源在同一时刻只能被一个线程占用。当一个线程已经占用了该资源，其他任何试图获取该资源的线程都必须等待，直到资源被释放。</li>
<li><strong>生活类比</strong>：一间只有一个座位的厕所，一次只能进去一个人。</li>
<li><strong>在Java中</strong>：<code>synchronized</code> 关键字和 <code>JUC</code> 包下的各种 <code>Lock</code> 实现都满足互斥条件。</li>
</ul>
</li>
<li><strong>请求与保持条件 (Hold and Wait)</strong><ul>
<li><strong>定义</strong>：一个线程在已经持有了<strong>至少一个</strong>资源的情况下，又去请求其他资源。如果请求的资源被其他线程占用，那么该线程会进入阻塞状态，并且在等待期间<strong>不会释放</strong>自己已经持有的资源。</li>
<li><strong>生活类比</strong>：你左手拿着筷子，又想去拿勺子，但勺子被别人拿着，你不会放下筷子，而是拿着筷子干等着。</li>
</ul>
</li>
<li><strong>非剥夺条件 (No Preemption)</strong><ul>
<li><strong>定义</strong>：线程已经获得的资源，在未使用完毕之前，不能被其他线程强行剥夺。只能由持有资源的线程自己主动释放。</li>
<li><strong>生活类比</strong>：别人不能从你手里强行抢走你正在使用的筷子，只能等你用完自己放下。</li>
</ul>
</li>
<li><strong>循环等待条件 (Circular Wait)</strong><ul>
<li><strong>定义</strong>：存在一个线程—资源的循环等待链。线程集合 {T0, T1, T2, …, Tn} 中，T0 在等待 T1 持有的资源，T1 在等待 T2 持有的资源，…，Tn 在等待 T0 持有的资源，形成一个闭环。</li>
<li><strong>生活类比</strong>：A 等 B，B 等 C，C 又在等 A。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-1-3-示例"><a href="#5-1-3-示例" class="headerlink" title="5.1.3 示例"></a>5.1.3 示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 持有 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 制造一些耗时操作，给另一个线程获取 lockB 的机会</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 成功获取 lockA 和 lockB！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程 2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 持有 lockB，尝试获取 lockA...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 成功获取 lockB 和 lockA！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main thread finished.</span><br><span class="line">线程A 持有 lockA，尝试获取 lockB...</span><br><span class="line">线程B 持有 lockB，尝试获取 lockA...</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-1-4-如何排查死锁"><a href="#5-1-4-如何排查死锁" class="headerlink" title="5.1.4 如何排查死锁"></a>5.1.4 如何排查死锁</h4><p>当线上应用出现无响应、CPU利用率不高但线程数很多等情况时，就需要怀疑是否发生了死锁。JDK 提供了强大的命令行工具来帮助我们定位问题。</p>
<ol>
<li><p><strong>使用 <code>jps</code> 找到 Java 进程 ID (PID)</strong></p>
<p>在命令行中输入 <code>jps -l</code>，可以列出所有正在运行的 Java 进程及其 PID。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l</span><br><span class="line">18872 com.example.DeadlockDemo  &lt;-- 找到我们的死锁程序PID</span><br><span class="line">12345 sun.tools.jps.Jps</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>jstack</code> 分析线程堆栈</strong></p>
<p><code>jstack</code> 是排查 Java 线程问题的神器，它可以打印出指定 PID 进程的线程堆栈信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstack 18872</span><br></pre></td></tr></table></figure>

<p>如果存在死锁，<code>jstack</code> 会在输出的末尾明确地检测出来并给出详细报告。</p>
<p><strong><code>jstack</code> 输出示例：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">... (前面是所有线程的堆栈信息)</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;线程B&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f9a8c003d08 (object 0x000000076acb3a00, a java.lang.Object),</span><br><span class="line">  which is held by &quot;线程A&quot;</span><br><span class="line">&quot;线程A&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f9a8c006378 (object 0x000000076acb3a10, a java.lang.Object),</span><br><span class="line">  which is held by &quot;线程B&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;线程B&quot;:</span><br><span class="line">    at com.example.DeadlockDemo.lambda$main$1(DeadlockDemo.java:35)</span><br><span class="line">    - waiting to lock &lt;0x000000076acb3a00&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076acb3a10&gt; (a java.lang.Object)</span><br><span class="line">    at com.example.DeadlockDemo$$Lambda$2/0x0000000800061440.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;线程A&quot;:</span><br><span class="line">    at com.example.DeadlockDemo.lambda$main$0(DeadlockDemo.java:21)</span><br><span class="line">    - waiting to lock &lt;0x000000076acb3a10&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076acb3a00&gt; (a java.lang.Object)</span><br><span class="line">    at com.example.DeadlockDemo$$Lambda$1/0x0000000800060c40.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p>从这份报告中，我们可以清晰地看到：</p>
<ul>
<li><code>&quot;线程B&quot;</code> 正在等待一个锁 (<code>0x...3a00</code>)，而这个锁正被 <code>&quot;线程A&quot;</code> 持有。</li>
<li><code>&quot;线程A&quot;</code> 正在等待另一个锁 (<code>0x...3a10</code>)，而这个锁正被 <code>&quot;线程B&quot;</code> 持有。</li>
<li>报告还指出了发生等待的代码行号 (<code>DeadlockDemo.java:35</code> 和 <code>DeadlockDemo.java:21</code>)。</li>
</ul>
</li>
<li><p><strong>使用图形化工具 (JConsole, VisualVM)</strong></p>
<p>JDK 自带的 JConsole 或功能更强大的 VisualVM 也提供了图形化的线程监控和死锁检测功能。连接到目标 Java 进程后，在 “线程” (Threads) 标签页下，通常会有一个 “检测死锁” (Detect Deadlock) 的按钮，点击后可以直观地看到死锁的线程和它们之间的依赖关系。</p>
</li>
</ol>
<hr>
<h4 id="5-1-5-如何预防和避免死锁"><a href="#5-1-5-如何预防和避免死锁" class="headerlink" title="5.1.5 如何预防和避免死锁"></a>5.1.5 如何预防和避免死锁</h4><p>预防死锁的核心思想是<strong>破坏其四个必要条件中的至少一个</strong>。</p>
<ol>
<li><p><strong>破坏“循环等待”条件（最常用）</strong></p>
<ul>
<li><p><strong>方法</strong>：<strong>按序加锁 (Lock Ordering)</strong>。规定所有线程必须按照一个全局统一的、固定的顺序来获取锁。</p>
</li>
<li><p><strong>示例</strong>：在上面的例子中，我们可以规定：无论在哪个线程中，都必须先获取 <code>lockA</code>，再获取 <code>lockB</code>。</p>
</li>
<li><p><strong>修复后的代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程 B 的代码修改为</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 同样先获取 lockA</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 持有 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再获取 lockB</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 成功获取 lockA 和 lockB！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程B&quot;</span>).start();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原理</strong>：线程 B 现在也会先尝试获取 <code>lockA</code>。如果 <code>lockA</code> 被线程 A 持有，线程 B 就会在获取第一个锁时就阻塞，而不会持有 <code>lockB</code> 再去请求 <code>lockA</code>，从而打破了循环等待的链条。</p>
</li>
</ul>
</li>
<li><p><strong>破坏“请求与保持”条件</strong></p>
<ul>
<li><p><strong>方法</strong>：一次性申请所有需要的资源。如果不能一次性获得所有资源，则一个都不占有。</p>
</li>
<li><p><strong>实现</strong>：这种方式在 <code>synchronized</code> 关键字上很难直接实现。但可以使用 <code>JUC</code> 下的 <code>Lock</code> 接口。例如，<code>ReentrantLock</code> 的 <code>tryLock()</code> 方法。</p>
</li>
<li><p><strong>示例 (使用 <code>tryLock</code>)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lockA.tryLock()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lockB.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 成功获取两个锁，执行业务逻辑</span></span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 退出循环</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lockB.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lockA.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁失败，可以等待一小段时间后重试，避免活锁</span></span><br><span class="line">    Thread.sleep(<span class="number">10</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原理</strong>：<code>tryLock()</code> 会立即返回获取锁的结果（<code>true</code> 或 <code>false</code>），而不是一直阻塞。如果获取 <code>lockB</code> 失败，线程会释放已经持有的 <code>lockA</code>，然后重试，这就破坏了“持有并等待”的条件。</p>
</li>
</ul>
</li>
<li><p><strong>破坏“非剥夺”条件</strong></p>
<ul>
<li><strong>方法</strong>：当一个线程请求的资源不可得时，它可以主动释放已经占有的资源。</li>
<li><strong>实现</strong>：这和使用 <code>tryLock()</code> 的思想类似。<code>synchronized</code> 是非剥夺的，一旦持有锁，除非代码块执行完毕或抛出异常，否则不会释放。而 <code>Lock</code> 接口提供了可中断的 (<code>lockInterruptibly()</code>) 和可超时的 (<code>tryLock(long time, TimeUnit unit)</code>) 获取锁的方式，这些方式提供了从阻塞状态中退出的能力，从而可以手动释放已持有的锁，间接实现了“剥夺”。</li>
</ul>
</li>
<li><p><strong>破坏“互斥”条件</strong></p>
<ul>
<li><strong>方法</strong>：允许资源被多个线程同时访问。</li>
<li><strong>实现</strong>：这在大多数场景下是不可行的，因为我们使用锁的目的就是为了保证互斥。但可以考虑使用更乐观的并发策略，如使用 <strong>CAS (Compare-And-Swap)</strong> 操作（详见 <code>4.1 原子操作类</code>），它不涉及阻塞，也就不存在死锁问题。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-2-线程安全的设计方式"><a href="#5-2-线程安全的设计方式" class="headerlink" title="5.2 线程安全的设计方式"></a>5.2 线程安全的设计方式</h3><p><strong>线程安全</strong>的核心在于<strong>正确地管理共享的可变状态 (Shared Mutable State)</strong>。当多个线程需要访问和修改同一个对象或数据时，如果没有采取正确的措施，就会导致数据不一致、程序崩溃等各种问题。</p>
<p>设计线程安全的代码，本质上就是围绕如何处理这个“共享的可变状态”来展开。主要的设计思路可以分为三大类：<strong>避免共享、不可变、安全共享</strong>。</p>
<h4 id="5-2-1-避免共享-Avoid-Sharing-从根源上杜绝问题"><a href="#5-2-1-避免共享-Avoid-Sharing-从根源上杜绝问题" class="headerlink" title="5.2.1 避免共享 (Avoid Sharing) - 从根源上杜绝问题"></a>5.2.1 避免共享 (Avoid Sharing) - 从根源上杜绝问题</h4><p>这是最简单、最安全的策略。如果没有共享数据，那么每个线程操作的都是自己的数据，自然就不会有线程安全问题。</p>
<h5 id="1-栈封闭-Stack-Confinement"><a href="#1-栈封闭-Stack-Confinement" class="headerlink" title="1. 栈封闭 (Stack Confinement)"></a>1. 栈封闭 (Stack Confinement)</h5><ul>
<li><p><strong>概念</strong>：将数据完全限制在线程的栈（Stack）上。最典型的就是方法的<strong>局部变量</strong>。</p>
</li>
<li><p><strong>原理</strong>：每个线程都有自己独立的虚拟机栈，局部变量存储在栈帧中，是线程私有的，其他线程无法访问。因此，局部变量永远是线程安全的。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// userRequest 和 connection 都是局部变量，是线程安全的</span></span><br><span class="line">    <span class="type">UserRequest</span> <span class="variable">userRequest</span> <span class="operator">=</span> parseRequest();</span><br><span class="line">    <span class="type">DBConnection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionManager.getConnection();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在方法内部使用，不会被其他线程访问</span></span><br><span class="line">    connection.execute(userRequest.getSql());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意</strong>：如果局部变量是一个<strong>对象引用</strong>，要确保这个对象没有“逃逸”(escape)出当前方法的作用域，即没有被赋值给类的成员变量，或者作为返回值返回给其他线程可能访问的地方。</p>
</li>
</ul>
<hr>
<h5 id="2-线程封闭-Thread-Confinement"><a href="#2-线程封闭-Thread-Confinement" class="headerlink" title="2. 线程封闭 (Thread Confinement)"></a>2. 线程封闭 (Thread Confinement)</h5><ul>
<li><p><strong>概念</strong>：当无法使用栈封闭时，可以通过设计将一个可变对象“封闭”或“限制”在单个线程内部，不允许其他线程访问它。</p>
</li>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li><strong>Ad-hoc 线程封闭</strong>：这是一种纯粹靠程序设计纪律来保证的线程封闭。例如，在一个单线程的 Executor 中处理任务，所有任务操作的对象都自然地被封闭在该 Executor 的工作线程中。这种方式非常脆弱，需要团队有严格的编码规范。</li>
<li><strong><code>ThreadLocal</code> 类</strong>： 为每个使用该变量的线程都提供一个独立的变量副本，每个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</li>
</ul>
</li>
<li><p><strong><code>ThreadLocal</code> 示例与注意事项</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContextHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ThreadLocal 变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; holder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        holder.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 关键：用完后务必清理，防止内存泄漏</span></span><br><span class="line">        holder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Web 过滤器或拦截器中使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getUserFromRequest(req);</span><br><span class="line">        UserContextHolder.set(user);</span><br><span class="line">        chain.doFilter(req, res);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 必须在 finally 块中调用 remove()</span></span><br><span class="line">        UserContextHolder.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心注意点</strong>：在使用线程池的场景下，线程是会被复用的。如果不调用<code>remove()</code>，那么上一个请求在该线程中设置的数据会“污染”下一个使用该线程的请求，并可能导致内存泄漏。</p>
</li>
</ul>
<hr>
<h4 id="5-2-2-不可变-Immutability-让共享变得安全"><a href="#5-2-2-不可变-Immutability-让共享变得安全" class="headerlink" title="5.2.2 不可变 (Immutability) - 让共享变得安全"></a>5.2.2 不可变 (Immutability) - 让共享变得安全</h4><p>如果共享的数据是不可变的，那么它天生就是线程安全的。因为所有线程都只能读取它，不能修改它，所以无论多少线程同时访问，都不会产生数据不一致的问题。</p>
<ul>
<li><p><strong>定义</strong>：一个对象的状态在创建之后就不能再被修改。</p>
</li>
<li><p><strong>实现不可变对象的规则</strong>：</p>
<ol>
<li>类声明为 <code>final</code>，防止被继承。</li>
<li>所有成员变量都声明为 <code>private</code> 和 <code>final</code>。</li>
<li>不提供任何可以修改状态的 “setter” 方法。</li>
<li>如果成员变量是可变对象（如 <code>Date</code>, <code>List</code>），在构造函数和 getter 方法中要进行<strong>防御性拷贝 (Defensive Copy)</strong>，确保外部代码无法通过引用修改内部状态。</li>
</ol>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImmutableUserInfo</span> &#123; <span class="comment">// 1. final class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;         <span class="comment">// 2. private final 字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; permissions; <span class="comment">// 4. 可变对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImmutableUserInfo</span><span class="params">(String name, <span class="type">int</span> age, List&lt;String&gt; permissions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="comment">// 4. 构造时进行防御性拷贝</span></span><br><span class="line">        <span class="built_in">this</span>.permissions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(permissions); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 只有 getter, 没有 setter</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getPermissions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 返回时也进行防御性拷贝</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(permissions); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JDK 中的例子</strong>：<code>String</code>、<code>Integer</code> 等包装类。</p>
</li>
</ul>
<hr>
<h4 id="5-2-3-安全共享-Safe-Sharing-精细化管理并发访问"><a href="#5-2-3-安全共享-Safe-Sharing-精细化管理并发访问" class="headerlink" title="5.2.3 安全共享 (Safe Sharing) - 精细化管理并发访问"></a>5.2.3 安全共享 (Safe Sharing) - 精细化管理并发访问</h4><p>当状态必须是可变且共享的时候，我们就需要使用同步机制来保证线程安全。</p>
<h5 id="1-同步-Synchronization"><a href="#1-同步-Synchronization" class="headerlink" title="1. 同步 (Synchronization)"></a>1. 同步 (Synchronization)</h5><p>使用锁来保证在同一时刻，只有一个线程可以访问共享的可变状态。</p>
<ul>
<li><p><strong><code>synchronized</code> 关键字</strong>：</p>
<ul>
<li><strong>同步方法</strong>：<code>public synchronized void increment() { count++; }</code>，锁是当前对象实例 (<code>this</code>)。</li>
<li><strong>同步代码块</strong>：<code>synchronized(lockObject) { ... }</code>，提供更细粒度的控制，锁是 <code>lockObject</code> 对象。</li>
<li><strong>最佳实践</strong>：<ol>
<li><strong>减小锁的粒度</strong>：<code>synchronized</code> 代码块应尽可能小，只包含必须同步的代码，以提高并发性。</li>
<li><strong>使用私有锁对象</strong>：<code>private final Object lock = new Object();</code>，避免使用 <code>this</code> 或公开的对象作为锁，防止外部代码无意中获取了你的锁而导致死锁或活性问题。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>JUC <code>Lock</code> 接口 (<code>ReentrantLock</code> 等)</strong>：</p>
<ul>
<li><p>相比 <code>synchronized</code> 提供了更高级的功能，如：可中断的锁获取、可超时的锁获取、公平性选择、一个锁绑定多个条件变量 (Condition)。</p>
</li>
<li><p><strong>标准使用范式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performAction</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... 访问共享资源的代码 ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 必须在 finally 块中释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-使用线程安全的容器"><a href="#2-使用线程安全的容器" class="headerlink" title="2. 使用线程安全的容器"></a>2. 使用线程安全的容器</h5><p>JDK 在 <code>java.util.concurrent</code> (JUC) 包中提供了大量高性能的线程安全容器，应当优先使用它们，而不是自己去同步 <code>ArrayList</code> 或 <code>HashMap</code>。</p>
<ul>
<li><code>ConcurrentHashMap</code>：高性能的线程安全哈希表，是 <code>Hashtable</code> 和 <code>Collections.synchronizedMap</code> 的优选替代品。</li>
<li><code>CopyOnWriteArrayList</code>：<strong>读多写少</strong>场景下的利器。读取操作完全不加锁，性能极高。写入操作（add, set, remove）时，会复制一份底层数组，在新数组上修改，然后将引用指向新数组。写入成本高，但保证了读写的绝对分离。非常适合用于事件监听器列表等场景。</li>
<li><code>BlockingQueue</code> (如 <code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>)：阻塞队列，是实现<strong>生产者-消费者</strong>模式的基石，线程池的内部实现也依赖它。它封装了所有同步细节，使用者只需调用 <code>put()</code> 和 <code>take()</code> 方法即可。</li>
</ul>
<hr>
<h5 id="3-使用原子变量-Atomic-Variables"><a href="#3-使用原子变量-Atomic-Variables" class="headerlink" title="3. 使用原子变量 (Atomic Variables)"></a>3. 使用原子变量 (Atomic Variables)</h5><p>对于简单的、单一的数值操作（如计数器），使用锁的开销可能过大。JUC 的 <code>java.util.concurrent.atomic</code> 包提供了一系列原子类。</p>
<ul>
<li><p><strong>原理</strong>：基于硬件级别的 <strong>CAS (Compare-And-Swap)</strong> 指令，这是一种乐观的、非阻塞的同步技术。</p>
</li>
<li><p><strong>示例</strong>：实现一个线程安全的计数器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不安全的计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123; count++; &#125; <span class="comment">// 非原子操作，线程不安全</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 AtomicInteger 的安全计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">safeIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    atomicCount.incrementAndGet(); <span class="comment">// 原子操作，线程安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>：在高并发下，性能通常优于基于锁的实现，因为它避免了线程的阻塞和上下文切换。</p>
</li>
</ul>
<hr>
<h4 id="5-2-4-原子性问题"><a href="#5-2-4-原子性问题" class="headerlink" title="5.2.4 原子性问题"></a>5.2.4 原子性问题</h4><p>一个或多个操作，要么全部执行成功，要么全部不执行，中间不能被任何其他线程中断。</p>
<h5 id="1-发生原子性错误的代码"><a href="#1-发生原子性错误的代码" class="headerlink" title="1. 发生原子性错误的代码"></a>1. 发生原子性错误的代码</h5><p>在这个版本中，共享变量 <code>count</code> 没有使用任何同步机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicityErrorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非原子性的自增方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这个操作不是原子的</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM_THREADS</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ITERATIONS_PER_THREAD</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXPECTED_COUNT</span> <span class="operator">=</span> NUM_THREADS * ITERATIONS_PER_THREAD;</span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicityErrorExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicityErrorExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程列表</span></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ITERATIONS_PER_THREAD; j++) &#123;</span><br><span class="line">                    example.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动所有线程</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;期望的最终结果: &quot;</span> + EXPECTED_COUNT);</span><br><span class="line">        System.out.println(<span class="string">&quot;实际的最终结果: &quot;</span> + example.getCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (example.getCount() != EXPECTED_COUNT) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;错误：发生了原子性问题！实际结果小于期望结果。&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;丢失的更新次数: &quot;</span> + (EXPECTED_COUNT - example.getCount()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜！在本次运行中未发生原子性问题（小概率事件）。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">期望的最终结果: <span class="number">100000</span></span><br><span class="line">实际的最终结果: <span class="number">15245</span></span><br><span class="line">------------------------------------</span><br><span class="line">错误：发生了原子性问题！实际结果小于期望结果。</span><br><span class="line">丢失的更新次数: <span class="number">84755</span></span><br></pre></td></tr></table></figure>

<p><strong>问题分析</strong> </p>
<p>假设 <code>count</code> 当前值为 <code>100</code>，线程A和线程B同时执行 <code>increment()</code>：</p>
<ol>
<li><strong>线程A</strong> 读取 <code>count</code> 的值，得到 <code>100</code>。</li>
<li><strong>线程B</strong> 也读取 <code>count</code> 的值，同样得到 <code>100</code>。（此时线程A还没来得及把新值写回去）</li>
<li><strong>线程A</strong> 在自己的工作内存中计算 <code>100 + 1</code>，得到 <code>101</code>。</li>
<li><strong>线程B</strong> 也在自己的工作内存中计算 <code>100 + 1</code>，得到 <code>101</code>。</li>
<li><strong>线程A</strong> 将 <code>101</code> 写回主内存，此时 <code>count</code> 变为 <code>101</code>。</li>
<li><strong>线程B</strong> 也将 <code>101</code> 写回主内存，此时 <code>count</code> 仍然是 <code>101</code>。</li>
</ol>
<p><strong>结果</strong>：两个线程都执行了自增操作，但 <code>count</code> 的值只增加了1。一次自增操作被“丢失”了。当成千上万次这样的操作发生时，最终的结果会远小于期望值。</p>
<h5 id="2-使用-synchronized-解决原子性错误"><a href="#2-使用-synchronized-解决原子性错误" class="headerlink" title="2. 使用 synchronized 解决原子性错误"></a>2. 使用 <code>synchronized</code> 解决原子性错误</h5><p><code>synchronized</code> 关键字可以保证同一时刻只有一个线程能进入被它修饰的代码块或方法，从而保证了操作的原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 synchronized 解决原子性问题的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicityFixedWithSynchronized</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 关键字确保方法的原子性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ... (main 方法与上面的例子完全相同)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM_THREADS</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ITERATIONS_PER_THREAD</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXPECTED_COUNT</span> <span class="operator">=</span> NUM_THREADS * ITERATIONS_PER_THREAD;</span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicityFixedWithSynchronized</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicityFixedWithSynchronized</span>();</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ITERATIONS_PER_THREAD; j++) &#123;</span><br><span class="line">                    example.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123; t.start(); &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123; t.join(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;期望的最终结果: &quot;</span> + EXPECTED_COUNT);</span><br><span class="line">        System.out.println(<span class="string">&quot;实际的最终结果: &quot;</span> + example.getCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (example.getCount() == EXPECTED_COUNT) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正确：使用了 synchronized，结果符合预期。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>synchronized</code> 的作用</strong>：它为 <code>increment</code> 方法上了一把锁。任何线程想要执行这个方法，必须先获得这把锁。执行完毕后，释放锁。这样就保证了 “读取-修改-写入” 这三步作为一个不可分割的整体来执行。</p>
<h5 id="3-使用-AtomicInteger-解决原子性错误"><a href="#3-使用-AtomicInteger-解决原子性错误" class="headerlink" title="3. 使用 AtomicInteger 解决原子性错误"></a>3. 使用 <code>AtomicInteger</code> 解决原子性错误</h5><p>对于计数器这样的场景，Java 并发包（J.U.C）提供了更高效的原子类，如 <code>AtomicInteger</code>。它使用了一种称为**CAS（Compare-And-Swap）**的无锁技术，性能通常比 <code>synchronized</code> 更好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 AtomicInteger 解决原子性问题的类 (推荐方式)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicityFixedWithAtomic</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子类 AtomicInteger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原子类的原子方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (main 方法与上面的例子完全相同, 只需修改类名)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXPECTED_COUNT</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">10000</span>;</span><br><span class="line">        <span class="type">AtomicityFixedWithAtomic</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicityFixedWithAtomic</span>();</span><br><span class="line">        <span class="comment">// ... (线程创建、启动、等待逻辑不变)</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;期望的最终结果: &quot;</span> + EXPECTED_COUNT);</span><br><span class="line">        System.out.println(<span class="string">&quot;实际的最终结果: &quot;</span> + example.getCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (example.getCount() == EXPECTED_COUNT) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正确：使用了 AtomicInteger，结果符合预期。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>AtomicInteger</code> 的作用</strong>：<code>incrementAndGet()</code> 方法是一个原子操作。它在硬件级别上得到支持，能够在一个指令周期内完成 “比较并交换” 的操作，从而避免了传统锁的开销。</p>
<hr>
<h4 id="5-2-5-可见性"><a href="#5-2-5-可见性" class="headerlink" title="5.2.5 可见性"></a>5.2.5 可见性</h4><p>当一个线程修改了共享变量的值，其他线程能够立即看到这个修改。由于CPU缓存的存在，一个线程对共享变量的修改可能只存在于自己的CPU缓存中，而没有及时写回主内存，导致其他线程读取到的仍然是旧值。</p>
<h5 id="1-发生可见性错误的代码"><a href="#1-发生可见性错误的代码" class="headerlink" title="1. 发生可见性错误的代码"></a>1. 发生可见性错误的代码</h5><p>在这个版本中，共享变量 <code>running</code> 没有使用任何同步机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程已启动...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 如果循环体内部为空，JIT编译器更容易进行优化，</span></span><br><span class="line">            <span class="comment">// 导致它可能只从CPU缓存中读取running的值。</span></span><br><span class="line">            <span class="comment">// 为了让问题更容易复现，我们在这里做一个简单的计数。</span></span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程已停止。 Counter = &quot;</span> + counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        workerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠1秒，确保工作线程已经开始运行并可能缓存了 running 的值</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程修改共享变量 running 的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程尝试停止工作线程...&quot;</span>);</span><br><span class="line">        myThread.running = <span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程已将 running 设置为 false&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待工作线程结束，如果发生可见性问题，程序会卡在这里</span></span><br><span class="line">        workerThread.join(<span class="number">2000</span>); <span class="comment">// 最多等待2秒</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(workerThread.isAlive()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;错误：工作线程未能按预期停止！可见性问题发生。&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;程序将无法正常退出。&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;程序正常结束。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">工作线程已启动...</span><br><span class="line">主线程尝试停止工作线程...</span><br><span class="line">主线程已将 running 设置为 <span class="literal">false</span></span><br><span class="line">------------------------------------</span><br><span class="line">错误：工作线程未能按预期停止！可见性问题发生。</span><br><span class="line">程序将无法正常退出。</span><br><span class="line">------------------------------------</span><br><span class="line">(程序会一直挂起，不会自动终止)</span><br></pre></td></tr></table></figure>

<p><strong>问题分析</strong></p>
<ol>
<li><strong>CPU 缓存</strong>：每个CPU核心都有自己的高速缓存（L1, L2 Cache）。工作线程启动后，可能会将主内存中的 <code>running = true</code> 读取到自己的CPU缓存中。</li>
<li><strong>JIT 编译器优化</strong>：Java的即时（JIT）编译器在运行时会优化代码。对于 <code>while(running)</code> 这样的循环，如果它检测到循环体内没有修改 <code>running</code> 的代码，它可能会做出一个假设：<code>running</code> 的值不会改变。于是，它可能将代码优化为类似 <code>if(running) { while(true) { ... } }</code> 的形式，只在循环开始前检查一次 <code>running</code>。</li>
<li><strong>结果</strong>：当主线程在主内存中将 <code>running</code> 修改为 <code>false</code> 时，工作线程由于以上原因，可能仍然从自己的缓存中读取旧的 <code>true</code> 值，或者由于JIT优化，根本不再检查 <code>running</code> 的值，导致循环无法停止。</li>
</ol>
<h5 id="2-使用-volatile-解决可见性错误"><a href="#2-使用-volatile-解决可见性错误" class="headerlink" title="2. 使用 volatile 解决可见性错误"></a>2. 使用 <code>volatile</code> 解决可见性错误</h5><p>现在，我们通过为 <code>running</code> 变量添加 <code>volatile</code> 关键字来解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程已启动...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 如果循环体内部为空，JIT编译器更容易进行优化，</span></span><br><span class="line">            <span class="comment">// 导致它可能只从CPU缓存中读取running的值。</span></span><br><span class="line">            <span class="comment">// 为了让问题更容易复现，我们在这里做一个简单的计数。</span></span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程已停止。 Counter = &quot;</span> + counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        workerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠1秒，确保工作线程已经开始运行并可能缓存了 running 的值</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程修改共享变量 running 的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程尝试停止工作线程...&quot;</span>);</span><br><span class="line">        myThread.running = <span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程已将 running 设置为 false&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待工作线程结束，如果发生可见性问题，程序会卡在这里</span></span><br><span class="line">        workerThread.join(<span class="number">2000</span>); <span class="comment">// 最多等待2秒</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(workerThread.isAlive()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;错误：工作线程未能按预期停止！可见性问题发生。&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;程序将无法正常退出。&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;程序正常结束。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">工作线程已启动...</span><br><span class="line">主线程尝试停止工作线程...</span><br><span class="line">主线程已将 running 设置为 <span class="literal">false</span></span><br><span class="line">工作线程已停止。 Counter = -<span class="number">1237374496</span></span><br><span class="line">程序正常结束。</span><br></pre></td></tr></table></figure>

<p><strong><code>volatile</code> 关键字的作用</strong></p>
<p><code>volatile</code> 关键字能提供两个重要的保证：</p>
<ol>
<li><strong>可见性（Visibility）</strong>：<ul>
<li>当一个线程<strong>写入</strong>一个 <code>volatile</code> 变量时，JMM（Java内存模型）会强制将该线程工作内存（CPU缓存）中的值立即刷新到主内存中。</li>
<li>当一个线程<strong>读取</strong>一个 <code>volatile</code> 变量时，JMM会强制让该线程的工作内存（CPU缓存）失效，并从主内存中重新读取最新值。</li>
</ul>
</li>
<li><strong>有序性（Ordering）</strong>：<ul>
<li>禁止指令重排序优化。确保 <code>volatile</code> 变量之前的代码都执行完毕，<code>volatile</code> 变量之后执行的代码都在它之后执行（建立所谓的 “happens-before” 关系）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-2-6-有序性"><a href="#5-2-6-有序性" class="headerlink" title="5.2.6 有序性"></a>5.2.6 有序性</h4><p>为了提高性能，编译器和处理器可能会对指令进行重排序。在单线程中，这不会影响最终结果。但在多线程中，重排序可能会破坏逻辑上的先后关系，导致意想不到的错误。</p>
<h5 id="1-发生有序性错误的代码"><a href="#1-发生有序性错误的代码" class="headerlink" title="1. 发生有序性错误的代码"></a>1. 发生有序性错误的代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示指令重排序（有序性）问题的类</span></span><br><span class="line"><span class="comment"> * 这个错误不是每次都发生，需要多次运行来触发。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstructionReorderingError</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 用来存储读线程的计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写线程执行的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这两行代码理论上可能被重排序</span></span><br><span class="line">        a = <span class="number">1</span>;         <span class="comment">// 操作1</span></span><br><span class="line">        flag = <span class="literal">true</span>;   <span class="comment">// 操作2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读线程执行的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;      <span class="comment">// 操作3</span></span><br><span class="line">            result = a * a; <span class="comment">// 操作4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="type">InstructionReorderingError</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstructionReorderingError</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建写线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">writerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::writer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建读线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::reader);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同时启动两个线程</span></span><br><span class="line">            writerThread.start();</span><br><span class="line">            readerThread.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待两个线程执行完毕</span></span><br><span class="line">            writerThread.join();</span><br><span class="line">            readerThread.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查结果</span></span><br><span class="line">            <span class="comment">// 如果 result == 0，说明读线程在 flag=true 时，读到的 a 仍然是 0。</span></span><br><span class="line">            <span class="comment">// 这就证明了 writer 线程中的 a=1 和 flag=true 发生了重排序。</span></span><br><span class="line">            <span class="comment">// 读线程看到了重排序后的结果：先执行了 flag=true，然后才执行 a=1。</span></span><br><span class="line">            <span class="keyword">if</span> (example.result == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">                System.out.printf(<span class="string">&quot;错误发生在第 %d 次执行！\n&quot;</span>, count);</span><br><span class="line">                System.out.println(<span class="string">&quot;Result is 0, which means reordering occurred.&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Reader thread saw flag=true, but a was still 0.&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 找到错误后退出循环</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 为了避免无限输出，可以注释掉这部分</span></span><br><span class="line">                <span class="comment">// System.out.printf(&quot;第 %d 次执行：正常, result = %d\n&quot;, count, example.result);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">------------------------------------</span><br><span class="line">错误发生在第 [一个比较大的数字] 次执行！</span><br><span class="line">Result is <span class="number">0</span>, which means reordering occurred.</span><br><span class="line">Reader thread saw flag=<span class="literal">true</span>, but a was still <span class="number">0.</span></span><br><span class="line">------------------------------------</span><br></pre></td></tr></table></figure>

<p><strong>问题分析</strong></p>
<ol>
<li><strong>代码的逻辑顺序</strong>：<code>writer()</code> 方法中，我们希望 <code>a = 1</code> 在 <code>flag = true</code> 之前执行。</li>
<li><strong>可能的执行顺序 (重排序后)</strong>：<ul>
<li><code>flag = true;</code></li>
<li><code>a = 1;</code></li>
</ul>
</li>
<li><strong>线程交叉执行</strong>：<ul>
<li><strong>写线程</strong>：执行了重排序后的第一步 <code>flag = true;</code>，然后CPU时间片切换。</li>
<li><strong>读线程</strong>：开始执行，检查 <code>if (flag)</code>，发现 <code>flag</code> 已经是 <code>true</code>。</li>
<li><strong>读线程</strong>：进入 <code>if</code> 语句块，执行 <code>result = a * a;</code>。但此时写线程的 <code>a = 1</code> 还没有执行，所以 <code>a</code> 的值仍然是 <code>0</code>。<code>result</code> 被计算为 <code>0</code>。</li>
<li><strong>程序错误</strong>：程序出现了一个不符合预期的结果。我们期望 <code>result</code> 的值要么是 <code>-1</code> (读线程先执行完)，要么是 <code>1</code> (写线程正常执行完)，但绝不应该是 <code>0</code>。<code>result == 0</code> 就是指令重排序的铁证。</li>
</ul>
</li>
</ol>
<h5 id="2-使用-volatile-解决有序性错误"><a href="#2-使用-volatile-解决有序性错误" class="headerlink" title="2. 使用 volatile 解决有序性错误"></a>2. 使用 <code>volatile</code> 解决有序性错误</h5><p><code>volatile</code> 关键字除了保证可见性，还能禁止指令重排序，从而解决这个问题。</p>
<p>我们将 <code>flag</code> 变量声明为 <code>volatile</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 volatile 解决指令重排序问题的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstructionReorderingFixed</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 使用 volatile 修饰 flag 变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 对 volatile 变量的写操作，会确保在此之前的普通写操作都已完成，</span></span><br><span class="line">        <span class="comment">// 并且结果对其他线程可见。</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 对 volatile 变量的读操作，会确保在此之后的所有读操作都能看到之前写入的值。</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            result = a * a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 运行这个版本，程序将永远不会打印出错误信息，会一直运行下去。</span></span><br><span class="line">        <span class="comment">// 因为 volatile 保证了有序性。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="type">InstructionReorderingFixed</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstructionReorderingFixed</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">writerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::writer);</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::reader);</span><br><span class="line"></span><br><span class="line">            writerThread.start();</span><br><span class="line">            readerThread.start();</span><br><span class="line"></span><br><span class="line">            writerThread.join();</span><br><span class="line">            readerThread.join();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (example.result == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这段代码理论上永远不会被执行</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;错误！在第 %d 次执行时，result 仍然为 0！\n&quot;</span>, count);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">100000</span> == <span class="number">0</span>) &#123; <span class="comment">// 每10万次打印一次，证明程序在正常运行</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;已正常执行 %d 次...\n&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>volatile</code> 如何解决有序性问题</strong></p>
<p><code>volatile</code> 通过**内存屏障（Memory Barrier）**来禁止指令重排序，它遵循以下规则：</p>
<ol>
<li><strong>写 volatile 变量</strong>：当程序向一个 <code>volatile</code> 变量写入时（如 <code>flag = true</code>），JMM会插入一个<strong>写屏障</strong>。这个屏障会确保：<ul>
<li>在此屏障之前的所有普通变量的写入（如 <code>a = 1</code>）都已经被刷新到主内存。</li>
<li>禁止屏障之前的写操作与屏障之后的写操作重排序。</li>
</ul>
</li>
<li><strong>读 volatile 变量</strong>：当程序读取一个 <code>volatile</code> 变量时（如 <code>if (flag)</code>），JMM会插入一个<strong>读屏障</strong>。这个屏障会确保：<ul>
<li>禁止屏障之后的读操作与屏障之前的读操作重排序。</li>
</ul>
</li>
</ol>
<p>这个机制建立了一个 <strong>“happens-before”</strong> 关系：对 <code>volatile</code> 变量 <code>flag</code> 的写操作 <em>happens-before</em> 任何后续对 <code>flag</code> 的读操作。因此，当读线程读到 <code>flag</code> 为 <code>true</code> 时，它也一定能看到在写 <code>flag</code> 之前发生的所有操作的结果，即 <code>a = 1</code>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%85%AB%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%85%AB%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">八、网络编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:35:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:35:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-23 11:32:53" itemprop="dateModified" datetime="2025-11-23T11:32:53+08:00">2025-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="八、网络编程"><a href="#八、网络编程" class="headerlink" title="八、网络编程"></a>八、网络编程</h1><h2 id="1-网络编程基础三要素"><a href="#1-网络编程基础三要素" class="headerlink" title="1. 网络编程基础三要素"></a>1. 网络编程基础三要素</h2><h3 id="1-1-IP地址-IP-Address"><a href="#1-1-IP地址-IP-Address" class="headerlink" title="1.1  IP地址 (IP Address)"></a>1.1  IP地址 (IP Address)</h3><h4 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1 定义"></a>1.1.1 <strong>定义</strong></h4><p>IP地址是网络中设备的唯一标识符，如同现实世界中的门牌号码。它负责在复杂的网络环境中定位到具体的<strong>主机</strong>。</p>
<hr>
<h4 id="1-1-2-版本"><a href="#1-1-2-版本" class="headerlink" title="1.1.2 版本"></a>1.1.2 版本</h4><h5 id="1-IPv4"><a href="#1-IPv4" class="headerlink" title="1. IPv4"></a>1. IPv4</h5><p><strong>全称</strong>：Internet Protocol version 4，互联网通信协议第四版</p>
<p><strong>格式</strong>：采用32位地址，格式为<code>A.B.C.D</code>（点分十进制），约有42亿个地址。目前仍在广泛使用，但已基本耗尽。</p>
<p><strong>分类形式</strong></p>
<ul>
<li>公网地址（万维网使用）和私有地址（局域网使用）</li>
<li>常用CMD命令<ul>
<li>ipconfig：查看本机IP地址</li>
<li>ping：检查网络是否联通(+IP或网址)</li>
</ul>
</li>
</ul>
<h5 id="2-IPv6"><a href="#2-IPv6" class="headerlink" title="2. IPv6"></a>2. IPv6</h5><p><strong>全称</strong>：Internet Protocol version 6，互联网通信协议第六版</p>
<p><strong>格式</strong>：采用128位地址长度，格式为<code>A:B:C:D:E:F:G</code>（冒分十六进制表示,如果中间有多个连续的0使用0位压缩表示法）</p>
<hr>
<h4 id="1-1-3-特殊IP地址"><a href="#1-1-3-特殊IP地址" class="headerlink" title="1.1.3 特殊IP地址"></a>1.1.3 特殊IP地址</h4><p><code>127.0.0.1</code> (或 <code>localhost</code>): 本地回环地址，指向本机。常用于本地测试。</p>
<p><code>192.168</code>开头的就是私有地址，范围位<code>192.168.0.0</code>-<code>192.168.255.255</code>，专门为了组织机构内部使用，节省IP</p>
<p><code>0.0.0.0</code>: 代表本机上的所有IP地址。当服务器监听<code>0.0.0.0</code>时，意味着它可以接受来自本机任何网卡接口的连接请求。</p>
<hr>
<h4 id="1-1-4-Java中的体现"><a href="#1-1-4-Java中的体现" class="headerlink" title="1.1.4  Java中的体现"></a>1.1.4  Java中的体现</h4><p><code>InetAddress</code>类是Java对IP地址的封装。它没有公共构造函数，只能通过静态方法获取实例。</p>
<p><strong>核心方法</strong>:</p>
<ul>
<li><code>InetAddress.getByName(&quot;www.google.com&quot;)</code>: 通过域名获取<code>InetAddress</code>对象。</li>
<li><code>InetAddress.getLocalHost()</code>: 获取本地主机的<code>InetAddress</code>对象。</li>
<li><code>getHostName()</code>: 获取主机名。</li>
<li><code>getHostAddress()</code>: 获取IP地址字符串。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取本地主机的InetAddress对象</span></span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">    System.out.println(<span class="string">&quot;Local Host: &quot;</span> + localHost);</span><br><span class="line">    <span class="comment">// 获取本地主机的主机名</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Local Host Name: &quot;</span> + localHost.getHostName());</span><br><span class="line">    <span class="comment">// 获取本地主机的IP地址</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Local Host Address: &quot;</span> + localHost.getHostAddress());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据主机名获取远程主机的InetAddress对象</span></span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">remoteHost</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取远程主机的主机名</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Remote Host Name: &quot;</span> + remoteHost.getHostName());</span><br><span class="line">    <span class="comment">// 获取远程主机的IP地址</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Remote IP Address: &quot;</span> + remoteHost.getHostAddress());</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">    <span class="comment">// 捕获未知主机异常并打印错误信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Error getting local host&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-端口号"><a href="#1-2-端口号" class="headerlink" title="1.2 端口号"></a>1.2 端口号</h3><p><strong>定义</strong>: 如果IP地址定位了主机，那么端口号就是用来定位主机上的具体<strong>应用程序（进程）</strong>。它是一个16位的无符号整数，范围是<code>0</code>到<code>65535</code>。</p>
<p><strong>作用</strong>: 使得一台主机可以同时运行多个网络服务（如Web服务、FTP服务、数据库服务）。IP地址和端口号的组合 <code>(IP:Port)</code> 构成了一个网络套接字地址（Socket Address），唯一标识了网络中的一个通信端点。</p>
<p><strong>端口分类</strong>:</p>
<ul>
<li><strong>公认端口 (Well-Known Ports)</strong>: <code>0</code> ~ <code>1023</code>。被预留给一些知名的服务，如HTTP(80), HTTPS(443), FTP(21), SSH(22)。</li>
<li><strong>注册端口 (Registered Ports)</strong>: <code>1024</code> ~ <code>49151</code>。分配给用户进程或应用程序，如MySQL(3306), Tomcat(8080), Oracle(1521)。</li>
<li><strong>动态&#x2F;私有端口 (Dynamic&#x2F;Private Ports)</strong>: <code>49152</code> ~ <code>65535</code>。通常由客户端在建立连接时动态分配。</li>
</ul>
<hr>
<h3 id="1-3-协议"><a href="#1-3-协议" class="headerlink" title="1.3 协议"></a>1.3 协议</h3><p><strong>定义：</strong></p>
<ul>
<li><p><strong>现实世界中的类比</strong>：</p>
<ul>
<li><strong>语言</strong>：想象一下，一个说中文的人和一个说英语的人，如果他们之间没有一个共同的语言（比如都说英语）或者一个翻译，他们就无法沟通。这个“共同的语言”就是一种协议。</li>
<li><strong>交通规则</strong>：红灯停，绿灯行。这是一个所有司机都必须遵守的规则，它确保了交通的有序和安全。这个“交通规则”也是一种协议。</li>
</ul>
</li>
<li><p><strong>计算机世界中的定义</strong>：<br>在计算机网络中，<strong>协议就是一套双方或多方都必须共同遵守的规则、标准或约定</strong>。它规定了计算机之间如何建立连接、如何交换信息。</p>
<p>协议通常定义了以下内容：</p>
<ul>
<li><strong>数据格式 (Syntax)</strong>：信息的结构和格式是怎样的？（比如，先发送什么，后发送什么，用什么编码？）</li>
<li><strong>语义 (Semantics)</strong>：信息中各个部分的具体含义是什么？（比如，某个代码 <code>200</code> 代表“成功”，<code>404</code> 代表“找不到”。）</li>
<li><strong>时序 (Timing)</strong>：通信的先后顺序是怎样的？（比如，谁先发起请求？收到请求后应该做什么？）</li>
</ul>
</li>
</ul>
<p><strong>核心作用</strong>: 确保数据能够被正确地发送、接收和理解。</p>
<hr>
<h3 id="1-4-DNS-Domain-Name-System-域名系统"><a href="#1-4-DNS-Domain-Name-System-域名系统" class="headerlink" title="1.4 DNS (Domain Name System - 域名系统)"></a>1.4 DNS (Domain Name System - 域名系统)</h3><h4 id="1-4-1-定义与作用"><a href="#1-4-1-定义与作用" class="headerlink" title="1.4.1 定义与作用"></a>1.4.1 定义与作用</h4><p>DNS 是一个<strong>分层的、分布式的命名系统</strong>，用于将<strong>域名 (Domain Name)</strong>（如 <code>www.google.com</code>）解析成计算机网络能够理解的 <strong>IP 地址</strong>（如 <code>172.217.160.68</code>）。</p>
<ul>
<li><strong>核心作用</strong>：解决了IP地址难于记忆的问题。如果没有DNS，我们访问网站就必须记住一长串数字，这几乎是不可能的。DNS 就像一本互联网的电话簿，我们提供一个名字（域名），它告诉我们对应的电话号码（IP地址）。</li>
<li><strong>为何是“分层”和“分布式”</strong>：<ul>
<li><strong>分层 (Hierarchical)</strong>：域名结构是树状的，例如 <code>.com</code> 是顶级域，<code>google.com</code> 是二级域，<code>www.google.com</code> 是三级域。这种结构便于管理。</li>
<li><strong>分布式 (Distributed)</strong>：没有任何一台服务器存有互联网上所有域名和IP的对应关系。这些信息被分散存储在全球成千上万的DNS服务器上，提高了系统的可靠性和可伸缩性。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-4-2-DNS-查询过程（域名解析过程）"><a href="#1-4-2-DNS-查询过程（域名解析过程）" class="headerlink" title="1.4.2 DNS 查询过程（域名解析过程）"></a>1.4.2 DNS 查询过程（域名解析过程）</h4><p>当你在浏览器输入 <code>www.google.com</code> 并回车时，一个复杂的查询过程在毫秒间完成：</p>
<ol>
<li><strong>检查本地缓存</strong>：<ul>
<li><strong>浏览器缓存</strong>：浏览器首先检查自己的缓存中是否有该域名的记录。</li>
<li><strong>操作系统缓存</strong>：如果浏览器缓存没有，操作系统会检查自身的缓存（如 <code>hosts</code> 文件和系统DNS缓存）。</li>
<li><strong>路由器缓存</strong>：某些路由器也会缓存DNS记录。</li>
<li>如果缓存命中，直接返回IP地址，查询结束。</li>
</ul>
</li>
<li><strong>向本地DNS服务器（LDNS）请求</strong>：<ul>
<li>如果本地缓存都没有，计算机会向其网络配置中指定的 <strong>本地DNS服务器</strong>（通常由你的互联网服务提供商ISP提供，如移动、联通）发起一个<strong>递归查询 (Recursive Query)</strong>。</li>
<li>递归查询的意思是：“请帮我找到 <code>www.google.com</code> 的IP地址，并把最终结果给我。”</li>
</ul>
</li>
<li><strong>本地DNS服务器的迭代查询 (Iterative Query)</strong>：<br>本地DNS服务器自己通常也不知道答案，于是它会代表你进行一系列<strong>迭代查询</strong>：<ul>
<li><strong>a. 查询根域名服务器 (Root Name Server)</strong>：LDNS 向全球13组根服务器中的一台发出请求：“谁知道 <code>.com</code> 的地址？” 根服务器不会直接回答最终结果，而是返回负责 <code>.com</code> 域的<strong>顶级域（TLD）名服务器</strong>的地址列表。</li>
<li><strong>b. 查询顶级域（TLD）名服务器</strong>：LDNS 接着向其中一台 <code>.com</code> 的TLD服务器发出请求：“谁知道 <code>google.com</code> 的地址？” TLD服务器同样不会给出最终答案，而是返回负责管理 <code>google.com</code> 域的<strong>权威域名服务器 (Authoritative Name Server)</strong> 的地址。这个权威服务器通常由Google自己或其域名注册商管理。</li>
<li><strong>c. 查询权威域名服务器</strong>：LDNS 最后向 <code>google.com</code> 的权威域名服务器发出请求：“<code>www.google.com</code> 的IP地址是什么？” 权威域名服务器拥有该域名的最终解释权，它会查询自己的记录，找到对应的IP地址并返回给LDNS。</li>
</ul>
</li>
<li><strong>返回结果与缓存</strong>：<ul>
<li>本地DNS服务器（LDNS）拿到IP地址后，一方面将其<strong>缓存</strong>起来（以便下次有同样请求时能快速响应），另一方面将这个IP地址返回给你的计算机。</li>
<li>你的计算机拿到IP地址后，也将其进行缓存，并最终交给浏览器。</li>
</ul>
</li>
<li><strong>建立连接</strong>：浏览器使用获取到的IP地址，与目标服务器（端口通常是80或443）建立TCP连接，开始HTTP通信。</li>
</ol>
<hr>
<h4 id="1-4-3-常见的DNS记录类型"><a href="#1-4-3-常见的DNS记录类型" class="headerlink" title="1.4.3 常见的DNS记录类型"></a>1.4.3 常见的DNS记录类型</h4><p>DNS服务器中存储的不仅仅是IP地址，还包括多种类型的记录：</p>
<ul>
<li><strong>A 记录 (Address Record)</strong>：最常见的记录，用于将域名指向一个IPv4地址。</li>
<li><strong>AAAA 记录 (IPv6 Address Record)</strong>：用于将域名指向一个IPv6地址。</li>
<li><strong>CNAME 记录 (Canonical Name Record)</strong>：别名记录。将一个域名指向另一个域名。例如，可以将 <code>ftp.example.com</code> 指向 <code>server1.example.com</code>。</li>
<li><strong>MX 记录 (Mail Exchange Record)</strong>：邮件交换记录。指定负责接收该域名的电子邮件的服务器地址。</li>
<li><strong>NS 记录 (Name Server Record)</strong>：域名服务器记录。指定该域由哪些权威域名服务器来解析。</li>
</ul>
<hr>
<h4 id="1-4-4-Java中的体现与实践"><a href="#1-4-4-Java中的体现与实践" class="headerlink" title="1.4.4 Java中的体现与实践"></a>1.4.4 Java中的体现与实践</h4><p>在Java网络编程中，DNS解析通常是<strong>隐式</strong>发生的。当你创建一个 <code>Socket</code> 或 <code>URL</code> 对象时，Java的底层网络库会自动为你完成DNS查询。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当执行这行代码时，JVM会自动进行DNS查询，将 &quot;www.google.com&quot; 解析为IP地址</span></span><br><span class="line"><span class="comment">// 然后再用该IP地址和80端口发起TCP连接。</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;www.google.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;成功连接到 Google, 远程IP: &quot;</span> + socket.getInetAddress().getHostAddress());</span><br></pre></td></tr></table></figure>

<p><strong>JVM的DNS缓存</strong>：</p>
<p>值得注意的是，JVM自身也会对DNS查询结果进行缓存，以提高性能。这个缓存的有效期可以通过JVM启动参数或Java安全策略文件进行配置。例如，<code>-Dnetworkaddress.cache.ttl=60</code> 可以将DNS缓存的有效期设置为60秒。了解这一点对于处理域名IP变更后服务不生效等问题非常重要。</p>
<hr>
<h3 id="1-5-认识-URL-统一资源定位符"><a href="#1-5-认识-URL-统一资源定位符" class="headerlink" title="1.5 认识 URL (统一资源定位符)"></a>1.5 认识 URL (统一资源定位符)</h3><p>URL，全称 <strong>Uniform Resource Locator</strong>，即“<strong>统一资源定位符</strong>”。它的作用非常直观：为互联网上的每一个资源提供一个独一无二的“地址”。就像现实世界中每家每户都有一个唯一的门牌号一样，有了 URL，浏览器才能准确地找到并访问你想要的任何资源（网页、图片、视频、API 等）。</p>
<h4 id="1-5-1-URL-的组成部分"><a href="#1-5-1-URL-的组成部分" class="headerlink" title="1.5.1 URL 的组成部分"></a>1.5.1 URL 的组成部分</h4><p>一个完整的 URL 结构看起来可能很复杂，但我们可以把它拆解成几个核心部分。以这个常见的 URL 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com:443/path/to/resource?query1=value1&amp;query2=value2#section1</span><br></pre></td></tr></table></figure>

<p>下面我们逐一解析它的构成：</p>
<table>
<thead>
<tr>
<th>部分 (Part)</th>
<th>示例值</th>
<th>英文名</th>
<th>解释说明</th>
<th>是否必需</th>
</tr>
</thead>
<tbody><tr>
<td><strong>协议 (Scheme)</strong></td>
<td><code>https</code></td>
<td>Scheme &#x2F; Protocol</td>
<td>定义了客户端应该使用哪种协议来访问资源。常见的有 <code>http</code>, <code>https</code>, <code>ftp</code>, <code>file</code> 等。它必须以 <code>:</code> 结尾。</td>
<td>是</td>
</tr>
<tr>
<td><strong>分隔符</strong></td>
<td><code>://</code></td>
<td>Delimiter</td>
<td>用于分隔协议和后面的主机部分。</td>
<td>是</td>
</tr>
<tr>
<td><strong>主机 (Host)</strong></td>
<td><code>www.example.com</code></td>
<td>Host &#x2F; Domain Name</td>
<td>标识了资源所在的服务器的域名或 IP 地址。这是网络上的“门牌号”。</td>
<td>是</td>
</tr>
<tr>
<td><strong>端口 (Port)</strong></td>
<td><code>:443</code></td>
<td>Port</td>
<td>指定了服务器上用于监听请求的“窗口”或“服务台”。每个网络服务都与一个端口号关联。</td>
<td>否 (可选)</td>
</tr>
<tr>
<td><strong>路径 (Path)</strong></td>
<td><code>/path/to/resource</code></td>
<td>Path</td>
<td>描述了资源在服务器上的具体位置，类似电脑文件系统中的文件路径。以 <code>/</code> 开头。</td>
<td>否 (可选)</td>
</tr>
<tr>
<td><strong>查询 (Query)</strong></td>
<td><code>?query1=value1&amp;query2=value2</code></td>
<td>Query &#x2F; Search</td>
<td>提供给服务器的额外参数，通常用于过滤、分页或搜索。以 <code>?</code> 开始，多个参数之间用 <code>&amp;</code> 分隔。</td>
<td>否 (可选)</td>
</tr>
<tr>
<td><strong>片段 (Fragment)</strong></td>
<td><code>#section1</code></td>
<td>Fragment</td>
<td>也称为“锚点 (Anchor)”，用于定位到资源内部的某个特定部分（如网页中的某个标题）。以 <code>#</code> 开始。</td>
<td>否 (可选)</td>
</tr>
</tbody></table>
<hr>
<p><strong>各部分的详细说明：</strong></p>
<ol>
<li><strong>协议 (Scheme)</strong><ul>
<li>它告诉浏览器用什么“语言”去和服务器沟通。</li>
<li><code>http</code>: 超文本传输协议，是 Web 的基础协议，默认端口 80。</li>
<li><code>https</code>: 安全的超文本传输协议，在 HTTP 的基础上加入了 SSL&#x2F;TLS 加密，默认端口 443。</li>
<li><code>ftp</code>: 文件传输协议，用于文件上传下载。</li>
<li><code>file</code>: 用于访问本地计算机上的文件。</li>
</ul>
</li>
<li><strong>主机 (Host)</strong><ul>
<li>可以是<strong>域名</strong>（如 <code>www.google.com</code>），域名最终会通过 DNS 解析成 IP 地址。</li>
<li>也可以直接是 <strong>IP 地址</strong>（如 <code>192.168.1.1</code>）。</li>
</ul>
</li>
<li><strong>端口 (Port)</strong><ul>
<li>端口号是一个 16 位的数字（0-65535）。</li>
<li>如果 URL 中<strong>省略了端口号</strong>，浏览器会使用该协议的<strong>默认端口</strong>。<ul>
<li><code>http</code> 的默认端口是 <strong>80</strong>。</li>
<li><code>https</code> 的默认端口是 <strong>443</strong>。</li>
</ul>
</li>
<li>因此，<code>http://example.com</code> 等价于 <code>http://example.com:80</code>。</li>
</ul>
</li>
<li><strong>路径 (Path)</strong><ul>
<li>路径部分是大小写敏感的（除非服务器特殊配置）。</li>
<li>如果 URL 中只有主机名而没有路径（如 <code>https://www.example.com</code>），那么路径默认为根路径 <code>/</code>。</li>
</ul>
</li>
<li><strong>查询 (Query)</strong><ul>
<li>这是客户端向服务器传递动态数据的主要方式，尤其是在 <code>GET</code> 请求中。</li>
<li>格式是 <code>key=value</code> 的键值对，多个键值对用 <code>&amp;</code> 连接。</li>
<li>例如，在搜索引擎中搜索“http”，URL 可能是 <code>https://www.google.com/search?q=http</code>。这里的 <code>q=http</code> 就是查询参数。</li>
</ul>
</li>
<li><strong>片段 (Fragment)</strong><ul>
<li><strong>一个非常重要的特性是：片段部分完全由客户端（浏览器）处理，它不会被发送到服务器。</strong></li>
<li>当浏览器加载完页面后，它会查找 ID 为 <code>section1</code> 的元素，并将页面滚动到该位置。</li>
<li>这在单页应用 (SPA) 中被广泛用于实现前端路由。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-5-2-URI-URL-URN-的区别与联系"><a href="#1-5-2-URI-URL-URN-的区别与联系" class="headerlink" title="1.5.2 URI, URL, URN 的区别与联系"></a>1.5.2 URI, URL, URN 的区别与联系</h4><p>在技术文档中，可能还会遇到 URI 和 URN两个术语。它们的关系如下：</p>
<p><strong>URI (Uniform Resource Identifier - 统一资源标识符)</strong></p>
<ul>
<li><strong>定义</strong>：URI是一个用于<strong>唯一标识</strong>互联网上任何资源（如网页、图片、视频、文件等）的字符串。它的核心作用是“标识”，就像每个公民都有一个独一无二的身份证号一样。</li>
<li><strong>目的</strong>：提供一种统一的、标准的方式来识别资源，而不关心如何访问它或它在哪里。</li>
<li><strong>分类</strong>：URI主要分为两大类：URL和URN。</li>
</ul>
<p><strong>URL (Uniform Resource Locator - 统一资源定位符)</strong></p>
<ul>
<li><strong>定义</strong>：URL是URI的一个子集。它不仅<strong>标识</strong>了资源，还提供了找到该资源的<strong>位置信息</strong>以及<strong>访问该资源的方法（协议）</strong>。它就像一个完整的家庭住址，告诉你某人住在哪个城市、哪条街道、哪个门牌号，让你能够准确地找到他。</li>
<li><strong>目的</strong>：定位资源，为访问资源提供足够的信息。我们日常在浏览器地址栏中输入的网址，绝大多数都是URL。</li>
</ul>
<p><strong>URN (Uniform Resource Name - 统一资源名称)</strong></p>
<ul>
<li><strong>定义</strong>：URN也是URI的一个子集。它通过一个在特定命名空间内唯一的、持久的名称来<strong>标识</strong>资源，而不关心其物理位置。如果资源被移动，它的URN保持不变。它就像一本书的ISBN号（<code>urn:isbn:0451450523</code>），无论这本书是在北京的图书馆还是纽约的书店，它的ISBN号都是一样的。</li>
<li><strong>现状</strong>：URN在实际应用中不如URL普遍。</li>
</ul>
<p><strong>三者关系总结</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      +------------------+</span><br><span class="line">      |       URI        |  (标识符总称)</span><br><span class="line">      |  (Identifier)    |</span><br><span class="line">      +------------------+</span><br><span class="line">             /      \</span><br><span class="line">            /        \</span><br><span class="line">+----------------+  +----------------+</span><br><span class="line">|      URL       |  |      URN       | (名称)</span><br><span class="line">|  (Locator)     |  |     (Name)     |</span><br><span class="line">+----------------+  +----------------+</span><br><span class="line">(标识 + 定位)       (标识，但无定位)</span><br></pre></td></tr></table></figure>

<p><strong>核心关系</strong>：<strong>所有URL都是URI，但并非所有URI都是URL。</strong> 在绝大多数Web开发场景中，我们打交道的都是URL。</p>
<hr>
<h4 id="1-5-3-Java中的体现与实践"><a href="#1-5-3-Java中的体现与实践" class="headerlink" title="1.5.3 Java中的体现与实践"></a>1.5.3 Java中的体现与实践</h4><p>Java在 <code>java.net</code> 包中提供了两个核心类来处理URI和URL：<code>URI</code> 和 <code>URL</code>。</p>
<h5 id="1-java-net-URI-类"><a href="#1-java-net-URI-类" class="headerlink" title="1. java.net.URI 类"></a>1. <code>java.net.URI</code> 类</h5><ul>
<li><strong>特点</strong>：<ul>
<li>它是一个纯粹的<strong>标识符</strong>的抽象表示，严格遵守 RFC 2396 规范。</li>
<li>它只负责解析和操作URI字符串的各个部分（scheme, host, path等），<strong>不包含任何用于网络访问的方法</strong>。</li>
<li>它的构造器不会尝试建立网络连接，只会因语法错误抛出 <code>URISyntaxException</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-java-net-URL-类"><a href="#2-java-net-URL-类" class="headerlink" title="2. java.net.URL 类"></a>2. <code>java.net.URL</code> 类</h5><ul>
<li><strong>特点</strong>：<ul>
<li>它代表了一个指向网络资源的<strong>定位符</strong>。</li>
<li>除了包含URI的解析功能外，它的核心能力在于<strong>与资源进行交互</strong>。它提供了如 <code>openConnection()</code>, <code>openStream()</code> 等方法来获取资源内容。</li>
<li>它的构造器在创建对象时，会检查协议处理器是否存在。如果传入一个Java不认识的协议（如<code>myprotocol://...</code>），会抛出 <code>MalformedURLException</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UriUrlDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 使用URI类进行解析</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URI</span>(<span class="string">&quot;https://www.example.com:8080/path/to/myfile?key1=value1#section1&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;--- URI 解析 ---&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Scheme: &quot;</span> + uri.getScheme());       <span class="comment">// 输出: https</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Host: &quot;</span> + uri.getHost());           <span class="comment">// 输出: www.example.com</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Port: &quot;</span> + uri.getPort());           <span class="comment">// 输出: 8080</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Path: &quot;</span> + uri.getPath());           <span class="comment">// 输出: /path/to/myfile</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Query: &quot;</span> + uri.getQuery());         <span class="comment">// 输出: key1=value1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Fragment: &quot;</span> + uri.getFragment());   <span class="comment">// 输出: section1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Authority: &quot;</span> + uri.getAuthority()); <span class="comment">// 输出: www.example.com:8080</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;URI 语法错误: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n=====================================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用URL类进行资源访问</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个URL对象</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;--- URL 访问 ---&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Protocol: &quot;</span> + url.getProtocol()); <span class="comment">// 输出: https</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Host: &quot;</span> + url.getHost());         <span class="comment">// 输出: www.baidu.com</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Default Port: &quot;</span> + url.getDefaultPort()); <span class="comment">// 输出: 443 (https的默认端口)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过URL打开一个输入流，读取网页内容</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> url.openStream();</span><br><span class="line">                 <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line">                 <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr)) &#123;</span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">&quot;\n正在读取 &quot;</span> + url + <span class="string">&quot; 的内容...&quot;</span>);</span><br><span class="line">                String line;</span><br><span class="line">                <span class="comment">// 只读取前5行作为演示</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span> &amp;&amp; (line = br.readLine()) != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                    System.out.println(line);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;...内容读取完毕(仅演示部分)...&quot;</span>);</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;读取URL内容失败: &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;URL 格式错误: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 在Java中，如果你只是需要解析或构建一个标识符字符串，<code>URI</code>是更合适、更严格的选择。如果你需要实际地去连接并获取该标识符指向的网络资源，那么就必须使用 <code>URL</code> 类。</p>
<hr>
<h2 id="2-网络分层模型"><a href="#2-网络分层模型" class="headerlink" title="2. 网络分层模型"></a>2. 网络分层模型</h2><p>为了降低网络设计的复杂性，网络协议被组织成层次结构。</p>
<p><strong>OSI七层模型 (理论模型)</strong>:</p>
<ol>
<li>物理层 (Physical)</li>
<li>数据链路层 (Data Link)</li>
<li><strong>网络层 (Network)</strong></li>
<li><strong>传输层 (Transport)</strong></li>
<li>会话层 (Session)</li>
<li>表示层 (Presentation)</li>
<li><strong>应用层 (Application)</strong></li>
</ol>
<p><strong>TCP&#x2F;IP四层&#x2F;五层模型 (事实标准)</strong>:</p>
<ul>
<li><strong>应用层</strong>: (对应OSI 5-7层) - 我们最常接触的层面。负责应用程序间的通信。协议：HTTP, FTP, DNS, SMTP。</li>
<li><strong>传输层</strong>: (对应OSI 4层) - 负责端到端（进程到进程）的数据传输。协议：<strong>TCP, UDP</strong>。</li>
<li><strong>网络层&#x2F;网际层</strong>: (对应OSI 3层) - 负责数据包在网络间的路由和转发（主机到主机）。协议：<strong>IP</strong>。</li>
<li><strong>网络接口层&#x2F;数据链路层</strong>: (对应OSI 1-2层) - 负责在物理媒介上传输数据。协议：Ethernet。</li>
</ul>
<hr>
<h2 id="3-传输层协议解析"><a href="#3-传输层协议解析" class="headerlink" title="3. 传输层协议解析"></a>3. 传输层协议解析</h2><h3 id="3-1-TCP-Transmission-Control-Protocol-传输控制协议"><a href="#3-1-TCP-Transmission-Control-Protocol-传输控制协议" class="headerlink" title="3.1 TCP (Transmission Control Protocol - 传输控制协议)"></a>3.1 TCP (Transmission Control Protocol - 传输控制协议)</h3><h4 id="3-1-1-特性"><a href="#3-1-1-特性" class="headerlink" title="3.1.1 特性"></a>3.1.1 特性</h4><ol>
<li><strong>面向连接 (Connection-Oriented)</strong>: 通信前必须先建立连接（三次握手），通信结束后需要断开连接（四次挥手）。</li>
<li><strong>可靠传输 (Reliable)</strong>: 通过序列号、确认应答(ACK)、超时重传、流量控制和拥塞控制等机制，确保数据无差错、不丢失、不重复且按序到达。</li>
<li><strong>面向字节流 (Byte Stream)</strong>: 数据像水流一样，没有边界。发送方写入的数据和接收方读取的数据在字节序列上是一致的，但读取的次数和大小可能与写入时不同。</li>
</ol>
<hr>
<h4 id="3-1-2-基本概念与标志位"><a href="#3-1-2-基本概念与标志位" class="headerlink" title="3.1.2 基本概念与标志位"></a>3.1.2 基本概念与标志位</h4><p> TCP 报文头中的几个关键标志位（Flag）和字段：</p>
<ul>
<li><strong>SYN (Synchronize Sequence Numbers)</strong>：同步序列号，用于发起连接。</li>
<li><strong>ACK (Acknowledgment)</strong>：确认标志，用于确认收到数据。</li>
<li><strong>FIN (Finish)</strong>：结束标志，用于释放连接。</li>
<li><strong>seq (Sequence Number)</strong>：序列号，标识当前发送数据的起始位置。</li>
<li><strong>ack (Acknowledgment Number)</strong>：确认号，期望收到对方下一个报文段的第一个字节的序号（即告诉对方：这个序号之前的数据我都收到了）。</li>
</ul>
<hr>
<h4 id="3-1-3-底层核心机制"><a href="#3-1-3-底层核心机制" class="headerlink" title="3.1.3 底层核心机制"></a>3.1.3 底层核心机制</h4><h5 id="1-三次握手-Three-Way-Handshake-建立连接"><a href="#1-三次握手-Three-Way-Handshake-建立连接" class="headerlink" title="1. 三次握手 (Three-Way Handshake) - 建立连接"></a>1. 三次握手 (Three-Way Handshake) - 建立连接</h5><ul>
<li><p><strong>第一次握手 (SYN)</strong></p>
<ul>
<li><strong>动作</strong>：客户端发送一个 SYN 报文段到服务器，并选择一个初始序列号 <code>seq = x</code>。</li>
<li><strong>标志位</strong>：<code>SYN=1</code>, <code>seq=x</code></li>
<li><strong>状态变化</strong>：客户端进入 <strong>SYN_SENT</strong> 状态。</li>
<li><strong>含义</strong>：客户端说：“你好，我想建立连接，我的初始序号是 x。”</li>
</ul>
</li>
<li><p><strong>第二次握手 (SYN + ACK)</strong></p>
<ul>
<li><strong>动作</strong>：服务器收到 SYN 报文后，同意建立连接。向客户端发送确认报文。同时也发送自己的 SYN 请求信息。</li>
<li><strong>标志位</strong>：<code>SYN=1</code>, <code>ACK=1</code>, <code>seq=y</code>, <code>ack=x+1</code></li>
<li><strong>状态变化</strong>：服务器进入 <strong>SYN_RCVD</strong> 状态。</li>
<li><strong>含义</strong>：服务器说：“收到了，我知道你的序号是 x 了。我也想建立连接，我的初始序号是 y。”</li>
</ul>
</li>
<li><p><strong>第三次握手 (ACK)</strong></p>
<ul>
<li><strong>动作</strong>：客户端收到服务器的 SYN+ACK 报文后，向服务器发送确认报文。</li>
<li><strong>标志位</strong>：<code>ACK=1</code>, <code>seq=x+1</code>, <code>ack=y+1</code></li>
<li><strong>状态变化</strong>：客户端进入 <strong>ESTABLISHED</strong> 状态。服务器收到该报文后，也进入 <strong>ESTABLISHED</strong> 状态。</li>
<li><strong>含义</strong>：客户端说：“收到了，我知道你的序号是 y 了。连接建立完成！”</li>
</ul>
</li>
<li><p><strong>目的</strong>: 确保双方都具备发送和接收数据的能力。</p>
</li>
<li><p><strong>为什么是三次，而不是两次？</strong></p>
<ol>
<li><strong>防止失效的连接请求突然传到服务端</strong>：<ul>
<li>如果只有两次握手：假设客户端发出的第一个 SYN 请求在网络中滞留了，客户端超时重发了第二个 SYN 并建立了连接、传输完数据、关闭了连接。</li>
<li>此时，滞留的第一个 SYN 终于到达了服务器。服务器误以为是新的连接请求，于是发出 ACK（第二次握手）。如果只有两次，连接就建立了，服务器会一直等待客户端发数据，导致资源浪费。</li>
<li>有了三次握手，客户端收到服务器对“滞留 SYN”的回复时，发现这不是自己当前的请求，就会发送 RST（复位）报文拒绝连接。</li>
</ul>
</li>
<li><strong>确认双方的收发能力</strong>：<ul>
<li>第一次：服务端确认（对方发正常，自己收正常）。</li>
<li>第二次：客户端确认（自己发&#x2F;收正常，对方发&#x2F;收正常）。</li>
<li>第三次：服务端确认（自己发正常，对方收正常）。</li>
</ul>
</li>
</ol>
</li>
</ul>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client as 客户端
    participant Server as 服务器

    title TCP三次握手

    %% 第一次握手: 客户端 -&gt; 服务器
    Client-&gt;&gt;Server: SYN (seq=x)
    note right of Client: 客户端进入 SYN_SENT 状态

    %% 第二次握手: 服务器 -&gt; 客户端
    Server--&gt;&gt;Client: SYN+ACK (seq=y, ack=x+1)
    note left of Server: 服务器进入 SYN_RCVD 状态

    %% 第三次握手: 客户端 -&gt; 服务器
    Client-&gt;&gt;Server: ACK (seq=x+1, ack=y+1)
    note right of Client: 客户端进入 ESTABLISHED 状态
    note left of Server: 服务器收到ACK后&lt;br/&gt;也进入 ESTABLISHED 状态</code></pre>

<hr>
<h5 id="2-四次挥手-Four-Way-Wave-断开连接"><a href="#2-四次挥手-Four-Way-Wave-断开连接" class="headerlink" title="2. 四次挥手 (Four-Way Wave) - 断开连接"></a>2. 四次挥手 (Four-Way Wave) - 断开连接</h5><p>假设客户端先发起关闭请求（服务端也可以发起）。</p>
<ul>
<li><p><strong>第一次挥手 (FIN)</strong></p>
<ul>
<li><strong>动作</strong>：客户端数据发送完毕，向服务器发送 FIN 报文，请求关闭连接。</li>
<li><strong>标志位</strong>：<code>FIN=1</code>, <code>seq=u</code></li>
<li><strong>状态变化</strong>：客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li>
<li><strong>含义</strong>：客户端说：“我没有数据要发给你了，我想断开。”</li>
</ul>
</li>
<li><p><strong>第二次挥手 (ACK)</strong></p>
<ul>
<li><strong>动作</strong>：服务器收到 FIN 报文，回发一个 ACK 报文。</li>
<li><strong>标志位</strong>：<code>ACK=1</code>, <code>seq=v</code>, <code>ack=u+1</code></li>
<li><strong>状态变化</strong>：服务器进入 <strong>CLOSE_WAIT</strong> 状态；客户端收到后进入 <strong>FIN_WAIT_2</strong> 状态。</li>
<li><strong>含义</strong>：服务器说：“好的，我知道你要断开了。但我可能还有数据没发完，你先等一下。”</li>
<li><em>注意：此时 TCP 处于“半关闭”状态，客户端不能发数据，但能收数据。</em></li>
</ul>
</li>
<li><p><strong>第三次挥手 (FIN)</strong></p>
<ul>
<li><strong>动作</strong>：服务器的数据也发送完了，向客户端发送 FIN 报文。</li>
<li><strong>标志位</strong>：<code>FIN=1</code>, <code>ACK=1</code>, <code>seq=w</code>, <code>ack=u+1</code></li>
<li><strong>状态变化</strong>：服务器进入 <strong>LAST_ACK</strong> 状态。</li>
<li><strong>含义</strong>：服务器说：“我也没数据要发了，现在可以正式断开了。”</li>
</ul>
</li>
<li><p><strong>第四次挥手 (ACK)</strong></p>
<ul>
<li><strong>动作</strong>：客户端收到服务器的 FIN 报文，回发 ACK 报文。</li>
<li><strong>标志位</strong>：<code>ACK=1</code>, <code>seq=u+1</code>, <code>ack=w+1</code></li>
<li><strong>状态变化</strong>：<ul>
<li>客户端进入 <strong>TIME_WAIT</strong> 状态，等待 <strong>2MSL</strong>（最长报文段寿命）时间后，自动进入 <strong>CLOSED</strong> 状态。</li>
<li>服务器收到 ACK 后，直接进入 <strong>CLOSED</strong> 状态。</li>
</ul>
</li>
<li><strong>含义</strong>：客户端说：“好的，再见。”</li>
</ul>
</li>
<li><p><strong>目的</strong>: 确保双方数据都已传输完毕，并优雅地关闭连接。</p>
</li>
<li><p><strong>为什么要四次挥手？</strong></p>
<ul>
<li>因为 TCP 是全双工的。</li>
<li>当客户端发送 FIN 时，只代表客户端没数据发了，但服务器可能还有数据要处理和发送。</li>
<li>所以服务器先回一个 ACK（表示收到关闭请求），等自己数据处理完了，再发一个 FIN（表示自己也准备好了）。ACK 和 FIN 分了两步发，所以是四次。</li>
</ul>
</li>
<li><p><strong>为什么客户端最后要等待 2MSL (TIME_WAIT)？</strong><br>这是为了保证连接正确关闭：</p>
<ol>
<li><strong>保证最后一个 ACK 能到达服务器</strong>：如果客户端发出的第四次挥手（ACK）丢包了，服务器收不到确认，会超时重传第三次挥手（FIN）。客户端必须维持 TIME_WAIT 状态才能收到这个重传的 FIN 并再次补发 ACK。如果是直接 CLOSED，服务器重传 FIN 时客户端会报错。</li>
<li><strong>防止旧报文混淆新连接</strong>：等待 2MSL 可以让本连接中产生的所有报文段都从网络中消失。防止在同样的 IP 和端口建立新连接时，收到上一个连接残留的旧数据包。</li>
</ol>
</li>
</ul>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client as 主动关闭方
    participant Server as 被动关闭方

    title TCP 四次挥手

    %% 数据传输阶段
    Note over Client,Server: 连接已建立，数据正常传输...

    %% 第一次挥手: 客户端 -&gt; 服务器
    Client-&gt;&gt;Server: FIN (seq=u)
    note right of Client: 客户端进入 FIN_WAIT_1 状态

    %% 第二次挥手: 服务器 -&gt; 客户端
    Server--&gt;&gt;Client: ACK (ack=u+1)
    note left of Server: 服务器进入 CLOSE_WAIT 状态
    note right of Client: 客户端收到ACK后&lt;br/&gt;进入 FIN_WAIT_2 状态

    %% 服务器可能还在发送剩余数据
    Note over Client,Server: 服务器可能继续发送数据...

    %% 第三次挥手: 服务器 -&gt; 客户端
    Server--&gt;&gt;Client: FIN (seq=v)
    note left of Server: 服务器数据发送完毕&lt;br/&gt;进入 LAST_ACK 状态

    %% 第四次挥手: 客户端 -&gt; 服务器
    Client-&gt;&gt;Server: ACK (ack=v+1)
    note right of Client: 客户端进入 TIME_WAIT 状态
    note left of Server: 服务器收到ACK后&lt;br/&gt;进入 CLOSED 状态
    note right of Client: 客户端等待 2*MSL 后&lt;br/&gt;也进入 CLOSED 状态</code></pre>

<hr>
<h4 id="3-1-4-Java-TCP编程核心类-基于BIO"><a href="#3-1-4-Java-TCP编程核心类-基于BIO" class="headerlink" title="3.1.4 Java TCP编程核心类 (基于BIO)"></a>3.1.4 Java TCP编程核心类 (基于BIO)</h4><h5 id="1-ServerSocket-服务器端"><a href="#1-ServerSocket-服务器端" class="headerlink" title="1. ServerSocket (服务器端)"></a>1. <code>ServerSocket</code> (服务器端)</h5><ul>
<li><strong>角色与职责</strong>:<ul>
<li>代表服务器端的监听套接字。</li>
<li>它的核心职责是监听指定的服务器端口，等待客户端的连接请求。</li>
<li>它是一个“连接工厂”，当接收到客户端连接时，会创建一个代表该连接的 <code>Socket</code> 对象。</li>
</ul>
</li>
<li><strong>核心工作流程</strong>:<ol>
<li><strong>创建实例</strong>: <code>new ServerSocket(int port)</code> - 在指定端口上创建并绑定监听服务。</li>
<li><strong>等待连接</strong>: 调用 <code>accept()</code> 方法。这是一个<strong>阻塞方法</strong>，程序会在此处暂停，直到有一个客户端成功连接。</li>
<li><strong>获取连接</strong>: <code>accept()</code> 方法成功返回一个 <code>Socket</code> 对象。这个 <code>Socket</code> 对象才是真正用于与<strong>单个客户端</strong>进行数据通信的通道。</li>
<li><strong>处理通信</strong>: 通常，服务器会将返回的 <code>Socket</code> 对象交给一个新的线程去处理，以便主线程可以继续调用 <code>accept()</code> 方法接收其他客户端的连接。这就是经典的“一个请求一个线程”模型。</li>
<li><strong>关闭服务</strong>: 调用 <code>close()</code> 方法，释放端口，不再接受任何新连接。</li>
</ol>
</li>
<li><strong>重要方法</strong>:<ul>
<li><code>ServerSocket(int port)</code>: 构造方法，在指定端口上监听。</li>
<li><code>Socket accept()</code>: 阻塞式方法，等待并返回一个客户端连接的 <code>Socket</code>。</li>
<li><code>void close()</code>: 关闭服务器套接字。</li>
<li><code>boolean isClosed()</code>: 判断服务器套接字是否关闭。</li>
<li><code>void bind(SocketAddress endpoint)</code>: 更灵活的地址和端口绑定。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-Socket-客户端-服务器端连接通道"><a href="#2-Socket-客户端-服务器端连接通道" class="headerlink" title="2. Socket (客户端 &amp; 服务器端连接通道)"></a>2. <code>Socket</code> (客户端 &amp; 服务器端连接通道)</h5><ul>
<li><strong>角色与职责</strong>:<ul>
<li>代表网络连接中的一个“端点”（Endpoint）。它封装了IP地址和端口号。</li>
<li>在<strong>客户端</strong>，主动创建 <code>Socket</code> 实例来向服务器发起连接请求。</li>
<li>在<strong>服务器端</strong>，通过 <code>ServerSocket.accept()</code> 方法被动创建，代表一个已经建立的、与特定客户端的连接。</li>
<li>是数据传输的载体，提供了**输入流（InputStream）<strong>和</strong>输出流（OutputStream）**用于双向通信。</li>
</ul>
</li>
<li><strong>核心工作流程 (客户端)</strong>:<ol>
<li><strong>创建实例并发起连接</strong>: <code>new Socket(String host, int port)</code> - 指定服务器的IP地址和端口号。构造方法内部会完成TCP三次握手，如果连接失败会抛出异常。</li>
<li><strong>获取IO流</strong>:<ul>
<li><code>getOutputStream()</code>: 获取输出流，用于向服务器发送数据。</li>
<li><code>getInputStream()</code>: 获取输入流，用于从服务器读取数据。</li>
</ul>
</li>
<li><strong>数据通信</strong>: 通过IO流进行读写操作。</li>
<li><strong>关闭连接</strong>: 调用 <code>close()</code> 方法。这会触发TCP四次挥手，优雅地断开连接，并释放相关资源。</li>
</ol>
</li>
<li><strong>重要方法</strong>:<ul>
<li><code>Socket(String host, int port)</code>: 客户端构造方法。</li>
<li><code>InputStream getInputStream()</code>: 获取字节输入流。</li>
<li><code>OutputStream getOutputStream()</code>: 获取字节输出流。</li>
<li><code>void close()</code>: 关闭Socket连接。</li>
<li><code>void shutdownInput()</code> &#x2F; <code>void shutdownOutput()</code>: 关闭单向数据流，可以用于实现半关闭状态。</li>
<li><code>InetAddress getInetAddress()</code>: 获取远程连接的IP地址对象。</li>
<li><code>int getPort()</code>: 获取远程连接的端口号。</li>
<li><code>boolean isConnected()</code>: 判断是否已连接。</li>
<li><code>boolean isClosed()</code>: 判断是否已关闭。</li>
<li><code>void setSoTimeout(int timeout)</code>: 设置读操作的超时时间（毫秒）。当调用<code>read()</code>方法阻塞超过该时间仍无数据返回时，会抛出<code>SocketTimeoutException</code>，这是避免永久阻塞的关键。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-基础C-S模型代码示例-一请求一线程模型"><a href="#3-基础C-S模型代码示例-一请求一线程模型" class="headerlink" title="3. 基础C&#x2F;S模型代码示例 (一请求一线程模型)"></a>3. 基础C&#x2F;S模型代码示例 (一请求一线程模型)</h5><p><strong>服务器端代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP 服务端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主函数，启动TCP服务器并监听指定端口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 命令行参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义服务器监听端口</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(PORT)) &#123;</span><br><span class="line">            <span class="comment">// 输出服务器启动信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器启动，监听端口：&quot;</span> + PORT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环等待客户端连接</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 接受客户端连接请求</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="comment">// 输出客户端连接信息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;客户端已连接：&quot;</span> + clientSocket.getInetAddress().getHostAddress());</span><br><span class="line">                <span class="comment">// 为每个客户端连接创建新线程处理</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ClientHandler</span>(clientSocket)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获并抛出IO异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端处理器类，用于处理客户端连接的读写操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClientHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造函数，初始化客户端Socket连接</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> socket 客户端Socket连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClientHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程执行方法，处理客户端消息的读取和回显</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">                 <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(), <span class="literal">true</span>)) &#123;</span><br><span class="line">                String inputLine;</span><br><span class="line">                <span class="comment">// 循环读取客户端发送的消息</span></span><br><span class="line">                <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 输出接收到的客户端消息</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;收到客户端消息：&quot;</span> + inputLine);</span><br><span class="line">                    <span class="comment">// 将消息回显给客户端</span></span><br><span class="line">                    out.println(<span class="string">&quot;已收到：&quot;</span> + inputLine);</span><br><span class="line">                    <span class="comment">// 如果客户端发送&quot;bye&quot;，则断开连接</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;bye&quot;</span>.equalsIgnoreCase(inputLine)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端主动断开连接&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// 捕获并抛出IO异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 关闭客户端连接</span></span><br><span class="line">                    socket.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接已关闭&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// 捕获并抛出关闭连接时的IO异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP 客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 服务器地址和端口</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVER_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SERVER_PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建客户端Socket连接到服务器</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(SERVER_HOST, SERVER_PORT);</span><br><span class="line">                <span class="comment">// 创建输出流，用于向服务器发送消息</span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 创建输入流，用于接收服务器消息</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">                <span class="comment">// 创建控制台输入扫描器</span></span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已连接到服务器&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动一个线程接收服务器消息</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String response;</span><br><span class="line">                    <span class="comment">// 持续读取服务器发送的消息并打印到控制台</span></span><br><span class="line">                    <span class="keyword">while</span> ((response = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;服务器回复：&quot;</span> + response);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;与服务器连接断开&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 主线程负责发送消息</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入消息（输入 &#x27;bye&#x27; 退出）：&quot;</span>);</span><br><span class="line">                <span class="comment">// 从控制台读取用户输入</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="comment">// 将消息发送给服务器</span></span><br><span class="line">                out.println(message);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果输入bye则退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;bye&quot;</span>.equalsIgnoreCase(message)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-5-TCP粘包-拆包"><a href="#3-1-5-TCP粘包-拆包" class="headerlink" title="3.1.5 TCP粘包&#x2F;拆包"></a>3.1.5 TCP粘包&#x2F;拆包</h4><h5 id="1-问题本质"><a href="#1-问题本质" class="headerlink" title="1. 问题本质"></a>1. 问题本质</h5><p>首先，必须明确一个核心前提：<strong>TCP粘包&#x2F;拆包不是TCP协议的Bug，而是其核心特性——面向字节流（Byte Stream）——所带来的必然现象。</strong></p>
<ul>
<li><strong>面向字节流 (Byte Stream)</strong>: 在TCP看来，它要传输的数据就是一连串没有边界的字节，像水流一样。TCP不关心你应用层一次<code>write</code>了多少数据，也不关心你应用层一次<code>read</code>想要多少数据。它只负责把这一串字节数据可靠地、按序地从一端传输到另一端。</li>
<li><strong>对比UDP (Datagram-Oriented)</strong>: UDP是面向数据报的。你发送一个数据包，接收方就会收到一个完整的数据包。它有明确的边界，像一个个独立的集装箱，所以UDP天然不会有粘包&#x2F;拆包问题。</li>
</ul>
<hr>
<h5 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h5><p><strong>粘包 (Packet Stickiness)</strong></p>
<ul>
<li><strong>现象</strong>: 发送方连续发送了多个较小的数据包，而接收方在一次读取操作中，把这多个数据包合并成一个大的数据块接收了。</li>
<li><strong>举例</strong>:<ul>
<li>发送方先后调用两次<code>write</code>，发送了<code>&quot;Hello&quot;</code>和<code>&quot;World&quot;</code>。</li>
<li>接收方调用一次<code>read</code>，读到了<code>&quot;HelloWorld&quot;</code>。</li>
<li><strong>这就是“粘包”：两个逻辑上的包，在物理上粘在了一起。</strong></li>
</ul>
</li>
</ul>
<p><strong>拆包 (Packet Splitting)</strong></p>
<ul>
<li><strong>现象</strong>: 发送方发送了一个较大的数据包，但由于网络等原因，接收方需要通过多次读取操作才能接收完整。</li>
<li><strong>举例</strong>:<ul>
<li>发送方调用一次<code>write</code>，发送了<code>&quot;Hi, this is a long message.&quot;</code>。</li>
<li>接收方第一次<code>read</code>，读到了<code>&quot;Hi, this is a&quot;</code>。</li>
<li>接收方第二次<code>read</code>，读到了<code>&quot; long message.&quot;</code>。</li>
<li><strong>这就是“拆包”：一个逻辑上的包，被拆分成了多个物理上的数据块。</strong></li>
</ul>
</li>
</ul>
<p>更常见的是，<strong>粘包和拆包会混合发生</strong>。例如，发送方发送了<code>Packet1</code>和<code>Packet2</code>，接收方可能第一次读到<code>Packet1的后半部分</code> + <code>Packet2</code>。</p>
<hr>
<h5 id="3-底层原因"><a href="#3-底层原因" class="headerlink" title="3. 底层原因"></a>3. 底层原因</h5><p><strong>发送方原因 (主要导致粘包):</strong></p>
<ol>
<li><strong>Nagle算法 (Nagle’s Algorithm)</strong>: 这是TCP中一个非常重要的优化算法。为了避免网络中充斥着大量的小数据包（比如每次只发送1个字节的按键信息），Nagle算法会把多个小的发送数据<strong>缓存</strong>起来，合并成一个较大的数据包（通常达到MSS大小）再一起发送。这是造成粘包的<strong>最主要原因之一</strong>。默认是开启的，可以通过<code>socket.setTcpNoDelay(true)</code>关闭它。</li>
<li><strong>发送方缓冲区</strong>: 应用层的数据是先写入操作系统内核的TCP发送缓冲区。如果应用层<code>write</code>的速度非常快，而网络发送速度跟不上，那么多个小的数据包就会在缓冲区中排队，操作系统在合适的时机将它们合并成一个大的TCP段（Segment）发送出去。</li>
</ol>
<p><strong>接收方原因 (主要导致拆包):</strong></p>
<ol>
<li><strong>接收方缓冲区</strong>: 接收方内核有一个TCP接收缓冲区。收到的TCP段会先存放在这里。当应用层调用<code>read</code>时，它只是从这个缓冲区里“捞”数据。如果应用层<code>read</code>时，缓冲区里只有一个不完整的包，那么就会发生拆包。如果缓冲区里恰好有多个完整的包，一次<code>read</code>操作就可能把它们都读出来，造成粘包。</li>
<li><strong>TCP段的MSS&#x2F;MTU限制</strong>: 数据在网络层会被分片。一个大的应用层数据包，在传输层会被分割成多个TCP段（Segment），每个段的大小受限于最大报文段长度（MSS）。接收方会逐个收到这些段，如果应用层在所有段都到达前就开始读取，就会发生拆包。</li>
</ol>
<p><strong>总结一句话：问题的根源在于，应用层消息的“边界”在TCP传输过程中丢失了。</strong></p>
<hr>
<h5 id="4-解决方案：重建消息边界"><a href="#4-解决方案：重建消息边界" class="headerlink" title="4. 解决方案：重建消息边界"></a>4. 解决方案：重建消息边界</h5><p>既然问题是消息边界的丢失，那么解决方案的核心就是：<strong>在应用层设计一种协议，能够让接收方准确地知道一个消息从哪里开始，到哪里结束。</strong></p>
<p>以下是三种最主流的解决方案：</p>
<p><strong>方案一：固定长度消息 (Fixed Length)</strong></p>
<ul>
<li><strong>原理</strong>: 客户端和服务器约定，每个消息的长度都是固定的。比如约定每个消息都是256字节。</li>
<li><strong>实现</strong>: 接收方每次都从TCP流中读取固定长度（如256字节）的数据。读够了就认为是一个完整的消息。如果发送的数据不足256字节，需要用特殊字符（如空格或<code>\0</code>）进行填充。</li>
<li><strong>优点</strong>: 实现非常简单。</li>
<li><strong>缺点</strong>: 浪费带宽，非常不灵活。如果消息普遍很小，大量空间被浪费在填充上。</li>
</ul>
<p><strong>方案二：特殊分隔符 (Delimiter-based)</strong></p>
<ul>
<li><strong>原理</strong>: 在每个逻辑消息的末尾，都加上一个特殊的分隔符。例如，HTTP头部就是用<code>\r\n</code>作为每行的分隔符。</li>
<li><strong>实现</strong>: 接收方持续从TCP流中读取数据，并不断扫描读取到的数据流，直到找到那个特殊的分隔符。从开始到分隔符之间的内容，就是一个完整的消息。</li>
<li><strong>优点</strong>: 灵活，节省带宽。</li>
<li><strong>缺点</strong>:<ol>
<li>如果消息体内部恰好包含了分隔符，会造成解析错误。需要对消息体内容进行转义，增加了复杂性。</li>
<li>需要从头到尾扫描数据，当消息很大时，性能会下降。</li>
</ol>
</li>
</ul>
<p><strong>方案三：长度字段+消息体 (Length-Field Based) - [业界最佳实践]</strong></p>
<ul>
<li><strong>原理</strong>: 这是最常用、最健壮的方案。在每个消息的前面，附加一个固定大小的字段，用来描述紧跟其后的消息体的长度。<ul>
<li><strong>协议格式</strong>: <code>[消息长度(固定字节，如4字节)] + [消息体(可变长度)]</code></li>
</ul>
</li>
<li><strong>实现</strong>:<ol>
<li>接收方先读取固定长度的头部（比如4个字节）。</li>
<li>解析这4个字节，得到一个整数，这个整数就是接下来消息体的实际长度（比如<code>dataLength</code>）。</li>
<li>然后，接收方就精确地再读取<code>dataLength</code>个字节的数据。这<code>dataLength</code>个字节就是一条完整的消息。</li>
</ol>
</li>
<li><strong>优点</strong>:<ol>
<li><strong>精确、高效</strong>: 无需扫描，直接根据长度读取，性能很高。</li>
<li><strong>灵活</strong>: 消息体可以是任意内容，包括二进制数据，不用担心内容与分隔符冲突。</li>
<li><strong>扩展性好</strong>: 消息头除了长度，还可以包含版本号、消息类型等其他元数据。</li>
</ol>
</li>
<li><strong>缺点</strong>: 实现比前两种稍复杂，但一劳永逸。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改TcpService中的ClientHandler类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClientHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用DataInputStream和DataOutputStream处理长度字段</span></span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(socket.getInputStream());</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(socket.getOutputStream());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取消息长度</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">                <span class="comment">// 根据长度读取消息体</span></span><br><span class="line">                <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">                dis.readFully(data);</span><br><span class="line">                </span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, StandardCharsets.UTF_8);</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端消息：&quot;</span> + message);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 回显消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;已收到：&quot;</span> + message;</span><br><span class="line">                <span class="type">byte</span>[] responseData = response.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">                dos.writeInt(responseData.length);</span><br><span class="line">                dos.write(responseData);</span><br><span class="line">                dos.flush();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;bye&quot;</span>.equalsIgnoreCase(message)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端主动断开连接&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端连接已关闭&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改TcpClient的main方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVER_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SERVER_PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(SERVER_HOST, SERVER_PORT);</span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(socket.getOutputStream());</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(socket.getInputStream());</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)</span><br><span class="line">    ) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务器&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动接收线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 读取响应消息长度</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">                    <span class="comment">// 根据长度读取响应消息体</span></span><br><span class="line">                    <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">                    dis.readFully(data);</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, StandardCharsets.UTF_8);</span><br><span class="line">                    System.out.println(<span class="string">&quot;服务器回复：&quot;</span> + response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;与服务器连接断开&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 主线程发送消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入消息（输入 &#x27;bye&#x27; 退出）：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 发送消息（带长度字段）</span></span><br><span class="line">            <span class="type">byte</span>[] data = message.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            dos.writeInt(data.length);</span><br><span class="line">            dos.write(data);</span><br><span class="line">            dos.flush();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;bye&quot;</span>.equalsIgnoreCase(message)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-UDP-User-Datagram-Protocol-用户数据报协议"><a href="#3-2-UDP-User-Datagram-Protocol-用户数据报协议" class="headerlink" title="3.2 UDP (User Datagram Protocol - 用户数据报协议)"></a>3.2 UDP (User Datagram Protocol - 用户数据报协议)</h3><h4 id="3-2-1-特性"><a href="#3-2-1-特性" class="headerlink" title="3.2.1 特性"></a>3.2.1 特性</h4><ol>
<li><strong>无连接 (Connectionless)</strong>: 发送数据前不需要建立连接，每个数据包（Datagram）都是一个独立单元。</li>
<li><strong>不可靠 (Unreliable)</strong>: 不保证数据包的到达、顺序或完整性。它尽最大努力交付（Best-Effort Delivery）。</li>
<li><strong>面向数据报 (Datagram-Oriented)</strong>: 每个数据包都有明确的边界。发送方发送一个包，接收方必须以包为单位接收。数据包大小有限制（通常为64KB）。</li>
</ol>
<p><strong>优点</strong>: 开销小、速度快、实时性好。</p>
<p><strong>适用场景</strong>: DNS查询、视频&#x2F;音频流媒体、在线游戏、广播&#x2F;多播等对实时性要求高、但能容忍少量丢包的场景。</p>
<hr>
<h4 id="3-2-2-Java-UDP编程实现"><a href="#3-2-2-Java-UDP编程实现" class="headerlink" title="3.2.2 Java UDP编程实现"></a>3.2.2 Java UDP编程实现</h4><h5 id="1-DatagramSocket"><a href="#1-DatagramSocket" class="headerlink" title="1. DatagramSocket"></a>1. <code>DatagramSocket</code></h5><p><code>DatagramSocket</code> 是执行UDP通信的“码头”或“邮局”。无论是发送还是接收数据，你都需要一个 <code>DatagramSocket</code> 实例来绑定到一个特定的端口上，通过这个端口进行所有的数据报收发操作。</p>
<ul>
<li><strong>核心作用</strong>:<ul>
<li><strong>绑定端口</strong>: 监听指定的本地端口，以便接收发往该端口的数据报。</li>
<li><strong>发送数据</strong>: 将封装好的 <code>DatagramPacket</code> 发送到网络中的指定目标（IP + 端口）。</li>
<li><strong>接收数据</strong>: 接收到达本地端口的数据报，并将其内容填充到一个 <code>DatagramPacket</code> 对象中。</li>
</ul>
</li>
<li><strong>常用构造方法</strong>:<ul>
<li><code>DatagramSocket()</code>: 创建一个数据报套接字，并将其<strong>绑定到本地主机上任何可用的端口</strong>。这通常用于<strong>客户端（发送方）</strong>，因为它不关心自己的端口号，只需要一个端口来发送数据即可。</li>
<li><code>DatagramSocket(int port)</code>: 创建一个数据报套接字，并将其<strong>绑定到本地主机上的指定端口</strong>。这通常用于<strong>服务器端（接收方）</strong>，因为它必须在一个固定的、众所周知的端口上等待客户端的数据。</li>
</ul>
</li>
<li><strong>核心方法</strong>:<ul>
<li><code>void send(DatagramPacket p)</code>: 发送一个数据报包。包中必须包含目标地址和端口。</li>
<li><code>void receive(DatagramPacket p)</code>: 接收一个数据报包。这是一个<strong>阻塞方法</strong>，程序会在此处暂停，直到接收到一个数据包为止。接收到的数据、发送方IP和端口等信息会被填充到传入的 <code>DatagramPacket</code> 对象 <code>p</code> 中。</li>
<li><code>void close()</code>: 关闭此数据报套接字，释放其占用的端口资源。</li>
<li><code>void setSoTimeout(int timeout)</code>: 设置 <code>receive()</code> 方法的阻塞超时时间（以毫秒为单位）。如果在指定时间内没有接收到数据，将抛出 <code>SocketTimeoutException</code>，这可以防止程序无限期地阻塞。</li>
</ul>
</li>
</ul>
<h5 id="2-DatagramPacket"><a href="#2-DatagramPacket" class="headerlink" title="2. DatagramPacket"></a>2. <code>DatagramPacket</code></h5><p><code>DatagramPacket</code> 是UDP通信中数据的载体，可以理解为“集装箱”或“快递包裹”。每个包都是一个独立、自包含的单元，它不仅携带了要传输的数据（payload），还包含了目的地或来源地的地址信息。</p>
<ul>
<li><p><strong>核心作用</strong>:</p>
<ul>
<li><strong>封装数据</strong>: 将要发送的字节数组（<code>byte[]</code>）封装成一个网络数据包。</li>
<li><strong>携带地址信息</strong>: 包含目标或来源的IP地址和端口号。</li>
</ul>
</li>
<li><p><strong>常用构造方法 (用途分明)</strong>:</p>
<ol>
<li><p><strong>用于发送数据时创建的包</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramPacket(<span class="type">byte</span>[] buf, <span class="type">int</span> length, InetAddress address, <span class="type">int</span> port)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>buf</code>: 包含要发送数据的字节数组。</li>
<li><code>length</code>: 要发送的数据的实际长度。</li>
<li><code>address</code>: 目标主机的 <code>InetAddress</code> 对象。</li>
<li><code>port</code>: 目标主机的端口号。<br><strong>必须明确指定目的地，因为UDP是无连接的。</strong></li>
</ul>
</li>
<li><p><strong>用于接收数据时创建的包</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramPacket(<span class="type">byte</span>[] buf, <span class="type">int</span> length)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>buf</code>: 一个<strong>空的</strong>字节数组，用作缓冲区来接收数据。</li>
<li><code>length</code>: 缓冲区的最大容量，即 <code>buf.length</code>。<br><strong>这个包像一个空容器，传递给 <code>socket.receive()</code> 方法后，由该方法填充内容和发送方地址信息。</strong></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>核心方法 (主要用于读取接收到的包)</strong>:</p>
<ul>
<li><code>InetAddress getAddress()</code>: 获取数据包的来源（或目标）IP地址。</li>
<li><code>int getPort()</code>: 获取数据包的来源（或目标）端口号。</li>
<li><code>byte[] getData()</code>: 获取数据包中的原始字节数组（即构造时传入的缓冲区）。</li>
<li><code>int getLength()</code>: <strong>获取数据包中数据的实际长度</strong>。这个非常重要，因为接收到的数据大小通常小于缓冲区的总大小。</li>
</ul>
</li>
</ul>
<h5 id="3-基础收发代码示例"><a href="#3-基础收发代码示例" class="headerlink" title="3. 基础收发代码示例"></a>3. 基础收发代码示例</h5><ul>
<li><code>java.net.DatagramSocket</code>: 用于发送和接收UDP数据包的Socket。</li>
<li><code>java.net.DatagramPacket</code>: UDP通信中的数据载体，包含了数据本身、目标&#x2F;源IP和端口。</li>
</ul>
<p><strong>发送端（Sender）代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UdpSender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建DatagramSocket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(); <span class="comment">// 无需指定端口，系统会自动分配</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 准备数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;你好，UDP接收端！&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = message.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建DatagramPacket，封装数据、目标IP和端口</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">receiverAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">receiverPort</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length, receiverAddress, receiverPort);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 发送数据包</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line">        System.out.println(<span class="string">&quot;数据已发送。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭Socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接收端（Receiver）代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UdpReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建DatagramSocket，并监听指定端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收端已启动，等待数据...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建一个空的DatagramPacket用于接收数据</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 调用receive()方法，阻塞等待数据包</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 解析接收到的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">        <span class="type">String</span> <span class="variable">senderIp</span> <span class="operator">=</span> packet.getAddress().getHostAddress();</span><br><span class="line">        <span class="type">int</span> <span class="variable">senderPort</span> <span class="operator">=</span> packet.getPort();</span><br><span class="line">        System.out.println(<span class="string">&quot;收到来自 &quot;</span> + senderIp + <span class="string">&quot;:&quot;</span> + senderPort + <span class="string">&quot; 的消息: &quot;</span> + receivedMessage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭Socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-IO与网络编程"><a href="#4-IO与网络编程" class="headerlink" title="4. IO与网络编程"></a>4. IO与网络编程</h2><h3 id="4-1-BIO-Blocking-I-O-阻塞I-O"><a href="#4-1-BIO-Blocking-I-O-阻塞I-O" class="headerlink" title="4.1 BIO (Blocking I&#x2F;O - 阻塞I&#x2F;O)"></a>4.1 BIO (Blocking I&#x2F;O - 阻塞I&#x2F;O)</h3><ul>
<li><strong>模型</strong>: 上述TCP示例代码就是典型的BIO模型。其特点是<strong>一个连接一个线程</strong>。</li>
<li><strong>工作流程</strong>:<ol>
<li>服务器<code>ServerSocket.accept()</code>方法是阻塞的，直到有客户端连接进来。</li>
<li>连接建立后，<code>InputStream.read()</code>方法也是阻塞的，直到有数据可读。</li>
</ol>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>伸缩性差</strong>: 每来一个连接就需要创建一个线程，当并发连接数很高时（如C10K问题），会创建大量线程，导致系统资源（内存、CPU上下文切换开销）被耗尽，性能急剧下降。</li>
<li><strong>资源浪费</strong>: 大部分线程在大部分时间里都处于阻塞等待状态，没有执行任何有效工作，浪费CPU。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-2-NIO-Non-Blocking-I-O-New-I-O"><a href="#4-2-NIO-Non-Blocking-I-O-New-I-O" class="headerlink" title="4.2 NIO (Non-Blocking I&#x2F;O &#x2F; New I&#x2F;O)"></a>4.2 NIO (Non-Blocking I&#x2F;O &#x2F; New I&#x2F;O)</h3><ul>
<li><p><strong>模型</strong>: Java 1.4引入，提供了非阻塞的、基于事件驱动的I&#x2F;O模型。其核心是<strong>用一个线程处理多个连接</strong>。</p>
</li>
<li><p><strong>工作流程 (事件驱动)</strong>:</p>
<ol>
<li>创建一个Selector。</li>
<li>创建一个ServerSocketChannel，设置为非阻塞模式，并注册到Selector上，监听<code>OP_ACCEPT</code>事件。</li>
<li>启动一个循环，在循环中调用<code>selector.select()</code>。</li>
<li>当<code>select()</code>返回时，遍历<code>selectedKeys</code>集合。</li>
<li>如果key是<code>OP_ACCEPT</code>事件，调用<code>serverSocketChannel.accept()</code>获取<code>SocketChannel</code>，将其设为非阻塞，并注册到Selector上，监听<code>OP_READ</code>事件。</li>
<li>如果key是<code>OP_READ</code>事件，从对应的<code>SocketChannel</code>中读取数据进行处理。</li>
</ol>
</li>
<li><p><strong>优点</strong>:</p>
<ul>
<li><strong>高伸缩性</strong>: 用少量线程即可管理大量连接，避免了线程创建和上下文切换的巨大开销，非常适合高并发场景。</li>
<li><strong>资源利用率高</strong>: 线程只在有事件发生时才工作，不会因等待I&#x2F;O而长时间阻塞。</li>
</ul>
</li>
<li><p><strong>缺点</strong>: 编程模型比BIO复杂得多，需要手动处理Buffer的读写切换、事件的分发等细节。</p>
<pre><code class="highlight mermaid">graph BT
    %% 定义顶部的 Selector 节点
    subgraph Selector
        S[&quot;Selector&lt;br/&gt;监听所有注册的Channel的事件&lt;br/&gt;(ACCEPT, READ, WRITE)&quot;]
    end

    %% 定义底部的 Channel 节点
    subgraph Channels
        direction LR
        SSC[&quot;ServerSocketChannel&lt;br/&gt;监听ACCEPT事件&quot;]
        SCR[&quot;SocketChannel&lt;br/&gt;监听READ事件&quot;]
        SCW[&quot;SocketChannel&lt;br/&gt;监听WRITE事件&quot;]
    end

    %% 定义连接关系 (Channels 注册到 Selector)
    SSC -- &quot;注册&quot; --&gt; S
    SCR -- &quot;注册&quot; --&gt; S
    SCW -- &quot;注册&quot; --&gt; S

    %% 设置样式 (可选，让它更好看)
    style S fill:#333,stroke:#fff,stroke-width:2px,color:#fff
    style SSC fill:#333,stroke:#fff,stroke-width:2px,color:#fff
    style SCR fill:#333,stroke:#fff,stroke-width:2px,color:#fff
    style SCW fill:#333,stroke:#fff,stroke-width:2px,color:#fff</code></pre>
</li>
<li><p><strong>服务端代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP服务端程序，使用NIO实现高并发网络通信</span></span><br><span class="line"><span class="comment"> * 支持处理多个客户端连接，并按照[长度+内容]的协议格式进行消息传输</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 程序入口点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 命令行参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 定义服务器监听端口</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建选择器，用于监听通道事件</span></span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建服务器套接字通道</span></span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 绑定端口并设置为非阻塞模式</span></span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将服务器通道注册到选择器，监听ACCEPT事件</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;服务器启动，监听端口：&quot;</span> + PORT);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 主循环，持续监听和处理事件</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待就绪的通道事件</span></span><br><span class="line">                <span class="keyword">if</span> (selector.select() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取就绪的事件键集合</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历处理所有就绪事件</span></span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">// 处理新的客户端连接请求</span></span><br><span class="line">                        handleAccept(key, selector);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">// 处理通道可读事件（接收数据）</span></span><br><span class="line">                        handleRead(key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 移除已处理的事件键</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获并重新抛出IO异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理客户端连接请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 选择键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selector 选择器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO操作异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleAccept</span><span class="params">(SelectionKey key, Selector selector)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 从 key 中获取 ServerSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接受新的客户端连接</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (socketChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将新的客户端 Channel 注册到 Selector，并关注 OP_READ 事件</span></span><br><span class="line">            <span class="comment">// 同时附加一个ByteBuffer用于读取数据</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">2048</span>));</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;接受到来自客户端的连接: &quot;</span> + socketChannel.getRemoteAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理读事件，接收并处理客户端发送的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 选择键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO操作异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 从 key 中获取 SocketChannel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取附加的ByteBuffer用于读取数据</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从通道中读取数据到缓冲区</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 切换 Buffer 到读模式</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 循环处理缓冲区中的完整消息</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">4</span>) &#123; <span class="comment">// 至少需要4个字节才能读取到长度字段</span></span><br><span class="line">                    buffer.mark(); <span class="comment">// 标记当前位置，如果消息不完整则恢复</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">contentLength</span> <span class="operator">=</span> buffer.getInt(); <span class="comment">// 读取4字节的消息长度</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果剩余的数据不足一个完整的消息体，则重置position并等待下一次读取</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.remaining() &lt; contentLength) &#123;</span><br><span class="line">                        buffer.reset(); <span class="comment">// 恢复到标记位置</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 退出循环，等待更多数据</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 读取一个完整的消息体</span></span><br><span class="line">                    <span class="type">byte</span>[] content = <span class="keyword">new</span> <span class="title class_">byte</span>[contentLength];</span><br><span class="line">                    buffer.get(content);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(content, StandardCharsets.UTF_8);</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到来自 &quot;</span> + socketChannel.getRemoteAddress() + <span class="string">&quot; 的完整消息: &quot;</span> + receivedMessage);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 回显消息给客户端，同样遵循 [长度+内容] 的协议</span></span><br><span class="line">                    <span class="type">byte</span>[] responseBytes = (<span class="string">&quot;回显: &quot;</span> + receivedMessage).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">responseBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span> + responseBytes.length);</span><br><span class="line">                    responseBuffer.putInt(responseBytes.length);</span><br><span class="line">                    responseBuffer.put(responseBytes);</span><br><span class="line">                    responseBuffer.flip();</span><br><span class="line">                    socketChannel.write(responseBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将未处理完的数据（半包）移到缓冲区开头，为下一次读取做准备</span></span><br><span class="line">                buffer.compact();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 客户端正常关闭连接</span></span><br><span class="line">                handleClientClose(key, socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// bytesRead == 0 的情况表示暂时没有数据，忽略即可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 客户端异常断开连接</span></span><br><span class="line">            handleClientClose(key, socketChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理客户端关闭连接的情况</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 选择键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socketChannel 套接字通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO操作异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleClientClose</span><span class="params">(SelectionKey key, SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端关闭或异常断开连接: &quot;</span> + socketChannel.getRemoteAddress());</span><br><span class="line">        key.cancel(); <span class="comment">// 取消注册的选择键</span></span><br><span class="line">        socketChannel.close(); <span class="comment">// 关闭通道</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP客户端类，用于与TCP服务器进行通信</span></span><br><span class="line"><span class="comment"> * 使用NIO SocketChannel实现非阻塞通信</span></span><br><span class="line"><span class="comment"> * 支持发送和接收带长度前缀的消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端主方法</span></span><br><span class="line"><span class="comment">     * 建立与服务器的连接，启动读取线程，并处理用户输入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 命令行参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 SocketChannel</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">            <span class="comment">// 连接服务器</span></span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 设置为非阻塞模式，以便读取操作不会一直等待</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;已连接到服务器，可以开始输入消息。&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动一个线程来读取服务器的响应</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 创建读取缓冲区</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">2048</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 循环读取服务器响应</span></span><br><span class="line">                    <span class="keyword">while</span> (socketChannel.isOpen()) &#123;</span><br><span class="line">                        <span class="comment">// 读取服务器响应</span></span><br><span class="line">                        <span class="keyword">if</span> (socketChannel.read(readBuffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 切换缓冲区为读模式</span></span><br><span class="line">                            readBuffer.flip();</span><br><span class="line">                            <span class="comment">// 处理缓冲区中的所有完整消息</span></span><br><span class="line">                            <span class="keyword">while</span> (readBuffer.remaining() &gt; <span class="number">4</span>) &#123;</span><br><span class="line">                                <span class="comment">// 标记当前位置，以便后续回退</span></span><br><span class="line">                                readBuffer.mark();</span><br><span class="line">                                <span class="comment">// 读取消息长度（前4字节）</span></span><br><span class="line">                                <span class="type">int</span> <span class="variable">contentLength</span> <span class="operator">=</span> readBuffer.getInt();</span><br><span class="line">                                <span class="comment">// 检查缓冲区中是否有足够的数据</span></span><br><span class="line">                                <span class="keyword">if</span> (readBuffer.remaining() &lt; contentLength) &#123;</span><br><span class="line">                                    <span class="comment">// 数据不完整，回退并等待更多数据</span></span><br><span class="line">                                    readBuffer.reset();</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 读取消息体</span></span><br><span class="line">                                <span class="type">byte</span>[] content = <span class="keyword">new</span> <span class="title class_">byte</span>[contentLength];</span><br><span class="line">                                readBuffer.get(content);</span><br><span class="line">                                <span class="comment">// 输出接收到的消息</span></span><br><span class="line">                                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(content, StandardCharsets.UTF_8));</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 压缩缓冲区，为下一次读取做准备</span></span><br><span class="line">                            readBuffer.compact();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;与服务器的连接已断开。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 主线程用于发送数据</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要发送的消息（输入&#x27;exit&#x27;退出）：&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(message)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sendMessage(socketChannel, message);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            socketChannel.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接已关闭。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;客户端发生IO异常：&quot;</span> + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息到服务器</span></span><br><span class="line"><span class="comment">     * 消息格式：4字节长度 + 消息体</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel  SocketChannel连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message  要发送的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(SocketChannel channel, String message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (message == <span class="literal">null</span> || message.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将消息转换为字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] messageBytes = message.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">// 创建一个大小为 4 + 消息体长度 的ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span> + messageBytes.length);</span><br><span class="line">        <span class="comment">// 放入4字节的长度</span></span><br><span class="line">        buffer.putInt(messageBytes.length);</span><br><span class="line">        <span class="comment">// 放入消息体</span></span><br><span class="line">        buffer.put(messageBytes);</span><br><span class="line">        <span class="comment">// 切换到读模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-3-AIO-Asynchronous-I-O-异步I-O"><a href="#4-3-AIO-Asynchronous-I-O-异步I-O" class="headerlink" title="4.3 AIO (Asynchronous I&#x2F;O - 异步I&#x2F;O)"></a>4.3 AIO (Asynchronous I&#x2F;O - 异步I&#x2F;O)</h3><ul>
<li><strong>模型</strong>: Java 1.7引入，也称为NIO.2。是真正的异步非阻塞I&#x2F;O。</li>
<li><strong>工作模式 (Proactor模式)</strong>:<ul>
<li>应用程序发起一个I&#x2F;O操作后，<strong>立即返回</strong>，不需要等待操作完成。</li>
<li>由操作系统来完成整个I&#x2F;O操作。</li>
<li>当操作完成后，操作系统会<strong>通知</strong>应用程序，应用程序通过回调函数（<code>CompletionHandler</code>）或<code>Future</code>对象来处理结果。</li>
</ul>
</li>
<li><strong>与NIO的区别</strong>:<ul>
<li><strong>NIO (Reactor)</strong>: 应用程序需要自己轮询（<code>select</code>）哪些通道<strong>准备好了I&#x2F;O</strong>，然后<strong>自己去执行I&#x2F;O操作</strong>（读&#x2F;写）。</li>
<li><strong>AIO (Proactor)</strong>: 应用程序告诉操作系统去执行I&#x2F;O操作，操作系统<strong>完成后通知</strong>应用程序。</li>
</ul>
</li>
<li><strong>优点</strong>: 编程模型相比NIO更简单一些，将I&#x2F;O操作完全交给了操作系统。</li>
<li><strong>缺点</strong>: 在Linux上，AIO的底层实现是基于epoll模拟的，性能提升并不明显。因此，在高性能网络服务器领域，基于NIO的框架（如Netty）仍然是主流选择。</li>
</ul>
<hr>
<h2 id="5-高级网络编程概念概览"><a href="#5-高级网络编程概念概览" class="headerlink" title="5. 高级网络编程概念概览"></a>5. 高级网络编程概念概览</h2><p>这些是构建在TCP&#x2F;UDP和I&#x2F;O模型之上的更高级的应用层协议或框架。</p>
<h3 id="5-1-HTTP-HyperText-Transfer-Protocol"><a href="#5-1-HTTP-HyperText-Transfer-Protocol" class="headerlink" title="5.1 HTTP (HyperText Transfer Protocol)"></a>5.1 HTTP (HyperText Transfer Protocol)</h3><ul>
<li><strong>简介</strong>: 应用层协议，构建于TCP之上。是Web开发的基础。采用请求&#x2F;响应模型，通常是无状态的。</li>
<li><strong>Java实现</strong>: 可以使用<code>HttpURLConnection</code>，但更常用的是第三方库如Apache HttpClient, OkHttp等。</li>
</ul>
<h3 id="5-2-Netty"><a href="#5-2-Netty" class="headerlink" title="5.2 Netty"></a>5.2 Netty</h3><ul>
<li><strong>简介</strong>: 一个高性能、异步、事件驱动的NIO客户端&#x2F;服务器框架。它极大地简化了Java网络编程，特别是NIO编程的复杂性。</li>
<li><strong>核心优势</strong>: 封装了NIO的复杂细节，提供了易于使用的API、强大的协议编解码支持、高可定制的事件处理管道（Pipeline）和对多种协议的内置支持。是构建高性能网络服务的首选框架。</li>
</ul>
<h3 id="5-3-SSL-TLS-Secure-Sockets-Layer-Transport-Layer-Security"><a href="#5-3-SSL-TLS-Secure-Sockets-Layer-Transport-Layer-Security" class="headerlink" title="5.3 SSL&#x2F;TLS (Secure Sockets Layer &#x2F; Transport Layer Security)"></a>5.3 SSL&#x2F;TLS (Secure Sockets Layer &#x2F; Transport Layer Security)</h3><ul>
<li><strong>简介</strong>: 在传输层和应用层之间提供安全服务的密码学协议。它为基于TCP的通信（如HTTP）提供了数据加密、完整性校验和身份认证。HTTPS就是HTTP over TLS。</li>
<li><strong>Java实现</strong>: Java通过<code>javax.net.ssl</code>包（如<code>SSLSocket</code>, <code>SSLEngine</code>）提供了对SSL&#x2F;TLS的原生支持。</li>
</ul>
<h3 id="5-4-WebSocket"><a href="#5-4-WebSocket" class="headerlink" title="5.4 WebSocket"></a>5.4 WebSocket</h3><ul>
<li><strong>简介</strong>: 一种在单个TCP连接上进行全双工通信的协议。它解决了HTTP协议单向、无状态的限制。</li>
<li><strong>核心优势</strong>: 客户端和服务器可以随时互相发送消息，延迟低，开销小。非常适合实时Web应用，如在线聊天、股票行情、实时协作等。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B8%83%E3%80%81Java%E6%96%B0%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B8%83%E3%80%81Java%E6%96%B0%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">七、Java新特性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:30:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:30:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-22 12:26:39" itemprop="dateModified" datetime="2025-11-22T12:26:39+08:00">2025-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="七、Java新特性"><a href="#七、Java新特性" class="headerlink" title="七、Java新特性"></a>七、Java新特性</h1><h2 id="1-Stream流"><a href="#1-Stream流" class="headerlink" title="1. Stream流"></a>1. Stream流</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p><strong>Stream</strong> 是 Java 8 引入的接口（<code>java.util.stream.Stream&lt;T&gt;</code>），用于描述数据集合的序列化处理管道。</p>
<p><strong>核心特性</strong>：</p>
<ul>
<li><strong>不是数据结构</strong>：Stream 不存储数据，它只是按需计算。</li>
<li><strong>不修改源数据</strong>：Stream 的操作不会改变源对象，而是返回一个新的结果。</li>
<li><strong>惰性求值（Lazy）</strong>：中间操作（Intermediate Operations）不会立即执行，只有遇到终结操作（Terminal Operation）时，流才会被触发计算。</li>
<li><strong>一次性使用</strong>：流一旦被消费（执行了终结操作），就不能再次使用了。</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>代码简洁：链式调用取代传统 for 循环。</li>
<li>并行友好：易于并行处理，提高性能。</li>
<li>函数式：支持 Lambda 表达式和方法引用。</li>
</ul>
<hr>
<h3 id="1-2-Stream-vs-传统集合操作"><a href="#1-2-Stream-vs-传统集合操作" class="headerlink" title="1.2 Stream vs 传统集合操作"></a>1.2 Stream vs 传统集合操作</h3><table>
<thead>
<tr>
<th>方面</th>
<th>传统方式 (for 循环)</th>
<th>Stream API</th>
</tr>
</thead>
<tbody><tr>
<td><strong>可读性</strong></td>
<td>较低，代码冗长</td>
<td>高，链式表达意图清晰</td>
</tr>
<tr>
<td><strong>并行</strong></td>
<td>需要手动线程管理</td>
<td>一键 <code>parallel()</code></td>
</tr>
<tr>
<td><strong>惰性</strong></td>
<td>无</td>
<td>支持短路优化</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单循环</td>
<td>复杂过滤&#x2F;转换&#x2F;聚合</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-Stream的生命周期与核心概念"><a href="#1-3-Stream的生命周期与核心概念" class="headerlink" title="1.3 Stream的生命周期与核心概念"></a>1.3 Stream的生命周期与核心概念</h3><p>Stream 的生命周期通常分为三个阶段：</p>
<ol>
<li><strong>创建流（Source）</strong>：从集合、数组或生成器中获取流。</li>
<li><strong>中间操作（Intermediate）</strong>：对数据进行处理（过滤、转换等），返回一个新的 Stream。</li>
<li><strong>终结操作（Terminal）</strong>：触发流的执行，产生最终结果（List、Integer、void 等）。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据源 -&gt; filter -&gt; map -&gt; sorted -&gt; collect (结果)</span><br><span class="line">(Source)    (中间操作 - 惰性)         (终结操作 - 触发)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-4-创建Stream"><a href="#1-4-创建Stream" class="headerlink" title="1.4 创建Stream"></a>1.4 创建Stream</h3><table>
<thead>
<tr>
<th align="left">创建方式</th>
<th align="left">方法</th>
<th align="left">示例代码</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>集合创建</strong></td>
<td align="left"><code>collection.stream()</code> 或 <code>collection.parallelStream()</code></td>
<td align="left"><code>List&lt;String&gt; list = ...; Stream&lt;String&gt; stream = list.stream();</code></td>
</tr>
<tr>
<td align="left"><strong>数组创建</strong></td>
<td align="left"><code>Arrays.stream(array)</code></td>
<td align="left"><code>String[] array = ...; Stream&lt;String&gt; stream = Arrays.stream(array);</code></td>
</tr>
<tr>
<td align="left"><strong>静态方法创建</strong></td>
<td align="left"><code>Stream.of(T... values)</code></td>
<td align="left"><code>Stream&lt;String&gt; stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>Stream.iterate(T seed, UnaryOperator&lt;T&gt; f)</code></td>
<td align="left"><code>Stream&lt;Integer&gt; evens = Stream.iterate(0, n -&gt; n + 2).limit(10); // 0, 2, 4...</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>Stream.generate(Supplier&lt;T&gt; s)</code></td>
<td align="left"><code>Stream&lt;Double&gt; randoms = Stream.generate(Math::random).limit(5);</code></td>
</tr>
<tr>
<td align="left"><strong>数值流</strong></td>
<td align="left"><code>IntStream.range(start, end)</code>, <code>LongStream.rangeClosed(...)</code></td>
<td align="left"><code>IntStream intStream = IntStream.range(1, 5); // 1, 2, 3, 4</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="1-5-常用中间操作"><a href="#1-5-常用中间操作" class="headerlink" title="1.5 常用中间操作"></a>1.5 常用中间操作</h3><h4 id="1-5-1-筛选与切片"><a href="#1-5-1-筛选与切片" class="headerlink" title="1.5.1 筛选与切片"></a>1.5.1 筛选与切片</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>filter(Predicate&lt;? super T&gt; predicate)</code></td>
<td align="left">筛选出满足条件的元素。</td>
</tr>
<tr>
<td align="left"><code>distinct()</code></td>
<td align="left">去除重复元素（依赖 <code>equals</code> 和 <code>hashCode</code>）。</td>
</tr>
<tr>
<td align="left"><code>limit(long maxSize)</code></td>
<td align="left">截断流，只取前maxSize个元素。</td>
</tr>
<tr>
<td align="left"><code>skip(long n)</code></td>
<td align="left">跳过，丢弃前 n 个元素。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt; <span class="number">3</span>) <span class="comment">// 长度大于3</span></span><br><span class="line">    .distinct()                  <span class="comment">// 去重</span></span><br><span class="line">    .limit(<span class="number">5</span>)                    <span class="comment">// 只取前5个</span></span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-5-2-映射-Mapping"><a href="#1-5-2-映射-Mapping" class="headerlink" title="1.5.2 映射 (Mapping)"></a>1.5.2 映射 (Mapping)</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>map(Function&lt;? super T, ? extends R&gt; mapper)</code></td>
<td align="left">将每个元素转换为另一个元素（一对一映射）。</td>
</tr>
<tr>
<td align="left"><code>flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</code></td>
<td align="left"><strong>扁平化映射</strong>。将每个元素转换为一个 Stream，然后将所有这些 Stream 连接成一个单一的 Stream（一对多映射）。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map: 获取所有用户的名字</span></span><br><span class="line">List&lt;String&gt; names = users.stream()</span><br><span class="line">                          .map(User::getName)</span><br><span class="line">                          .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// flatMap: 单词列表 -&gt; 字母列表</span></span><br><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">List&lt;String&gt; chars = words.stream()</span><br><span class="line">                          .map(w -&gt; w.split(<span class="string">&quot;&quot;</span>))</span><br><span class="line">                          .flatMap(Arrays::stream) <span class="comment">// 将多个数组流合并为一个流</span></span><br><span class="line">                          .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-5-3-排序"><a href="#1-5-3-排序" class="headerlink" title="1.5.3 排序"></a>1.5.3 排序</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>sorted()</code></td>
<td align="left">按自然顺序排序（元素需实现 <code>Comparable</code> 接口）。</td>
</tr>
<tr>
<td align="left"><code>sorted(Comparator&lt;? super T&gt; comparator)</code></td>
<td align="left">使用自定义比较器排序。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .sorted(Comparator.comparing(User::getAge).reversed()) <span class="comment">// 按年龄倒序</span></span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-5-4-调试"><a href="#1-5-4-调试" class="headerlink" title="1.5.4 调试"></a>1.5.4 调试</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>peek(Consumer&lt;? super T&gt; action)</code></td>
<td align="left">对每个元素执行一个操作，主要用于调试，查看流经此处的元素。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-6-常用终端操作"><a href="#1-6-常用终端操作" class="headerlink" title="1.6 常用终端操作"></a>1.6 常用终端操作</h3><h4 id="1-6-1-匹配与查找"><a href="#1-6-1-匹配与查找" class="headerlink" title="1.6.1 匹配与查找"></a>1.6.1 匹配与查找</h4><p>这些是<strong>短路操作 (Short-circuiting)</strong>，一旦找到满足条件的结果，就会立即停止计算。</p>
<table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>anyMatch(Predicate&lt;? super T&gt; predicate)</code></td>
<td align="left">是否有<strong>至少一个</strong>元素匹配。</td>
<td align="left"><code>boolean</code></td>
</tr>
<tr>
<td align="left"><code>allMatch(Predicate&lt;? super T&gt; predicate)</code></td>
<td align="left">是否<strong>所有</strong>元素都匹配。</td>
<td align="left"><code>boolean</code></td>
</tr>
<tr>
<td align="left"><code>noneMatch(Predicate&lt;? super T&gt; predicate)</code></td>
<td align="left">是否<strong>没有</strong>元素匹配。</td>
<td align="left"><code>boolean</code></td>
</tr>
<tr>
<td align="left"><code>findFirst()</code></td>
<td align="left">返回第一个元素。</td>
<td align="left"><code>Optional&lt;T&gt;</code></td>
</tr>
<tr>
<td align="left"><code>findAny()</code></td>
<td align="left">返回任意一个元素（在并行流中性能更好）。</td>
<td align="left"><code>Optional&lt;T&gt;</code></td>
</tr>
</tbody></table>
<hr>
<h4 id="1-6-2-归约-Reduction"><a href="#1-6-2-归约-Reduction" class="headerlink" title="1.6.2 归约 (Reduction)"></a>1.6.2 归约 (Reduction)</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>count()</code></td>
<td align="left">返回流中元素的总数。</td>
</tr>
<tr>
<td align="left"><code>max(Comparator&lt;? super T&gt; comparator)</code></td>
<td align="left">返回最大元素。</td>
</tr>
<tr>
<td align="left"><code>min(Comparator&lt;? super T&gt; comparator)</code></td>
<td align="left">返回最小元素。</td>
</tr>
<tr>
<td align="left"><code>reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></td>
<td align="left">将流中的元素反复结合起来，得到一个单一的值。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：计算数字列表的和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b); <span class="comment">// 0是初始值</span></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sumWithMethodRef</span> <span class="operator">=</span> numbers.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">System.out.println(sumWithMethodRef); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-6-3-收集-Collect"><a href="#1-6-3-收集-Collect" class="headerlink" title="1.6.3 收集 (Collect)"></a>1.6.3 收集 (Collect)</h4><p><code>collect</code> 是最强大、最灵活的终端操作，它能将 Stream 中的元素转换成各种形式的结果，如 <code>List</code>, <code>Set</code>, <code>Map</code> 等。</p>
<p>它接收一个 <code>Collector</code> 作为参数，而 <code>java.util.stream.Collectors</code> 工具类提供了大量静态工厂方法来创建常用的 <code>Collector</code>。</p>
<table>
<thead>
<tr>
<th align="left">Collector</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>toList()</code>, <code>toSet()</code></td>
<td align="left">收集到 List 或 Set。</td>
<td align="left"><code>...collect(Collectors.toList());</code></td>
</tr>
<tr>
<td align="left"><code>toMap(keyMapper, valueMapper)</code></td>
<td align="left">收集到 Map。<strong>注意：key 不能重复，否则会抛异常</strong>。</td>
<td align="left"><code>...collect(Collectors.toMap(Person::getId, person -&gt; person));</code></td>
</tr>
<tr>
<td align="left"><code>toMap(k, v, mergeFunction)</code></td>
<td align="left"><code>toMap</code> 的重载版本，用于处理 key 冲突。</td>
<td align="left"><code>...toMap(Person::getCity, Person::getName, (name1, name2) -&gt; name1 + &quot;, &quot; + name2));</code></td>
</tr>
<tr>
<td align="left"><code>joining(delimiter)</code></td>
<td align="left">将流中的 <code>String</code> 元素用分隔符连接起来。</td>
<td align="left"><code>...collect(Collectors.joining(&quot;, &quot;));</code></td>
</tr>
<tr>
<td align="left"><code>groupingBy(classifier)</code></td>
<td align="left"><strong>分组</strong>。根据一个分类函数对元素进行分组，返回一个 <code>Map</code>。</td>
<td align="left"><code>Map&lt;City, List&lt;Person&gt;&gt; peopleByCity = ...collect(Collectors.groupingBy(Person::getCity));</code></td>
</tr>
<tr>
<td align="left"><code>partitioningBy(predicate)</code></td>
<td align="left"><strong>分区</strong>。根据一个断言将元素分为 <code>true</code> 和 <code>false</code> 两组。</td>
<td align="left"><code>Map&lt;Boolean, List&lt;Person&gt;&gt; passingFailing = ...collect(Collectors.partitioningBy(s -&gt; s.getScore() &gt; 60));</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="1-7-示例"><a href="#1-7-示例" class="headerlink" title="1.7 示例"></a>1.7 示例</h3><p>假设我们有一个 <code>Employee</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String department;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="comment">// Constructor, getters, setters, toString...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需求</strong>：找出 “Engineering” 部门中，薪水最高的3名员工，并按薪水降序排列，最后返回他们的姓名列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamFullDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; employees = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">28</span>, <span class="string">&quot;Engineering&quot;</span>, <span class="number">90000</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">35</span>, <span class="string">&quot;Sales&quot;</span>, <span class="number">75000</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">22</span>, <span class="string">&quot;Engineering&quot;</span>, <span class="number">68000</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;David&quot;</span>, <span class="number">42</span>, <span class="string">&quot;Engineering&quot;</span>, <span class="number">120000</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Eve&quot;</span>, <span class="number">31</span>, <span class="string">&quot;HR&quot;</span>, <span class="number">60000</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Frank&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Engineering&quot;</span>, <span class="number">95000</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; topEngineers = employees.stream() <span class="comment">// 1. 获取 Stream</span></span><br><span class="line">            <span class="comment">// 2. 中间操作</span></span><br><span class="line">            .filter(e -&gt; <span class="string">&quot;Engineering&quot;</span>.equals(e.getDepartment())) <span class="comment">// 筛选出工程部门的员工</span></span><br><span class="line">            .sorted(Comparator.comparingDouble(Employee::getSalary).reversed()) <span class="comment">// 按薪水降序排列</span></span><br><span class="line">            .limit(<span class="number">3</span>) <span class="comment">// 取前3名</span></span><br><span class="line">            .map(Employee::getName) <span class="comment">// 提取员工姓名</span></span><br><span class="line">            <span class="comment">// 3. 终端操作</span></span><br><span class="line">            .collect(Collectors.toList()); <span class="comment">// 收集成 List</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Top 3 engineers by salary: &quot;</span> + topEngineers);</span><br><span class="line">        <span class="comment">// 输出: Top 3 engineers by salary: [David, Frank, Alice]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-8-并行流"><a href="#1-8-并行流" class="headerlink" title="1.8 并行流"></a>1.8 并行流</h3><ul>
<li><strong>创建</strong>: <code>collection.parallelStream()</code> 或 <code>stream.parallel()</code>。</li>
<li><strong>原理</strong>: 底层使用 <code>Fork/Join</code> 框架，将大数据块分解（fork）成小块，交给不同的线程处理，最后将结果合并（join）。</li>
<li><strong>适用场景</strong>:<ul>
<li>数据量巨大（成千上万个元素以上）。</li>
<li>每个元素的操作相对耗时（CPU密集型）。</li>
<li>操作之间是独立的，没有顺序要求。</li>
</ul>
</li>
<li><strong>警告与陷阱</strong>:<ul>
<li><strong>线程安全</strong>: 传递给并行流的 Lambda 表达式必须是无状态的，且不能修改共享变量，否则会产生线程安全问题。</li>
<li><strong>装箱&#x2F;拆箱开销</strong>: 对基本数据类型流（<code>IntStream</code>, <code>LongStream</code>, <code>DoubleStream</code>）进行操作可以避免昂贵的自动装箱&#x2F;拆箱开oversized，性能更好。</li>
<li><strong>并非总是更快</strong>: 对于小数据量或简单的操作，线程切换和管理的开销可能超过并行带来的好处。<strong>使用前请务必进行性能测试</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-9-最佳实践"><a href="#1-9-最佳实践" class="headerlink" title="1.9 最佳实践"></a>1.9 最佳实践</h3><ol>
<li><strong>无状态原则</strong>: 传递给中间操作的 Lambda 表达式应该是无状态的（Stateless），即其结果不应依赖于任何在 Stream pipeline 执行期间可能改变的状态。</li>
<li><strong>副作用最小化</strong>: 尽量避免在 <code>forEach</code> 之外的 Lambda 中产生副作用（如修改外部变量）。让 Stream 操作专注于数据转换。</li>
<li><strong>拥抱 Optional</strong>: <code>findFirst()</code>, <code>max()</code>, <code>min()</code> 等返回 <code>Optional</code> 的方法，强制你处理可能不存在的情况，能有效避免 <code>NullPointerException</code>。</li>
<li><strong>选择正确的 Collector</strong>: <code>groupingBy</code> 是处理复杂分组聚合的利器，要熟练掌握。</li>
<li><strong>注意可读性</strong>: 虽然可以写出很长的链式调用，但如果逻辑过于复杂，应考虑将其拆分成多个步骤或封装成私有方法，以保持代码的可读性。</li>
</ol>
<hr>
<h2 id="2-Optional"><a href="#2-Optional" class="headerlink" title="2. Optional"></a>2. Optional</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><h4 id="2-1-1-作用"><a href="#2-1-1-作用" class="headerlink" title="2.1.1 作用"></a>2.1.1 作用</h4><p>在 Java 8 之前，<code>null</code> 引用是导致 <code>NullPointerException</code> (NPE) 的主要元凶。我们通常需要编写大量的防御性代码来避免它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧的方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> user.getName();</span><br><span class="line"><span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(name.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种 <code>if (obj != null)</code> 的检查随处可见，不仅繁琐，而且容易遗忘，导致潜在的 NPE 风险。更糟糕的是，一个方法的返回类型是 <code>String</code>，但它有时可能会返回 <code>null</code>，这在方法的签名中完全看不出来，调用者必须去阅读文档或源码才能知道需要进行 null 检查。</p>
<p><code>Optional</code> 的出现就是为了解决这个问题。它是一个<strong>容器类</strong>，可以代表一个值的存在（<code>present</code>）或不存在（<code>absent</code>）。通过将可能为 <code>null</code> 的对象包装在 <code>Optional</code> 中，方法的返回类型 <code>Optional&lt;T&gt;</code> 就能清晰地告诉调用者：“这个结果可能不存在，你必须显式地处理这种情况。”</p>
<hr>
<h4 id="2-1-2-核心设计哲学"><a href="#2-1-2-核心设计哲学" class="headerlink" title="2.1.2 核心设计哲学"></a>2.1.2 核心设计哲学</h4><ul>
<li><strong>它不是 <code>null</code> 的替代品</strong>：<code>Optional</code> 的目的不是要消灭代码中所有的 <code>null</code>。它的主要应用场景是作为<strong>方法的返回值</strong>，明确表示一个值可能缺失。</li>
<li><strong>它是一种提醒和契约</strong>：使用 <code>Optional</code> 作为返回类型，就像是与调用者签订了一个契约，强制他们思考“如果值不存在该怎么办”。</li>
<li><strong>鼓励函数式编程</strong>：<code>Optional</code> 提供了丰富的函数式API（如 <code>map</code>, <code>flatMap</code>, <code>filter</code>），使得处理缺失值的逻辑可以优雅地链式调用，而不是嵌套在 <code>if-else</code> 块中。</li>
</ul>
<hr>
<h3 id="2-2-创建Oprional对象"><a href="#2-2-创建Oprional对象" class="headerlink" title="2.2 创建Oprional对象"></a>2.2 创建<code>Oprional</code>对象</h3><p><code>Optional</code> 的构造函数是私有的，我们必须使用其提供的三个静态工厂方法来创建实例。</p>
<table>
<thead>
<tr>
<th align="left">静态方法</th>
<th align="left">描述</th>
<th align="left">注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Optional.of(T value)</code></td>
<td align="left">创建一个包含给定值的 <code>Optional</code>。</td>
<td align="left"><strong>参数 <code>value</code> 绝不能为 <code>null</code></strong>，否则会立即抛出 <code>NullPointerException</code>。</td>
</tr>
<tr>
<td align="left"><code>Optional.ofNullable(T value)</code></td>
<td align="left">创建一个 <code>Optional</code>，如果 <code>value</code> 不为 <code>null</code>，则行为与 <code>of()</code> 相同；如果 <code>value</code> 为 <code>null</code>，则创建一个空的 <code>Optional</code>。</td>
<td align="left"><strong>最常用、最安全</strong>的创建方式。</td>
</tr>
<tr>
<td align="left"><code>Optional.empty()</code></td>
<td align="left">创建一个空的 <code>Optional</code> 实例。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 of() - 确定非空</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;John&quot;</span>;</span><br><span class="line">Optional&lt;String&gt; optName = Optional.of(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这行会立即抛出 NullPointerException</span></span><br><span class="line"><span class="comment">// Optional&lt;String&gt; optNull = Optional.of(null);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 ofNullable() - 可能为空</span></span><br><span class="line"><span class="type">String</span> <span class="variable">nullableName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;String&gt; optNullableName = Optional.ofNullable(nullableName); <span class="comment">// 返回一个空的 Optional</span></span><br><span class="line">Optional&lt;String&gt; optNonNull = Optional.ofNullable(<span class="string">&quot;Jane&quot;</span>);      <span class="comment">// 返回一个包含 &quot;Jane&quot; 的 Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用 empty()</span></span><br><span class="line">Optional&lt;String&gt; emptyOpt = Optional.empty();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-核心方法"><a href="#2-3-核心方法" class="headerlink" title="2.3 核心方法"></a>2.3 核心方法</h3><p>一旦我们有了一个 <code>Optional</code> 对象，我们就可以使用它的实例方法来安全地处理可能存在或缺失的值。</p>
<h4 id="2-3-1-判断与消费-Checking-and-Consuming"><a href="#2-3-1-判断与消费-Checking-and-Consuming" class="headerlink" title="2.3.1 判断与消费 (Checking and Consuming)"></a>2.3.1 判断与消费 (Checking and Consuming)</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean isPresent()</code></td>
<td align="left">如果值存在，返回 <code>true</code>，否则返回 <code>false</code>。（Java 11 后推荐使用 <code>isEmpty()</code>）</td>
</tr>
<tr>
<td align="left"><code>boolean isEmpty()</code></td>
<td align="left">（自 Java 11 起）如果值不存在，返回 <code>true</code>，否则返回 <code>false</code>。语义上更清晰。</td>
</tr>
<tr>
<td align="left"><code>void ifPresent(Consumer&lt;? super T&gt; consumer)</code></td>
<td align="left">如果值存在，就对该值执行给定的操作（<code>Consumer</code>），否则什么也不做。</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-3-2-获取值-Unwrapping-the-Value-谨慎使用-get"><a href="#2-3-2-获取值-Unwrapping-the-Value-谨慎使用-get" class="headerlink" title="2.3.2 获取值 (Unwrapping the Value) - 谨慎使用 get()"></a>2.3.2 获取值 (Unwrapping the Value) - 谨慎使用 <code>get()</code></h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>T get()</code></td>
<td align="left">如果值存在，返回值；否则抛出 <code>NoSuchElementException</code>。<strong>通常不推荐直接使用</strong>。</td>
</tr>
<tr>
<td align="left"><code>T orElse(T other)</code></td>
<td align="left">如果值存在，返回值；否则返回指定的默认值 <code>other</code>。<strong>非常常用</strong>。</td>
</tr>
<tr>
<td align="left"><code>T orElseGet(Supplier&lt;? extends T&gt; other)</code></td>
<td align="left">如果值存在，返回值；否则执行 <code>Supplier</code> 函数并返回其结果。</td>
</tr>
<tr>
<td align="left"><code>T orElseThrow()</code></td>
<td align="left">(自 Java 10 起) 如果值存在，返回值；否则抛出 <code>NoSuchElementException</code>。</td>
</tr>
<tr>
<td align="left"><code>&lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code></td>
<td align="left">如果值存在，返回值；否则抛出由 <code>Supplier</code> 创建的异常。<strong>自定义异常的最佳方式</strong>。</td>
</tr>
</tbody></table>
<p><strong><code>orElse()</code> vs <code>orElseGet()</code> 的区别</strong>:</p>
<ul>
<li><code>orElse(defaultValue)</code>: 无论 <code>Optional</code> 中是否有值，<code>defaultValue</code> 这个参数<strong>总会被求值</strong>。</li>
<li><code>orElseGet(supplier)</code>: 只有当 <code>Optional</code> 为空时，<code>supplier</code> 这个 Lambda 表达式<strong>才会被执行</strong>。</li>
</ul>
<p>如果默认值的创建开销很大（例如，需要调用一个方法或 new 一个新对象），<code>orElseGet()</code> 的<strong>懒加载</strong>特性可以带来性能优势。</p>
<hr>
<h4 id="2-3-3-函数式转换-Functional-Transformations"><a href="#2-3-3-函数式转换-Functional-Transformations" class="headerlink" title="2.3.3 函数式转换 (Functional Transformations)"></a>2.3.3 函数式转换 (Functional Transformations)</h4><p>这是 <code>Optional</code> 最强大的部分，允许我们以声明式的方式进行链式操作。</p>
<table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</code></td>
<td align="left">如果值存在，则对其应用 <code>mapper</code> 函数，并将结果包装在新的 <code>Optional</code> 中返回；如果为空，则返回一个空的 <code>Optional</code>。</td>
</tr>
<tr>
<td align="left"><code>Optional&lt;U&gt; flatMap(Function&lt;? super T, ? extends Optional&lt;? extends U&gt;&gt; mapper)</code></td>
<td align="left">与 <code>map</code> 类似，但要求 <code>mapper</code> 函数的返回值<strong>本身就是一个 <code>Optional</code></strong>。<code>flatMap</code> 会将这个结果“压平”，避免出现 <code>Optional&lt;Optional&lt;T&gt;&gt;</code> 这样的嵌套结构。</td>
</tr>
<tr>
<td align="left"><code>Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td>
<td align="left">如果值存在且满足 <code>predicate</code> 条件，则返回当前 <code>Optional</code>；否则返回一个空的 <code>Optional</code>。</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-4-最佳实践"><a href="#2-4-最佳实践" class="headerlink" title="2.4 最佳实践"></a>2.4 最佳实践</h3><p>假设有以下类结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个可能返回 null 的方法</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="comment">// ... 模拟查找</span></span><br><span class="line">    <span class="keyword">return</span> id.equals(<span class="string">&quot;123&quot;</span>) ? <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>) : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="范例1：使用-Optional-重构查找方法"><a href="#范例1：使用-Optional-重构查找方法" class="headerlink" title="范例1：使用 Optional 重构查找方法"></a>范例1：使用 <code>Optional</code> 重构查找方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;User&gt; <span class="title function_">findUserByIdOptional</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(findUserById(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，方法的签名 <code>Optional&lt;User&gt;</code> 清楚地表明了结果可能为空。</p>
<hr>
<h4 id="范例2：反模式-vs-推荐模式"><a href="#范例2：反模式-vs-推荐模式" class="headerlink" title="范例2：反模式 vs 推荐模式"></a>范例2：反模式 vs 推荐模式</h4><p><strong>反模式：<code>isPresent()</code> + <code>get()</code></strong> - 这与传统的 <code>if (obj != null)</code> 几乎没有区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反模式 (Anti-Pattern)</span></span><br><span class="line">Optional&lt;User&gt; userOpt = findUserByIdOptional(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (userOpt.isPresent()) &#123;</span><br><span class="line">    System.out.println(userOpt.get().getName());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;User not found.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>推荐模式：使用 <code>orElse</code>, <code>ifPresent</code>, <code>map</code> 等</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐方式 1: 提供默认值</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> findUserByIdOptional(<span class="string">&quot;404&quot;</span>).orElse(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Default User&quot;</span>));</span><br><span class="line">System.out.println(user.getName()); <span class="comment">// 输出: Default User</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐方式 2: 值存在时执行操作</span></span><br><span class="line">findUserByIdOptional(<span class="string">&quot;123&quot;</span>).ifPresent(u -&gt; System.out.println(u.getName())); <span class="comment">// 输出: Alice</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐方式 3: 链式调用，获取用户名，不存在则返回 &quot;Guest&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> findUserByIdOptional(<span class="string">&quot;404&quot;</span>)</span><br><span class="line">                    .map(User::getName) <span class="comment">// Optional&lt;User&gt; -&gt; Optional&lt;String&gt;</span></span><br><span class="line">                    .orElse(<span class="string">&quot;Guest&quot;</span>);</span><br><span class="line">System.out.println(username); <span class="comment">// 输出: Guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐方式 4: 找不到用户时抛出自定义异常</span></span><br><span class="line"><span class="type">User</span> <span class="variable">foundUser</span> <span class="operator">=</span> findUserByIdOptional(<span class="string">&quot;404&quot;</span>)</span><br><span class="line">                    .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">ResourceNotFoundException</span>(<span class="string">&quot;User not found&quot;</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="范例3：map-vs-flatMap"><a href="#范例3：map-vs-flatMap" class="headerlink" title="范例3：map vs flatMap"></a>范例3：<code>map</code> vs <code>flatMap</code></h4><p>假设 <code>User</code> 有一个返回 <code>Optional&lt;Address&gt;</code> 的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Address&gt; <span class="title function_">getAddress</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStreet</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需求</strong>：获取用户的街道地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;User&gt; userOpt = findUserByIdOptional(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用 map, 会得到嵌套的 Optional: Optional&lt;Optional&lt;String&gt;&gt;</span></span><br><span class="line">Optional&lt;Optional&lt;String&gt;&gt; nestedStreet = userOpt.map(u -&gt; u.getAddress().map(Address::getStreet));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 flatMap 可以优雅地解决这个问题</span></span><br><span class="line">Optional&lt;String&gt; street = userOpt.flatMap(User::getAddress) <span class="comment">// flatMap 后是 Optional&lt;Address&gt;</span></span><br><span class="line">                                 .map(Address::getStreet); <span class="comment">// map 后是 Optional&lt;String&gt;</span></span><br><span class="line"></span><br><span class="line">street.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-常见误区与注意事项"><a href="#2-5-常见误区与注意事项" class="headerlink" title="2.5 常见误区与注意事项"></a>2.5 常见误区与注意事项</h3><ol>
<li><strong>不要用 <code>Optional</code> 作为类的字段</strong>：<code>Optional</code> 没有实现 <code>Serializable</code> 接口，这会导致序列化问题。字段为空可以直接用 <code>null</code> 表示。</li>
<li><strong>不要用 <code>Optional</code> 作为方法的参数</strong>：这会使方法调用变得笨拙。如果一个参数是可选的，应该使用方法重载。</li>
<li><strong>不要用 <code>Optional</code> 包装集合</strong>：一个返回集合的方法，如果没有结果，应该返回一个<strong>空的集合</strong>（如 <code>Collections.emptyList()</code>），而不是 <code>Optional&lt;List&lt;T&gt;&gt;</code>。这更符合直觉且调用方无需额外处理 <code>Optional</code>。</li>
</ol>
<hr>
<h2 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3. Lambda表达式"></a>3. Lambda表达式</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><ul>
<li><strong>引入版本</strong>：Java 8。</li>
<li><strong>本质</strong>：Lambda 表达式在 Java 中本质上是一个<strong>匿名函数</strong>。它提供了一种简洁的方式来表示代码块（行为），并可以将这些代码块作为参数传递给方法。</li>
<li><strong>目的</strong>：<ol>
<li>减少冗余代码（特别是匿名内部类）。</li>
<li>支持函数式编程风格。</li>
<li>为 Stream API（流式处理）提供基础支持。</li>
</ol>
</li>
</ul>
<p>在 Java 8 之前，如果想传递一段代码逻辑（比如一个比较器或一个任务），必须使用<strong>匿名内部类</strong>。</p>
<p><strong>示例：使用匿名内部类排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.compareTo(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种写法的缺点显而易见：</p>
<ul>
<li><strong>语法冗余（Boilerplate Code）</strong>: 为了实现一个简单的方法，需要写很多模板化的代码（<code>new Comparator&lt;String&gt;()</code>, <code>@Override</code>, 方法签名等）。</li>
<li><strong>可读性差</strong>: 核心逻辑 <code>a.compareTo(b)</code> 被包裹在大量的语法噪音中。</li>
</ul>
<p>Lambda 表达式正是为了解决这些问题而生的。</p>
<p><strong>示例：使用 Lambda 表达式排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a.compareTo(b);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码已经简洁了很多。我们还可以进一步简化它，这将在后面详细讲解。</p>
<hr>
<h3 id="3-2-Lambda-表达式的核心语法"><a href="#3-2-Lambda-表达式的核心语法" class="headerlink" title="3.2 Lambda 表达式的核心语法"></a>3.2 Lambda 表达式的核心语法</h3><p>Lambda 表达式的基本语法结构是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<p>它由三部分组成：</p>
<ol>
<li><strong>参数列表 (Parameter list)</strong>: <code>(String a, String b)</code></li>
<li><strong>箭头符号 (Arrow token)</strong>: <code>-&gt;</code></li>
<li><strong>主体 (Body)</strong>: 可以是一个表达式，也可以是一个代码块。</li>
</ol>
<p><strong>语法简化规则</strong></p>
<p>Java 编译器可以根据上下文推断出很多信息，因此 Lambda 表达式可以写得非常简洁。</p>
<ol>
<li><p><strong>类型推断</strong>: 编译器可以推断参数类型，所以可以省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (String a, String b) 可以简化为 (a, b)</span></span><br><span class="line">Collections.sort(names, (a, b) -&gt; a.compareTo(b));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>单参数时省略括号</strong>: 如果参数列表只有一个参数，可以省略括号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function&lt;String, String&gt; func = (String s) -&gt; s.toUpperCase();</span></span><br><span class="line">Function&lt;String, String&gt; func = s -&gt; s.toUpperCase();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>单行表达式时省略大括号和 <code>return</code></strong>: 如果主体只有一行表达式，可以省略大括号 <code>{}</code> 和 <code>return</code> 关键字。该表达式的结果就是返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (a, b) -&gt; &#123; return a.compareTo(b); &#125; 可以简化为 (a, b) -&gt; a.compareTo(b)</span></span><br><span class="line">Collections.sort(names, (a, b) -&gt; a.compareTo(b));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无参数时使用空括号</strong>: 如果没有参数，需要使用一对空括号 <code>()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello Lambda!&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="3-3-函数式接口"><a href="#3-3-函数式接口" class="headerlink" title="3.3 函数式接口"></a>3.3 函数式接口</h3><h4 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1 概述"></a>3.3.1 概述</h4><p>Lambda 表达式必须依赖于<strong>函数式接口</strong>才能运行。</p>
<ul>
<li><strong>定义</strong>：接口中<strong>有且仅有一个抽象方法</strong>的接口。</li>
<li><strong>注解</strong>：Java 8 引入<code>@FunctionalInterface</code>（可选，但推荐加上，用于编译器检查）。</li>
<li><strong>特例</strong>：接口中可以包含默认方法（default methods）和静态方法（static methods），只要抽象方法只有一个即可。</li>
</ul>
<p><strong>示例：<code>Runnable</code> 接口就是一个函数式接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Comparator</code> 也是，它只有一个抽象方法 <code>compare()</code>。</p>
<p>Lambda 表达式的参数列表和返回类型必须与函数式接口中抽象方法的签名相匹配。</p>
<hr>
<h4 id="3-3-2-内置四大核心函数式接口"><a href="#3-3-2-内置四大核心函数式接口" class="headerlink" title="3.3.2 内置四大核心函数式接口"></a>3.3.2 内置四大核心函数式接口</h4><p>Java 8 在 <code>java.util.function</code> 包中预定义了大量常用的函数式接口，以满足各种场景的需求。</p>
<table>
<thead>
<tr>
<th align="left">接口名</th>
<th align="left">抽象方法</th>
<th align="left">描述</th>
<th align="left">典型用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>Consumer&lt;T&gt;</code></strong></td>
<td align="left"><code>void accept(T t)</code></td>
<td align="left"><strong>消费型接口</strong>：接收一个参数，无返回值。</td>
<td align="left">打印日志、修改对象属性</td>
</tr>
<tr>
<td align="left"><strong><code>Supplier&lt;T&gt;</code></strong></td>
<td align="left"><code>T get()</code></td>
<td align="left"><strong>供给型接口</strong>：不接收参数，返回一个结果。</td>
<td align="left">工厂方法、获取随机数</td>
</tr>
<tr>
<td align="left"><strong><code>Function&lt;T, R&gt;</code></strong></td>
<td align="left"><code>R apply(T t)</code></td>
<td align="left"><strong>函数型接口</strong>：接收类型 T，返回类型 R。</td>
<td align="left">数据类型转换、计算</td>
</tr>
<tr>
<td align="left"><strong><code>Predicate&lt;T&gt;</code></strong></td>
<td align="left"><code>boolean test(T t)</code></td>
<td align="left"><strong>断言型接口</strong>：接收一个参数，返回布尔值。</td>
<td align="left">逻辑判断、过滤数据</td>
</tr>
<tr>
<td align="left"><strong><code>UnaryOperator&lt;T&gt;</code></strong></td>
<td align="left"><code>T apply(T t)</code></td>
<td align="left"><strong>函数型接口</strong>：<code>Function</code>的特例，输入输出类型相同。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong><code>BinaryOperator&lt;T&gt;</code></strong></td>
<td align="left"><code>T apply(T t1, T t2)</code></td>
<td align="left"><strong>函数型接口</strong>：接收两个同类型参数，返回同类型结果。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>此外，还有针对基本数据类型（<code>int</code>, <code>long</code>, <code>double</code>）的特化版本，如 <code>IntPredicate</code>, <code>LongConsumer</code>, <code>DoubleFunction</code> 等，以避免自动装箱&#x2F;拆箱带来的性能开销。</p>
<p><strong>代码示例：</strong></p>
<p><strong>1. Consumer (消费型)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; printer = s -&gt; System.out.println(<span class="string">&quot;Processing: &quot;</span> + s);</span><br><span class="line">printer.accept(<span class="string">&quot;Hello Java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>2. Supplier (供给型)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Double&gt; randomizer = () -&gt; Math.random();</span><br><span class="line">System.out.println(randomizer.get());</span><br></pre></td></tr></table></figure>

<p><strong>3. Function (函数型)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; strLength = s -&gt; s.length();</span><br><span class="line">System.out.println(strLength.apply(<span class="string">&quot;Lambda&quot;</span>)); <span class="comment">// 输出 6</span></span><br></pre></td></tr></table></figure>

<p><strong>4. Predicate (断言型)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; isEven = n -&gt; n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">System.out.println(isEven.test(<span class="number">4</span>)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-方法引用"><a href="#3-4-方法引用" class="headerlink" title="3.4 方法引用"></a>3.4 方法引用</h3><p>当 Lambda 表达式的方法体<strong>仅仅是调用一个已存在的方法</strong>时，可以使用方法引用来进一步简化代码。符号为 <code>::</code>。</p>
<p><strong>四种类型的方法引用</strong></p>
<ol>
<li><strong>静态方法引用 (Static Method Reference)</strong><ul>
<li><strong>语法</strong>: <code>ClassName::staticMethodName</code></li>
<li><strong>Lambda</strong>: <code>(args) -&gt; ClassName.staticMethod(args)</code></li>
<li><strong>Ref</strong>: <code>ClassName::staticMethod</code></li>
<li><strong>Example</strong>: <code>Math::max</code> 等同于 <code>(x, y) -&gt; Math.max(x, y)</code></li>
</ul>
</li>
<li><strong>实例方法引用 (Instance Method Reference on a Specific Object)</strong><ul>
<li><strong>语法</strong>: <code>instance::instanceMethodName</code></li>
<li><strong>Lambda</strong>: <code>(args) -&gt; instance.method(args)</code></li>
<li><strong>Ref</strong>: <code>System.out::println</code></li>
<li><strong>Example</strong>: <code>list.forEach(System.out::println)</code></li>
</ul>
</li>
<li><strong>特定类型的任意对象的实例方法引用</strong><ul>
<li><strong>语法</strong>: <code>ClassName::instanceMethodName</code></li>
<li><strong>Lambda</strong>: <code>(obj, args) -&gt; obj.instanceMethod(args)</code></li>
<li><strong>Ref</strong>: <code>String::compareTo</code></li>
<li><strong>Example</strong>: <code>(s1, s2) -&gt; s1.compareTo(s2)</code> 变为 <code>String::compareTo</code></li>
</ul>
</li>
<li><strong>构造方法引用 (Constructor Reference)</strong><ul>
<li><strong>语法</strong>: <code>ClassName::new</code></li>
<li><strong>Lambda</strong>: <code>() -&gt; new ArrayList&lt;&gt;()</code></li>
<li><strong>Ref</strong>: <code>ArrayList::new</code></li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-5-Lambda表达式的变量捕获"><a href="#3-5-Lambda表达式的变量捕获" class="headerlink" title="3.5 Lambda表达式的变量捕获"></a>3.5 Lambda表达式的变量捕获</h3><p>Lambda 表达式可以访问其外部作用域的变量，这个过程称为“捕获”。</p>
<ul>
<li><strong>捕获局部变量</strong>：<ul>
<li>Lambda 内部可以捕获外部的局部变量。</li>
<li><strong>限制</strong>：该变量必须是 <code>final</code> 或者 <strong>effectively final</strong>（即初始化后从未被修改过）。</li>
<li><em>原因</em>：为了防止并发问题（Java 的闭包是通过值拷贝实现的）。</li>
</ul>
</li>
<li><strong>捕获成员变量和静态变量</strong>：<ul>
<li>没有限制，可以读取和修改。</li>
</ul>
</li>
<li><strong>捕获this 关键字</strong>：<ul>
<li>在 Lambda 内部，<code>this</code> 指向的是<strong>创建该 Lambda 的外部类实例</strong>，而不是 Lambda 本身（这点与匿名内部类不同）。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaScopeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// num 是 effectively final</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;The number is: &quot;</span> + num);</span><br><span class="line">        r.run();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在这里修改 num 的值，上面的 Lambda 就会编译失败</span></span><br><span class="line">        <span class="comment">// num = 20; // Error: Variable &#x27;num&#x27; is accessed from within inner class, needs to be final or effectively final</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么有这个限制？</strong></p>
<p>这是为了避免在多线程环境下（Lambda 表达式常用于并发）出现线程安全问题。如果 Lambda 可以修改外部变量，那么当 Lambda 在另一个线程执行时，就可能出现数据不一致的问题。Java 设计者通过强制变量为事实 final 来简化并发模型，避免了这类错误。</p>
<hr>
<h3 id="3-7-Lambda-与-Stream-API-实战"><a href="#3-7-Lambda-与-Stream-API-实战" class="headerlink" title="3.7 Lambda 与 Stream API 实战"></a>3.7 Lambda 与 Stream API 实战</h3><p>Lambda 最强大的威力体现在集合操作上，结合 <code>Stream API</code>。</p>
<p><strong>场景：有一个用户列表，找出年龄大于 20 岁的用户姓名，转换为大写并排序。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; users = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">23</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">19</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">25</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式：需要写循环、if判断、临时集合</span></span><br><span class="line"><span class="comment">// ...（省略冗长代码）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda + Stream 方式：</span></span><br><span class="line">List&lt;String&gt; names = users.stream()</span><br><span class="line">    .filter(u -&gt; u.getAge() &gt; <span class="number">20</span>)       <span class="comment">// Predicate: 筛选</span></span><br><span class="line">    .map(u -&gt; u.getName().toUpperCase())<span class="comment">// Function: 转换</span></span><br><span class="line">    .sorted()                           <span class="comment">// Comparator: 排序</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(names); <span class="comment">// [ALICE, CHARLIE]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-8-最佳实践"><a href="#3-8-最佳实践" class="headerlink" title="3.8 最佳实践"></a>3.8 最佳实践</h3><ol>
<li><strong>优先使用 Lambda</strong>: 在任何需要函数式接口的地方，优先使用 Lambda 表达式或方法引用，而不是匿名内部类。</li>
<li><strong>保持简洁</strong>: Lambda 的威力在于其简洁性。如果一个 Lambda 的主体变得很长（超过3行），考虑将其重构为一个独立的私有方法，然后使用方法引用。</li>
<li><strong>明确类型 vs 类型推断</strong>: 在大多数情况下，让编译器进行类型推断。但如果 Lambda 逻辑复杂，显式声明参数类型可以提高可读性。</li>
<li><strong>熟悉 <code>java.util.function</code></strong>: 这是使用 Lambda 和 Stream API 的基础，必须熟练掌握并优先使用避免过度自定义接口。</li>
<li><strong>理解闭包和变量捕获</strong>: 清楚 Lambda 能够访问哪些变量以及相关的限制，是编写正确代码的关键。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%85%AD%E3%80%81%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%85%AD%E3%80%81%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/" class="post-title-link" itemprop="url">六、常用工具类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:25:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:25:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-23 11:26:01" itemprop="dateModified" datetime="2025-11-23T11:26:01+08:00">2025-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="六、常用工具类"><a href="#六、常用工具类" class="headerlink" title="六、常用工具类"></a>六、常用工具类</h1><h2 id="1-Math"><a href="#1-Math" class="headerlink" title="1. Math"></a>1. Math</h2><h3 id="1-1-简介-Introduction"><a href="#1-1-简介-Introduction" class="headerlink" title="1.1 简介 (Introduction)"></a>1.1 简介 (Introduction)</h3><p><code>java.lang.Math</code> 类是一个工具类，提供了执行基本数学运算所需的方法，如初等指数、对数、平方根和三角函数。它包含了大量的静态方法，方便我们随时调用。</p>
<hr>
<h3 id="1-2-核心特点"><a href="#1-2-核心特点" class="headerlink" title="1.2 核心特点"></a>1.2 核心特点</h3><ul>
<li><strong>final 类</strong>: <code>Math</code> 类被声明为 <code>final</code>，因此不能被继承。</li>
<li><strong>私有构造函数</strong>: 它的构造函数是 <code>private</code> 的，这意味着无法创建 <code>Math</code> 类的实例。强制只能通过类名直接调用其静态方法。</li>
<li><strong>静态成员</strong>: 所有的字段（如 <code>PI</code>, <code>E</code>）和方法都是 <code>static</code> 的。</li>
<li><strong>无需导入</strong>: 因为 <code>Math</code> 类位于 <code>java.lang</code> 包下，所以在任何Java代码中都可以直接使用，无需显式 <code>import</code>。</li>
</ul>
<hr>
<h3 id="1-3-常用方法详解与示例"><a href="#1-3-常用方法详解与示例" class="headerlink" title="1.3 常用方法详解与示例"></a>1.3 常用方法详解与示例</h3><h4 id="1-3-1-基本运算"><a href="#1-3-1-基本运算" class="headerlink" title="1.3.1 基本运算"></a>1.3.1 基本运算</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static double abs(double a)</code></td>
<td align="left">返回一个数的绝对值（有 <code>int</code>, <code>long</code>, <code>float</code> 的重载版本）。</td>
</tr>
<tr>
<td align="left"><code>static double pow(double a, double b)</code></td>
<td align="left">返回第一个参数的第二个参数次幂的值，即 $a^b$。</td>
</tr>
<tr>
<td align="left"><code>static double sqrt(double a)</code></td>
<td align="left">返回一个数的平方根，即$\sqrt{a}$。</td>
</tr>
<tr>
<td align="left"><code>static double cbrt(double a)</code></td>
<td align="left">返回一个数的立方根，即$\sqrt[3]{a}$。</td>
</tr>
<tr>
<td align="left"><code>static double max(double a, double b)</code></td>
<td align="left">返回两个数中的较大值（有 <code>int</code>, <code>long</code>, <code>float</code> 的重载版本）。</td>
</tr>
<tr>
<td align="left"><code>static double min(double a, double b)</code></td>
<td align="left">返回两个数中的较小值（有 <code>int</code>, <code>long</code>, <code>float</code> 的重载版本）。</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-3-2-取整运算"><a href="#1-3-2-取整运算" class="headerlink" title="1.3.2 取整运算"></a>1.3.2 取整运算</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static double ceil(double a)</code></td>
<td align="left"><strong>向上取整</strong>。返回大于或等于参数的最小整数（类型为double）。</td>
</tr>
<tr>
<td align="left"><code>static double floor(double a)</code></td>
<td align="left"><strong>向下取整</strong>。返回小于或等于参数的最大整数（类型为double）。</td>
</tr>
<tr>
<td align="left"><code>static long round(double a)</code></td>
<td align="left"><strong>四舍五入</strong>。返回最接近参数的 <code>long</code> 型整数。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>: <code>Math.round(1.5)</code> 结果是2，<code>Math.round(-1.5)</code> 结果是-1。其算法是 <code>Math.floor(x+0.5)</code>。</p>
</blockquote>
<hr>
<h4 id="1-3-3-随机数"><a href="#1-3-3-随机数" class="headerlink" title="1.3.3 随机数"></a>1.3.3 随机数</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static double random()</code></td>
<td align="left">返回一个 <code>[0.0, 1.0)</code> 范围内的伪随机 <code>double</code> 值。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>高级技巧</strong>:</p>
<ul>
<li>生成 <code>[min, max]</code> 范围的随机整数: <code>(int) (Math.random() * (max - min + 1) + min)</code></li>
<li>在并发或需要更高质量随机数的场景下，推荐使用 <code>java.util.Random</code> 类或 <code>java.util.concurrent.ThreadLocalRandom</code>。</li>
</ul>
</blockquote>
<hr>
<h4 id="1-3-4-三角函数与常数"><a href="#1-3-4-三角函数与常数" class="headerlink" title="1.3.4 三角函数与常数"></a>1.3.4 三角函数与常数</h4><table>
<thead>
<tr>
<th align="left">成员</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static final double PI</code></td>
<td align="left">圆周率 π。</td>
</tr>
<tr>
<td align="left"><code>static final double E</code></td>
<td align="left">自然对数的底数 e。</td>
</tr>
<tr>
<td align="left"><code>static double sin(double a)</code></td>
<td align="left">返回角的三角正弦（参数为弧度）。</td>
</tr>
<tr>
<td align="left"><code>static double cos(double a)</code></td>
<td align="left">返回角的三角余弦（参数为弧度）。</td>
</tr>
<tr>
<td align="left"><code>static double toRadians(double angdeg)</code></td>
<td align="left">将角度转换为弧度。</td>
</tr>
<tr>
<td align="left"><code>static double toDegrees(double angrad)</code></td>
<td align="left">将弧度转换为角度。</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 基本运算</span></span><br><span class="line">        System.out.println(<span class="string">&quot;绝对值: &quot;</span> + Math.abs(-<span class="number">99</span>)); <span class="comment">// 99</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2的3次方: &quot;</span> + Math.pow(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 8.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;16的平方根: &quot;</span> + Math.sqrt(<span class="number">16</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最大值: &quot;</span> + Math.max(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 取整运算</span></span><br><span class="line">        System.out.println(<span class="string">&quot;向上取整 (3.14): &quot;</span> + Math.ceil(<span class="number">3.14</span>));   <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;向下取整 (3.78): &quot;</span> + Math.floor(<span class="number">3.78</span>));  <span class="comment">// 3.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;四舍五入 (3.5): &quot;</span> + Math.round(<span class="number">3.5</span>));    <span class="comment">// 4</span></span><br><span class="line">        System.out.println(<span class="string">&quot;四舍五入 (-3.5): &quot;</span> + Math.round(-<span class="number">3.5</span>));  <span class="comment">// -3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 随机数</span></span><br><span class="line">        <span class="comment">// 生成一个 [0.0, 1.0) 之间的随机数</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">randomValue</span> <span class="operator">=</span> Math.random();</span><br><span class="line">        System.out.println(<span class="string">&quot;0-1随机数: &quot;</span> + randomValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个 [10, 20] 之间的随机整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">10</span>, max = <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomInt</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * (max - min + <span class="number">1</span>) + min);</span><br><span class="line">        System.out.println(<span class="string">&quot;10-20随机整数: &quot;</span> + randomInt);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 常量与三角函数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;PI: &quot;</span> + Math.PI);</span><br><span class="line">        <span class="comment">// 计算90度的正弦值</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">sin90</span> <span class="operator">=</span> Math.sin(Math.toRadians(<span class="number">90</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;sin(90°): &quot;</span> + sin90); <span class="comment">// 约等于 1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-System"><a href="#2-System" class="headerlink" title="2. System"></a>2. System</h2><hr>
<h3 id="2-1-简介-Introduction"><a href="#2-1-简介-Introduction" class="headerlink" title="2.1 简介 (Introduction)"></a>2.1 简介 (Introduction)</h3><p><code>java.lang.System</code> 类同样是一个工具类，它提供了对标准输入、标准输出、错误输出流的访问，以及访问外部定义的属性和环境变量、加载文件和库、以及执行数组复制等系统级操作。</p>
<hr>
<h3 id="2-2-核心特点"><a href="#2-2-核心特点" class="headerlink" title="2.2 核心特点"></a>2.2 核心特点</h3><ul>
<li><strong>final 类</strong>: 不可被继承。</li>
<li><strong>私有构造函数</strong>: 不可被实例化。</li>
<li><strong>静态成员</strong>: 所有成员和方法都是静态的。</li>
<li><strong>无需导入</strong>: 位于 <code>java.lang</code> 包下。</li>
</ul>
<hr>
<h3 id="2-3-常用方法详解与示例"><a href="#2-3-常用方法详解与示例" class="headerlink" title="2.3 常用方法详解与示例"></a>2.3 常用方法详解与示例</h3><h4 id="2-3-1-标准I-O流"><a href="#2-3-1-标准I-O流" class="headerlink" title="2.3.1 标准I&#x2F;O流"></a>2.3.1 标准I&#x2F;O流</h4><table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static InputStream in</code></td>
<td align="left"><code>java.io.InputStream</code></td>
<td align="left">标准输入流。通常对应键盘输入。</td>
</tr>
<tr>
<td align="left"><code>static PrintStream out</code></td>
<td align="left"><code>java.io.PrintStream</code></td>
<td align="left">标准输出流。通常对应控制台输出。<code>System.out.println()</code> 就是用的它。</td>
</tr>
<tr>
<td align="left"><code>static PrintStream err</code></td>
<td align="left"><code>java.io.PrintStream</code></td>
<td align="left">标准错误流。通常也对应控制台，但用于输出错误信息。</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-3-2-系统操作"><a href="#2-3-2-系统操作" class="headerlink" title="2.3.2 系统操作"></a>2.3.2 系统操作</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static void exit(int status)</code></td>
<td align="left">终止当前运行的 Java 虚拟机。<code>status</code> 为 0 表示正常退出，非 0 表示异常退出。<strong>谨慎使用</strong>，会导致程序立即中断。</td>
</tr>
<tr>
<td align="left"><code>static void gc()</code></td>
<td align="left"><strong>建议</strong> JVM 执行垃圾回收。这只是一个请求，JVM 不一定会立即执行。</td>
</tr>
<tr>
<td align="left"><code>static long currentTimeMillis()</code></td>
<td align="left">返回自 1970 年 1 月 1 日 00:00:00 UTC 以来的毫秒数。常用于计算代码执行时间。</td>
</tr>
<tr>
<td align="left"><code>static long nanoTime()</code></td>
<td align="left">返回 JVM 高精度时间源的当前值，单位是纳秒。主要用于<strong>精确测量时间间隔</strong>，不适合用于获取当前日期时间。</td>
</tr>
<tr>
<td align="left"><code>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code></td>
<td align="left">高效地从源数组复制数据到目标数组。这是一个 native 方法，性能远高于循环复制。</td>
</tr>
<tr>
<td align="left"><code>static String getProperty(String key)</code></td>
<td align="left">获取指定键的系统属性，如 <code>java.version</code>, <code>os.name</code> 等。</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-4-代码示例"><a href="#2-4-代码示例" class="headerlink" title="2.4. 代码示例"></a>2.4. 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 时间测量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// long startTimeNano = System.nanoTime();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// long endTimeNano = System.nanoTime();</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;代码执行耗时: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">// System.out.println(&quot;代码执行耗时: &quot; + (endTimeNano - startTimeNano) + &quot; 纳秒&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 数组复制</span></span><br><span class="line">        <span class="type">int</span>[] source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] destination = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// &#123;0, 0, 0, 0, 0&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从 source 数组的索引2开始，复制3个元素到 destination 数组的索引1开始的位置</span></span><br><span class="line">        <span class="comment">// source:    1, 2, [3, 4, 5], 6, 7</span></span><br><span class="line">        <span class="comment">// destination: 0, [3, 4, 5], 0</span></span><br><span class="line">        System.arraycopy(source, <span class="number">2</span>, destination, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;数组复制结果: &quot;</span> + Arrays.toString(destination)); <span class="comment">// [0, 3, 4, 5, 0]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取系统属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">javaVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Java 版本: &quot;</span> + javaVersion);</span><br><span class="line">        System.out.println(<span class="string">&quot;操作系统: &quot;</span> + osName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印所有系统属性</span></span><br><span class="line">        <span class="comment">// Properties props = System.getProperties();</span></span><br><span class="line">        <span class="comment">// props.list(System.out);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 终止JVM (此行代码后的内容将不会执行)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;程序准备退出...&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>); <span class="comment">// 正常退出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;这行代码永远不会被执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Objects"><a href="#3-Objects" class="headerlink" title="3. Objects"></a>3. Objects</h2><h3 id="3-1-简介-Introduction"><a href="#3-1-简介-Introduction" class="headerlink" title="3.1 简介 (Introduction)"></a>3.1 简介 (Introduction)</h3><p><code>java.util.Objects</code> 是一个在 JDK 7 中引入的工具类，它包含了一系列静态实用方法，用于操作对象或在操作前检查某些条件。这个类的主要设计目标是<strong>简化代码</strong>和<strong>防止 <code>NullPointerException</code></strong>。</p>
<hr>
<h3 id="3-2-核心特点"><a href="#3-2-核心特点" class="headerlink" title="3.2 核心特点"></a>3.2 核心特点</h3><ul>
<li><strong>需要导入</strong>: 位于 <code>java.util</code> 包，使用前需要 <code>import java.util.Objects;</code>。</li>
<li><strong>空指针安全 (Null-safe)</strong>: 大部分方法都对 <code>null</code> 进行了处理，从而避免了 <code>NullPointerException</code>。</li>
<li><strong>静态方法</strong>: 所有方法都是 <code>static</code> 的。</li>
<li><strong>私有构造函数</strong>: 不可被实例化。</li>
</ul>
<hr>
<h3 id="3-3-常用方法详解与示例"><a href="#3-3-常用方法详解与示例" class="headerlink" title="3.3 常用方法详解与示例"></a>3.3 常用方法详解与示例</h3><h4 id="3-3-1-空指针检查"><a href="#3-3-1-空指针检查" class="headerlink" title="3.3.1 空指针检查"></a>3.3.1 空指针检查</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static &lt;T&gt; T requireNonNull(T obj)</code></td>
<td align="left">如果 <code>obj</code> 不为 <code>null</code>，则返回 <code>obj</code> 本身；否则，抛出 <code>NullPointerException</code>。</td>
</tr>
<tr>
<td align="left"><code>static &lt;T&gt; T requireNonNull(T obj, String message)</code></td>
<td align="left">与上一个方法类似，但在抛出异常时会使用指定的 <code>message</code>。</td>
</tr>
<tr>
<td align="left"><code>static boolean isNull(Object obj)</code></td>
<td align="left">判断对象是否为 <code>null</code>。等价于 <code>obj == null</code>，但更具可读性，常用于 Stream API。</td>
</tr>
<tr>
<td align="left"><code>static boolean nonNull(Object obj)</code></td>
<td align="left">判断对象是否不为 <code>null</code>。等价于 <code>obj != null</code>，同样常用于 Stream API。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>最佳实践</strong>: 在构造方法和普通方法的参数校验中，使用 <code>requireNonNull</code> 来实现“<strong>快速失败（Fail-fast）</strong>”，能让问题尽早暴露。</p>
</blockquote>
<hr>
<h4 id="3-3-2-对象比较与哈希"><a href="#3-3-2-对象比较与哈希" class="headerlink" title="3.3.2 对象比较与哈希"></a>3.3.2 对象比较与哈希</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static boolean equals(Object a, Object b)</code></td>
<td align="left">比较两个对象是否相等，内部处理了 <code>null</code> 的情况。如果 <code>a</code> 和 <code>b</code> 都为 <code>null</code>，返回 <code>true</code>。如果只有一个为 <code>null</code>，返回 <code>false</code>。否则，调用 <code>a.equals(b)</code>。</td>
</tr>
<tr>
<td align="left"><code>static int hashCode(Object o)</code></td>
<td align="left">如果 <code>o</code> 不为 <code>null</code>，返回 <code>o.hashCode()</code>；如果 <code>o</code> 为 <code>null</code>，返回 0。</td>
</tr>
<tr>
<td align="left"><code>static int hash(Object... values)</code></td>
<td align="left">为一组对象生成一个哈希码。常用于在 <code>hashCode()</code> 方法中组合多个字段的哈希值。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>最佳实践</strong>: 在重写 <code>equals()</code> 方法时，推荐使用 <code>Objects.equals()</code>。在重写 <code>hashCode()</code> 方法时，推荐使用 <code>Objects.hash()</code>。</p>
</blockquote>
<hr>
<h4 id="3-3-3-其他实用方法"><a href="#3-3-3-其他实用方法" class="headerlink" title="3.3.3 其他实用方法"></a>3.3.3 其他实用方法</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static String toString(Object o)</code></td>
<td align="left">如果 <code>o</code> 不为 <code>null</code>，返回 <code>o.toString()</code>；如果 <code>o</code> 为 <code>null</code>，返回字符串 “null”。</td>
</tr>
<tr>
<td align="left"><code>static String toString(Object o, String nullDefault)</code></td>
<td align="left">如果 <code>o</code> 不为 <code>null</code>，返回 <code>o.toString()</code>；如果 <code>o</code> 为 <code>null</code>，返回 <code>nullDefault</code>。</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-4-代码示例"><a href="#3-4-代码示例" class="headerlink" title="3.4 代码示例"></a>3.4 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectsDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectsDemo</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 requireNonNull 进行参数校验，防止创建出不合法的对象</span></span><br><span class="line">        <span class="built_in">this</span>.name = Objects.requireNonNull(name, <span class="string">&quot;Name cannot be null&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ObjectsDemo</span> <span class="variable">that</span> <span class="operator">=</span> (ObjectsDemo) o;</span><br><span class="line">        <span class="comment">// 使用 Objects.equals 进行 null-safe 比较</span></span><br><span class="line">        <span class="keyword">return</span> age == that.age &amp;&amp; Objects.equals(name, that.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Objects.hash 方便地计算多个字段的哈希码</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. requireNonNull 示例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试用 null name 创建对象</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ObjectsDemo</span>(<span class="literal">null</span>, <span class="number">30</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;捕获到异常: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. equals 示例</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 传统方式，如果 str2 为 null, str2.equals(str1) 会抛出 NPE</span></span><br><span class="line">        <span class="comment">// System.out.println(str2.equals(str1)); // -&gt; NullPointerException</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 Objects.equals，安全可靠</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Objects.equals(str1, str2): &quot;</span> + Objects.equals(str1, str2)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Objects.equals(null, null): &quot;</span> + Objects.equals(<span class="literal">null</span>, <span class="literal">null</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. hashCode 和 toString 示例</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Objects.hashCode(name): &quot;</span> + Objects.hashCode(name)); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Objects.toString(name): &quot;</span> + Objects.toString(name)); <span class="comment">// &quot;null&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Objects.toString(name, \&quot;Default\&quot;): &quot;</span> + Objects.toString(name, <span class="string">&quot;Default&quot;</span>)); <span class="comment">// &quot;Default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-BigInteger"><a href="#4-BigInteger" class="headerlink" title="4. BigInteger"></a>4. BigInteger</h2><h3 id="4-1-简介-Introduction"><a href="#4-1-简介-Introduction" class="headerlink" title="4.1 简介 (Introduction)"></a>4.1 简介 (Introduction)</h3><p><code>java.math.BigInteger</code> 是一个用于表示任意精度整数的类。当一个整数的大小超过了 <code>long</code> 类型的最大值（<code>Long.MAX_VALUE</code>，约 9 x 10^18）时，就必须使用 <code>BigInteger</code>。它内部用一个 <code>int[]</code> 数组来存储这个超大的整数，因此理论上它可以表示的整数大小只受限于可用内存。</p>
<hr>
<h3 id="4-2-核心特点"><a href="#4-2-核心特点" class="headerlink" title="4.2 核心特点"></a>4.2 核心特点</h3><ul>
<li><strong>不可变性 (Immutability)</strong>: <code>BigInteger</code> 对象是不可变的。任何算术运算（如加、减、乘、除）都会返回一个<strong>新的</strong> <code>BigInteger</code> 对象，而不会修改原始对象。</li>
<li><strong>任意精度</strong>: 可以表示比 <code>long</code> 更大的整数。</li>
<li><strong>面向对象</strong>: 算术运算通过方法调用完成，而不是使用 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 等操作符。</li>
</ul>
<hr>
<h3 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h3><table>
<thead>
<tr>
<th align="left">构造方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>BigInteger(String val)</code></td>
<td align="left"><strong>最常用</strong>。将一个表示十进制整数的字符串转换为 <code>BigInteger</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>BigInteger(String val, int radix)</code></td>
<td align="left">将指定进制（radix）的字符串转换为 <code>BigInteger</code>。</td>
</tr>
<tr>
<td align="left"><code>static BigInteger valueOf(long val)</code></td>
<td align="left">将 <code>long</code> 类型的值转换为 <code>BigInteger</code>，有性能优化。</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-4-常用方法详解与示例"><a href="#4-4-常用方法详解与示例" class="headerlink" title="4.4 常用方法详解与示例"></a>4.4 常用方法详解与示例</h3><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>BigInteger add(BigInteger val)</code></td>
<td align="left">加法。</td>
</tr>
<tr>
<td align="left"><code>BigInteger subtract(BigInteger val)</code></td>
<td align="left">减法。</td>
</tr>
<tr>
<td align="left"><code>BigInteger multiply(BigInteger val)</code></td>
<td align="left">乘法。</td>
</tr>
<tr>
<td align="left"><code>BigInteger divide(BigInteger val)</code></td>
<td align="left">除法（取整）。</td>
</tr>
<tr>
<td align="left"><code>BigInteger remainder(BigInteger val)</code></td>
<td align="left">取余。</td>
</tr>
<tr>
<td align="left"><code>BigInteger[] divideAndRemainder(BigInteger val)</code></td>
<td align="left">返回一个包含商和余数的 <code>BigInteger</code> 数组。</td>
</tr>
<tr>
<td align="left"><code>int compareTo(BigInteger val)</code></td>
<td align="left">比较大小。返回 -1 (小于), 0 (等于), 1 (大于)。</td>
</tr>
<tr>
<td align="left"><code>BigInteger pow(int exponent)</code></td>
<td align="left">计算当前 <code>BigInteger</code> 的 <code>exponent</code> 次幂。</td>
</tr>
<tr>
<td align="left"><code>BigInteger abs()</code></td>
<td align="left">返回绝对值。</td>
</tr>
<tr>
<td align="left"><code>int intValue()</code>, <code>long longValue()</code></td>
<td align="left">转换为 <code>int</code> 或 <code>long</code>。<strong>注意：如果 <code>BigInteger</code> 的值超出范围，会发生数据丢失！</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-5-代码示例"><a href="#4-5-代码示例" class="headerlink" title="4.5 代码示例"></a>4.5 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigIntegerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 BigInteger 对象</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigNum1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123456789012345678901234567890&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigNum2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;987654321098765432109876543210&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">smallNum</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">100L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 算术运算 (注意：结果需要重新赋值)</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">sum</span> <span class="operator">=</span> bigNum1.add(bigNum2);</span><br><span class="line">        System.out.println(<span class="string">&quot;和: &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">product</span> <span class="operator">=</span> bigNum1.multiply(smallNum);</span><br><span class="line">        System.out.println(<span class="string">&quot;积: &quot;</span> + product);</span><br><span class="line"></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">quotient</span> <span class="operator">=</span> bigNum2.divide(bigNum1);</span><br><span class="line">        System.out.println(<span class="string">&quot;商: &quot;</span> + quotient);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 比较</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">comparisonResult</span> <span class="operator">=</span> bigNum1.compareTo(bigNum2); <span class="comment">// -1</span></span><br><span class="line">        <span class="keyword">if</span> (comparisonResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bigNum1 小于 bigNum2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 计算阶乘 (经典应用场景)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;50的阶乘: &quot;</span> + factorial(<span class="number">50</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">result</span> <span class="operator">=</span> BigInteger.ONE; <span class="comment">// 使用常量 BigInteger.ONE</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            result = result.multiply(BigInteger.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-BigDecima"><a href="#5-BigDecima" class="headerlink" title="5. BigDecima"></a>5. BigDecima</h2><h3 id="5-1-简介-Introduction"><a href="#5-1-简介-Introduction" class="headerlink" title="5.1 简介 (Introduction)"></a>5.1 简介 (Introduction)</h3><p><code>java.math.BigDecimal</code> 是用于表示任意精度带符号十进制数的类。它解决了 <code>float</code> 和 <code>double</code> 类型在进行浮点数运算时存在的精度丢失问题。因此，在需要<strong>精确计算</strong>的场景，尤其是<strong>金融领域</strong>（如货币计算），<strong>必须使用 <code>BigDecimal</code></strong>。</p>
<blockquote>
<p><strong>经典面试题：为什么 <code>0.1 + 0.2</code> 不等于 <code>0.3</code>？</strong><br>因为 <code>float</code> 和 <code>double</code> 是基于二进制的浮点表示法，无法精确地表示像 <code>0.1</code> 这样的十进制小数，只能无限接近。而 <code>BigDecimal</code> 内部使用一个 <code>BigInteger</code> (unscaled value) 和一个 <code>int</code> (scale) 来表示数值，是基于十进制的，从而保证了精度。</p>
</blockquote>
<hr>
<h3 id="5-2-核心特点"><a href="#5-2-核心特点" class="headerlink" title="5.2 核心特点"></a>5.2 核心特点</h3><ul>
<li><strong>不可变性 (Immutability)</strong>: 与 <code>BigInteger</code> 相同，运算会返回新对象。</li>
<li><strong>精确十进制表示</strong>: 避免了二进制浮点数的舍入误差。</li>
<li><strong>需要指定舍入模式</strong>: 在进行除法等可能产生无限小数的运算时，必须显式指定<strong>舍入模式 (RoundingMode)</strong>，否则可能抛出 <code>ArithmeticException</code>。</li>
</ul>
<hr>
<h3 id="5-3-构造方法-陷阱与最佳实践"><a href="#5-3-构造方法-陷阱与最佳实践" class="headerlink" title="5.3 构造方法 (陷阱与最佳实践)"></a>5.3 构造方法 (陷阱与最佳实践)</h3><table>
<thead>
<tr>
<th align="left">构造方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>BigDecimal(String val)</code></td>
<td align="left"><strong>强烈推荐</strong>。将字符串精确转换为 <code>BigDecimal</code>。</td>
</tr>
<tr>
<td align="left"><code>static BigDecimal valueOf(double val)</code></td>
<td align="left"><strong>推荐</strong>。内部使用 <code>Double.toString(val)</code>，避免了 <code>new BigDecimal(double)</code> 的精度问题。</td>
</tr>
<tr>
<td align="left"><code>BigDecimal(double val)</code></td>
<td align="left"><strong>严禁使用</strong>！此构造方法会引入 <code>double</code> 本身的精度误差。例如 <code>new BigDecimal(0.1)</code> 的实际值并非 0.1。</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-4-常用方法详解与示例"><a href="#5-4-常用方法详解与示例" class="headerlink" title="5.4. 常用方法详解与示例"></a>5.4. 常用方法详解与示例</h3><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>BigDecimal add(BigDecimal augend)</code></td>
<td align="left">加法。</td>
</tr>
<tr>
<td align="left"><code>BigDecimal subtract(BigDecimal subtrahend)</code></td>
<td align="left">减法。</td>
</tr>
<tr>
<td align="left"><code>BigDecimal multiply(BigDecimal multiplicand)</code></td>
<td align="left">乘法。</td>
</tr>
<tr>
<td align="left"><code>BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)</code></td>
<td align="left"><strong>最常用的除法</strong>。<code>scale</code> 指定小数点后保留的位数，<code>roundingMode</code> 指定舍入模式。</td>
</tr>
<tr>
<td align="left"><code>int compareTo(BigDecimal val)</code></td>
<td align="left"><strong>推荐用于比较值的大小</strong>。返回 -1, 0, 1。它只比较数值，忽略 <code>scale</code>。</td>
</tr>
<tr>
<td align="left"><code>boolean equals(Object x)</code></td>
<td align="left">比较对象是否相等。<strong>注意：它会同时比较值和 <code>scale</code></strong>。例如 <code>new BigDecimal(&quot;2.0&quot;)</code> 和 <code>new BigDecimal(&quot;2.00&quot;)</code> 不相等。</td>
</tr>
<tr>
<td align="left"><code>BigDecimal setScale(int newScale, RoundingMode roundingMode)</code></td>
<td align="left">设置小数位数和舍入模式，返回一个新对象。</td>
</tr>
</tbody></table>
<p><strong>常用舍入模式 <code>RoundingMode</code></strong></p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>RoundingMode.HALF_UP</code></td>
<td align="left">四舍五入。</td>
</tr>
<tr>
<td align="left"><code>RoundingMode.DOWN</code></td>
<td align="left">直接截断，不进行任何舍入。</td>
</tr>
<tr>
<td align="left"><code>RoundingMode.UP</code></td>
<td align="left">远离零方向舍入。</td>
</tr>
<tr>
<td align="left"><code>RoundingMode.CEILING</code></td>
<td align="left">向正无穷方向舍入。</td>
</tr>
<tr>
<td align="left"><code>RoundingMode.FLOOR</code></td>
<td align="left">向负无穷方向舍入。</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-5-代码示例"><a href="#5-5-代码示例" class="headerlink" title="5.5 代码示例"></a>5.5 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 精度问题展示</span></span><br><span class="line">        System.out.println(<span class="string">&quot;double计算: 0.1 + 0.2 = &quot;</span> + (<span class="number">0.1</span> + <span class="number">0.2</span>)); <span class="comment">// 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 构造方法的陷阱与正确用法</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">badDecimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;错误的构造方法 new BigDecimal(0.1): &quot;</span> + badDecimal);</span><br><span class="line"></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">goodDecimal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">goodDecimal2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正确的构造方法 new BigDecimal(\&quot;0.1\&quot;): &quot;</span> + goodDecimal1);</span><br><span class="line">        System.out.println(<span class="string">&quot;BigDecimal.valueOf(0.2): &quot;</span> + goodDecimal2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 精确计算</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">sum</span> <span class="operator">=</span> goodDecimal1.add(goodDecimal2);</span><br><span class="line">        System.out.println(<span class="string">&quot;BigDecimal计算: 0.1 + 0.2 = &quot;</span> + sum); <span class="comment">// 0.3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 除法与舍入</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> BigDecimal.TEN; <span class="comment">// 10</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             num1.divide(num2); <span class="comment">// 会抛出 ArithmeticException，因为结果是无限循环小数</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除法未指定舍入模式，捕获到异常: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正确的除法</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">result</span> <span class="operator">=</span> num1.divide(num2, <span class="number">2</span>, RoundingMode.HALF_UP);</span><br><span class="line">        System.out.println(<span class="string">&quot;10 / 3 (保留两位小数，四舍五入): &quot;</span> + result); <span class="comment">// 3.33</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 比较： compareTo vs equals</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a.equals(b): &quot;</span> + a.equals(b)); <span class="comment">// false，因为scale不同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a.compareTo(b): &quot;</span> + a.compareTo(b)); <span class="comment">// 0，因为数值相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-正则表达式"><a href="#6-正则表达式" class="headerlink" title="6. 正则表达式"></a>6. 正则表达式</h2><h3 id="6-1-简介-Introduction"><a href="#6-1-简介-Introduction" class="headerlink" title="6.1 简介 (Introduction)"></a>6.1 简介 (Introduction)</h3><p>正则表达式（Regex）是一种强大的字符串处理工具，它定义了一个<strong>搜索模式</strong>，用于匹配、查找、替换和分割字符串。Java 通过 <code>java.util.regex</code> 包提供了完整的正则表达式支持。</p>
<hr>
<h3 id="6-2-核心类"><a href="#6-2-核心类" class="headerlink" title="6.2 核心类"></a>6.2 核心类</h3><table>
<thead>
<tr>
<th align="left">类名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>Pattern</code></strong></td>
<td align="left"><strong>正则表达式的编译表示形式</strong>。它是不可变的，且是线程安全的。通常通过 <code>Pattern.compile(regex)</code> 创建。</td>
</tr>
<tr>
<td align="left"><strong><code>Matcher</code></strong></td>
<td align="left"><strong>执行匹配操作的引擎</strong>。它解释 Pattern 对字符串进行匹配。它是有状态的，<strong>线程不安全</strong>。</td>
</tr>
<tr>
<td align="left"><strong><code>PatternSyntaxException</code></strong></td>
<td align="left">当正则表达式语法错误时抛出的非受检异常。</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-3-基础语法"><a href="#6-3-基础语法" class="headerlink" title="6.3 基础语法"></a>6.3 基础语法</h3><h4 id="6-3-1-字符类"><a href="#6-3-1-字符类" class="headerlink" title="6.3.1 字符类"></a>6.3.1 字符类</h4><table>
<thead>
<tr>
<th align="left">写法</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[abc]</code></td>
<td align="left">a、b 或 c (简单类)</td>
</tr>
<tr>
<td align="left"><code>[^abc]</code></td>
<td align="left">任何字符，除了 a、b 或 c (否定)</td>
</tr>
<tr>
<td align="left"><code>[a-zA-Z]</code></td>
<td align="left">a 到 z 或 A 到 Z (范围)</td>
</tr>
<tr>
<td align="left"><code>.</code></td>
<td align="left">任何字符 (默认不匹配换行符)</td>
</tr>
<tr>
<td align="left"><code>\d</code></td>
<td align="left">数字：<code>[0-9]</code></td>
</tr>
<tr>
<td align="left"><code>\D</code></td>
<td align="left">非数字：<code>[^0-9]</code></td>
</tr>
<tr>
<td align="left"><code>\s</code></td>
<td align="left">空白字符：<code>[ \t\n\x0B\f\r]</code></td>
</tr>
<tr>
<td align="left"><code>\S</code></td>
<td align="left">非空白字符：<code>[^\s]</code></td>
</tr>
<tr>
<td align="left"><code>\w</code></td>
<td align="left">单词字符：<code>[a-zA-Z_0-9]</code> (字母、数字、下划线)</td>
</tr>
<tr>
<td align="left"><code>\W</code></td>
<td align="left">非单词字符：<code>[^\w]</code></td>
</tr>
</tbody></table>
<hr>
<h4 id="6-3-2-边界匹配器"><a href="#6-3-2-边界匹配器" class="headerlink" title="6.3.2 边界匹配器"></a>6.3.2 边界匹配器</h4><table>
<thead>
<tr>
<th align="left">写法</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>^</code></td>
<td align="left">行的开头</td>
</tr>
<tr>
<td align="left"><code>$</code></td>
<td align="left">行的结尾</td>
</tr>
<tr>
<td align="left"><code>\b</code></td>
<td align="left">单词边界</td>
</tr>
<tr>
<td align="left"><code>\B</code></td>
<td align="left">非单词边界</td>
</tr>
</tbody></table>
<hr>
<h4 id="6-3-3-量词"><a href="#6-3-3-量词" class="headerlink" title="6.3.3 量词"></a>6.3.3 量词</h4><table>
<thead>
<tr>
<th align="left">贪婪 (Greedy)</th>
<th align="left">勉强&#x2F;懒惰 (Reluctant)</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>X?</code></td>
<td align="left"><code>X??</code></td>
<td align="left">X 出现 0 次或 1 次</td>
</tr>
<tr>
<td align="left"><code>X*</code></td>
<td align="left"><code>X*?</code></td>
<td align="left">X 出现 0 次或多次</td>
</tr>
<tr>
<td align="left"><code>X+</code></td>
<td align="left"><code>X+?</code></td>
<td align="left">X 出现 1 次或多次</td>
</tr>
<tr>
<td align="left"><code>X{n}</code></td>
<td align="left"><code>X{n}?</code></td>
<td align="left">X 恰好出现 n 次</td>
</tr>
<tr>
<td align="left"><code>X{n,}</code></td>
<td align="left"><code>X{n,}?</code></td>
<td align="left">X 至少出现 n 次</td>
</tr>
<tr>
<td align="left"><code>X{n,m}</code></td>
<td align="left"><code>X{n,m}?</code></td>
<td align="left">X 出现 n 到 m 次</td>
</tr>
</tbody></table>
<ul>
<li><strong>贪婪</strong>：尽可能多地匹配。</li>
<li><strong>懒惰</strong>：尽可能少地匹配 (在量词后加 <code>?</code>)。</li>
</ul>
<hr>
<h3 id="6-4-Java-中的使用方式"><a href="#6-4-Java-中的使用方式" class="headerlink" title="6.4 Java 中的使用方式"></a>6.4 Java 中的使用方式</h3><h4 id="6-4-1-String-类的便捷方法"><a href="#6-4-1-String-类的便捷方法" class="headerlink" title="6.4.1 String 类的便捷方法"></a>6.4.1 <code>String</code> 类的便捷方法</h4><p><code>String</code> 类内置了一些使用正则表达式的便捷方法，适合简单的匹配场景。</p>
<ul>
<li><code>boolean matches(String regex)</code>: 判断整个字符串是否完全匹配给定的正则表达式。</li>
<li><code>String replaceAll(String regex, String replacement)</code>: 替换所有匹配的子串。</li>
<li><code>String[] split(String regex)</code>: 根据正则表达式分割字符串。</li>
</ul>
<hr>
<h4 id="6-4-2-Pattern-和-Matcher-的标准流程-更强大灵活"><a href="#6-4-2-Pattern-和-Matcher-的标准流程-更强大灵活" class="headerlink" title="6.4.2 Pattern 和 Matcher 的标准流程 (更强大灵活)"></a>6.4.2 <code>Pattern</code> 和 <code>Matcher</code> 的标准流程 (更强大灵活)</h4><ol>
<li><strong>编译模式</strong>: <code>Pattern pattern = Pattern.compile(regex);</code></li>
<li><strong>创建匹配器</strong>: <code>Matcher matcher = pattern.matcher(inputString);</code></li>
<li><strong>执行匹配</strong>:<ul>
<li><code>matcher.matches()</code>: 尝试将整个输入序列与该模式匹配（类似 <code>String.matches</code>）。</li>
<li><code>matcher.find()</code>: 扫描输入序列，查找与该模式匹配的下一个子序列。常与 <code>while</code> 循环一起使用，找出所有匹配项。</li>
<li><code>matcher.group(int group)</code>: 在 <code>find()</code> 或 <code>matches()</code> 成功后，返回由给定捕获组捕获的子序列。<code>group(0)</code> 代表整个匹配。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="6-4-3-代码示例"><a href="#6-4-3-代码示例" class="headerlink" title="6.4.3 代码示例"></a>6.4.3 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// --- 1. String类的便捷方法 ---</span></span><br><span class="line">        <span class="comment">// a. 验证手机号 (简单示例)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneRegex</span> <span class="operator">=</span> <span class="string">&quot;^1[3-9]\\d&#123;9&#125;$&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;18812345678&quot;</span>.matches(phoneRegex)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;12812345678&quot;</span>.matches(phoneRegex)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. 替换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello Java, I love Java!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">replacedText</span> <span class="operator">=</span> text.replaceAll(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">        System.out.println(replacedText); <span class="comment">// Hello World, I love World!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. 分割</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;apple,banana,,orange&quot;</span>;</span><br><span class="line">        String[] fruits = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String fruit : fruits) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Fruit: &#x27;&quot;</span> + fruit + <span class="string">&quot;&#x27;&quot;</span>); <span class="comment">// 注意会产生空字符串</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 2. Pattern 和 Matcher 的标准用法 ---</span></span><br><span class="line">        <span class="comment">// 目标：从文本中提取所有邮箱地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">log</span> <span class="operator">=</span> <span class="string">&quot;Contact us at support@example.com or sales.department@company.co.uk for help.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">emailRegex</span> <span class="operator">=</span> <span class="string">&quot;\\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]&#123;2,&#125;\\b&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 编译模式 (可重用)</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">emailPattern</span> <span class="operator">=</span> Pattern.compile(emailRegex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建匹配器</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> emailPattern.matcher(log);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 查找所有匹配</span></span><br><span class="line">        System.out.println(<span class="string">&quot;找到的邮箱地址:&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            <span class="comment">// matcher.group(0) 或 matcher.group() 返回整个匹配的字符串</span></span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --- 3. 捕获组 (Capturing Groups) ---</span></span><br><span class="line">        <span class="comment">// 目标：从 &quot;John Doe&quot; 中提取姓和名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">nameRegex</span> <span class="operator">=</span> <span class="string">&quot;(\\w+)\\s+(\\w+)&quot;</span>; <span class="comment">// 两个捕获组 (firstName) (lastName)</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">namePattern</span> <span class="operator">=</span> Pattern.compile(nameRegex);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">nameMatcher</span> <span class="operator">=</span> namePattern.matcher(<span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nameMatcher.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">firstName</span> <span class="operator">=</span> nameMatcher.group(<span class="number">1</span>); <span class="comment">// 第一个括号匹配的内容</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">lastName</span> <span class="operator">=</span> nameMatcher.group(<span class="number">2</span>);  <span class="comment">// 第二个括号匹配的内容</span></span><br><span class="line">            System.out.println(<span class="string">&quot;First Name: &quot;</span> + firstName); <span class="comment">// John</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Last Name: &quot;</span> + lastName);   <span class="comment">// Doe</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-5-分组与捕获"><a href="#6-5-分组与捕获" class="headerlink" title="6.5 分组与捕获"></a>6.5 分组与捕获</h3><p>用圆括号 <code>()</code> 将部分正则括起来，可以提取子串。</p>
<ul>
<li><code>group(0)</code>：代表整个匹配到的字符串。</li>
<li><code>group(1)</code>：代表第一个括号匹配的内容。</li>
<li><code>group(2)</code>：代表第二个括号，依此类推。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;User: alice, ID: 1001&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;User: (\\w+), ID: (\\d+)&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(text);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Whole: &quot;</span> + m.group(<span class="number">0</span>)); <span class="comment">// &quot;User: alice, ID: 1001&quot;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Name:  &quot;</span> + m.group(<span class="number">1</span>)); <span class="comment">// &quot;alice&quot;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;ID:    &quot;</span> + m.group(<span class="number">2</span>)); <span class="comment">// &quot;1001&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非捕获组</strong></p>
<p><code>(?:X)</code> ：匹配 X，但不捕获（不能用 group(1) 提取），用于提升性能或仅做逻辑分组。</p>
<hr>
<h3 id="6-6-常用Pattern标识"><a href="#6-6-常用Pattern标识" class="headerlink" title="6.6 常用Pattern标识"></a>6.6 常用Pattern标识</h3><p>可以在 <code>compile</code> 时指定，也可以在正则内部通过 <code>(?flags)</code> 指定。</p>
<table>
<thead>
<tr>
<th align="left">标志常量</th>
<th align="left">内部写法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Pattern.CASE_INSENSITIVE</code></td>
<td align="left"><code>(?i)</code></td>
<td align="left"><strong>忽略大小写</strong> (如 <code>[a-z]</code> 也能匹配大写)</td>
</tr>
<tr>
<td align="left"><code>Pattern.MULTILINE</code></td>
<td align="left"><code>(?m)</code></td>
<td align="left"><strong>多行模式</strong>。<code>^</code> 和 <code>$</code> 匹配每一行的开头结尾，而不仅仅是整个字符串的开头结尾。</td>
</tr>
<tr>
<td align="left"><code>Pattern.DOTALL</code></td>
<td align="left"><code>(?s)</code></td>
<td align="left"><strong>点号全配</strong>。让 <code>.</code> 也可以匹配换行符 <code>\n</code>。</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略大小写匹配 &quot;java&quot;</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;java&quot;</span>, Pattern.CASE_INSENSITIVE);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p2</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(?i)java&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-7-零宽断言"><a href="#6-7-零宽断言" class="headerlink" title="6.7 零宽断言"></a>6.7 零宽断言</h3><p>用于匹配位置，<strong>不消耗字符</strong>。</p>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>(?=X)</code></td>
<td align="left">正向先行断言</td>
<td align="left">右边必须是 X (例如：<code>Win(?=XP)</code> 匹配 “WinXP” 中的 “Win”)</td>
</tr>
<tr>
<td align="left"><code>(?!X)</code></td>
<td align="left">负向先行断言</td>
<td align="left">右边不能是 X</td>
</tr>
<tr>
<td align="left"><code>(?&lt;=X)</code></td>
<td align="left">正向后行断言</td>
<td align="left">左边必须是 X</td>
</tr>
<tr>
<td align="left"><code>(?&lt;!X)</code></td>
<td align="left">负向后行断言</td>
<td align="left">左边不能是 X</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-8-常用正则表达式合集"><a href="#6-8-常用正则表达式合集" class="headerlink" title="6.8 常用正则表达式合集"></a>6.8 常用正则表达式合集</h3><table>
<thead>
<tr>
<th align="left">用途</th>
<th align="left">正则表达式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>中文字符</strong></td>
<td align="left"><code>[\u4e00-\u9fa5]</code></td>
</tr>
<tr>
<td align="left"><strong>Email</strong></td>
<td align="left"><code>\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</code></td>
</tr>
<tr>
<td align="left"><strong>中国手机号</strong></td>
<td align="left"><code>^1[3-9]\d{9}$</code></td>
</tr>
<tr>
<td align="left"><strong>身份证(18位)</strong></td>
<td align="left">&#96;^[1-9]\d{5}(18</td>
</tr>
<tr>
<td align="left"><strong>日期 (yyyy-MM-dd)</strong></td>
<td align="left"><code>^\d{4}-\d{2}-\d{2}$</code></td>
</tr>
<tr>
<td align="left"><strong>去除首尾空格</strong></td>
<td align="left">&#96;^\s+</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-9-常见坑与最佳实践"><a href="#6-9-常见坑与最佳实践" class="headerlink" title="6.9 常见坑与最佳实践"></a>6.9 常见坑与最佳实践</h3><ol>
<li><strong><code>matches()</code> vs <code>find()</code></strong>:<ul>
<li><code>matches()</code>：尝试将<strong>整个区域</strong>与模式匹配（相当于自带 <code>^...$</code>）。</li>
<li><code>find()</code>：在输入序列中查找匹配的<strong>子序列</strong>。</li>
</ul>
</li>
<li><strong>反斜杠地狱</strong>:<ul>
<li>Java 字符串中 <code>\</code> 是转义符。</li>
<li>正则中 <code>\</code> 也是转义符。</li>
<li><strong>结论</strong>：要匹配一个真实的反斜杠字符 <code>\</code>，Java 字符串里需要写 <code>\\\\</code>。</li>
</ul>
</li>
<li><strong>性能问题</strong>:<ul>
<li><strong>预编译</strong>：如果一个正则要用多次，<strong>一定</strong>要定义为 <code>static final Pattern</code> 常量，避免在循环中重复 <code>Pattern.compile()</code>。</li>
<li><strong>回溯陷阱 (Catastrophic Backtracking)</strong>：避免嵌套的量词，如 <code>(a+)+</code>，这在处理长字符串时可能导致 CPU 100% 卡死。</li>
</ul>
</li>
<li><strong>线程安全</strong>:<ul>
<li><code>Pattern</code> 是线程安全的，可以全局共享。</li>
<li><code>Matcher</code> 不是线程安全的，每个线程&#x2F;每次操作需要重新创建。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="7-时间类"><a href="#7-时间类" class="headerlink" title="7. 时间类"></a>7. 时间类</h2><h3 id="7-1-JDK-7及之前的时间API【过时】"><a href="#7-1-JDK-7及之前的时间API【过时】" class="headerlink" title="7.1 JDK 7及之前的时间API【过时】"></a>7.1 JDK 7及之前的时间API【过时】</h3><h4 id="7-1-1-Date类"><a href="#7-1-1-Date类" class="headerlink" title="7.1.1 Date类"></a>7.1.1 Date类</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><ul>
<li><strong>简介</strong>: <code>Date</code> 类是Java早期用于表示特定时间点的类。其内部本质上是一个包装了 <code>long</code> 类型毫秒值的对象，该毫秒值表示自UTC 1970年1月1日00:00:00以来的时间戳。</li>
<li><strong>核心问题</strong>: 除了 <code>getTime()</code> 和 <code>setTime()</code> 等少数方法外，大部分用于日期和时间分量计算的方法（如 <code>getYear()</code>, <code>getMonth()</code>）都已被废弃，因为它们的设计存在严重缺陷。<code>Date</code> 对象本身是可变的。</li>
</ul>
<hr>
<h5 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h5><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Date()</code></td>
<td align="left">创建一个表示当前时间的 <code>Date</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>Date(long date)</code></td>
<td align="left">根据指定的毫秒值创建 <code>Date</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>long getTime()</code></td>
<td align="left">返回自纪元以来的毫秒数。</td>
</tr>
<tr>
<td align="left"><code>void setTime(long time)</code></td>
<td align="left">设置 <code>Date</code> 对象的时间（修改自身）。</td>
</tr>
</tbody></table>
<hr>
<h5 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldDateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建Date对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前时间: &quot;</span> + now); <span class="comment">// 输出格式可读性差，如：Wed Apr 17 15:30:00 CST 2024</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取毫秒时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> now.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前时间戳 (毫秒): &quot;</span> + timestamp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 从时间戳创建Date</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">fromTimestamp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(timestamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;从时间戳创建的Date: &quot;</span> + fromTimestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-1-2-Calender"><a href="#7-1-2-Calender" class="headerlink" title="7.1.2 Calender"></a>7.1.2 Calender</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><ul>
<li><strong>简介</strong>: <code>Calendar</code> 是一个抽象类，用于弥补 <code>Date</code> 类在日期时间计算和操作上的不足。它提供了设置和获取年、月、日、时、分、秒等字段的方法。通常通过 <code>Calendar.getInstance()</code> 获取其子类 <code>GregorianCalendar</code> 的实例。</li>
<li><strong>核心问题</strong>: 对象可变、月份从0开始、API冗长、时区处理依然不便。</li>
</ul>
<hr>
<h5 id="2-常用方法-1"><a href="#2-常用方法-1" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h5><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static Calendar getInstance()</code></td>
<td align="left">获取一个表示当前日期和时间的 <code>Calendar</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>int get(int field)</code></td>
<td align="left">获取指定字段的值，如 <code>Calendar.YEAR</code>。</td>
</tr>
<tr>
<td align="left"><code>void set(int field, int value)</code></td>
<td align="left">设置指定字段的值。</td>
</tr>
<tr>
<td align="left"><code>void add(int field, int amount)</code></td>
<td align="left">对指定字段进行加减运算。</td>
</tr>
<tr>
<td align="left"><code>Date getTime()</code></td>
<td align="left">将 <code>Calendar</code> 对象转换回 <code>Date</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>void setTime(Date date)</code></td>
<td align="left">使用 <code>Date</code> 对象设置 <code>Calendar</code> 的时间。</td>
</tr>
</tbody></table>
<hr>
<h5 id="3-代码示例-1"><a href="#3-代码示例-1" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取Calendar实例</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取日期时间分量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> calendar.get(Calendar.YEAR);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> calendar.get(Calendar.MONTH) + <span class="number">1</span>; <span class="comment">// 月份从0开始，需要+1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.printf(<span class="string">&quot;当前日期: %d-%02d-%02d%n&quot;</span>, year, month, day);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 设置特定日期</span></span><br><span class="line">        calendar.set(<span class="number">2025</span>, Calendar.JANUARY, <span class="number">1</span>); <span class="comment">// 月份使用常量，更清晰</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">newYear2025</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;2025年元旦: &quot;</span> + newYear2025);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 日期计算：计算10天后</span></span><br><span class="line">        calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// 重置为当前时间</span></span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10天后的日期: &quot;</span> + calendar.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-1-2-SimpleDateFormat"><a href="#7-1-2-SimpleDateFormat" class="headerlink" title="7.1.2 SimpleDateFormat"></a>7.1.2 SimpleDateFormat</h4><h5 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h5><ul>
<li><strong>简介</strong>: <code>SimpleDateFormat</code> 是一个用于以特定格式（如 “yyyy-MM-dd HH:mm:ss”）<strong>格式化</strong>（日期 -&gt; 文本）和<strong>解析</strong>（文本 -&gt; 日期）日期的具体类。</li>
<li><strong>核心问题</strong>: <strong>非线程安全</strong>。在多线程环境下共享一个 <code>SimpleDateFormat</code> 实例会产生并发问题。解决方案是使用 <code>ThreadLocal</code> 或者每次使用时都创建新实例。</li>
</ul>
<hr>
<h5 id="2-常用方法-2"><a href="#2-常用方法-2" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h5><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>SimpleDateFormat(String pattern)</code></td>
<td align="left">使用给定的模式构造 <code>SimpleDateFormat</code>。</td>
</tr>
<tr>
<td align="left"><code>String format(Date date)</code></td>
<td align="left">将 <code>Date</code> 对象格式化为字符串。</td>
</tr>
<tr>
<td align="left"><code>Date parse(String source)</code></td>
<td align="left">将字符串解析为 <code>Date</code> 对象（可能抛出 <code>ParseException</code>）。</td>
</tr>
</tbody></table>
<hr>
<h5 id="3-代码示例-2"><a href="#3-代码示例-2" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDateFormatDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 格式化 (Date -&gt; String)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedDate</span> <span class="operator">=</span> sdf.format(now);</span><br><span class="line">        System.out.println(<span class="string">&quot;格式化后的日期: &quot;</span> + formattedDate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 解析 (String -&gt; Date)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dateString</span> <span class="operator">=</span> <span class="string">&quot;2023-10-01 08:00:00&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">parsedDate</span> <span class="operator">=</span> sdf.parse(dateString);</span><br><span class="line">            System.out.println(<span class="string">&quot;解析后的日期: &quot;</span> + parsedDate);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;日期解析失败: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-2-JDK-8及之后的新时间API"><a href="#7-2-JDK-8及之后的新时间API" class="headerlink" title="7.2 JDK 8及之后的新时间API"></a>7.2 JDK 8及之后的新时间API</h3><h4 id="7-2-1-核心类概览"><a href="#7-2-1-核心类概览" class="headerlink" title="7.2.1 核心类概览"></a>7.2.1 核心类概览</h4><p><strong>本地日期&#x2F;时间</strong>:</p>
<ul>
<li><code>LocalDate</code>: 只表示日期，如 <code>2024-04-17</code>。</li>
<li><code>LocalTime</code>: 只表示时间，如 <code>15:45:30.123</code>。</li>
<li><code>LocalDateTime</code>: 表示日期和时间，是上面两者的结合，如 <code>2024-04-17T15:45:30.123</code>。它们都<strong>不包含时区信息</strong>。</li>
</ul>
<p><strong>带时区的日期&#x2F;时间</strong>:</p>
<ul>
<li><code>ZonedDateTime</code>: 最完整的日期时间表示，包含时区信息。</li>
<li><code>ZoneId</code>: 表示时区。</li>
</ul>
<p><strong>时间戳</strong>:</p>
<ul>
<li><code>Instant</code>: 表示时间线上的一个瞬时点（时间戳），以UTC为基准。与 <code>Date</code> 的 <code>getTime()</code> 类似，但精度更高（纳秒）。</li>
</ul>
<p><strong>时间段</strong>:</p>
<ul>
<li><code>Duration</code>: 表示以秒和纳秒为单位的时间间隔，适合机器计算（例如，两小时三十分钟）。</li>
<li><code>Period</code>: 表示以年、月、日为单位的时间间隔，适合人类阅读（例如，两年三个月零五天）。</li>
</ul>
<p><strong>格式化与解析</strong>:</p>
<ul>
<li><code>DateTimeFormatter</code>: <code>java.time</code> 的格式化器，<strong>不可变且线程安全</strong>。</li>
</ul>
<p><strong>工具类</strong>:</p>
<ul>
<li><code>TemporalAdjusters</code>: 提供了一系列静态方法，用于进行复杂的日期调整，如“当月第一天”、“下个周日”等。</li>
</ul>
<hr>
<h4 id="7-2-2-常用方法与代码示例"><a href="#7-2-2-常用方法与代码示例" class="headerlink" title="7.2.2 常用方法与代码示例"></a>7.2.2 常用方法与代码示例</h4><h5 id="1-LocalDate-LocalTime-LocalDateTime"><a href="#1-LocalDate-LocalTime-LocalDateTime" class="headerlink" title="1. LocalDate, LocalTime, LocalDateTime"></a>1. <code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewTimeApiDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建实例</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">nowTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">currentDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;今天日期: &quot;</span> + today);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前时间: &quot;</span> + nowTime);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前日期时间: &quot;</span> + currentDateTime);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 of() 方法创建指定日期时间</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">specificDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2025</span>, Month.JANUARY, <span class="number">1</span>); <span class="comment">// 月份使用枚举，更安全</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">specificDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取日期时间分量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> currentDateTime.getYear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">monthValue</span> <span class="operator">=</span> currentDateTime.getMonthValue(); <span class="comment">// 直接返回 1-12</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> currentDateTime.getDayOfMonth();</span><br><span class="line">        System.out.printf(<span class="string">&quot;年: %d, 月: %d, 日: %d%n&quot;</span>, year, monthValue, day);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 日期时间计算 (返回新的实例，原对象不变)</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">futureDateTime</span> <span class="operator">=</span> currentDateTime.plusDays(<span class="number">10</span>).plusHours(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10天2小时后: &quot;</span> + futureDateTime);</span><br><span class="line">        </span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">pastDateTime</span> <span class="operator">=</span> currentDateTime.minusMonths(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;一个月前: &quot;</span> + pastDateTime);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 修改日期时间分量</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">modifiedDateTime</span> <span class="operator">=</span> currentDateTime.withYear(<span class="number">2099</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;年份修改为2099: &quot;</span> + modifiedDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-Instant-时间戳"><a href="#2-Instant-时间戳" class="headerlink" title="2. Instant (时间戳)"></a>2. <code>Instant</code> (时间戳)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstantDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前UTC时间戳</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前Instant: &quot;</span> + now); <span class="comment">// UTC时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 转换为毫秒/秒</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">epochMilli</span> <span class="operator">=</span> now.toEpochMilli();</span><br><span class="line">        <span class="type">long</span> <span class="variable">epochSecond</span> <span class="operator">=</span> now.getEpochSecond();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前毫秒时间戳: &quot;</span> + epochMilli);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 从毫秒创建Instant</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">fromMilli</span> <span class="operator">=</span> Instant.ofEpochMilli(epochMilli);</span><br><span class="line">        System.out.println(<span class="string">&quot;从毫秒创建的Instant: &quot;</span> + fromMilli);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-DateTimeFormatter-格式化与解析"><a href="#3-DateTimeFormatter-格式化与解析" class="headerlink" title="3. DateTimeFormatter (格式化与解析)"></a>3. <code>DateTimeFormatter</code> (格式化与解析)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.format.FormatStyle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormatterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 使用预定义格式</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">isoFormatter</span> <span class="operator">=</span> DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">        System.out.println(<span class="string">&quot;ISO格式: &quot;</span> + now.format(isoFormatter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 自定义格式</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">customFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> now.format(customFormatter);</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义格式: &quot;</span> + formatted);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 解析字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dateTimeStr</span> <span class="operator">=</span> <span class="string">&quot;2023/10/01 09:30:00&quot;</span>;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">parsedDateTime</span> <span class="operator">=</span> LocalDateTime.parse(dateTimeStr, customFormatter);</span><br><span class="line">        System.out.println(<span class="string">&quot;解析后的日期时间: &quot;</span> + parsedDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-Duration-和-Period-时间间隔"><a href="#4-Duration-和-Period-时间间隔" class="headerlink" title="4. Duration 和 Period (时间间隔)"></a>4. <code>Duration</code> 和 <code>Period</code> (时间间隔)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Period;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntervalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Duration: 计算时间差</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2024</span>, <span class="number">4</span>, <span class="number">17</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2024</span>, <span class="number">4</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">30</span>, <span class="number">15</span>);</span><br><span class="line">        <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(start, end);</span><br><span class="line">        System.out.println(<span class="string">&quot;时间间隔: &quot;</span> + duration.toHours() + <span class="string">&quot; 小时&quot;</span>); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;时间间隔: &quot;</span> + duration.toMinutes() + <span class="string">&quot; 分钟&quot;</span>); <span class="comment">// 150</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Period: 计算日期差</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">startDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">endDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2024</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(startDate, endDate);</span><br><span class="line">        System.out.printf(<span class="string">&quot;日期相差: %d 年, %d 月, %d 天%n&quot;</span>,</span><br><span class="line">                period.getYears(), period.getMonths(), period.getDays());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%BA%94%E3%80%81IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%BA%94%E3%80%81IO/" class="post-title-link" itemprop="url">五、IO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:20:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:20:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-20 21:15:23" itemprop="dateModified" datetime="2025-11-20T21:15:23+08:00">2025-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="五、IO"><a href="#五、IO" class="headerlink" title="五、IO"></a>五、IO</h1><h2 id="1-IO流概述"><a href="#1-IO流概述" class="headerlink" title="1. IO流概述"></a>1. IO流概述</h2><h3 id="1-1-什么是IO流"><a href="#1-1-什么是IO流" class="headerlink" title="1.1 什么是IO流"></a>1.1 什么是IO流</h3><ul>
<li>定义：输入&#x2F;输出流的抽象，数据在设备（文件、网络、键盘等）与程序之间的流动像“流”一样。</li>
<li>核心思想：顺序读写，先进先出。</li>
</ul>
<hr>
<h3 id="1-2-流的分类标准"><a href="#1-2-流的分类标准" class="headerlink" title="1.2 流的分类标准"></a>1.2 流的分类标准</h3><ul>
<li><strong>按流向分</strong>（以程序为参照物）：<ul>
<li><code>输入流 (InputStream/Reader)</code>：从源（文件、网络等）读取数据到程序。</li>
<li><code>输出流 (OutputStream/Writer)</code>：从程序写出数据到目标（文件、网络等）。</li>
</ul>
</li>
<li><strong>按操作数据类型分</strong>：<ul>
<li><code>字节流 (Byte Streams)</code>：以字节（8bit, <code>byte</code>）为单位，操作所有类型的数据（图片、视频、文本等）。基类：<code>InputStream</code>, <code>OutputStream</code>。</li>
<li><code>字符流 (Character Streams)</code>：以字符（16bit, <code>char</code>）为单位，专门处理文本数据，能自动处理编码问题。基类：<code>Reader</code>, <code>Writer</code>。</li>
</ul>
</li>
<li><strong>按角色功能分</strong>：<ul>
<li><code>节点流 (Node Streams)</code>：直接从数据源或目的地读写数据。如：<code>FileInputStream</code>。</li>
<li><code>处理流/包装流 (Processing Streams)</code>：对已存在的流进行封装，提供更强大、更方便的功能（如缓冲、转换等）。使用了<strong>装饰器模式</strong>。如：<code>BufferedInputStream</code>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-File【存在设计缺陷，推荐使用-Path】"><a href="#2-File【存在设计缺陷，推荐使用-Path】" class="headerlink" title="2. File【存在设计缺陷，推荐使用 Path】"></a>2. File【存在设计缺陷，推荐使用 <code>Path</code>】</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><ul>
<li><strong>不代表文件本身</strong>：<code>File</code> 对象不是文件，它只是一个路径的“包装器”。</li>
<li><strong>抽象路径</strong>：它使用一个与系统无关的“抽象路径名”来屏蔽不同操作系统（Windows, Linux, macOS）在路径表示上的差异（例如，使用 <code>/</code> 而不是 <code>\</code>）。</li>
<li><strong>功能</strong>：主要用于文件和目录的<strong>元数据操作</strong>（创建、删除、重命名、查询属性等），<strong>而不是文件内容的读写</strong>。文件内容的读写需要配合 <code>FileInputStream</code>, <code>FileOutputStream</code> 等流类使用。</li>
<li><strong>现状</strong>：<strong>已过时</strong>。</li>
</ul>
<hr>
<h3 id="2-2-核心概念与方法"><a href="#2-2-核心概念与方法" class="headerlink" title="2.2 核心概念与方法"></a>2.2 核心概念与方法</h3><h4 id="2-2-1-构造File对象"><a href="#2-2-1-构造File对象" class="headerlink" title="2.2.1 构造File对象"></a>2.2.1 构造File对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 通过父路径字符串和子路径字符串创建</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp&quot;</span>, <span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过完整的路径字符串创建</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过另一个File对象（父目录）和子路径字符串创建</span></span><br><span class="line"><span class="type">File</span> <span class="variable">parentDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentDir, <span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 使用相对路径（相对于当前工作目录）</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;relative_path.txt&quot;</span>); <span class="comment">// 例如在IDE中运行，相对项目根目录</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-2-文件与目录的检测"><a href="#2-2-2-文件与目录的检测" class="headerlink" title="2.2.2 文件与目录的检测"></a>2.2.2 文件与目录的检测</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件或目录是否存在</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> file.exists();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否是文件（而不是目录）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFile</span> <span class="operator">=</span> file.isFile();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否是目录</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isDirectory</span> <span class="operator">=</span> file.isDirectory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否是一个隐藏文件（取决于操作系统）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isHidden</span> <span class="operator">=</span> file.isHidden();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否可读</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">canRead</span> <span class="operator">=</span> file.canRead();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否可写</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">canWrite</span> <span class="operator">=</span> file.canWrite();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否可执行（对于程序或脚本）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">canExecute</span> <span class="operator">=</span> file.canExecute();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-3-文件与目录的操作"><a href="#2-2-3-文件与目录的操作" class="headerlink" title="2.2.3 文件与目录的操作"></a>2.2.3 文件与目录的操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;new_file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件：如果文件不存在且创建成功，返回true；如果文件已存在，返回false。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件或目录（如果是空目录）：删除成功返回true。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">deleted</span> <span class="operator">=</span> file.delete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// JVM退出时删除文件或目录：通常用于临时文件</span></span><br><span class="line">file.deleteOnExit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目录：只能创建一级目录</span></span><br><span class="line"><span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;new_dir&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">dirCreated</span> <span class="operator">=</span> dir.mkdir();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多级目录：创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。</span></span><br><span class="line"><span class="type">File</span> <span class="variable">multiLevelDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;level1/level2/level3&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">dirsCreated</span> <span class="operator">=</span> multiLevelDir.mkdirs();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名或移动文件/目录</span></span><br><span class="line"><span class="type">File</span> <span class="variable">oldFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;old_name.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">newFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;new_name.txt&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">renamed</span> <span class="operator">=</span> oldFile.renameTo(newFile); <span class="comment">// 也可用于移动到另一个目录</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-4-获取文件信息"><a href="#2-2-4-获取文件信息" class="headerlink" title="2.2.4 获取文件信息"></a>2.2.4 获取文件信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件名称（包含扩展名）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName(); <span class="comment">// &quot;test.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父目录的路径字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> file.getParent(); <span class="comment">// 例如 “/tmp”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父目录的File对象</span></span><br><span class="line"><span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> file.getParentFile();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件绝对路径（字符串）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">absolutePath</span> <span class="operator">=</span> file.getAbsolutePath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件规范路径（字符串），会解析其中的 `..` 和 `.` 等符号链接（Unix）或快捷方式（Windows）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">canonicalPath</span> <span class="operator">=</span> file.getCanonicalPath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件长度（字节数），如果文件不存在则返回0L</span></span><br><span class="line"><span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> file.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件最后修改时间（毫秒数，自1970年纪元起）</span></span><br><span class="line"><span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> file.lastModified();</span><br><span class="line"><span class="comment">// 通常转换为Date对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">lastModifiedDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(lastModified);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-5-目录列表"><a href="#2-2-5-目录列表" class="headerlink" title="2.2.5 目录列表"></a>2.2.5 目录列表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出目录下的所有文件和子目录的名称（字符串数组）</span></span><br><span class="line">String[] fileNames = dir.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出目录下的所有文件和子目录的File对象（更常用）</span></span><br><span class="line">File[] files = dir.listFiles();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用FilenameFilter过滤器列出文件</span></span><br><span class="line"><span class="comment">// 例如，列出所有 .txt 文件</span></span><br><span class="line">File[] txtFiles = dir.listFiles(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name.toLowerCase().endsWith(<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Java 8+ Lambda 表达式写法</span></span><br><span class="line">File[] txtFilesLambda = dir.listFiles((d, name) -&gt; name.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-重要注意事项与局限性"><a href="#2-3-重要注意事项与局限性" class="headerlink" title="2.3 重要注意事项与局限性"></a>2.3 重要注意事项与局限性</h3><ol>
<li><p><strong>路径分隔符</strong>：使用 <code>File.separator</code>（字符串）或 <code>File.separatorChar</code>（字符）来代替硬编码的 <code>/</code> 或 <code>\</code>，以保证跨平台兼容性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">betterFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir&quot;</span> + File.separator + <span class="string">&quot;file.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常处理</strong>：许多方法（如 <code>createNewFile()</code>, <code>canonicalPath()</code>）会抛出 <code>IOException</code>，必须使用 <code>try-catch</code> 进行处理。</p>
</li>
<li><p><strong>原子性</strong>：由于文件系统是共享的，某些操作不是原子的。例如，在调用 <code>exists()</code> 和 <code>createNewFile()</code> 之间，另一个进程可能已经创建或删除了该文件。</p>
</li>
<li><p><strong>符号链接</strong>：<code>File</code> 类对符号链接的处理可能因平台而异，有时会解析链接，有时不会，行为不够一致。</p>
</li>
<li><p><strong>性能</strong>：对于遍历大型目录结构（如整个磁盘），<code>listFiles()</code> 性能较差，因为它会一次性返回所有结果。</p>
</li>
<li><p><strong>功能有限</strong>：缺少一些现代文件系统所需的高级功能，如文件属性、符号链接的精细控制、文件更改通知等。</p>
</li>
</ol>
<hr>
<h3 id="2-4-RandomAccessFile【特定场景使用，通常可被-NIO-FileChannel-替代】"><a href="#2-4-RandomAccessFile【特定场景使用，通常可被-NIO-FileChannel-替代】" class="headerlink" title="2.4 RandomAccessFile【特定场景使用，通常可被 NIO FileChannel 替代】"></a>2.4 RandomAccessFile【特定场景使用，通常可被 NIO <code>FileChannel</code> 替代】</h3><h4 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h4><p><code>RandomAccessFile</code> 是Java标准库（<code>java.io</code>包）中的一个类，用于支持对文件的<strong>随机访问</strong>读写。它的名字“随机”意味着你可以从文件的任意位置（通过移动文件指针）开始读取或写入数据，而不像<code>InputStream</code>或<code>OutputStream</code>那样只能顺序进行。</p>
<hr>
<h4 id="2-4-2-核心功能与用法"><a href="#2-4-2-核心功能与用法" class="headerlink" title="2.4.2 核心功能与用法"></a>2.4.2 核心功能与用法</h4><ol>
<li><strong>模式（Mode）</strong>：构造时需要指定访问模式。<ul>
<li><code>&quot;r&quot;</code>: 只读。</li>
<li><code>&quot;rw&quot;</code>: 读写。如果文件不存在，会尝试创建。</li>
<li><code>&quot;rws&quot;</code>: 读写，并且要求对文件内容或元数据的每次更新都同步写入底层存储设备。</li>
<li><code>&quot;rwd&quot;</code>: 读写，并且要求对文件内容的每次更新都同步写入底层存储设备。</li>
</ul>
</li>
<li><strong>文件指针（File Pointer）</strong>：这是其核心机制。<ul>
<li><code>long getFilePointer()</code>: 返回当前指针的位置。</li>
<li><code>void seek(long pos)</code>: 设置文件指针偏移量（从文件开头开始的字节数）。通过这个方法可以跳转到文件的任何位置。</li>
</ul>
</li>
<li><strong>读写方法</strong>：<ul>
<li>提供了多种基本数据类型的读写方法，如 <code>readInt()</code>, <code>writeChar()</code>, <code>readLine()</code>, <code>writeUTF(String str)</code> 等。这些方法使得读写结构化数据非常方便。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-4-3-典型使用场景"><a href="#2-4-3-典型使用场景" class="headerlink" title="2.4.3 典型使用场景"></a>2.4.3 典型使用场景</h4><ul>
<li><strong>DIY数据库或索引文件</strong>：你可以自己设计文件格式，比如前8个字节是long型表示记录数，后面是每条记录。通过<code>seek()</code>可以快速定位到某条记录。</li>
<li><strong>大文件的部分读取</strong>：例如一个巨大的日志文件，你只想看最后1MB的内容，可以用<code>seek()</code>跳到文件末尾附近开始读。</li>
<li><strong>多线程下载&#x2F;断点续传</strong>：将文件分成几块，不同的线程通过<code>seek()</code>到不同位置并行写入。</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.dat&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 写入一个int和一個String</span></span><br><span class="line">    raf.writeInt(<span class="number">100</span>);</span><br><span class="line">    raf.writeUTF(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// UTF格式写入，会先写入长度信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指针重置到文件开头，重新读取</span></span><br><span class="line">    raf.seek(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> raf.readInt();</span><br><span class="line">    <span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> raf.readUTF();</span><br><span class="line"></span><br><span class="line">    System.out.println(number);    <span class="comment">// 输出 100</span></span><br><span class="line">    System.out.println(greeting);  <span class="comment">// 输出 Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：JDK原生，无需额外依赖。功能强大且独特，能解决顺序读写无法解决的问题。</li>
<li><strong>缺点</strong>：API相对古老和繁琐。对于简单的文件操作，它远不如<code>Files</code>类方便。性能在某些场景下可能不如NIO的<code>FileChannel</code>。</li>
</ul>
<hr>
<h3 id="2-5-Apache-FileUtils类"><a href="#2-5-Apache-FileUtils类" class="headerlink" title="2.5 Apache FileUtils类"></a>2.5 Apache FileUtils类</h3><h4 id="2-5-1-概念"><a href="#2-5-1-概念" class="headerlink" title="2.5.1 概念"></a>2.5.1 概念</h4><p><code>FileUtils</code>是Apache Commons IO库中的一个<strong>工具类</strong>。它的设计理念与<code>java.nio.file.Files</code>类似，提供了大量<strong>静态方法</strong>来简化常见的文件操作，但其功能比早期的JDK <code>File</code>类强大得多，甚至对<code>Files</code>类也是一个很好的补充，API设计也非常直观。</p>
<hr>
<h4 id="2-5-2-核心功能与用法"><a href="#2-5-2-核心功能与用法" class="headerlink" title="2.5.2 核心功能与用法"></a>2.5.2 核心功能与用法</h4><ul>
<li><strong>读写文件内容</strong>：<ul>
<li><code>String readFileToString(File file, String encoding)</code>: 一次性读取整个文件到字符串。</li>
<li><code>void writeStringToFile(File file, String data, String encoding)</code>: 将字符串写入文件。</li>
<li><code>List&lt;String&gt; readLines(File file, String encoding)</code>: 按行读取文件到字符串列表。</li>
</ul>
</li>
<li><strong>文件操作</strong>：<ul>
<li><code>copyFile(File srcFile, File destFile)</code>: 复制文件。</li>
<li><code>copyDirectory(File srcDir, File destDir)</code>: 复制整个目录。</li>
<li><code>deleteDirectory(File directory)</code>: 删除整个目录（包括子目录和文件）。</li>
<li><code>cleanDirectory(File directory)</code>: 清空目录内的所有内容。</li>
</ul>
</li>
<li><strong>文件比较与校验</strong>：<ul>
<li><code>boolean contentEquals(File file1, File file2)</code>: 比较两个文件内容是否完全相同。</li>
</ul>
</li>
<li><strong>临时文件操作</strong>：<ul>
<li><code>File getTempDirectory()</code>, <code>File getUserDirectory()</code></li>
</ul>
</li>
<li><strong>文件监控</strong>：提供了<code>FileAlterationMonitor</code>等类用于监听文件变化。</li>
</ul>
<hr>
<h4 id="2-5-3-典型引用场景"><a href="#2-5-3-典型引用场景" class="headerlink" title="2.5.3 典型引用场景"></a>2.5.3 典型引用场景</h4><ul>
<li>需要快速完成一个文件操作任务，不希望写太多样板代码（Boilerplate Code）。</li>
<li>在Java 7之前（没有<code>Files</code>类）的项目中，它是文件操作的“神器”。</li>
<li>即使有<code>Files</code>类，它的某些功能（如整个目录的复制、删除、比较文件内容）仍然非常方便。</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入Apache Commons IO依赖后使用</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 读取文件内容</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> FileUtils.readFileToString(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 写入文件</span></span><br><span class="line">FileUtils.writeStringToFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;output.txt&quot;</span>), <span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 复制整个目录</span></span><br><span class="line">FileUtils.copyDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/sourceDir&quot;</span>), <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/destDir&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：API极其友好和强大，大大简化了代码。是Java界历史悠久、广泛使用的顶级开源库，稳定可靠。</li>
<li><strong>缺点</strong>：需要额外引入第三方依赖（commons-io）。在有了JDK 7+的<code>Files</code>之后，其部分功能可以被替代。</li>
</ul>
<hr>
<h3 id="2-6-Hutool-FileUtil类"><a href="#2-6-Hutool-FileUtil类" class="headerlink" title="2.6 Hutool FileUtil类"></a>2.6 Hutool FileUtil类</h3><h4 id="2-6-1-概念"><a href="#2-6-1-概念" class="headerlink" title="2.6.1 概念"></a>2.6.1 概念</h4><p><code>FileUtil</code>是国产开源工具库<strong>Hutool</strong>中的一个工具类。它的定位与Apache的<code>FileUtils</code>非常相似，也是一个提供大量静态方法的工具类，旨在用一行代码完成文件操作。它的设计更符合中文用户的习惯，并且整合了JDK中<code>File</code>、<code>Files</code>、<code>Paths</code>等多个类的功能，并做了进一步增强。</p>
<hr>
<h4 id="2-6-2-核心功能与用法"><a href="#2-6-2-核心功能与用法" class="headerlink" title="2.6.2 核心功能与用法"></a>2.6.2 核心功能与用法</h4><p>它的功能覆盖了<code>FileUtils</code>的几乎所有功能，并且还有自己的特色：</p>
<ul>
<li><strong>基本文件操作</strong>：与<code>FileUtils</code>类似，提供了<code>readString</code>, <code>writeString</code>, <code>copy</code>, <code>mkdir</code>等方法。</li>
<li><strong>路径处理</strong>：<ul>
<li><code>File file(String path)</code>: 创建<code>File</code>对象（自动处理<code>~</code>表示用户home目录）。</li>
<li><code>getAbsolutePath(String path)</code>: 获取绝对路径。</li>
</ul>
</li>
<li><strong>文件类型判断</strong>：<ul>
<li><code>getType(File file)</code>: 通过文件扩展名获取MIME类型。</li>
<li><code>isModified(File file, long lastModifyTime)</code>: 判断文件是否被修改过。</li>
</ul>
</li>
<li><strong>文件名处理</strong>：<ul>
<li><code>mainName(File file)</code>: 获取主文件名（不含扩展名）。</li>
<li><code>extName(File file)</code>: 获取扩展名。</li>
</ul>
</li>
<li><strong>与流转换</strong>：提供了方便的方法在<code>File</code>、<code>InputStream</code>、<code>OutputStream</code>之间转换。</li>
</ul>
<hr>
<h4 id="2-6-3-典型引用场景"><a href="#2-6-3-典型引用场景" class="headerlink" title="2.6.3 典型引用场景"></a>2.6.3 典型引用场景</h4><ul>
<li>与<code>FileUtils</code>几乎完全一致，希望用最简洁的代码完成文件操作。</li>
<li>项目已经引入了Hutool作为核心工具库（Hutool不仅仅有IO工具，还提供了集合、日期、HTTP客户端、加密解密等海量工具）。</li>
<li>对中文文档和社区支持有偏好。</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入Hutool依赖后使用</span></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.io.FileUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 读取文件内容 (UTF-8)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> FileUtil.readString(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 写入文件</span></span><br><span class="line">FileUtil.writeString(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 复制文件或目录 (方法名与Linux命令相同，非常直观)</span></span><br><span class="line">FileUtil.copy(<span class="string">&quot;/sourceDir&quot;</span>, <span class="string">&quot;/destDir&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：API设计极其简洁，符合国人习惯。功能全面，不仅仅是文件操作，Hutool整个生态非常强大，“一个工具库解决所有问题”。</li>
<li><strong>缺点</strong>：同样是第三方依赖。在一些对依赖管理极其严格的公司，可能更倾向于使用Apache这种“国际标准”或者直接使用JDK原生API。</li>
</ul>
<hr>
<h2 id="3-字节流"><a href="#3-字节流" class="headerlink" title="3. 字节流"></a>3. 字节流</h2><h3 id="3-1-OutPutStream-输出流"><a href="#3-1-OutPutStream-输出流" class="headerlink" title="3.1 OutPutStream (输出流)"></a>3.1 OutPutStream (输出流)</h3><p><code>OutputStream</code> 是一个抽象类，是所有字节输出流的超类。它定义了向目标写入字节的基本方法。</p>
<p><strong>主要方法：</strong></p>
<ul>
<li><code>void write(int b)</code>：向输出流写入<strong>一个字节</strong>（参数 <code>int b</code> 的低8位，高24位被忽略）。</li>
<li><code>void write(byte[] b)</code>：将字节数组 <code>b</code> 中的<strong>所有字节</strong>写入输出流。</li>
<li><code>void write(byte[] b, int off, int len)</code>：将字节数组 <code>b</code> 中从偏移量 <code>off</code> 开始的 <code>len</code> 个字节写入输出流。这是最常用、最灵活的方法。</li>
<li><code>void flush()</code>：<strong>刷新</strong>此输出流。对于缓冲流（如 <code>BufferedOutputStream</code>），此方法会强制将缓冲区中的所有数据立即写入目标，而不是等缓冲区满了再写。</li>
<li><code>void close()</code>：<strong>关闭</strong>此输出流并释放与之关联的所有系统资源。<strong>非常重要！</strong> 必须调用此方法来避免资源泄漏。通常放在 <code>finally</code> 块或使用 try-with-resources 语句自动关闭。</li>
</ul>
<hr>
<h3 id="3-2-FileOutPutStream-文件输出流"><a href="#3-2-FileOutPutStream-文件输出流" class="headerlink" title="3.2 FileOutPutStream (文件输出流)"></a>3.2 FileOutPutStream (文件输出流)</h3><p><code>FileOutputStream</code> 是 <code>OutputStream</code> 的子类，用于将数据写入文件。它负责将字节流写入文件系统中的一个具体文件。</p>
<p><strong>构造方法 (常用)：</strong></p>
<ul>
<li><code>FileOutputStream(File file)</code>：创建一个向指定 <code>File</code> 对象表示的文件写入数据的文件输出流。</li>
<li><code>FileOutputStream(File file, boolean append)</code>：同上，但 <code>append</code> 参数决定是追加还是覆盖。<code>true</code> 表示追加到文件末尾，<code>false</code> 表示覆盖原文件。</li>
<li><code>FileOutputStream(String name)</code>：创建一个向具有指定名称的文件写入数据的输出流。</li>
<li><code>FileOutputStream(String name, boolean append)</code>：同上，带追加模式。</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 try-with-resources 语法，无需手动调用 close()</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="literal">true</span>)) &#123; <span class="comment">// true 表示追加模式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 将字符串转换为字节数组并写入</span></span><br><span class="line">    fos.write(text.getBytes()); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以逐个字节写入</span></span><br><span class="line">    <span class="comment">// fos.write(&#x27;H&#x27;);</span></span><br><span class="line">    <span class="comment">// fos.write(&#x27;i&#x27;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新缓冲区 (对于FileOutputStream，每次write通常直接写盘，但刷新是好习惯)</span></span><br><span class="line">    fos.flush(); </span><br><span class="line">    System.out.println(<span class="string">&quot;数据写入成功！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ul>
<li>如果文件不存在，<code>FileOutputStream</code> 会<strong>自动创建</strong>该文件（但如果路径中的目录不存在，会抛出 <code>FileNotFoundException</code>）。</li>
<li>如果不指定 <code>append</code> 参数或设置为 <code>false</code>，<strong>每次创建流都会清空原文件内容</strong>。</li>
<li>它直接操作字节，所以如果你要写入字符串，需要调用 <code>String.getBytes()</code> 方法进行转换。</li>
</ul>
<hr>
<h3 id="3-3-InPutStream-输入流"><a href="#3-3-InPutStream-输入流" class="headerlink" title="3.3 InPutStream (输入流)"></a>3.3 InPutStream (输入流)</h3><p><code>InputStream</code> 是一个抽象类，是所有字节输入流的超类。它定义了从源读取字节的基本方法。</p>
<p><strong>主要方法：</strong></p>
<ul>
<li><code>int read()</code>：从输入流读取<strong>一个字节</strong>，返回的是读取到的字节值（0-255）。如果已到达流末尾，则返回 <code>-1</code>。</li>
<li><code>int read(byte[] b)</code>：从输入流中读取一些字节并将其存储到字节数组 <code>b</code> 中。返回实际读取的字节数，如果到达末尾则返回 <code>-1</code>。</li>
<li><code>int read(byte[] b, int off, int len)</code>：尝试读取最多 <code>len</code> 个字节到数组 <code>b</code> 中，从偏移量 <code>off</code> 开始存储。返回实际读取的字节数。</li>
<li><code>long skip(long n)</code>：跳过并丢弃此输入流中的 <code>n</code> 个字节数据。</li>
<li><code>int available()</code>：返回此流中<strong>立即可读</strong>的估计字节数（不是文件总大小）。</li>
<li><code>void close()</code>：关闭此输入流并释放资源。同样至关重要。</li>
</ul>
<hr>
<h3 id="3-4-FileInPutStream-文件输入流"><a href="#3-4-FileInPutStream-文件输入流" class="headerlink" title="3.4 FileInPutStream (文件输入流)"></a>3.4 FileInPutStream (文件输入流)</h3><p><code>FileInputStream</code> 是 <code>InputStream</code> 的子类，用于从文件系统中的某个文件获取输入字节，即读取文件内容。</p>
<p><strong>构造方法 (常用)：</strong></p>
<ul>
<li><code>FileInputStream(File file)</code>：通过打开一个到实际文件的连接来创建一个 <code>FileInputStream</code>，该文件通过文件系统中的 <code>File</code> 对象指定。</li>
<li><code>FileInputStream(String name)</code>：通过打开一个到实际文件的连接来创建一个 <code>FileInputStream</code>，该文件通过文件系统中的路径名 <code>name</code> 指定。</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 try-with-resources</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 方法1：逐个字节读取 (效率低，不推荐用于大文件)</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            int content;</span></span><br><span class="line"><span class="comment">            while ((content = fis.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">                System.out.print((char) content); // 将字节转换为字符打印</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方法2：使用字节数组缓冲区读取 (高效，推荐)</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB的缓冲区</span></span><br><span class="line">            <span class="type">int</span> bytesRead; <span class="comment">// 实际读取的字节数</span></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 将读取到的字节转换为字符串并输出</span></span><br><span class="line">                <span class="comment">// 使用 0 到 bytesRead 的范围，避免读取旧数据</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">                System.out.print(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ul>
<li>如果指定的文件<strong>不存在</strong>，会抛出 <code>FileNotFoundException</code>。</li>
<li>使用缓冲区（<code>byte[]</code>）一次性读取多个字节，比逐个字节读取<strong>效率高得多</strong>，是标准做法。</li>
<li>它读取的是原始字节。如果你知道文件内容是文本，需要将其转换为字符串（<code>new String(byteArray)</code>），并注意字符编码问题（最好指定编码，如 <code>new String(buffer, 0, bytesRead, &quot;UTF-8&quot;)</code>）。</li>
</ul>
<hr>
<h2 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4. 字符流"></a>4. 字符流</h2><h3 id="4-1-Reader（读取器）"><a href="#4-1-Reader（读取器）" class="headerlink" title="4.1 Reader（读取器）"></a>4.1 Reader（读取器）</h3><p><code>java.io.Reader</code> 是一个<strong>抽象类</strong>，定义了所有字符输入流的共同行为。</p>
<p><strong>主要方法：</strong></p>
<ul>
<li><code>int read()</code>: 读取<strong>单个字符</strong>。返回作为整数读取的字符，如果已到达流的末尾，则返回 -1。</li>
<li><code>int read(char[] cbuf)</code>: 将字符读入一个数组。返回实际读取的字符数，如果已到达流的末尾，则返回 -1。<strong>更高效</strong>，因为它减少了实际的物理读取次数。</li>
<li><code>int read(char[] cbuf, int off, int len)</code>: 将字符读入数组的某一部分。</li>
<li><code>void close()</code>: <strong>至关重要！</strong> 关闭流并释放与之关联的所有系统资源。必须在 finally 块中或使用 try-with-resources 语句来关闭，以避免资源泄漏。</li>
</ul>
<hr>
<h3 id="4-2-FileReder（文件读取器）"><a href="#4-2-FileReder（文件读取器）" class="headerlink" title="4.2 FileReder（文件读取器）"></a>4.2 FileReder（文件读取器）</h3><p><code>java.io.FileReader</code> 是 <code>InputStreamReader</code> 的子类，是专门用于从<strong>文件</strong>中读取字符数据的便捷类。</p>
<ul>
<li><strong>作用</strong>：它假定文件使用<strong>系统默认的字符编码</strong>（如 Windows 中文版可能是 GBK，macOS&#x2F;Linux 可能是 UTF-8）。这对于简单的、与平台紧密相关的文本读取很方便，但也是其主要缺点。</li>
<li><strong>缺点</strong>：无法指定编码。如果文件的编码与系统默认编码不同（例如，一个 UTF-8 编码的文件在默认编码为 GBK 的系统上读取），就会导致<strong>乱码</strong>。</li>
</ul>
<p><strong>构造方法</strong></p>
<ul>
<li><code>FileReader(String fileName)</code></li>
<li><code>FileReader(File file)</code></li>
</ul>
<p><strong>使用示例</strong><br>	这种方式会自动关闭资源，代码更简洁安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在 try 语句中声明资源，会自动关闭</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> length;</span><br><span class="line">            <span class="keyword">while</span> ((length = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-Writer（写入器）"><a href="#4-3-Writer（写入器）" class="headerlink" title="4.3 Writer（写入器）"></a>4.3 Writer（写入器）</h3><p><code>java.io.Writer</code> 是一个<strong>抽象类</strong>，定义了所有字符输出流的共同行为。</p>
<p><strong>主要方法：</strong></p>
<ul>
<li><code>void write(int c)</code>: 写入<strong>单个字符</strong>。</li>
<li><code>void write(char[] cbuf)</code>: 写入一个字符数组。</li>
<li><code>void write(char[] cbuf, int off, int len)</code>: 写入字符数组的某一部分。</li>
<li><code>void write(String str)</code>: 写入一个字符串。</li>
<li><code>void write(String str, int off, int len)</code>: 写入字符串的某一部分。</li>
<li><code>void flush()</code>: <strong>刷新</strong>该流。如果缓冲区中有任何字符，立即将它们强制写入目标文件。写入器通常是有缓冲的。</li>
<li><code>void close()</code>: 关闭流，先刷新它。关闭后再调用 write() 或 flush() 将抛出异常。</li>
</ul>
<hr>
<h3 id="4-4-FileWriter（文件写入器）"><a href="#4-4-FileWriter（文件写入器）" class="headerlink" title="4.4 FileWriter（文件写入器）"></a>4.4 FileWriter（文件写入器）</h3><p><code>java.io.FileWriter</code> 是 <code>OutputStreamWriter</code> 的子类，是专门用于向<strong>文件</strong>写入字符数据的便捷类。</p>
<ul>
<li><strong>作用</strong>：它使用<strong>系统默认的字符编码</strong>将字符写入文件。同样，这可能导致在不同编码环境的系统上出现写入乱码的问题。</li>
<li><strong>模式</strong>：构造函数可以接受一个 <code>boolean</code> 参数来指定是<strong>追加</strong>（append）还是<strong>覆盖</strong>（overwrite）文件。<ul>
<li><code>FileWriter(String fileName, boolean append)</code></li>
<li><code>append</code> 为 <code>true</code>：将数据追加到文件末尾。</li>
<li><code>append</code> 为 <code>false</code> 或默认：清空原文件内容再写入。</li>
</ul>
</li>
</ul>
<p><strong>构造方法</strong></p>
<ul>
<li><code>FileWriter(String fileName)</code> （覆盖模式）</li>
<li><code>FileWriter(String fileName, boolean append)</code> （追加模式）</li>
<li><code>FileWriter(File file)</code></li>
<li><code>FileWriter(File file, boolean append)</code></li>
</ul>
<p><strong>使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 try-with-resources 自动关闭，注意这里设置为追加模式 (true)</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="literal">true</span>)) &#123; </span><br><span class="line">            writer.write(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;这是一段中文。\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="number">65</span>); <span class="comment">// 写入字符 &#x27;A&#x27;</span></span><br><span class="line">            <span class="comment">// 不需要显式调用 flush()，因为 close() 会自动调用它</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-缓冲流"><a href="#5-缓冲流" class="headerlink" title="5. 缓冲流"></a>5. 缓冲流</h2><p>在内存中创建一个<strong>缓冲区</strong>（一个字节或字符数组）。当进行读写操作时，数据首先被批量地读取到缓冲区中，或从缓冲区中批量地写入。这样就极大地减少了与实际物理设备（如硬盘）的直接交互次数。</p>
<h3 id="5-1-BufferedInputStream-BufferedOutputStream（字节缓冲流）"><a href="#5-1-BufferedInputStream-BufferedOutputStream（字节缓冲流）" class="headerlink" title="5.1 BufferedInputStream &amp; BufferedOutputStream（字节缓冲流）"></a>5.1 BufferedInputStream &amp; BufferedOutputStream（字节缓冲流）</h3><p>它们为字节流提供缓冲，是 <code>FilterInputStream</code> 和 <code>FilterOutputStream</code> 的子类。</p>
<p><strong>核心方法（与其父类基本一致，但带缓冲）：</strong></p>
<ul>
<li><code>read()</code>: 读取一个字节。</li>
<li><code>read(byte[] b)</code>: 读取多个字节到数组。</li>
<li><code>write(int b)</code>: 写入一个字节。</li>
<li><code>write(byte[] b, int off, int len)</code>: 写入字节数组的一部分。</li>
</ul>
<p><strong>示例：复制一个文件（效率远超逐个字节复制）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedByteStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.jpg&quot;</span>);</span><br><span class="line">             <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis); <span class="comment">// 包装</span></span><br><span class="line">             <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;target.jpg&quot;</span>);</span><br><span class="line">             <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos)) &#123; <span class="comment">// 包装</span></span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>]; <span class="comment">// 8KB 的缓冲区</span></span><br><span class="line">            <span class="type">int</span> length;</span><br><span class="line">            <span class="comment">// bis.read(buffer) 会尝试一次性从文件中读取最多 8KB 数据到 buffer</span></span><br><span class="line">            <span class="keyword">while</span> ((length = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// bos.write(buffer, 0, length) 将 buffer 中的数据写入内部缓冲区</span></span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, length); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// try-with-resources 自动关闭流，在关闭 bos 前会自动调用 flush() 将缓冲区数据强制写入文件</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-BufferedReader-BufferedWriter（字符缓冲流）"><a href="#5-2-BufferedReader-BufferedWriter（字符缓冲流）" class="headerlink" title="5.2 BufferedReader &amp; BufferedWriter（字符缓冲流）"></a>5.2 BufferedReader &amp; BufferedWriter（字符缓冲流）</h3><p>它们为字符流提供缓冲，是 <code>Reader</code> 和 <code>Writer</code> 的子类。它们比字节缓冲流更常用，因为提供了额外的方法。</p>
<p><strong><code>BufferedReader</code> 的核心增强方法：</strong></p>
<ul>
<li><code>String readLine()</code>: <strong>读取一行文本</strong>。遇到换行符 (<code>&#39;\n&#39;</code>)、回车符 (<code>&#39;\r&#39;</code>) 或回车后直接跟着换行 (<code>&quot;\r\n&quot;</code>) 时停止。返回的字符串不包含行终止符。如果已到达流末尾，则返回 <code>null</code>。这是读取文本文件最常用的方法。</li>
</ul>
<p><strong><code>BufferedWriter</code> 的核心增强方法：</strong></p>
<ul>
<li><code>void newLine()</code>: <strong>写入一个行分隔符</strong>。这个方法会根据操作系统自动选择正确的行分隔符（<code>\n</code>、<code>\r</code> 或 <code>\r\n</code>），比直接写 <code>&quot;\n&quot;</code> 更可移植。</li>
</ul>
<p><strong>示例：读写文本文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedCharStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 读取一个文本文件并打印到控制台</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">             <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr)) &#123;</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">// 使用 readLine() 方法逐行读取，非常方便</span></span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将内容写入一个文本文件</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">             <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw)) &#123;</span><br><span class="line"></span><br><span class="line">            bw.write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">            bw.newLine(); <span class="comment">// 换行</span></span><br><span class="line">            bw.write(<span class="string">&quot;这是第二行。&quot;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            <span class="comment">// 无需手动 flush(), close() 会自动执行</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-数据流"><a href="#6-数据流" class="headerlink" title="6. 数据流"></a>6. 数据流</h2><h3 id="6-1-核心功能与应用场景"><a href="#6-1-核心功能与应用场景" class="headerlink" title="6.1 核心功能与应用场景"></a><strong>6.1 核心功能与应用场景</strong></h3><h4 id="6-1-1-核心功能"><a href="#6-1-1-核心功能" class="headerlink" title="6.1.1 核心功能"></a>6.1.1 核心功能</h4><ul>
<li><strong>类型保持 (Type Preservation):</strong> 数据流的核心功能是允许你直接写入一个 <code>int</code>，读取时也能直接得到一个 <code>int</code>。它负责将Java基本类型与其二进制表示进行转换。例如，<code>writeInt(65)</code> 会写入4个字节的二进制数据，而不是字符’A’或字符串”65”的字节。</li>
<li><strong>平台无关性 (Platform Independence):</strong> 数据流以一种标准化的方式写入数据（例如，使用大端字节序 Big-Endian），确保了在任何Java虚拟机（JVM）上写入的数据，都可以在其他任何JVM上被正确读取，无需担心底层操作系统的差异。</li>
<li><strong>二进制格式 (Binary Format):</strong> 数据以紧凑的二进制格式存储，通常比文本格式（如XML、JSON）占用更少的空间，读写速度也更快。但是，生成的文件是不可直接阅读的。</li>
<li><strong>方便的API (Convenient API):</strong> 提供了如 <code>writeInt()</code>, <code>readDouble()</code>, <code>writeUTF()</code> 等一系列直观的方法，使得操作基本数据类型变得非常简单。</li>
</ul>
<hr>
<h4 id="6-1-2-典型应用场景"><a href="#6-1-2-典型应用场景" class="headerlink" title="6.1.2 典型应用场景"></a>6.1.2 典型应用场景</h4><ul>
<li><strong>简单的数据持久化 (Simple Data Persistence):</strong> 当你需要存储一些结构化但非复杂对象的数据时，数据流是一个很好的选择。</li>
<li><strong>自定义二进制文件格式 (Custom Binary File Formats):</strong> 当你需要定义一个私有的、高效的二进制文件格式来存储数据时，数据流是理想的工具。</li>
<li><strong>网络通信 (Network Communication):</strong> 在基于Java的客户端&#x2F;服务器之间进行通信时，可以使用数据流来定义一个简单的应用层协议。例如，发送消息长度（<code>int</code>），后跟一个消息（<code>String</code>）。</li>
</ul>
<hr>
<h3 id="6-2-DataOutputStream-数据输出流"><a href="#6-2-DataOutputStream-数据输出流" class="headerlink" title="6.2 DataOutputStream (数据输出流)"></a>6.2 DataOutputStream (数据输出流)</h3><h4 id="6-2-1-构造方法"><a href="#6-2-1-构造方法" class="headerlink" title="6.2.1 构造方法"></a>6.2.1 构造方法</h4><p>它只有一个构造方法，用于包装一个已存在的 <code>OutputStream</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DataOutputStream</span><span class="params">(OutputStream out)</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数据写入文件 data.dat</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.dat&quot;</span>);</span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了提高效率，通常会再包装一层缓冲流</span></span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dosBuffered</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.dat&quot;</span>)</span><br><span class="line">                                 )</span><br><span class="line">                             );</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-2-2-核心方法"><a href="#6-2-2-核心方法" class="headerlink" title="6.2.2 核心方法"></a>6.2.2 核心方法</h4><ul>
<li><code>void writeInt(int v)</code>: 将一个 <code>int</code> 值作为4字节数据写入。</li>
<li><code>void writeDouble(double v)</code>: 将一个 <code>double</code> 值作为8字节数据写入。</li>
<li><code>void writeBoolean(boolean v)</code>: 将一个 <code>boolean</code> 值作为1字节数据写入（1表示<code>true</code>，0表示<code>false</code>）。</li>
<li><code>void writeLong(long v)</code>: 将一个 <code>long</code> 值作为8字节数据写入。</li>
<li><code>void writeFloat(float v)</code>: 将一个 <code>float</code> 值作为4字节数据写入。</li>
<li><code>void writeShort(int v)</code>: 将一个 <code>short</code> 值作为2字节数据写入。</li>
<li><code>void writeByte(int v)</code>: 将一个 <code>byte</code> 值作为1字节数据写入。</li>
<li><code>void writeChar(int v)</code>: 将一个 <code>char</code> 值作为2字节数据写入。</li>
<li><code>void writeUTF(String str)</code>: 以一种改进的UTF-8编码格式写入字符串。它会先写入两个字节表示字符串的长度，然后才是字符串的内容。这使得 <code>readUTF()</code> 知道需要读取多少字节。</li>
<li><code>void flush()</code>: 刷新此数据输出流。这迫使所有缓冲的输出字节被写出到底层流。</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;player.dat&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Knight&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">75</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">health</span> <span class="operator">=</span> <span class="number">98.5</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasKey</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    dos.writeUTF(name);</span><br><span class="line">    dos.writeInt(level);</span><br><span class="line">    dos.writeDouble(health);</span><br><span class="line">    dos.writeBoolean(hasKey);</span><br><span class="line">    </span><br><span class="line">    dos.flush(); <span class="comment">// 确保数据写入文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-3-DataInputStream-数据输入流"><a href="#6-3-DataInputStream-数据输入流" class="headerlink" title="6.3 DataInputStream (数据输入流)"></a>6.3 DataInputStream (数据输入流)</h3><h4 id="6-3-1-构造方法"><a href="#6-3-1-构造方法" class="headerlink" title="6.3.1 构造方法"></a>6.3.1 构造方法</h4><p>同样，它也只有一个构造方法，用于包装一个已存在的 <code>InputStream</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DataInputStream</span><span class="params">(InputStream in)</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件 data.dat 读取数据</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.dat&quot;</span>);</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fis);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样，推荐结合缓冲流使用</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">disBuffered</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.dat&quot;</span>)</span><br><span class="line">                                 )</span><br><span class="line">                             );</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-3-2-核心方法"><a href="#6-3-2-核心方法" class="headerlink" title="6.3.2 核心方法"></a>6.3.2 核心方法</h4><p>核心方法与 <code>DataOutputStream</code> 的写入方法一一对应：</p>
<ul>
<li><code>int readInt()</code></li>
<li><code>double readDouble()</code></li>
<li><code>boolean readBoolean()</code></li>
<li><code>long readLong()</code></li>
<li><code>float readFloat()</code></li>
<li><code>short readShort()</code></li>
<li><code>byte readByte()</code></li>
<li><code>char readChar()</code></li>
<li><code>String readUTF()</code></li>
</ul>
<p><strong>代码示例 (读取上面写入的数据):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;player.dat&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">double</span> <span class="variable">health</span> <span class="operator">=</span> dis.readDouble();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasKey</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;Level: &quot;</span> + level);</span><br><span class="line">    System.out.println(<span class="string">&quot;Health: &quot;</span> + health);</span><br><span class="line">    System.out.println(<span class="string">&quot;Has Key: &quot;</span> + hasKey);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">    <span class="comment">// 当读取到文件末尾时，会抛出此异常，这是正常结束的标志</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数据读取完毕。&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-重要注意事项"><a href="#6-4-重要注意事项" class="headerlink" title="6.4 重要注意事项"></a>6.4 重要注意事项</h3><ol>
<li><p><strong>读写顺序必须严格一致 (Read&#x2F;Write Order Must Be Identical):</strong> 这是使用数据流时最重要、也最容易出错的一点。必须以写入时完全相同的顺序和类型来读取数据。如果写入顺序是 <code>int -&gt; double -&gt; String</code>，那么读取顺序也必须是 <code>readInt() -&gt; readDouble() -&gt; readUTF()</code>。任何顺序或类型的错乱都会导致数据损坏或抛出异常。</p>
</li>
<li><p><strong><code>EOFException</code> 的正确处理 (Correctly Handling <code>EOFException</code>):</strong> 当使用 <code>readXxx()</code> 方法尝试从一个已经没有数据的流中读取时，会抛出 <code>java.io.EOFException</code> (End Of File Exception)。这通常不是一个程序错误，而是<strong>程序正常结束读取的信号</strong>。因此，在循环读取未知长度的数据时，通常将读取逻辑放在 <code>try</code> 块内，并捕获 <code>EOFException</code> 来优雅地终止循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环读取多个记录的模式</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;records.dat&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        <span class="comment">// ... process record</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;所有记录读取完成。&quot;</span>); <span class="comment">// 正常退出循环</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 其他IO错误</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>非对象序列化 (Not for Object Serialization):</strong> 数据流只能处理基本类型和 <code>String</code>。它不能直接写入或读取一个复杂的Java对象（例如一个 <code>Player</code>类的实例）。要实现对象的持久化，需要使用后面提到的对象流 (<code>ObjectOutputStream</code>)。</p>
</li>
<li><p><strong>与缓冲流结合 (Combining with Buffered Streams):</strong> 对于文件或网络IO，每次 <code>writeXxx()</code> 或 <code>readXxx()</code> 都可能触发一次底层的IO操作，这非常低效。强烈建议在数据流和节点流之间加入缓冲流（<code>BufferedInputStream</code> &#x2F; <code>BufferedOutputStream</code>），以显著提高性能。缓冲流会将多次小规模的读写操作合并为一次大规模的IO操作。</p>
</li>
</ol>
<hr>
<h2 id="7-字符编码与转换流"><a href="#7-字符编码与转换流" class="headerlink" title="7. 字符编码与转换流"></a>7. 字符编码与转换流</h2><h3 id="7-1-编码与解码"><a href="#7-1-编码与解码" class="headerlink" title="7.1 编码与解码"></a>7.1 编码与解码</h3><h4 id="7-1-1-字符编码-Character-Encoding"><a href="#7-1-1-字符编码-Character-Encoding" class="headerlink" title="7.1.1 字符编码 (Character Encoding)"></a>7.1.1 字符编码 (Character Encoding)</h4><p>这是最常见、最基础的编码类型，解决了“如何用二进制数字表示文字”的问题。</p>
<ul>
<li><strong>问题</strong>：计算机如何表示 <code>A</code>, <code>中</code>, <code>😊</code> 这些字符？</li>
<li><strong>编码过程</strong>：字符 -&gt; 二进制数字（编号）</li>
<li><strong>解码过程</strong>：二进制数字（编号） -&gt; 字符</li>
</ul>
<p><strong>常见标准：</strong></p>
<ul>
<li><p><strong>ASCII</strong>：最早的标准，用7位二进制数（0-127）表示英文字母、数字和一些控制符。只能处理英文。</p>
</li>
<li><p><strong>GB2312&#x2F;GBK</strong>：中国制定的国家标准，用2个字节表示汉字和中文符号，兼容ASCII。解决了中文编码问题（简体中文版Windows系统默认使用的就是GBK,系统显示ANSI）。</p>
</li>
<li><p><strong>Unicode</strong>：<strong>终极解决方案</strong>，旨在包含世界上所有文字和符号。它为每个字符分配一个<strong>唯一的编号（码点）</strong>，例如 <code>A</code> 的码点是 <code>U+0041</code>， <code>中</code> 的码点是 <code>U+4E2D</code>。</p>
</li>
<li><p><strong>UTF-8</strong>：<strong>Unicode的一种实现方式（编码格式）</strong>，是目前互联网上最主流的编码。它最大的优点是<strong>变长编码</strong>，兼容ASCII（ASCII字符用1个字节，汉字通常用3个字节），非常节省空间。</p>
<pre><code class="highlight mermaid">graph TD
    A[&quot;
    &lt;div style=&#x27;text-align:left;&#x27;&gt;
    &lt;b&gt;UTF-8编码方式&lt;/b&gt;
    &lt;hr&gt;
    0xxxxxxx (ASCII码)
    &lt;hr&gt;
    110xxxxx&amp;nbsp;10xxxxxx
    &lt;hr&gt;
    1110xxxx&amp;nbsp;10xxxxxx&amp;nbsp;10xxxxxx
    &lt;hr&gt;
    11110xxx&amp;nbsp;10xxxxxx&amp;nbsp;10xxxxxx&amp;nbsp;10xxxxxx
    &lt;/div&gt;
    &quot;]

    style A fill:#222, stroke:#fff, color:#fff</code></pre></li>
</ul>
<p><strong>示例：</strong></p>
<p>字符串 “Hello中文” 保存到文件：</p>
<ol>
<li><strong>编码</strong>：程序根据UTF-8规则，将每个字符转换成对应的二进制序列。<ul>
<li><code>H</code> -&gt; <code>01001000</code> (1字节)</li>
<li><code>中</code> -&gt; <code>11100100 10111000 10101101</code> (3字节)</li>
<li>…等等</li>
</ul>
</li>
<li>硬盘存储的是这一长串二进制位。</li>
<li><strong>解码</strong>：另一个程序打开文件，识别出这是UTF-8编码（通常通过文件头部的BOM或上下文推断），然后根据UTF-8规则，将二进制序列一一对应地转换回字符 <code>H</code>, <code>中</code> 等，最终正确显示 “Hello中文”。</li>
</ol>
<p><strong>乱码的产生</strong>：当用错误的编码方式去解码时就会发生。例如，一个用UTF-8编码的“中文”文本，如果你用GBK编码去打开，就会显示成一堆无意义的乱码，如“涓枃”。</p>
<hr>
<h4 id="7-1-2-多媒体编码-Multimedia-Encoding"><a href="#7-1-2-多媒体编码-Multimedia-Encoding" class="headerlink" title="7.1.2 多媒体编码 (Multimedia Encoding)"></a>7.1.2 多媒体编码 (Multimedia Encoding)</h4><p>解决了“如何用二进制数字表示图片、声音、视频”的问题。</p>
<ul>
<li><strong>图片编码 (JPEG, PNG, GIF)</strong><ul>
<li><strong>编码</strong>：将图片的像素点、颜色等信息通过压缩算法转换成二进制文件。JPEG是有损压缩（适合照片），PNG是无损压缩（适合图标）。</li>
<li><strong>解码</strong>：图形软件（如浏览器）读取二进制文件，根据编码规则解压缩，还原出像素点阵，在屏幕上渲染出来。</li>
</ul>
</li>
<li><strong>音频编码 (MP3, AAC, WAV)</strong><ul>
<li><strong>编码</strong>：将模拟的声波信号进行采样、量化和压缩，转换成二进制文件。MP3是有损压缩，会去除人耳不敏感的声音数据。</li>
<li><strong>解码</strong>：播放器读取二进制文件，解压缩，通过数模转换（DAC）还原成模拟电信号，驱动扬声器发出声音。</li>
</ul>
</li>
<li><strong>视频编码 (H.264&#x2F;AVC, H.265&#x2F;HEVC, AV1)</strong><ul>
<li><strong>视频本质</strong>是一系列连续播放的图片（帧）加上同步的音频。</li>
<li><strong>编码</strong>：利用帧与帧之间的相似性（连续画面变化很小）进行<strong>极度压缩</strong>，只存储前后帧的差异部分。这是视频文件远比图片序列小的原因。</li>
<li><strong>解码</strong>：播放器（如VLC, 哔哩哔哩客户端）读取视频文件，解压缩，逐帧还原出图像，并与音频同步播放。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-1-3-传输编码-Transfer-Encoding"><a href="#7-1-3-传输编码-Transfer-Encoding" class="headerlink" title="7.1.3 传输编码 (Transfer Encoding)"></a>7.1.3 传输编码 (Transfer Encoding)</h4><p>为了解决在特定传输环境中（如电子邮件、URL）安全可靠地传递数据。</p>
<ul>
<li><strong>URL编码 (Percent-Encoding)</strong><ul>
<li><strong>问题</strong>：URL中不能直接使用一些特殊字符，如 <code>空格</code>, <code>&amp;</code>, <code>=</code>，因为它们有特殊含义。</li>
<li><strong>编码</strong>：将特殊字符转换为 <code>%</code> 后跟两位十六进制数的形式。<ul>
<li>例如，空格被编码为 <code>%20</code>。</li>
</ul>
</li>
<li><strong>解码</strong>：浏览器或服务器收到URL后，会将 <code>%20</code> 还原回空格。</li>
</ul>
</li>
<li><strong>Base64编码</strong><ul>
<li><strong>问题</strong>：电子邮件协议最初设计为只传输ASCII文本，无法直接传输二进制文件（如图片、附件）。</li>
<li><strong>编码</strong>：将二进制数据转换成由 <code>A-Z, a-z, 0-9, +, /</code> 组成的文本字符串。</li>
<li><strong>解码</strong>：将Base64字符串还原回原始的二进制数据。</li>
<li><strong>应用</strong>：Data URLs（在HTML&#x2F;CSS中嵌入图片）、电子邮件附件、在XML&#x2F;JSON中安全地传输二进制数据。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-1-4-加密与解密-Encryption-Decryption"><a href="#7-1-4-加密与解密-Encryption-Decryption" class="headerlink" title="7.1.4 加密与解密 (Encryption &amp; Decryption)"></a>7.1.4 加密与解密 (Encryption &amp; Decryption)</h4><p>一种以安全保密为目的的特殊编码。</p>
<ul>
<li><strong>编码（加密）</strong>：使用<strong>密钥</strong>和加密算法（如AES）将原始数据（明文）转换为不可读的乱码（密文）。</li>
<li><strong>解码（解密）</strong>：使用正确的<strong>密钥</strong>和解密算法将密文还原为明文。</li>
<li><strong>核心</strong>：没有密钥，即使知道编码规则也无法解码。</li>
</ul>
<hr>
<h3 id="7-2-InputStreamReader-OutPutStreamWriter"><a href="#7-2-InputStreamReader-OutPutStreamWriter" class="headerlink" title="7.2 InputStreamReader &amp; OutPutStreamWriter"></a>7.2 InputStreamReader &amp; OutPutStreamWriter</h3><h4 id="7-2-1-InputStreamReader"><a href="#7-2-1-InputStreamReader" class="headerlink" title="7.2.1 InputStreamReader"></a>7.2.1 InputStreamReader</h4><p><code>InputStreamReader</code> 是 <code>Reader</code> 的子类，它从底层的字节输入流读取字节，并使用指定的字符编码将其解码为字符。</p>
<h5 id="1-关键构造函数"><a href="#1-关键构造函数" class="headerlink" title="1. 关键构造函数"></a>1. 关键构造函数</h5><ul>
<li><code>InputStreamReader(InputStream in)</code><ul>
<li>创建一个使用<strong>平台默认字符集</strong>的 InputStreamReader。</li>
<li><strong>注意</strong>：依赖于系统默认编码，不利于跨平台，一般不推荐使用。</li>
<li><code>InputStreamReader isr = new InputStreamReader(System.in); // 从标准输入读取</code></li>
</ul>
</li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code><ul>
<li>创建一个使用<strong>指定字符集</strong>的 InputStreamReader。</li>
<li><code>CharsetName</code> 可以是标准字符集名称，如 “UTF-8”, “GBK”, “ISO-8859-1” 等。</li>
<li><code>InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;file.txt&quot;), &quot;UTF-8&quot;);</code></li>
</ul>
</li>
<li><code>InputStreamReader(InputStream in, Charset cs)</code><ul>
<li>使用指定的 <code>Charset</code> 对象创建 InputStreamReader。这是更现代和推荐的方式。</li>
<li><code>InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;file.txt&quot;), StandardCharsets.UTF_8);</code></li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><p>当你调用 <code>isr.read()</code> 时，会发生以下步骤：</p>
<ol>
<li><code>InputStreamReader</code> 从其内部的 <code>InputStream</code>（例如 <code>FileInputStream</code>）中读取一个或多个字节。</li>
<li>这些字节根据创建 <code>InputStreamReader</code> 时指定的字符编码规则进行解码。</li>
<li>将解码后的结果返回为一个Unicode字符（<code>char</code>）。</li>
</ol>
<hr>
<h5 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h5><p>继承自 <code>Reader</code> 类：</p>
<ul>
<li><code>int read()</code>: 读取单个字符。</li>
<li><code>int read(char[] cbuf)</code>: 将字符读入数组。</li>
<li><code>int read(char[] cbuf, int off, int len)</code>: 将字符读入数组的某一部分。</li>
<li><code>void close()</code>: 关闭流。</li>
</ul>
<hr>
<h4 id="7-2-2-OutputStreamWriter"><a href="#7-2-2-OutputStreamWriter" class="headerlink" title="7.2.2 OutputStreamWriter"></a>7.2.2 OutputStreamWriter</h4><p><code>OutputStreamWriter</code> 是 <code>Writer</code> 的子类，它接收字符，使用指定的字符编码将其编码为字节，然后写入底层的字节输出流。</p>
<h5 id="1-关键构造函数-1"><a href="#1-关键构造函数-1" class="headerlink" title="1. 关键构造函数"></a>1. 关键构造函数</h5><ul>
<li><code>OutputStreamWriter(OutputStream out)</code><ul>
<li>创建一个使用<strong>平台默认字符集</strong>的 OutputStreamWriter。（不推荐）</li>
</ul>
</li>
<li><code>OutputStreamWriter(OutputStream out, String charsetName)</code><ul>
<li>创建一个使用<strong>指定字符集</strong>的 OutputStreamWriter。</li>
<li><code>OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;output.txt&quot;), &quot;GBK&quot;);</code></li>
</ul>
</li>
<li><code>OutputStreamWriter(OutputStream out, Charset cs)</code><ul>
<li>使用指定的 <code>Charset</code> 对象创建 OutputStreamWriter。</li>
<li><code>OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;output.txt&quot;), StandardCharsets.UTF_8);</code></li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-工作原理-1"><a href="#2-工作原理-1" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><p>当你调用 <code>osw.write(&#39;你&#39;)</code> 时，会发生以下步骤：</p>
<ol>
<li>字符 ‘你’（一个Unicode码点）被送入 <code>OutputStreamWriter</code>。</li>
<li><code>OutputStreamWriter</code> 根据创建时指定的字符编码规则（如UTF-8）将这个字符编码为一个或多个字节。</li>
<li>这些被编码后的字节被写入其内部的 <code>OutputStream</code>（例如 <code>FileOutputStream</code>），最终被写入文件或网络。</li>
</ol>
<hr>
<h5 id="3-常用方法-1"><a href="#3-常用方法-1" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h5><p>继承自 <code>Writer</code> 类：</p>
<ul>
<li><code>void write(int c)</code>: 写入单个字符。</li>
<li><code>void write(char[] cbuf)</code>: 写入字符数组。</li>
<li><code>void write(String str)</code>: 写入字符串。</li>
<li><code>void flush()</code>: 刷新流的缓冲，立即将缓冲区的数据写入目的地。</li>
<li><code>void close()</code>: 关闭流，关闭前会先刷新。</li>
</ul>
<hr>
<h2 id="8-序列流【存在安全风险，不推荐使用，有现代替代方案】"><a href="#8-序列流【存在安全风险，不推荐使用，有现代替代方案】" class="headerlink" title="8 序列流【存在安全风险，不推荐使用，有现代替代方案】"></a>8 序列流【存在安全风险，不推荐使用，有现代替代方案】</h2><h3 id="8-1-序列化"><a href="#8-1-序列化" class="headerlink" title="8.1 序列化"></a>8.1 序列化</h3><h4 id="8-1-1-概念"><a href="#8-1-1-概念" class="headerlink" title="8.1.1 概念"></a>8.1.1 概念</h4><p><strong>序列化（Serialization）</strong> 是指将一个对象的状态信息（即它的数据字段）转换为可以存储或传输的形式的过程。在 Java 中，这个“形式”通常是一个字节序列（byte stream）。</p>
<p><strong>反序列化（Deserialization）</strong> 则是相反的过程，它将从存储或传输中得到的字节序列重新构造成一个内存中的对象。</p>
<p>简单来说：</p>
<ul>
<li><strong>序列化：</strong> <code>Object</code> → <strong>字节流</strong> (可用于保存到文件、存入数据库、通过网络发送)</li>
<li><strong>反序列化：</strong> <strong>字节流</strong> → <code>Object</code></li>
</ul>
<hr>
<h4 id="8-1-2-Serializable-接口的核心角色"><a href="#8-1-2-Serializable-接口的核心角色" class="headerlink" title="8.1.2 Serializable 接口的核心角色"></a>8.1.2 <code>Serializable</code> 接口的核心角色</h4><p>Java 的序列化机制核心是一个标记接口（Marker Interface）—— <code>java.io.Serializable</code>。</p>
<ul>
<li><strong>标记接口（Marker Interface）</strong>：这种接口内部没有任何方法或字段。它仅仅像一个“标签”或“许可证”，用于告诉 Java 虚拟机（JVM）：“这个类的对象是可以被序列化的”。</li>
<li>如果一个类没有实现 <code>Serializable</code> 接口，尝试对其对象进行序列化将会抛出 <code>NotSerializableException</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-1-3-实现"><a href="#8-1-3-实现" class="headerlink" title="8.1.3 实现"></a>8.1.3 实现</h4><p> <strong>第一步：让目标类实现 <code>Serializable</code> 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password; <span class="comment">// 使用 transient 关键字，这个变量不会被序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法、getter、setter 等</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：使用 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&quot;secret123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象到文件 (序列化)</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.ser&quot;</span>);</span><br><span class="line">             <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut)) &#123;</span><br><span class="line"></span><br><span class="line">            out.writeObject(person); <span class="comment">// 关键方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Serialized data is saved in person.ser&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException i) &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件反序列化对象 (反序列化)</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">deserializedPerson</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.ser&quot;</span>);</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn)) &#123;</span><br><span class="line"></span><br><span class="line">            deserializedPerson = (Person) in.readObject(); <span class="comment">// 关键方法</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException i) &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证反序列化后的对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Deserialized Person...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + deserializedPerson.getName()); <span class="comment">// 输出: Alice</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + deserializedPerson.getAge());   <span class="comment">// 输出: 30</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Password: &quot;</span> + deserializedPerson.getPassword()); <span class="comment">// 输出: null (因为被 transient 修饰)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-1-4-关键特性与深入概念"><a href="#8-1-4-关键特性与深入概念" class="headerlink" title="8.1.4 关键特性与深入概念"></a>8.1.4 关键特性与深入概念</h4><h5 id="1-serialVersionUID"><a href="#1-serialVersionUID" class="headerlink" title="1. serialVersionUID"></a>1. <code>serialVersionUID</code></h5><p><strong>概念</strong>：一个类的序列化版本号。它是一个 <code>private static final long</code> 常量。</p>
<p><strong>用途</strong>：JVM 使用这个 ID 来验证序列化的发送者和接收者是否加载了与序列化兼容的类。如果反序列化时类的 <code>serialVersionUID</code> 与序列化时的值不匹配，就会抛出 <code>InvalidClassException</code>。</p>
<p><strong>最佳实践</strong>：如果你不显式声明，JVM 会根据类的细节（类名、成员、方法等）自动生成一个。一旦类发生任何更改（比如增加一个无关紧要的方法），自动生成的 ID 就会改变，导致之前序列化的对象无法反序列化。</p>
<p><strong>声明：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 可以是任意 long 值，通常从 1L 开始</span></span><br><span class="line">    <span class="comment">// ... 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-transient-关键字"><a href="#2-transient-关键字" class="headerlink" title="2. transient 关键字"></a>2. <code>transient</code> 关键字</h5><ul>
<li>用于修饰成员变量，表示该变量<strong>不应</strong>被序列化。</li>
<li>常用于存储敏感信息（如密码、密钥）或临时性、重建成本很低的数据（如线程池、文件句柄等）。</li>
<li>反序列化后，<code>transient</code> 变量的值会被设置为其类型的默认值（如对象为 <code>null</code>，<code>int</code> 为 <code>0</code>，<code>boolean</code> 为 <code>false</code>）。</li>
</ul>
<hr>
<h5 id="3-继承关系中的序列化"><a href="#3-继承关系中的序列化" class="headerlink" title="3. 继承关系中的序列化"></a>3. 继承关系中的序列化</h5><ul>
<li><strong>如果一个父类实现了 <code>Serializable</code>，其子类自动也是可序列化的。</strong></li>
<li>如果一个子类实现了 <code>Serializable</code>，但其父类没有：<ul>
<li>反序列化子类对象时，父类的<strong>无参构造方法</strong>会被自动调用，以初始化父类的字段。因此，父类必须有一个可访问的无参构造器，否则会抛出 <code>InvalidClassException</code>。</li>
<li>父类中定义的字段不会被序列化（因为它们不属于可序列化的类）。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-自定义序列化过程：writeObject-和-readObject"><a href="#4-自定义序列化过程：writeObject-和-readObject" class="headerlink" title="4. 自定义序列化过程：writeObject 和 readObject"></a>4. 自定义序列化过程：<code>writeObject</code> 和 <code>readObject</code></h5><p>如果你需要对序列化和反序列化的过程进行精确控制（例如，加密敏感数据、验证对象状态），可以在你的类中定义这两个私有方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 可以先对数据进行一些处理，例如加密密码字段（伪代码）</span></span><br><span class="line">    <span class="comment">// this.encryptedPassword = encrypt(this.password);</span></span><br><span class="line">    out.defaultWriteObject(); <span class="comment">// 执行默认的序列化机制</span></span><br><span class="line">    <span class="comment">// 还可以写入更多的自定义数据</span></span><br><span class="line">    <span class="comment">// out.writeInt(this.someExtraValue);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    in.defaultReadObject(); <span class="comment">// 执行默认的反序列化机制</span></span><br><span class="line">    <span class="comment">// 然后处理自定义的数据</span></span><br><span class="line">    <span class="comment">// this.someExtraValue = in.readInt();</span></span><br><span class="line">    <span class="comment">// 最后对数据进行后处理，例如解密密码字段（伪代码）</span></span><br><span class="line">    <span class="comment">// this.password = decrypt(this.encryptedPassword);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-特殊方法：readResolve-和-writeReplace"><a href="#5-特殊方法：readResolve-和-writeReplace" class="headerlink" title="5. 特殊方法：readResolve 和 writeReplace"></a>5. 特殊方法：<code>readResolve</code> 和 <code>writeReplace</code></h5><p>这两个方法允许你在序列化前后替换要写入或读取的对象，常用于实现单例模式，防止反序列化破坏单例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法在 readObject 之后被调用，返回的对象会替换掉反序列化创建的新对象</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE; <span class="comment">// 始终返回唯一的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="6-优缺点"><a href="#6-优缺点" class="headerlink" title="6. 优缺点"></a>6. 优缺点</h5><p><strong>优点：</strong></p>
<ul>
<li><strong>极其简单易用</strong>：只需实现一个接口，JDK 就处理了所有复杂工作。</li>
<li><strong>自动处理复杂对象图</strong>：能够递归序列化整个对象引用网络（例如，一个对象包含另一个对象的引用，另一个对象又包含其他引用），不会出现循环引用的问题。</li>
</ul>
<p><strong>缺点和风险：</strong></p>
<ol>
<li><strong>安全问题</strong>：<ul>
<li>反序列化过程本质上是在“执行代码”，它会调用类的构造器和方法。恶意构造的字节流可以导致任意代码执行，这是一个非常严重的安全漏洞。</li>
<li>著名的 <code>Apache Commons Collections</code> 反序列化漏洞就源于此。</li>
</ul>
</li>
<li><strong>版本兼容性</strong>：<ul>
<li>虽然 <code>serialVersionUID</code> 可以解决一部分问题，但类的结构发生重大变化（如删除字段、更改字段类型）时，兼容性处理依然非常棘手。</li>
</ul>
</li>
<li><strong>性能</strong>：<ul>
<li>生成的字节流通常比较庞大，序列化和反序列化的过程也相对较慢。</li>
</ul>
</li>
<li><strong>跨语言能力差</strong>：<ul>
<li>Java 序列化是 Java 特有的，其他语言无法读取由 Java 序列化产生的字节流。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="7-替代方案"><a href="#7-替代方案" class="headerlink" title="7. 替代方案"></a>7. 替代方案</h5><p>由于上述缺点，尤其是在微服务和分布式架构中，Java 原生序列化已不再是首选。更流行的替代方案包括：</p>
<ul>
<li><strong>JSON</strong> (如 Jackson, Gson): 文本格式，人类可读，跨语言支持极好，是 Web API 和数据交换的事实标准。</li>
<li><strong>XML</strong>: 类似 JSON，但更冗长。</li>
<li><strong>Protocol Buffers (Protobuf)</strong> - Google: 二进制格式，高性能，跨语言，需要预定义模式（<code>.proto</code>文件），是微服务间通信的绝佳选择。</li>
<li><strong>Apache Avro</strong>: 二进制格式，同样需要模式，常用于大数据领域（如 Hadoop）。</li>
<li><strong>MessagePack</strong>: 类似于二进制的 JSON，比 JSON 更紧凑。</li>
</ul>
<hr>
<h3 id="8-2-ObjectOutPutStream-ObjectInPutStream"><a href="#8-2-ObjectOutPutStream-ObjectInPutStream" class="headerlink" title="8.2 ObjectOutPutStream &amp; ObjectInPutStream"></a>8.2 ObjectOutPutStream &amp; ObjectInPutStream</h3><h4 id="8-2-1-ObjectOutputStream-的序列化过程"><a href="#8-2-1-ObjectOutputStream-的序列化过程" class="headerlink" title="8.2.1 ObjectOutputStream 的序列化过程"></a>8.2.1 ObjectOutputStream 的序列化过程</h4><p>当你调用 <code>out.writeObject(someObject)</code> 时，会发生以下几步：</p>
<ol>
<li><strong>检查与验证</strong>：<ul>
<li>首先，它会检查 <code>someObject</code> 的类是否实现了 <code>Serializable</code> 接口。如果没有，立即抛出 <code>NotSerializableException</code>。</li>
<li>检查并获取该类的 <code>serialVersionUID</code>。如果类明确定义了它，就使用定义的值；否则，JVM 会根据类的结构自动计算生成一个。</li>
</ul>
</li>
<li><strong>处理对象图</strong>：<ul>
<li>序列化不仅仅是序列化 <code>someObject</code> 本身。它会递归地序列化 <code>someObject</code> 所引用的所有其他对象（除非引用被 <code>transient</code> 修饰或为 <code>null</code>），形成一个完整的字节流网络。这个过程可以处理复杂的循环引用。</li>
</ul>
</li>
<li><strong>写入字节流</strong>：<ul>
<li>将类的描述信息（包括类名、<code>serialVersionUID</code>）、字段名、字段类型等信息写入流中。</li>
<li>然后，按照类的定义，将非 <code>transient</code> 的实例字段的值逐个写入流中。如果字段是另一个对象，则递归执行 <code>writeObject</code>。</li>
</ul>
</li>
<li><strong>自定义序列化</strong>：<ul>
<li>如果被序列化的类定义了私有的 <code>writeObject(ObjectOutputStream out)</code> 方法，那么<strong>默认的序列化行为将被覆盖</strong>，转而执行这个自定义方法。开发者可以在此方法中精确控制要写入什么数据（例如，先对敏感数据进行加密再调用 <code>defaultWriteObject</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="8-2-2-ObjectInputStream-的反序列化过程"><a href="#8-2-2-ObjectInputStream-的反序列化过程" class="headerlink" title="8.2.2 ObjectInputStream 的反序列化过程"></a>8.2.2 ObjectInputStream 的反序列化过程</h4><p>当你调用 <code>in.readObject()</code> 时，会发生以下几步：</p>
<ol>
<li><strong>读取与验证</strong>：<ul>
<li>从流中读取类的描述信息（元数据）和 <code>serialVersionUID</code>。</li>
<li>将读取到的 <code>serialVersionUID</code> 与当前 JVM 环境中对应类的 <code>serialVersionUID</code> 进行比对。<strong>如果不匹配，将抛出 <code>InvalidClassException</code></strong>。这是保证序列化双方版本一致性的关键。</li>
</ul>
</li>
<li><strong>分配内存与重建对象</strong>：<ul>
<li>JVM 会根据从流中读取到的类信息，<strong>不通过类的构造方法</strong>，直接为该对象分配内存空间。这是反序列化与普通对象创建的关键区别。</li>
</ul>
</li>
<li><strong>填充字段</strong>：<ul>
<li>按照流中的顺序，将字段值逐一读取并填充到新分配的对象中。</li>
<li>如果字段是原始类型（如 <code>int</code>, <code>double</code>），直接填充其值。</li>
<li>如果字段是对象引用，则递归地执行 <code>readObject()</code> 来重建整个对象图，并恢复原始的引用关系。</li>
</ul>
</li>
<li><strong>最终处理与自定义反序列化</strong>：<ul>
<li>如果被反序列化的类定义了私有的 <code>readObject(ObjectInputStream in)</code> 方法，那么<strong>默认的反序列化行为将被覆盖</strong>，转而执行这个自定义方法。开发者可以在此方法中进行额外的初始化或数据转换（例如，对加密的数据进行解密）。</li>
<li>最后，如果类定义了 <code>readResolve()</code> 方法，则会调用它，并用其返回的对象替换掉刚刚反序列化创建的对象。这对于保护单例模式至关重要。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="9-打印流"><a href="#9-打印流" class="headerlink" title="9. 打印流"></a>9. 打印流</h2><h3 id="9-1-核心特点"><a href="#9-1-核心特点" class="headerlink" title="9.1 核心特点"></a>9.1 核心特点</h3><ol>
<li><strong>不会抛出 IOException</strong><ul>
<li>这是打印流与其它 <code>OutputStream</code> 或 <code>Writer</code> 最显著的区别。</li>
<li>它内部设置了错误标志位。你可以通过 <code>checkError()</code> 方法来检查是否发生了错误，而不是用 <code>try-catch</code> 来捕获异常。这极大地简化了代码编写。</li>
</ul>
</li>
<li><strong>自动刷新 (AutoFlush)</strong><ul>
<li>可以在创建打印流时通过构造函数的一个参数来启用自动刷新功能。</li>
<li>当启用后，调用 <code>println()</code>, <code>printf()</code>, 或 <code>format()</code> 方法时，会自动刷新输出缓冲区，确保数据立即被写出。这对于控制台输出特别有用。</li>
</ul>
</li>
<li><strong>丰富的输出方法</strong><ul>
<li>提供了大量重载的 <code>print()</code> 和 <code>println()</code> 方法，可以接受几乎所有基本数据类型（<code>int</code>, <code>boolean</code>, <code>double</code>…）和对象（<code>Object</code>）。</li>
<li>对于对象，它会自动调用该对象的 <code>toString()</code> 方法将其转换为字符串再输出。</li>
<li><code>println()</code> 方法在输出内容后还会附加一个平台相关的行分隔符（如 <code>\n</code> 或 <code>\r\n</code>）。</li>
</ul>
</li>
<li><strong>格式化输出</strong><ul>
<li>提供了 <code>printf()</code> 和 <code>format()</code> 方法（两者功能完全相同），支持使用格式字符串进行复杂的格式化输出，类似于 C 语言的 <code>printf</code> 函数。</li>
</ul>
</li>
</ol>
<h3 id="9-2-PrintStream（字节打印流）"><a href="#9-2-PrintStream（字节打印流）" class="headerlink" title="9.2 PrintStream（字节打印流）"></a>9.2 PrintStream（字节打印流）</h3><p><code>PrintStream</code> 继承自 <code>FilterOutputStream</code>，用于向另一个 <code>OutputStream</code>（字节输出流）装饰和增强功能。</p>
<h4 id="9-2-1-常见构造方法"><a href="#9-2-1-常见构造方法" class="headerlink" title="9.2.1 常见构造方法"></a>9.2.1 常见构造方法</h4><ul>
<li><code>PrintStream(OutputStream out)</code>: 包装一个输出流，不自动刷新。</li>
<li><code>PrintStream(OutputStream out, boolean autoFlush)</code>: 包装一个输出流，并可指定是否自动刷新。</li>
<li><code>PrintStream(String fileName)</code>: 创建一个新的打印流，指定文件名，不自动刷新。</li>
<li><code>PrintStream(File file)</code>: 创建一个新的打印流，指定文件对象，不自动刷新。</li>
<li><code>PrintStream(String fileName, String csn)</code>: 创建指定文件和字符集的打印流。</li>
</ul>
<hr>
<h4 id="9-2-2-重要方法"><a href="#9-2-2-重要方法" class="headerlink" title="9.2.2 重要方法"></a>9.2.2 重要方法</h4><p>除了从 <code>FilterOutputStream</code> 继承的 <code>write()</code> 方法，它主要提供了：</p>
<ul>
<li><code>print(各种数据类型)</code></li>
<li><code>println(各种数据类型)</code></li>
<li><code>printf(String format, Object... args)</code></li>
<li><code>format(String format, Object... args)</code></li>
<li><code>checkError()</code>: 刷新流并检查其错误状态。</li>
</ul>
<hr>
<h4 id="9-2-3-最著名的实例：System-out-和-System-err"><a href="#9-2-3-最著名的实例：System-out-和-System-err" class="headerlink" title="9.2.3 最著名的实例：System.out 和 System.err"></a>9.2.3 最著名的实例：<code>System.out</code> 和 <code>System.err</code></h4><p>Java 标准库中的 <code>System.out</code> 和 <code>System.err</code> 就是 <code>PrintStream</code> 对象。</p>
<ul>
<li><code>System.out</code>： 标准输出流，通常对应控制台。</li>
<li><code>System.err</code>： 标准错误输出流，通常也对应控制台，但用于输出错误信息（在某些IDE中会以红色显示）。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 打印到控制台 (使用System.out)</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Hello, &quot;</span>); <span class="comment">// 不换行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;World!&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;The number is: &quot;</span> + number); <span class="comment">// 自动转换</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Formatted: %05d %n&quot;</span>, number); <span class="comment">// 格式化输出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 重定向输出到文件</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">             <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fos, <span class="literal">true</span>)) &#123; <span class="comment">// 启用自动刷新</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将标准输出重定向到文件</span></span><br><span class="line">            System.setOut(ps);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在所有System.out.println都会写入文件</span></span><br><span class="line">            System.out.println(<span class="string">&quot;This line goes to output.txt&quot;</span>);</span><br><span class="line">            System.out.printf(<span class="string">&quot;Pi is approximately %.2f&quot;</span>, Math.PI);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 检查错误</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">myStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(System.out);</span><br><span class="line">        myStream.println(<span class="string">&quot;Testing error.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (myStream.checkError()) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;An error occurred in the print stream!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="9-3-PrintWriter（字符打印流）"><a href="#9-3-PrintWriter（字符打印流）" class="headerlink" title="9.3 PrintWriter（字符打印流）"></a>9.3 PrintWriter（字符打印流）</h3><p><code>PrintWriter</code> 继承自 <code>Writer</code>，用于向另一个 <code>Writer</code> 或 <code>OutputStream</code>（字节流）装饰和增强功能。<strong>在现代 Java 开发中，更推荐使用 <code>PrintWriter</code>，因为它基于字符，能更好地处理文本和国际化。</strong></p>
<h4 id="9-3-1-常见构造方法"><a href="#9-3-1-常见构造方法" class="headerlink" title="9.3.1 常见构造方法"></a>9.3.1 常见构造方法</h4><ul>
<li><code>PrintWriter(Writer out)</code></li>
<li><code>PrintWriter(Writer out, boolean autoFlush)</code></li>
<li><code>PrintWriter(OutputStream out)</code></li>
<li><code>PrintWriter(OutputStream out, boolean autoFlush)</code></li>
<li><code>PrintWriter(String fileName)</code></li>
<li><code>PrintWriter(File file)</code></li>
</ul>
<hr>
<h4 id="9-3-2-重要方法"><a href="#9-3-2-重要方法" class="headerlink" title="9.3.2 重要方法"></a>9.3.2 重要方法</h4><p>方法与 <code>PrintStream</code> 几乎完全一样：</p>
<ul>
<li><code>print()</code></li>
<li><code>println()</code></li>
<li><code>printf()</code></li>
<li><code>format()</code></li>
<li><code>checkError()</code></li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintWriterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 使用PrintWriter包装FileWriter (字符流)</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;log.txt&quot;</span>);</span><br><span class="line">             <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fw, <span class="literal">true</span>)) &#123; <span class="comment">// 启用自动刷新</span></span><br><span class="line"></span><br><span class="line">            pw.println(<span class="string">&quot;Application Log&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">            pw.printf(<span class="string">&quot;Timestamp: %tc %n&quot;</span>, System.currentTimeMillis());</span><br><span class="line">            pw.print(<span class="string">&quot;Status: OK&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 直接包装OutputStream (字节流)</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(System.out, <span class="literal">true</span>)) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;This goes to the console via PrintWriter.&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">19.99</span>;</span><br><span class="line">            pw.printf(<span class="string">&quot;The price is $%.2f&quot;</span>, price);</span><br><span class="line">        &#125; <span class="comment">// 不需要catch IOException，因为PrintWriter不抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-其他重要IO流"><a href="#10-其他重要IO流" class="headerlink" title="10. 其他重要IO流"></a>10. 其他重要IO流</h2><h3 id="10-1-内存操作流-In-Memory-I-O"><a href="#10-1-内存操作流-In-Memory-I-O" class="headerlink" title="10.1 内存操作流 (In-Memory I&#x2F;O)"></a>10.1 内存操作流 (In-Memory I&#x2F;O)</h3><h4 id="10-1-1-ByteArrayInputStream-ByteArrayOutputStream-字节数组流"><a href="#10-1-1-ByteArrayInputStream-ByteArrayOutputStream-字节数组流" class="headerlink" title="10.1.1 ByteArrayInputStream &amp; ByteArrayOutputStream (字节数组流)"></a>10.1.1 <code>ByteArrayInputStream</code> &amp; <code>ByteArrayOutputStream</code> (字节数组流)</h4><ul>
<li><p><strong>概念</strong>:</p>
<ul>
<li><code>ByteArrayOutputStream</code>: 这是一个<strong>输出流</strong>，它将数据写入到一个内部的、可自动增长的<strong>字节数组 (<code>byte[]</code>)</strong> 中。可以把它想象成一个在内存中不断增长的字节缓冲区。</li>
<li><code>ByteArrayInputStream</code>: 这是一个<strong>输入流</strong>，它从一个<strong>已存在的字节数组 (<code>byte[]</code>)</strong> 中读取数据。</li>
</ul>
</li>
<li><p><strong>核心用法</strong>:</p>
<ol>
<li>使用 <code>ByteArrayOutputStream</code> 收集来自不同来源的字节数据。</li>
<li>调用 <code>toByteArray()</code> 方法，从 <code>ByteArrayOutputStream</code> 中获取最终的、完整的字节数组。</li>
<li>将这个字节数组传递给 <code>ByteArrayInputStream</code> 的构造函数。</li>
<li>像从文件中读取一样，从 <code>ByteArrayInputStream</code> 中读取数据。</li>
</ol>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 ByteArrayOutputStream 写入数据到内存</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(baos)) &#123;</span><br><span class="line">    <span class="comment">// 写入一些不同类型的数据</span></span><br><span class="line">    dos.writeUTF(<span class="string">&quot;Hello Memory IO&quot;</span>);</span><br><span class="line">    dos.writeInt(<span class="number">12345</span>);</span><br><span class="line">    dos.writeDouble(<span class="number">3.14159</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 写入内存几乎不会发生IO异常，但语法上需要处理</span></span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从 OutputStream 中获取完整的字节数组</span></span><br><span class="line"><span class="type">byte</span>[] data = baos.toByteArray();</span><br><span class="line">System.out.println(<span class="string">&quot;写入内存的字节数组长度: &quot;</span> + data.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用 ByteArrayInputStream 从内存中读取数据</span></span><br><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(bais)) &#123;</span><br><span class="line">    System.out.println(dis.readUTF());    <span class="comment">// 输出: Hello Memory IO</span></span><br><span class="line">    System.out.println(dis.readInt());     <span class="comment">// 输出: 12345</span></span><br><span class="line">    System.out.println(dis.readDouble());  <span class="comment">// 输出: 3.14159</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="10-1-2-StringReader-StringWriter-字符串流"><a href="#10-1-2-StringReader-StringWriter-字符串流" class="headerlink" title="10.1.2 StringReader &amp; StringWriter (字符串流)"></a>10.1.2 <code>StringReader</code> &amp; <code>StringWriter</code> (字符串流)</h4><ul>
<li><p><strong>概念</strong>:</p>
<ul>
<li>这是字节数组流的<strong>字符版本</strong>。它们的数据源和目的地是内存中的字符串。</li>
<li><code>StringWriter</code>: 将字符数据写入其内部的 <code>StringBuffer</code> 或 <code>StringBuilder</code>。</li>
<li><code>StringReader</code>: 从一个已存在的 <code>String</code> 对象中读取字符数据。</li>
</ul>
</li>
<li><p><strong>核心用法</strong>:</p>
<ul>
<li>与字节数组流类似，<code>StringWriter</code> 用于构建字符串，然后通过 <code>toString()</code> 获取结果。<code>StringReader</code> 则用于将一个现有字符串包装成一个 <code>Reader</code>，使其可以被需要 <code>Reader</code> 作为参数的API（如XML解析器、模板引擎）处理。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 StringWriter 写入字符数据到内存</span></span><br><span class="line"><span class="type">StringWriter</span> <span class="variable">stringWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(stringWriter)) &#123;</span><br><span class="line">    printWriter.println(<span class="string">&quot;This is line 1.&quot;</span>);</span><br><span class="line">    printWriter.printf(<span class="string">&quot;This is line %d with a value.&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从 StringWriter 获取完整的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> stringWriter.toString();</span><br><span class="line">System.out.println(<span class="string">&quot;--- StringWriter Result ---&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用 StringReader 从字符串中读取</span></span><br><span class="line">System.out.println(<span class="string">&quot;--- Reading from StringReader ---&quot;</span>);</span><br><span class="line"><span class="type">StringReader</span> <span class="variable">stringReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(result);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(stringReader)) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Read line: &quot;</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="10-1-3-核心应用：面向内存的IO操作与数据转换"><a href="#10-1-3-核心应用：面向内存的IO操作与数据转换" class="headerlink" title="10.1.3 核心应用：面向内存的IO操作与数据转换"></a>10.1.3 核心应用：面向内存的IO操作与数据转换</h4><ul>
<li><strong>单元测试</strong>: 当需要测试一个处理 <code>InputStream</code> 的方法时，无需创建临时文件，直接使用 <code>ByteArrayInputStream</code> 或 <code>StringReader</code> 传入测试数据即可。</li>
<li><strong>数据格式转换</strong>: 将一个Java对象序列化为字节数组，以便通过网络发送或存入数据库的BLOB字段。<code>ObjectOutputStream</code> 可以直接写入 <code>ByteArrayOutputStream</code> 来实现这一点。</li>
<li><strong>临时缓存</strong>: 在多步骤的数据处理流程中，可以将一个步骤的输出写入内存流，作为下一步骤的输入，避免了磁盘I&#x2F;O的开销。</li>
<li><strong>动态生成文件内容</strong>: 在Web应用中，可以动态生成一个CSV或XML文件的内容到 <code>StringWriter</code> 或 <code>ByteArrayOutputStream</code>，然后将其作为HTTP响应直接发送给客户端，而无需在服务器上创建实体文件。</li>
</ul>
<hr>
<h3 id="10-2-管道流-Piped-I-O"><a href="#10-2-管道流-Piped-I-O" class="headerlink" title="10.2 管道流 (Piped I&#x2F;O)"></a>10.2 管道流 (Piped I&#x2F;O)</h3><h4 id="10-2-1-PipedInputStream-PipedOutputStream"><a href="#10-2-1-PipedInputStream-PipedOutputStream" class="headerlink" title="10.2.1 PipedInputStream &amp; PipedOutputStream"></a>10.2.1 <code>PipedInputStream</code> &amp; <code>PipedOutputStream</code></h4><ul>
<li><strong>概念</strong>:<ul>
<li>它们必须成对使用，一个 <code>PipedOutputStream</code> (写入端) 必须连接到一个 <code>PipedInputStream</code> (读取端)。</li>
<li>一个线程通过 <code>PipedOutputStream</code> 写入数据，另一个线程通过 <code>PipedInputStream</code> 读取这些数据。</li>
<li>内部有一个缓冲区。如果写入线程写得太快，缓冲区满了，写入线程会<strong>阻塞</strong>。如果读取线程读得太快，缓冲区空了，读取线程会<strong>阻塞</strong>。这种阻塞机制天然地实现了生产者-消费者模式的同步。</li>
</ul>
</li>
<li><strong>连接方式</strong>:<ol>
<li><code>PipedInputStream pipedIn = new PipedInputStream();</code><br><code>PipedOutputStream pipedOut = new PipedOutputStream(pipedIn);</code></li>
<li><code>PipedInputStream pipedIn = new PipedInputStream();</code><br><code>PipedOutputStream pipedOut = new PipedOutputStream();</code><br><code>pipedIn.connect(pipedOut); // 或者 pipedOut.connect(pipedIn);</code></li>
</ol>
</li>
</ul>
<hr>
<h4 id="10-2-2-核心应用：线程间通信"><a href="#10-2-2-核心应用：线程间通信" class="headerlink" title="10.2.2 核心应用：线程间通信"></a>10.2.2 核心应用：线程间通信</h4><p>这是管道流最主要也是几乎唯一的应用场景。</p>
<ul>
<li><p><strong>代码示例：生产者-消费者模型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipedStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PipedInputStream</span> <span class="variable">pipedIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedInputStream</span>();</span><br><span class="line">        <span class="comment">// 建议在构造时就连接，更安全</span></span><br><span class="line">        <span class="type">PipedOutputStream</span> <span class="variable">pipedOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedOutputStream</span>(pipedIn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Message &quot;</span> + i;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Producing: &quot;</span> + message);</span><br><span class="line">                    pipedOut.write(message.getBytes());</span><br><span class="line">                    pipedOut.flush();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pipedOut.close(); <span class="comment">// 必须关闭，否则读取端会一直阻塞等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> len;</span><br><span class="line">                <span class="comment">// read()会阻塞，直到有数据或写入端关闭</span></span><br><span class="line">                <span class="keyword">while</span> ((len = pipedIn.read(buffer)) != -<span class="number">1</span>) &#123; </span><br><span class="line">                    <span class="type">String</span> <span class="variable">received</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consuming: &quot;</span> + received);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer finished.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pipedIn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="10-3-功能组合流"><a href="#10-3-功能组合流" class="headerlink" title="10.3 功能组合流"></a>10.3 功能组合流</h3><h4 id="10-3-1-SequenceInputStream-序列输入流"><a href="#10-3-1-SequenceInputStream-序列输入流" class="headerlink" title="10.3.1 SequenceInputStream (序列输入流)"></a>10.3.1 <code>SequenceInputStream</code> (序列输入流)</h4><ul>
<li><p><strong>概念</strong>:</p>
<ul>
<li><code>SequenceInputStream</code> 可以将<strong>两个或多个输入流（InputStream）逻辑上串联起来</strong>，使其表现得像一个单一的、连续的输入流。</li>
<li>当从 <code>SequenceInputStream</code> 读取时，它会先从第一个流读取，直到该流结束，然后无缝地切换到第二个流，以此类推，直到所有流都读取完毕。</li>
</ul>
</li>
<li><p><strong>核心应用：文件合并</strong></p>
<ul>
<li>当需要合并多个文件的内容进行处理，但又不想先将它们合并成一个大的物理文件时，<code>SequenceInputStream</code> 是完美的选择。例如，合并分块下载的文件，或者处理按日期分割的日志文件。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟两个文件内容</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="string">&quot;Hello, &quot;</span>.getBytes());</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="string">&quot;World!&quot;</span>.getBytes());</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="string">&quot; Welcome.&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 s1 和 s2 合并</span></span><br><span class="line"><span class="type">SequenceInputStream</span> <span class="variable">sis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequenceInputStream</span>(s1, s2);</span><br><span class="line"><span class="comment">// 再将 s3 也合并进来</span></span><br><span class="line"><span class="type">SequenceInputStream</span> <span class="variable">finalSis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequenceInputStream</span>(sis, s3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从合并后的流中读取</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> byteData;</span><br><span class="line">    <span class="keyword">while</span> ((byteData = finalSis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) byteData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出: Hello, World! Welcome.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭SequenceInputStream会自动关闭其包含的所有流</span></span><br><span class="line">    finalSis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SequenceInputStream</code> 还有一个接受 <code>Enumeration&lt;? extends InputStream&gt;</code> 的构造函数，可以合并任意数量的流。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="10-3-2-LineNumberReader-行号读取器"><a href="#10-3-2-LineNumberReader-行号读取器" class="headerlink" title="10.3.2 LineNumberReader (行号读取器)"></a>10.3.2 <code>LineNumberReader</code> (行号读取器)</h4><ul>
<li><p><strong>概念</strong>:</p>
<ul>
<li>这是一个装饰器流，继承自 <code>BufferedReader</code>，因此拥有缓冲功能。</li>
<li>它的核心特性是<strong>能够跟踪当前读取到的行号</strong>。</li>
</ul>
</li>
<li><p><strong>核心应用：文本解析与错误定位</strong></p>
<ul>
<li>在解析配置文件、源代码或其他格式化文本时非常有用。如果发现语法错误，可以立即通过 <code>getLineNumber()</code> 方法获取错误所在的行号，为用户提供精确的错误信息。</li>
</ul>
</li>
<li><p><strong>核心方法</strong>:</p>
<ul>
<li><code>int getLineNumber()</code>: 获取当前行号（从0开始计数）。</li>
<li><code>void setLineNumber(int lineNumber)</code>: 设置当前行号。</li>
<li><code>readLine()</code>: 读取一行，并使内部行号计数器加一。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;First line\nSecond line\nThird line&quot;</span>;</span><br><span class="line"><span class="type">StringReader</span> <span class="variable">stringReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(text);</span><br><span class="line"><span class="type">LineNumberReader</span> <span class="variable">lineNumberReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineNumberReader</span>(stringReader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = lineNumberReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// getLineNumber() 返回的是刚刚读完的行的行号</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Line %d: %s%n&quot;</span>, lineNumberReader.getLineNumber(), line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lineNumberReader.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出:</span></span><br><span class="line"><span class="comment"> * Line 1: First line</span></span><br><span class="line"><span class="comment"> * Line 2: Second line</span></span><br><span class="line"><span class="comment"> * Line 3: Third line</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="10-4-流的选择"><a href="#10-4-流的选择" class="headerlink" title="10.4 流的选择"></a>10.4 流的选择</h3><pre><code class="highlight mermaid">graph TD
    A[开始选择IO流] --&gt; B&#123;处理什么类型数据?&#125;;

    B -- &quot;文本/字符数据&quot; --&gt; C[&quot;选择字符流&lt;br/&gt;Reader/Writer体系&quot;];
    B -- &quot;二进制数据&quot; --&gt; D[&quot;选择字节流&lt;br/&gt;InputStream/OutputStream&quot;];

    C --&gt; E&#123;数据来源/目的地?&#125;;
    E -- &quot;文件&quot; --&gt; E1[使用FileReader/FileWriter];
    E -- &quot;内存中的字符串&quot; --&gt; E2[使用StringReader/StringWriter];
    E -- &quot;网络/其他字节流&quot; --&gt; E3[&quot;使用InputStreamReader/&lt;br/&gt;OutputStreamWriter转换&quot;];

    D --&gt; F&#123;数据来源/目的地?&#125;;
    F -- &quot;文件&quot; --&gt; F1[&quot;使用FileInputStream/&lt;br/&gt;FileOutputStream&quot;];
    F -- &quot;内存中的字节数组&quot; --&gt; F2[&quot;使用ByteArrayInputStream/&lt;br/&gt;ByteArrayOutputStream&quot;];
    F -- &quot;线程间通信&quot; --&gt; F3[&quot;使用PipedInputStream/&lt;br/&gt;PipedOutputStream&quot;];

    subgraph 基础流选择
        E1 &amp; E2 &amp; E3 &amp; F1 &amp; F2 &amp; F3
    end

    E1 --&gt; G&#123;需要额外功能?&#125;;
    E2 --&gt; G;
    E3 --&gt; G;
    F1 --&gt; G;
    F2 --&gt; G;
    F3 --&gt; G;

    G -- &quot;需要高效读取&quot; --&gt; H1[&quot;+BufferedReader/&lt;br/&gt;BufferedWriter&quot;];
    G -- &quot;需要高效读取&quot; --&gt; H2[&quot;+BufferedInputStream/&lt;br/&gt;BufferedOutputStream&quot;];
    G -- &quot;需要读取基本数据类型&quot; --&gt; H3[&quot;+DataInputStream/&lt;br/&gt;DataOutputStream&quot;];
    G -- &quot;需要序列化对象&quot; --&gt; H4[&quot;使用ObjectInputStream/&lt;br/&gt;ObjectOutputStream&quot;];
    G -- &quot;需要格式化输出&quot; --&gt; H5[&quot;使用PrintWriter/&lt;br/&gt;PrintStream&quot;];
    G -- &quot;不需要额外功能&quot; --&gt; H6[直接使用基础流];

    subgraph &quot;功能流(装饰器)选择&quot;
        H1 &amp; H2 &amp; H3 &amp; H4 &amp; H5 &amp; H6
    end

    H1 --&gt; Z[完成选择];
    H2 --&gt; Z;
    H3 --&gt; Z;
    H4 --&gt; Z;
    H5 --&gt; Z;
    H6 --&gt; Z;</code></pre>

<hr>
<h4 id="10-4-1-根据数据类型选择"><a href="#10-4-1-根据数据类型选择" class="headerlink" title="10.4.1 根据数据类型选择"></a>10.4.1 根据数据类型选择</h4><ul>
<li><strong>字节数据</strong>（如图片、音频、视频、任何二进制文件）：<ul>
<li>使用字节流：<code>InputStream</code>&#x2F;<code>OutputStream</code>体系</li>
</ul>
</li>
<li><strong>文本数据</strong>：<ul>
<li>使用字符流：<code>Reader</code>&#x2F;<code>Writer</code>体系</li>
<li>注意编码问题，特别是多语言环境</li>
</ul>
</li>
</ul>
<hr>
<h4 id="10-4-2-根据数据来源-目的地选择"><a href="#10-4-2-根据数据来源-目的地选择" class="headerlink" title="10.4.2 根据数据来源&#x2F;目的地选择"></a>10.4.2 根据数据来源&#x2F;目的地选择</h4><ul>
<li><strong>文件</strong>：<ul>
<li>字节流：<code>FileInputStream</code>&#x2F;<code>FileOutputStream</code></li>
<li>字符流：<code>FileReader</code>&#x2F;<code>FileWriter</code></li>
</ul>
</li>
<li><strong>内存操作</strong>：<ul>
<li>字节数组：<code>ByteArrayInputStream</code>&#x2F;<code>ByteArrayOutputStream</code></li>
<li>字符数组：<code>CharArrayReader</code>&#x2F;<code>CharArrayWriter</code></li>
<li>字符串：<code>StringReader</code>&#x2F;<code>StringWriter</code></li>
</ul>
</li>
<li><strong>网络通信</strong>：<ul>
<li>通常使用字节流，如Socket获取的输入输出流</li>
</ul>
</li>
<li><strong>线程间通信</strong>：<ul>
<li>使用管道流：<code>PipedInputStream</code>&#x2F;<code>PipedOutputStream</code>或<code>PipedReader</code>&#x2F;<code>PipedWriter</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="10-4-3-根据功能需求选择"><a href="#10-4-3-根据功能需求选择" class="headerlink" title="10.4.3 根据功能需求选择"></a>10.4.3 根据功能需求选择</h4><ul>
<li><strong>需要缓冲提高性能</strong>：<ul>
<li>字节缓冲流：<code>BufferedInputStream</code>&#x2F;<code>BufferedOutputStream</code></li>
<li>字符缓冲流：<code>BufferedReader</code>&#x2F;<code>BufferedWriter</code></li>
<li>特别是对于文件操作和网络操作，几乎总是应该使用缓冲流</li>
</ul>
</li>
<li><strong>需要读写基本数据类型</strong>：<ul>
<li>使用数据流：<code>DataInputStream</code>&#x2F;<code>DataOutputStream</code></li>
</ul>
</li>
<li><strong>需要序列化对象</strong>：<ul>
<li>使用对象流：<code>ObjectInputStream</code>&#x2F;<code>ObjectOutputStream</code></li>
<li>注意：被序列化的类必须实现<code>Serializable</code>接口</li>
</ul>
</li>
<li><strong>需要格式化输出</strong>：<ul>
<li>使用打印流：<code>PrintStream</code>&#x2F;<code>PrintWriter</code></li>
<li><code>PrintWriter</code>更适用于字符输出，支持更多字符编码</li>
</ul>
</li>
<li><strong>需要将多个输入流合并</strong>：<ul>
<li>使用<code>SequenceInputStream</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="10-4-4-常见使用场景和建议"><a href="#10-4-4-常见使用场景和建议" class="headerlink" title="10.4.4 常见使用场景和建议"></a>10.4.4 常见使用场景和建议</h4><h5 id="1-读取文本文件（推荐方式）："><a href="#1-读取文本文件（推荐方式）：" class="headerlink" title="1. 读取文本文件（推荐方式）："></a>1. 读取文本文件（推荐方式）：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用缓冲字符流读取文本文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>))) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理每一行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-写入文本文件（推荐方式）："><a href="#2-写入文本文件（推荐方式）：" class="headerlink" title="2. 写入文本文件（推荐方式）："></a>2. 写入文本文件（推荐方式）：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用缓冲字符流写入文本文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;file.txt&quot;</span>))) &#123;</span><br><span class="line">    writer.write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    writer.newLine(); <span class="comment">// 跨平台换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-复制二进制文件（推荐方式）："><a href="#3-复制二进制文件（推荐方式）：" class="headerlink" title="3. 复制二进制文件（推荐方式）："></a>3. 复制二进制文件（推荐方式）：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用缓冲字节流复制文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.jpg&quot;</span>));</span><br><span class="line">     <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dest.jpg&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">while</span> ((length = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-读取基本数据类型："><a href="#4-读取基本数据类型：" class="headerlink" title="4. 读取基本数据类型："></a>4. 读取基本数据类型：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数据流读取基本数据类型</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.bin&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> dis.readDouble();</span><br><span class="line">    <span class="type">String</span> <span class="variable">stringValue</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-序列化对象："><a href="#5-序列化对象：" class="headerlink" title="5. 序列化对象："></a>5. 序列化对象：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用对象流序列化和反序列化对象</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>))) &#123;</span><br><span class="line">    oos.writeObject(myObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="10-4-5-性能考虑"><a href="#10-4-5-性能考虑" class="headerlink" title="10.4.5 性能考虑"></a>10.4.5 性能考虑</h4><ol>
<li><strong>总是使用缓冲流</strong>：对于文件IO和网络IO，缓冲流可以显著提高性能</li>
<li><strong>选择合适的缓冲区大小</strong>：默认缓冲区大小通常为8KB，对于大文件可以考虑使用更大的缓冲区</li>
<li><strong>及时关闭流</strong>：使用try-with-resources语句确保流被正确关闭</li>
<li><strong>考虑使用NIO</strong>：对于高性能需求，考虑使用Java NIO的Channel和Buffer类</li>
</ol>
<hr>
<h2 id="11-NIO"><a href="#11-NIO" class="headerlink" title="11. NIO"></a>11. NIO</h2><p>Java NIO 是自 Java 1.4 引入的一套新的 I&#x2F;O API，用于替代标准的 Java I&#x2F;O API（简称 BIO&#x2F;Blocking I&#x2F;O）。它的核心目标是<strong>提供高速、面向块的 I&#x2F;O 操作</strong>，以解决传统 I&#x2F;O 在管理大量并发连接时的性能瓶颈。</p>
<h3 id="11-1-核心思想"><a href="#11-1-核心思想" class="headerlink" title="11.1 核心思想"></a>11.1 核心思想</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Java BIO (Blocking I&#x2F;O)</th>
<th align="left">Java NIO (Non-blocking I&#x2F;O)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>工作方式</strong></td>
<td align="left"><strong>流导向 (Stream Oriented)</strong></td>
<td align="left"><strong>缓冲区导向 (Buffer Oriented)</strong></td>
</tr>
<tr>
<td align="left"><strong>阻塞性</strong></td>
<td align="left"><strong>阻塞 I&#x2F;O (Blocking I&#x2F;O)</strong></td>
<td align="left"><strong>非阻塞 I&#x2F;O (Non-blocking I&#x2F;O)</strong></td>
</tr>
<tr>
<td align="left"><strong>核心组件</strong></td>
<td align="left"><code>InputStream</code>, <code>OutputStream</code></td>
<td align="left"><code>Buffer</code>, <code>Channel</code>, <code>Selector</code></td>
</tr>
<tr>
<td align="left"><strong>处理连接</strong></td>
<td align="left">一个连接一个线程 (1:1)</td>
<td align="left">一个线程处理多个连接 (1:m)</td>
</tr>
<tr>
<td align="left"><strong>编程模型</strong></td>
<td align="left">简单直观</td>
<td align="left">相对复杂，需要事件循环</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">连接数较少且固定的架构</td>
<td align="left">连接数多且连接时间短的架构，如聊天服务器、推送系统</td>
</tr>
</tbody></table>
<hr>
<h3 id="11-2-三大核心组件"><a href="#11-2-三大核心组件" class="headerlink" title="11.2 三大核心组件"></a>11.2 三大核心组件</h3><h4 id="11-2-1-Buffer-缓冲区"><a href="#11-2-1-Buffer-缓冲区" class="headerlink" title="11.2.1 Buffer (缓冲区)"></a>11.2.1 Buffer (缓冲区)</h4><h5 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h5><p><strong>作用：</strong> 一个用于存储特定基本数据类型的容器。所有数据的读写都是直接与 Buffer 交互。</p>
<p><strong>本质：</strong> 本质上是一个内存块，但提供了更丰富的 API 来操作数据。</p>
<hr>
<h5 id="2-核心属性"><a href="#2-核心属性" class="headerlink" title="2. 核心属性"></a>2. 核心属性</h5><ul>
<li><strong>capacity (容量)：</strong> 缓冲区的总大小。一旦创建，<code>capacity</code> 就固定不变。</li>
<li><strong>position (位置)：</strong> 下一个要被<strong>读取</strong>或<strong>写入</strong>的元素的索引。<code>position</code> 会随着 <code>get()</code> 或 <code>put()</code> 操作而移动。</li>
<li><strong>limit (限制)：<strong>在</strong>读模式</strong>下，<code>limit</code> 表示最多能读取到哪里（即写入的数据终点）。在<strong>写模式</strong>下，<code>limit</code> 等于 <code>capacity</code>，表示最多可以写到哪里。<code>limit</code> 之后的数据是不可读写的。</li>
<li><strong>mark (标记)：</strong> 一个备忘位置。调用 <code>mark()</code> 会将 <code>mark</code> 设置为当前的 <code>position</code>。调用 <code>reset()</code> 会将 <code>position</code> 恢复到 <code>mark</code> 的位置。</li>
<li>这四个属性之间永远遵循这个不变式： <strong><code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></strong></li>
</ul>
<hr>
<h5 id="3-常用方法-2"><a href="#3-常用方法-2" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h5><p><strong>核心属性相关方法</strong></p>
<ul>
<li><strong><code>capacity()</code></strong>: 返回缓冲区的容量（总大小）。创建后不可改变。</li>
<li><strong><code>position()</code></strong>: 返回当前的指针位置（下一个要读&#x2F;写的索引）。</li>
<li><strong><code>limit()</code></strong>: 返回界限。</li>
<li><strong><code>remaining()</code></strong>: 返回 <code>limit - position</code>，即当前还有多少个元素可以读或写。</li>
<li><strong><code>hasRemaining()</code></strong>: 返回 boolean，判断是否还有剩余元素。</li>
</ul>
<p><strong>读写数据方法</strong></p>
<ul>
<li><strong><code>put(byte b)</code> &#x2F; <code>put(type t)</code></strong>: 相对写。向当前 <code>position</code> 写入数据，并将 <code>position + 1</code>。</li>
<li><strong><code>put(int index, byte b)</code></strong>: 绝对写。向指定索引 <code>index</code> 写入数据，<strong>不改变</strong> <code>position</code>。</li>
<li><strong><code>get()</code></strong>: 相对读。读取当前 <code>position</code> 的数据，并将 <code>position + 1</code>。</li>
<li><strong><code>get(int index)</code></strong>: 绝对读。读取指定索引 <code>index</code> 的数据，<strong>不改变</strong> <code>position</code>。</li>
</ul>
<p>**模式切换与重置方法 **</p>
<ul>
<li><strong><code>flip()</code></strong>: <strong>翻转&#x2F;切换到读模式</strong>。这是从<strong>写模式切换到读模式</strong>的关键方法。它会执行以下操作：<ol>
<li><code>limit = position;</code> &#x2F;&#x2F; 将 <code>limit</code> 设置为当前 <code>position</code>，界定了可读数据的范围。</li>
<li><code>position = 0;</code> &#x2F;&#x2F; 将 <code>position</code> 重置为0，准备从头开始读取。</li>
<li><code>mark = -1;</code> &#x2F;&#x2F; 丢弃标记。</li>
</ol>
</li>
<li><strong><code>clear()</code></strong>: <strong>清空&#x2F;切换到写模式</strong>。这个方法并<strong>不会真正清除Buffer中的数据</strong>，它只是重置指针，准备让Buffer被重新写入。它执行以下操作：<ol>
<li><code>position = 0;</code> &#x2F;&#x2F; <code>position</code> 回到起点。</li>
<li><code>limit = capacity;</code> &#x2F;&#x2F; <code>limit</code> 回到最大容量，允许从头写满整个Buffer。</li>
<li><code>mark = -1;</code> &#x2F;&#x2F; 丢弃标记。</li>
</ol>
</li>
<li><strong><code>rewind()</code></strong>：重读。<code>position</code> 归 0，<code>limit</code> 不变。可以重新读取数据。</li>
<li><strong><code>compact()</code></strong>：压缩缓冲区。将未读的数据复制到缓冲区起始处，然后设置 <code>position</code> 到未读数据的下一个位置，<code>limit</code> 为 <code>capacity</code>。为<strong>继续写入</strong>做准备。</li>
</ul>
<p><strong>标记与跳转方法</strong></p>
<ul>
<li><strong><code>mark()</code></strong>: 在当前的 <code>position</code> 打一个标记（Mark）。</li>
<li><strong><code>reset()</code></strong>: 将 <code>position</code> 恢复到之前 <code>mark()</code> 的位置。<ul>
<li><em>注意</em>：如果未定义 mark 就调用 reset 会抛出异常。</li>
</ul>
</li>
</ul>
<p><strong>缓冲区创建方法 (静态方法)</strong></p>
<p>以<code>ByteBuffer</code>为例</p>
<ul>
<li><strong><code>allocate(int capacity)</code></strong>: 分配 JVM 堆内存（Heap Memory）。读写速度稍慢，但在 GC 管辖范围内。</li>
<li><strong><code>allocateDirect(int capacity)</code></strong>: 分配直接内存（Direct Memory &#x2F; 非堆内存）。读写速度快（少一次内核态到用户态的拷贝），但分配和销毁开销大，适合长寿命的大缓冲区。</li>
<li><strong><code>wrap(byte[] array)</code></strong>: 将现有的 Java 数组包装成 Buffer。</li>
</ul>
<hr>
<h5 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h5><p><strong>常见类型：</strong> <code>ByteBuffer</code>, <code>CharBuffer</code>, <code>IntBuffer</code> 等，其中最常用的是 <code>ByteBuffer</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 分配一个容量为 10 的缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化: &quot;</span> + printBuffer(buffer));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 写入数据 (Put)</span></span><br><span class="line">        buffer.put((<span class="type">byte</span>) <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        buffer.put((<span class="type">byte</span>) <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">        buffer.put((<span class="type">byte</span>) <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">        buffer.put((<span class="type">byte</span>) <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">        buffer.put((<span class="type">byte</span>) <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;写入后: &quot;</span> + printBuffer(buffer)); </span><br><span class="line">        <span class="comment">// 此时 position=5, limit=10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 切换到读模式 (Flip)</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="string">&quot;Flip后: &quot;</span> + printBuffer(buffer));</span><br><span class="line">        <span class="comment">// 此时 position=0, limit=5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 读取数据 (Get)</span></span><br><span class="line">        <span class="type">byte</span>[] target = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        buffer.get(target); <span class="comment">// 读取前两个字节 &#x27;H&#x27;, &#x27;e&#x27;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;读取两个字节: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(target));</span><br><span class="line">        System.out.println(<span class="string">&quot;读取后: &quot;</span> + printBuffer(buffer));</span><br><span class="line">        <span class="comment">// 此时 position=2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 标记 (Mark)</span></span><br><span class="line">        buffer.mark(); <span class="comment">// 在索引 2 处标记</span></span><br><span class="line">        buffer.get();  <span class="comment">// 读 &#x27;l&#x27;, position 变 3</span></span><br><span class="line">        buffer.get();  <span class="comment">// 读 &#x27;l&#x27;, position 变 4</span></span><br><span class="line">        buffer.reset(); <span class="comment">// 回到 mark 处 (索引 2)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Reset后: &quot;</span> + printBuffer(buffer));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 压缩 (Compact) - 假设只处理了部分数据，想继续写</span></span><br><span class="line">        <span class="comment">// 当前 position=2, limit=5。剩余 &quot;llo&quot; (3个字节) 未处理。</span></span><br><span class="line">        buffer.compact();</span><br><span class="line">        System.out.println(<span class="string">&quot;Compact后: &quot;</span> + printBuffer(buffer));</span><br><span class="line">        <span class="comment">// &quot;llo&quot; 被移到了开头 0,1,2 的位置。position 变为 3，准备接收新数据。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 继续写入</span></span><br><span class="line">        buffer.put((<span class="type">byte</span>) <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;再写入!: &quot;</span> + printBuffer(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">printBuffer</span><span class="params">(ByteBuffer buffer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pos: &quot;</span> + buffer.position() + </span><br><span class="line">               <span class="string">&quot;, Lim: &quot;</span> + buffer.limit() + </span><br><span class="line">               <span class="string">&quot;, Cap: &quot;</span> + buffer.capacity();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="11-2-2-Channel-通道"><a href="#11-2-2-Channel-通道" class="headerlink" title="11.2.2 Channel (通道)"></a>11.2.2 Channel (通道)</h4><h5 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1. 介绍"></a>1. 介绍</h5><p><strong>作用：</strong> 代表了与一个能够执行I&#x2F;O操作的实体（如文件、套接字）之间的<strong>开放连接</strong>。它是数据传输的<strong>载体</strong>。与单向的Stream不同，Channel通常是<strong>双向的</strong>，可以同时进行读写操作。</p>
<p><strong>主要实现：</strong></p>
<ul>
<li><code>FileChannel</code>：用于文件读写。</li>
<li><code>DatagramChannel</code>：用于 UDP 通信。</li>
<li><code>SocketChannel</code>：用于 TCP 客户端。</li>
<li><code>ServerSocketChannel</code>：用于TCP网络服务器端，可以接受新的连接并为每个连接创建一个 <code>SocketChannel</code>。</li>
</ul>
<p><strong>重要特性：</strong></p>
<ul>
<li><strong>可以异步地读写</strong>。</li>
<li><strong>与Buffer交互</strong>: Channel的所有数据传输都通过Buffer进行。<code>read()</code> 方法将数据从Channel读入Buffer，<code>write()</code> 方法将数据从Buffer写入Channel。</li>
<li><strong>双向性</strong>: 大多数Channel实现（如 <code>SocketChannel</code>）既可以读也可以写，而Stream是严格单向的（<code>InputStream</code> 只能读，<code>OutputStream</code> 只能写）。</li>
<li><strong>可配置为非阻塞模式</strong>: 这是NIO与BIO最根本的区别。可以将Channel设置为非阻塞模式，在这种模式下，一个I&#x2F;O操作（如<code>read()</code>）会立即返回，无论是否真的读到了数据。</li>
<li><strong>支持“分散(Scatter)”和“聚集(Gather)”</strong>：<ul>
<li><strong>Scatter:</strong> 从一个 Channel 读取数据到多个 Buffer 中。</li>
<li><strong>Gather:</strong> 将多个 Buffer 的数据写入到一个 Channel 中。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-获取Channel"><a href="#2-获取Channel" class="headerlink" title="2. 获取Channel"></a>2. 获取Channel</h5><h6 id="a-从传统-IO-流获取"><a href="#a-从传统-IO-流获取" class="headerlink" title="a. 从传统 IO 流获取"></a>a. 从传统 IO 流获取</h6><p>这是最常见的方式，特别是在维护老代码或进行简单文件操作时。<code>java.io</code> 包中的核心类都添加了 <code>getChannel()</code> 方法。</p>
<ul>
<li><strong>FileInputStream</strong>: 获取只读通道。</li>
<li><strong>FileOutputStream</strong>: 获取只写通道。</li>
<li><strong>RandomAccessFile</strong>: 获取可读可写通道（最灵活）。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetFileChannel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 从 FileInputStream 获取 (只读)</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">readChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从 FileOutputStream 获取 (只写)</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">writeChannel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 从 RandomAccessFile 获取 (可读可写)</span></span><br><span class="line">        <span class="comment">// &quot;rw&quot; 代表读写模式</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">rwChannel</span> <span class="operator">=</span> raf.getChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意：关闭流也会自动关闭对应的 Channel</span></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">        raf.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="b-使用静态-open-方法"><a href="#b-使用静态-open-方法" class="headerlink" title="b. 使用静态 open() 方法"></a>b. 使用静态 <code>open()</code> 方法</h6><p>对于网络编程（Socket）以及 Java 7 引入的增强文件操作，我们使用各个 Channel 类自带的静态工厂方法 <code>open()</code>。</p>
<p>使用 <code>FileChannel.open()</code> 可以更精细地控制文件的打开模式（如追加、创建不存在的文件等），这是相比 <code>getChannel()</code> 的优势。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardOpenOption;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种方式不需要先创建 FileInputStream/OutputStream</span></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> FileChannel.open(</span><br><span class="line">    Paths.get(<span class="string">&quot;example.txt&quot;</span>), </span><br><span class="line">    StandardOpenOption.READ,  <span class="comment">// 读模式</span></span><br><span class="line">    StandardOpenOption.WRITE, <span class="comment">// 写模式</span></span><br><span class="line">    StandardOpenOption.CREATE <span class="comment">// 如果文件不存在则创建</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>网络通道没有对应的流可以调用 <code>getChannel</code>（虽然 Socket 类有这个方法，但只有通过 Channel 创建的 Socket 才能返回 Channel，否则返回 null），所以<strong>必须</strong>使用 <code>open()</code>。</p>
<ul>
<li><strong>SocketChannel</strong>: TCP 客户端</li>
<li><strong>ServerSocketChannel</strong>: TCP 服务端</li>
<li><strong>DatagramChannel</strong>: UDP</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetSocketChannel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 获取 TCP 客户端通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        <span class="comment">// socketChannel.configureBlocking(false); // 设置非阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取 TCP 服务端通道</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 获取 UDP 通道</span></span><br><span class="line">        <span class="type">DatagramChannel</span> <span class="variable">datagramChannel</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line">        datagramChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="c-使用工具类-Files"><a href="#c-使用工具类-Files" class="headerlink" title="c. 使用工具类 Files"></a>c. 使用工具类 <code>Files</code></h6><p>Java 7 引入了 <code>java.nio.file.Files</code> 工具类，它是一个极其强大的文件操作入口，也可以用来获取 Channel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.channels.SeekableByteChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardOpenOption;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个字节通道（SeekableByteChannel 是 FileChannel 的父接口）</span></span><br><span class="line"><span class="type">SeekableByteChannel</span> <span class="variable">sbc</span> <span class="operator">=</span> Files.newByteChannel(</span><br><span class="line">    Paths.get(<span class="string">&quot;test.txt&quot;</span>), </span><br><span class="line">    StandardOpenOption.READ, </span><br><span class="line">    StandardOpenOption.WRITE</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 注意：如果需要使用 FileChannel 特有的 map() 或 transferTo() 方法，</span></span><br><span class="line"><span class="comment">// 最好还是用 FileChannel.open() 或强制转换（如果底层确实是 FileChannel）</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-核心方法"><a href="#3-核心方法" class="headerlink" title="3. 核心方法"></a>3. 核心方法</h5><h6 id="a-通用基础方法"><a href="#a-通用基础方法" class="headerlink" title="a. 通用基础方法"></a><strong>a. 通用基础方法</strong></h6><ul>
<li><strong><code>close()</code></strong><ul>
<li><strong>作用</strong>：关闭通道。</li>
<li><strong>注意</strong>：通道关闭后，任何尝试再次读写的操作都会抛出 <code>ClosedChannelException</code>。关闭是释放底层操作系统资源的关键。</li>
</ul>
</li>
<li><strong><code>isOpen()</code></strong><ul>
<li><strong>作用</strong>：判断通道是否处于打开状态。</li>
<li><strong>返回</strong>：<code>true</code> 表示打开，<code>false</code> 表示关闭。</li>
</ul>
</li>
</ul>
<h6 id="b-数据读写核心方法"><a href="#b-数据读写核心方法" class="headerlink" title="b. 数据读写核心方法"></a><strong>b. 数据读写核心方法</strong></h6><p>主要定义在 <code>ReadableByteChannel</code> 和 <code>WritableByteChannel</code> 接口中。</p>
<p><strong>切记：数据总是从通道读入缓冲区，或者从缓冲区写入通道。</strong></p>
<ul>
<li><strong><code>int read(ByteBuffer dst)</code></strong><ul>
<li><strong>作用</strong>：从通道读取数据<strong>放入</strong>缓冲区 (<code>dst</code>)。</li>
<li><strong>返回值</strong>：<ul>
<li>正整数：实际读取到的字节数。</li>
<li><code>0</code>：没有读到数据（通常在非阻塞模式下出现）。</li>
<li><code>-1</code>：读到了流的末尾 (EOF)。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>int write(ByteBuffer src)</code></strong><ul>
<li><strong>作用</strong>：将缓冲区 (<code>src</code>) 中的数据<strong>写入</strong>到通道中。</li>
<li><strong>返回值</strong>：实际写入的字节数。</li>
<li><strong>注意</strong>：在非阻塞模式下，可能无法一次性写入 Buffer 中的所有数据，需要循环调用。</li>
</ul>
</li>
<li><strong><code>long read(ByteBuffer[] dsts)</code> &#x2F; <code>long write(ByteBuffer[] srcs)</code></strong> (Scatter&#x2F;Gather)<ul>
<li><strong>作用</strong>：<strong>分散读取 (Scatter)</strong> 和 <strong>聚集写入 (Gather)</strong>。</li>
<li><strong>场景</strong>：非常适合处理协议数据，例如将消息头写入第一个 Buffer，消息体写入第二个 Buffer，然后一次性写入通道。</li>
</ul>
</li>
</ul>
<h6 id="c-FileChannel-特有方法"><a href="#c-FileChannel-特有方法" class="headerlink" title="c. FileChannel 特有方法"></a><strong>c. FileChannel 特有方法</strong></h6><p><code>FileChannel</code> 不能设置为非阻塞模式，但它提供了极高效率的文件操作方法。</p>
<ul>
<li><strong><code>transferTo(long position, long count, WritableByteChannel target)</code></strong><ul>
<li><strong>作用</strong>：将数据从当前文件通道直接传输到另一个通道。</li>
<li><strong>核心优势</strong>：<strong>零拷贝 (Zero-Copy)</strong>。数据直接在操作系统内核空间传递，不需要拷贝到 JVM 内存，性能极高（常用于构建高性能 Web 服务器，如发送静态文件）。</li>
</ul>
</li>
<li><strong><code>transferFrom(ReadableByteChannel src, long position, long count)</code></strong><ul>
<li><strong>作用</strong>：将数据从源通道直接传输到当前文件通道。同样也是零拷贝技术。</li>
</ul>
</li>
<li><strong><code>MappedByteBuffer map(MapMode mode, long position, long size)</code></strong><ul>
<li><strong>作用</strong>：<strong>内存映射文件 (Memory Mapped File)</strong>。将文件（或部分）直接映射到虚拟内存中。</li>
<li><strong>优势</strong>：对于大文件的读写，比标准的 <code>read/write</code> 快很多。</li>
</ul>
</li>
<li><strong><code>force(boolean metaData)</code></strong><ul>
<li><strong>作用</strong>：强制将通道中未写入磁盘的数据刷入磁盘。</li>
<li><strong>场景</strong>：类似于 <code>fsync</code>，用于确保数据持久化，防止系统崩溃导致数据丢失。</li>
</ul>
</li>
<li><strong><code>position(long newPosition)</code> &#x2F; <code>long position()</code></strong><ul>
<li><strong>作用</strong>：获取或设置当前文件的读写位置（实现文件的随机读写）。</li>
</ul>
</li>
</ul>
<h6 id="d-Socket-通道特有方法"><a href="#d-Socket-通道特有方法" class="headerlink" title="d. Socket 通道特有方法"></a><strong>d. Socket 通道特有方法</strong></h6><p>包括 <code>SocketChannel</code> (TCP客户端), <code>ServerSocketChannel</code> (TCP服务端), <code>DatagramChannel</code> (UDP)。</p>
<ul>
<li><strong><code>configureBlocking(boolean block)</code></strong><ul>
<li><strong>作用</strong>：设置阻塞模式。</li>
<li><strong>关键点</strong>：<strong><code>false</code> 表示非阻塞模式</strong>。这是 NIO 的核心。在非阻塞模式下，<code>read</code> 如果没数据会立刻返回 0，而不是卡住线程。</li>
</ul>
</li>
<li><strong><code>register(Selector sel, int ops)</code></strong><ul>
<li><strong>作用</strong>：将通道注册到 <strong>Selector (选择器)</strong> 上。</li>
<li><strong>参数</strong>：<ul>
<li><code>sel</code>：选择器实例。</li>
<li><code>ops</code>：关注的事件（如 <code>SelectionKey.OP_READ</code>, <code>OP_ACCEPT</code>, <code>OP_CONNECT</code>, <code>OP_WRITE</code>）。</li>
</ul>
</li>
<li><strong>场景</strong>：实现多路复用（一个线程管理成千上万个连接）。</li>
</ul>
</li>
<li><strong><code>finishConnect()</code> (仅 SocketChannel)</strong><ul>
<li><strong>作用</strong>：在非阻塞模式下，<code>connect()</code> 方法可能在连接建立前就返回了。需要调用此方法来确认连接最终是否建立成功。</li>
</ul>
</li>
<li><strong><code>accept()</code> (仅 ServerSocketChannel)</strong><ul>
<li><strong>作用</strong>：监听新进来的连接。</li>
<li><strong>注意</strong>：在非阻塞模式下，如果没有新连接，该方法会立刻返回 <code>null</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-代码示例-1"><a href="#4-代码示例-1" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 1. 获取 Channel (通过 FileInputStream/FileOutputStream)</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>).getChannel();</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">destChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>).getChannel()</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// --- 方法 A: 使用 Buffer 传统读写 ---</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                buffer.clear(); <span class="comment">// 清空缓冲区，准备写入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> sourceChannel.read(buffer); <span class="comment">// 核心方法 read</span></span><br><span class="line">                <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                buffer.flip(); <span class="comment">// 切换模式：准备从 Buffer 读取数据写入通道</span></span><br><span class="line">                destChannel.write(buffer); <span class="comment">// 核心方法 write</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// --- 方法 B: 使用 transferTo (零拷贝，更高效，推荐) ---</span></span><br><span class="line">            <span class="comment">// 重置位置以便演示</span></span><br><span class="line">            sourceChannel.position(<span class="number">0</span>); </span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> sourceChannel.size();</span><br><span class="line">            <span class="comment">// 直接将 sourceChannel 的数据传输到 destChannel</span></span><br><span class="line">            sourceChannel.transferTo(<span class="number">0</span>, size, destChannel);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;文件复制完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="11-2-3-Selector-选择器"><a href="#11-2-3-Selector-选择器" class="headerlink" title="11.2.3 Selector (选择器)"></a>11.2.3 Selector (选择器)</h4><p><strong>作用：<strong>Selector 是NIO实现</strong>I&#x2F;O多路复用</strong>的核心。它允许<strong>单个线程监视多个Channel</strong>的状态（例如：是否可读、是否可写、是否已连接等）。这使得一个线程可以管理成百上千个网络连接，极大地减少了线程数量和上下文切换的开销。</p>
<p><strong>核心概念：</strong></p>
<ul>
<li><strong>事件 (SelectionKey)：</strong> <code>SelectionKey.OP_ACCEPT</code> (连接接受), <code>OP_CONNECT</code> (连接建立), <code>OP_READ</code> (读就绪), <code>OP_WRITE</code> (写就绪)。</li>
<li><strong>注册 (Register)：</strong> 将 Channel 注册到 Selector 上，并指定感兴趣的事件。</li>
<li><strong>选择 (Select)：</strong> Selector 会阻塞，直到有一个或多个注册的 Channel 上有你感兴趣的事件就绪。</li>
<li><strong>选择键集合 (Selected Keys)：</strong> 当 <code>select()</code> 方法返回后，可以通过 <code>selectedKeys()</code> 方法获取所有就绪的事件集合，然后进行迭代处理。</li>
</ul>
<p><strong>工作流程：</strong></p>
<ol>
<li><p><strong>创建Selector</strong>: <code>Selector selector = Selector.open();</code></p>
</li>
<li><p><strong>注册Channel</strong>: 将需要监视的Channel注册到Selector上，并指定你<strong>感兴趣的事件</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Channel必须是非阻塞的</span></span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>); </span><br><span class="line"><span class="comment">// 2. 注册并指定感兴趣的事件 (e.g., OP_READ)</span></span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>轮询就绪事件</strong>: 在一个循环中，调用 <code>selector.select()</code>。这个方法会<strong>阻塞</strong>，直到至少有一个注册的Channel上发生了你感兴趣的事件。</p>
</li>
<li><p><strong>处理就绪Channel</strong>: <code>select()</code> 方法返回后，通过 <code>selector.selectedKeys()</code> 获取所有就绪事件的 <code>SelectionKey</code> 集合。</p>
</li>
<li><p><strong>遍历并处理</strong>: 遍历 <code>SelectionKey</code> 集合，根据事件类型进行相应的处理（例如，如果是 <code>OP_ACCEPT</code>，就接受新连接；如果是 <code>OP_READ</code>，就从Channel读取数据）。</p>
</li>
<li><p><strong>移除Key</strong>: <strong>非常重要的一步！</strong> 处理完一个 <code>SelectionKey</code> 后，必须手动从 <code>selectedKeys</code> 集合中将其<strong>移除 (<code>iterator.remove()</code>)</strong>，否则Selector下次还会报告这个已处理的事件。</p>
</li>
</ol>
<p><strong>示例：一个简单的 NIO Server 骨架</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioServerSkeleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 打开 ServerSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 绑定端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 【关键】设置为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 打开 Selector (多路复用器)</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将 Server 注册到 Selector 上，并关注 &quot;OP_ACCEPT&quot; (有新连接进来的事件)</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;NIO Server 启动成功，监听端口: 8080...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 进入事件循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待，直到至少有一个通道发生了注册的事件</span></span><br><span class="line">            <span class="comment">// 返回值是就绪通道的数量</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 获取所有已就绪的事件集合 (SelectionKey 集合)</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 【非常重要】必须手动从集合中移除当前 key，否则下次循环会被重复处理</span></span><br><span class="line">                iterator.remove();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 8. 根据事件类型分发处理</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        handleAccept(key, selector);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        handleRead(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 这里还可以处理 isWritable() 等其他事件</span></span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// 发生异常（如客户端强制断开），需要取消 key 并关闭通道</span></span><br><span class="line">                    key.cancel();</span><br><span class="line">                    <span class="keyword">if</span> (key.channel() != <span class="literal">null</span>) &#123;</span><br><span class="line">                        key.channel().close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理新连接接入事件 (OP_ACCEPT)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleAccept</span><span class="params">(SelectionKey key, Selector selector)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取 ServerSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接受客户端连接</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【关键】客户端通道也必须设置为非阻塞</span></span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将客户端通道注册到 Selector，关注 &quot;OP_READ&quot; (读就绪事件)</span></span><br><span class="line">        clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;新客户端接入: &quot;</span> + clientChannel.getRemoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理数据读取事件 (OP_READ)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取对应的 SocketChannel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分配缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从通道读取数据到缓冲区</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> clientChannel.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 读到了数据</span></span><br><span class="line">            buffer.flip(); <span class="comment">// 切换为读模式</span></span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">            buffer.get(data);</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data).trim();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到消息: &quot;</span> + content);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// (可选) 写回数据 echo</span></span><br><span class="line">            <span class="comment">// clientChannel.write(ByteBuffer.wrap((&quot;Server received: &quot; + content).getBytes()));</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 客户端正常关闭了连接 (读到了 EOF)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端断开连接: &quot;</span> + clientChannel.getRemoteAddress());</span><br><span class="line">            clientChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="11-3-Path-Files"><a href="#11-3-Path-Files" class="headerlink" title="11.3 Path &amp; Files"></a>11.3 Path &amp; Files</h3><h4 id="11-3-1-Path"><a href="#11-3-1-Path" class="headerlink" title="11.3.1 Path"></a>11.3.1 Path</h4><p><code>Path</code> 接口是 <code>java.nio.file</code> 包的核心接口之一，表示的是<strong>文件系统中的路径</strong>（只是一个字符串的抽象表示），<strong>不代表</strong>文件本身（文件内容操作要用 <code>Files</code> 类）。这个路径可以指向一个文件、一个目录，甚至可以不存在。是 <code>java.io.File</code> 类的现代化替代品。</p>
<h5 id="1-创建方式"><a href="#1-创建方式" class="headerlink" title="1. 创建方式"></a>1. 创建方式</h5><h6 id="a-Path-of-推荐-Java-11"><a href="#a-Path-of-推荐-Java-11" class="headerlink" title="a. Path.of(...) (推荐 - Java 11+)"></a>a. <code>Path.of(...)</code> (推荐 - Java 11+)</h6><p>这是从 <strong>Java 11</strong> 开始引入的新方法，也是<strong>目前最推荐</strong>的方式。它定义在 <code>Path</code> 接口本身，不需要额外导入 <code>Paths</code> 工具类，代码更简洁。</p>
<ul>
<li><strong>特点</strong>：支持多参数自动拼接，自动处理不同系统的路径分隔符。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 单个路径字符串</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">p1</span> <span class="operator">=</span> Path.of(<span class="string">&quot;D:/data/logs/app.log&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 多个字符串自动拼接 (强烈推荐，跨平台更安全)</span></span><br><span class="line"><span class="comment">// 相当于 &quot;D:&quot; + File.separator + &quot;data&quot; + ...</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">p2</span> <span class="operator">=</span> Path.of(<span class="string">&quot;D:&quot;</span>, <span class="string">&quot;data&quot;</span>, <span class="string">&quot;logs&quot;</span>, <span class="string">&quot;app.log&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 从 URI 创建</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">p3</span> <span class="operator">=</span> Path.of(URI.create(<span class="string">&quot;file:///D:/data/test.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h6 id="b-Paths-get-经典-Java-7-10"><a href="#b-Paths-get-经典-Java-7-10" class="headerlink" title="b. Paths.get(...) (经典 - Java 7 ~ 10)"></a>b. <code>Paths.get(...)</code> (经典 - Java 7 ~ 10)</h6><p><code>Paths</code> 类是一个非常简单的工具类，它只包含静态方法，其核心作用就是用来获取 <code>Path</code> 接口的实例。</p>
<p>在 Java 11 之前（Java 7 引入 NIO.2 时），这是创建 Path 的标准方式。</p>
<ul>
<li><strong>特点</strong>：底层逻辑和 <code>Path.of</code> 完全一样（事实上 Java 11 后 <code>Paths.get</code> 内部直接调用了 <code>Path.of</code>）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法完全同上</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">p1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/usr/local/bin&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">p2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/usr&quot;</span>, <span class="string">&quot;local&quot;</span>, <span class="string">&quot;bin&quot;</span>); <span class="comment">// 自动拼接</span></span><br></pre></td></tr></table></figure>

<h6 id="c-File-toPath-兼容旧代码"><a href="#c-File-toPath-兼容旧代码" class="headerlink" title="c. File.toPath() (兼容旧代码)"></a>c. <code>File.toPath()</code> (兼容旧代码)</h6><p>用于将旧版的 <code>java.io.File</code> 对象转换为新版的 <code>Path</code> 对象。这在维护老项目或需要与旧 API 交互时非常有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;old_style.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换核心方法</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> file.toPath(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向转换 (Path -&gt; File)</span></span><br><span class="line"><span class="type">File</span> <span class="variable">backToFile</span> <span class="operator">=</span> path.toFile();</span><br></pre></td></tr></table></figure>

<h6 id="d-FileSystems-getDefault-getPath-底层方式"><a href="#d-FileSystems-getDefault-getPath-底层方式" class="headerlink" title="d. FileSystems.getDefault().getPath(...) (底层方式)"></a>d. <code>FileSystems.getDefault().getPath(...)</code> (底层方式)</h6><p>这是 <code>Paths.get()</code> 的底层实现原理。通常我们不直接写这么长的代码，但在<strong>非默认文件系统</strong>（比如读取 Zip 文件内部路径）时，这种模式是必须的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.FileSystems;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取默认文件系统的路径 (和 Paths.get 一样)</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">p1</span> <span class="operator">=</span> FileSystems.getDefault().getPath(<span class="string">&quot;/home/user&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【高级场景】从 Zip 文件系统中获取 Path</span></span><br><span class="line"><span class="comment">// 假设已经创建了一个 zipFileSystem</span></span><br><span class="line"><span class="comment">// Path inZip = zipFileSystem.getPath(&quot;/doc/readme.txt&quot;);</span></span><br></pre></td></tr></table></figure>

<h6 id="e-通过-URI-创建"><a href="#e-通过-URI-创建" class="headerlink" title="e. 通过 URI 创建"></a>e. 通过 URI 创建</h6><p>适用于处理带有协议头的路径（如 <code>file:///</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> URI.create(<span class="string">&quot;file:///Users/admin/demo.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 A (Java 11+)</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">p1</span> <span class="operator">=</span> Path.of(uri);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 B (Java 7+)</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">p2</span> <span class="operator">=</span> Paths.get(uri);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-Path-接口的常用方法"><a href="#2-Path-接口的常用方法" class="headerlink" title="2. Path 接口的常用方法"></a>2. Path 接口的常用方法</h5><h6 id="a-获取路径信息"><a href="#a-获取路径信息" class="headerlink" title="a. 获取路径信息"></a>a. 获取路径信息</h6><p>用于拆解路径字符串，获取文件名、父目录等。</p>
<ul>
<li><strong><code>getFileName()</code></strong><ul>
<li>获取路径中的最后一部分（文件名或最后一级目录名）。</li>
</ul>
</li>
<li><strong><code>getParent()</code></strong><ul>
<li>获取父路径。如果已经是根目录，返回 <code>null</code>。</li>
</ul>
</li>
<li><strong><code>getRoot()</code></strong><ul>
<li>获取根路径（如 Windows 的 <code>C:\</code> 或 Linux 的 <code>/</code>）。</li>
</ul>
</li>
<li><strong><code>getNameCount()</code></strong><ul>
<li>获取路径中元素的数量（不包含根节点）。</li>
</ul>
</li>
<li><strong><code>getName(int index)</code></strong><ul>
<li>获取路径中指定索引位置的名称元素（从 0 开始）。</li>
</ul>
</li>
</ul>
<h6 id="b-路径操作与转换"><a href="#b-路径操作与转换" class="headerlink" title="b. 路径操作与转换"></a>b. 路径操作与转换</h6><p>用于处理相对路径、绝对路径和路径拼接。</p>
<ul>
<li>**<code>resolve(String/Path other)</code> **<ul>
<li><strong>作用</strong>：<strong>路径拼接</strong>。相当于 <code>parent + &quot;/&quot; + child</code>。</li>
<li><em>例子</em>：<code>Path p1 = Path.of(&quot;/opt&quot;); p1.resolve(&quot;conf/app.yml&quot;)</code> -&gt; <code>/opt/conf/app.yml</code>。</li>
</ul>
</li>
<li><strong><code>resolveSibling(String/Path other)</code></strong><ul>
<li><strong>作用</strong>：<strong>兄弟节点替换</strong>。基于当前路径的父目录，替换最后的文件名。</li>
<li><em>例子</em>：<code>/a/b/test.txt</code> resolveSibling <code>dev.txt</code> -&gt; <code>/a/b/dev.txt</code>。</li>
</ul>
</li>
<li><strong><code>relativize(Path other)</code></strong><ul>
<li><strong>作用</strong>：<strong>计算相对路径</strong>。计算“从当前路径怎么走才能到目标路径”。</li>
<li><em>例子</em>：从 <code>/a/b</code> 到 <code>/a/c</code>，结果是 <code>../c</code>。</li>
</ul>
</li>
<li><strong><code>normalize()</code></strong><ul>
<li><strong>作用</strong>：<strong>路径标准化</strong>。去除路径中的冗余部分（如 <code>.</code> 和 <code>..</code>）。</li>
<li><em>例子</em>：<code>/home/./user/../docs</code> -&gt; <code>/home/docs</code>。</li>
</ul>
</li>
<li><strong><code>toAbsolutePath()</code></strong><ul>
<li><strong>作用</strong>：转为绝对路径。如果当前是相对路径，会拼接上项目运行的工作目录。</li>
</ul>
</li>
</ul>
<h6 id="c-兼容性与检测"><a href="#c-兼容性与检测" class="headerlink" title="c. 兼容性与检测"></a>c. 兼容性与检测</h6><ul>
<li><strong><code>toFile()</code></strong><ul>
<li><strong>作用</strong>：将 NIO 的 <code>Path</code> 转回旧版的 <code>java.io.File</code> 对象。这在兼容老代码时非常有用。</li>
</ul>
</li>
<li><strong><code>toString()</code></strong><ul>
<li><strong>作用</strong>：返回路径的字符串表示。</li>
</ul>
</li>
<li><strong><code>startsWith(String/Path)</code> &#x2F; <code>endsWith(String/Path)</code></strong><ul>
<li><strong>作用</strong>：判断路径是否以某段路径开始或结束。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 Path (Java 11+ 推荐 Path.of，旧版本用 Paths.get)</span></span><br><span class="line">        <span class="comment">// 假设是一个包含冗余符号的相对路径</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Path.of(<span class="string">&quot;buffers/./../nio/data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原始路径: &quot;</span> + path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 信息获取 ---</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件名: &quot;</span> + path.getFileName()); <span class="comment">// data.txt</span></span><br><span class="line">        System.out.println(<span class="string">&quot;父路径: &quot;</span> + path.getParent());   <span class="comment">// buffers/./../nio</span></span><br><span class="line">        System.out.println(<span class="string">&quot;层级数: &quot;</span> + path.getNameCount()); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 路径操作 ---</span></span><br><span class="line">        <span class="comment">// 标准化 (去除 . 和 ..)</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">normalized</span> <span class="operator">=</span> path.normalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;标准化后: &quot;</span> + normalized); <span class="comment">// nio/data.txt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转绝对路径</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">absPath</span> <span class="operator">=</span> normalized.toAbsolutePath();</span><br><span class="line">        System.out.println(<span class="string">&quot;绝对路径: &quot;</span> + absPath); <span class="comment">// D:\Projects\Demo\nio\data.txt (视系统而定)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 路径拼接 (Resolve) ---</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">basePath</span> <span class="operator">=</span> Path.of(<span class="string">&quot;/usr/local&quot;</span>);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">configPath</span> <span class="operator">=</span> basePath.resolve(<span class="string">&quot;conf/settings.xml&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;拼接路径: &quot;</span> + configPath); <span class="comment">// /usr/local/conf/settings.xml</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 相对路径计算 (Relativize) ---</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">p1</span> <span class="operator">=</span> Path.of(<span class="string">&quot;/data/logs&quot;</span>);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">p2</span> <span class="operator">=</span> Path.of(<span class="string">&quot;/data/backup/2023&quot;</span>);</span><br><span class="line">        <span class="comment">// 从 p1 走到 p2 需要怎么走？</span></span><br><span class="line">        System.out.println(<span class="string">&quot;从p1到p2: &quot;</span> + p1.relativize(p2)); <span class="comment">// ../backup/2023</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --- 兼容旧代码 ---</span></span><br><span class="line">        java.io.<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> path.toFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="11-3-2-Files"><a href="#11-3-2-Files" class="headerlink" title="11.3.2 Files"></a>11.3.2 Files</h4><p><code>Files</code> 类是一个纯粹的工具类，提供了大量的静态方法来对 <code>Path</code> 对象所指向的文件或目录进行<strong>读取、写入、创建、删除、复制、移动、属性查询</strong>等操作。它的方法大多设计良好，错误时抛出 <code>IOException</code>。</p>
<h5 id="1-检测与元数据"><a href="#1-检测与元数据" class="headerlink" title="1. 检测与元数据"></a>1. 检测与元数据</h5><ul>
<li><strong><code>exists(Path path)</code></strong> &#x2F; <strong><code>notExists(Path path)</code></strong><ul>
<li><strong>作用</strong>：检查文件或目录是否存在。</li>
</ul>
</li>
<li><strong><code>isDirectory(Path path)</code></strong> &#x2F; <strong><code>isRegularFile(Path path)</code></strong><ul>
<li><strong>作用</strong>：判断是文件夹还是普通文件。</li>
</ul>
</li>
<li><strong><code>isExecutable(Path path)</code></strong> &#x2F; <strong><code>isHidden(Path path)</code></strong> &#x2F; <strong><code>isReadable(Path path)</code></strong><ul>
<li><strong>作用</strong>：检查文件的权限和属性。</li>
</ul>
</li>
<li><strong><code>size(Path path)</code></strong><ul>
<li><strong>作用</strong>：获取文件大小（字节数）。</li>
</ul>
</li>
<li><strong><code>getLastModifiedTime(Path path)</code></strong><ul>
<li><strong>作用</strong>：获取最后修改时间。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.FileTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetadataDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设当前目录下有一个 test.txt，或者你可以先手动创建一个</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Path.of(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 基础判断 (不抛异常)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> Files.exists(path);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件是否存在: &quot;</span> + exists);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exists) &#123;</span><br><span class="line">            <span class="comment">// 2. 类型判断</span></span><br><span class="line">            System.out.println(<span class="string">&quot;是目录吗? &quot;</span> + Files.isDirectory(path));</span><br><span class="line">            System.out.println(<span class="string">&quot;是普通文件吗? &quot;</span> + Files.isRegularFile(path));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 权限与属性 (可能抛出 IOException)</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;是否隐藏: &quot;</span> + Files.isHidden(path));</span><br><span class="line">                System.out.println(<span class="string">&quot;是否可读: &quot;</span> + Files.isReadable(path));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 4. 获取大小 (字节)</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Files.size(path);</span><br><span class="line">                System.out.println(<span class="string">&quot;文件大小: &quot;</span> + size + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 获取时间</span></span><br><span class="line">                <span class="type">FileTime</span> <span class="variable">lastModifiedTime</span> <span class="operator">=</span> Files.getLastModifiedTime(path);</span><br><span class="line">                System.out.println(<span class="string">&quot;最后修改时间: &quot;</span> + lastModifiedTime);</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-文件的增删改-CRUD"><a href="#2-文件的增删改-CRUD" class="headerlink" title="2. 文件的增删改 (CRUD)"></a>2. 文件的增删改 (CRUD)</h5><ul>
<li><strong><code>createFile(Path path)</code></strong><ul>
<li><strong>作用</strong>：创建一个空文件。如果文件已存在会抛异常。</li>
</ul>
</li>
<li><strong><code>createDirectory(Path path)</code></strong><ul>
<li><strong>作用</strong>：创建一级目录。如果父目录不存在会抛异常。</li>
</ul>
</li>
<li><strong><code>createDirectories(Path path)</code></strong> (<strong>强烈推荐</strong>)<ul>
<li><strong>作用</strong>：<strong>递归创建目录</strong>（类似于 Linux 的 <code>mkdir -p</code>）。如果父目录不存在，会自动帮你创建；如果目录已存在，则不会报错。</li>
</ul>
</li>
<li><strong><code>delete(Path path)</code></strong><ul>
<li><strong>作用</strong>：删除文件或空目录。如果不存在会抛异常。</li>
</ul>
</li>
<li><strong><code>deleteIfExists(Path path)</code></strong><ul>
<li><strong>作用</strong>：如果存在则删除。返回 boolean 表示是否删除成功。</li>
</ul>
</li>
<li><strong><code>copy(Path source, Path target, CopyOption... options)</code></strong><ul>
<li><strong>作用</strong>：复制文件。</li>
<li><strong>注意</strong>：默认情况下，如果目标文件已存在，会报错。通常需要配合 <code>StandardCopyOption.REPLACE_EXISTING</code> 使用。</li>
</ul>
</li>
<li><strong><code>move(Path source, Path target, CopyOption... options)</code></strong><ul>
<li><strong>作用</strong>：移动文件或重命名。同样建议配合 <code>REPLACE_EXISTING</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSysCrudDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">baseDir</span> <span class="operator">=</span> Path.of(<span class="string">&quot;nio_demo&quot;</span>);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">sourceFile</span> <span class="operator">=</span> baseDir.resolve(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">targetFile</span> <span class="operator">=</span> baseDir.resolve(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">backupDir</span> <span class="operator">=</span> baseDir.resolve(<span class="string">&quot;backup&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 创建多级目录 (推荐用 createDirectories 而不是 createDirectory)</span></span><br><span class="line">            Files.createDirectories(baseDir);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 创建文件 (如果已存在会报错，所以通常配合 notExists 使用)</span></span><br><span class="line">            <span class="keyword">if</span> (Files.notExists(sourceFile)) &#123;</span><br><span class="line">                Files.createFile(sourceFile);</span><br><span class="line">                System.out.println(<span class="string">&quot;创建文件: &quot;</span> + sourceFile);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 复制文件</span></span><br><span class="line">            <span class="comment">// StandardCopyOption.REPLACE_EXISTING 表示如果目标存在则覆盖</span></span><br><span class="line">            Files.copy(sourceFile, targetFile, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">            System.out.println(<span class="string">&quot;复制成功: source -&gt; target&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 移动/重命名文件</span></span><br><span class="line">            Files.createDirectories(backupDir);</span><br><span class="line">            <span class="type">Path</span> <span class="variable">moveTarget</span> <span class="operator">=</span> backupDir.resolve(<span class="string">&quot;moved_source.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// ATOMIC_MOVE 保证原子性操作</span></span><br><span class="line">            Files.move(sourceFile, moveTarget, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">            System.out.println(<span class="string">&quot;移动成功: source -&gt; backup/moved_source.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 删除</span></span><br><span class="line">            Files.deleteIfExists(targetFile); <span class="comment">// 删除 target.txt</span></span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功: target.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-读写文件内容-Read-Write"><a href="#3-读写文件内容-Read-Write" class="headerlink" title="3. 读写文件内容 (Read &amp; Write)"></a>3. 读写文件内容 (Read &amp; Write)</h5><p><code>Files</code> 提供了非常方便的方法来读写文件，不再需要手动写繁琐的 <code>FileInputStream</code>。</p>
<h6 id="a-小文件读写-一次性加载到内存"><a href="#a-小文件读写-一次性加载到内存" class="headerlink" title="a. 小文件读写 (一次性加载到内存)"></a>a. 小文件读写 (一次性加载到内存)</h6><p><strong>注意：千万不要用这些方法读取大文件（如几百MB以上），否则会导致 OOM (内存溢出)。</strong></p>
<ul>
<li><strong><code>readAllBytes(Path path)</code></strong><ul>
<li><strong>作用</strong>：读取所有字节，返回 <code>byte[]</code>。</li>
</ul>
</li>
<li><strong><code>readString(Path path)</code></strong> (Java 11+)<ul>
<li><strong>作用</strong>：直接读取为字符串。</li>
</ul>
</li>
<li><strong><code>readAllLines(Path path)</code></strong><ul>
<li><strong>作用</strong>：读取所有行，返回 <code>List&lt;String&gt;</code>。</li>
</ul>
</li>
<li><strong><code>write(Path path, byte[] bytes, OpenOption... options)</code></strong><ul>
<li><strong>作用</strong>：将字节数组写入文件。</li>
</ul>
</li>
<li><strong><code>writeString(Path path, CharSequence csq, OpenOption... options)</code></strong> (Java 11+)<ul>
<li><strong>作用</strong>：将字符串直接写入文件。</li>
<li><em>示例</em>：<code>Files.writeString(path, &quot;Hello&quot;, StandardOpenOption.APPEND);</code> (追加模式)</li>
</ul>
</li>
</ul>
<h6 id="b-流式-大文件读写-桥接到传统-IO"><a href="#b-流式-大文件读写-桥接到传统-IO" class="headerlink" title="b. 流式&#x2F;大文件读写 (桥接到传统 IO)"></a>b. 流式&#x2F;大文件读写 (桥接到传统 IO)</h6><p>如果文件很大，或者需要按行流式处理。</p>
<ul>
<li><strong><code>newInputStream(Path path)</code></strong> &#x2F; <strong><code>newOutputStream(Path path)</code></strong><ul>
<li><strong>作用</strong>：获取传统 IO 流。</li>
</ul>
</li>
<li><strong><code>newBufferedReader(Path path)</code></strong> &#x2F; <strong><code>newBufferedWriter(Path path)</code></strong><ul>
<li><strong>作用</strong>：获取带缓冲的字符流（高效）。</li>
</ul>
</li>
<li><strong><code>lines(Path path)</code></strong> (<strong>Java 8 Stream 神器</strong>)<ul>
<li><strong>作用</strong>：返回 <code>Stream&lt;String&gt;</code>。允许你用 Lambda 表达式懒加载地处理大文件的每一行。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Path.of(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- A. 小文件操作 (简单粗暴，全进内存) ---</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 写入 (Java 11 writeString, 旧版用 write)</span></span><br><span class="line">        <span class="comment">// CREATE: 不存在则创建, TRUNCATE_EXISTING: 存在则清空重写, APPEND: 追加</span></span><br><span class="line">        Files.writeString(path, <span class="string">&quot;Hello Line 1\n&quot;</span>, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);</span><br><span class="line">        Files.writeString(path, <span class="string">&quot;Hello Line 2&quot;</span>, StandardOpenOption.APPEND);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 读取全部字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> Files.readString(path);</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 全部读取 ---\n&quot;</span> + content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 读取所有行到 List</span></span><br><span class="line">        List&lt;String&gt; lines = Files.readAllLines(path);</span><br><span class="line">        System.out.println(<span class="string">&quot;总行数: &quot;</span> + lines.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- B. 大文件操作 (流式/缓冲，节省内存) ---</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 使用 Java 8 Stream 按行处理 (非常推荐)</span></span><br><span class="line">        <span class="comment">// 注意：必须在 try-with-resources 中使用，否则文件句柄不会释放！</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--- Stream 读取 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;String&gt; lineStream = Files.lines(path)) &#123;</span><br><span class="line">            lineStream</span><br><span class="line">                .filter(s -&gt; s.contains(<span class="string">&quot;Line 2&quot;</span>)) <span class="comment">// 过滤</span></span><br><span class="line">                .forEach(System.out::println);     <span class="comment">// 处理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 传统 BufferedWriter (用于高性能写出)</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> Files.newBufferedWriter(path, StandardOpenOption.APPEND)) &#123;</span><br><span class="line">            writer.write(<span class="string">&quot;\nLine 3 from Writer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-目录遍历"><a href="#4-目录遍历" class="headerlink" title="4. 目录遍历"></a>4. 目录遍历</h5><ul>
<li><strong><code>list(Path dir)</code></strong><ul>
<li><strong>作用</strong>：列出当前目录下的第一级内容（不递归），返回 <code>Stream&lt;Path&gt;</code>。类似于 <code>ls</code> 命令。</li>
<li><strong>注意</strong>：使用完必须关闭 Stream（通常放在 try-with-resources 中）。</li>
</ul>
</li>
<li><strong><code>walk(Path start, int maxDepth)</code></strong><ul>
<li><strong>作用</strong>：<strong>递归遍历</strong>目录树（深度优先）。</li>
<li><strong>场景</strong>：查找整个文件夹下的所有 <code>.java</code> 文件、递归删除文件夹。</li>
</ul>
</li>
<li><strong><code>find(Path start, int maxDepth, BiPredicate matcher)</code></strong><ul>
<li><strong>作用</strong>：带条件的递归遍历。java</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraverseDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用当前项目根目录作为演示</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">startDir</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;.&quot;</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 浅层遍历 (类似于 ls 命令，只看当前一级)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 当前目录列表 (Files.list) ---&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;Path&gt; stream = Files.list(startDir)) &#123;</span><br><span class="line">            stream.forEach(p -&gt; System.out.println(p.getFileName()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 深度递归遍历 (类似于 find 命令，查找子子孙孙)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 递归查找所有 .java 文件 (Files.walk) ---&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;Path&gt; stream = Files.walk(startDir, <span class="number">3</span>)) &#123; <span class="comment">// maxDepth=3，防止太深</span></span><br><span class="line">            stream</span><br><span class="line">                .filter(Files::isRegularFile) <span class="comment">// 只看文件</span></span><br><span class="line">                .filter(p -&gt; p.toString().endsWith(<span class="string">&quot;.java&quot;</span>)) <span class="comment">// 只要 java 文件</span></span><br><span class="line">                .forEach(p -&gt; System.out.println(<span class="string">&quot;发现源码: &quot;</span> + p.getFileName()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="11-4-总结与应用"><a href="#11-4-总结与应用" class="headerlink" title="11.4 总结与应用"></a>11.4 总结与应用</h3><h4 id="11-4-1-优劣势"><a href="#11-4-1-优劣势" class="headerlink" title="11.4.1 优劣势"></a>11.4.1 优劣势</h4><p><strong>优势：</strong></p>
<ol>
<li><strong>高性能：</strong> 单线程管理大量连接，极大减少了线程上下文切换的开销。</li>
<li><strong>资源节约：</strong> 避免了为每个连接创建一个线程的巨大资源消耗。</li>
<li><strong>非阻塞：</strong> I&#x2F;O 操作不会阻塞线程，允许线程做其他事情，提高了 CPU 利用率。</li>
</ol>
<p><strong>劣势：</strong></p>
<ol>
<li><strong>API 复杂：</strong> 编程模型比 BIO 复杂得多，需要对三大组件有深刻理解。</li>
<li><strong>调试困难：</strong> 异步和非阻塞的特性使得调试和问题排查更具挑战性。</li>
<li><strong>“空轮询” Bug：</strong> 在旧版本的 JDK 中，Selector 的 <code>select()</code> 方法可能在没有就绪事件时无故返回，导致 CPU 100%，不过此问题在 JDK 1.6 及之后版本已修复。</li>
</ol>
<hr>
<h4 id="11-4-2-最佳实践"><a href="#11-4-2-最佳实践" class="headerlink" title="11.4.2 最佳实践"></a>11.4.2 最佳实践</h4><p>直接使用原生 NIO API 进行开发非常繁琐且容易出错。因此，在实践中，我们通常会使用基于 NIO 构建的<strong>高性能网络框架</strong>，如 <strong>Netty</strong> 或 <strong>Mina</strong>。这些框架对复杂的 NIO API 进行了极佳的封装，提供了简单易用的接口和强大的功能（如心跳检测、粘包拆包处理、编解码器等），极大地提升了开发效率和应用程序的健壮性。</p>
<hr>
<h2 id="12-AIO【未来】"><a href="#12-AIO【未来】" class="headerlink" title="12. AIO【未来】"></a>12. AIO【未来】</h2><h3 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h3><p><strong>AIO</strong>，全称为 <strong>Asynchronous I&#x2F;O</strong>（异步 I&#x2F;O），是在 Java 7 中引入的一种全新的 I&#x2F;O 模型。它的核心思想是 <strong>“订阅-通知”</strong> 模式。</p>
<p>与 NIO 的“非阻塞”和“就绪选择”不同，AIO 是真正的<strong>异步</strong>。这意味着：</p>
<ul>
<li><strong>NIO (Non-blocking I&#x2F;O):</strong> 你主动去问（轮询 Selector）“数据准备好了吗？”，如果准备好了，你自己再去读写（这个读写过程本身可能是阻塞的，但通常很快）。</li>
<li><strong>AIO (Asynchronous I&#x2F;O):</strong> 你发起一个 I&#x2F;O 操作（如 <code>read</code>），并提供一个“回调函数”（Callback）。然后你就可以立刻去做别的事情了。<strong>当操作系统真正完成了整个 I&#x2F;O 操作（数据已经从内核缓冲区复制到你的用户缓冲区）后，它会主动通知你</strong>，你的回调函数才会被调用。</li>
</ul>
<p><strong>一个经典的比喻：</strong></p>
<ul>
<li><strong>BIO (同步阻塞)：</strong> 你去餐馆点餐，<strong>一直站在柜台前等着</strong>，直到厨师做好饭后你才端着饭离开。期间你什么也干不了。</li>
<li><strong>NIO (同步非阻塞)：</strong> 你点完餐后，<strong>不停地回到柜台问</strong>：“好了吗？好了吗？”（轮询）。在问的间隙，你可以玩手机。直到某次问的时候，饭做好了，你才自己端走。</li>
<li><strong>AIO (异步非阻塞)：</strong> 你点完餐后，<strong>直接回座位玩手机</strong>。你<strong>不需要主动去问</strong>。厨师做好饭后，<strong>服务员会主动把饭送到你的桌子上</strong>（回调通知），然后你开始吃饭。</li>
</ul>
<hr>
<h3 id="12-2-核心组件"><a href="#12-2-核心组件" class="headerlink" title="12.2 核心组件"></a>12.2 核心组件</h3><p>Java AIO 的核心类主要在 <code>java.nio.channels</code> 包下，以 <code>Asynchronous</code> 开头。</p>
<ol>
<li><strong><code>AsynchronousChannel</code> (异步通道)</strong><br>这是一个标记接口，所有支持异步操作的通道都实现它。最重要的两个实现是：<ul>
<li><code>AsynchronousSocketChannel</code>：用于客户端 TCP 套接字。</li>
<li><code>AsynchronousServerSocketChannel</code>：用于服务端 TCP 套接字，监听接入的连接。</li>
<li><code>AsynchronousFileChannel</code>：用于异步文件操作。</li>
</ul>
</li>
<li><strong><code>CompletionHandler</code> (完成处理器)</strong><br>这是 AIO 的“回调函数”接口。当你发起一个异步操作时，需要传递一个 <code>CompletionHandler</code> 的实现。它有两个方法：<ul>
<li><code>completed(V result, A attachment)</code>：当 I&#x2F;O 操作<strong>成功完成</strong>时被调用。</li>
<li><code>failed(Throwable exc, A attachment)</code>：当 I&#x2F;O 操作<strong>失败</strong>时被调用。</li>
</ul>
</li>
<li><strong><code>Future</code> (未来结果)</strong><br>除了回调模式，AIO 也支持 <code>Future</code> 模式。当你发起一个异步操作时，它<strong>立即返回一个 <code>Future</code> 对象</strong>。你可以通过这个 <code>Future</code> 对象来检查操作是否完成 (<code>isDone()</code>)，或者<strong>阻塞地等待操作完成并获取结果</strong> (<code>get()</code>)。这为开发者提供了另一种处理异步操作的方式。</li>
</ol>
<hr>
<h3 id="12-3-AIO工作模式"><a href="#12-3-AIO工作模式" class="headerlink" title="12.3 AIO工作模式"></a>12.3 AIO工作模式</h3><h4 id="12-3-1-回调模式-Callback-based-更“异步”"><a href="#12-3-1-回调模式-Callback-based-更“异步”" class="headerlink" title="12.3.1 回调模式 (Callback-based) - 更“异步”"></a>12.3.1 回调模式 (Callback-based) - 更“异步”</h4><p>使用 <code>CompletionHandler</code>。</p>
<p><strong>示例：一个简单的 AIO 服务器端 Accept 操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建异步服务端通道并绑定端口</span></span><br><span class="line"><span class="type">AsynchronousServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open()</span><br><span class="line">        .bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 发起一个异步 Accept 操作，等待客户端连接</span></span><br><span class="line"><span class="comment">//    第一个参数是附件（可为null），第二个是CompletionHandler</span></span><br><span class="line">server.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 当有客户端成功连接时，此方法被系统回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel client, Void attachment)</span> &#123;</span><br><span class="line">        <span class="comment">// 非常重要：立即再次发起 accept，以接收下一个客户端连接</span></span><br><span class="line">        server.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理这个新连接，比如为其发起一个读操作</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发起一个异步读操作</span></span><br><span class="line">        client.read(buffer, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer bytesRead, ByteBuffer buffer)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; client.close(); &#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">// 处理读取到的数据...</span></span><br><span class="line">                System.out.println(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                buffer.clear();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 继续发起下一次读操作，形成循环</span></span><br><span class="line">                client.read(buffer, buffer, <span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer buffer)</span> &#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">                <span class="keyword">try</span> &#123; client.close(); &#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 如果 Accept 操作失败（如端口被占用），此方法被回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void attachment)</span> &#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 防止主线程退出，因为所有操作都是异步的</span></span><br><span class="line">System.in.read();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="12-3-2-Future-模式-Future-based-更“可控”"><a href="#12-3-2-Future-模式-Future-based-更“可控”" class="headerlink" title="12.3.2 Future 模式 (Future-based) - 更“可控”"></a>12.3.2 Future 模式 (Future-based) - 更“可控”</h4><p>使用操作返回的 <code>Future</code> 对象来等待结果。</p>
<p><strong>示例：使用 Future 进行异步文件读取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;largefile.bin&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(path, StandardOpenOption.READ)) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>); <span class="comment">// 1MB buffer</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 从文件开头读取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起异步读操作，立即返回一个 Future</span></span><br><span class="line">    Future&lt;Integer&gt; operation = fileChannel.read(buffer, position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在等待读操作完成的同时，主线程可以去做其他事情...</span></span><br><span class="line">    doSomethingElse();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果事情做完了，但读操作还没完，可以在这里阻塞等待，直到完成</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">bytesRead</span> <span class="operator">=</span> operation.get(); <span class="comment">// 这是一个阻塞调用</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Read &quot;</span> + bytesRead + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="comment">// ... 处理数据</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ExecutionException | InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="12-4-AIO-的现状与总结"><a href="#12-4-AIO-的现状与总结" class="headerlink" title="12.4 AIO 的现状与总结"></a>12.4 AIO 的现状与总结</h3><p><strong>优点：</strong></p>
<ul>
<li>理论性能上限非常高，是真正的异步。</li>
<li>对于文件 I&#x2F;O 操作，<code>AsynchronousFileChannel</code> 是一个不错的选择。</li>
</ul>
<p><strong>缺点与挑战：</strong></p>
<ol>
<li><strong>Linux 支持问题：</strong> 这是最大的硬伤。由于 Linux 内核层面对网络 AIO 的支持不完善，导致 Java AIO 在 Linux 下的网络性能甚至可能不如成熟的 NIO 框架（如 Netty）。</li>
<li><strong>编程复杂度极高：</strong> 嵌套的回调函数难以编写、阅读、调试和维护，容易陷入“回调地狱”。</li>
<li><strong>生态系统薄弱：</strong> 主流的高性能网络框架（如 <strong>Netty</strong>, <strong>gRPC</strong>）都基于 NIO 构建，因为它们需要跨平台的高性能。AIO 没有形成强大的生态系统。</li>
</ol>
<p><strong>实践建议：</strong></p>
<ul>
<li><strong>对于网络编程，几乎总是应该选择 NIO</strong>，并使用基于 NIO 的成熟框架（如 <strong>Netty</strong>）。Netty 在 NIO 之上已经做了极佳的封装和优化，其性能和易用性远超自己编写的 AIO 代码。</li>
<li><strong>只有在 Windows 平台下进行高性能网络服务端开发</strong>，且对 Windows 的 IOCP 非常熟悉时，才考虑直接使用 AIO。</li>
<li><strong>对于大文件的异步读写操作</strong>，可以考虑使用 <code>AsynchronousFileChannel</code>。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%9B%9B%E3%80%81%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%9B%9B%E3%80%81%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">四、集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:15:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:15:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-30 15:51:38" itemprop="dateModified" datetime="2025-11-30T15:51:38+08:00">2025-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="四、集合"><a href="#四、集合" class="headerlink" title="四、集合"></a>四、集合</h1><h2 id="1-集合框架整体架构"><a href="#1-集合框架整体架构" class="headerlink" title="1. 集合框架整体架构"></a>1. 集合框架整体架构</h2><p>Java 集合框架主要分为两大家族：<strong><code>Collection</code></strong> 和 <strong><code>Map</code></strong>。</p>
<ul>
<li><strong><code>Collection</code></strong>： 存储单一元素的集合。</li>
<li><strong><code>Map</code></strong>： 存储键值对（Key-Value）的集合。</li>
</ul>
<pre><code class="highlight mermaid">graph TD
    %% 样式定义
    classDef interfaceStyle fill:#262626,stroke:#2ecc71,stroke-width:2px,color:#fff
    classDef abstractClassStyle fill:#262626,stroke:#e67e22,stroke-width:2px,color:#fff
    classDef concreteClassStyle fill:#262626,stroke:#ecf0f1,stroke-width:2px,color:#fff
    classDef privateClassStyle fill:#262626,stroke:#e74c3c,stroke-width:2px,color:#fff

    %% Collection 体系
    Collection(&quot;Collection&quot;) -.-&gt; Set(&quot;Set&quot;)
    Collection -.-&gt; List(&quot;List&quot;)
    Collection -.-&gt; Queue(&quot;Queue&quot;)

    %% Set 分支
    Set --&gt; EnumSet(&quot;EnumSet&quot;)
    Set --&gt; HashSet(&quot;HashSet&quot;)
    Set --&gt; TreeSet(&quot;TreeSet&quot;)
    Set --&gt; CopyOnWriteArraySet(&quot;CopyOnWriteArraySet&quot;)
    EnumSet --&gt; RegularEnumSet(&quot;Regular EnumSet&quot;)
    EnumSet --&gt; JumboEnumSet(&quot;Jumbo EnumSet&quot;)
    HashSet -.-&gt; LinkedHashSet(&quot;Linked HashSet&quot;)

    %% List 分支
    List --&gt; ArrayList(&quot;ArrayList&quot;)
    List --&gt; CopyOnWriteArrayList(&quot;CopyOnWrite ArrayList&quot;)
    List --&gt; Vector(&quot;Vector&quot;)
    List --&gt; LinkedList(&quot;LinkedList&quot;)
    Vector -.-&gt; Stack(&quot;Stack&quot;)

    %% Queue 分支
    Queue -.-&gt; Deque(&quot;Deque&quot;)
    Deque --&gt; ArrayDeque(&quot;ArrayDeque&quot;)
    LinkedList --&gt; Deque
    
    PriorityQueue(&quot;PriorityQueue&quot;) --&gt; Queue
    LinkedBlockingQueue(&quot;LinkedBlockingQueue&quot;) --&gt; Queue
    ConcurrentLinkedQueue(&quot;ConcurrentLinkedQueue&quot;) --&gt; Queue
    ArrayBlockingQueue(&quot;ArrayBlockingQueue&quot;) --&gt; Queue

    %% Map 体系 (独立分支)
    Map(&quot;Map&quot;) -.-&gt; HashMap(&quot;HashMap&quot;)
    Map -.-&gt; TreeMap(&quot;TreeMap&quot;)
    Map -.-&gt; Hashtable(&quot;Hashtable&quot;)
    Map -.-&gt; ConcurrentHashMap(&quot;Concurrent HashMap&quot;)
    HashMap -.-&gt; LinkedHashMap(&quot;Linked HashMap&quot;)

    %% 应用样式
    class Collection,Set,List,Queue,Deque,Map interfaceStyle
    class EnumSet abstractClassStyle
    class RegularEnumSet,JumboEnumSet privateClassStyle
    class HashSet,LinkedHashSet,TreeSet,CopyOnWriteArraySet,ArrayList,CopyOnWriteArrayList,Vector,Stack,LinkedList,ArrayDeque,PriorityQueue,LinkedBlockingQueue,ConcurrentLinkedQueue,ArrayBlockingQueue,HashMap,LinkedHashMap,TreeMap,Hashtable,ConcurrentHashMap concreteClassStyle</code></pre>

<hr>
<h2 id="2-Collection-接口体系"><a href="#2-Collection-接口体系" class="headerlink" title="2. Collection 接口体系"></a>2. Collection 接口体系</h2><h3 id="2-1-Collection"><a href="#2-1-Collection" class="headerlink" title="2.1 Collection"></a>2.1 Collection</h3><h4 id="2-2-1-概念"><a href="#2-2-1-概念" class="headerlink" title="2.2.1 概念"></a>2.2.1 概念</h4><p><code>Collection</code> 是Java集合框架的<strong>根接口</strong>之一，用于表示一组对象，这些对象也称为集合的<strong>元素</strong>。它定义了所有单列集合（即每个元素都是一个独立对象，如 <code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code>）将具备的<strong>通用操作</strong>。</p>
<hr>
<h4 id="2-2-2-核心方法"><a href="#2-2-2-核心方法" class="headerlink" title="2.2.2 核心方法"></a>2.2.2 核心方法</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">功能描述</th>
<th align="left">注意点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean add(E e)</code></td>
<td align="left">确保此集合包含指定的元素。</td>
<td align="left">如果集合因调用而改变则返回 <code>true</code>（例如，<code>Set</code> 添加重复元素会返回 <code>false</code>）。</td>
</tr>
<tr>
<td align="left"><code>boolean remove(Object o)</code></td>
<td align="left">从此集合中移除指定元素的单个实例（如果存在）。</td>
<td align="left">移除成功返回 <code>true</code>。</td>
</tr>
<tr>
<td align="left"><code>void clear()</code></td>
<td align="left">移除此集合中的所有元素。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>boolean contains(Object o)</code></td>
<td align="left">如果此集合包含指定的元素，返回 <code>true</code>。</td>
<td align="left">依赖对象的 <code>equals()</code> 方法进行判断，如果集合存储自定义对象，一定要重写equals方法。</td>
</tr>
<tr>
<td align="left"><code>int size()</code></td>
<td align="left">返回此集合中的元素数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>boolean isEmpty()</code></td>
<td align="left">如果此集合不包含任何元素，则返回 <code>true</code>。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Iterator&lt;E&gt; iterator()</code></td>
<td align="left"><strong>返回在此集合的元素上进行迭代的迭代器。</strong></td>
<td align="left">这是<strong>遍历集合</strong>最基本和通用的方式。</td>
</tr>
<tr>
<td align="left"><code>Object[] toArray()</code></td>
<td align="left">返回包含此集合中所有元素的数组。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&lt;T&gt; T[] toArray(T[] a)</code></td>
<td align="left">返回包含此集合中所有元素的数组；返回数组的运行时类型与指定数组的相同。</td>
<td align="left">更常用的方式，可以指定返回数组的类型。</td>
</tr>
<tr>
<td align="left"><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td>
<td align="left">将指定集合中的所有元素添加到此集合中。</td>
<td align="left"><strong>批量操作</strong></td>
</tr>
<tr>
<td align="left"><code>boolean removeAll(Collection&lt;?&gt; c)</code></td>
<td align="left">移除此集合中那些也包含在指定集合中的所有元素（差集）。</td>
<td align="left"><strong>批量操作</strong></td>
</tr>
<tr>
<td align="left"><code>boolean retainAll(Collection&lt;?&gt; c)</code></td>
<td align="left">仅保留此集合中那些也包含在指定集合中的元素（交集）。</td>
<td align="left"><strong>批量操作</strong></td>
</tr>
<tr>
<td align="left"><code>boolean containsAll(Collection&lt;?&gt; c)</code></td>
<td align="left">如果此集合包含指定集合中的所有元素，则返回 <code>true</code>（子集判断）。</td>
<td align="left"><strong>批量操作</strong></td>
</tr>
</tbody></table>
<hr>
<h4 id="2-2-3-遍历方式"><a href="#2-2-3-遍历方式" class="headerlink" title="2.2.3 遍历方式"></a>2.2.3 遍历方式</h4><ol>
<li><p><strong>迭代器（Iterator）</strong>： 最通用、最标准的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ... 添加元素</span></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">    <span class="comment">// it.remove(); // 可以在遍历时安全地移除元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>增强 for 循环（for-each）</strong>： 语法糖，底层仍然是迭代器。<strong>更简洁，但不能在遍历时直接删除元素（会抛异常）</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String element : coll) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Lambda 表达式 + forEach() 方法（JDK8+）</strong>： 非常简洁的遍历方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coll.forEach(element -&gt; System.out.println(element));</span><br><span class="line"><span class="comment">// 或使用方法引用</span></span><br><span class="line">coll.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="2-2-List-接口及其实现类"><a href="#2-2-List-接口及其实现类" class="headerlink" title="2.2 List 接口及其实现类"></a>2.2 <strong>List 接口及其实现类</strong></h3><p><code>List</code> 是 <code>Collection</code> 接口的一个极其重要的子接口。它代表了一个<strong>有序的、可重复的</strong>元素序列，有时也称为<strong>序列</strong>（Sequence）。</p>
<h4 id="2-2-1-核心特征："><a href="#2-2-1-核心特征：" class="headerlink" title="2.2.1 核心特征："></a>2.2.1 核心特征：</h4><ol>
<li><strong>有序（Ordered）</strong>： 元素以一种特定的顺序存储，并且允许以索引（下标）的方式精确控制每个元素的插入位置。<strong>存取顺序一致</strong>（例如，先存”a”再存”b”，遍历时也是先得到”a”再得到”b”）。</li>
<li><strong>可重复（Allow Duplicates）</strong>： 允许存储相同的元素（包括 <code>null</code> 元素）。它依赖元素的 <code>equals()</code> 方法来判断是否重复。</li>
<li><strong>有索引（Indexed）</strong>： 提供了基于整数索引（从 <code>0</code> 开始）的访问方式。用户可以通过 <code>list.get(int index)</code> 直接访问特定位置的元素，这是它与 <code>Set</code> 最明显的区别。</li>
</ol>
<p>正因为这些特性，<code>List</code> 可以被看作是<strong>长度可变的、功能更强大的数组</strong>。</p>
<hr>
<h4 id="2-2-2-特有的核心方法"><a href="#2-2-2-特有的核心方法" class="headerlink" title="2.2.2 特有的核心方法"></a>2.2.2 特有的核心方法</h4><p>除了继承自 <code>Collection</code> 的所有方法外，<code>List</code> 接口定义了大量与<strong>索引</strong>相关的特有方法。</p>
<table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>E get(int index)</code></td>
<td align="left">返回列表中指定位置的元素。<strong>这是List最常用的特性之一。</strong></td>
</tr>
<tr>
<td align="left"><code>E set(int index, E element)</code></td>
<td align="left">用指定元素替换列表中指定位置的元素，并返回被替换的元素。</td>
</tr>
<tr>
<td align="left"><code>void add(int index, E element)</code></td>
<td align="left">在列表的指定位置插入指定元素，原该位置及之后的元素向后移动。</td>
</tr>
<tr>
<td align="left"><code>E remove(int index)</code></td>
<td align="left">移除列表中指定位置的元素，并将后续元素向左移动，<strong>返回被移除的元素</strong>。</td>
</tr>
<tr>
<td align="left"><code>int indexOf(Object o)</code></td>
<td align="left">返回此列表中<strong>第一次</strong>出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。</td>
</tr>
<tr>
<td align="left"><code>int lastIndexOf(Object o)</code></td>
<td align="left">返回此列表中<strong>最后一次</strong>出现的指定元素的索引。</td>
</tr>
<tr>
<td align="left"><code>ListIterator&lt;E&gt; listIterator()</code></td>
<td align="left">返回此列表元素的<strong>列表迭代器</strong>（功能比普通 <code>Iterator</code> 更强大）。</td>
</tr>
<tr>
<td align="left"><code>ListIterator&lt;E&gt; listIterator(int index)</code></td>
<td align="left">从列表的指定位置开始，返回列表迭代器。</td>
</tr>
<tr>
<td align="left"><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code></td>
<td align="left">返回列表中指定的 <code>fromIndex</code>（包括）和 <code>toIndex</code>（不包括）之间的部分<strong>视图</strong>。对子列表的修改会影响原列表。</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-2-3-ArrayList【核心掌握】"><a href="#2-2-3-ArrayList【核心掌握】" class="headerlink" title="2.2.3 ArrayList【核心掌握】"></a>2.2.3 ArrayList【核心掌握】</h4><h5 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>ArrayList</code> 是 <code>List</code> 接口的<strong>可调整大小的数组实现</strong>。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有序（Ordered）</strong>： 元素按照插入顺序存放。</li>
<li><strong>可重复（Allows Duplicates）</strong>： 允许存储相同的元素和 <code>null</code>。</li>
<li><strong>有索引（Indexed）</strong>： 可以通过从 <code>0</code> 开始的索引高速访问元素。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 多线程环境下未经同步直接使用会导致不确定的结果。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个 <strong><code>Object[] elementData</code></strong> 数组来存储所有元素。所有看似“动态”的行为（如自动扩容）都是通过操作这个数组来实现的。</li>
<li><strong>设计思想</strong>：用动态数组实现一个“可变长、随机访问快、尾插效率高”的容器，满足绝大多数读多写少的业务场景需求，同时在扩容策略、接口抽象、并发检测等方面做了权衡。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性"><a href="#2-底层数据结构和关键属性" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>ArrayList</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于空实例的共享空数组（在初始化容量为0时使用）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于默认大小空实例的共享空数组（与EMPTY_ELEMENTDATA区分开来，以知道第一次添加元素时要扩容多少）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真正存储ArrayList元素的数组缓冲区。</span></span><br><span class="line"><span class="comment">     * ArrayList的容量就是这个数组缓冲区的长度。</span></span><br><span class="line"><span class="comment">     * 当第一个元素被添加时，任何以DEFAULTCAPACITY_EMPTY_ELEMENTDATA初始化的ArrayList</span></span><br><span class="line"><span class="comment">     * 都会被扩容到DEFAULT_CAPACITY（10）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList中实际包含的元素数量（size &lt;= elementData.length）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>elementData</code></strong>： 元素真正存储的区域。它被 <code>transient</code> 修饰，是因为 <code>ArrayList</code> 自定义了序列化逻辑以节省空间。</li>
<li><strong><code>size</code></strong>： 记录当前列表中<strong>实际有多少个有效元素</strong>。</li>
<li><strong><code>DEFAULT_CAPACITY</code></strong>： 默认初始容量（10）。<strong>注意：只有在使用无参构造器且第一次添加元素时，才会真正初始化为这个容量。</strong></li>
</ul>
<hr>
<h5 id="3-构造方法与初始化"><a href="#3-构造方法与初始化" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>ArrayList</code> 提供了三种构造方式：</p>
<ol>
<li><p><strong><code>public ArrayList()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 将 <code>elementData</code> 指向 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>懒加载</strong>。此时数组长度为0，节省内存。在<strong>第一次调用 <code>add()</code> 方法添加元素时</strong>，才会将容量真正初始化为 <code>DEFAULT_CAPACITY</code>（10）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量为 10 的空列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public ArrayList(int initialCapacity)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 如果 <code>initialCapacity &gt; 0</code>，则新建一个指定大小的 <code>Object[]</code>；如果等于0，则指向 <code>EMPTY_ELEMENTDATA</code>；小于0则抛异常。</p>
</li>
<li><p><strong>特点</strong>： <strong>显式指定初始容量</strong>。如果你能预估数据量，使用此构造器可以避免多次扩容，提升性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造具有指定初始容量的空列表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 列表的初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果指定的初始容量为负数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public ArrayList(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 将传入的集合通过 <code>c.toArray()</code> 转为数组，并赋值给 <code>elementData</code>。如果转换后的数组长度不为0，还会检查其类型是否为 <code>Object[]</code>，不是则用 <code>Arrays.copyOf</code> 进行转换。</p>
</li>
<li><p><strong>特点</strong>： <strong>用一个已有集合来构造</strong>，元素顺序由该集合的迭代器决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定集合元素的列表，按照集合迭代器返回的顺序排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 其元素要放入此列表中的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 替换为空数组</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-扩容机制-Grow"><a href="#4-扩容机制-Grow" class="headerlink" title="4. 扩容机制 (Grow)"></a>4. 扩容机制 (Grow)</h5><p>当试图向已满的数组（<code>size == elementData.length</code>）添加新元素时，就会触发扩容。</p>
<p><strong>源码逻辑：</strong></p>
<ol>
<li><strong>取出当前数组长度。</strong></li>
<li><strong>判断是否是“第一次添加元素”</strong>：<ul>
<li>如果 <code>oldCapacity == 0</code> 且 <code>elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>（还没初始化过数组），直接分配一个新数组，长度为 <code>max(默认容量10, minCapacity)</code>。</li>
<li>否则，进入正常扩容逻辑。</li>
</ul>
</li>
<li><strong>正常扩容逻辑</strong>：调用 <code>ArraysSupport.newLength</code> 来计算新数组容量。</li>
<li><strong>在 newLength 中的逻辑</strong>：<ul>
<li>计算推荐容量：<br> <code>prefLength = oldCapacity + max(minGrowth, prefGrowth)</code><br> → 既要满足<strong>最小需求</strong>，又尽量走 <strong>1.5倍扩容策略</strong>。</li>
<li>如果 <code>prefLength</code> 合法（没溢出，且 ≤ SOFT_MAX_ARRAY_LENGTH），直接返回。</li>
<li>否则进入 <strong>hugeLength</strong> 处理超大数组情况。</li>
</ul>
</li>
<li><strong>hugeLength 逻辑</strong>（接近 <code>Integer.MAX_VALUE</code> 时）：<ul>
<li>先计算 <code>minLength = oldLength + minGrowth</code>。</li>
<li>如果溢出（&lt;0），抛 <code>OutOfMemoryError</code>。</li>
<li>如果 <code>minLength</code> 还没超过软最大值（<code>Integer.MAX_VALUE - 8</code>），取软最大值。</li>
<li>否则返回 <code>minLength</code>（可能就是 <code>Integer.MAX_VALUE</code>）。</li>
</ul>
</li>
<li><strong>最终扩容</strong>：申请一个新数组，把旧数据复制过去，完成扩容。</li>
</ol>
<ul>
<li><p><strong>最佳实践</strong>： 如果能预估数据量，<strong>务必使用 <code>ArrayList(int initialCapacity)</code> 构造器指定初始容量</strong>，避免或减少扩容次数。</p>
</li>
<li><p><strong>时间复杂度</strong>：<strong>单次扩容操作</strong>O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加容量以确保它至少可以容纳最小容量参数指定的元素数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError 如果 minCapacity &lt; 0（溢出）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">// 旧数组的长度</span></span><br><span class="line">    <span class="comment">// 如果当前数组已经初始化过（不是空数组）</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 计算新的容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(</span><br><span class="line">                oldCapacity,</span><br><span class="line">                minCapacity - oldCapacity, <span class="comment">// minGrowth：最小需要增长的数量</span></span><br><span class="line">                oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">// prefGrowth：首选增长（旧容量的一半，即 1.5 倍扩容）</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 拷贝数据到新数组</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果还是空数组（第一次添加元素）</span></span><br><span class="line">        <span class="comment">// 初始化容量为 默认值 (10) 或者 minCapacity（取大者）</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArraysSupport.newLength源码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算扩容后的数组长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldLength  原数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minGrowth  最小需要增长的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prefGrowth 首选增长数量（通常是 oldLength / 2，即扩容 1.5 倍）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth, <span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算“首选长度”：旧容量 + (max(最小需要增长, 首选增长))</span></span><br><span class="line">    <span class="comment">// 保证至少能容纳新元素，同时优先使用 1.5 倍扩容策略</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新长度合法（&gt;0 且没有超过软最大值）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefLength; <span class="comment">// 直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，尝试计算更大的长度（可能接近 Integer.MAX_VALUE）</span></span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ArraysSupport.hugeLength源码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理极大数组的扩容情况（接近 Integer.MAX_VALUE）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth)</span> &#123;</span><br><span class="line">    <span class="comment">// 最小需要的数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> oldLength + minGrowth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果溢出（&lt;0），抛出 OOM</span></span><br><span class="line">    <span class="keyword">if</span> (minLength &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>(</span><br><span class="line">            <span class="string">&quot;Required array length &quot;</span> + oldLength + <span class="string">&quot; + &quot;</span> + minGrowth + <span class="string">&quot; is too large&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果还没超过软最大值（2^31 - 1 - 8），直接取软最大值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (minLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> SOFT_MAX_ARRAY_LENGTH;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 否则，返回真正的最小需求值（可能就是 Integer.MAX_VALUE）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-添加元素-Add"><a href="#5-添加元素-Add" class="headerlink" title="5. 添加元素(Add)"></a>5. 添加元素(Add)</h5><ul>
<li><p><strong><code>public boolean add(E e)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>计数器++</li>
<li>如果数组已满 → 扩容（grow）。</li>
<li>元素插入数组末尾</li>
<li>size++</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong>摊销常数时间 <code>O(1)</code></strong>（因为扩容操作被分摊到了多次添加操作中）。最坏情况（触发扩容）是 <code>O(n)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向列表末尾追加一个元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 永远返回 true（符合 Collection#add 的规范）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;                <span class="comment">// 修改次数计数器（用于快速失败机制）</span></span><br><span class="line">    add(e, elementData, size); <span class="comment">// 调用辅助方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是从 add(E) 方法中拆分出来的辅助方法，</span></span><br><span class="line"><span class="comment"> * 目的是让 add(E) 的字节码长度小于 35（JVM 参数 -XX:MaxInlineSize 的默认值），</span></span><br><span class="line"><span class="comment"> * 这样在 JIT 编译时 add(E) 在 C1 编译器的循环里更容易被内联优化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果数组已满，需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">// 将元素放入数组末尾</span></span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    <span class="comment">// size 增加 1</span></span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public void add(int index, E element)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑：</strong></p>
<ol>
<li><code>rangeCheckForAdd(index)</code> 检查下标是否合法（是否在0~size之间）。</li>
<li>修改计数器 <code>modCount++</code>。</li>
<li>如果数组已满 → 扩容（grow）。</li>
<li>使用 <code>System.arraycopy</code> 将 <code>[index, size-1]</code> 区间的元素整体向右移动一格。</li>
<li>把新元素放到 <code>elementData[index]</code>。</li>
<li><code>size++</code>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。因为涉及到数组元素的移动。<strong>在列表头部或中间插入元素效率很低</strong>，插入到末尾时（等价于 <code>add(E e)</code>）→ O(1) 均摊。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定位置插入元素，</span></span><br><span class="line"><span class="comment"> * 会将该位置及之后的元素整体向右移动一格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 插入位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果 index 越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index); <span class="comment">// 检查索引是否有效</span></span><br><span class="line">    modCount++;              <span class="comment">// 修改次数计数器 +1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="comment">// 如果数组已满，先扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="built_in">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">// 将 index 及之后的元素整体向右移动一位</span></span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    <span class="comment">// 把新元素放到指定位置</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// size 增加 1</span></span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add 和 addAll 使用的 rangeCheck 版本。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-删除元素-Remove"><a href="#6-删除元素-Remove" class="headerlink" title="6. 删除元素(Remove)"></a>6. 删除元素(Remove)</h5><p><strong><code>public E remove(int index)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong></p>
<ol>
<li>校验下标是否越界。</li>
<li>取出 <code>elementData[index]</code> 的值，保存为返回值。</li>
<li>调用 <code>fastRemove()</code> 删除该元素。</li>
</ol>
</li>
<li><p><strong>最坏情况 O(n)</strong>：删除第一个元素时，需要移动 <code>n-1</code> 个元素。</p>
</li>
<li><p><strong>最好情况 O(1)</strong>：删除最后一个元素时，无需移动，只是 <code>null</code> 清空和 <code>size--</code>。</p>
</li>
<li><p><strong>平均情况 O(n&#x2F;2)</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除列表中指定位置的元素。</span></span><br><span class="line"><span class="comment"> * 删除后会将该位置之后的元素整体左移一位（索引减 1）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除元素的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果下标越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查下标是否有效（0 &lt;= index &lt; size），无效则抛异常</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="comment">// 获取底层数组的引用</span></span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="comment">// 取出被删除的元素，返回时强转为 E</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) es[index];</span><br><span class="line">    <span class="comment">// 执行快速删除（内部方法），会移动数组元素并更新 size</span></span><br><span class="line">    fastRemove(es, index);</span><br><span class="line">    <span class="comment">// 返回被删除的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部删除方法，不做边界检查。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(Object[] es, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    modCount++;                  <span class="comment">// 修改次数计数器 +1（迭代器快速失败机制）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> newSize;</span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i) &#123;</span><br><span class="line">        <span class="comment">// 如果删除的不是最后一个元素：</span></span><br><span class="line">        <span class="comment">// 将 i+1 到 size-1 的元素整体向左移动一位</span></span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让最后一个位置为 null，便于 GC 回收对象</span></span><br><span class="line">    es[size = newSize] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-获取与修改元素-Get-Set"><a href="#7-获取与修改元素-Get-Set" class="headerlink" title="7. 获取与修改元素(Get&amp;Set)"></a>7. 获取与修改元素(Get&amp;Set)</h5><ul>
<li><p><strong><code>public E get(int index)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>检查索引越界 。</li>
<li>直接返回 <code>(E) elementData[index]</code>。<strong>纯粹的数组随机访问</strong>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E set(int index, E element)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>检查索引越界。</li>
<li>取出旧元素 <code>E oldValue = elementData(index)</code>。</li>
<li>将新元素放入指定位置 <code>elementData[index] = element</code>。</li>
<li>返回旧元素。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="8-查找-indexOf-lastIndexOf"><a href="#8-查找-indexOf-lastIndexOf" class="headerlink" title="8. 查找(indexOf&#x2F;lastIndexOf)"></a>8. 查找(indexOf&#x2F;lastIndexOf)</h5><ul>
<li><p><strong>indexOf(第一次出现的位置)</strong></p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>调用 <code>indexOfRange(o, 0, size)</code>。</li>
<li>如果 <code>o == null</code>：从左到右遍历数组，找到第一个 <code>null</code>。</li>
<li>如果 <code>o != null</code>：从左到右遍历数组，调用 <code>o.equals(es[i])</code> 比较。</li>
<li>找到则返回下标；否则返回 <code>-1</code>。</li>
</ol>
</li>
<li><p><strong>最坏情况 O(n)</strong>：元素不存在，需要遍历完整个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素在列表中第一次出现的位置（最小下标），</span></span><br><span class="line"><span class="comment"> * 如果不存在则返回 -1。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 更正式的说：返回最小的下标 i，</span></span><br><span class="line"><span class="comment"> * 满足 Objects.equals(o, get(i))，</span></span><br><span class="line"><span class="comment"> * 如果没有则返回 -1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOfRange(o, <span class="number">0</span>, size); <span class="comment">// 实际调用区间搜索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定范围 [start, end) 内查找元素第一次出现的下标。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要查找的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 搜索起始位置（包含）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 搜索结束位置（不包含）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 第一次出现的位置，如果不存在返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOfRange</span><span class="params">(Object o, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    Object[] es = elementData;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 查找 null 元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 查找非 null 元素，调用 equals 比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>lastIndexOf(最后一次出现)</strong></p>
<ul>
<li><p><strong>源码逻辑：</strong></p>
<ol>
<li>调用 <code>lastIndexOfRange(o, 0, size)</code>。</li>
<li>如果 <code>o == null</code>：从右到左遍历数组，找到最后一个 <code>null</code>。</li>
<li>如果 <code>o != null</code>：从右到左遍历数组，调用 <code>o.equals(es[i])</code> 比较。</li>
<li>找到则返回下标；否则返回 <code>-1</code>。</li>
</ol>
</li>
<li><p><strong>最坏情况 O(n)</strong>：元素不存在，需要遍历完整个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素在列表中最后一次出现的位置（最大下标），</span></span><br><span class="line"><span class="comment"> * 如果不存在则返回 -1。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 更正式的说：返回最大的下标 i，</span></span><br><span class="line"><span class="comment"> * 满足 Objects.equals(o, get(i))，</span></span><br><span class="line"><span class="comment"> * 如果没有则返回 -1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lastIndexOfRange(o, <span class="number">0</span>, size); <span class="comment">// 实际调用区间搜索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定范围 [start, end) 内查找元素最后一次出现的下标。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要查找的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 搜索起始位置（包含）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 搜索结束位置（不包含）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最后一次出现的位置，如果不存在返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOfRange</span><span class="params">(Object o, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    Object[] es = elementData;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 倒序查找 null 元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 倒序查找非 null 元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="9-遍历方式"><a href="#9-遍历方式" class="headerlink" title="9. 遍历方式"></a>9. 遍历方式</h5><ul>
<li><strong>索引for循环</strong>： <code>for (int i=0; i&lt;list.size(); i++) { list.get(i); }</code> —— <strong>最高效</strong>，充分利用了 <code>O(1)</code> 的随机访问特性。</li>
<li><strong>迭代器（Iterator）</strong>： 也是常见方式。</li>
<li><strong>for-each循环</strong>： 语法糖，底层是迭代器。</li>
</ul>
<p><strong>注意</strong>： <strong>严禁在遍历过程中使用 <code>ArrayList</code> 的 <code>remove()</code> 等方法修改集合结构</strong>，否则会抛出 <code>ConcurrentModificationException</code>。如需遍历时删除，必须使用 <strong><code>Iterator.remove()</code></strong> 方法。</p>
<hr>
<h5 id="10-典型应用场景"><a href="#10-典型应用场景" class="headerlink" title="10. 典型应用场景"></a>10. 典型应用场景</h5><p><strong>1. “读多写少”或“主要追加操作”的集合</strong></p>
<p>​	这是 ArrayList <strong>最经典、最合适的应用场景</strong>。</p>
<ul>
<li><strong>场景描述</strong>：你需要一个容器来存储数据，大部分操作是<strong>查询和遍历</strong>，而添加操作主要是<strong>在列表末尾追加</strong>，很少或几乎不在列表的中间进行插入和删除。</li>
<li><strong>举例</strong>：<ul>
<li><strong>商品列表</strong>：从数据库查询出一批商品信息展示给用户，用户会频繁地浏览（查询）、翻页、过滤（遍历），但商品列表本身不会频繁变动。</li>
<li><strong>日志记录</strong>：应用程序将日志事件依次添加到日志列表中，最后再统一处理或输出。这主要是追加操作。</li>
<li><strong>配置信息列表</strong>：程序启动时加载一批配置信息到内存中供后续频繁读取。</li>
</ul>
</li>
</ul>
<p><strong>2. 需要通过索引进行频繁随机访问</strong></p>
<ul>
<li><strong>场景描述</strong>：你需要根据位置（第几个）来快速获取或设置元素。</li>
<li><strong>举例</strong>：<ul>
<li>一个学生列表，需要快速获取第 5 个学生的信息。</li>
</ul>
</li>
</ul>
<p><strong>3. 作为临时容器用于计算或转换</strong></p>
<ul>
<li><strong>场景描述</strong>：在进行一些数据处理时，我们常常需要一个有序的、可重复的临时容器来存放中间结果。</li>
<li><strong>举例</strong>：<ul>
<li>从数据库或文件中读出一批数据，先放入 ArrayList，然后在内存中进行排序、过滤、统计等操作。</li>
<li>将一个 Set（集合）转换成一个有序的列表。</li>
</ul>
</li>
</ul>
<p><strong>4. 替代数组，提供更丰富的功能</strong></p>
<ul>
<li><strong>场景描述</strong>：你需要一个类似数组的结构，但希望它的大小能够动态增长，并且不想自己手动处理数组扩容的复杂逻辑。</li>
<li><strong>举例</strong>：<ul>
<li>存储一个不确定数量的对象，比如解析一个 CSV 文件，每一行读到一个 ArrayList 中。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-4-LinkedList【核心掌握】"><a href="#2-2-4-LinkedList【核心掌握】" class="headerlink" title="2.2.4 LinkedList【核心掌握】"></a>2.2.4 LinkedList【核心掌握】</h4><h5 id="1-核心概念-1"><a href="#1-核心概念-1" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>LinkedList</code> 是一个实现了 <code>List</code> 和 <code>Deque</code> 接口的<strong>双向链表</strong>。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有序（Ordered）</strong>： 元素按照插入顺序存放。</li>
<li><strong>可重复（Allows Duplicates）</strong>： 允许存储相同的元素和 <code>null</code>。</li>
<li><strong>无索引（但模拟索引）</strong>： 底层没有数组，索引访问需要通过遍历实现。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 和 <code>ArrayList</code> 一样，多线程环境下需要手动同步。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层通过一个<strong>双向链表（Doubly-linked list）</strong> 来存储所有元素。所有操作都是通过指针的引用来完成。</li>
<li><strong>设计思想</strong>：用 <strong>双向链表结构</strong> 实现一个 <strong>插入、删除高效，不依赖连续内存</strong> 的通用容器；</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-1"><a href="#2-底层数据结构和关键属性-1" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>LinkedList</code> 的源码（以OpenJDK为例）：</p>
<p>核心节点类是 <strong><code>Node&lt;E&gt;</code></strong>（静态内部类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;         <span class="comment">// 当前节点存储的实际元素</span></span><br><span class="line">    Node&lt;E&gt; next;   <span class="comment">// 指向下一个节点的引用</span></span><br><span class="line">    Node&lt;E&gt; prev;   <span class="comment">// 指向前一个节点的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个节点都知道 <strong>前驱节点</strong> 和 <strong>后继节点</strong>。</li>
<li>支持从前向后、从后向前遍历。</li>
<li>插入&#x2F;删除节点只需改指针，效率 O(1)。</li>
</ul>
<p>同时，<code>LinkedList</code> 类本身有三个关键属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;       <span class="comment">// 当前链表的元素个数</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;      <span class="comment">// 指向第一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;       <span class="comment">// 指向最后一个节点</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>size</code></strong>：记录链表中元素的数量，支持 O(1) 获取长度。</p>
</li>
<li><p><strong><code>first</code></strong>：指向链表头节点，方便 <code>addFirst</code> &#x2F; <code>removeFirst</code> 操作。</p>
</li>
<li><p><strong><code>last</code></strong>：指向链表尾节点，方便 <code>addLast</code> &#x2F; <code>removeLast</code> 操作。</p>
</li>
</ul>
<hr>
<h5 id="3-添加元素（Add）"><a href="#3-添加元素（Add）" class="headerlink" title="3. 添加元素（Add）"></a>3. 添加元素（Add）</h5><ul>
<li><p><strong><code>public boolean add(E e)</code></strong>： <strong>在链表末尾添加元素</strong>。</p>
<ul>
<li><p><strong>源码逻辑</strong></p>
<ol>
<li>内部调用 <code>linkLast(e)</code>。</li>
<li>保存原来的尾节点 <code>last</code>。</li>
<li>创建一个新节点 <code>newNode</code>，其前驱指向原尾节点，数据域存储 <code>e</code>，后继为 <code>null</code>。</li>
<li>更新 <code>last = newNode</code>，使链表尾指针指向新节点。</li>
<li>如果原链表为空（<code>last == null</code>），说明这是第一个节点 → 更新 <code>first = newNode</code>。</li>
<li>否则，将原尾节点的 <code>next</code> 指向 <code>newNode</code>，把新节点接到链表尾部。</li>
<li>更新 <code>size</code> 和 <code>modCount</code>。</li>
</ol>
</li>
<li><p><strong>时间复杂度：O(1)</strong>：直接在尾部插入，不涉及遍历或移动元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在链表末尾添加一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 永远返回 true（符合 Collection#add 的规范）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);   <span class="comment">// 将元素链接到链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素作为最后一个节点插入链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;                 <span class="comment">// 取出当前尾节点（可能是 null）</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>); <span class="comment">// 创建新节点，前驱 = l，数据 = e，后继 = null</span></span><br><span class="line">    last = newNode;                         <span class="comment">// 更新尾节点指针</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)                          <span class="comment">// 如果链表之前为空</span></span><br><span class="line">        first = newNode;                    <span class="comment">// 头节点也指向新节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;                   <span class="comment">// 否则，将原尾节点的 next 指向新节点</span></span><br><span class="line">    size++;                                 <span class="comment">// 链表长度 +1</span></span><br><span class="line">    modCount++;                             <span class="comment">// 修改次数计数器 +1（用于 fail-fast 机制）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public void add(int index, E element)</code></strong>： <strong>在指定索引处插入元素</strong>。</p>
<ul>
<li><p><strong>源码逻辑：</strong></p>
<ol>
<li>检查索引是否越界 (<code>checkPositionIndex(index)</code>)。</li>
<li>如果 <code>index == size</code>，说明是在尾部插入，直接调用 <code>linkLast(element)</code>。</li>
<li>否则，调用 <code>linkBefore(element, node(index))</code>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。主要是因为 <code>node(index)</code> 查找目标节点需要 <code>O(n)</code> 的时间。但<strong>实际的插入操作（修改指针）本身是 <code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在链表的指定位置插入一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index   插入位置（范围：0 &lt;= index &lt;= size）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果下标越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkPositionIndex(index);   <span class="comment">// 检查下标是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)           <span class="comment">// 插入位置在链表尾部</span></span><br><span class="line">        linkLast(element);       <span class="comment">// 直接追加到末尾</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index)); <span class="comment">// 在指定位置的节点前插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据下标返回对应的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要查找的节点下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 目标位置的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果在前半部分，从头开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在后半部分，从尾开始向前遍历</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定节点 &#123;<span class="doctag">@code</span> succ&#125; 之前插入新节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e    要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> succ 插入位置的节点，新节点将插入到它前面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;                     <span class="comment">// succ 的前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);  <span class="comment">// 创建新节点</span></span><br><span class="line">    succ.prev = newNode;                                <span class="comment">// succ 的前驱改为新节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)                                   <span class="comment">// 如果插入位置在头部</span></span><br><span class="line">        first = newNode;                                <span class="comment">// 更新头指针</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;                            <span class="comment">// 前驱的 next 指向新节点</span></span><br><span class="line"></span><br><span class="line">    size++;                                             <span class="comment">// 链表大小 +1</span></span><br><span class="line">    modCount++;                                         <span class="comment">// 修改次数 +1（fail-fast 用）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-删除元素（Remove）"><a href="#4-删除元素（Remove）" class="headerlink" title="4. 删除元素（Remove）"></a>4. 删除元素（Remove）</h5><p><strong><code>public E remove(int index)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>检查索引越界。</li>
<li>用 <code>node(index)</code> 找到要删除的节点 <code>x</code>。</li>
<li>调用 <code>unlink(Node&lt;E&gt; x)</code> 执行删除。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。同样，主要时间耗费在 <code>node(index)</code> 查找上，<strong>实际的删除操作（修改指针）是 <code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;       <span class="comment">// 要删除的元素</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;    <span class="comment">// 前驱节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;             <span class="comment">// 1. 如果前驱为null，说明x是头节点</span></span><br><span class="line">        first = next;               <span class="comment">//    让first指向x的后继</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;           <span class="comment">// 2. 否则，让前驱节点的next绕过x，指向x的后继</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;              <span class="comment">//    帮助GC</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;             <span class="comment">// 3. 如果后继为null，说明x是尾节点</span></span><br><span class="line">        last = prev;                <span class="comment">//    让last指向x的前驱</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;           <span class="comment">// 4. 否则，让后继节点的prev绕过x，指向x的前驱</span></span><br><span class="line">        x.next = <span class="literal">null</span>;              <span class="comment">//    帮助GC</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;                  <span class="comment">// 5. 清空数据，帮助GC</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-获取与修改元素（Get-Set）"><a href="#5-获取与修改元素（Get-Set）" class="headerlink" title="5. 获取与修改元素（Get &amp; Set）"></a>5. 获取与修改元素（Get &amp; Set）</h5><ul>
<li><p><strong><code>public E get(int index)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>检查索引越界。</li>
<li>调用 <code>node(index)</code> 遍历找到对应节点。</li>
<li>返回 <code>node.item</code>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E set(int index, E element)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>检查索引越界。</li>
<li>调用 <code>node(index)</code> 找到对应节点 <code>x</code>。</li>
<li>保存旧值 <code>E oldVal = x.item</code>。</li>
<li>将新值赋给节点 <code>x.item = element</code>。</li>
<li>返回旧值。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-典型应用场景"><a href="#6-典型应用场景" class="headerlink" title="6. 典型应用场景"></a>6. 典型应用场景</h5><ol>
<li><strong>频繁在列表中间进行插入和删除操作</strong></li>
</ol>
<p>​	这是 LinkedList <strong>最经典、最合适的应用场景</strong>。</p>
<ul>
<li><strong>场景描述</strong>：你的业务逻辑需要频繁地在列表的<strong>任意位置</strong>（而不仅仅是末尾）添加或移除元素。</li>
<li><strong>原理</strong>：对于 LinkedList，只要你已经拥有了要操作的节点的引用（例如，通过列表迭代器定位到了那里），插入和删除操作的时间复杂度就是 <strong>O(1)</strong>。相比之下，ArrayList 需要移动后续所有元素，是 <strong>O(n)</strong> 的操作。</li>
<li><strong>举例</strong>：<ul>
<li><strong>任务管理系统</strong>：一个待办事项列表，用户可以随时在列表中间插入高优先级的任务，或者完成&#x2F;删除任意位置的任务。</li>
<li><strong>音乐播放列表</strong>：用户频繁地拖动歌曲改变顺序（先删除再插入），或者从播放列表中间删除歌曲。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>需要实现栈、队列或双端队列</strong></li>
</ol>
<ul>
<li><p><strong>场景描述</strong>：你需要一个后进先出（LIFO）的栈，或者先进先出（FIFO）的队列，或者两端都能进出的双端队列。</p>
</li>
<li><p><strong>原理</strong>：由于 <code>LinkedList</code> 实现了 <code>Deque</code> 接口，它天然提供了这些数据结构所需的所有方法，并且在这些操作的性能上都很好（均为 O(1)）。</p>
</li>
<li><p><strong>举例</strong>：</p>
<ul>
<li><p><strong>作为栈使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;A&quot;</span>); <span class="comment">// 入栈</span></span><br><span class="line">stack.push(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop(); <span class="comment">// 出栈，返回 &quot;B&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>作为队列使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.offer(<span class="string">&quot;A&quot;</span>); <span class="comment">// 入队</span></span><br><span class="line">queue.offer(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 出队，返回 &quot;A&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>作为双端队列（Deque）使用</strong>：适合实现“撤销”功能（栈）和“历史记录”功能（队列）的结合。</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>内存使用效率不确定的场景</strong></li>
</ol>
<ul>
<li><strong>场景描述</strong>：列表的大小变化非常剧烈且不可预测，有时很大，有时很小。</li>
<li><strong>原理</strong>：<code>LinkedList</code> 的每个元素都是独立分配内存的，添加元素就分配一个新节点，删除元素就释放一个节点，没有像 <code>ArrayList</code> 那样“预分配”的容量概念，因此不会造成内存的空闲浪费。但请注意，每个节点因为要存储两个指针，所以单个元素的内存开销比 ArrayList 大。</li>
<li><strong>举例</strong>：处理一个数据流，其流量极不稳定，可能长时间为空，也可能瞬间涌入大量数据。</li>
</ul>
<hr>
<h4 id="2-2-5-CopyOnWriteArrayList【了解】"><a href="#2-2-5-CopyOnWriteArrayList【了解】" class="headerlink" title="2.2.5 CopyOnWriteArrayList【了解】"></a>2.2.5 CopyOnWriteArrayList【了解】</h4><h5 id="1-核心概念-2"><a href="#1-核心概念-2" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>CopyOnWriteArrayList</code> 是 <code>List</code> 接口的一个<strong>线程安全</strong>的实现。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有序（Ordered）</strong>： 元素按照插入顺序存放。</li>
<li><strong>可重复（Allows Duplicates）</strong>： 允许存储相同的元素和 <code>null</code>。</li>
<li><strong>有索引（Indexed）</strong>： 可以通过从 <code>0</code> 开始的索引访问元素。</li>
<li><strong>线程安全（Thread-Safe）</strong>： 所有可变操作（add, set, remove等）都是通过<strong>创建底层数组的新副本</strong>来实现的，这保证了线程安全。</li>
<li><strong>写时复制（Copy-On-Write）</strong>： 这是实现线程安全的核心机制。任何会修改集合结构的操作（写操作）都不是在原数组上进行的，而是先复制一份新的数组，在新数组上进行修改，修改完成后，再将集合的数组引用指向这个新数组。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个 <strong><code>volatile Object[] array</code></strong> 数组来存储所有元素。<strong>读操作</strong>利用 <code>volatile</code> 的可见性实现了<strong>无锁访问</strong>，极大地提高了读性能；<strong>写操作</strong>通过**锁（ReentrantLock + synchronized）**来保证原子性，并在锁内进行“复制-修改-替换”的流程。</li>
<li><strong>设计思想</strong>：<strong>在多线程下用空间换时间，通过写时复制保证读操作无锁且一致，适合读多写少的场景</strong>。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-2"><a href="#2-底层数据结构和关键属性-2" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>CopyOnWriteArrayList</code> 的源码（以OpenJDK 21 为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保护所有修改操作的锁  (在两者都可以的情况下，我们稍微更倾向于使用内置监视器而不是 ReentrantLock)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/** 该数组仅通过 getArray/setArray 访问. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前的数组快照（用于读操作）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子地设置数组引用（用于写操作完成时）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">        array = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>array</code></strong>： 这是 <code>CopyOnWriteArrayList</code> 的核心。所有读操作都通过<code>getArray</code>访问该数组的快照。<code>volatile</code> 保证了<strong>内存可见性</strong>。当一个写操作完成并调用 <code>setArray</code> 后，所有其他线程能立即看到这个新数组。</li>
<li><strong><code>lock</code></strong>： 保证所有的写操作（add, set, remove）是互斥的，同一时间只能有一个线程进行数组的复制和修改。<ul>
<li><strong>变化</strong>：<ul>
<li><strong>JDK 8</strong>：使用 <code>ReentrantLock</code> (<code>final ReentrantLock lock = new ReentrantLock();</code>)。</li>
<li><strong>JDK 11+</strong>：使用原生的 <code>synchronized</code> 锁对象 (<code>Object lock</code>)。</li>
</ul>
</li>
<li><strong>为什么改回 <code>synchronized</code>？</strong>：随着 JVM 版本的升级，<code>synchronized</code>引入锁升级等技术，性能得到了巨大的优化，在某些场景下性能甚至优于 <code>ReentrantLock</code>。此外，使用简单的 <code>Object</code> 还可以减少内存占用（相比于 <code>ReentrantLock</code> 对象）。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-1"><a href="#3-构造方法与初始化-1" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>CopyOnWriteArrayList</code> 提供了三种构造方式：</p>
<ol>
<li><p><strong><code>public CopyOnWriteArrayList()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 初始化一个长度为 0 的空数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个空列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]); <span class="comment">// 初始化为一个空数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 将传入集合的元素转换为数组，并将此数组设置为底层 <code>array</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个包含指定集合元素的列表，</span></span><br><span class="line"><span class="comment"> * 顺序由集合的迭代器决定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// c.toArray 可能不会返回 Object[]</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public CopyOnWriteArrayList(E[] toCopyIn)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 使用 <code>Arrays.copyOf</code> 将传入数组的元素复制到一个新数组中，并将此新数组设置为底层 <code>array</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个包含给定数组副本的列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> &#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-添加元素-Add"><a href="#4-添加元素-Add" class="headerlink" title="4. 添加元素(Add)"></a>4. 添加元素(Add)</h5><p><strong><code>public boolean add(E e)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li><strong>加锁</strong>：防止多个线程同时写入，保证线程安全。</li>
<li><strong>获取快照</strong>：取得当前存储数据的数组副本。</li>
<li><strong>复制数组</strong>：通过 <code>Arrays.copyOf</code> 复制一个新的数组，长度 +1。</li>
<li><strong>写入新元素</strong>：把新元素放到新数组的最后一位。</li>
<li><strong>替换引用</strong>：底层数组引用替换为新数组。</li>
<li><strong>释放锁</strong>：保证其他线程可以继续写。</li>
<li><strong>返回 true</strong>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 线程安全，使用独占锁保证写操作互斥</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;  </span><br><span class="line">        <span class="comment">// 2. 获取当前底层数组（快照）</span></span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="comment">// 3. 获取当前数组长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> es.length;</span><br><span class="line">        <span class="comment">// 4. 创建新数组，长度比原数组多 1</span></span><br><span class="line">        <span class="comment">//   -&gt; 注意不是扩容机制，而是直接复制一份新数组</span></span><br><span class="line">        es = Arrays.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 5. 在新数组最后一个位置放入新元素</span></span><br><span class="line">        es[len] = e;</span><br><span class="line">        <span class="comment">// 6. 将底层数组引用指向新数组</span></span><br><span class="line">        setArray(es);</span><br><span class="line">        <span class="comment">// 7. 返回添加成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-获取元素-Get"><a href="#5-获取元素-Get" class="headerlink" title="5. 获取元素(Get)"></a>5. 获取元素(Get)</h5><p><strong><code>public E get(int index)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>获取当前时刻数组的引用</li>
<li>访问数组下标</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elementAt(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; E <span class="title function_">elementAt</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-修改元素-Set"><a href="#6-修改元素-Set" class="headerlink" title="6. 修改元素(Set)"></a>6. 修改元素(Set)</h5><p><strong><code>public E set(int index, E element)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li><strong>加锁</strong>：子列表操作必须同步，避免写操作冲突。</li>
<li><strong>rangeCheck(index)</strong>：确认 <code>index</code> 在子列表范围内。</li>
<li><strong>checkForComodification()</strong>：确保子列表和父列表共享同一个快照数组。<ul>
<li><strong>调用父列表的 <code>set</code> 方法</strong>：真正的写操作由 <code>CopyOnWriteArrayList.this.set()</code> 完成。<ul>
<li>父列表的 <code>set()</code> 会执行：<ul>
<li>复制整个底层数组（写时复制机制，O(n)）。</li>
<li>修改指定位置的元素。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>更新 expectedArray</strong>：子列表记录最新快照，防止后续一致性错误。</li>
<li><strong>返回旧值</strong>：返回被替换掉的元素。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 子列表加锁，保证线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;  </span><br><span class="line">        <span class="comment">// 2. 检查下标是否越界（0 &lt;= index &lt; size）</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">// 3. 检查子列表是否和父列表的快照一致</span></span><br><span class="line">        <span class="comment">//    避免并发修改引发数据不一致</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// 4. 调用父列表 CopyOnWriteArrayList 的 set() 方法</span></span><br><span class="line">        <span class="comment">//    offset 表示子列表起始偏移量</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> CopyOnWriteArrayList.<span class="built_in">this</span>.set(offset + index, element);</span><br><span class="line">        <span class="comment">// 5. 更新当前子列表的 expectedArray 引用</span></span><br><span class="line">        <span class="comment">//    让子列表快照保持和父列表一致</span></span><br><span class="line">        expectedArray = getArray();</span><br><span class="line">        <span class="comment">// 6. 返回被替换掉的旧值</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-删除元素-Remove"><a href="#7-删除元素-Remove" class="headerlink" title="7. 删除元素(Remove)"></a>7. 删除元素(Remove)</h5><p><strong><code>public E remove(int index)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li><p><strong>加锁</strong> ： 保证并发删除安全。</p>
</li>
<li><p><strong>获取快照</strong> ： 拿到当前底层数组。</p>
</li>
<li><p><strong>定位要删除的元素</strong> ： 存储在 <code>oldValue</code>。</p>
</li>
<li><p><strong>判断是否删除尾部</strong>：</p>
<ul>
<li><p><strong>尾部删除</strong>：直接 <code>Arrays.copyOf()</code> 拷贝前 <code>len-1</code> 个元素。</p>
</li>
<li><p><strong>中间删除</strong>：新建一个数组，分别拷贝 <strong>前半部分</strong> 和 <strong>后半部分</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>更新底层数组引用</strong> ： 指向新数组。</p>
</li>
<li><p><strong>返回被删除的元素</strong>。</p>
</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。最坏情况（删除第一个元素）需要复制 <code>n-1</code> 个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 加锁，保证写操作线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;  </span><br><span class="line">        <span class="comment">// 2. 获取当前底层数组（快照）</span></span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> es.length;</span><br><span class="line">        <span class="comment">// 3. 取出要删除的元素（返回值用）</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementAt(es, index);</span><br><span class="line">        <span class="comment">// 4. 计算要移动的元素个数</span></span><br><span class="line">        <span class="comment">//    如果删的是中间元素，右边的部分要整体往前挪</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index - <span class="number">1</span>;</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="comment">// 5. 如果删除的是最后一个元素（尾删）</span></span><br><span class="line">        <span class="comment">//    直接复制前 len-1 个即可</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            newElements = Arrays.copyOf(es, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 如果删除的是中间的元素</span></span><br><span class="line">            <span class="comment">//    需要新建一个数组（比原来少 1）</span></span><br><span class="line">            newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 6.1 拷贝前半部分（[0, index-1]）</span></span><br><span class="line">            System.arraycopy(es, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 6.2 拷贝后半部分（[index+1, len-1]）</span></span><br><span class="line">            System.arraycopy(es, index + <span class="number">1</span>, newElements, index, numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7. 用新数组替换旧数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="comment">// 8. 返回被删除的旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="8-遍历与迭代器-Iterator"><a href="#8-遍历与迭代器-Iterator" class="headerlink" title="8. 遍历与迭代器(Iterator)"></a>8. 遍历与迭代器(Iterator)</h5><p><strong><code>public Iterator&lt;E&gt; iterator()</code></strong>：</p>
<ul>
<li><p>返回的迭代器是基于<strong>调用 <code>iterator()</code> 方法时</strong>的底层数组快照（<code>snapshot</code>）工作的。</p>
</li>
<li><p>这个迭代器在构造后就不再受后续任何对集合修改操作的影响。<strong>它在迭代过程中不会抛出 <code>ConcurrentModificationException</code></strong>。</p>
</li>
<li><p><strong>不支持</strong>在迭代过程中通过迭代器的 <code>remove()</code>、<code>set()</code>、<code>add()</code> 方法修改集合，调用这些方法会直接抛出 <code>UnsupportedOperationException</code>。</p>
</li>
<li><p><strong>特性</strong>： 这种迭代器被称为 <strong>“弱一致性”（Weakly Consistent）</strong> 迭代器。它反映的是创建迭代器那一刻的集合状态，但不保证能反映迭代过程中集合的后续修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">COWIterator</span>&lt;E&gt;(getArray(), <span class="number">0</span>); <span class="comment">// 传入当前数组快照</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">COWIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/** 迭代器创建时刻的数组快照 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">    </span><br><span class="line">    COWIterator(Object[] elements, <span class="type">int</span> initialCursor) &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements; <span class="comment">// 持有快照引用，后续写操作与此快照无关</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(); <span class="comment">// 不支持修改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 其他方法同样不支持修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="9-典型应用场景"><a href="#9-典型应用场景" class="headerlink" title="9. 典型应用场景"></a>9. 典型应用场景</h5><ol>
<li><strong>事件监听器或回调函数列表（Most Classic Use Case）</strong></li>
</ol>
<p>这是 <code>CopyOnWriteArrayList</code> <strong>最经典、最完美的应用场景</strong>。</p>
<ul>
<li><strong>场景描述</strong>：在一个事件发布&#x2F;订阅模型中，需要维护一个监听器列表。事件发生时，需要遍历这个列表并通知每一个监听器。</li>
<li><strong>为何适用</strong>：<ul>
<li><strong>读多写极少</strong>：<strong>注册&#x2F;注销监听器（写操作）</strong> 通常发生在系统初始化或配置阶段，频率极低。而<strong>触发事件（读操作，即遍历列表）</strong> 会发生成千上万次，频率极高。</li>
<li><strong>线程安全需求</strong>：事件发布和监听器的注册注销可能来自不同线程。</li>
<li><strong>避免 <code>ConcurrentModificationException</code></strong>：使用普通 <code>ArrayList</code> 时，如果在遍历通知监听器的过程中，另一个线程注销了一个监听器，就会抛出此异常。而 <code>CopyOnWriteArrayList</code> 的迭代器基于旧的快照，遍历过程不会受任何写操作影响，非常安全。</li>
</ul>
</li>
<li><strong>举例</strong>：<ul>
<li>Java Swing&#x2F;AWT 中的 GUI 事件监听器管理。</li>
<li>Spring 框架中的应用事件（<code>ApplicationEvent</code>）和监听器（<code>ApplicationListener</code>）。</li>
<li>任何自定义的观察者模式实现。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>读多写少的“黑名单”或“白名单”</strong></li>
</ol>
<ul>
<li><strong>场景描述</strong>：你需要一个内存中的名单来进行快速查询（例如，检查一个用户ID是否在黑名单中），而这个名单只会被很少量的更新。</li>
<li><strong>为何适用</strong>：<ul>
<li><strong>查询（读）操作</strong>是主体，可能每秒发生几万次，需要极快的速度和无锁。</li>
<li><strong>更新（写）操作</strong>可能每天只有几次，由管理员后台操作。即使复制整个数组，开销也完全可以接受。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>只读操作远多于修改操作的缓存</strong></li>
</ol>
<ul>
<li><strong>场景描述</strong>：缓存一些几乎不变的数据供所有线程频繁读取，偶尔需要重新加载整个缓存。</li>
<li><strong>为何适用</strong>：<ul>
<li>读取无需加锁，性能极高。</li>
<li>当数据源变化需要更新缓存时，直接创建一个新的数组并替换掉旧的（一次写操作）。虽然这次写操作开销大，但频率极低，可以接受。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-6-Vector【过时】"><a href="#2-2-6-Vector【过时】" class="headerlink" title="2.2.6 Vector【过时】"></a>2.2.6 Vector【过时】</h4><h5 id="1-核心概念-3"><a href="#1-核心概念-3" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><p><code>Vector</code> 是 Java 早期版本（1.0）中就存在的一个集合类，它实现了<strong>动态数组</strong>的数据结构，类似于 <code>ArrayList</code>。它的主要特点包括：</p>
<ol>
<li><strong>动态扩容</strong>：当元素数量超过当前容量时，它会自动增长其内部数组的大小（默认增长一倍）。</li>
<li><strong>线程安全</strong>：其几乎所有方法（如 <code>add</code>, <code>get</code>, <code>size</code>）都使用了 <strong><code>synchronized</code></strong> 关键字进行同步，保证了在多线程环境下的线程安全。</li>
<li><strong>顺序访问</strong>：像数组一样，它通过整数索引来访问元素，提供了快速的随机访问能力。</li>
<li><strong>遗留类</strong>：它是 Java 集合框架（Java Collections Framework, 始于 JDK 1.2）诞生之前的类，后来为了融入新的框架，对其进行了改造，使其实现了 <code>List</code> 接口。</li>
</ol>
<hr>
<h5 id="2-性能开销"><a href="#2-性能开销" class="headerlink" title="2. 性能开销"></a>2. 性能开销</h5><p><code>Vector</code> 的线程安全是通过在每个方法上添加 <strong><code>synchronized</code></strong> 同步锁来实现的。</p>
<ul>
<li><strong>单线程场景下的性能损失</strong>：在绝大多数不需要线程安全的单线程应用场景中（这类场景其实占大多数），每次调用 <code>add()</code>, <code>get()</code> 等方法都会进行一次不必要的加锁和解锁操作。这带来了显著的性能开销。</li>
<li><strong>对比 <code>ArrayList</code></strong>：<code>ArrayList</code> 没有使用任何同步机制，因此在单线程环境下速度远快于 <code>Vector</code>。现代开发哲学是 <strong>“默认非线程安全，需要时再由开发者控制同步”</strong>，这样能为大多数场景提供最佳性能。</li>
</ul>
<hr>
<h5 id="3-功能陈旧且设计不佳"><a href="#3-功能陈旧且设计不佳" class="headerlink" title="3. 功能陈旧且设计不佳"></a>3. 功能陈旧且设计不佳</h5><p><code>Vector</code> 是一个遗留类，它有一些在现代集合框架看来比较怪异的设计。</p>
<ul>
<li><strong>枚举器（Enumeration）</strong>：<code>Vector</code> 提供了一个 <code>elements()</code> 方法来返回一个 <code>Enumeration</code> 接口的实例来遍历集合。这是一个古老的迭代器，功能不如后来的 <code>Iterator</code> 强大（例如，<code>Iterator</code> 支持安全的 <code>remove()</code> 操作，而 <code>Enumeration</code> 不支持）。</li>
<li><strong>冗余的方法</strong>：为了保持向后兼容，它拥有一些独特的方法，如 <code>addElement()</code>, <code>elementAt()</code> 等，这些方法与从 <code>List</code> 接口继承来的 <code>add()</code>, <code>get()</code> 功能重复，导致 API 变得臃肿和不清晰。</li>
</ul>
<hr>
<h5 id="4-替代方案"><a href="#4-替代方案" class="headerlink" title="4. 替代方案"></a>4. 替代方案</h5><p>Java 集合框架（Collections Framework）提供了更多、更灵活、更高效的选择。</p>
<ul>
<li><strong>单线程替代品：<code>ArrayList</code></strong><br>在不需要线程安全的情况下，<strong><code>ArrayList</code> 是毫无疑问的首选</strong>。它没有任何同步开销，性能卓越。</li>
<li><strong>多线程替代品：</strong><ul>
<li><strong><code>Collections.synchronizedList()</code></strong>：如果你需要一个线程安全的列表，可以使用 <code>Collections.synchronizedList(new ArrayList())</code> 来包装一个 <code>ArrayList</code>。这提供了和 <code>Vector</code> 类似的同步行为，但更加灵活（你可以选择何时需要同步包装）。</li>
<li><strong><code>CopyOnWriteArrayList</code></strong>：这是 <code>java.util.concurrent</code> 包下的一个高级并发集合。它采用“写时复制”技术，对于<strong>读多写少</strong>的并发场景性能极高。所有的读操作都不需要加锁，只有在写入时才会复制底层数组。它在概念和实现上都比古老的 <code>Vector</code> 更先进。</li>
<li><strong>其他并发集合</strong>：根据不同的场景，还有 <code>ConcurrentLinkedQueue</code> 等更多选择。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-7-Stack【过时】"><a href="#2-2-7-Stack【过时】" class="headerlink" title="2.2.7 Stack【过时】"></a>2.2.7 Stack【过时】</h4><h5 id="1-核心概念-4"><a href="#1-核心概念-4" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><p><code>Stack</code> 类是 Java 早期版本（JDK 1.0）中提供的一个集合类，它代表了一个<strong>后进先出</strong>（LIFO, Last-In-First-Out）的<strong>对象栈</strong>。你可以把它想象成一摞盘子，你总是取最上面的那个（最后放上去的），新的盘子也只能放在最上面。</p>
<p>它继承自 <code>Vector</code> 类，这意味着它<strong>内部使用数组实现</strong>，并且所有<strong>基本操作都是线程安全</strong>的（因为它的父类 <code>Vector</code> 的方法是 <code>synchronized</code> 的）。</p>
<hr>
<h5 id="2-糟糕的继承"><a href="#2-糟糕的继承" class="headerlink" title="2. 糟糕的继承"></a>2. 糟糕的继承</h5><p>这是 <code>Stack</code> 最根本的设计缺陷。栈应该是一个只提供 <code>push</code>、<code>pop</code>、<code>peek</code> 等操作的接口，但 Java 的 <code>Stack</code> 却是一个具体的类，并且继承了 <code>Vector</code> 的所有公共方法。</p>
<p>这意味着，可以完全<strong>破坏栈的 LIFO 原则</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本应是栈，却可以使用 Vector 的方法随意操作！</span></span><br><span class="line">stack.add(<span class="number">1</span>, <span class="string">&quot;C&quot;</span>); <span class="comment">// 在中间插入元素！这违反了栈的原则</span></span><br><span class="line"><span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> stack.get(<span class="number">0</span>); <span class="comment">// 随机访问底部元素！</span></span><br><span class="line">stack.remove(<span class="number">0</span>); <span class="comment">// 移除底部元素！</span></span><br><span class="line"></span><br><span class="line">System.out.println(stack); <span class="comment">// 输出什么？栈的结构完全被破坏了。</span></span><br></pre></td></tr></table></figure>

<p>一个真正的栈应该只允许在顶端操作，而 <code>Stack</code> 类暴露了太多不属于栈概念的方法，这使得它非常不严谨。</p>
<hr>
<h5 id="3-性能开销"><a href="#3-性能开销" class="headerlink" title="3. 性能开销"></a>3. 性能开销</h5><p>和 <code>Vector</code> 一样，<code>Stack</code> 的方法是同步的（<code>synchronized</code>）。在绝大多数<strong>单线程</strong>使用栈的场景下（例如算法实现、表达式求值），这种同步带来了<strong>不必要的性能开销</strong>。</p>
<hr>
<h5 id="4-官方推荐使用-Deque-接口及其实现"><a href="#4-官方推荐使用-Deque-接口及其实现" class="headerlink" title="4. 官方推荐使用 Deque 接口及其实现"></a>4. 官方推荐使用 <code>Deque</code> 接口及其实现</h5><p>在 Java 1.6 之后，官方推荐使用 <strong><code>Deque</code></strong>（双端队列）接口来实现栈的功能。<code>Deque</code> 提供了更完整、更一致且性能更好的 LIFO 栈操作方&#96;法。</p>
<blockquote>
<p><strong>JDK 文档原文（<code>Stack</code> 类的注释中）：</strong><br><strong>A more complete and consistent set of LIFO stack operations is provided by the <code>Deque</code> interface and its implementations, which should be used in preference to this class.</strong><br>（<code>Deque</code> 接口及其实现提供了一组更完整、更一致的 LIFO 栈操作，<strong>应该优先于这个类（指Stack）使用</strong>。）</p>
</blockquote>
<hr>
<h5 id="5-替代方案"><a href="#5-替代方案" class="headerlink" title="5. 替代方案"></a>5. 替代方案</h5><p><code>Deque</code> 接口的实现类，如 <strong><code>ArrayDeque</code></strong> 和 <strong><code>LinkedList</code></strong>，是取代 <code>Stack</code> 的完美选择。其中，<strong><code>ArrayDeque</code></strong> 在大多数场景下是性能最好的选择。</p>
<hr>
<h4 id="2-2-8-实现类的对比"><a href="#2-2-8-实现类的对比" class="headerlink" title="2.2.8 实现类的对比"></a>2.2.8 实现类的对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>ArrayList</code></th>
<th align="left"><code>LinkedList</code></th>
<th align="left"><code>Vector</code></th>
<th align="left"><code>Stack</code></th>
<th align="left"><strong><code>CopyOnWriteArrayList</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层数据结构</strong></td>
<td align="left"><strong>动态数组（Object[]）</strong></td>
<td align="left"><strong>双向链表（Node）</strong></td>
<td align="left"><strong>动态数组（Object[]）</strong></td>
<td align="left"><strong>动态数组（Object[]）</strong>（继承自<code>Vector</code>）</td>
<td align="left"><strong>动态数组（Object[]）</strong></td>
</tr>
<tr>
<td align="left"><strong>所在包</strong></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><strong><code>java.util.concurrent</code></strong></td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong>（方法大多用 <code>synchronized</code> 修饰）</td>
<td align="left"><strong>是</strong>（继承自<code>Vector</code>）</td>
<td align="left"><strong>是</strong>（通过写时复制和锁实现）</td>
</tr>
<tr>
<td align="left"><strong>锁机制</strong></td>
<td align="left">无</td>
<td align="left">无</td>
<td align="left">悲观锁（<code>synchronized</code>方法级）</td>
<td align="left">悲观锁（<code>synchronized</code>方法级）</td>
<td align="left"><strong>写时复制 + 独占锁（<code>ReentrantLock</code>）</strong></td>
</tr>
<tr>
<td align="left"><strong>随机访问性能</strong></td>
<td align="left"><strong>极快（O(1)）</strong></td>
<td align="left"><strong>慢（O(n)）</strong></td>
<td align="left"><strong>快（O(1)）</strong></td>
<td align="left"><strong>快（O(1)）</strong></td>
<td align="left"><strong>快（O(1)）</strong>（读操作无锁）</td>
</tr>
<tr>
<td align="left"><strong>头部插入&#x2F;删除</strong></td>
<td align="left"><strong>慢（O(n)）</strong></td>
<td align="left"><strong>极快（O(1)）</strong></td>
<td align="left"><strong>慢（O(n)）</strong></td>
<td align="left"><strong>不应在此操作</strong></td>
<td align="left"><strong>极慢（O(n)）</strong>（需要复制整个数组）</td>
</tr>
<tr>
<td align="left"><strong>尾部插入&#x2F;删除</strong></td>
<td align="left"><strong>快（O(1)）</strong>（摊销）</td>
<td align="left"><strong>快（O(1)）</strong></td>
<td align="left"><strong>快（O(1)）</strong></td>
<td align="left"><strong>快（O(1)）</strong>（栈顶操作）</td>
<td align="left"><strong>极慢（O(n)）</strong>（需要复制整个数组）</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">较小（可能有空闲容量）</td>
<td align="left">较大（需存储指针）</td>
<td align="left">类似<code>ArrayList</code></td>
<td align="left">类似<code>Vector</code></td>
<td align="left"><strong>很大</strong>（写操作时会短暂出现两份完整数据）</td>
</tr>
<tr>
<td align="left"><strong>迭代器</strong></td>
<td align="left"><strong>快速失败（Fail-Fast）</strong></td>
<td align="left"><strong>快速失败（Fail-Fast）</strong></td>
<td align="left"><strong>快速失败（Fail-Fast）</strong></td>
<td align="left"><strong>快速失败（Fail-Fast）</strong></td>
<td align="left"><strong>弱一致性（Weakly Consistent）</strong>（不会抛出<code>CME</code>）</td>
</tr>
<tr>
<td align="left"><strong>扩容机制</strong></td>
<td align="left"><strong>当前容量 * 1.5</strong></td>
<td align="left"><strong>无扩容</strong></td>
<td align="left"><strong>当前容量 * 2</strong></td>
<td align="left"><strong>当前容量 * 2</strong></td>
<td align="left"><strong>每次写操作都按需扩容（len+1或其他）</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="2-3-Set-接口及其实现类"><a href="#2-3-Set-接口及其实现类" class="headerlink" title="2.3 Set 接口及其实现类"></a>2.3 <strong>Set 接口及其实现类</strong></h3><p><code>Set</code> 是 <code>Collection</code> 接口的一个极其重要的子接口。它代表了一个<strong>无序的、不重复、无索引</strong>元素序列。</p>
<h4 id="2-3-1-核心特征"><a href="#2-3-1-核心特征" class="headerlink" title="2.3.1 核心特征"></a>2.3.1 核心特征</h4><ol>
<li><strong>不重复</strong>：这是 <code>Set</code> 最核心、最重要的特性。一个 <code>Set</code> 中不能包含两个相同的元素。更具体地说，<code>Set</code> 不允许包含满足 <code>e1.equals(e2)</code> 的元素对。</li>
<li><strong>无序性（大多数实现）</strong>：<code>Set</code> 不保证维护元素的插入顺序。当然，也有特例（如 <code>LinkedHashSet</code>）和特殊情况（如 <code>TreeSet</code> 根据元素排序）。</li>
<li><strong>无索引</strong>：<code>Set</code> 不像 <code>List</code> 那样有位置的概念，因此没有 <code>get(int index)</code> 方法</li>
<li><strong>最多一个 null 元素</strong>：由于不允许重复，一个 <code>Set</code> 最多只能包含一个 <code>null</code> 元素。</li>
</ol>
<p>正因为这些特性，<code>Set</code> 是处理<strong>去重</strong>业务的完美选择。</p>
<hr>
<h4 id="2-3-2-HashSet【核心掌握】"><a href="#2-3-2-HashSet【核心掌握】" class="headerlink" title="2.3.2 HashSet【核心掌握】"></a>2.3.2 HashSet【核心掌握】</h4><h5 id="1-核心概念-5"><a href="#1-核心概念-5" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>HashSet</code> 是 <code>Set</code> 接口的一个<strong>基于哈希表的实现</strong>。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>唯一性（Uniqueness）</strong>： 不允许存储重复的元素。</li>
<li><strong>无序性（Unordered）</strong>： 不保证元素的迭代顺序，特别是不能保证顺序恒久不变（<code>LinkedHashSet</code> 除外，它维护插入顺序）。</li>
<li><strong>允许Null元素</strong>： 允许存储一个 <code>null</code> 元素。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 多线程环境下未经同步直接使用会导致不确定的结果。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层本质上是一个 <strong><code>HashMap</code></strong> 实例。<code>HashSet</code> 的元素被存储为这个 <code>HashMap</code> 的键（Key），而所有的键都共享同一个<strong>虚拟值（PRESENT）</strong>。</li>
<li><strong>设计思想</strong>： 利用哈希表存储元素，依赖 <code>hashCode</code> 和 <code>equals</code> 保证唯一性，以 O(1) 的代价实现高效的去重和查询。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-3"><a href="#2-底层数据结构和关键属性-3" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>HashSet</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet底层存储数据的HashMap实例。</span></span><br><span class="line"><span class="comment">     * HashSet的所有元素实际上是作为该HashMap的Key来存储的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个静态的、不可变的虚拟对象，用于作为底层HashMap中每个键对应的值。</span></span><br><span class="line"><span class="comment">     * 因为HashSet只关心Key，Value无实际意义。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>map</code></strong>： 所有元素都作为键（Key）存储在这个 <code>HashMap</code> 中。</li>
<li><strong><code>PRESENT</code></strong>： 这是 <code>HashSet</code> 的<strong>虚拟值</strong>。所有键（Key）对应的值（Value）都是这个同一个对象的引用，以此节省内存。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-2"><a href="#3-构造方法与初始化-2" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>HashSet</code> 提供了五种构造方式：</p>
<ol>
<li><p><strong><code>public HashSet()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个默认初始容量为16，默认加载因子为0.75的 <code>HashMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>最常用</strong>的构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的空集合；其底层使用的 &#123;<span class="doctag">@code</span> HashMap&#125; 实例</span></span><br><span class="line"><span class="comment"> * 具有默认的初始容量 (16) 和负载因子 (0.75)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public HashSet(int initialCapacity)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个指定初始容量，默认加载因子为0.75的 <code>HashMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>显式指定初始容量</strong>。如果能预估元素数量，可以避免早期扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的空集合；其底层使用的 &#123;<span class="doctag">@code</span> HashMap&#125; 实例</span></span><br><span class="line"><span class="comment"> * 具有指定的初始容量和默认的负载因子 (0.75)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span></span></span><br><span class="line"><span class="comment"> * 如果想创建一个能够容纳预期元素数量的 &#123;<span class="doctag">@code</span> HashSet&#125;，</span></span><br><span class="line"><span class="comment"> * 建议使用 &#123;<span class="doctag">@link</span> #newHashSet(int) newHashSet&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 哈希表的初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量小于 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public HashSet(int initialCapacity, float loadFactor)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个指定初始容量和指定加载因子的 <code>HashMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>更精细地控制哈希表性能</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的空集合；其底层使用的 &#123;<span class="doctag">@code</span> HashMap&#125; 实例</span></span><br><span class="line"><span class="comment"> * 具有指定的初始容量和指定的负载因子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span></span></span><br><span class="line"><span class="comment"> * 如果想创建一个能够容纳预期元素数量的 &#123;<span class="doctag">@code</span> HashSet&#125;，</span></span><br><span class="line"><span class="comment"> * 建议使用 &#123;<span class="doctag">@link</span> #newHashSet(int) newHashSet&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 哈希映射的初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor      哈希映射的负载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量小于 0，或者负载因子不大于 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public HashSet(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个足以容纳指定集合元素的 <code>HashMap</code>（容量为 <code>c.size()</code> 和 12 中的较大者），然后将集合中的所有元素添加到本 <code>HashSet</code> 中。</p>
</li>
<li><p><strong>特点</strong>： <strong>用一个已有集合来构造</strong>，常用于集合去重。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的集合，包含指定集合中的元素。</span></span><br><span class="line"><span class="comment"> * 底层使用的 &#123;<span class="doctag">@code</span> HashMap&#125; 采用默认的负载因子 (0.75)，</span></span><br><span class="line"><span class="comment"> * 并具有足以容纳指定集合中所有元素的初始容量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 要将其元素放入此集合的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    map = HashMap.newHashMap(Math.max(c.size(), <span class="number">12</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-添加元素-Add-与保证元素唯一的机制"><a href="#4-添加元素-Add-与保证元素唯一的机制" class="headerlink" title="4. 添加元素(Add)与保证元素唯一的机制"></a>4. 添加元素(Add)与保证元素唯一的机制</h5><p><strong><code>public boolean add(E e)</code></strong></p>
<ul>
<li><p>底层调用<code>HashMap</code>时间复杂度与处理逻辑与<code>HashMap</code>的<code>put</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果指定的元素尚未存在于此集合中，则将其添加到集合中。</span></span><br><span class="line"><span class="comment"> * 更正式地说，如果此集合中不存在任何元素 &#123;<span class="doctag">@code</span> e2&#125;，</span></span><br><span class="line"><span class="comment"> * 使得 &#123;<span class="doctag">@code</span> Objects.equals(e, e2)&#125; 返回 true，</span></span><br><span class="line"><span class="comment"> * 则将指定元素 &#123;<span class="doctag">@code</span> e&#125; 添加到集合中。</span></span><br><span class="line"><span class="comment"> * 如果此集合已包含该元素，则不做任何更改并返回 &#123;<span class="doctag">@code</span> false&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加到此集合的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此集合之前不包含指定元素，则返回 &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>最佳实践</strong>： 当你要把自定义类的对象放入 <code>HashSet</code>时，<strong>必须重写该类的 <code>hashCode()</code> 和 <code>equals(Object obj)</code> 方法</strong>，并且要保证相等的对象必须具有相等的哈希码。</p>
<hr>
<h5 id="5-删除元素-Remove"><a href="#5-删除元素-Remove" class="headerlink" title="5. 删除元素(Remove)"></a>5. 删除元素(Remove)</h5><p><strong><code>public boolean remove(Object o)</code></strong></p>
<ul>
<li><p>底层调用<code>HashMap</code>时间复杂度与处理逻辑与<code>HashMap</code>的<code>remove</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果指定的元素存在，则将其从集合中移除。</span></span><br><span class="line"><span class="comment"> * 更正式地说，移除集合中满足 &#123;<span class="doctag">@code</span> Objects.equals(o, e)&#125; 的某个元素 &#123;<span class="doctag">@code</span> e&#125;。</span></span><br><span class="line"><span class="comment"> * 如果此集合包含该元素，则返回 &#123;<span class="doctag">@code</span> true&#125;；</span></span><br><span class="line"><span class="comment"> * 换句话说，如果调用导致集合发生了变化，则返回 &#123;<span class="doctag">@code</span> true&#125;。</span></span><br><span class="line"><span class="comment"> * （调用返回后，此集合将不再包含该元素。）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 如果存在，要从此集合中移除的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果集合包含指定元素，则返回 &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-查找元素-Contains"><a href="#6-查找元素-Contains" class="headerlink" title="6. 查找元素(Contains)"></a>6. 查找元素(Contains)</h5><p><strong><code>public boolean contains(Object o)</code></strong></p>
<ul>
<li><p>底层调用<code>HashMap</code>时间复杂度与处理逻辑与<code>HashMap</code>的<code>containsKey</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此集合包含指定的元素，则返回 &#123;<span class="doctag">@code</span> true&#125;。</span></span><br><span class="line"><span class="comment"> * 更正式地说，当且仅当集合中存在某个元素 &#123;<span class="doctag">@code</span> e&#125;，</span></span><br><span class="line"><span class="comment"> * 使得 &#123;<span class="doctag">@code</span> Objects.equals(o, e)&#125; 返回 true 时，返回 &#123;<span class="doctag">@code</span> true&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要测试是否存在于集合中的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此集合包含指定元素，则返回 &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-遍历方式"><a href="#7-遍历方式" class="headerlink" title="7. 遍历方式"></a>7. 遍历方式</h5><p>由于 <code>HashSet</code> 没有索引且无序，不能使用普通的 <code>for</code> 循环（基于索引）遍历。</p>
<ol>
<li><p><strong>迭代器（Iterator）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = hashSet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>增强for循环（for-each）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer element : hashSet) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>forEach + Lambda（Java 8+）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashSet.forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意</strong>： <strong>严禁在遍历过程中使用 <code>HashSet</code> 的 <code>remove()</code> 等方法修改集合结构</strong>，否则会抛出 <code>ConcurrentModificationException</code>。如需遍历时删除，必须使用 <strong><code>Iterator.remove()</code></strong> 方法。</p>
<hr>
<h5 id="8-典型应用场景"><a href="#8-典型应用场景" class="headerlink" title="8. 典型应用场景"></a>8. 典型应用场景</h5><p><strong>1. 数据去重（最经典、最常用的场景）</strong></p>
<p>这是 <code>HashSet</code> 最直接、最广泛的应用。当你有一个数据集合（如列表、数组），需要快速去除其中的重复项时，使用 <code>HashSet</code> 是最高效便捷的方式。</p>
<p><strong>示例场景</strong>：</p>
<ul>
<li><strong>统计一篇文章中使用了多少个不同的单词</strong>：将文章分割成单词，然后全部添加到一个 <code>HashSet</code> 中，重复的单词会被自动过滤，最后 <code>set.size()</code> 就是不同单词的数量。</li>
<li><strong>清洗数据</strong>：从数据库或文件中读取数据，其中可能包含重复记录，使用 <code>HashSet</code> 可以轻松去除重复项。</li>
<li><strong>提取集合中的唯一值</strong>：例如，从一个用户ID列表中找出所有不重复的活跃用户。</li>
</ul>
<hr>
<p><strong>2. 快速成员检测（检查存在性）</strong></p>
<p><strong>示例场景</strong>：</p>
<ul>
<li><strong>白名单&#x2F;黑名单过滤</strong>：将禁止访问的IP地址（黑名单）或允许访问的用户ID（白名单）预先加载到一个 <code>HashSet</code> 中。当有新的请求到来时，只需调用 <code>set.contains(ip)</code> 即可瞬间判断是否允许通过。</li>
<li><strong>避免重复操作</strong>：在处理任务队列时，可以用一个 <code>HashSet</code> 来记录已经处理过的任务ID，防止同一个任务被重复处理。</li>
<li><strong>图算法中记录已访问节点</strong>：在广度优先搜索（BFS）或深度优先搜索（DFS）中，用一个 <code>HashSet</code> 来记录已经访问过的节点，可以高效防止走回头路和无限循环。</li>
</ul>
<hr>
<p><strong>3. 集合运算</strong></p>
<p><strong>示例场景</strong>：</p>
<ul>
<li><strong>社交网络中的共同好友</strong>：用户A的好友列表是一个Set，用户B的好友列表是另一个Set，它们的交集就是A和B的共同好友。</li>
<li><strong>商品推荐系统</strong>：用户喜欢的商品集合为Set A，另一个用户喜欢的商品集合为Set B，A和B的交集可以用于计算用户相似度，而差集（B - A）则可以用于向A用户推荐他可能感兴趣但还没购买的商品。</li>
<li><strong>权限管理</strong>：一个用户拥有多个角色，每个角色有对应的权限集合。计算用户的全部权限就是所有角色权限集的并</li>
</ul>
<hr>
<h4 id="2-3-3-LinkedHashSet【核心掌握】"><a href="#2-3-3-LinkedHashSet【核心掌握】" class="headerlink" title="2.3.3 LinkedHashSet【核心掌握】"></a>2.3.3 LinkedHashSet【核心掌握】</h4><h5 id="1-核心概念-6"><a href="#1-核心概念-6" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>LinkedHashSet</code> 是 <code>HashSet</code> 的一个子类，是 <code>Set</code> 接口的<strong>哈希表和链表实现</strong>。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>唯一性（Uniqueness）</strong>： 继承自 <code>HashSet</code>，不允许存储重复的元素。</li>
<li><strong>有序性（Ordered）</strong>： <strong>维护元素的插入顺序</strong>。迭代顺序即是元素最初被插入集合的顺序（insertion-order）。</li>
<li><strong>允许Null元素</strong>： 允许存储一个 <code>null</code> 元素。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 多线程环境下未经同步直接使用会导致不确定的结果。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层本质上是一个 <strong><code>LinkedHashMap</code></strong> 实例。它继承了 <code>HashSet</code> 的所有特性，并通过维护一个<strong>运行于所有条目的双向链表</strong>来扩展功能，从而定义了迭代顺序。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-4"><a href="#2-底层数据结构和关键属性-4" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p><code>LinkedHashSet</code> 本身没有定义新的属性，它完全依赖于其父类 <code>HashSet</code> 和底层的 <code>LinkedHashMap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2851667679971038690L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 构造方法和其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心机制隐藏在 <code>HashSet</code> 的一个特殊构造器中，该构造器被 <code>LinkedHashSet</code> 使用：</p>
<p>在 <code>HashSet</code> 类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的空的链式哈希集合（仅由 LinkedHashSet 调用的包内私有构造方法）。</span></span><br><span class="line"><span class="comment"> * 底层使用的 HashMap 实例是一个 LinkedHashMap，</span></span><br><span class="line"><span class="comment"> * 其初始容量和负载因子由参数指定。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 哈希映射的初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor      哈希映射的负载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dummy           忽略（用于区分与其他 int、float 构造函数）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量小于 0，或者负载因子不大于 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>底层结构</strong>： <code>LinkedHashMap</code>。它包含一个 <code>HashMap</code> 的桶数组用于快速查找，同时包含一个<strong>双向链表（Doubly-Linked List）</strong> 用于维护顺序。</li>
<li><strong>链表节点</strong>： <code>LinkedHashMap.Entry</code> 继承自 <code>HashMap.Node</code>，并额外添加了 <code>before</code> 和 <code>after</code> 引用，指向前一个和后一个插入的节点，从而串起整个链表。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-3"><a href="#3-构造方法与初始化-3" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>LinkedHashSet</code> 完全复用了 <code>HashSet</code> 的构造逻辑，并通过调用上述特殊构造器来创建 <code>LinkedHashMap</code> 实例。</p>
<ol>
<li><p><strong><code>public LinkedHashSet()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 调用父类 <code>HashSet</code> 的特殊构造器，创建一个初始容量为16，加载因子为0.75的 <code>LinkedHashMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>最常用</strong>的构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>); <span class="comment">// 调用HashSet(int, float, boolean)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public LinkedHashSet(int initialCapacity)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 调用父类构造器，创建一个指定初始容量，默认加载因子为0.75的 <code>LinkedHashMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>显式指定初始容量</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public LinkedHashSet(int initialCapacity, float loadFactor)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 调用父类构造器，创建一个指定初始容量和指定加载因子的 <code>LinkedHashMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>更精细地控制哈希表性能</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public LinkedHashSet(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个足以容纳指定集合元素的 <code>LinkedHashMap</code>（容量为 <code>Math.max(2*c.size(), 11)</code>），然后将集合中的所有元素按迭代器顺序添加到本 <code>LinkedHashSet</code> 中。</p>
</li>
<li><p><strong>特点</strong>： <strong>用一个已有集合来构造</strong>，新集合的迭代顺序由原集合 <code>c</code> 的迭代器顺序决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-维护插入顺序的机制"><a href="#4-维护插入顺序的机制" class="headerlink" title="4. 维护插入顺序的机制"></a>4. 维护插入顺序的机制</h5><p>这是 <code>LinkedHashSet</code> 最核心的特性，其实现完全委托给底层的 <code>LinkedHashMap</code>。</p>
<hr>
<h5 id="5-添加、删除、查找元素"><a href="#5-添加、删除、查找元素" class="headerlink" title="5. 添加、删除、查找元素"></a>5. 添加、删除、查找元素</h5><p><code>LinkedHashSet</code> <strong>没有重写</strong> <code>HashSet</code> 的 <code>add</code>, <code>remove</code>, <code>contains</code> 等方法。它完全继承了 <code>HashSet</code> 的实现，只是底层Map的实现从 <code>HashMap</code> 换成了 <code>LinkedHashMap</code>。</p>
<p>因此，这些操作的<strong>时间复杂度与 <code>HashSet</code> 完全一致</strong>：</p>
<ul>
<li><strong><code>add(E e)</code></strong>, <strong><code>remove(Object o)</code></strong>, <strong><code>contains(Object o)</code></strong>: 平均情况 <code>O(1)</code>，最坏情况 <code>O(n)</code> 或 <code>O(log n)</code>。</li>
</ul>
<p>唯一的区别是，在执行这些操作时，底层的 <code>LinkedHashMap</code> 会额外地维护双向链表，这会带来微小的常数级时间开销，但时间复杂度级别不变。</p>
<hr>
<h5 id="6-遍历方式"><a href="#6-遍历方式" class="headerlink" title="6. 遍历方式"></a>6. 遍历方式</h5><p>与 <code>HashSet</code> 相同，但由于有内部链表维护顺序，遍历结果是有保障的。</p>
<ol>
<li><strong>迭代器（Iterator）</strong>： <strong>按插入顺序</strong>进行迭代。</li>
<li><strong>增强for循环（for-each）</strong>： 底层是迭代器，<strong>按插入顺序</strong>进行迭代。</li>
<li><strong>forEach + Lambda（Java 8+）</strong>: <strong>按插入顺序</strong>进行迭代。</li>
</ol>
<hr>
<h5 id="7-典型应用场景"><a href="#7-典型应用场景" class="headerlink" title="7. 典型应用场景"></a>7. 典型应用场景</h5><p><strong>1. 需要维护插入顺序的去重场景（最核心场景）</strong></p>
<p>当你需要一个集合自动去重，但又希望遍历顺序和添加顺序一致时，<code>LinkedHashSet</code> 是最完美、最直观的选择。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>记录用户操作流水并去重</strong>：需要记录用户一系列唯一的操作（如点击的菜单ID），并且后续需要按照用户的点击顺序来进行分析或回放。使用 <code>HashSet</code> 会丢失顺序，使用 <code>ArrayList</code> 需要自己处理去重逻辑，而 <code>LinkedHashSet</code> 一举两得。</li>
<li><strong>数据清洗与保序</strong>：从文件或数据库中读取数据，需要去除重复行，但必须保持剩余行的原始顺序。例如，处理一个日志文件，要剔除重复的错误记录，但分析时需要按发生时间（即读取顺序）排列。</li>
<li><strong>生成有序的唯一值集合</strong>：例如，从一个无序的、含重复项的列表中提取所有不重复的元素，并要求结果列表保持元素第一次出现的相对顺序。</li>
</ul>
<hr>
<p><strong>2. 实现简单的 LRU（最近最少使用）缓存</strong></p>
<p>LRU 缓存是一种常见的缓存淘汰算法，其核心思想是“如果数据最近被访问过，那么将来被访问的概率也更高”。当缓存满时，它会优先淘汰最久未被访问的数据。</p>
<p><code>LinkedHashSet</code> 本身并不直接支持完整的 LRU 缓存实现（因为它缺乏根据访问重新排序的特性），但它为实现 LRU 缓存提供了绝佳的基础。通过重写其 <code>removeEldestEntry</code> 方法（实际上是在其父类 <code>LinkedHashMap</code> 中），可以非常轻松地创建一个具有 LRU 策略的缓存。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>缓存热点数据</strong>：缓存用户信息、商品信息等，当缓存达到容量上限时，自动淘汰最久未被访问的数据。</li>
<li><strong>连接池、线程池</strong>：管理有限的资源，保持最近被使用的资源。</li>
</ul>
<hr>
<p><strong>3. 需要预测迭代顺序的集合</strong></p>
<p>在某些场景下，集合的迭代顺序必须是可预测的，而不能是 <code>HashSet</code> 那样随机的顺序。<code>LinkedHashSet</code> 提供的稳定的插入顺序，使得程序的行为更加确定，有利于调试和日志记录。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>单元测试</strong>：测试一个返回集合的方法时，如果顺序是固定的，断言就更容易编写和阅读。</li>
<li><strong>生成确定性输出</strong>：例如，根据处理过程生成一个报告，报告中的项目顺序需要与输入源中第一次出现的顺序一致，以确保每次运行的结果都是相同的。</li>
</ul>
<hr>
<h4 id="2-3-4-TreeSet【核心掌握】"><a href="#2-3-4-TreeSet【核心掌握】" class="headerlink" title="2.3.4 TreeSet【核心掌握】"></a>2.3.4 TreeSet【核心掌握】</h4><h5 id="1-核心概念-7"><a href="#1-核心概念-7" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>TreeSet</code> 是 <code>Set</code> 接口的一个<strong>基于红黑树（Red-Black tree）的 NavigableSet 实现</strong>。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>唯一性（Uniqueness）</strong>： 不允许存储重复的元素。</li>
<li><strong>有序性（Ordered）</strong>： <strong>元素按照某种明确的规则自动排序</strong>。排序规则可以是元素的自然顺序（实现 <code>Comparable</code> 接口），也可以是创建 <code>TreeSet</code> 时提供的 <code>Comparator</code> 所定义的顺序。</li>
<li><strong>不允许Null元素</strong>： 如果使用自然排序，或者提供的 <code>Comparator</code> 不支持与 <code>null</code> 比较，尝试添加 <code>null</code> 元素将抛出 <code>NullPointerException</code>。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 多线程环境下未经同步直接使用会导致不确定的结果。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层本质上是一个 <strong><code>TreeMap</code></strong> 实例。<code>TreeSet</code> 的元素被存储为这个 <code>TreeMap</code> 的键（Key），而所有的键都共享同一个<strong>虚拟值（PRESENT）</strong>。元素的排序和存储由 <code>TreeMap</code> 的红黑树数据结构保证。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-5"><a href="#2-底层数据结构和关键属性-5" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>TreeSet</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TreeSet底层存储数据的TreeMap实例。</span></span><br><span class="line"><span class="comment">     * TreeSet的所有元素实际上是作为该TreeMap的Key来存储的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个静态的、不可变的虚拟对象，用于作为底层TreeMap中每个键对应的值。</span></span><br><span class="line"><span class="comment">     * 因为TreeSet只关心Key，Value无实际意义。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>m</code></strong>： 所有元素都作为键（Key）存储在这个 <code>NavigableMap</code>（实际上是 <code>TreeMap</code>）中。</li>
<li><strong><code>PRESENT</code></strong>： 这是 <code>TreeSet</code> 的<strong>虚拟值</strong>。所有键（Key）对应的值（Value）都是这个同一个对象的引用。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-4"><a href="#3-构造方法与初始化-4" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>TreeSet</code> 提供了四种构造方式，决定了其排序规则：</p>
<ol>
<li><p><strong><code>public TreeSet()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个使用元素的<strong>自然顺序</strong>进行排序的 <code>TreeMap</code>。</p>
</li>
<li><p><strong>特点</strong>： 集合中的元素<strong>必须实现 <code>Comparable</code> 接口</strong>，否则在添加时会抛出 <code>ClassCastException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;()); <span class="comment">// 使用自然排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public TreeSet(Comparator&lt;? super E&gt; comparator)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个使用指定的<strong>定制比较器（Comparator）</strong> 进行排序的 <code>TreeMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>优先级高于自然排序</strong>。即使元素实现了 <code>Comparable</code> 接口，也会使用此 <code>Comparator</code> 来排序。允许更灵活的排序逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public TreeSet(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个使用自然顺序的 <code>TreeSet</code>，并将指定集合 <code>c</code> 中的所有元素添加进来。</p>
</li>
<li><p><strong>特点</strong>： 集合 <code>c</code> 中的元素必须实现 <code>Comparable</code> 接口，或者都是可以相互比较的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(); <span class="comment">// 调用无参构造器</span></span><br><span class="line">    addAll(c); <span class="comment">// 添加所有元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public TreeSet(SortedSet&lt;E&gt; s)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个新的 <code>TreeSet</code>，其排序规则与指定的有序集合 <code>s</code> 相同，并包含 <code>s</code> 中的所有元素。</p>
</li>
<li><p><strong>特点</strong>： 高效地复制一个已有有序集合的排序规则和元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(s.comparator()); <span class="comment">// 使用s的比较器</span></span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-添加元素-Add-与保证元素唯一和有序的机制"><a href="#4-添加元素-Add-与保证元素唯一和有序的机制" class="headerlink" title="4. 添加元素(Add)与保证元素唯一和有序的机制"></a>4. 添加元素(Add)与保证元素唯一和有序的机制</h5><p><strong><code>public boolean add(E e)</code></strong></p>
<ul>
<li><p>底层调用<code>TreeMap</code>时间复杂度与处理逻辑与<code>TreeMap</code>的<code>put</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-删除元素-Remove-1"><a href="#5-删除元素-Remove-1" class="headerlink" title="5. 删除元素(Remove)"></a>5. 删除元素(Remove)</h5><p><strong><code>public boolean remove(Object o)</code></strong></p>
<ul>
<li><p>底层调用<code>TreeMap</code>时间复杂度与处理逻辑与<code>TreeMap</code>的<code>remove</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-查找元素-Contains-1"><a href="#6-查找元素-Contains-1" class="headerlink" title="6. 查找元素(Contains)"></a>6. 查找元素(Contains)</h5><p><strong><code>public boolean contains(Object o)</code></strong></p>
<ul>
<li><p>底层调用<code>TreeMap</code>时间复杂度与处理逻辑与<code>TreeMap</code>的<code>containsKey</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-导航方法（Navigation-Methods）"><a href="#7-导航方法（Navigation-Methods）" class="headerlink" title="7. 导航方法（Navigation Methods）"></a>7. 导航方法（Navigation Methods）</h5><p>作为 <code>NavigableSet</code> 的实现，<code>TreeSet</code> 提供了一系列强大的导航方法，用于报告给定搜索目标的最接近匹配项。这是 <code>TreeSet</code> 相比 <code>HashSet</code> 和 <code>LinkedHashSet</code> 的一大优势（底层都是调用<code>TreeMap</code>提供的方法）。</p>
<ul>
<li><strong><code>E ceiling(E e)</code></strong>： 返回<strong>大于等于</strong> <code>e</code> 的<strong>最小</strong>元素，不存在则返回 <code>null</code>。</li>
<li><strong><code>E floor(E e)</code></strong>： 返回<strong>小于等于</strong> <code>e</code> 的<strong>最大</strong>元素，不存在则返回 <code>null</code>。</li>
<li><strong><code>E higher(E e)</code></strong>： 返回<strong>严格大于</strong> <code>e</code> 的<strong>最小</strong>元素，不存在则返回 <code>null</code>。</li>
<li><strong><code>E lower(E e)</code></strong>： 返回<strong>严格小于</strong> <code>e</code> 的<strong>最大</strong>元素，不存在则返回 <code>null</code>。</li>
<li><strong><code>E pollFirst()</code></strong>： 获取并移除<strong>第一个（最小）</strong> 元素。</li>
<li><strong><code>E pollLast()</code></strong>： 获取并移除<strong>最后一个（最大）</strong> 元素。</li>
</ul>
<p>这些方法的时间复杂度也都是 <strong><code>O(log n)</code></strong>。</p>
<hr>
<h5 id="8-遍历方式"><a href="#8-遍历方式" class="headerlink" title="8. 遍历方式"></a>8. 遍历方式</h5><p><code>TreeSet</code> 的迭代器按排序顺序返回元素。这是通过红黑树的<strong>中序遍历</strong>实现的。</p>
<ol>
<li><p><strong>迭代器（Iterator）</strong>： **按排序顺序（升序）**进行迭代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = treeSet.iterator();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>降序迭代器（Descending Iterator）</strong>： **按排序顺序的逆序（降序）**进行迭代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; descIterator = treeSet.descendingIterator();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>增强for循环（for-each）</strong>： 底层是升序迭代器，**按排序顺序（升序）**进行迭代。</p>
</li>
<li><p><strong>forEach + Lambda（Java 8+）</strong>: **按排序顺序（升序）**进行迭代。</p>
</li>
</ol>
<p><strong>注意</strong>： 与其它 <code>Set</code> 一样，<strong>严禁在遍历过程中使用 <code>TreeSet</code> 的 <code>remove()</code> 等方法修改集合结构</strong>，否则会抛出 <code>ConcurrentModificationException</code>。如需遍历时删除，必须使用 <strong><code>Iterator.remove()</code></strong> 方法。</p>
<hr>
<h5 id="9-典型应用场景-1"><a href="#9-典型应用场景-1" class="headerlink" title="9. 典型应用场景"></a>9. 典型应用场景</h5><p><strong>1. 需要维护一个自动排序的唯一集合（核心场景）</strong></p>
<p>这是 <code>TreeSet</code> 最直接、最经典的应用。当你需要一个集合，它既能自动去重，又能始终保持所有元素处于排序状态时，<code>TreeSet</code> 是唯一的选择。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>排行榜</strong>：记录游戏玩家的分数，要求分数从高到低排序且不能重复（或者处理同分情况后唯一）。每当玩家分数更新时，只需将其新分数对象添加到 <code>TreeSet</code>，集合会自动将其放在正确的位置。</li>
<li><strong>日程安排</strong>：存储一系列唯一的、未来的时间点（<code>Date</code> 或 <code>Instant</code> 对象），<code>TreeSet</code> 可以自动按时间先后排序，方便快速找到下一个要执行的任务。</li>
<li><strong>词汇表</strong>：存储单词并要求按字母顺序排列。</li>
</ul>
<p><strong>代码示例（排行榜）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个PlayerScore类，实现了Comparable接口按分数降序排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerScore</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;PlayerScore&gt; &#123;</span><br><span class="line">    String playerName;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 构造方法、getter ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PlayerScore other)</span> &#123;</span><br><span class="line">        <span class="comment">// 按分数降序排，分数相同按名字排（保证唯一性）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">scoreCompare</span> <span class="operator">=</span> Integer.compare(other.score, <span class="built_in">this</span>.score);</span><br><span class="line">        <span class="keyword">return</span> scoreCompare != <span class="number">0</span> ? scoreCompare : <span class="built_in">this</span>.playerName.compareTo(other.playerName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用TreeSet自动维护排行榜</span></span><br><span class="line">NavigableSet&lt;PlayerScore&gt; leaderboard = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">leaderboard.add(<span class="keyword">new</span> <span class="title class_">PlayerScore</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">950</span>));</span><br><span class="line">leaderboard.add(<span class="keyword">new</span> <span class="title class_">PlayerScore</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">1200</span>));</span><br><span class="line">leaderboard.add(<span class="keyword">new</span> <span class="title class_">PlayerScore</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">750</span>));</span><br><span class="line">leaderboard.add(<span class="keyword">new</span> <span class="title class_">PlayerScore</span>(<span class="string">&quot;David&quot;</span>, <span class="number">1200</span>)); <span class="comment">// 与Bob同分，但名字不同，会被加入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动按分数从高到低输出</span></span><br><span class="line"><span class="keyword">for</span> (PlayerScore ps : leaderboard) &#123;</span><br><span class="line">    System.out.println(ps.getPlayerName() + <span class="string">&quot;: &quot;</span> + ps.getScore());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Bob: 1200</span></span><br><span class="line"><span class="comment">// David: 1200</span></span><br><span class="line"><span class="comment">// Alice: 950</span></span><br><span class="line"><span class="comment">// Charlie: 750</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 需要频繁进行范围查询和导航操作</strong></p>
<p>得益于 <code>NavigableSet</code> 接口，<code>TreeSet</code> 提供了极其强大的方法来查询相对于某个元素的“邻居”，或者获取集合中的某个子集（范围查询）。这些操作都非常高效（O(log n)）。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>查找界限</strong>：在一个考试成绩集合中，快速找到“比85分低一分的那个成绩” (<code>lower(85)</code>）或者“比60分高的第一个成绩” (<code>higher(60)</code>）。</li>
<li><strong>获取数据切片</strong>：处理有序数据时，需要获取某一范围内的所有数据，例如获取所有分数在 70 到 90 分之间的学生 (<code>subSet(70, true, 90, true)</code>)。</li>
<li><strong>实现最近邻搜索</strong>：在一个坐标集合中，快速找到与某个给定值最接近的元素（通过 <code>floor()</code> 和 <code>ceiling()</code> 方法比较即可）。</li>
</ul>
<p><strong>代码示例（范围查询）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; scores = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Arrays.asList(<span class="number">56</span>, <span class="number">72</span>, <span class="number">83</span>, <span class="number">90</span>, <span class="number">65</span>, <span class="number">100</span>, <span class="number">45</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有及格（&gt;=60）的成绩</span></span><br><span class="line">NavigableSet&lt;Integer&gt; passingScores = scores.tailSet(<span class="number">60</span>, <span class="literal">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Passing Scores: &quot;</span> + passingScores); <span class="comment">// [65, 72, 83, 90, 100]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有80分到90分之间的成绩（包括80，不包括90）</span></span><br><span class="line">NavigableSet&lt;Integer&gt; between80And90 = scores.subSet(<span class="number">80</span>, <span class="literal">true</span>, <span class="number">90</span>, <span class="literal">false</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Between 80 and 90: &quot;</span> + between80And90); <span class="comment">// [83]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出比85分小的最大元素（即小于85的最大值）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">justBelow85</span> <span class="operator">=</span> scores.lower(<span class="number">85</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Just below 85: &quot;</span> + justBelow85); <span class="comment">// 83</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 需要按顺序处理数据且允许高效插入&#x2F;删除</strong></p>
<p>虽然 <code>ArrayList</code> 也可以排序 (<code>Collections.sort()</code>)，但每次插入新元素后都要重新排序的成本是 O(n log n)。而 <code>TreeSet</code> 在每次插入时维护有序性的成本仅为 O(log n)。如果数据是动态变化的，并且需要随时保持有序，<code>TreeSet</code> 的整体性能会远优于“列表+重复排序”的方案。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>实时数据流排序</strong>：传感器数据源源不断地传来，你需要实时维护一个唯一且有序的数据集合来进行监控。</li>
<li><strong>优先级队列的替代方案</strong>：<code>TreeSet</code> 提供了比 <code>PriorityQueue</code> 更丰富的操作（如查看中间元素、删除任意元素等）。如果你需要的是一个有序集合而不仅仅是按优先级取出，<code>TreeSet</code> 是更好的选择。（注意：<code>PriorityQueue</code> 允许重复元素，而 <code>TreeSet</code> 不允许）。</li>
</ul>
<hr>
<h4 id="2-3-5-EnumSet【了解】"><a href="#2-3-5-EnumSet【了解】" class="headerlink" title="2.3.5 EnumSet【了解】"></a>2.3.5 EnumSet【了解】</h4><h5 id="1-核心概念-8"><a href="#1-核心概念-8" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>EnumSet</code> 是一个专用于<strong>枚举类型</strong>的高性能 <code>Set</code> 实现。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>专属（Specialized）</strong>： 只能存储<strong>单一枚举类型</strong>的元素。枚举类型在创建集合时显式或隐式地指定。</li>
<li><strong>高性能（High Performance）</strong>： 所有基本操作（如 <code>add</code>, <code>remove</code>, <code>contains</code>）都在<strong>常数时间 <code>O(1)</code></strong> 内完成，且非常快，因为它基于位向量（Bit Vector）实现。</li>
<li><strong>内存高效（Memory Efficient）</strong>： 内部使用位掩码（bitmask）或长整型（long）来表示集合，非常节省空间。</li>
<li><strong>类型安全（Type-Safe）</strong>： 由于专用于单一枚举类型，提供了编译时的类型安全。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 与大多数标准集合实现一样，未经同步直接在多线程环境下使用会导致不确定的结果。可以使用 <code>Collections.synchronizedSet</code> 包装。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个 <strong><code>long</code></strong> 类型的位向量（或 <code>long[]</code>）<code>elements</code> 来存储集合的状态。枚举实例的序数（<code>ordinal</code>）作为位的位置，该位是 1 还是 0 表示元素是否存在。所有操作都通过高效的位运算（如 <code>|</code>, <code>&amp;</code>, <code>^</code>, <code>~</code>）来完成。</li>
<li><strong>设计思想</strong>：<strong>利用枚举类型的有限性，通过位向量表示集合，实现高效、类型安全、低内存占用的 Set 实现</strong>。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-6"><a href="#2-底层数据结构和关键属性-6" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>EnumSet</code> 的源码（以OpenJDK为例），它是一个抽象类，有两个包私有的具体实现：<code>RegularEnumSet</code>（用于枚举常量数 &lt;&#x3D; 64）和 <code>JumboEnumSet</code>（用于枚举常量数 &gt; 64）。它们的核心属性如下：</p>
<p><strong><code>RegularEnumSet</code> (用于小枚举，&lt;&#x3D; 64个元素)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RegularEnumSet</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; <span class="keyword">extends</span> <span class="title class_">EnumSet</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位向量（Bit vector），每一位代表对应序数的枚举常量是否存在。</span></span><br><span class="line"><span class="comment">     * 枚举常量 e 的存在性由表达式 (elements &amp; (1L &lt;&lt; e.ordinal())) != 0) 判断。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">elements</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 初始状态，所有位为0，表示空集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>JumboEnumSet</code> (用于大枚举，&gt; 64个元素)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JumboEnumSet</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; <span class="keyword">extends</span> <span class="title class_">EnumSet</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位向量数组。每一位代表对应序数的枚举常量是否存在。</span></span><br><span class="line"><span class="comment">     * 数组的长度为：((universe.length - 1) &gt;&gt;&gt; 6) + 1</span></span><br><span class="line"><span class="comment">     * 即 (元素总数 - 1) / 64 + 1，向上取整。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> elements[]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组中有效元素（long）的个数，减少某些计算中的循环次数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>elements</code> (long 或 long[])</strong>： 这是 <code>EnumSet</code> 的<strong>心脏</strong>。所有集合成员信息都压缩存储在这里。</li>
<li><strong><code>size</code> (仅在 <code>JumboEnumSet</code> 中)</strong>： 记录当前集合中<strong>实际有多少个有效元素</strong>。在 <code>RegularEnumSet</code> 中，通过计算 <code>Long.bitCount(elements)</code> 来获得大小。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-5"><a href="#3-构造方法与初始化-5" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>EnumSet</code> 是一个抽象类，所有构造器都是包私有的。它提供了一系列<strong>静态工厂方法</strong>来创建实例。工厂方法会根据枚举类型的常量数量自动选择 <code>RegularEnumSet</code> 或 <code>JumboEnumSet</code>。</p>
<ol>
<li><p><strong><code>public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 获取枚举的所有常量 <code>E[] universe = getUniverse(elementType)</code>。如果常量数 &lt;&#x3D; 64，创建 <code>RegularEnumSet</code>，否则创建 <code>JumboEnumSet</code>。</p>
</li>
<li><p><strong>特点</strong>： 创建一个空的 <code>EnumSet</code>。这是最基础的工厂方法，其他方法（如 <code>of</code>, <code>range</code>）内部都调用了它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取该枚举类型的所有实例</span></span><br><span class="line">    E[] universe = getUniverse(elementType);</span><br><span class="line">    <span class="keyword">if</span> (universe == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>(elementType + <span class="string">&quot; not an enum&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据数量决定具体实现</span></span><br><span class="line">    <span class="keyword">if</span> (universe.length &lt;= <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegularEnumSet</span>&lt;&gt;(elementType, universe);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JumboEnumSet</span>&lt;&gt;(elementType, universe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; allOf(Class&lt;E&gt; elementType)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 调用 <code>noneOf</code> 创建空集，然后调用 <code>complement()</code> 或直接设置所有位为 1，来填充所有元素。</p>
</li>
<li><p><strong>特点</strong>： 创建一个包含指定枚举类型所有常量的 <code>EnumSet</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegularEnumSet 的实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (universe.length != <span class="number">0</span>)</span><br><span class="line">        elements = -<span class="number">1L</span> &gt;&gt;&gt; -universe.length; <span class="comment">// 将前 universe.length 位设为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JumboEnumSet 的实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; elements.length; i++)</span><br><span class="line">        elements[i] = -<span class="number">1</span>; <span class="comment">// 每个 long 都设为全1</span></span><br><span class="line">    elements[elements.length - <span class="number">1</span>] &gt;&gt;&gt;= -universe.length; <span class="comment">// 清理末尾多余的位</span></span><br><span class="line">    size = universe.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5)</code></strong> 及其重载</p>
<ul>
<li><strong>源码逻辑</strong>： 调用 <code>noneOf(e1.getDeclaringClass())</code> 创建空集，然后依次 <code>add</code> 传入的元素。</li>
<li><strong>特点</strong>： 创建一个最初包含指定元素的 <code>EnumSet</code>。有多个重载版本（1到5个参数），以及一个可变参数版本 <code>(E... elements)</code>。</li>
</ul>
</li>
<li><p><strong><code>public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; range(E from, E to)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用 <code>noneOf</code> 创建空集，然后通过位运算设置从 <code>from.ordinal()</code> 到 <code>to.ordinal()</code> 之间的所有位。</li>
<li><strong>特点</strong>： 创建一个包含指定范围内所有元素的 <code>EnumSet</code>。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-添加元素-Add-1"><a href="#4-添加元素-Add-1" class="headerlink" title="4. 添加元素(Add)"></a>4. 添加元素(Add)</h5><p><strong><code>public boolean add(E e)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑：</strong></p>
<ol>
<li>类型检查，确保 <code>e</code> 属于正确的枚举类型。</li>
<li>计算该元素对应的位 <code>ordinal = e.ordinal()</code>。</li>
<li>执行位运算，将对应位设为 1。</li>
<li>如果该位之前是 0（即元素是新添加的），返回 <code>true</code>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。纯粹的位操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegularEnumSet 的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    typeCheck(e); <span class="comment">// 检查类型</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">oldElements</span> <span class="operator">=</span> elements;</span><br><span class="line">    <span class="comment">// 1L &lt;&lt; e.ordinal() 计算出要设置的位</span></span><br><span class="line">    <span class="comment">// |= 操作将该位设为1</span></span><br><span class="line">    elements |= (<span class="number">1L</span> &lt;&lt; e.ordinal()); </span><br><span class="line">    <span class="keyword">return</span> elements != oldElements; <span class="comment">// 如果相等，说明元素已存在，添加失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-删除元素-Remove-2"><a href="#5-删除元素-Remove-2" class="headerlink" title="5. 删除元素(Remove)"></a>5. 删除元素(Remove)</h5><p><strong><code>public boolean remove(Object e)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>如果 <code>e</code> 为 <code>null</code> 或类型不匹配，返回 <code>false</code>。</li>
<li>计算该元素对应的位 <code>ordinal = e.ordinal()</code>。</li>
<li>执行位运算，将对应位设为 0。</li>
<li>如果该位之前是 1（即元素原本存在），返回 <code>true</code>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。纯粹的位操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegularEnumSet 的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Class&lt;?&gt; eClass = e.getClass();</span><br><span class="line">    <span class="keyword">if</span> (eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 类型不匹配</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">oldElements</span> <span class="operator">=</span> elements;</span><br><span class="line">    <span class="comment">// ~(1L &lt;&lt; e.ordinal()) 得到一个只有目标位是0的掩码</span></span><br><span class="line">    <span class="comment">// &amp;= 操作将目标位清零</span></span><br><span class="line">    elements &amp;= ~(<span class="number">1L</span> &lt;&lt; ((Enum&lt;?&gt;)e).ordinal());</span><br><span class="line">    <span class="keyword">return</span> elements != oldElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-包含判断-Contains"><a href="#6-包含判断-Contains" class="headerlink" title="6. 包含判断(Contains)"></a>6. 包含判断(Contains)</h5><p><strong><code>public boolean contains(Object e)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>如果 <code>e</code> 为 <code>null</code> 或类型不匹配，返回 <code>false</code>。</li>
<li>计算该元素对应的位 <code>ordinal = e.ordinal()</code>。</li>
<li>执行位与运算 <code>(elements &amp; (1L &lt;&lt; ordinal)) != 0</code>，检查对应位是否为 1。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。纯粹的位操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegularEnumSet 的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Class&lt;?&gt; eClass = e.getClass();</span><br><span class="line">    <span class="keyword">if</span> (eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 检查对应位是否为1</span></span><br><span class="line">    <span class="keyword">return</span> (elements &amp; (<span class="number">1L</span> &lt;&lt; ((Enum&lt;?&gt;)e).ordinal())) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-批量操作"><a href="#7-批量操作" class="headerlink" title="7. 批量操作"></a>7. 批量操作</h5><p><code>EnumSet</code> 的批量操作（如 <code>addAll</code>, <code>removeAll</code>, <code>retainAll</code>）都通过位运算实现，效率极高。</p>
<ul>
<li><strong><code>complement()</code></strong>： 求补集。将位向量取反（<code>~</code>），然后清理掉超出枚举常量数量的高位。</li>
<li><strong><code>addAll(Collection c)</code></strong>： 如果参数是另一个 <code>EnumSet</code> 且类型相同，直接进行位或运算（<code>|=</code>）。</li>
<li><strong><code>retainAll(Collection c)</code></strong>： 如果参数是另一个 <code>EnumSet</code> 且类型相同，直接进行位与运算（<code>&amp;=</code>）。</li>
</ul>
<hr>
<h5 id="8-遍历方式-1"><a href="#8-遍历方式-1" class="headerlink" title="8. 遍历方式"></a>8. 遍历方式</h5><ul>
<li><strong>迭代器（Iterator）</strong>： <code>EnumSet</code> 提供了自己的 <code>Iterator</code> 实现，它预先生成了所有有效元素的序列，遍历效率很高。</li>
<li><strong>for-each循环</strong>： 推荐方式，语法简洁，底层也是迭代器。</li>
</ul>
<p><strong>注意</strong>： <code>EnumSet</code> 的迭代器是<strong>弱一致性的（weakly consistent）</strong>，它不会抛出 <code>ConcurrentModificationException</code>。但如果在迭代期间修改集合，迭代结果是不确定的。</p>
<hr>
<h5 id="9-典型应用场面"><a href="#9-典型应用场面" class="headerlink" title="9. 典型应用场面"></a>9. 典型应用场面</h5><p><strong>1. 替代位掩码（Bit Flags &#x2F; Bitmask） - 最经典的场景</strong></p>
<p>在历史上，为了表示一组开关、状态或选项，程序员经常使用位掩码操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统位掩码做法（不推荐）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STYLE_BOLD</span>     <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STYLE_ITALIC</span>   <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STYLE_UNDERLINE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">myStyles</span> <span class="operator">=</span> STYLE_BOLD | STYLE_ITALIC; <span class="comment">// 使用 OR 操作组合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((myStyles &amp; STYLE_BOLD) != <span class="number">0</span>) &#123; <span class="comment">// 使用 AND 操作检查</span></span><br><span class="line">    <span class="comment">// 粗体生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法虽然高效，但有很多缺点：类型不安全、打印调试不直观、易出错、可读性差。</p>
<p><strong><code>EnumSet</code> 完美地解决了所有这些问题，同时保留了位操作的性能优势</strong>。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>文本样式</strong>：字体可以是粗体、斜体、下划线等的任意组合。</li>
<li><strong>系统权限</strong>：一个用户可能拥有读、写、执行、删除等权限的任意组合。</li>
<li><strong>游戏状态</strong>：一个游戏实体可能同时处于“移动中”、“受伤”、“无敌”等多种状态。</li>
<li><strong>配置选项</strong>：启用或禁用一系列功能选项。</li>
</ul>
<p><strong>代码示例（用EnumSet替代位掩码）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TextStyle</span> &#123;</span><br><span class="line">    BOLD, ITALIC, UNDERLINE, STRIKETHROUGH</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 使用EnumSet</span></span><br><span class="line">Set&lt;TextStyle&gt; myStyles = EnumSet.of(TextStyle.BOLD, TextStyle.ITALIC);</span><br><span class="line"><span class="comment">// 检查是否包含 - 可读性极高，且性能极快</span></span><br><span class="line"><span class="keyword">if</span> (myStyles.contains(TextStyle.BOLD)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;文本是粗体&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加样式</span></span><br><span class="line">myStyles.add(TextStyle.UNDERLINE);</span><br><span class="line"><span class="comment">// 移除样式</span></span><br><span class="line">myStyles.remove(TextStyle.ITALIC);</span><br><span class="line"><span class="comment">// 遍历所有应用的样式</span></span><br><span class="line"><span class="keyword">for</span> (TextStyle style : myStyles) &#123;</span><br><span class="line">    System.out.println(style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 表示有限的状态机或工作流</strong></p>
<p>在许多系统中，一个对象只能处于有限状态集合中的某一个状态，并且状态之间的转换是预定义的。<code>EnumSet</code> 非常适合用来表示“从一个状态可以转移到哪些状态”的集合。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>订单状态流</strong>：订单可能处于 <code>NEW</code>, <code>PAID</code>, <code>SHIPPED</code>, <code>DELIVERED</code>, <code>CANCELLED</code> 等状态。<code>EnumSet</code> 可以用来定义，例如，<code>PAID</code> 状态的下一个状态只能是 <code>SHIPPED</code> 或 <code>CANCELLED</code>。</li>
<li><strong>线程生命周期</strong>：线程状态 <code>NEW</code>, <code>RUNNABLE</code>, <code>BLOCKED</code>, <code>WAITING</code>, <code>TIMED_WAITING</code>, <code>TERMINATED</code>。</li>
</ul>
<p><strong>代码示例（状态机）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderStatus</span> &#123; NEW, CONFIRMED, PAID, SHIPPED, DELIVERED, CANCELLED &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个状态转换规则：当前状态 -&gt; 可能的下一个状态集合</span></span><br><span class="line">Map&lt;OrderStatus, EnumSet&lt;OrderStatus&gt;&gt; stateTransitions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化状态转换规则</span></span><br><span class="line">    stateTransitions.put(OrderStatus.NEW,</span><br><span class="line">            EnumSet.of(OrderStatus.CONFIRMED, OrderStatus.CANCELLED));</span><br><span class="line">    stateTransitions.put(OrderStatus.CONFIRMED,</span><br><span class="line">            EnumSet.of(OrderStatus.PAID, OrderStatus.CANCELLED));</span><br><span class="line">    stateTransitions.put(OrderStatus.PAID,</span><br><span class="line">            EnumSet.of(OrderStatus.SHIPPED));</span><br><span class="line">    <span class="comment">// ... 其他规则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法：检查一个状态转换是否合法</span></span><br><span class="line"><span class="type">OrderStatus</span> <span class="variable">currentStatus</span> <span class="operator">=</span> OrderStatus.PAID;</span><br><span class="line"><span class="type">OrderStatus</span> <span class="variable">nextStatus</span> <span class="operator">=</span> OrderStatus.SHIPPED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stateTransitions.get(currentStatus).contains(nextStatus)) &#123;</span><br><span class="line">    currentStatus = nextStatus; <span class="comment">// 合法，执行状态转换</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid state transition!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 处理枚举的所有值或某个范围的值</strong></p>
<p><code>EnumSet</code> 提供了非常方便的静态工厂方法来快速创建包含枚举所有值或某个连续范围值的集合。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>批量操作</strong>：需要处理除了某几个值之外的所有枚举值。</li>
<li><strong>初始化</strong>：在系统初始化时，需要启用一整套默认功能。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">DayOfWeek</span> &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;</span><br><span class="line"><span class="comment">// 创建一个包含所有值的集合</span></span><br><span class="line">EnumSet&lt;DayOfWeek&gt; allDays = EnumSet.allOf(DayOfWeek.class);</span><br><span class="line"><span class="comment">// 创建一个工作日集合（从周一到周五）</span></span><br><span class="line">EnumSet&lt;DayOfWeek&gt; weekdays = EnumSet.range(DayOfWeek.MONDAY, DayOfWeek.FRIDAY);</span><br><span class="line"><span class="comment">// 创建一个周末集合（用“所有值”减去“工作日”）</span></span><br><span class="line">EnumSet&lt;DayOfWeek&gt; weekend = EnumSet.complementOf(weekdays); <span class="comment">// 包含 SATURDAY, SUNDAY</span></span><br><span class="line"><span class="comment">// 创建一个空的EnumSet，并指定元素类型</span></span><br><span class="line">EnumSet&lt;DayOfWeek&gt; none = EnumSet.noneOf(DayOfWeek.class);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-6-CopyOnWriteArraySet【了解】"><a href="#2-3-6-CopyOnWriteArraySet【了解】" class="headerlink" title="2.3.6 CopyOnWriteArraySet【了解】"></a>2.3.6 CopyOnWriteArraySet【了解】</h4><h5 id="1-核心概念-9"><a href="#1-核心概念-9" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>CopyOnWriteArraySet</code> 是 <code>Set</code> 接口的一个<strong>线程安全</strong>的实现。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>线程安全（Thread-Safe）</strong>： 所有操作都是线程安全的，无需外部同步。</li>
<li><strong>写时复制（Copy-On-Write）</strong>： 所有修改操作（如 <code>add</code>, <code>remove</code>）都会创建底层数组的一个新副本。这是它线程安全的基础。</li>
<li><strong>弱一致性迭代（Weakly Consistent Iteration）</strong>： 迭代器在创建时持有创建那一刻底层数组的快照（Snapshot）。在迭代过程中不会抛出 <code>ConcurrentModificationException</code>，但迭代器反映的是创建时的状态，看不到迭代开始后其他线程的修改。</li>
<li><strong>无序（Unordered）</strong>： 不保证元素的遍历顺序，特别是它不保证像 <code>HashSet</code> 那样基于哈希码的顺序。</li>
<li><strong>允许空元素（Allows Null）</strong>： 支持添加 <code>null</code> 元素。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 其所有操作都是通过委托给一个内部的 <code>CopyOnWriteArrayList</code> 实例来完成的。<code>Set</code> 的特性（元素唯一性）由 <code>CopyOnWriteArrayList</code> 的 <code>addIfAbsent</code> 和 <code>addAllAbsent</code> 方法来保证。</li>
<li><strong>设计思想</strong>：<code>CopyOnWriteArraySet</code> 基于 <code>CopyOnWriteArrayList</code>，采用写时复制策略实现线程安全和无重复元素集合。它的设计是为了解决“读多写少”场景下的并发安全问题，读操作无锁且高效，写操作开销较大但简单安全。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-7"><a href="#2-底层数据结构和关键属性-7" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>CopyOnWriteArraySet</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">5457747651344034263L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心！所有操作都委托给这个 CopyOnWriteArrayList 实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个空集合。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyOnWriteArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个包含指定集合所有元素的集合。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyOnWriteArraySet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == CopyOnWriteArraySet.class) &#123;</span><br><span class="line">            <span class="comment">// 如果传入的集合就是 CopyOnWriteArraySet，直接获取其内部的 ArrayList</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            CopyOnWriteArraySet&lt;E&gt; cc = (CopyOnWriteArraySet&lt;E&gt;)c;</span><br><span class="line">            al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;(cc.al);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，新建一个空的 ArrayList，然后添加所有元素</span></span><br><span class="line">            al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class="line">            al.addAllAbsent(c); <span class="comment">// 使用 addAllAbsent 保证元素唯一性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 所有方法都委托给 &#x27;al&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>al</code> (CopyOnWriteArrayList)</strong>： 所有集合操作都通过调用这个内部列表的相应方法来完成。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-6"><a href="#3-构造方法与初始化-6" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>CopyOnWriteArraySet</code> 提供了两种构造方式：</p>
<ol>
<li><p><strong><code>public CopyOnWriteArraySet()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 初始化内部引用 <code>al</code> 为一个新的、空的 <code>CopyOnWriteArrayList</code>。</p>
</li>
<li><p><strong>特点</strong>： 创建一个空的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个空的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">    al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public CopyOnWriteArraySet(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 如果传入的集合本身就是 <code>CopyOnWriteArraySet</code>，则直接访问其内部的 <code>al</code> 来构造新的列表，效率较高。否则，创建一个新的空 <code>CopyOnWriteArrayList</code>，然后调用 <code>addAllAbsent(c)</code> 来添加元素，此方法能保证元素唯一性。</p>
</li>
<li><p><strong>特点</strong>： 用一个已有集合来构造。<strong>注意：如果传入的集合包含重复元素，重复项会被自动去除。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个包含指定集合中所有元素的 Set。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 要初始化到该集合中的元素集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArraySet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line"> 	<span class="comment">// 如果传入的集合本身就是一个 CopyOnWriteArraySet</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArraySet.class) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> CopyOnWriteArraySet&lt;E&gt; cc =</span><br><span class="line">            (CopyOnWriteArraySet&lt;E&gt;)c;</span><br><span class="line">     	<span class="comment">// 直接用传入集合内部的 CopyOnWriteArrayList 来初始化</span></span><br><span class="line">        al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;(cc.al);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">     	<span class="comment">// 否则，创建一个新的 CopyOnWriteArrayList</span></span><br><span class="line">        al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class="line">       	<span class="comment">// 将集合 c 中的所有元素添加进来，跳过已有的重复元素</span></span><br><span class="line">        al.addAllAbsent(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-添加元素-Add-2"><a href="#4-添加元素-Add-2" class="headerlink" title="4. 添加元素(Add)"></a>4. 添加元素(Add)</h5><p><strong><code>public boolean add(E e)</code></strong>：</p>
<ul>
<li><p>底层调用<code>CopyOnWriteArrayList</code>时间复杂度与处理逻辑与<code>CopyOnWriteArrayList</code>的<code>addIfAbsent</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> al.addIfAbsent(e); <span class="comment">// 核心调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-删除元素-Remove-3"><a href="#5-删除元素-Remove-3" class="headerlink" title="5. 删除元素(Remove)"></a>5. 删除元素(Remove)</h5><p><strong><code>public boolean remove(Object o)</code></strong>：</p>
<ul>
<li><p>底层调用<code>CopyOnWriteArrayList</code>时间复杂度与处理逻辑与<code>CopyOnWriteArrayList</code>的<code>remove</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> al.remove(o); <span class="comment">// 核心调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-包含判断-Contains-1"><a href="#6-包含判断-Contains-1" class="headerlink" title="6. 包含判断(Contains)"></a>6. 包含判断(Contains)</h5><p><strong><code>public boolean contains(Object o)</code></strong>：</p>
<ul>
<li><p>底层调用<code>CopyOnWriteArrayList</code>时间复杂度与处理逻辑与<code>CopyOnWriteArrayList</code>的<code>contains</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> al.contains(o); <span class="comment">// 核心调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-遍历与迭代器"><a href="#7-遍历与迭代器" class="headerlink" title="7. 遍历与迭代器"></a>7. 遍历与迭代器</h5><p><strong><code>public Iterator&lt;E&gt; iterator()</code></strong>：</p>
<ul>
<li><p>底层调用<code>CopyOnWriteArrayList</code>的<code>iterator</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> al.iterator(); <span class="comment">// 返回一个基于快照的迭代器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="8-典型应用场景-1"><a href="#8-典型应用场景-1" class="headerlink" title="8. 典型应用场景"></a>8. 典型应用场景</h5><p><strong>1. 读操作极度频繁，写操作非常稀少的场景（最核心场景）</strong></p>
<p>这是 <code>CopyOnWriteArraySet</code> 设计的初衷和最主要的应用场景。系统的性能瓶颈在于需要高吞吐量的读操作，而写操作只是偶尔发生。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>事件监听器列表 (Listener Lists)</strong>：这是一个教科书级的例子。在 GUI 框架（如 Swing）或事件驱动系统中，需要维护一个事件监听器的集合。<br>* <strong>读操作极度频繁</strong>：当事件发生时，需要遍历所有监听器并通知它们（<code>for (Listener l : listeners) l.onEvent();</code>）。这个过程会非常频繁地发生。<br>* <strong>写操作非常稀少</strong>：监听器的注册 (<code>addListener</code>) 和注销 (<code>removeListener</code>) 通常在程序初始化或用户交互时发生，频率比事件触发低几个数量级。<ul>
<li>使用 <code>CopyOnWriteArraySet</code>，事件通知（读遍历）可以<strong>无锁、高速</strong>地进行，而偶尔的注册&#x2F;注销操作（写）带来的性能开销是可以接受的。</li>
</ul>
</li>
<li><strong>只读为主的缓存</strong>：缓存的数据几乎不变化，但会被成千上万的线程并发读取。偶尔需要重新加载或更新整个缓存集。</li>
<li><strong>存储不变的配置信息</strong>：配置信息在启动后基本不会改变，但需要被许多线程频繁查询。</li>
</ul>
<p><strong>代码示例（事件监听器）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventSource</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 CopyOnWriteArraySet 保存监听器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;EventListener&gt; listeners = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册监听器（写操作，慢但稀少）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(EventListener listener)</span> &#123;</span><br><span class="line">        listeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除监听器（写操作，慢但稀少）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeListener</span><span class="params">(EventListener listener)</span> &#123;</span><br><span class="line">        listeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件（读操作，快且频繁！）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历操作不需要同步，极快！</span></span><br><span class="line">        <span class="comment">// 这里迭代的是触发事件那一刻的集合快照</span></span><br><span class="line">        <span class="keyword">for</span> (EventListener listener : listeners) &#123;</span><br><span class="line">            listener.onEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 需要避免在迭代过程中加锁的场景</strong></p>
<p>在某些情况下，你需要对集合进行长时间的遍历（例如，处理集合中的每个元素需要执行一些耗时的操作），并且在此期间不希望阻塞其他线程的读操作。使用传统的同步集合（如 <code>Collections.synchronizedSet()</code>）会在整个迭代期间持有锁，导致其他线程无法访问，严重降低吞吐量。</p>
<p><code>CopyOnWriteArraySet</code> 的“快照”迭代器完美解决了这个问题。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>批量数据处理</strong>：一个后台线程需要遍历当前所有连接的会话（Session）来进行健康检查或统计。这个遍历过程可能很慢，但你不希望在这个过程中阻塞新的连接请求（添加新会话）或正常的消息处理（读取会话信息）。</li>
<li><strong>分析诊断</strong>：需要获取系统当前状态的快照（如所有活跃任务、所有打开的文件）进行分析，分析过程不希望被后续的状态变化所影响。</li>
</ul>
<hr>
<p><strong>3. 需要保证不会抛出 <code>ConcurrentModificationException</code></strong></p>
<p>如果你受够了在迭代集合时因为其他线程修改集合而抛出 <code>ConcurrentModificationException</code>，但又不想在遍历时用锁同步整个集合，<code>CopyOnWriteArraySet</code> 是一个简单的解决方案。它的迭代器基于创建时的快照，绝对安全。</p>
<hr>
<h4 id="2-3-7-综合对比"><a href="#2-3-7-综合对比" class="headerlink" title="2.3.7 综合对比"></a>2.3.7 综合对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>HashSet</code></th>
<th align="left"><code>LinkedHashSet</code></th>
<th align="left"><code>TreeSet</code></th>
<th align="left"><code>EnumSet</code></th>
<th align="left"><code>CopyOnWriteArraySet</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层数据结构</strong></td>
<td align="left"><strong>哈希表 (HashMap)</strong></td>
<td align="left"><strong>哈希表 + 双向链表</strong></td>
<td align="left"><strong>红黑树</strong></td>
<td align="left"><strong>位向量 (Bit Vector)</strong></td>
<td align="left"><strong>动态数组 (CopyOnWriteArrayList)</strong></td>
</tr>
<tr>
<td align="left"><strong>所在包</strong></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><strong><code>java.util.concurrent</code></strong></td>
</tr>
<tr>
<td align="left"><strong>元素顺序</strong></td>
<td align="left"><strong>无顺序</strong> (不保证迭代顺序)</td>
<td align="left"><strong>插入顺序</strong> (按添加顺序迭代)</td>
<td align="left"><strong>自然顺序 或 定制排序</strong> (排序顺序)</td>
<td align="left"><strong>枚举常量声明顺序</strong> (在枚举类中定义的顺序)</td>
<td align="left"><strong>插入顺序</strong> (但迭代器创建时的快照顺序)</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>允许 <code>null</code> 元素</strong></td>
<td align="left"><strong>是</strong> (最多一个)</td>
<td align="left"><strong>是</strong> (最多一个)</td>
<td align="left"><strong>否</strong> (如果使用自然排序) <strong>可能</strong> (如果使用Comparator)</td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>性能 (增删查)</strong></td>
<td align="left"><strong>O(1)</strong> (平均情况)</td>
<td align="left"><strong>O(1)</strong> (平均情况，略慢于HashSet)</td>
<td align="left"><strong>O(log n)</strong></td>
<td align="left"><strong>极快 O(1)</strong></td>
<td align="left"><strong>读: O(1)</strong> <strong>写: O(n)</strong> (极慢)</td>
</tr>
<tr>
<td align="left"><strong>迭代器性能</strong></td>
<td align="left">受容量影响 (较好)</td>
<td align="left"><strong>极快</strong> (直接遍历链表)</td>
<td align="left"><strong>O(n)</strong> (中序遍历)</td>
<td align="left"><strong>极快</strong></td>
<td align="left"><strong>极快</strong> (遍历快照，无并发冲突)</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">较低</td>
<td align="left">较高 (需要维护链表结构)</td>
<td align="left">较低</td>
<td align="left"><strong>极低</strong> (位操作)</td>
<td align="left"><strong>较高</strong> (写时复制机制导致)</td>
</tr>
<tr>
<td align="left"><strong>迭代器类型</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>弱一致性 (Weakly Consistent)</strong> (不会抛<code>CME</code>)</td>
</tr>
<tr>
<td align="left"><strong>比较方式</strong></td>
<td align="left"><code>equals()</code> 和 <code>hashCode()</code></td>
<td align="left"><code>equals()</code> 和 <code>hashCode()</code></td>
<td align="left"><code>compareTo()</code> 或 <code>Comparator</code></td>
<td align="left"><code>equals()</code></td>
<td align="left"><code>equals()</code></td>
</tr>
<tr>
<td align="left"><strong>核心用途</strong></td>
<td align="left">需要快速查找、去重，且不关心顺序的场景</td>
<td align="left">需要保证插入顺序的快速查找和去重</td>
<td align="left">需要元素始终保持排序状态的场景</td>
<td align="left">专门用于存储<strong>同一枚举类型</strong>的元素，性能极致优化</td>
<td align="left"><strong>读多写极少</strong>的高并发场景，需要线程安全且避免迭代时抛异常</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-4-Queue-Deque-接口及其实现类"><a href="#2-4-Queue-Deque-接口及其实现类" class="headerlink" title="2.4 Queue &#x2F; Deque 接口及其实现类"></a>2.4 <strong>Queue &#x2F; Deque 接口及其实现类</strong></h3><h4 id="2-4-1-Queue"><a href="#2-4-1-Queue" class="headerlink" title="2.4.1 Queue"></a>2.4.1 Queue</h4><p><code>Queue</code> 接口设计用于在处理元素<strong>之前</strong>保存元素。它通常（但并非一定）遵循<strong>先进先出（FIFO）</strong> 的原则。</p>
<h5 id="1-核心特征："><a href="#1-核心特征：" class="headerlink" title="1.核心特征："></a>1.<strong>核心特征：</strong></h5><ol>
<li><strong>有序（Ordered）</strong>： 元素以一种特定的顺序存储，这个顺序由队列的类型决定（如 FIFO、LIFO 或优先级）。</li>
<li><strong>可重复（Allow Duplicates）</strong>： 通常允许存储相同的元素（包括 <code>null</code> 元素，但具体实现可能有限制，例如 <code>PriorityQueue</code> 不允许 <code>null</code>）。</li>
<li><strong>无索引（Non-Indexed）</strong>： <strong>不能</strong>通过索引访问队列中间的元素。所有操作都仅限于队列的<strong>头部</strong>或<strong>尾部</strong>。</li>
<li><strong>核心操作（Core Operations）</strong>： 提供了插入、移除和检查元素的方法，每种操作都有两种形式：一种在操作<strong>失败时抛出异常</strong>，另一种则返回一个<strong>特殊值</strong>（如 <code>null</code> 或 <code>false</code>）。</li>
</ol>
<hr>
<h5 id="2-特有的核心方法"><a href="#2-特有的核心方法" class="headerlink" title="2.特有的核心方法"></a>2.<strong>特有的核心方法</strong></h5><p><code>Queue</code> 接口的方法主要围绕其<strong>头部（出队端）</strong> 和<strong>尾部（入队端）</strong> 进行。</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>抛出异常的方法</th>
<th>返回特殊值的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>插入（Insert）</strong></td>
<td><code>boolean add(E e)</code></td>
<td><code>boolean offer(E e)</code></td>
<td>将元素插入队列尾部。如果成功，<code>add()</code> 返回 <code>true</code>，失败则抛出 <code>IllegalStateException</code>（容量受限时）。<code>offer()</code> 在成功时返回 <code>true</code>，失败时返回 <code>false</code>。</td>
</tr>
<tr>
<td><strong>移除（Remove）</strong></td>
<td><code>E remove()</code></td>
<td><code>E poll()</code></td>
<td>移除并返回队列头部的元素。如果队列为空，<code>remove()</code> 抛出 <code>NoSuchElementException</code>，而 <code>poll()</code> 返回 <code>null</code>。</td>
</tr>
<tr>
<td><strong>检查（Examine）</strong></td>
<td><code>E element()</code></td>
<td><code>E peek()</code></td>
<td>返回队列头部的元素（但不移除）。如果队列为空，<code>element()</code> 抛出 <code>NoSuchElementException</code>，而 <code>peek()</code> 返回 <code>null</code>。</td>
</tr>
</tbody></table>
<p><strong>典型使用场景</strong>：任务调度、消息传递、BFS 算法等。</p>
<hr>
<h4 id="2-4-2-LinkedBlockingQueue【了解】"><a href="#2-4-2-LinkedBlockingQueue【了解】" class="headerlink" title="2.4.2 LinkedBlockingQueue【了解】"></a>2.4.2 LinkedBlockingQueue【了解】</h4><h5 id="1-核心概念-10"><a href="#1-核心概念-10" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>LinkedBlockingQueue</code> 是一个基于<strong>单向链表</strong>实现的、可选容量的、<strong>线程安全</strong>的阻塞队列。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>FIFO（先进先出）</strong>： 队列的头部是在队列中时间最长的元素，队列的尾部是在队列中时间最短的元素。</li>
<li><strong>线程安全（Thread-Safe）</strong>： 内部采用<strong>两把锁（ReentrantLock）</strong> 和<strong>条件变量（Condition）</strong> 的机制来保证并发安全，并实现阻塞操作。</li>
<li><strong>阻塞操作（Blocking Operations）</strong>： 当队列为空时，尝试从队列<strong>取出（take）</strong> 元素的线程会被阻塞，直到队列中有可用元素；当队列已满时，尝试向队列<strong>放入（put）</strong> 元素的线程会被阻塞，直到队列出现空位。</li>
<li><strong>可选容量（Optionally Bounded）</strong>： 可以在构造时指定队列的最大容量。如果未指定，则默认容量为 <code>Integer.MAX_VALUE</code>，可近似认为是一个“无界”队列（但仍受限于物理资源）。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个<strong>单向链表</strong> (<code>Node</code>) 来存储元素。通过 <code>head</code> 和 <code>last</code>（或 <code>tail</code>）节点来维护队列的头部和尾部。通过<strong>分离<code>putLock</code>（入队锁）和<code>takeLock</code>（出队锁）</strong> 以及对应的条件变量 <code>notFull</code> 和 <code>notEmpty</code>，实现了高并发的入队和出队操作。</li>
<li><strong>设计思想</strong>：基于链表实现的有界阻塞队列，采用读写分离锁+Condition实现线程安全，支持高并发、阻塞等待和容量控制，特别适合生产者-消费者场景。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-8"><a href="#2-底层数据结构和关键属性-8" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>LinkedBlockingQueue</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6903933977591709194L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表节点类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可能的取值：</span></span><br><span class="line"><span class="comment">         * - 真正的后继节点（successor Node）</span></span><br><span class="line"><span class="comment">         * - 当前节点自身（this Node），表示后继节点是 head.next</span></span><br><span class="line"><span class="comment">         * - null，表示没有后继节点（即这是最后一个节点）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 容量上限，如果没有限制则为 Integer.MAX_VALUE */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前元素数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表头结点。</span></span><br><span class="line"><span class="comment">     * 不变量：head.item == null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表尾结点。</span></span><br><span class="line"><span class="comment">     * 不变量：last.next == null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 被 take、poll 等操作持有的锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** take 操作等待的条件队列 */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;serial&quot;)</span> <span class="comment">// 实现 Condition 的类可能是可序列化的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 被 put、offer 等操作持有的锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** put 操作等待的条件队列 */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;serial&quot;)</span> <span class="comment">// 实现 Condition 的类可能是可序列化的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>Node&lt;E&gt;</code></strong>： 链表的节点，是 <code>LinkedBlockingQueue</code> 的<strong>心脏</strong>。<code>item</code> 存储元素，<code>next</code> 指向下一个节点。</li>
<li><strong><code>head</code> &amp; <code>last</code></strong>： 分别指向链表的头部（哑元节点）和尾部，是操作队列的<strong>指针</strong>。</li>
<li><strong><code>count</code></strong>： 使用 <code>AtomicInteger</code> 记录当前队列中的元素数量。它是<strong>连接两把锁的桥梁</strong>，所有需要同时判断数量和状态的操作（如 <code>signalNotFull</code>）都需要先获取这个值。</li>
<li><strong><code>takeLock</code> &amp; <code>notEmpty</code></strong>： <strong>出队锁</strong>。当线程要取元素时，需要先获取这把锁。如果队列为空，线程会在 <code>notEmpty</code> 条件上等待。</li>
<li><strong><code>putLock</code> &amp; <code>notFull</code></strong>： <strong>入队锁</strong>。当线程要放元素时，需要先获取这把锁。如果队列已满，线程会在 <code>notFull</code> 条件上等待。</li>
<li><strong><code>capacity</code></strong>： 队列的<strong>容量限制</strong>。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-7"><a href="#3-构造方法与初始化-7" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>LinkedBlockingQueue</code> 提供了三种构造方式：</p>
<ol>
<li><p><strong><code>public LinkedBlockingQueue()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 调用 <code>this(Integer.MAX_VALUE)</code>，即创建一个默认容量为 <code>Integer.MAX_VALUE</code> 的“无界”队列。</p>
</li>
<li><p><strong>特点</strong>： <strong>默认容量极大</strong>，在使用时要注意可能的内存耗尽（OOM）风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public LinkedBlockingQueue(int capacity)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 校验容量值，初始化 <code>head</code> 和 <code>last</code> 指向同一个<strong>哑元（Dummy）节点</strong>，并设置 <code>capacity</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>显式指定队列容量</strong>。这是<strong>推荐的使用方式</strong>，可以防止系统资源被耗尽。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个具有给定（固定）容量的 LinkedBlockingQueue。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 队列的容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果 capacity 不大于 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public LinkedBlockingQueue(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 使用 <code>Integer.MAX_VALUE</code> 容量初始化队列，然后获取 <code>putLock</code>（<strong>注意：这里会锁住所有的入队操作</strong>），遍历集合并将元素逐个加入队列。</p>
</li>
<li><p><strong>特点</strong>： <strong>用一个已有集合来构造</strong>。如果集合元素数量超过 <code>capacity</code>（这里默认是MAX），则会抛出 <code>IllegalStateException</code> (“Queue full”)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue，</span></span><br><span class="line"><span class="comment"> * 最初包含给定集合的元素，按集合迭代器的遍历顺序添加。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 其元素要放入此队列的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定集合或其任何元素为 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException 如果由于容量限制，此时无法添加所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    putLock.lock(); <span class="comment">// 从未在序列化中竞争的条件获取可见性</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">            enqueue(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e)); <span class="comment">// 内部入队方法</span></span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        count.set(n); <span class="comment">// 原子设置计数器</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-入队操作-Put-Offer"><a href="#4-入队操作-Put-Offer" class="headerlink" title="4. 入队操作(Put&#x2F;Offer)"></a>4. 入队操作(Put&#x2F;Offer)</h5><ul>
<li><p><strong><code>public void put(E e) throws InterruptedException</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑：</strong></p>
<ol>
<li>如果元素为 <code>null</code>，抛出 <code>NullPointerException</code>。</li>
<li>获取 <code>putLock</code>（可中断地）。<ol>
<li>检查当前元素数量 <code>count</code>：<ul>
<li>如果 <code>count == capacity</code>（队列已满），则当前线程在 <code>notFull</code> 条件上等待。</li>
</ul>
</li>
</ol>
</li>
<li>调用 <code>enqueue(Node&lt;E&gt; node)</code> 方法将新节点插入链表尾部。</li>
<li>原子性地增加 <code>count</code> (<code>c = count.getAndIncrement()</code>)。</li>
<li>如果增加后 <code>c + 1 &lt; capacity</code>（队列还没满），则唤醒一个可能在 <code>notFull</code> 上等待的<strong>生产者</strong>线程。</li>
<li>释放 <code>putLock</code>。</li>
<li>如果插入前队列是空的 (<code>c == 0</code>)，则还需要<strong>尝试唤醒可能在 <code>notEmpty</code> 上等待的消费者线程</strong>（这一步需要获取 <code>takeLock</code>）。</li>
</ol>
</li>
<li><p><strong>特点</strong>： <strong>阻塞</strong>。如果队列满，会一直等待直到有空位或被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队列尾部插入指定元素，如果必要则等待空间可用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException 如果在等待时被中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定元素为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当队列满时，等待 notFull 条件</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// 获取旧计数并自增</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 如果放入后还没满，唤醒其他生产者</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果放入前队列是空的 (c==0)，唤醒一个消费者</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有入队方法：将节点链接到 last 后面，并更新 last</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发出非空信号（需要获取 takeLock）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public boolean offer(E e, long timeout, TimeUnit unit)</code></strong>：</p>
<ul>
<li>逻辑与 <code>put</code> 类似，但使用 <code>notFull.awaitNanos(nanos)</code> 进行<strong>超时等待</strong>。</li>
<li>如果在超时时间内等到空位，则插入元素并返回 <code>true</code>。</li>
<li>如果超时时间到仍未等到空位，则返回 <code>false</code>。</li>
</ul>
</li>
<li><p><strong><code>public boolean offer(E e)</code></strong>：</p>
<ul>
<li><strong>非阻塞</strong>版本。</li>
<li>如果队列未满，则立即插入并返回 <code>true</code>。</li>
<li>如果队列已满，则<strong>立即返回 <code>false</code></strong>，不会等待。</li>
</ul>
</li>
</ul>
<h5 id="5-出队操作-Take-Poll"><a href="#5-出队操作-Take-Poll" class="headerlink" title="5. 出队操作(Take&#x2F;Poll)"></a>5. 出队操作(Take&#x2F;Poll)</h5><ul>
<li><p><strong><code>public E take() throws InterruptedException</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong></p>
<ol>
<li><p>获取 <code>takeLock</code>（可中断地）。</p>
<ol start="2">
<li>检查当前元素数量 <code>count</code>：<ul>
<li>如果 <code>count == 0</code>（队列为空），则当前线程在 <code>notEmpty</code> 条件上等待。</li>
</ul>
</li>
</ol>
</li>
<li><p>调用 <code>dequeue()</code> 方法从链表头部（<code>head.next</code>）取出元素。</p>
</li>
<li><p>原子性地减少 <code>count</code> (<code>c = count.getAndDecrement()</code>)。</p>
</li>
<li><p>如果减少后 <code>c &gt; 1</code>（队列还不为空），则唤醒一个可能在 <code>notEmpty</code> 上等待的<strong>消费者</strong>线程。</p>
</li>
<li><p>释放 <code>takeLock</code>。</p>
</li>
<li><p>如果取出前队列是满的 (<code>c == capacity</code>)，则还需要<strong>尝试唤醒可能在 <code>notFull</code> 上等待的生产者线程</strong>（这一步需要获取 <code>putLock</code>）。</p>
</li>
</ol>
</li>
<li><p><strong>特点</strong>： <strong>阻塞</strong>。如果队列空，会一直等待直到有元素或被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> E x;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当队列空时，等待 notEmpty 条件</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">// 获取旧计数并自减</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">// 如果取出后还不为空，唤醒其他消费者</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果取出前队列是满的 (c == capacity)，唤醒一个生产者</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有出队方法：移除头节点的下一个节点，并返回其 item</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;E&gt; h = head;      <span class="comment">// 当前头节点</span></span><br><span class="line">    Node&lt;E&gt; first = h.next; <span class="comment">// 第一个实际数据节点</span></span><br><span class="line">    h.next = h; <span class="comment">// 帮助 GC（断开原头节点的引用）</span></span><br><span class="line">    head = first;          <span class="comment">// 将第一个数据节点设为新的头节点</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;      <span class="comment">// 获取要返回的数据</span></span><br><span class="line">    first.item = <span class="literal">null</span>;     <span class="comment">// 将新头节点的 item 置为 null，恢复哑元状态</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发出非满信号（需要获取 putLock）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotFull</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E poll(long timeout, TimeUnit unit)</code></strong>：</p>
<ul>
<li>逻辑与 <code>take</code> 类似，但使用 <code>notEmpty.awaitNanos(nanos)</code> 进行<strong>超时等待</strong>。</li>
<li>如果在超时时间内等到元素，则取出并返回。</li>
<li>如果超时时间到仍未等到元素，则返回 <code>null</code>。</li>
</ul>
</li>
<li><p><strong><code>public E poll()</code></strong>：</p>
<ul>
<li><strong>非阻塞</strong>版本。</li>
<li>如果队列不为空，则立即取出并返回元素。</li>
<li>如果队列为空，则<strong>立即返回 <code>null</code></strong>，不会等待。</li>
</ul>
</li>
</ul>
<h5 id="6-查看元素-Peek"><a href="#6-查看元素-Peek" class="headerlink" title="6. 查看元素(Peek)"></a>6. 查看元素(Peek)</h5><ul>
<li><strong><code>public E peek()</code></strong>：<ul>
<li>获取 <code>takeLock</code>。</li>
<li>查看头节点的下一个节点（即第一个有效数据节点）的 <code>item</code> (<code>(head.next == null) ? null : head.next.item</code>)。</li>
<li>释放 <code>takeLock</code>。</li>
<li><strong>特点</strong>： <strong>只查看不移除</strong>，如果队列为空则返回 <code>null</code>。</li>
</ul>
</li>
</ul>
<h5 id="7-典型应用场景-1"><a href="#7-典型应用场景-1" class="headerlink" title="7.  典型应用场景"></a>7.  典型应用场景</h5><p><strong>1. 线程池的任务队列 (最经典的应用)</strong></p>
<p>这是 <code>LinkedBlockingQueue</code> 最重要、最广泛的应用场景，没有之一。</p>
<ul>
<li><strong>如何工作</strong>： Java <code>ThreadPoolExecutor</code> 的核心组件之一就是工作队列。当提交到线程池的任务数超过核心线程数时，新来的任务不会被立即执行，而是被放入这个工作队列中等待空闲的线程来处理。</li>
<li><strong>为什么是它</strong>：<ul>
<li><strong>线程安全</strong>： 线程池本身是多线程环境，任务提交（生产者）和工作线程获取任务（消费者）是并发进行的，必须保证队列操作的线程安全。</li>
<li><strong>阻塞特性</strong>： 当队列为空时，工作线程会通过 <code>take()</code> 方法被阻塞并等待，直到有新任务进来。这避免了工作线程无谓的循环空转，节省了CPU资源。</li>
<li><strong>管理负载</strong>： 作为有界队列使用时（<strong>推荐</strong>），它可以防止内存溢出。当队列满时，<code>ThreadPoolExecutor</code> 可以根据指定的拒绝策略来处理新提交的任务（如抛出异常、丢弃等），从而为系统提供背压（Backpressure）保护。</li>
</ul>
</li>
</ul>
<p><strong>简单来说，你所使用的 <code>ExecutorService</code>，其底层很可能就依赖 <code>LinkedBlockingQueue</code> 来管理待执行的任务。</strong></p>
<hr>
<p><strong>2. 通用的生产者-消费者问题</strong></p>
<p>任何需要解耦生产数据和消费数据过程的场景，都是 <code>LinkedBlockingQueue</code> 的用武之地。</p>
<ul>
<li><strong>日志记录</strong>： 多个应用线程（生产者）产生日志消息，并快速放入一个 <code>LinkedBlockingQueue</code>，然后由一个专门的日志线程（消费者）从队列中取出消息并写入磁盘文件。这样做避免了多个线程竞争磁盘IO，提升了性能。</li>
<li><strong>订单处理</strong>： 在电商系统中，用户下单（生产者）和后端的库存扣减、发货等复杂操作（消费者）可以解耦。订单先被放入队列，然后由后端的消费者线程池慢慢处理，峰值流量可以被队列缓冲，避免系统被冲垮。</li>
<li><strong>数据采集与处理</strong>： 从网络或传感器采集数据（生产者）的速度可能很快，但后续的数据分析处理（消费者）可能较慢。使用 <code>LinkedBlockingQueue</code> 作为中间缓冲区，可以平衡两者的速度差异。</li>
</ul>
<hr>
<p><strong>3. 实现异步处理和提高响应性</strong></p>
<p>通过将耗时的操作放入队列，交由后台线程处理，可以立即释放请求处理线程，从而快速响应用户。</p>
<ul>
<li><strong>Web服务器中的请求处理</strong>： 收到用户请求后，主线程可以迅速将需要处理的“任务对象”放入 <code>LinkedBlockingQueue</code>，然后立即返回一个“已接收”的响应。后台的工作线程会异步地从队列中取出任务并执行真正的耗时操作（如生成报表、发送邮件等）。</li>
</ul>
<hr>
<h4 id="2-4-3-ConcurrentLinkedQueue【了解】"><a href="#2-4-3-ConcurrentLinkedQueue【了解】" class="headerlink" title="2.4.3 ConcurrentLinkedQueue【了解】"></a>2.4.3 ConcurrentLinkedQueue【了解】</h4><h5 id="1-核心概念-11"><a href="#1-核心概念-11" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>ConcurrentLinkedQueue</code> 是一个基于<strong>单向链表</strong>实现的、<strong>无界的</strong>、<strong>线程安全</strong>的非阻塞队列。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>FIFO（先进先出）</strong>： 队列的头部是在队列中时间最长的元素，队列的尾部是在队列中时间最短的元素。</li>
<li><strong>线程安全（Thread-Safe）</strong>： 内部采用<strong>无锁（Lock-Free）</strong> 算法，使用 <strong>CAS（Compare-And-Swap）</strong> 操作来保证并发安全。这意味着它不会使用传统的锁（如 <code>synchronized</code> 或 <code>ReentrantLock</code>），从而避免了线程挂起和上下文切换的开销。</li>
<li><strong>非阻塞（Non-Blocking）</strong>： 所有操作（如 <code>offer</code>, <code>poll</code>）都采用<strong>忙等（Busy-Wait）</strong> 策略，通过循环不断尝试CAS操作直到成功，线程不会被挂起。这使得它在高并发、多线程竞争激烈的环境下通常能提供更好的吞吐量。</li>
<li><strong>无界（Unbounded）</strong>： 队列没有容量限制（仅受限于物理内存），因此 <code>put</code>&#x2F;<code>offer</code> 操作<strong>永远不会等待</strong>。</li>
<li><strong>弱一致性（Weakly Consistent）</strong>： 它的迭代器和 <code>size()</code> 等方法返回的是<strong>某一时刻的估计值</strong>，而不是精确的当前状态。这些方法主要用于监控，而不用于程序控制逻辑。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个<strong>单向链表</strong> (<code>Node</code>) 来存储元素。通过 <code>head</code> 和 <code>tail</code> 节点来维护队列的头部和尾部。所有修改操作（入队、出队）都通过 <strong>CAS</strong> 来原子性地更新链表指针（如 <code>next</code>, <code>tail</code>），如果CAS失败（被其他线程抢先修改），则循环重试。</li>
<li><strong>设计思想：基于单向链表+CAS 原子操作实现的无锁化、非阻塞、高并发 FIFO 队列，通过弱一致性迭代器和滞后指针策略，最大限度减少锁竞争，适合高并发、低延迟的消息传递场景。</strong></li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-9"><a href="#2-底层数据结构和关键属性-9" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>ConcurrentLinkedQueue</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">196745693267521676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点的静态内部类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="comment">// 使用 volatile 修饰，保证多线程下的可见性</span></span><br><span class="line">        <span class="keyword">volatile</span> E item;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E item) &#123;</span><br><span class="line">            <span class="comment">// 使用 lazySet 进行延迟写，是一种性能优化</span></span><br><span class="line">            UNSAFE.putObject(<span class="built_in">this</span>, itemOffset, item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 CAS 操作来修改节点的 item 和 next 字段</span></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">casItem</span><span class="params">(E cmp, E val)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, itemOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> &#123;</span><br><span class="line">            UNSAFE.putOrderedObject(<span class="built_in">this</span>, nextOffset, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略 Unsafe 机制的初始化代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的头节点（并非总是第一个元素节点，会被延迟更新）。</span></span><br><span class="line"><span class="comment">     * 约定：head.item 可能为 null（节点已出队），head != null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的尾节点（并非总是最后一个元素节点，会被延迟更新）。</span></span><br><span class="line"><span class="comment">     * 约定：tail.next 可能不为 null（并非真正的尾部），tail != null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>Node&lt;E&gt;</code></strong>： 链表的节点，是 <code>ConcurrentLinkedQueue</code> 的<strong>心脏</strong>。<ul>
<li><code>item</code> 和 <code>next</code> 都用 <code>volatile</code> 修饰，保证了多线程环境下的<strong>可见性</strong>。</li>
<li>提供了 <code>casItem</code> 和 <code>casNext</code> 方法，使用 <strong>CAS</strong> 来原子性地修改节点的内容，这是实现无锁算法的<strong>基石</strong>。</li>
</ul>
</li>
<li><strong><code>head</code></strong>： 指向链表的头部。为了性能优化，它并不总是精确地指向第一个元素节点（它可能指向一个已经被 <code>poll</code> 掉的“哑元”节点），这种策略称为**“延迟更新”**。</li>
<li><strong><code>tail</code></strong>： 指向链表的尾部。同样为了性能优化，它并不总是精确地指向最后一个元素节点（它可能滞后），这也是一种**“延迟更新”**策略。这可以减少CAS操作的次数，提升整体吞吐量。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-8"><a href="#3-构造方法与初始化-8" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>ConcurrentLinkedQueue</code> 提供了两种构造方式：</p>
<ol>
<li><p><strong><code>public ConcurrentLinkedQueue()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 初始化 <code>head</code> 和 <code>tail</code>，让它们都指向一个 <code>item</code> 为 <code>null</code> 的<strong>哑元节点</strong>。</p>
</li>
<li><p><strong>特点</strong>： 创建一个空队列。初始状态 <code>head = tail = new Node&lt;E&gt;(null)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个最初为空的 ConcurrentLinkedQueue。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentLinkedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public ConcurrentLinkedQueue(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 初始化队列后，遍历集合，调用 <code>add</code> (内部是 <code>offer</code>) 方法将元素逐个加入队列。</p>
</li>
<li><p><strong>特点</strong>： <strong>用一个已有集合来构造</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个最初包含给定集合元素的 ConcurrentLinkedQueue，</span></span><br><span class="line"><span class="comment"> * 按集合迭代器的遍历顺序添加。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 其元素要放入此队列的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定集合或其任何元素为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentLinkedQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Node&lt;E&gt; h = <span class="literal">null</span>, t = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span>)</span><br><span class="line">            h = t = newNode;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            t.lazySetNext(newNode);</span><br><span class="line">            t = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>)</span><br><span class="line">        h = t = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">    head = h;</span><br><span class="line">    tail = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-入队操作-Offer"><a href="#4-入队操作-Offer" class="headerlink" title="4. 入队操作(Offer)"></a>4. 入队操作(Offer)</h5><p><strong><code>public boolean offer(E e)</code></strong>：</p>
<ol>
<li><strong>检查非空</strong>： <code>checkNotNull(e)</code>，不允许插入 <code>null</code> 元素。</li>
<li><strong>创建新节点</strong>： <code>final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e)</code>。</li>
<li><strong>循环CAS尝试</strong>： 进入一个无限循环 <code>for (;;)</code>。<ul>
<li>获取当前的尾节点 <code>t</code> 和它的下一个节点 <code>p.next</code>。</li>
<li>如果 <code>p == null</code> (<code>p</code> 是真正的尾节点)，尝试用 <code>casNext(t, newNode)</code> 将新节点链入。<ul>
<li>如果成功，再尝试用 <code>casTail(t, newNode)</code> <strong>延迟更新</strong> <code>tail</code> 指针（即使这一步失败也没关系，其他线程后续会帮它完成更新）。</li>
<li>然后返回 <code>true</code>。</li>
</ul>
</li>
<li>如果 <code>p != null</code> 且 <code>p == q</code> (<code>p</code> 指向了自己，说明该节点已被移除)，说明 <code>tail</code> 已滞后，需要重新定位到新的 <code>head</code> 开始查找真正的尾节点。</li>
<li>否则，说明 <code>tail</code> 不是真正的尾节点，尝试将 <code>p</code> 作为新的候选尾节点，继续循环查找。</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>特点</strong>： <strong>无锁、非阻塞</strong>。通过循环CAS不断尝试，直到成功。由于无界，该方法<strong>永远不会返回 <code>false</code></strong>（除非传入 <code>null</code> 抛出异常）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 tail 节点开始循环尝试</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p 是最后一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="literal">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// CAS 成功，新节点已链接</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// 允许 tail 更新失败（跳一次）</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// 失败也没事</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CAS 失败，被其他线程抢先，重试</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// 遇到自链接节点，说明节点已被移除（p.next == p）</span></span><br><span class="line">            <span class="comment">// 需要从 head 重新开始查找（如果 tail 被修改，则从新的 tail 开始）</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 继续向后检查下一个节点</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-出队操作-Poll"><a href="#5-出队操作-Poll" class="headerlink" title="5. 出队操作(Poll)"></a>5. 出队操作(Poll)</h5><p><strong><code>public E poll()</code></strong>：</p>
<ol>
<li><strong>循环CAS尝试</strong>： 进入一个无限循环 <code>for (;;)</code>。<ul>
<li>获取当前的头节点 <code>h</code>，第一个元素节点 <code>p = h.next</code>，以及它的 item。</li>
<li>如果 <code>p == null</code>，队列为空，返回 <code>null</code>。</li>
<li>如果 <code>p != null</code>，尝试用 <code>casItem(p.item, null)</code> 将节点的 item 置为 <code>null</code>（标记为已移除）。<ul>
<li>如果成功，再尝试用 <code>casHead(h, p)</code> <strong>延迟更新</strong> <code>head</code> 指针（将 <code>head</code> 指向刚刚出队的节点，使其成为新的哑元头节点）。然后返回删除的元素。</li>
</ul>
</li>
<li>如果上述CAS失败，或者发现节点已被其他线程移除 (<code>p == q</code>)，则重新循环尝试。</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>特点</strong>： <strong>无锁、非阻塞</strong>。通过循环CAS不断尝试，直到成功或发现队列为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">item</span> <span class="operator">=</span> p.item;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前节点的 item 不为空，尝试 CAS 置 null</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="literal">null</span> &amp;&amp; p.casItem(item, <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// CAS 成功</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// 跳多次才更新一次 head</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="literal">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查 p 的下一个节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 队列为空</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="comment">// 节点已自移除，需要从 head 重新开始</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 移动到下一个节点继续尝试</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 head 节点</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h); <span class="comment">// 将旧 head 节点指向自己，帮助 GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-查看元素-Peek-1"><a href="#6-查看元素-Peek-1" class="headerlink" title="6. 查看元素(Peek)"></a>6. 查看元素(Peek)</h5><p><strong><code>public E peek()</code></strong>：</p>
<ul>
<li>与 <code>poll</code> 逻辑类似，但它只<strong>查看而不移除</strong>元素。</li>
<li>它获取第一个有效数据节点（<code>head.next</code>）的 <code>item</code>。</li>
<li>如果遇到已被移除的节点（<code>item == null</code>），它会继续寻找下一个有效节点。</li>
<li><strong>特点</strong>： 由于弱一致性，它可能返回 <code>null</code>，即使此时可能有其他线程正在入队元素。</li>
</ul>
<hr>
<h5 id="7-大小-Size-与弱一致性"><a href="#7-大小-Size-与弱一致性" class="headerlink" title="7. 大小(Size)与弱一致性"></a>7. 大小(Size)与弱一致性</h5><p><strong><code>public int size()</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>： 遍历整个链表，统计 <code>item != null</code> 的节点数量。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ol>
<li><strong>时间复杂度高</strong>： <code>O(n)</code>，需要遍历整个链表，效率很低。</li>
<li><strong>弱一致性</strong>： 在遍历过程中，队列可能被其他线程并发修改。因此，返回的 <code>size</code> <strong>只是一个估计值</strong>，不能用于精确的控制（如 <code>if (queue.size() &gt; 0) { ... }</code> 是<strong>错误</strong>的用法）。</li>
<li><strong>设计目的</strong>： 该方法通常仅用于监控和调试，<strong>不应用于核心的业务逻辑判断</strong>。判断队列是否为空应使用 <code>isEmpty()</code>，但它也是弱一致性的。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="8-线程安全与性能"><a href="#8-线程安全与性能" class="headerlink" title="8. 线程安全与性能"></a>8. 线程安全与性能</h5><ul>
<li><strong>无锁（Lock-Free）算法</strong>： 这是 <code>ConcurrentLinkedQueue</code> 高性能的核心。它通过 <strong>CAS</strong> 避免了使用重量级锁带来的性能开销（线程挂起、上下文切换、锁竞争）。在高并发场景下，它能提供极高的吞吐量。</li>
<li><strong>延迟更新（Lazy Update）</strong>： 对 <code>head</code> 和 <code>tail</code> 指针的更新不是每次操作都进行，而是采用“跳几次更新一次”的策略（HOPS）。这大大减少了CAS操作的次数，进一步提升了性能，但代价是增加了代码的复杂度和 <code>size()</code> 等方法的计算成本。</li>
<li><strong>ABA 问题</strong>： 无锁算法需要处理ABA问题（一个值从A变成B又变回A，CAS检查不出变化）。在此队列中，通过将已出队的节点 <code>next</code> 指针指向自己（<code>self-link</code>）来避免这个问题。</li>
</ul>
<hr>
<h5 id="9-典型应用场景-2"><a href="#9-典型应用场景-2" class="headerlink" title="9.  典型应用场景"></a>9.  典型应用场景</h5><p><strong>1. 高性能的生产者-消费者模型</strong></p>
<p>这是最经典的应用场景。当你有多个线程生产任务（生产者），多个线程处理任务（消费者）时，<code>ConcurrentLinkedQueue</code> 可以作为中间的任务传输通道。</p>
<ul>
<li><strong>为什么适用？</strong><ul>
<li><strong>高吞吐</strong>： 在生产者或消费者线程非常多的情况下，非阻塞算法能提供远超阻塞队列（如 <code>LinkedBlockingQueue</code>）的吞吐量。</li>
<li><strong>生产者无等待</strong>： 由于队列无界，生产者可以全力生产任务而不用担心被阻塞，特别适合“爆发性”的任务提交。</li>
</ul>
</li>
<li><strong>典型例子</strong>：<ul>
<li><strong>线程池任务调度</strong>： 许多高性能的线程池（如 <code>ForkJoinPool</code> 或 <code>Executors.newWorkStealingPool()</code> 背后的实现）在其内部工作窃取队列中使用了类似 <code>ConcurrentLinkedQueue</code> 的非阻塞算法。</li>
<li><strong>事件总线&#x2F;消息分发</strong>： 在一个事件驱动架构中，事件发布者（生产者）可以快速将事件放入队列，然后由多个事件处理器（消费者）异步取出并处理。例如，GUI应用中的点击事件处理、游戏服务器中的玩家操作事件等。</li>
<li><strong>日志记录</strong>： 多个应用线程将日志消息快速放入一个共享的 <code>ConcurrentLinkedQueue</code>，然后由一个专用的后台消费者线程负责将日志写入磁盘或网络。这样可以避免昂贵的 I&#x2F;O 操作阻塞主业务线程。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2. 连接池、资源池</strong></p>
<p><code>ConcurrentLinkedQueue</code> 可以用来实现一个轻量级的连接池或资源池。</p>
<ul>
<li><strong>为什么适用？</strong><ul>
<li><strong>借出和归还可以高度并发</strong>： 当大量线程同时请求和归还资源（如数据库连接、网络连接、对象实例）时，非阻塞的入队和出队操作效率极高。</li>
</ul>
</li>
<li><strong>如何实现</strong>：<ul>
<li>池初始化时，将所有空闲资源对象放入 <code>ConcurrentLinkedQueue</code>。</li>
<li>线程调用 <code>poll()</code> 尝试借出一个资源（如果队列为空则返回 <code>null</code>，池可以创建新资源或让线程等待）。</li>
<li>线程归还资源时，调用 <code>offer()</code> 方法将资源放回队列。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>3. 交换数据或传递消息</strong></p>
<p>在一些协作式多线程算法中，线程之间需要安全地交换一些数据或消息，而不希望因为锁而阻塞自己的执行流程。</p>
<ul>
<li><strong>为什么适用？</strong><ul>
<li><strong>非阻塞</strong>： 线程可以“顺便”尝试投递或获取一个消息，如果成功很好，如果不成功（例如队列空或满？但它无界所以不会满）就继续做其他事情，不会停滞</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-4-4-PriorityQueue【了解】"><a href="#2-4-4-PriorityQueue【了解】" class="headerlink" title="2.4.4 PriorityQueue【了解】"></a>2.4.4 PriorityQueue【了解】</h4><h5 id="1-核心概念-12"><a href="#1-核心概念-12" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>PriorityQueue</code> 是一个基于<strong>优先级堆（Priority Heap）</strong> 的无界优先级队列。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有序（Ordered）</strong>： 元素并非按插入顺序排序，而是根据其<strong>自然顺序（Natural Ordering）</strong> 或构造时提供的 <strong><code>Comparator</code>（比较器）</strong> 进行排序。队头（<code>peek</code>&#x2F;<code>poll</code>）总是当前优先级最高（或最低，取决于排序规则）的元素。</li>
<li><strong>不允许 <code>null</code> 元素</strong>： 尝试添加 <code>null</code> 会抛出 <code>NullPointerException</code>。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 多线程环境下需要额外同步。</li>
<li><strong>无界（Unbounded）</strong>： 队列的容量会根据需要自动增长。但有一个基于数组最大大小的限制（<code>MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8</code>）。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个 <strong>平衡二叉堆（通常是最小堆）</strong> 来实现，并使用 <strong><code>Object[]</code> 数组</strong> 来存储这个堆结构。所有操作（如入队、出队）都围绕着维护堆的特性来进行。</li>
<li><strong>设计思想</strong>：利用基于数组实现的完全二叉最小堆，通过上浮和下沉操作在 O(log n) 时间内完成入队和出队，保证队首始终是最高优先级元素，从而高效实现优先级队列。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-10"><a href="#2-底层数据结构和关键属性-10" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>PriorityQueue</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7720805057305804111L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级队列的底层存储数组。它维护了一个平衡二叉堆：</span></span><br><span class="line"><span class="comment">     * queue[n] 的两个孩子分别是 queue[2*n+1] 和 queue[2*(n+1)]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列中的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较器。如果为 null，则使用元素的自然顺序（元素必须实现 Comparable 接口）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改次数计数器，用于实现迭代器的快速失败机制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>queue</code></strong>： 这是 <code>PriorityQueue</code> 的<strong>心脏</strong>。所有元素都存储在这个数组中，并且<strong>数组的逻辑结构是一个二叉堆</strong>。</li>
<li><strong><code>comparator</code></strong>： 这是 <code>PriorityQueue</code> 的<strong>大脑</strong>。它决定了元素的排列顺序。如果为 <code>null</code>，则依赖元素自身的 <code>Comparable</code> 实现。</li>
<li><strong><code>size</code></strong>： 记录了队列中实际的有效元素数量。</li>
<li><strong><code>DEFAULT_INITIAL_CAPACITY</code></strong>： 默认初始容量（11）。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-9"><a href="#3-构造方法与初始化-9" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>PriorityQueue</code> 提供了多种构造方式，核心是初始化 <code>queue</code> 数组和 <code>comparator</code>。</p>
<ol>
<li><p><strong><code>public PriorityQueue()</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 使用默认初始容量（11），并且默认按元素的<strong>自然顺序</strong>排序（<code>comparator = null</code>）。</li>
<li><strong>特点</strong>： <strong>元素必须实现 <code>Comparable</code> 接口</strong>，否则在添加时会抛出 <code>ClassCastException</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public PriorityQueue(int initialCapacity)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 指定初始容量，但仍使用元素的自然顺序（<code>comparator = null</code>）。</li>
<li><strong>特点</strong>： 避免初期频繁扩容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 使用默认初始容量，但提供一个自定义的 <code>Comparator</code>。</li>
<li><strong>特点</strong>： <strong>元素无需实现 <code>Comparable</code> 接口</strong>，顺序完全由比较器决定。或者可以用此比较器覆盖元素自身的自然顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 综合以上两者，是最底层的构造器。</li>
<li><strong>特点</strong>： 完全自定义容量和排序规则。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                     Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public PriorityQueue(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 用一个已有集合来构造优先级队列。</li>
<li><strong>特点</strong>： 如果传入的集合是另一个 <code>SortedSet</code> 或 <code>PriorityQueue</code>，则会继承其比较器。否则使用自然顺序，并需要<strong>将无序集合“堆化”（Heapify）</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的是 SortedSet，继承其比较器</span></span><br><span class="line">        SortedSet&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; ss = (SortedSet&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt;) c;</span><br><span class="line">        <span class="built_in">this</span>.comparator = (Comparator&lt;? <span class="built_in">super</span> E&gt;) ss.comparator();</span><br><span class="line">        initElementsFromCollection(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的是 PriorityQueue，继承其比较器</span></span><br><span class="line">        PriorityQueue&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; pq = (PriorityQueue&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt;) c;</span><br><span class="line">        <span class="built_in">this</span>.comparator = (Comparator&lt;? <span class="built_in">super</span> E&gt;) pq.comparator();</span><br><span class="line">        initFromPriorityQueue(pq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他集合（如List, Set），使用自然顺序，并需要堆化</span></span><br><span class="line">        <span class="built_in">this</span>.comparator = <span class="literal">null</span>;</span><br><span class="line">        initFromCollection(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="4-扩容机制-Grow-1"><a href="#4-扩容机制-Grow-1" class="headerlink" title="4. 扩容机制 (Grow)"></a>4. 扩容机制 (Grow)</h5><p>当尝试向已满的数组（<code>size &gt;= queue.length</code>）添加新元素时，就会触发扩容。</p>
<p><strong>源码流程（以 <code>add(E e)</code> &#x2F; <code>offer(E e)</code> 为例）：</strong></p>
<ol>
<li><p><code>offer(E e)</code> -&gt; <code>if (i &gt;= size)</code> （判断容量是否已满）</p>
</li>
<li><p><code>grow(i + 1)</code> -&gt; <code>grow(int minCapacity)</code></p>
</li>
<li><p><strong><code>grow(int minCapacity)</code></strong>： <strong>扩容核心方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加数组容量以确保它至少可以容纳 minCapacity 个元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> queue.length;</span><br><span class="line">    <span class="comment">// 计算新容量：如果旧容量 &lt; 64，则 double (oldCapacity + oldCapacity + 2)；</span></span><br><span class="line">    <span class="comment">//            否则，增长 50% (oldCapacity + oldCapacity / 2)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 处理溢出情况</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 拷贝数据到新数组</span></span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// 溢出，minCapacity 变成了负数</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>扩容策略</strong>： 小容量时加倍增长（<code>&lt;64</code> 时 <code>old*2+2</code>），大容量时增长 50%（<code>old*1.5</code>），以避免频繁扩容。与 <code>ArrayList</code> 的固定 1.5 倍略有不同。</p>
<hr>
<h5 id="5-添加元素-Offer-Add"><a href="#5-添加元素-Offer-Add" class="headerlink" title="5. 添加元素(Offer&#x2F;Add)"></a>5. 添加元素(Offer&#x2F;Add)</h5><ul>
<li><p><strong><code>public boolean offer(E e)</code></strong>：</p>
<ol>
<li>检查元素是否为 <code>null</code>，是则抛 <code>NPE</code>。</li>
<li>修改计数器 <code>modCount++</code>。</li>
<li>判断容量，不足则扩容 <code>grow(size + 1)</code>。</li>
<li>调用 <code>siftUp(int k, E x)</code> <strong>“上浮”</strong> 操作，将新元素 <code>x</code> 从堆底 <code>k</code> 的位置开始，向上与父节点比较并交换，直到找到其正确的位置，以维持堆的性质。</li>
<li><code>size++</code>。</li>
<li>返回 <code>true</code>。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>： <strong><code>O(log n)</code></strong>。因为上浮操作最多需要遍历堆的高度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>); <span class="comment">// 扩容</span></span><br><span class="line">    siftUp(i, e);   <span class="comment">// 关键：上浮操作，维护堆结构</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据是否有比较器，选择不同的上浮方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x, queue, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x, queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自然顺序的上浮实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, T x, Object[] es)</span> &#123;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> T&gt; key = (Comparable&lt;? <span class="built_in">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 找到父节点的索引</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> es[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>) <span class="comment">// 如果当前节点 &gt;= 父节点，满足最小堆，停止</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        es[k] = e; <span class="comment">// 否则，父节点下沉</span></span><br><span class="line">        k = parent; <span class="comment">// 当前指针 k 上移到父节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    es[k] = key; <span class="comment">// 找到最终位置，放入元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public boolean add(E e)</code></strong>：</p>
<ul>
<li><p>内部直接调用 <code>offer(e)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-获取与删除队头元素-Poll-Remove"><a href="#6-获取与删除队头元素-Poll-Remove" class="headerlink" title="6. 获取与删除队头元素(Poll&#x2F;Remove)"></a>6. 获取与删除队头元素(Poll&#x2F;Remove)</h5><ul>
<li><p><strong><code>public E poll()</code></strong>：</p>
<ol>
<li>如果 <code>size == 0</code>，返回 <code>null</code>。</li>
<li>修改计数器 <code>modCount++</code>。</li>
<li>取出堆顶元素 <code>result = (E) queue[0]</code>（即优先级最高的元素）。</li>
<li>取出堆尾元素 <code>E x = (E) queue[s]</code>，并将堆尾置 <code>null</code>。</li>
<li><code>size--</code>。</li>
<li>如果队列不为空，调用 <code>siftDown(int k, E x)</code> <strong>“下沉”</strong> 操作，将堆尾元素 <code>x</code> 从堆顶 <code>k=0</code> 的位置开始，向下与子节点中较小的那个比较并交换，直到找到其正确的位置，以维持堆的性质。</li>
<li>返回取出的堆顶元素 <code>result</code>。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>： <strong><code>O(log n)</code></strong>。因为下沉操作最多需要遍历堆的高度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> E result;</span><br><span class="line">    <span class="keyword">if</span> ((result = (E) ((es = queue)[<span class="number">0</span>])) != <span class="literal">null</span>) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) es[(n = --size)]; <span class="comment">// 取出最后一个元素</span></span><br><span class="line">        es[n] = <span class="literal">null</span>; <span class="comment">// 最后一个位置置空</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            siftDown(<span class="number">0</span>, x); <span class="comment">// 关键：将最后一个元素放到顶部并下沉</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据是否有比较器，选择不同的下沉方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x, queue, size, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x, queue, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自然顺序的下沉实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, T x, Object[] es, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> T&gt; key = (Comparable&lt;? <span class="built_in">super</span> T&gt;) x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> n &gt;&gt;&gt; <span class="number">1</span>;           <span class="comment">// 只需要遍历到非叶子节点（无子节点的节点）即可</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左孩子索引</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> es[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;    <span class="comment">// 右孩子索引</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="built_in">super</span> T&gt;) c).compareTo((T) es[right]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果右孩子存在且比左孩子小，则 c 指向右孩子（选择更小的孩子）</span></span><br><span class="line">            c = es[child = right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>) <span class="comment">// 如果当前节点 &lt;= 最小的孩子，满足堆，停止</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        es[k] = c; <span class="comment">// 否则，最小的孩子上浮</span></span><br><span class="line">        k = child; <span class="comment">// 当前指针 k 下移到孩子位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    es[k] = key; <span class="comment">// 找到最终位置，放入元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E remove()</code></strong>：</p>
<ul>
<li><p>内部调用 <code>poll()</code>，但如果队列为空会抛出 <code>NoSuchElementException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="7-查看队头元素-Peek-Element"><a href="#7-查看队头元素-Peek-Element" class="headerlink" title="7. 查看队头元素(Peek&#x2F;Element)"></a>7. 查看队头元素(Peek&#x2F;Element)</h5><ul>
<li><p><strong><code>public E peek()</code></strong>：</p>
<ul>
<li><p>直接返回 <code>(E) queue[0]</code>。</p>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E element()</code></strong>：</p>
<ul>
<li><p>内部调用 <code>peek()</code>，但如果队列为空会抛出 <code>NoSuchElementException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">element</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> peek();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="8-查找-Contains-与删除指定元素-Remove"><a href="#8-查找-Contains-与删除指定元素-Remove" class="headerlink" title="8. 查找(Contains)与删除指定元素(Remove)"></a>8. 查找(Contains)与删除指定元素(Remove)</h5><ul>
<li><p><strong><code>public boolean contains(Object o)</code></strong>：</p>
<ul>
<li><strong>源码逻辑</strong>： 直接遍历底层数组 <code>queue</code>，使用 <code>equals</code> 方法进行比较。</li>
<li><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。无法利用堆的特性进行高效查找。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] es = queue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = size; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public boolean remove(Object o)</code></strong>：</p>
<ul>
<li><strong>源码逻辑</strong>：<ol>
<li>先调用 <code>indexOf(o)</code> 找到元素索引 <code>i</code>。</li>
<li>如果没找到 (<code>i == -1</code>)，返回 <code>false</code>。</li>
<li>调用 <code>removeAt(int i)</code> 方法删除该索引处的元素。</li>
</ol>
</li>
<li><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>（查找 <code>O(n)</code> + 删除 <code>O(log n)</code> ≈ <code>O(n)</code>）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定位置的元素</span></span><br><span class="line">E <span class="title function_">removeAt</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = queue;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size; <span class="comment">// size 先减 1</span></span><br><span class="line">    <span class="keyword">if</span> (s == i) &#123; <span class="comment">// 如果删除的是最后一个元素，直接置空即可</span></span><br><span class="line">        es[i] = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">moved</span> <span class="operator">=</span> (E) es[s]; <span class="comment">// 取出最后一个元素</span></span><br><span class="line">        es[s] = <span class="literal">null</span>;        <span class="comment">// 最后一个位置置空</span></span><br><span class="line">        siftDown(i, moved);  <span class="comment">// 先尝试将最后一个元素在 i 位置下沉</span></span><br><span class="line">        <span class="comment">// 如果下沉后 moved 元素还在原位 i，说明它无法下沉，</span></span><br><span class="line">        <span class="comment">// 可能需要尝试上浮（例如，它比子节点小，但比父节点大）</span></span><br><span class="line">        <span class="keyword">if</span> (es[i] == moved) &#123;</span><br><span class="line">            siftUp(i, moved); <span class="comment">// 尝试上浮</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 返回被删除的元素（此处省略）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="9-遍历方式-1"><a href="#9-遍历方式-1" class="headerlink" title="9. 遍历方式"></a>9. 遍历方式</h5><ul>
<li><strong>迭代器（Iterator）</strong>： 通过 <code>iterator()</code> 方法返回的迭代器进行遍历。<ul>
<li><strong>重要警告</strong>： <strong>迭代器不保证以任何特定的顺序遍历队列中的元素</strong>。它只是简单地遍历底层数组。如果需要按优先级顺序处理，应该使用 <code>poll()</code> 循环取出。</li>
</ul>
</li>
<li><strong><code>Object[] toArray()</code></strong>： 返回包含队列所有元素的数组。<ul>
<li><strong>同样不保证顺序</strong>。数组是底层 <code>queue</code> 数组的拷贝，但未经过堆排序。</li>
</ul>
</li>
</ul>
<p><strong>最佳实践</strong>： <strong>永远不要使用迭代器或 <code>toArray()</code> 来获取有序序列</strong>。唯一能保证顺序的操作是循环调用 <code>poll()</code>。</p>
<hr>
<h4 id="2-4-5-ArrayBlockingQueue【了解】"><a href="#2-4-5-ArrayBlockingQueue【了解】" class="headerlink" title="2.4.5 ArrayBlockingQueue【了解】"></a>2.4.5 ArrayBlockingQueue【了解】</h4><h5 id="1-核心概念-13"><a href="#1-核心概念-13" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>ArrayBlockingQueue</code> 是一个由<strong>数组</strong>支持的、<strong>有界的</strong>、<strong>阻塞的</strong>、<strong>线程安全的</strong> FIFO（先进先出）队列。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有界（Bounded）</strong>： 队列的容量在创建时被固定，一旦满员，尝试插入的操作将被阻塞。</li>
<li><strong>阻塞（Blocking）</strong>： 当队列操作条件不满足时（如空队列取元素，满队列存元素），调用线程会被<strong>阻塞</strong>，直到条件满足或被中断。</li>
<li><strong>线程安全（Thread-Safe）</strong>： 所有公共方法都通过一个<strong>全局锁（ReentrantLock）</strong> 来实现线程安全。</li>
<li><strong>FIFO（First-In-First-Out）</strong>： 队列头是在队列中时间最长的元素，队列尾是在队列中时间最短的元素。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个定长的 <code>Object[]</code> 数组来存储元素，通过两个索引 (<code>takeIndex</code>, <code>putIndex</code>) 来实现循环数组（Circular Array）。通过一个 <code>ReentrantLock</code> 和与之关联的两个 <code>Condition</code>（<code>notEmpty</code>, <code>notFull</code>) 来实现线程间的等待&#x2F;通知机制。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-11"><a href="#2-底层数据结构和关键属性-11" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>ArrayBlockingQueue</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">817911632652898426L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 存储元素的底层数组 */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下一个要执行 take, poll, peek 或 remove 操作的索引位置 */</span></span><br><span class="line">    <span class="type">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下一个要执行 put, offer, 或 add 操作的索引位置 */</span></span><br><span class="line">    <span class="type">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 队列中的元素个数 */</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 保护所有访问的主锁 */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于等待“非空”条件的 Condition */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于等待“未满”条件的 Condition */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>items</code></strong>： 定长数组，是队列的存储核心。</li>
<li><strong><code>takeIndex</code> &amp; <code>putIndex</code></strong>： 这两个索引是实现<strong>循环数组</strong>的关键。当索引到达数组末尾时，会绕回数组开头（<code>0</code>）。</li>
<li><strong><code>count</code></strong>： 当前队列中的元素数量。</li>
<li><strong><code>lock</code></strong>： <strong>全局锁（<code>ReentrantLock</code>）</strong>。所有对队列的访问都必须先获得此锁，这是实现线程安全的基础。</li>
<li><strong><code>notEmpty</code> &amp; <code>notFull</code></strong>： 两个 <code>Condition</code> 对象，分别与“队列不为空”和“队列未满”这两个条件关联。当条件不满足时，线程会在这些条件上等待；当条件可能被满足时，其他线程会唤醒在此条件上等待的线程。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-10"><a href="#3-构造方法与初始化-10" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>ArrayBlockingQueue</code> 提供了三种构造方式，核心是初始化数组和锁。</p>
<ol>
<li><p><strong><code>public ArrayBlockingQueue(int capacity)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 创建指定容量的队列，默认使用<strong>非公平</strong>的锁策略。</li>
<li><strong>特点</strong>： 非公平锁的吞吐量通常更高，但可能造成线程饥饿。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(capacity, <span class="literal">false</span>); <span class="comment">// 默认非公平锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public ArrayBlockingQueue(int capacity, boolean fair)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 创建指定容量的队列，并指定锁的公平性。</li>
<li><strong>特点</strong>： 如果 <code>fair</code> 为 <code>true</code>，则锁使用公平策略，等待时间最长的线程会优先获得锁，避免饥饿，但可能会降低整体吞吐量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity]; <span class="comment">// 初始化定长数组</span></span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);     <span class="comment">// 创建指定公平策略的锁</span></span><br><span class="line">    notEmpty = lock.newCondition();     <span class="comment">// 从锁创建条件变量</span></span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 创建指定容量和锁策略的队列，并用一个集合来初始化。</li>
<li><strong>特点</strong>： 初始化操作也会在锁的保护下进行，保证线程安全。如果集合大小超过指定容量，会抛出异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair,</span></span><br><span class="line"><span class="params">                          Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(capacity, fair); <span class="comment">// 调用双参数构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 初始化也需要加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                items[i++] = e; <span class="comment">// 将集合元素放入数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        count = i;         <span class="comment">// 更新元素数量</span></span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i; <span class="comment">// 更新 putIndex</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 必须在 finally 块中解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="4-扩容机制"><a href="#4-扩容机制" class="headerlink" title="4. 扩容机制"></a>4. 扩容机制</h5><ul>
<li><strong><code>ArrayBlockingQueue</code> 是有界队列，创建后容量固定，不支持动态扩容。</strong> 这是它与 <code>ArrayList</code> 和 <code>PriorityQueue</code> 最根本的区别之一。尝试向已满队列添加元素的操作会根据不同方法而阻塞、返回特殊值或抛出异常。</li>
</ul>
<hr>
<h5 id="5-添加元素-Put-Offer-Add"><a href="#5-添加元素-Put-Offer-Add" class="headerlink" title="5. 添加元素(Put&#x2F;Offer&#x2F;Add)"></a>5. 添加元素(Put&#x2F;Offer&#x2F;Add)</h5><ul>
<li><p><strong><code>public void put(E e) throws InterruptedException</code></strong>：</p>
<ol>
<li>检查非空，可响应中断。</li>
<li>获取锁 <code>lock.lockInterruptibly()</code>。</li>
<li>循环检查 <code>while (count == items.length)</code>，如果队列满，则在 <code>notFull</code> 条件上等待 <code>notFull.await()</code>。</li>
<li>调用 <code>enqueue(E x)</code> 方法将元素入队。</li>
<li>释放锁 <code>lock.unlock()</code>。</li>
</ol>
<ul>
<li><p><strong>特点</strong>： <strong>阻塞</strong>。如果队列满，当前线程会一直等待，直到有空间被唤醒或被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 获取可中断的锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) <span class="comment">// 循环检查（防止虚假唤醒）</span></span><br><span class="line">            notFull.await();         <span class="comment">// 在 notFull 条件上等待</span></span><br><span class="line">        enqueue(e);                  <span class="comment">// 队列未满，执行入队</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入队核心方法（必须在持有锁时调用）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    items[putIndex] = x; <span class="comment">// 将元素放入 putIndex 位置</span></span><br><span class="line">    <span class="comment">// 循环数组：如果 putIndex 到达末尾，则绕回 0</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;             <span class="comment">// 元素数量增加</span></span><br><span class="line">    notEmpty.signal();   <span class="comment">// 唤醒一个在 notEmpty 上等待的线程（消费者）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public boolean offer(E e)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>： 与 <code>put</code> 类似，但<strong>非阻塞</strong>。如果队列满，立即返回 <code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length) <span class="comment">// 队列已满</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;         <span class="comment">// 立即返回 false</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);          <span class="comment">// 队列未满，执行入队</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;         <span class="comment">// 返回 true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>： <strong>超时阻塞</strong>。如果队列满，会在 <code>notFull</code> 条件上等待指定的超时时间。如果在超时前被唤醒或有空间了，则入队；如果超时了还是满的，则返回 <code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout); <span class="comment">// 转换为纳秒</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)      <span class="comment">// 超时时间已用完</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// 返回 false</span></span><br><span class="line">            nanos = notFull.awaitNanos(nanos); <span class="comment">// 进行超时等待，返回剩余时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public boolean add(E e)</code></strong>：</p>
<ul>
<li>内部调用 <code>offer(e)</code>。</li>
<li>如果队列满，<code>offer(e)</code> 返回 <code>false</code>，<code>add</code> 会抛出 <code>IllegalStateException(&quot;Queue full&quot;)</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-获取与删除队头元素-Take-Poll-Remove"><a href="#6-获取与删除队头元素-Take-Poll-Remove" class="headerlink" title="6. 获取与删除队头元素(Take&#x2F;Poll&#x2F;Remove)"></a>6. 获取与删除队头元素(Take&#x2F;Poll&#x2F;Remove)</h5><ul>
<li><p><strong><code>public E take() throws InterruptedException</code></strong>：</p>
<ol>
<li>获取可中断的锁。</li>
<li>循环检查 <code>while (count == 0)</code>，如果队列空，则在 <code>notEmpty</code> 条件上等待 <code>notEmpty.await()</code>。</li>
<li>调用 <code>dequeue()</code> 方法将元素出队。</li>
<li>释放锁。</li>
<li>返回取出的元素。</li>
</ol>
<ul>
<li><p><strong>特点</strong>： <strong>阻塞</strong>。如果队列空，当前线程会一直等待，直到有元素被唤醒或被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)     <span class="comment">// 循环检查（防止虚假唤醒）</span></span><br><span class="line">            notEmpty.await(); <span class="comment">// 在 notEmpty 条件上等待</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();     <span class="comment">// 队列不空，执行出队</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队核心方法（必须在持有锁时调用）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex]; <span class="comment">// 取出 takeIndex 位置的元素</span></span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;    <span class="comment">// 将该位置置空，帮助 GC</span></span><br><span class="line">    <span class="comment">// 循环数组：如果 takeIndex 到达末尾，则绕回 0</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;                <span class="comment">// 元素数量减少</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">        itrs.elementDequeued(); <span class="comment">// 更新迭代器状态（如果存在）</span></span><br><span class="line">    notFull.signal();       <span class="comment">// 唤醒一个在 notFull 上等待的线程（生产者）</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E poll()</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>： <strong>非阻塞</strong>。如果队列空，立即返回 <code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue(); <span class="comment">// 三目运算</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E poll(long timeout, TimeUnit unit) throws InterruptedException</code></strong>：</p>
<ul>
<li><strong>源码逻辑</strong>： <strong>超时阻塞</strong>。与 <code>offer(E, long, TimeUnit)</code> 逻辑类似，但是在 <code>notEmpty</code> 条件上等待。</li>
</ul>
</li>
<li><p><strong><code>public E remove()</code></strong>：</p>
<ul>
<li>内部调用 <code>poll()</code>。</li>
<li>如果队列空，<code>poll()</code> 返回 <code>null</code>，<code>remove</code> 会抛出 <code>NoSuchElementException</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="7-查看队头元素-Peek-Element-1"><a href="#7-查看队头元素-Peek-Element-1" class="headerlink" title="7. 查看队头元素(Peek&#x2F;Element)"></a>7. 查看队头元素(Peek&#x2F;Element)</h5><ul>
<li><p><strong><code>public E peek()</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>： 加锁后，直接返回 <code>(E) items[takeIndex]</code>（即队头元素），但<strong>不移除</strong>它。如果队列为空则返回 <code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// 如果队列空，返回 null</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> E <span class="title function_">itemAt</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E element()</code></strong>：</p>
<ul>
<li>内部调用 <code>peek()</code>，但如果队列为空会抛出 <code>NoSuchElementException</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="8-遍历方式-2"><a href="#8-遍历方式-2" class="headerlink" title="8. 遍历方式"></a>8. 遍历方式</h5><ul>
<li><strong>迭代器（Iterator）</strong>： 通过 <code>iterator()</code> 方法返回的迭代器进行遍历。<ul>
<li><strong>特点</strong>： 迭代器是<strong>弱一致性（Weakly Consistent）</strong> 的。它反映的是创建迭代器那一刻或之后某个时刻的队列状态，<strong>不会抛出 <code>ConcurrentModificationException</code></strong>，但可能不会反映出迭代过程中所有的修改。</li>
<li>迭代器的实现同样需要获取主锁，以保证遍历过程中状态的相对一致性。</li>
</ul>
</li>
</ul>
<p><strong>最佳实践</strong>： <code>ArrayBlockingQueue</code> 是实现<strong>生产者-消费者（Producer-Consumer）</strong> 模式的经典工具。生产者线程调用 <code>put()</code> 或 <code>offer()</code>，消费者线程调用 <code>take()</code> 或 <code>poll()</code>，通过内置的锁和条件变量高效地协调工作。</p>
<hr>
<h4 id="2-4-6-Deque-继承"><a href="#2-4-6-Deque-继承" class="headerlink" title="2.4.6 Deque(继承)"></a>2.4.6 Deque(继承)</h4><p><code>Deque</code>（Double Ended Queue，发音为 “deck”）是 <code>Queue</code> 的直接子接口。它支持在<strong>队列的两端</strong>插入、移除和检查元素。因此，它既可以作为 FIFO 的<strong>队列</strong>使用，也可以作为 LIFO 的<strong>栈</strong>使用。</p>
<h5 id="1-核心特征：-1"><a href="#1-核心特征：-1" class="headerlink" title="1.核心特征："></a>1.<strong>核心特征：</strong></h5><ol>
<li><strong>双端操作（Double-Ended）</strong>： 这是其最核心的特征，允许在头部和尾部进行添加、删除和查看操作。</li>
<li><strong>可作队列和栈（Queue &amp; Stack）</strong>： 它完全包含了 <code>Queue</code> 的所有功能，并且提供了一组与 <code>Stack</code> 类（古老类，不推荐使用）等效的方法。</li>
<li><strong>无索引（Non-Indexed）</strong>： 同样<strong>不能</strong>通过索引访问中间的元素。</li>
<li><strong>方法对（Method Pairs）</strong>： 对于每个操作，都提供了针对“第一端”（头部）和“最后一端”（尾部）的两个方法，并且每个方法都有“抛出异常”和“返回特殊值”两种形式。</li>
</ol>
<h5 id="2-特有的核心方法-1"><a href="#2-特有的核心方法-1" class="headerlink" title="2.特有的核心方法"></a>2.<strong>特有的核心方法</strong></h5><p><code>Deque</code> 的方法非常对称，其方法名通常以 <code>First</code>（头部）或 <code>Last</code>（尾部）结尾。</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>头部（First Element &#x2F; Head）</th>
<th>尾部（Last Element &#x2F; Tail）</th>
<th>等效的栈方法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>插入</strong></td>
<td><code>void addFirst(E e)</code></td>
<td><code>void addLast(E e)</code></td>
<td></td>
</tr>
<tr>
<td><strong>移除</strong></td>
<td><code>E removeFirst()</code></td>
<td><code>E removeLast()</code></td>
<td><code>E pop()</code></td>
</tr>
<tr>
<td><strong>检查</strong></td>
<td><code>E getFirst()</code></td>
<td><code>E getLast()</code></td>
<td><code>E peek()</code></td>
</tr>
</tbody></table>
<p><strong>说明</strong>：</p>
<ul>
<li><strong>作为队列（FIFO）</strong>：<ul>
<li><strong>入队</strong>：使用 <code>addLast(e)</code> &#x2F; <code>offerLast(e)</code></li>
<li><strong>出队</strong>：使用 <code>removeFirst()</code> &#x2F; <code>pollFirst()</code></li>
</ul>
</li>
<li><strong>作为栈（LIFO）</strong>：<ul>
<li><strong>入栈（Push）</strong>：使用 <code>addFirst(e)</code> &#x2F; <code>push(e)</code></li>
<li><strong>出栈（Pop）</strong>：使用 <code>removeFirst()</code> &#x2F; <code>pop()</code></li>
<li><strong>查看栈顶（Peek）</strong>：使用 <code>getFirst()</code> &#x2F; <code>peekFirst()</code> &#x2F; <code>peek()</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-4-7-ArrayDeque【了解】"><a href="#2-4-7-ArrayDeque【了解】" class="headerlink" title="2.4.7 ArrayDeque【了解】"></a>2.4.7 ArrayDeque【了解】</h4><h5 id="1-核心概念-14"><a href="#1-核心概念-14" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>ArrayDeque</code> 是 <code>Deque</code> 接口的<strong>基于可变数组的实现</strong>。<code>Deque</code> 是“Double Ended Queue”的缩写，即双端队列。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>双端操作</strong>： 可以在队列的<strong>头部</strong>和<strong>尾部</strong>高效地进行插入、删除和查看操作。</li>
<li><strong>无容量限制</strong>： 像 <code>ArrayList</code> 一样，会根据需要自动扩容。</li>
<li><strong>非线程安全</strong>： 多线程环境下未经同步直接使用会导致不确定的结果。</li>
<li><strong>禁止 null 元素</strong>： 不允许插入 <code>null</code> 元素，因为 <code>null</code> 被用作某些方法的特殊返回值（如 poll 失败时返回 <code>null</code>）。</li>
<li><strong>性能</strong>： 作为栈使用时，性能优于 <code>Stack</code>；作为队列使用时，性能优于 <code>LinkedList</code>。它是大多数场景下实现栈和队列的<strong>首选</strong>。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个 <strong><code>Object[] elements</code></strong> 数组来存储所有元素。通过两个整型变量 <strong><code>head</code></strong> 和 <strong><code>tail</code></strong> 来标记队列的头部和尾部，从而构成一个<strong>逻辑上的循环数组</strong>。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-12"><a href="#2-底层数据结构和关键属性-12" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>ArrayDeque</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt;</span><br><span class="line">                           <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;E&gt;, Cloneable, Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储双端队列元素的数组。</span></span><br><span class="line"><span class="comment">     * 双端队列的容量就是这个数组的长度，它总是 2 的幂。</span></span><br><span class="line"><span class="comment">     * 数组永远不允许变满，除非在 addX 方法中短暂地变满，然后立即调整大小（参见双倍容量）。</span></span><br><span class="line"><span class="comment">     * 这避免了 head 和 tail 缠绕在一起时变得相等。</span></span><br><span class="line"><span class="comment">     * 数组也永远不允许变空，但会保持至少一个空位。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头部元素的索引（即将被 remove() 或 pop() 移除的元素）。</span></span><br><span class="line"><span class="comment">     * 如果双端队列为空，head 可能等于 tail。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个元素将被添加到尾部的索引（通过 addLast(E), add(E), offer(E)）。</span></span><br><span class="line"><span class="comment">     * 如果双端队列为空，tail 可能等于 head。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小初始容量，必须是 2 的幂。</span></span><br><span class="line"><span class="comment">     * 至少为 8。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>elements</code></strong>： 这是 <code>ArrayDeque</code> 的<strong>存储核心</strong>。所有元素都存储在这个数组中。</li>
<li><strong><code>head</code></strong>： <strong>头部索引</strong>。指向当前队列中<strong>第一个有效元素</strong>的位置。</li>
<li><strong><code>tail</code></strong>： <strong>尾部索引</strong>。指向当前队列中<strong>下一个元素将被添加的位置</strong>（即最后一个有效元素的下一个空位）。</li>
<li><strong><code>MIN_INITIAL_CAPACITY</code></strong>： 最小初始容量（8）。底层数组的容量<strong>永远是 2 的幂</strong>，这是为了使用位运算 (<code>&amp; (length-1)</code>) 来高效计算索引，实现数组的循环利用。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-11"><a href="#3-构造方法与初始化-11" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>ArrayDeque</code> 提供了三种构造方式：</p>
<ol>
<li><p><strong><code>public ArrayDeque()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 将数组初始化为一个默认大小的空数组（通常是 16，但具体实现是 <code>calculateSize(numElements)</code> 方法计算的结果）。</p>
</li>
<li><p><strong>特点</strong>： <strong>默认构造器</strong>。创建一个初始容量为 16 的空数组双端队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量为 16 的空数组双端队列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span> &#123;</span><br><span class="line">    elements = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">16</span>]; <span class="comment">// 实际上是调用 calculateSize(16) 的结果，但 16 正好是 2 的幂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public ArrayDeque(int numElements)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 调用 <code>allocateElements(numElements)</code> 方法，该方法会计算一个<strong>大于等于 <code>numElements</code> 的最小的 2 的幂</strong>作为初始容量。</p>
</li>
<li><p><strong>特点</strong>： <strong>显式指定初始容量</strong>。避免一开始就进行多次扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量足以容纳指定数量元素的空数组双端队列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numElements 要容纳的元素数量的下限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">    elements = <span class="keyword">new</span> <span class="title class_">Object</span>[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算容量，返回大于等于 numElements 的最小的 2 的幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateSize</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">initialCapacity</span> <span class="operator">=</span> MIN_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">// 如果指定了更大的容量，则计算最小的 2 的幂来容纳它</span></span><br><span class="line">    <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">        initialCapacity = numElements;</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        initialCapacity++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// 太大，溢出了</span></span><br><span class="line">            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>; <span class="comment">// 回退到 2^30</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public ArrayDeque(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 使用默认构造器的逻辑初始化一个足够大的数组，然后使用 <code>addAll(c)</code> 将集合中的所有元素添加到双端队列的尾部。</p>
</li>
<li><p><strong>特点</strong>： <strong>用一个已有集合来构造</strong>，元素顺序由该集合的迭代器决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定集合所有元素的双端队列，</span></span><br><span class="line"><span class="comment"> * 元素顺序由集合的迭代器返回顺序决定。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 其元素要被放入此双端队列的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    allocateElements(c.size());</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-扩容机制-doubleCapacity"><a href="#4-扩容机制-doubleCapacity" class="headerlink" title="4. 扩容机制 (doubleCapacity)"></a>4. 扩容机制 (doubleCapacity)</h5><p>当队列已满（即 <code>head == tail</code>）时，尝试添加元素就会触发扩容。</p>
<p><strong>源码流程：</strong></p>
<ol>
<li><p>判断 <code>head</code> 是否等于 <code>tail</code>。</p>
</li>
<li><p>调用 <strong><code>doubleCapacity()</code></strong>： <strong>扩容核心方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将双端队列的容量增加一倍。</span></span><br><span class="line"><span class="comment"> * 仅在 head == tail 时调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doubleCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 断言：head == tail，队列已满</span></span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> elements.length; <span class="comment">// 旧数组长度</span></span><br><span class="line">    <span class="comment">// head 右边（到数组末尾）的元素数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - p; </span><br><span class="line">    <span class="comment">// 新容量是旧容量的两倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 检查是否溢出</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    Object[] a = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 分两段拷贝数据到新数组</span></span><br><span class="line">    <span class="comment">// 1. 拷贝从 head 到数组末尾的元素 [p, n)</span></span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">    <span class="comment">// 2. 拷贝从数组开头到 head 的元素 [0, p)</span></span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">    <span class="comment">// 更新 elements 引用</span></span><br><span class="line">    elements = a;</span><br><span class="line">    <span class="comment">// 重置 head 和 tail</span></span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n; <span class="comment">// n 是旧数组长度，也是新数组中有效元素的末尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>关键点</strong>：</p>
<ul>
<li>新容量是旧容量的<strong>两倍</strong>。</li>
<li>拷贝数据时分为两段：从 <code>head</code> 到数组末尾，以及从数组开头到 <code>head</code>。这是因为 <code>ArrayDeque</code> 是循环数组，<code>head</code> 可能在数组中间。</li>
<li>扩容后，<code>head</code> 被重置为 <code>0</code>，<code>tail</code> 被重置为旧数组的长度 <code>n</code>，整个队列在物理上变得连续。</li>
</ul>
<hr>
<h5 id="5-添加元素-Add-1"><a href="#5-添加元素-Add-1" class="headerlink" title="5. 添加元素(Add)"></a>5. 添加元素(Add)</h5><ul>
<li><p><strong>头部添加 <code>public void addFirst(E e)</code> &#x2F; <code>offerFirst(E e)</code></strong>：</p>
<ol>
<li>检查元素是否为 <code>null</code>，是则抛出 <code>NullPointerException</code>。</li>
<li>将 <code>head</code> 指针<strong>向前（向左）移动一位</strong>。由于是循环数组，使用 <code>(head - 1) &amp; (elements.length - 1)</code> 计算新位置（利用了 <code>length</code> 是 2 的幂的特性，<code>&amp; (length-1)</code> 等价于 <code>% length</code>，但效率更高）。</li>
<li>将新元素放入新的 <code>head</code> 位置。</li>
<li>检查是否 <code>head == tail</code>，如果是则调用 <code>doubleCapacity()</code> 扩容。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>： <strong>摊销常数时间 <code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 计算新的 head 位置： (head - 1) mod (elements.length)</span></span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements;</span><br><span class="line">    es[head = dec(head, es.length)] = e;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        grow(<span class="number">1</span>); <span class="comment">// 最终会调用 doubleCapacity()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算前移一位的索引（循环）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> modulus)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (--i &lt; <span class="number">0</span>) i = modulus - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更高效的位运算写法（因为 modulus 是 2 的幂）：</span></span><br><span class="line"><span class="comment">// head = (head - 1) &amp; (elements.length - 1)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>尾部添加 <code>public void addLast(E e)</code> &#x2F; <code>offerLast(E e)</code> &#x2F; <code>add(E e)</code> &#x2F; <code>offer(E e)</code></strong>：</p>
<ol>
<li>检查元素是否为 <code>null</code>。</li>
<li>将新元素放入当前的 <code>tail</code> 位置。</li>
<li>将 <code>tail</code> 指针<strong>向后（向右）移动一位</strong>，使用 <code>(tail + 1) &amp; (elements.length - 1)</code> 计算新位置。</li>
<li>检查是否 <code>head == tail</code>，如果是则调用 <code>doubleCapacity()</code> 扩容。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>： <strong>摊销常数时间 <code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements;</span><br><span class="line">    es[tail] = e;</span><br><span class="line">    <span class="comment">// 计算新的 tail 位置： (tail + 1) mod (elements.length)</span></span><br><span class="line">    <span class="keyword">if</span> (head == (tail = inc(tail, es.length)))</span><br><span class="line">        grow(<span class="number">1</span>); <span class="comment">// 最终会调用 doubleCapacity()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算后移一位的索引（循环）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> modulus)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (++i &gt;= modulus) i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更高效的位运算写法：</span></span><br><span class="line"><span class="comment">// tail = (tail + 1) &amp; (elements.length - 1)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-删除元素-Remove-1"><a href="#6-删除元素-Remove-1" class="headerlink" title="6. 删除元素(Remove)"></a>6. 删除元素(Remove)</h5><ul>
<li><p><strong>头部删除 <code>public E removeFirst()</code> &#x2F; <code>pollFirst()</code> &#x2F; <code>poll()</code> &#x2F; <code>pop()</code></strong>：</p>
<ol>
<li>获取 <code>head</code> 位置的元素。</li>
<li>如果元素为 <code>null</code>（即队列为空），<code>pollFirst()</code> 返回 <code>null</code>，<code>removeFirst()</code> 和 <code>pop()</code> 抛出 <code>NoSuchElementException</code>。</li>
<li>将原 <code>head</code> 位置的元素置为 <code>null</code>（帮助 GC）。</li>
<li>将 <code>head</code> 指针<strong>向后移动一位</strong>。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> h;</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> elementAt(es = elements, h = head);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        es[h] = <span class="literal">null</span>; <span class="comment">// 清空引用</span></span><br><span class="line">        head = inc(h, es.length); <span class="comment">// head 后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;E&gt; E <span class="title function_">elementAt</span><span class="params">(Object[] es, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) es[i]; <span class="comment">// 如果 es[i] 为 null 则返回 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>尾部删除 <code>public E removeLast()</code> &#x2F; <code>pollLast()</code></strong>：</p>
<ol>
<li>将 <code>tail</code> 指针<strong>向前移动一位</strong>，得到要删除的元素位置。</li>
<li>获取该位置的元素。</li>
<li>如果元素为 <code>null</code>（即队列为空），<code>pollLast()</code> 返回 <code>null</code>，<code>removeLast()</code> 抛出 <code>NoSuchElementException</code>。</li>
<li>将该位置的元素置为 <code>null</code>。</li>
<li>更新 <code>tail</code> 为新的位置。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> t;</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> elementAt(es = elements, t = dec(tail, es.length));</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        es[tail = t] = <span class="literal">null</span>; <span class="comment">// 清空引用并更新 tail</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="7-获取与查看元素-Get-Peek"><a href="#7-获取与查看元素-Get-Peek" class="headerlink" title="7. 获取与查看元素(Get&amp;Peek)"></a>7. 获取与查看元素(Get&amp;Peek)</h5><ul>
<li><strong>获取头部元素 <code>public E getFirst()</code> &#x2F; <code>peekFirst()</code> &#x2F; <code>peek()</code></strong>：<ul>
<li>直接返回 <code>head</code> 位置的元素。</li>
<li>如果队列为空，<code>getFirst()</code> 抛出异常，<code>peekFirst()</code> 和 <code>peek()</code> 返回 <code>null</code>。</li>
<li><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</li>
</ul>
</li>
<li><strong>获取尾部元素 <code>public E getLast()</code> &#x2F; <code>peekLast()</code></strong>：<ul>
<li>计算 <code>tail</code> 的前一个位置 (<code>dec(tail, length)</code>)，返回该位置的元素。</li>
<li>如果队列为空，<code>getLast()</code> 抛出异常，<code>peekLast()</code> 返回 <code>null</code>。</li>
<li><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>： <code>ArrayDeque</code> <strong>没有实现 <code>get(int index)</code> 方法</strong>，因为它不是为随机访问设计的。要按索引访问元素，必须通过迭代器遍历。</p>
<hr>
<h5 id="8-查找-Contains"><a href="#8-查找-Contains" class="headerlink" title="8. 查找(Contains)"></a>8. 查找(Contains)</h5><ul>
<li><p><strong><code>public boolean contains(Object o)</code></strong>：</p>
<ol>
<li>如果 <code>o == null</code>，返回 <code>false</code>（因为不允许 <code>null</code> 元素）。</li>
<li>从 <code>head</code> 开始遍历有效元素，直到 <code>tail</code>，使用 <code>o.equals(es[i])</code> 进行比较。</li>
<li>找到返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ol>
<ul>
<li><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="9-遍历方式-2"><a href="#9-遍历方式-2" class="headerlink" title="9. 遍历方式"></a>9. 遍历方式</h5><ul>
<li><strong>迭代器（Iterator）</strong>： <code>ArrayDeque</code> 提供了两种迭代器：<code>Iterator</code>（从头到尾）和<code>DescendingIterator</code>（从尾到头）。这是<strong>推荐</strong>的遍历方式。</li>
<li><strong>for-each循环</strong>： 语法糖，底层是 <code>Iterator</code>。</li>
</ul>
<p><strong>注意</strong>： 和 <code>ArrayList</code> 一样，<strong>严禁在遍历过程中使用 <code>ArrayDeque</code> 的 <code>remove()</code> 等方法修改集合结构</strong>，否则会抛出 <code>ConcurrentModificationException</code>。如需遍历时删除，必须使用 <strong><code>Iterator.remove()</code></strong> 方法。2.4.8 综合对比</p>
<hr>
<h5 id="10-对比"><a href="#10-对比" class="headerlink" title="10. 对比"></a>10. 对比</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>LinkedBlockingQueue</code></th>
<th align="left"><code>ConcurrentLinkedQueue</code></th>
<th align="left"><code>PriorityQueue</code></th>
<th align="left"><code>ArrayBlockingQueue</code></th>
<th align="left"><code>ArrayDeque</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>所在包</strong></td>
<td align="left"><code>java.util.concurrent</code></td>
<td align="left"><code>java.util.concurrent</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util.concurrent</code></td>
<td align="left"><code>java.util</code></td>
</tr>
<tr>
<td align="left"><strong>边界 (Boundedness)</strong></td>
<td align="left"><strong>有界</strong> (可选，默认 <code>Integer.MAX_VALUE</code>)</td>
<td align="left"><strong>无界</strong></td>
<td align="left"><strong>无界</strong></td>
<td align="left"><strong>有界</strong> (构造时必须指定)</td>
<td align="left"><strong>无界</strong> (会自动扩容)</td>
</tr>
<tr>
<td align="left"><strong>数据结构</strong></td>
<td align="left"><strong>链表</strong> (Node)</td>
<td align="left"><strong>链表</strong> (基于CAS的无锁算法)</td>
<td align="left"><strong>数组</strong> (二叉堆)</td>
<td align="left"><strong>数组</strong></td>
<td align="left"><strong>数组</strong> (循环数组)</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left"><strong>是</strong> (ReentrantLock 两把锁)</td>
<td align="left"><strong>是</strong> (CAS 无锁算法)</td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong> (ReentrantLock 一把锁)</td>
<td align="left"><strong>否</strong></td>
</tr>
<tr>
<td align="left"><strong>锁机制</strong></td>
<td align="left"><strong>阻塞锁</strong> (<code>put</code>&#x2F;<code>take</code> 会阻塞)</td>
<td align="left"><strong>无锁</strong> (CAS, 非阻塞)</td>
<td align="left">-</td>
<td align="left"><strong>阻塞锁</strong> (<code>put</code>&#x2F;<code>take</code> 会阻塞)</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>排序&#x2F;FIFO</strong></td>
<td align="left"><strong>FIFO</strong></td>
<td align="left"><strong>FIFO</strong></td>
<td align="left"><strong>按优先级</strong> (堆顶出队)</td>
<td align="left"><strong>FIFO</strong></td>
<td align="left"><strong>FIFO&#x2F;LIFO</strong> (双端操作)</td>
</tr>
<tr>
<td align="left"><strong>阻塞操作</strong></td>
<td align="left"><strong>支持</strong> (<code>put()</code>, <code>take()</code>, 限时的 <code>offer()</code>, <code>poll()</code>)</td>
<td align="left"><strong>不支持</strong></td>
<td align="left"><strong>不支持</strong></td>
<td align="left"><strong>支持</strong> (<code>put()</code>, <code>take()</code>, 限时的 <code>offer()</code>, <code>poll()</code>)</td>
<td align="left"><strong>不支持</strong></td>
</tr>
<tr>
<td align="left"><strong>允许 <code>null</code> 元素</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
</tr>
<tr>
<td align="left"><strong>性能特点</strong></td>
<td align="left">高并发下吞吐量较好 (生产消费可并行)</td>
<td align="left"><strong>极高</strong>的并发吞吐量 (无锁)</td>
<td align="left"><strong>O(log n)</strong> 的入队出队</td>
<td align="left">低于 <code>LinkedBlockingQueue</code> (生产消费争用同一把锁)</td>
<td align="left"><strong>极快</strong>的数组操作 (非并发下性能最优)</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left"><strong>经典的生产者-消费者模型</strong>，线程池任务队列 (<code>ThreadPoolExecutor</code>)</td>
<td align="left"><strong>高并发非阻塞场景</strong>，对吞吐量要求极高的多线程通信</td>
<td align="left"><strong>任务调度</strong>，需要按优先级处理元素的场景</td>
<td align="left"><strong>有界的生产者-消费者模型</strong></td>
<td align="left"><strong>替代<code>Stack</code></strong> (栈)，<strong>单线程任务队列</strong>，<strong>双端操作</strong>场景</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-Map-接口体系"><a href="#3-Map-接口体系" class="headerlink" title="3. Map 接口体系"></a>3. <strong>Map 接口体系</strong></h2><h3 id="3-1-Map"><a href="#3-1-Map" class="headerlink" title="3.1 Map"></a>3.1 Map</h3><h4 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1 概述"></a>3.1.1 概述</h4><p><code>Map</code> 是Java集合框架的<strong>根接口</strong>之一，用于表示<strong>键值对（Key-Value）</strong> 的集合。每个元素包含一个键（Key）和一个值（Value），键不可重复，每个键最多映射到一个值（即键唯一，值可以重复）。它定义了所有双列集合（如 <code>{&quot;Key1&quot;: &quot;Value1&quot;, &quot;Key2&quot;: &quot;Value2&quot;}</code>）将具备的<strong>通用操作</strong>。</p>
<p><code>Map</code> 接口的常见实现类有：<code>HashMap</code>, <code>TreeMap</code>, <code>LinkedHashMap</code>, 和 <code>Hashtable</code>。</p>
<hr>
<h4 id="3-1-2-核心方法"><a href="#3-1-2-核心方法" class="headerlink" title="3.1.2 核心方法"></a>3.1.2 核心方法</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">功能描述</th>
<th align="left">注意点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>V put(K key, V value)</code></td>
<td align="left">将指定的键值对添加到映射中。</td>
<td align="left">如果键已存在，则用新值替换旧值，并返回旧值；否则返回 <code>null</code>。</td>
</tr>
<tr>
<td align="left"><code>V get(Object key)</code></td>
<td align="left">返回指定键所映射的值。</td>
<td align="left">如果键不存在，则返回 <code>null</code>。</td>
</tr>
<tr>
<td align="left"><code>V remove(Object key)</code></td>
<td align="left">如果键存在，则从此映射中移除键值对。</td>
<td align="left">返回被移除的值，如果键不存在则返回 <code>null</code>。</td>
</tr>
<tr>
<td align="left"><code>void clear()</code></td>
<td align="left">移除此映射中的所有键值对。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>boolean containsKey(Object key)</code></td>
<td align="left">如果此映射包含指定键，则返回 <code>true</code>。</td>
<td align="left">依赖键的 <code>equals()</code> 方法进行判断。</td>
</tr>
<tr>
<td align="left"><code>boolean containsValue(Object value)</code></td>
<td align="left">如果此映射包含指定值，则返回 <code>true</code>。</td>
<td align="left">依赖值的 <code>equals()</code> 方法进行判断。</td>
</tr>
<tr>
<td align="left"><code>int size()</code></td>
<td align="left">返回此映射中的键值对数量。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>boolean isEmpty()</code></td>
<td align="left">如果此映射不包含任何键值对，则返回 <code>true</code>。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Set&lt;K&gt; keySet()</code></td>
<td align="left">返回此映射中包含的键的 <code>Set</code> 视图。</td>
<td align="left">键的集合，常用于遍历所有键。</td>
</tr>
<tr>
<td align="left"><code>Collection&lt;V&gt; values()</code></td>
<td align="left">返回此映射中包含的值的 <code>Collection</code> 视图。</td>
<td align="left">值的集合，常用于遍历所有值。</td>
</tr>
<tr>
<td align="left"><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></td>
<td align="left">返回此映射中包含的键值对的 <code>Set</code> 视图。</td>
<td align="left">键值对的集合，常用于同时遍历键和值。</td>
</tr>
<tr>
<td align="left"><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code></td>
<td align="left">将指定映射中的所有键值对复制到此映射中。</td>
<td align="left"><strong>批量操作</strong></td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-3-遍历方式"><a href="#3-1-3-遍历方式" class="headerlink" title="3.1.3 遍历方式"></a>3.1.3 遍历方式</h4><ol>
<li><p><strong>通过键集合（keySet）遍历</strong>： 先获取所有键，再通过键获取值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ... 添加键值对</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过键值对集合（entrySet）遍历</strong>： <strong>推荐的高效方式</strong>，直接获取键值对。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过值集合（values）遍历</strong>： 仅遍历值，不包含键信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Lambda 表达式 + forEach() 方法（JDK8+）</strong>： 简洁的遍历方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>迭代器（Iterator）</strong>： 通用方式，可与 <code>keySet()</code> 或 <code>entrySet()</code> 结合使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; entry = it.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">    <span class="comment">// it.remove(); // 可以在遍历时安全地移除键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="3-2-Map-接口的实现类"><a href="#3-2-Map-接口的实现类" class="headerlink" title="3.2 Map 接口的实现类"></a>3.2 Map 接口的实现类</h3><h4 id="3-2-1-HashMap【-核心掌握-】"><a href="#3-2-1-HashMap【-核心掌握-】" class="headerlink" title="3.2.1 HashMap【!核心掌握!】"></a>3.2.1 HashMap【!核心掌握!】</h4><h5 id="1-核心概念-15"><a href="#1-核心概念-15" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>HashMap</code> 是 <code>Map</code> 接口基于哈希表的实现。它存储键值对（key-value）映射。</li>
<li><strong>核心特征：</strong><ul>
<li><strong>键不可重复（Keys are unique）</strong>： 不允许重复的键。如果插入的键已存在，新的值会覆盖旧的值。</li>
<li><strong>允许 Null 键和值（Allows null key and values）</strong>： 可以存储一个 <code>null</code> 键和多个 <code>null</code> 值。</li>
<li><strong>非有序（Not Ordered）</strong>： 迭代顺序不保证是插入顺序（与 <code>LinkedHashMap</code> 区别）。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 多线程环境下未经同步直接使用会导致不确定的结果。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 它通过计算键（key）的哈希值（hash code）来决定键值对的存储位置，以实现高速的查找。底层结构是“数组 + 链表 + 红黑树”，通过拉链法解决哈希冲突。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-13"><a href="#2-底层数据结构和关键属性-13" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>HashMap</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量 —— 必须是 2 的幂。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 即 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量，如果在构造函数中隐式指定了更大的值，</span></span><br><span class="line"><span class="comment">     * 则会使用此值。必须是 2 的幂，且 &lt;= 1&lt;&lt;30。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认负载因子（当构造函数未指定时使用）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将链表转换为红黑树的阈值（当桶中节点数达到此值时）。</span></span><br><span class="line"><span class="comment">     * 该值必须大于 2，并且至少为 8，以便和树节点删除时退化回链表的逻辑保持一致。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将红黑树退化为链表的阈值（当桶中节点数小于此值时，在扩容时发生）。</span></span><br><span class="line"><span class="comment">     * 必须小于 TREEIFY_THRESHOLD，最大不能超过 6，</span></span><br><span class="line"><span class="comment">     * 以便在删除节点时能够正确检测并退化为链表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许进行树化的最小表容量。否则，如果桶中节点太多，会先选择扩容。</span></span><br><span class="line"><span class="comment">     * 建议至少为 4 * TREEIFY_THRESHOLD，以避免扩容与树化阈值冲突。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表（数组），在第一次使用时初始化，并根据需要调整大小。</span></span><br><span class="line"><span class="comment">     * 长度总是 2 的幂次方。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存 entrySet() 的结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此映射中包含的键值对数量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此 HashMap 被结构修改的次数（用于迭代器的快速失败机制）。</span></span><br><span class="line"><span class="comment">     * 结构修改是指更改 HashMap 中的映射数量或以其他方式修改其内部结构（例如，重新哈希）的修改。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一次需要调整大小（扩容）的阈值（容量 * 加载因子）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表的加载因子。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本的哈希桶节点，用于大多数普通的键值对。</span></span><br><span class="line"><span class="comment">     * （TreeNode 是其子类，LinkedHashMap 里有 Entry 子类）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;      <span class="comment">// 哈希值</span></span><br><span class="line">        <span class="keyword">final</span> K key;         <span class="comment">// 键</span></span><br><span class="line">        V value;             <span class="comment">// 值</span></span><br><span class="line">        Node&lt;K,V&gt; next;      <span class="comment">// 指向链表下一个节点</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// ... getKey(), getValue(), toString(), equals(), hashCode() 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树节点（当链表转树时使用）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 红黑树链接</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// 在删除后需要取消链接</span></span><br><span class="line">        <span class="type">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 一系列红黑树相关的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>table</code>： 这是 <code>HashMap</code> 的心脏，一个 <code>Node</code> 类型的数组。每个数组位置被称为一个“桶”（bucket）或“槽”（bin）。所有元素都分布在这个数组中。</li>
<li><code>Node</code>： 是链表节点结构，包含 <code>hash</code>, <code>key</code>, <code>value</code>, <code>next</code> 四个属性。<code>next</code> 用于解决哈希冲突，形成链表。</li>
<li><code>TreeNode</code>： 是红黑树节点结构。当链表过长时，会转换为红黑树，以提升查询效率。</li>
<li><code>size</code>： 记录当前映射中键值对的数量。</li>
<li><code>loadFactor</code>： <strong>加载因子</strong>。这是一个权衡时间和空间成本的因子，决定了哈希表在多少满时进行扩容。</li>
<li><code>threshold</code>： <strong>扩容阈值</strong>。其值为 <code>(capacity * loadFactor)</code>。当 <code>size</code> 超过 <code>threshold</code> 时，就会触发扩容（resize）。</li>
<li><code>DEFAULT_INITIAL_CAPACITY</code> 和 <code>DEFAULT_LOAD_FACTOR</code>： 默认的初始容量（16）和加载因子（0.75）。这是时间和空间的经典折衷。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-12"><a href="#3-构造方法与初始化-12" class="headerlink" title="3. 构造方法与初始化"></a><strong>3. 构造方法与初始化</strong></h5><p><code>HashMap</code> 提供了四种构造方式：</p>
<ol>
<li><p><strong><code>public HashMap()</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 将 <code>loadFactor</code> 设置为 <code>DEFAULT_LOAD_FACTOR</code> (0.75f)。<code>table</code> 数组此时并未初始化。</li>
<li><strong>特点</strong>： 懒加载。在第一次调用 <code>put()</code> 方法时，才会将 <code>table</code> 真正初始化为默认容量（16）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个空的 &#123;<span class="doctag">@code</span> HashMap&#125;，</span></span><br><span class="line"><span class="comment"> * 默认初始容量为 16，默认负载因子为 0.75。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// 其他字段使用默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public HashMap(int initialCapacity)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用 <code>this(initialCapacity, DEFAULT_LOAD_FACTOR)</code>。</li>
<li><strong>特点</strong>： 允许用户指定初始容量。<code>HashMap</code> 内部会将其规范化为大于等于该值的最小 2 的幂次方（如传入 10，实际初始容量为 16）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个空的 &#123;<span class="doctag">@code</span> HashMap&#125;，并指定初始容量，</span></span><br><span class="line"><span class="comment"> * 默认负载因子为 0.75。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span></span></span><br><span class="line"><span class="comment"> * 如果要创建一个能够容纳预期映射数量的 &#123;<span class="doctag">@code</span> HashMap&#125;，</span></span><br><span class="line"><span class="comment"> * 请使用 &#123;<span class="doctag">@link</span> #newHashMap(int) newHashMap&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量为负数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public HashMap(int initialCapacity, float loadFactor)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 对参数进行合法性校验。计算并设置初始的 <code>threshold</code>（注意，此时 <code>threshold</code> 是下一次扩容的大小，而不是 <code>capacity * loadFactor</code>，在第一次 <code>put</code> 时会用这个 <code>threshold</code> 来初始化 <code>table</code> 的容量）。</li>
<li><strong>特点</strong>： 允许用户完全自定义初始容量和加载因子。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个空的 &#123;<span class="doctag">@code</span> HashMap&#125;，并指定初始容量和负载因子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span></span></span><br><span class="line"><span class="comment"> * 如果要创建一个能够容纳预期映射数量的 &#123;<span class="doctag">@code</span> HashMap&#125;，</span></span><br><span class="line"><span class="comment"> * 请使用 &#123;<span class="doctag">@link</span> #newHashMap(int) newHashMap&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      负载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量为负数，</span></span><br><span class="line"><span class="comment"> *         或者负载因子小于等于 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个大于等于指定目标容量的 2 的幂大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="comment">// 减 1 的目的是 如果 cap 本身已经是 2 的幂，cap - 1 的二进制会把低位全部置 1。</span></span><br><span class="line">    <span class="comment">// 				如果 cap 本身已经是 2 的幂，cap - 1 的二进制会把低位全部置 1。</span></span><br><span class="line">    <span class="comment">// Integer.numberOfLeadingZeros(cap - 1) 返回 cap-1 的二进制表示里，前导 0 的个数</span></span><br><span class="line">    <span class="comment">// -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1) 无符号右移 k 位（&gt;&gt;&gt;）之后，得到的是 低位有 (32-k) 个 1 的掩码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public HashMap(Map&lt;? extends K, ? extends V&gt; m)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 设置 <code>loadFactor</code> 为默认值，然后调用 <code>putMapEntries(m, false)</code> 方法将传入映射的所有元素放入本映射中。</li>
<li><strong>特点</strong>： 用一个已有映射来构造。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的 &#123;<span class="doctag">@code</span> HashMap&#125;，其内容与指定的 &#123;<span class="doctag">@code</span> Map&#125; 相同。</span></span><br><span class="line"><span class="comment"> * 新创建的 &#123;<span class="doctag">@code</span> HashMap&#125; 默认负载因子为 0.75，</span></span><br><span class="line"><span class="comment"> * 初始容量足以容纳指定 &#123;<span class="doctag">@code</span> Map&#125; 中的所有映射。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m 要拷贝映射数据的 Map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException 如果传入的 Map 为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Map.putAll 方法和 Map 构造函数所需的逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 要拷贝的 map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果是在构造 HashMap 时调用，则为 false；</span></span><br><span class="line"><span class="comment"> *              否则为 true（传递给 afterNodeInsertion 方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// 当前哈希表还没初始化</span></span><br><span class="line">            <span class="comment">// 期望容量</span></span><br><span class="line">          	<span class="type">double</span> <span class="variable">dt</span> <span class="operator">=</span> Math.ceil(s / (<span class="type">double</span>)loadFactor);</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((dt &lt; (<span class="type">double</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)dt : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 由于链表桶的限制，不能一次性扩容到位，</span></span><br><span class="line">            <span class="comment">// 但可以通过现在多次翻倍来减少后续的扩容成本</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt; threshold &amp;&amp; table.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将传入 Map 的所有键值对插入到当前 HashMap 中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="4-哈希计算与数组下标定位"><a href="#4-哈希计算与数组下标定位" class="headerlink" title="4. 哈希计算与数组下标定位"></a><strong>4. 哈希计算与数组下标定位</strong></h5><p>在插入或查找一个元素时，首先要确定键值对应该放在 <code>table</code> 数组的哪个位置。</p>
<ol>
<li><p><strong>计算哈希值（hash(Object key)）</strong>：<br>为了防止质量较差的哈希函数（<code>key.hashCode()</code>）导致严重的哈希冲突，<code>HashMap</code> 会用自己的 <code>hash()</code> 方法对原始哈希码进行二次处理（扰动函数）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>key</code> 为 <code>null</code>，哈希值为 <code>0</code>，这就是 <code>HashMap</code> 支持 <code>null</code> 键的原因。</li>
<li>如果 <code>key</code> 不为 <code>null</code>，则计算 <code>key.hashCode()</code>，并将该值的高 16 位与低 16 位进行异或操作。这样做是为了将高位的特征也融入到低位中，从而减少哈希冲突。</li>
</ul>
</li>
<li><p><strong>计算数组下标</strong>：<br>得到扰动后的哈希值 <code>hash</code> 后，通过与操作 <code>(table.length - 1) &amp; hash</code> 来计算下标。、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash; <span class="comment">// n 是 table 的长度</span></span><br></pre></td></tr></table></figure>

<ul>
<li>因为 <code>n</code>（数组长度）永远是 2 的幂次方，所以 <code>n-1</code> 的二进制形式永远是全 <code>1</code>（例如，16-1&#x3D;15，二进制为 <code>1111</code>）。</li>
<li>这个操作实质上是 <code>hash % n</code>，但位运算的效率远高于取模运算。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="5-添加-更新元素-Put"><a href="#5-添加-更新元素-Put" class="headerlink" title="5. 添加&#x2F;更新元素(Put)"></a><strong>5. 添加&#x2F;更新元素(Put)</strong></h5><p><code>public V put(K key, V value)</code> 方法是核心：</p>
<ul>
<li><p><strong>源码流程</strong>：</p>
<ol>
<li>调用 <code>hash(key)</code> 计算键的哈希值。</li>
<li>如果 <code>table</code> 为空或长度为 0，则调用 <code>resize()</code> 进行初始化（懒加载）。</li>
<li>计算下标 <code>i = (n - 1) &amp; hash</code>。</li>
<li><strong>检查桶是否为空</strong><ul>
<li><strong>情况 A</strong>：桶为空 → 直接新建节点放进去。</li>
<li><strong>情况 B</strong>：桶非空 → 存在冲突，继续处理：<ul>
<li>判断桶首节点：<ul>
<li>如果 <strong>hash 相同 + key 相等</strong> → 找到已有节点，覆盖其值。</li>
<li>如果桶是 <strong>红黑树</strong> → 调用 <code>putTreeVal</code> 插入。</li>
<li>否则就是 <strong>链表</strong>：<ul>
<li>遍历链表：<ul>
<li>如果找到相同 key → 覆盖值。</li>
<li>如果没找到 → 在链尾插入新节点。</li>
<li>如果链表长度 ≥ 8 → 转换为红黑树（<code>treeifyBin</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>如果覆盖已有节点值</strong><ul>
<li>直接返回旧值，不做扩容。</li>
</ul>
</li>
<li><strong>如果是新插入的节点</strong><ul>
<li><code>modCount++</code>（结构修改次数，用于快速失败机制）</li>
<li><code>size++</code></li>
<li>如果 <code>size &gt; threshold</code> → 调用 <code>resize()</code> 扩容。</li>
</ul>
</li>
<li><strong>执行钩子方法</strong><ul>
<li><code>afterNodeAccess(e)</code>（节点访问后的回调，LinkedHashMap 会用）</li>
<li><code>afterNodeInsertion(evict)</code>（节点插入后的回调）</li>
</ul>
</li>
<li><strong>返回结果</strong><ul>
<li>如果是覆盖 → 返回旧值</li>
<li>如果是新增 → 返回 <code>null</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的值与此映射中的指定键关联。</span></span><br><span class="line"><span class="comment"> * 如果映射之前为该键存在映射，则旧值被替换。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 要关联指定值的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要与指定键关联的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与 &#123;<span class="doctag">@code</span> key&#125; 先前关联的值，或者如果没有映射则返回 &#123;<span class="doctag">@code</span> null&#125;。</span></span><br><span class="line"><span class="comment"> *         （返回 &#123;<span class="doctag">@code</span> null&#125; 也可能表示该映射先前将 &#123;<span class="doctag">@code</span> null&#125; 作为值与该键关联。）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Map.put 及相关方法的内部逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 键的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要放入的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果为 true，则不要更改已有值（即 putIfAbsent 的行为）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为 false，表处于创建（resize）模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 先前的值，或者如果没有则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// HashMap 的 数组（桶数组），每个位置存一个链表或红黑树的头节点</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    <span class="comment">// 指向当前桶的第一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; p; </span><br><span class="line">    <span class="comment">// n当前tab的长度，i桶的索引位置</span></span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果 table 为空，初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算桶索引</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 桶为空：直接插入新节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 桶非空 → 处理碰撞</span></span><br><span class="line">        <span class="comment">// 在查找/遍历时，表示 可能已经存在的目标节点。</span></span><br><span class="line">        Node&lt;K,V&gt; e; </span><br><span class="line">        <span class="comment">// 临时变量，存放节点的 key</span></span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">// 比较桶首节点：hash相同 + key相同 → 找到目标节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 找到已有节点，把它赋给 e</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果桶是红黑树，调用树的插入逻辑</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 否则就是链表：遍历</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 到达链表尾部 → 插入新节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                  	<span class="comment">// 如果链长超过阈值 8 → 转红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历中途发现 key 已存在 → 退出</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到了已有节点 e → 处理 value 替换</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">        	<span class="comment">// 钩子</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入新节点成功 → 更新 size，判断是否需要扩容</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 钩子</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li><strong>平均复杂度</strong>：O(1)</li>
<li><strong>最坏复杂度</strong>：O(n) （极端情况下所有 key 落在同一桶，并且未转树）</li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-扩容机制-Resize"><a href="#6-扩容机制-Resize" class="headerlink" title="6. 扩容机制 (Resize)"></a><strong>6. 扩容机制 (Resize)</strong></h5><p>这是 <code>HashMap</code> 性能的关键。当元素数量超过 <code>threshold</code> 时，容量会扩大为原来的 <strong>2 倍</strong>。</p>
<ul>
<li><p><strong>源码流程（<code>resize()</code>）</strong>：</p>
<ol>
<li>获取旧表信息。</li>
<li>计算新容量和阈值。<ul>
<li><strong>情况 A：旧容量 &gt; 0</strong><ul>
<li>如果达到最大值 <code>MAXIMUM_CAPACITY</code> → 不再扩容，<code>threshold = Integer.MAX_VALUE</code></li>
<li>否则：新容量 &#x3D; <code>oldCap &lt;&lt; 1</code>（扩容为 2 倍）<br> 新阈值 &#x3D; <code>oldThr &lt;&lt; 1</code>（翻倍）</li>
</ul>
</li>
<li><strong>情况 B：旧容量 &#x3D; 0，但 oldThr &gt; 0</strong><ul>
<li>说明是第一次初始化 → <code>newCap = oldThr</code></li>
</ul>
</li>
<li><strong>情况 C：oldCap &#x3D; 0 且 oldThr &#x3D; 0</strong><ul>
<li>使用默认容量 <code>DEFAULT_INITIAL_CAPACITY</code>（16）和默认阈值（16×0.75&#x3D;12）</li>
</ul>
</li>
<li>最后根据 <code>loadFactor</code> 重新计算 <code>threshold</code></li>
</ul>
</li>
<li>创建新数组。</li>
<li>数据迁移<ul>
<li>如果旧表非空，需要把元素迁移到新表中，遍历每个桶。</li>
<li>单节点：直接放到新表位置</li>
<li>红黑树节点：调用 <code>TreeNode.split(...)</code>，把树拆分为 <strong>低位链表&#x2F;树</strong> 和 <strong>高位链表&#x2F;树</strong>。</li>
<li>链表节点：<ul>
<li>遍历链表，按 <code>(e.hash &amp; oldCap)</code> 分成 <strong>两条链表</strong>：</li>
<li><strong>低位链表（loHead&#x2F;loTail）</strong> → 放到新表索引 <code>j</code></li>
<li><strong>高位链表（hiHead&#x2F;hiTail）</strong> → 放到新表索引 <code>j + oldCap</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化或将哈希表扩容为原来的两倍。</span></span><br><span class="line"><span class="comment"> * - 如果 table 为空，则会按照 threshold 里保存的初始容量目标来分配；</span></span><br><span class="line"><span class="comment"> * - 否则，由于我们使用的是 2 的幂次方扩容，原数组中每个 bin（桶）的元素要么留在原位置，</span></span><br><span class="line"><span class="comment"> *   要么移动到新表中索引位置 + 原容量（oldCap）的地方。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新的哈希表数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 原哈希表数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 原数组容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 扩容阈值（容量 * 负载因子）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 旧容量左移一位（即 2 倍扩容）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 阈值翻倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// threshold 被用作初始化容量</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// oldThr == 0 表示使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新计算阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 迁移旧数据</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历旧数组的每一个桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 桶非空，释放旧桶引用，帮助 GC</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 情况 1：桶里只有一个节点（既不是链表也不是树）</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 直接放到新数组的新位置（通过新容量计算索引）</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 情况 2：桶里是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 调用红黑树的 split 方法，拆成低位树和高位树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 情况 3：桶里是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 保持原有节点顺序</span></span><br><span class="line">                    <span class="comment">// 低位链表头尾</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 高位链表头尾</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                 	<span class="comment">// 遍历当前桶的链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 根据 e.hash &amp; oldCap 判断该节点应该留在原位置还是去新位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 低位链表：索引不变，仍然放在 j</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 高位链表：索引 = j + oldCap</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 把低位链表挂到新数组 j 位置</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 把高位链表挂到新数组 j+oldCap 位置</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最佳实践</strong>： 如果能预估数据量，应使用 <code>HashMap(int initialCapacity)</code> 构造器并传入 <code>(预计元素个数 / 0.75f) + 1</code> 来指定初始容量，这样可以避免或减少扩容次数。</p>
</li>
</ul>
<hr>
<h5 id="7-获取元素-Get"><a href="#7-获取元素-Get" class="headerlink" title="7. 获取元素(Get)"></a><strong>7. 获取元素(Get)</strong></h5><p><code>public V get(Object key)</code>：</p>
<ul>
<li><p><strong>源码流程</strong>：</p>
<ol>
<li>判断<code>table</code>是否为空并计算索引。</li>
<li>如果桶不为空：<ul>
<li>如果桶中第一个节点的 <code>key</code> 就匹配，直接返回。</li>
<li>如果第一个节点不匹配，且是树节点，则调用树的查找方法 <code>getTreeNode()</code>。</li>
<li>如果是链表，则遍历链表查找。</li>
</ul>
</li>
<li>都没找到则返回 <code>null</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定键所映射的值，</span></span><br><span class="line"><span class="comment"> * 如果此映射不包含该键的映射，则返回 &#123;<span class="doctag">@code</span> null&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;更正式地讲，如果此映射包含一个从键 &#123;<span class="doctag">@code</span> k&#125; 映射到值 &#123;<span class="doctag">@code</span> v&#125; 的映射，</span></span><br><span class="line"><span class="comment"> * 并且满足 &#123;<span class="doctag">@code</span> (key==null ? k==null : key.equals(k))&#125;，</span></span><br><span class="line"><span class="comment"> * 那么此方法返回 &#123;<span class="doctag">@code</span> v&#125;；否则返回 &#123;<span class="doctag">@code</span> null&#125;。</span></span><br><span class="line"><span class="comment"> * （最多只会存在一个这样的映射。）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;返回值为 &#123;<span class="doctag">@code</span> null&#125; 并&lt;i&gt;不一定&lt;/i&gt;表示此映射中没有该键的映射；</span></span><br><span class="line"><span class="comment"> * 也有可能是该映射显式地将该键映射到了 &#123;<span class="doctag">@code</span> null&#125;。</span></span><br><span class="line"><span class="comment"> * 可以使用 &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; 方法来区分这两种情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了 Map.get 及其相关方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 节点，如果不存在则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n, hash; K k;</span><br><span class="line">    <span class="comment">// 判断table是否为空，计算索引</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; (hash = hash(key))]) != <span class="literal">null</span>) &#123;</span><br><span class="line">  		<span class="comment">// 判断头节点      </span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;</span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是树节点调用树方法</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 如果是链表遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>时间复杂度</strong>： 与 <code>put</code> 类似，理想 O(1)，最坏 O(n)。</p>
</li>
</ul>
<hr>
<h5 id="8-删除元素-Remove"><a href="#8-删除元素-Remove" class="headerlink" title="8. 删除元素(Remove)"></a><strong>8. 删除元素(Remove)</strong></h5><p><code>public V remove(Object key)</code>：</p>
<ul>
<li><p><strong>源码流程</strong>：</p>
<ol>
<li>先根据 <code>key</code> 找到对应的节点（过程类似 <code>get</code>）。</li>
<li>如果找到，则执行删除。<ul>
<li>如果是链表节点，修改前后节点的指针。</li>
<li>如果是树节点，调用树的删除方法。</li>
</ul>
</li>
<li><code>modCount++</code>，<code>size--</code>。</li>
<li>在删除树节点后，如果树变得太小（节点数 <code>&lt;= UNTREEIFY_THRESHOLD (6)</code>），则会调用 <code>untreeify()</code> 方法将红黑树退化为链表。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定 key 对应的映射关系（如果存在）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key 要被移除的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回 key 之前对应的 value，</span></span><br><span class="line"><span class="comment"> *         如果不存在映射则返回 null。</span></span><br><span class="line"><span class="comment"> *         （注意：返回 null 也可能表示该 key 对应的 value 本身就是 null）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 调用 removeNode 进行实际删除，若删除成功则返回被删除的 value，否则返回 null</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Map.remove 以及相关方法的底层逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key 的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 要删除的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 仅当 matchValue = true 时才会用来比较，其他情况忽略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 是否要求匹配指定 value（true 表示 key 和 value 同时匹配才删除）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 是否允许在删除节点时进行结构调整（比如红黑树节点删除需要旋转）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除的节点，如果没有找到则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">// 哈希表数组</span></span><br><span class="line">    Node&lt;K,V&gt; p;     <span class="comment">// 当前桶的首节点</span></span><br><span class="line">    <span class="type">int</span> n, index;    <span class="comment">// n = table 长度，index = 桶下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// table 不为空，长度大于 0，并且定位到的桶内有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; </span><br><span class="line">        K k; V v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况 1：桶的首节点就是目标节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况 2：目标节点在链表或树的后续节点中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) </span><br><span class="line">                <span class="comment">// 在红黑树节点中查找</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通链表遍历查找目标节点</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e; <span class="comment">// 更新前驱节点，便于删除操作</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到目标节点，且需要时 value 也匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 情况 A：删除树节点</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况 B：删除的是桶的首节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况 C：删除链表中的非首节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改计数器，触发 fail-fast 机制</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// 元素数量减一</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 钩子方法</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到目标节点，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>时间复杂度</strong>： 与 <code>get</code> 类似。</p>
</li>
</ul>
<hr>
<h5 id="9-遍历方式-3"><a href="#9-遍历方式-3" class="headerlink" title="9. 遍历方式"></a><strong>9. 遍历方式</strong></h5><p><code>HashMap</code> 的遍历通常通过三种视图（View）进行：</p>
<ol>
<li><code>Set&lt;K&gt; keySet()</code>： 返回所有键的集合。</li>
<li><code>Collection&lt;V&gt; values()</code>： 返回所有值的集合。</li>
<li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>： 返回所有键值对的集合（<strong>最常用</strong>）。</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li><strong>性能</strong>： 遍历 <code>HashMap</code> 的时间复杂度是 O(n)，与 <code>capacity</code>（数组长度）无关，只与 <code>size</code>（实际元素个数）有关。因为它会依次访问每一个非空桶。</li>
<li><strong>快速失败机制</strong>： 使用迭代器遍历时，如果创建迭代器后映射被结构性地修改（非 <code>Iterator.remove</code> 方法），则会抛出 <code>ConcurrentModificationException</code>。</li>
<li><strong>最佳实践</strong>： 遍历键值对时，使用 <code>entrySet</code> 比先遍历 <code>keySet</code> 再调用 <code>get(key)</code> 效率高得多，因为后者相当于遍历了两次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐的遍历方式</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低效的遍历方式（不推荐）</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key); <span class="comment">// 这里又进行了一次哈希计算和查找！</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-2-LinkedHashMap【核心掌握】"><a href="#3-2-2-LinkedHashMap【核心掌握】" class="headerlink" title="3.2.2 LinkedHashMap【核心掌握】"></a>3.2.2 LinkedHashMap【核心掌握】</h4><h5 id="1-核心概念-16"><a href="#1-核心概念-16" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ul>
<li><strong>定义</strong>： <code>LinkedHashMap</code> 是 <code>HashMap</code> 的一个子类，它继承了 <code>HashMap</code> 的哈希表核心功能，并通过维护一个贯穿所有条目的<strong>双向链表</strong>，额外提供了可预测的迭代顺序。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有序（Ordered）</strong>： 迭代顺序可以是 <strong>插入顺序（Insertion-order）</strong> 或 <strong>访问顺序（Access-order）</strong>。这是它与 <code>HashMap</code> 最根本的区别。</li>
<li><strong>键不可重复（Keys are unique）</strong>： 继承自 <code>HashMap</code>。</li>
<li><strong>允许 Null 键和值（Allows null key and values）</strong>： 继承自 <code>HashMap</code>。</li>
<li><strong>性能</strong>： 迭代性能优于 <code>HashMap</code>，因为它只需遍历链表而非整个桶数组。增删改查操作的时间复杂度与 <code>HashMap</code> 相同，仅为维护链表付出了少量常数级别的额外开销。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 继承自 <code>HashMap</code>。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 在 <code>HashMap</code> 的“数组+链表&#x2F;红黑树”结构之上，为每一个键值对节点（<code>Entry</code>）增加了<strong>前驱（<code>before</code>）</strong> 和<strong>后继（<code>after</code>）</strong> 两个指针，将所有 <code>Entry</code> 节点链接成一个双向链表。这个链表定义了迭代的顺序。</li>
</ul>
<hr>
<h5 id="2-底层数据结构和关键属性-14"><a href="#2-底层数据结构和关键属性-14" class="headerlink" title="2. 底层数据结构和关键属性"></a><strong>2. 底层数据结构和关键属性</strong></h5><p>打开 <code>LinkedHashMap</code> 的源码（以OpenJDK为例）：打开 <code>LinkedHashMap</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap.Node 的子类，为 LinkedHashMap 的条目添加了 before 和 after 指针。</span></span><br><span class="line"><span class="comment">     * 这构成了双向链表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after; <span class="comment">// 新增的双向链表指针</span></span><br><span class="line">        Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向链表的头节点（最老的节点，或最久未被访问的节点）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向链表的尾节点（最新的节点，或最近被访问的节点）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代顺序的模式。</span></span><br><span class="line"><span class="comment">     * true: 访问顺序 (access-order) -&gt; 非常适合构建 LRU 缓存。</span></span><br><span class="line"><span class="comment">     * false: 插入顺序 (insertion-order) -&gt; 默认模式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Entry&lt;K,V&gt;</code>： 核心节点结构。它继承了 <code>HashMap.Node</code>，并增加了 <code>before</code> 和 <code>after</code> 两个指针，从而具备了成为双向链表节点的能力。</li>
<li><code>head</code> 和 <code>tail</code>： 分别指向这个双向链表的头部和尾部。<code>head</code> 是链表中最“老”的节点（最先插入或最久未被访问），<code>tail</code> 是最“新”的节点（最后插入或最近被访问）。</li>
<li><code>accessOrder</code>： <strong>决定迭代顺序模式的最终属性</strong>。此属性在构造时设定，之后不可更改。<ul>
<li><code>false</code>（默认）： <strong>插入顺序（Insertion-order）</strong>。迭代顺序就是元素被插入映射的顺序。</li>
<li><code>true</code>： <strong>访问顺序（Access-order）</strong>。迭代顺序是元素被访问的顺序。任何一次 <code>get</code> 或 <code>put</code> 操作都会将被访问的条目移动到链表尾部（成为最新的）。这使得 <code>LinkedHashMap</code> 非常适合实现 <strong>LRU（Least Recently Used）缓存</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-13"><a href="#3-构造方法与初始化-13" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>LinkedHashMap</code> 提供了五种构造方式，其逻辑与 <code>HashMap</code> 类似，主要增加了对 <code>accessOrder</code> 参数的设置。</p>
<ol>
<li><p><strong><code>public LinkedHashMap()</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用父类 <code>HashMap</code> 的无参构造器，并将 <code>accessOrder</code> 设为 <code>false</code>。</li>
<li><strong>特点</strong>： 创建一个默认初始容量（16）和加载因子（0.75）的，按<strong>插入顺序</strong>排序的 <code>LinkedHashMap</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public LinkedHashMap(int initialCapacity)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用父类构造器，并将 <code>accessOrder</code> 设为 <code>false</code>。</li>
<li><strong>特点</strong>： 创建一个指定初始容量和默认加载因子（0.75）的，按<strong>插入顺序</strong>排序的 <code>LinkedHashMap</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public LinkedHashMap(int initialCapacity, float loadFactor)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用父类构造器，并将 <code>accessOrder</code> 设为 <code>false</code>。</li>
<li><strong>特点</strong>： 创建一个指定初始容量和加载因子的，按<strong>插入顺序</strong>排序的 <code>LinkedHashMap</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用父类无参构造器，将 <code>accessOrder</code> 设为 <code>false</code>，然后调用 <code>putMapEntries(m, false)</code> 将传入映射的所有元素放入本映射中。</li>
<li><strong>特点</strong>： 用一个已有映射来构造一个按<strong>插入顺序</strong>排序的 <code>LinkedHashMap</code>。新映射的迭代顺序由原映射的迭代器决定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用父类构造器设置容量和因子，并设置本类的 <code>accessOrder</code> 属性。</li>
<li><strong>特点</strong>： 这是唯一可以创建<strong>访问顺序</strong>模式的构造器。<strong>这是实现 LRU 缓存的关键</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                     <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                     <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.accessOrder = accessOrder; <span class="comment">// 可以设置为 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="4-核心机制：维护链表的钩子方法"><a href="#4-核心机制：维护链表的钩子方法" class="headerlink" title="4. 核心机制：维护链表的钩子方法"></a>4. 核心机制：维护链表的钩子方法</h5><p><code>HashMap</code> 在设计时，预留了三个空的“钩子”方法（<code>afterNodeAccess</code>, <code>afterNodeInsertion</code>, <code>afterNodeRemoval</code>），专门供 <code>LinkedHashMap</code> 重写，以便在哈希表操作后维护双向链表的结构。</p>
<ol>
<li><p><strong><code>afterNodeInsertion(boolean evict)</code> - 插入后可能删除最老节点</strong></p>
<ul>
<li><strong>调用时机</strong>： 在 <code>HashMap</code> 的 <code>put</code> 或 <code>putAll</code> 方法成功插入一个新节点后被调用。</li>
<li><strong><code>LinkedHashMap</code> 中的逻辑</strong>： 检查是否应该移除链表中最老的节点（即 <code>head</code>）。<code>removeEldestEntry(first)</code> 方法默认返回 <code>false</code>。<strong>如果重写该方法并返回 <code>true</code>，则会删除 <code>head</code> 节点</strong>。这是实现固定大小 LRU 缓存的精髓所在。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">// 调用HashMap的remove方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认实现，总是返回false（永不删除最老节点）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>afterNodeAccess(Node&lt;K,V&gt; e)</code> - 访问后调整顺序</strong></p>
<ul>
<li><strong>调用时机</strong>： 在 <code>HashMap</code> 的 <code>get</code>, <code>replace</code> (成功时)，<code>put</code> (更新现有值时) 等方法访问到一个现有节点后被调用。<strong>注意：<code>put</code> 插入新值时不会调用。</strong></li>
<li><strong><code>LinkedHashMap</code> 中的逻辑</strong>： 如果 <code>accessOrder</code> 为 <code>true</code>（访问顺序模式），则将当前被访问的节点 <code>e</code> 移动到双向链表的尾部，使其成为“最新”的节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123; <span class="comment">// 如果是访问模式且当前节点不是尾节点</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// ... 复杂的链表指针调整，将p节点从原位置取出 ...</span></span><br><span class="line">        <span class="comment">// ... 并将p节点链接到链表尾部 ...</span></span><br><span class="line">        tail = p; <span class="comment">// 新的尾节点是p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>afterNodeRemoval(Node&lt;K,V&gt; e)</code> - 删除后维护链表</strong></p>
<ul>
<li><strong>调用时机</strong>： 在 <code>HashMap</code> 的 <code>remove</code> 方法成功删除一个节点后被调用。</li>
<li><strong><code>LinkedHashMap</code> 中的逻辑</strong>： 将节点 <code>e</code> 从双向链表中安全地移除，修补其前后节点的指针。这是纯粹的链表操作，保证删除节点后链表不断开。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="literal">null</span>; <span class="comment">// 将待删除节点p的指针置空</span></span><br><span class="line">    <span class="comment">// 修复其前驱和后继节点的指针</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="5-获取元素-Get-1"><a href="#5-获取元素-Get-1" class="headerlink" title="5. 获取元素(Get)"></a>5. 获取元素(Get)</h5><p><code>public V get(Object key)</code>：</p>
<ul>
<li><strong>源码逻辑</strong>： 它重写了 <code>HashMap</code> 的 <code>get</code> 方法。<ol>
<li>调用父类 <code>HashMap</code> 的 <code>getNode</code> 方法通过哈希查找节点。</li>
<li>如果找到了节点且 <code>accessOrder</code> 为 <code>true</code>，则会调用 <code>afterNodeAccess(e)</code> 将被访问的节点移动到链表尾部。</li>
<li>返回找到的值。</li>
</ol>
</li>
<li><strong>与 <code>HashMap</code> 的区别</strong>： 增加了在访问顺序模式下维护链表顺序的逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>) <span class="comment">// 调用HashMap的getNode</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder) <span class="comment">// 如果是访问顺序模式</span></span><br><span class="line">        afterNodeAccess(e); <span class="comment">// 将被访问的节点e移到链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="6-实现LRU缓存示例"><a href="#6-实现LRU缓存示例" class="headerlink" title="6. 实现LRU缓存示例"></a>6. 实现LRU缓存示例</h5><p>利用 <code>accessOrder</code> 模式和重写 <code>removeEldestEntry</code> 方法，可以轻松实现一个固定大小的 LRU 缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 缓存最大容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="literal">true</span>); <span class="comment">// 关键：accessOrder设为true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写此方法，当映射数量大于缓存容量时，返回true，触发删除最老节点（最近最少使用）。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eldest 链表中最老的节点（头节点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the eldest entry should be removed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">LRUCache&lt;String, String&gt; cache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;One&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;Two&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;Three&quot;</span>);</span><br><span class="line">cache.get(<span class="string">&quot;1&quot;</span>); <span class="comment">// 访问&quot;1&quot;，使其成为“最新”的</span></span><br><span class="line">cache.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;Four&quot;</span>); <span class="comment">// 此时容量已满，添加新元素会触发删除最老的节点（即&quot;2&quot;）</span></span><br><span class="line"></span><br><span class="line">System.out.println(cache); <span class="comment">// 输出: &#123;3=Three, 1=One, 4=Four&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="7-遍历方式-1"><a href="#7-遍历方式-1" class="headerlink" title="7. 遍历方式"></a>7. 遍历方式</h5><p><code>LinkedHashMap</code> 没有重写 <code>put</code>, <code>remove</code> 等核心数据操作逻辑，但它重写了<strong>迭代器</strong>的生成方法。</p>
<ul>
<li><strong><code>keySet().iterator()</code>, <code>values().iterator()</code>, <code>entrySet().iterator()</code></strong>： 这些方法返回的迭代器，其遍历顺序是双向链表的顺序（插入顺序或访问顺序），而不是像 <code>HashMap</code> 那样遍历整个桶数组。</li>
<li><strong>性能</strong>： 迭代 <code>LinkedHashMap</code> 的时间复杂度是 <strong>O(n)</strong>，其中 <code>n</code> 是 <code>size</code>。它只需要简单地遍历双向链表，因此<strong>迭代性能只与实际元素数量有关，与容量（capacity）无关</strong>。这在元素很多但散列良好的情况下，迭代性能远优于需要遍历整个空桶数组的 <code>HashMap</code>。</li>
<li><strong>快速失败机制</strong>： 与 <code>HashMap</code> 和 <code>ArrayList</code> 相同。</li>
</ul>
<hr>
<h4 id="3-2-3-TreeMap【核心掌握】"><a href="#3-2-3-TreeMap【核心掌握】" class="headerlink" title="3.2.3 TreeMap【核心掌握】"></a>3.2.3 TreeMap【核心掌握】</h4><h5 id="1-核心概念-17"><a href="#1-核心概念-17" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ul>
<li><strong>定义</strong>：<br><code>TreeMap</code> 是 <code>Map</code> 接口的一个基于<strong>红黑树（Red-Black tree）</strong> 的实现。它保证了所有键值对按照键的<strong>自然顺序</strong>或<strong>构造时提供的 <code>Comparator</code></strong> 进行排序。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有序（Ordered）</strong>： 迭代顺序由键的排序顺序决定，而不是插入顺序。</li>
<li><strong>键不可重复（Keys are unique）</strong>： 继承自 <code>Map</code> 接口。</li>
<li><strong>不允许 Null 键（Does not allow null keys）</strong>： 如果使用自然排序，且键为 <code>null</code>，会抛出 <code>NullPointerException</code>。但允许 <code>null</code> 值。</li>
<li><strong>性能</strong>： 查找、插入、删除操作的时间复杂度为 <strong>O(log n)</strong>，优于线性结构，但比 <code>HashMap</code> 慢。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 需外部同步或使用 <code>Collections.synchronizedSortedMap</code> 包装。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>：<br>使用红黑树（一种自平衡的二叉搜索树）来存储键值对。每个节点包含键、值、颜色标志（红&#x2F;黑）以及左右子节点引用。红黑树通过旋转和变色保持平衡，确保最坏情况下基本操作仍为对数时间复杂度。</li>
</ul>
<hr>
<h5 id="2-底层数据结构和关键属性-15"><a href="#2-底层数据结构和关键属性-15" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>TreeMap</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于排序的比较器，若为 null 则使用键的自然顺序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树中键值对的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构修改次数（用于迭代器的快速失败机制）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树节点结构</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; left;</span><br><span class="line">        Entry&lt;K,V&gt; right;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK; <span class="comment">// 默认黑色</span></span><br><span class="line"></span><br><span class="line">        Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>comparator</code>： 决定键的排序方式。若为 <code>null</code>，则键必须实现 <code>Comparable</code> 接口。</li>
<li><code>root</code>： 红黑树的根节点。</li>
<li><code>Entry</code>： 红黑树节点，包含键、值、左右子节点、父节点和颜色标志。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-14"><a href="#3-构造方法与初始化-14" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>TreeMap</code> 提供四种构造方式：</p>
<ol>
<li><strong><code>public TreeMap()</code></strong><br>使用键的<strong>自然顺序</strong>排序，键必须实现 <code>Comparable</code> 接口。</li>
<li><strong><code>public TreeMap(Comparator&lt;? super K&gt; comparator)</code></strong><br>使用指定的比较器进行排序。</li>
<li><strong><code>public TreeMap(Map&lt;? extends K, ? extends V&gt; m)</code></strong><br>使用原有 Map 的内容，并按键的自然顺序排序。</li>
<li><strong><code>public TreeMap(SortedMap&lt;K, ? extends V&gt; m)</code></strong><br>使用原有 <code>SortedMap</code> 的内容和排序规则。</li>
</ol>
<hr>
<h5 id="4-添加-更新元素（Put）"><a href="#4-添加-更新元素（Put）" class="headerlink" title="4. 添加&#x2F;更新元素（Put）"></a>4. 添加&#x2F;更新元素（Put）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">// 类型检查（可能抛出 ClassCastException）</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value); <span class="comment">// 键已存在，覆盖值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用自然顺序</span></span><br><span class="line">        <span class="comment">// ... 类似逻辑，使用 key.compareTo(t.key)</span></span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e); <span class="comment">// 红黑树平衡调整</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>流程</strong>：<ol>
<li>若树为空，直接创建根节点。</li>
<li>否则从根开始遍历，根据比较器或自然顺序找到插入位置。</li>
<li>若找到相同键，覆盖值并返回旧值。</li>
<li>插入新节点后调用 <code>fixAfterInsertion(e)</code> 进行红黑树平衡调整（旋转+变色）。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="5-获取元素（Get）"><a href="#5-获取元素（Get）" class="headerlink" title="5. 获取元素（Get）"></a>5. 获取元素（Get）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">null</span> ? <span class="literal">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="comment">// 使用自然顺序遍历查找</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(log n)</li>
<li>通过比较器或自然顺序递归查找键所在的节点。</li>
</ul>
<hr>
<h5 id="6-删除元素（Remove）"><a href="#6-删除元素（Remove）" class="headerlink" title="6. 删除元素（Remove）"></a>6. 删除元素（Remove）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> p.value;</span><br><span class="line">    deleteEntry(p); <span class="comment">// 删除节点并平衡红黑树</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>deleteEntry(p)</code> 方法负责：<ul>
<li>处理三种删除情况（无子节点、一个子节点、两个子节点）。</li>
<li>调用 <code>fixAfterDeletion(p)</code> 进行红黑树平衡调整。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="7-遍历方式-2"><a href="#7-遍历方式-2" class="headerlink" title="7. 遍历方式"></a>7. 遍历方式</h5><p><code>TreeMap</code> 提供了三种视图的迭代器，其遍历顺序为<strong>键的排序顺序</strong>：</p>
<ol>
<li><code>keySet().iterator()</code></li>
<li><code>values().iterator()</code></li>
<li><code>entrySet().iterator()</code></li>
</ol>
<p><strong>中序遍历（In-order traversal）</strong> 保证键从小到大输出。</p>
<hr>
<h5 id="8-特有方法（来自-NavigableMap）"><a href="#8-特有方法（来自-NavigableMap）" class="headerlink" title="8. 特有方法（来自 NavigableMap）"></a>8. 特有方法（来自 <code>NavigableMap</code>）</h5><p><code>TreeMap</code> 实现了 <code>NavigableMap</code>，提供了丰富的导航方法：</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>K firstKey()</code></td>
<td align="left">返回最小的键</td>
</tr>
<tr>
<td align="left"><code>K lastKey()</code></td>
<td align="left">返回最大的键</td>
</tr>
<tr>
<td align="left"><code>Map.Entry&lt;K,V&gt; ceilingEntry(K key)</code></td>
<td align="left">返回 ≥ 给定键的最小键值对</td>
</tr>
<tr>
<td align="left"><code>Map.Entry&lt;K,V&gt; floorEntry(K key)</code></td>
<td align="left">返回 ≤ 给定键的最大键值对</td>
</tr>
<tr>
<td align="left"><code>Map.Entry&lt;K,V&gt; higherEntry(K key)</code></td>
<td align="left">返回 &gt; 给定键的最小键值对</td>
</tr>
<tr>
<td align="left"><code>Map.Entry&lt;K,V&gt; lowerEntry(K key)</code></td>
<td align="left">返回 &lt; 给定键的最大键值对</td>
</tr>
<tr>
<td align="left"><code>NavigableMap&lt;K,V&gt; descendingMap()</code></td>
<td align="left">返回逆序视图</td>
</tr>
</tbody></table>
<hr>
<h5 id="9-使用场景与最佳实践"><a href="#9-使用场景与最佳实践" class="headerlink" title="9. 使用场景与最佳实践"></a>9. 使用场景与最佳实践</h5><ul>
<li><strong>适用场景</strong>：<ul>
<li>需要键有序遍历的场景。</li>
<li>需要范围查询（如找最接近的键）的场景。</li>
<li>键的类型没有好的哈希函数，但可实现 <code>Comparable</code> 或提供 <code>Comparator</code>。</li>
</ul>
</li>
<li><strong>不适用场景</strong>：<ul>
<li>对插入和查找性能要求极高且无需排序的场景（应使用 <code>HashMap</code>）。</li>
</ul>
</li>
<li><strong>最佳实践</strong>：<ul>
<li>若键为自定义类，应正确实现 <code>Comparable</code> 或提供 <code>Comparator</code>。</li>
<li>避免在迭代过程中结构性修改（否则触发 <code>ConcurrentModificationException</code>）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-4-Hashtable【了解】"><a href="#3-2-4-Hashtable【了解】" class="headerlink" title="3.2.4 Hashtable【了解】"></a>3.2.4 Hashtable【了解】</h4><h5 id="1-核心概念-18"><a href="#1-核心概念-18" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ul>
<li><strong>定义</strong>：<br><code>Hashtable</code> 是 Java 集合框架中最早实现的键值对存储结构之一，实现了 <code>Map</code> 接口。它是一个<strong>线程安全</strong>的哈希表，所有公共方法都使用 <code>synchronized</code> 关键字修饰，保证多线程环境下的安全性。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>线程安全（Thread-Safe）</strong>：所有方法都是同步的，适合多线程环境。</li>
<li><strong>键和值均不允许为 null</strong>：<code>Hashtable</code> 不允许键或值为 <code>null</code>，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>键不可重复</strong>：与 <code>HashMap</code> 相同，键是唯一的。</li>
<li><strong>无序</strong>：迭代顺序不保证与插入顺序一致。</li>
<li><strong>性能较低</strong>：由于同步开销，单线程环境下性能不如 <code>HashMap</code>。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>：<br>基于“数组 + 链表”的结构实现，使用拉链法解决哈希冲突。与 <code>HashMap</code> 类似，但没有引入红黑树优化。</li>
</ul>
<hr>
<h5 id="2-底层数据结构和关键属性-16"><a href="#2-底层数据结构和关键属性-16" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>Hashtable</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table; <span class="comment">// 哈希桶数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> count;          <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold;                <span class="comment">// 扩容阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> loadFactor;             <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">// 结构修改次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">Entry</span><span class="params">(<span class="type">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>table</code>：存储链表的数组。</li>
<li><code>count</code>：当前元素数量。</li>
<li><code>threshold</code>：扩容阈值，等于 <code>容量 * 负载因子</code>。</li>
<li><code>loadFactor</code>：负载因子，默认 0.75。</li>
<li><code>modCount</code>：用于快速失败机制。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-15"><a href="#3-构造方法与初始化-15" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>Hashtable</code> 提供四种构造方法：</p>
<ol>
<li><strong><code>public Hashtable()</code></strong><br>默认初始容量为 11，负载因子为 0.75。</li>
<li><strong><code>public Hashtable(int initialCapacity)</code></strong><br>指定初始容量，负载因子为 0.75。</li>
<li><strong><code>public Hashtable(int initialCapacity, float loadFactor)</code></strong><br>完全自定义初始容量和负载因子。</li>
<li><strong><code>public Hashtable(Map&lt;? extends K, ? extends V&gt; t)</code></strong><br>使用已有 Map 初始化，容量为 <code>Math.max(2*t.size(), 11)</code>。</li>
</ol>
<hr>
<h5 id="4-哈希计算与下标定位"><a href="#4-哈希计算与下标定位" class="headerlink" title="4. 哈希计算与下标定位"></a>4. 哈希计算与下标定位</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode(); <span class="comment">// 不允许 null key</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % table.length;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>key.hashCode()</code> 计算哈希值。</li>
<li>通过取模运算定位桶下标（<code>%</code> 运算，非位运算）。</li>
</ul>
<hr>
<h5 id="5-添加-更新元素（Put）"><a href="#5-添加-更新元素（Put）" class="headerlink" title="5. 添加&#x2F;更新元素（Put）"></a>5. 添加&#x2F;更新元素（Put）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="comment">// 遍历链表，若找到相同 key 则覆盖</span></span><br><span class="line">    <span class="comment">// 否则在链表头部插入新节点</span></span><br><span class="line">    <span class="comment">// 若 size &gt;= threshold，则调用 rehash() 扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>线程安全</strong>：方法使用 <code>synchronized</code> 修饰。</li>
<li><strong>不允许 null 值</strong>：会抛出 <code>NullPointerException</code>。</li>
<li><strong>扩容机制</strong>：当 <code>count &gt;= threshold</code> 时，调用 <code>rehash()</code> 方法扩容为 <code>2 * oldCapacity + 1</code>。</li>
</ul>
<hr>
<h5 id="6-获取元素（Get）"><a href="#6-获取元素（Get）" class="headerlink" title="6. 获取元素（Get）"></a>6. 获取元素（Get）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历链表查找对应键的值。</li>
<li>若未找到则返回 <code>null</code>。</li>
</ul>
<hr>
<h5 id="7-删除元素（Remove）"><a href="#7-删除元素（Remove）" class="headerlink" title="7. 删除元素（Remove）"></a>7. 删除元素（Remove）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="comment">// 遍历链表，找到并移除节点</span></span><br><span class="line">    <span class="comment">// 修改 modCount 和 count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除节点并维护链表结构。</li>
<li>同步方法，线程安全。</li>
</ul>
<hr>
<h5 id="8-遍历方式-3"><a href="#8-遍历方式-3" class="headerlink" title="8. 遍历方式"></a>8. 遍历方式</h5><p>与 <code>HashMap</code> 类似，支持三种视图：</p>
<ul>
<li><code>Enumeration&lt;K&gt; keys()</code>：返回键的枚举。</li>
<li><code>Enumeration&lt;V&gt; elements()</code>：返回值的枚举。</li>
<li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：返回键值对的集合。</li>
</ul>
<blockquote>
<p>⚠️ 注意：<code>Hashtable</code> 的迭代器不是快速失败的（没有 <code>modCount</code> 检查），但枚举器是。</p>
</blockquote>
<hr>
<h4 id="3-2-5-ConcurrentHashMap【核心掌握】"><a href="#3-2-5-ConcurrentHashMap【核心掌握】" class="headerlink" title="3.2.5 ConcurrentHashMap【核心掌握】"></a>3.2.5 ConcurrentHashMap【核心掌握】</h4><h5 id="1-核心概念-19"><a href="#1-核心概念-19" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ul>
<li><p><strong>定义</strong>：</p>
<p><code>ConcurrentHashMap</code> 是 <code>java.util.concurrent</code> 包下的一个线程安全的哈希表实现，它实现了 <code>ConcurrentMap</code> 接口。它通过细粒度的锁机制（JDK 7 的分段锁和 JDK 8 的 CAS + synchronized）来实现高并发下的高性能访问，是 <code>Hashtable</code> 的高性能替代品。</p>
</li>
<li><p><strong>核心特征</strong>：</p>
<ul>
<li><strong>线程安全（Thread-Safe）</strong>：支持高并发的读和写操作，不同段或桶上的操作可以并行进行。</li>
<li><strong>高性能</strong>：读操作通常不需要加锁，写操作使用锁分段或CAS优化，性能远高于 <code>Hashtable</code>。</li>
<li><strong>允许 Null 值</strong>：<strong>不允许 null 键或 null 值</strong>，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>键不可重复</strong>：与 <code>HashMap</code> 一致，键是唯一的。</li>
<li><strong>无序</strong>：迭代顺序不保证与插入顺序一致。</li>
<li><strong>弱一致性迭代器</strong>：迭代器反映的是创建迭代器时或之前的映射状态，不保证反映之后的修改。</li>
</ul>
</li>
<li><p><strong>核心实现原理（JDK8+）</strong></p>
<p>在 JDK 8 及之后，<code>ConcurrentHashMap</code> 放弃了分段锁（Segment），改为采用与 <code>HashMap</code> 类似的 <strong>“数组 + 链表 + 红黑树”</strong> 结构，但通过以下技术实现并发控制：</p>
<ol>
<li><strong>CAS (Compare-And-Swap)</strong>：用于无锁化的初始化、节点插入等操作。</li>
<li><strong>synchronized</strong>：对单个数组桶（链表头节点&#x2F;树根节点）进行同步，锁粒度更细。</li>
<li><strong>volatile</strong>：保证变量的可见性（如 <code>table</code>, <code>nextTable</code>, <code>sizeCtl</code> 等）。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="2-底层数据结构和关键属性-17"><a href="#2-底层数据结构和关键属性-17" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>concurrentHashMap</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组，延迟初始化，长度总是 2 的幂</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容时使用的下一张哈希表（非空时表示正在扩容）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制表初始化和扩容的状态标志。</span></span><br><span class="line">    <span class="comment">// 负数：-1 表示正在初始化，-N 表示有 N-1 个线程正在扩容。</span></span><br><span class="line">    <span class="comment">// 正数：0 表示未初始化，&gt;0 表示下一次扩容的阈值（容量 * 负载因子）。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认并发级别（为了兼容旧版API，实际不再使用分段锁）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认负载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表转红黑树的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树退化为链表的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小树化容量（表长度达到此值才允许树化）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本哈希节点类，用于链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">        <span class="comment">// ... 构造方法和其他实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;</span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;</span><br><span class="line">        <span class="type">boolean</span> red;</span><br><span class="line">        <span class="comment">// ... 树相关方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  forwarding 节点（在扩容时使用，指向 nextTable）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">        ForwardingNode(Node&lt;K,V&gt;[] nextTable) &#123;</span><br><span class="line">            <span class="built_in">super</span>(MOVED, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="built_in">this</span>.nextTable = nextTable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 查找方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-构造方法与初始化-16"><a href="#3-构造方法与初始化-16" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>ConcurrentHashMap</code> 提供多种构造方式：</p>
<ol>
<li><strong><code>public ConcurrentHashMap()</code></strong><ul>
<li>创建一个默认初始容量（16）、默认负载因子（0.75）和默认并发级别（16）的空映射。</li>
</ul>
</li>
<li><strong><code>public ConcurrentHashMap(int initialCapacity)</code></strong><ul>
<li>创建指定初始容量的空映射。</li>
</ul>
</li>
<li><strong><code>public ConcurrentHashMap(int initialCapacity, float loadFactor)</code></strong><ul>
<li>创建指定初始容量和负载因子的空映射。</li>
</ul>
</li>
<li><strong><code>public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</code></strong><ul>
<li>指定初始容量、负载因子和并发级别（ hint，JDK8 中主要用于兼容性）。</li>
</ul>
</li>
<li><strong><code>public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</code></strong><ul>
<li>用给定映射中的键值对初始化。</li>
</ul>
</li>
</ol>
<p>初始化表（<code>table</code>）是<strong>延迟</strong>进行的，在第一次插入（<code>put</code>）时通过 CAS 操作完成。</p>
<hr>
<h5 id="4-添加-更新元素"><a href="#4-添加-更新元素" class="headerlink" title="4. 添加&#x2F;更新元素"></a>4. 添加&#x2F;更新元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable(); <span class="comment">// 延迟初始化表</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 桶为空，CAS 尝试插入新节点</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// MOVED = -1，表示正在扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f); <span class="comment">// 协助扩容</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 锁住桶头节点</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">// 再次验证防止被修改</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 普通链表节点</span></span><br><span class="line">                        <span class="comment">// ... 遍历链表，更新或插入节点</span></span><br><span class="line">                        <span class="comment">// 若链表长度达到 TREEIFY_THRESHOLD，调用 treeifyBin 尝试树化</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树节点</span></span><br><span class="line">                        <span class="comment">// ... 调用红黑树的插入方法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i); <span class="comment">// 尝试树化</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount); <span class="comment">// 更新计数，并检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-获取元素"><a href="#5-获取元素" class="headerlink" title="5. 获取元素"></a>5. 获取元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val; <span class="comment">// 直接命中头节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) <span class="comment">// 特殊节点（树节点或ForwardingNode）</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>读操作通常无锁</strong>：通过 <code>volatile</code> 变量 <code>val</code> 和 <code>next</code> 保证可见性。</li>
<li>遇到特殊节点（如 <code>ForwardingNode</code>）时，会调用其 <code>find</code> 方法到新表中查找。</li>
</ul>
<hr>
<h5 id="6-删除元素"><a href="#6-删除元素" class="headerlink" title="6. 删除元素"></a>6. 删除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">validated</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// ... 验证桶头节点未变</span></span><br><span class="line">                <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 链表</span></span><br><span class="line">                    <span class="comment">// ... 遍历查找并删除</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 树</span></span><br><span class="line">                    <span class="comment">// ... 树中查找并删除</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 若树太小，退化为链表</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="7-扩容机制"><a href="#7-扩容机制" class="headerlink" title="7. 扩容机制"></a>7. 扩容机制</h5><p>当元素数量达到阈值（<code>容量 * 负载因子</code>）时，会触发扩容。扩容由多个线程协同完成：</p>
<ol>
<li><strong>生成新表</strong>：新表大小为原表的2倍。</li>
<li><strong>分配任务</strong>：线程每次处理一个桶（链表&#x2F;树），处理完成后将该桶标记为 <code>ForwardingNode</code>。</li>
<li><strong>协助扩容</strong>：其他线程在执行操作时若发现桶为 <code>ForwardingNode</code>，则会协助进行数据迁移。</li>
<li><strong>迁移完成</strong>：所有桶迁移完成后，用 <code>nextTable</code> 替换 <code>table</code>。</li>
</ol>
<hr>
<h5 id="8-遍历方式-4"><a href="#8-遍历方式-4" class="headerlink" title="8. 遍历方式"></a>8. 遍历方式</h5><p>提供三种视图的迭代器，均为<strong>弱一致性</strong>（weakly consistent）：</p>
<ul>
<li><code>KeySetView&lt;K,V&gt; keySet()</code></li>
<li><code>ValuesView&lt;K,V&gt; values()</code></li>
<li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></li>
</ul>
<p>弱一致性指迭代器反映的是创建迭代器时或之前的映射状态，但不保证反映迭代过程中的修改，且不会抛出 <code>ConcurrentModificationException</code>。</p>
<hr>
<h4 id="3-2-6-综合对比"><a href="#3-2-6-综合对比" class="headerlink" title="3.2.6 综合对比"></a>3.2.6 综合对比</h4><h5 id="1-核心特性对比表"><a href="#1-核心特性对比表" class="headerlink" title="1. 核心特性对比表"></a>1. 核心特性对比表</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>HashMap</code></th>
<th align="left"><code>LinkedHashMap</code></th>
<th align="left"><code>TreeMap</code></th>
<th align="left"><code>Hashtable</code></th>
<th align="left"><code>ConcurrentHashMap</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层数据结构</strong></td>
<td align="left"><strong>数组 + 链表&#x2F;红黑树 (JDK8+)</strong></td>
<td align="left"><strong>数组 + 链表&#x2F;红黑树 + 双向链表</strong></td>
<td align="left"><strong>红黑树</strong></td>
<td align="left"><strong>数组 + 链表</strong></td>
<td align="left"><strong>数组 + 链表&#x2F;红黑树 (JDK8+)</strong></td>
</tr>
<tr>
<td align="left"><strong>所在包</strong></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><strong><code>java.util.concurrent</code></strong></td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong> (方法大多用 <code>synchronized</code> 修饰)</td>
<td align="left"><strong>是</strong> (通过 CAS + <code>synchronized</code> 实现 (JDK8+))</td>
</tr>
<tr>
<td align="left"><strong>锁机制</strong></td>
<td align="left">无</td>
<td align="left">无</td>
<td align="left">无</td>
<td align="left">悲观锁 (<code>synchronized</code> 方法级)</td>
<td align="left"><strong>分段锁 (JDK7) &#x2F; 桶级别锁 (CAS + <code>synchronized</code>, JDK8+)</strong></td>
</tr>
<tr>
<td align="left"><strong>是否允许 Null Key&#x2F;Value</strong></td>
<td align="left"><strong>是</strong> (允许多个Null Value和1个Null Key)</td>
<td align="left"><strong>是</strong> (允许多个Null Value和1个Null Key)</td>
<td align="left"><strong>否</strong> (Key不能为null，Value可为null，取决于Comparator)</td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
</tr>
<tr>
<td align="left"><strong>元素顺序</strong></td>
<td align="left"><strong>无序</strong> (遍历顺序不确定)</td>
<td align="left"><strong>有序</strong> (默认按<strong>插入顺序</strong>，可配置为<strong>访问顺序</strong>)</td>
<td align="left"><strong>有序</strong> (按Key的<strong>自然顺序</strong>或<strong>Comparator排序</strong>)</td>
<td align="left"><strong>无序</strong></td>
<td align="left"><strong>无序</strong></td>
</tr>
<tr>
<td align="left"><strong>get&#x2F;put&#x2F;remove 性能</strong></td>
<td align="left"><strong>O(1)</strong> (平均，哈希函数良好)</td>
<td align="left"><strong>O(1)</strong> (平均)</td>
<td align="left"><strong>O(log n)</strong></td>
<td align="left"><strong>O(1)</strong> (平均)</td>
<td align="left"><strong>O(1)</strong> (平均)</td>
</tr>
<tr>
<td align="left"><strong>迭代性能</strong></td>
<td align="left">与容量相关，较好</td>
<td align="left"><strong>极快</strong> (直接遍历双向链表，与容量无关)</td>
<td align="left"><strong>O(n)</strong> (中序遍历)</td>
<td align="left">与容量相关，较好</td>
<td align="left">与容量相关，较好 (弱一致性迭代器)</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">较小</td>
<td align="left"><strong>较大</strong> (额外维护双向链表)</td>
<td align="left"><strong>较大</strong> (存储树结构开销)</td>
<td align="left">类似<code>HashMap</code></td>
<td align="left"><strong>较高</strong> (为实现并发控制的结构复杂度)</td>
</tr>
<tr>
<td align="left"><strong>迭代器</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong> (但已过时)</td>
<td align="left"><strong>弱一致性 (Weakly Consistent)</strong> (不会抛出<code>CME</code>)</td>
</tr>
<tr>
<td align="left"><strong>扩容机制</strong></td>
<td align="left"><strong>初始容量16，扩容为2的幂次 (2n)</strong></td>
<td align="left"><strong>同 <code>HashMap</code></strong></td>
<td align="left"><strong>无扩容</strong> (通过红黑树自平衡)</td>
<td align="left"><strong>初始容量11，扩容为 2n+1</strong></td>
<td align="left"><strong>类似 <code>HashMap</code>，但实现更复杂以支持并发</strong></td>
</tr>
</tbody></table>
<h5 id="2-如何选择"><a href="#2-如何选择" class="headerlink" title="2. 如何选择"></a>2. 如何选择</h5><p>选择的原则主要基于：<strong>性能需求</strong>、<strong>线程安全需求</strong>、<strong>顺序需求</strong> 和 <strong>对 Null 值的支持</strong>。</p>
<p><strong><code>HashMap</code> (单线程默认首选)</strong></p>
<ul>
<li><strong>场景</strong>：<strong>绝大多数单线程情况下的默认选择</strong>。</li>
<li><strong>原因</strong>：<ul>
<li><strong>性能最佳</strong> (平均O(1)时间复杂度)。</li>
<li><strong>通用性强</strong>。</li>
</ul>
</li>
<li><strong>注意</strong>：非线程安全。遍历顺序不可预测。</li>
</ul>
<p><strong><code>LinkedHashMap</code> (需要保持插入或访问顺序)</strong></p>
<ul>
<li><strong>场景</strong>：需要<strong>保持元素的插入顺序</strong>，或实现<strong>LRU (最近最少使用) 缓存</strong>。</li>
<li><strong>原因</strong>：<ul>
<li><strong>提供了可预测的迭代顺序</strong>。</li>
<li><strong>性能接近 <code>HashMap</code></strong>。</li>
</ul>
</li>
<li><strong>典型用例</strong>：缓存、需要按顺序处理或展示数据的场景。</li>
</ul>
<p><strong><code>TreeMap</code> (需要按Key排序)</strong></p>
<ul>
<li><strong>场景</strong>：需要让<strong>元素按照Key的自然顺序或者自定义顺序进行排序</strong>。</li>
<li><strong>原因</strong>：<ul>
<li><strong>Key有序</strong>，支持<strong>范围查找</strong>和<strong>顺序访问</strong>。</li>
<li>实现了 <code>NavigableMap</code> 接口，提供了一系列导航方法 (如 <code>ceilingKey</code>, <code>floorEntry</code>)。</li>
</ul>
</li>
<li><strong>缺点</strong>：平均性能为 O(log n)，比哈希实现的Map慢。</li>
</ul>
<p><strong><code>Hashtable</code> (历史遗留，不推荐使用)</strong></p>
<ul>
<li><strong>结论</strong>：<strong>基本上不应该在新的代码中使用</strong>。</li>
<li><strong>原因</strong>：<ul>
<li><strong>性能开销</strong>：粗粒度的<code>synchronized</code>方法级锁导致性能极其低下。</li>
<li><strong>有更好的替代品</strong>：<strong><code>ConcurrentHashMap</code></strong> 在任何需要线程安全的场景下都是更优的选择。</li>
<li><strong>API设计过时</strong>：是遗留类，不属于集合框架。</li>
</ul>
</li>
</ul>
<p><strong><code>ConcurrentHashMap</code> (高并发场景首选)</strong></p>
<ul>
<li><strong>场景</strong>：<strong>高并发</strong>环境下需要线程安全的Map。</li>
<li><strong>典型用例</strong>：<strong>多线程共享的缓存</strong>、<strong>并发计算</strong>等。</li>
<li><strong>选择原因</strong>：<ul>
<li><strong>高并发高性能</strong>：采用更细粒度的锁机制 (JDK8+是桶级别锁)，并发读基本无阻塞，并发写性能远高于 <code>Hashtable</code> 和 <code>Collections.synchronizedMap</code>。</li>
<li><strong>线程安全</strong>：提供线程安全的保证。</li>
<li><strong>迭代安全</strong>：迭代器是弱一致性的，不会抛出 <code>ConcurrentModificationException</code>。</li>
</ul>
</li>
<li><strong>注意</strong>：不允许 <code>null</code> 键或值。</li>
</ul>
<hr>
<h2 id="4-工具类：Collections"><a href="#4-工具类：Collections" class="headerlink" title="4. 工具类：Collections"></a>4. 工具类：Collections</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><ul>
<li><p><strong>定义</strong>：</p>
<p><code>Collections</code> <strong>提供了一系列静态方法，用于对集合（Collection）进行操作、包装和管理</strong>。这些方法极大地增强了 Java 集合框架的功能，提供了很多通用算法和数据操作的实现，使得开发者无需重复造轮子。</p>
</li>
<li><p><strong>核心特点</strong>：</p>
<ol>
<li><strong>静态工具类</strong>：它所有的方法都是静态的，不需要创建 <code>Collections</code> 的实例，直接通过类名调用即可（例如：<code>Collections.sort(list)</code>）。</li>
<li><strong>操作对象</strong>：主要操作 <code>Collection</code> 接口下的对象，最常用的是 <code>List</code>，也有些方法用于 <code>Set</code>、<code>Map</code> 等。</li>
<li><strong>包含算法</strong>：排序、查找、替换、同步控制、不可变集合创建等。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-2-主要功能与方法分类"><a href="#4-2-主要功能与方法分类" class="headerlink" title="4.2 主要功能与方法分类"></a>4.2 主要功能与方法分类</h3><h4 id="4-2-1-排序和查找（Sorting-and-Searching）"><a href="#4-2-1-排序和查找（Sorting-and-Searching）" class="headerlink" title="4.2.1 排序和查找（Sorting and Searching）"></a>4.2.1 排序和查找（Sorting and Searching）</h4><p>这是 <code>Collections</code> 最常用的功能之一。</p>
<ul>
<li><strong><code>sort(List&lt;T&gt; list)</code></strong>:<ul>
<li><strong>功能</strong>：根据元素的自然顺序（<code>Comparable</code> 接口）对指定列表进行升序排序。</li>
<li><strong>要求</strong>：列表中的所有元素都必须实现 <code>Comparable</code> 接口。</li>
</ul>
</li>
<li><strong><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code></strong>:<ul>
<li><strong>功能</strong>：根据指定的比较器 <code>Comparator</code> 对列表进行排序。这提供了更大的灵活性，可以自定义排序规则。</li>
</ul>
</li>
<li><strong><code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code></strong>:<ul>
<li><strong>功能</strong>：使用二分查找算法在<strong>已排序的</strong>列表中搜索指定元素。</li>
<li><strong>重要</strong>：<strong>列表必须是有序的（通常是升序）</strong>，否则结果不可预测。</li>
<li><strong>返回值</strong>：如果找到则返回索引；否则返回一个负值。</li>
</ul>
</li>
<li><strong><code>reverse(List&lt;?&gt; list)</code></strong>:<ul>
<li><strong>功能</strong>：反转指定列表中元素的顺序。</li>
</ul>
</li>
<li><strong><code>shuffle(List&lt;?&gt; list)</code></strong>:<ul>
<li><strong>功能</strong>：使用默认的随机源随机打乱列表元素的顺序（洗牌）。</li>
</ul>
</li>
</ul>
<p><strong>示例代码：排序和查找</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        numbers.add(<span class="number">5</span>);</span><br><span class="line">        numbers.add(<span class="number">1</span>);</span><br><span class="line">        numbers.add(<span class="number">8</span>);</span><br><span class="line">        numbers.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原始列表: &quot;</span> + numbers); <span class="comment">// [5, 1, 8, 3]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 自然排序（升序）</span></span><br><span class="line">        Collections.sort(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后: &quot;</span> + numbers); <span class="comment">// [1, 3, 5, 8]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 自定义排序（降序）</span></span><br><span class="line">        Collections.sort(numbers, Comparator.reverseOrder());</span><br><span class="line">        <span class="comment">// 或者使用 Lambda: Collections.sort(numbers, (a, b) -&gt; b - a);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;降序后: &quot;</span> + numbers); <span class="comment">// [8, 5, 3, 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 二分查找（必须先排序！这里先重新排序成升序）</span></span><br><span class="line">        Collections.sort(numbers); <span class="comment">// 恢复为 [1, 3, 5, 8]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Collections.binarySearch(numbers, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素 5 的索引是: &quot;</span> + index); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 反转</span></span><br><span class="line">        Collections.reverse(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;反转后: &quot;</span> + numbers); <span class="comment">// [8, 5, 3, 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 洗牌</span></span><br><span class="line">        Collections.shuffle(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;洗牌后: &quot;</span> + numbers); <span class="comment">// 顺序随机，如 [3, 8, 1, 5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-2-同步控制（Synchronization-Wrappers）"><a href="#4-2-2-同步控制（Synchronization-Wrappers）" class="headerlink" title="4.2.2 同步控制（Synchronization Wrappers）"></a>4.2.2 同步控制（Synchronization Wrappers）</h4><p>标准的集合实现（如 <code>ArrayList</code>, <code>HashSet</code>, <code>HashMap</code>）是<strong>非线程安全</strong>的。<code>Collections</code> 提供了创建线程安全版本的方法，这些方法返回一个同步（线程安全）的集合包装器。</p>
<ul>
<li><strong><code>synchronizedCollection(Collection&lt;T&gt; c)</code></strong></li>
<li><strong><code>synchronizedList(List&lt;T&gt; list)</code></strong></li>
<li><strong><code>synchronizedSet(Set&lt;T&gt; s)</code></strong></li>
<li><strong><code>synchronizedMap(Map&lt;K, V&gt; m)</code></strong></li>
</ul>
<p><strong>原理</strong>：这些方法返回的包装器对象，<strong>将所有方法（如 <code>add</code>, <code>get</code>, <code>put</code>）包装在同步块（<code>synchronized</code>）中</strong>，从而保证多线程环境下的安全。</p>
<p><strong>示例与注意</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; syncList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以在多线程中安全地使用 syncList 了</span></span><br><span class="line"><span class="comment">// 但是，在迭代遍历它时，仍然需要手动同步</span></span><br><span class="line"><span class="keyword">synchronized</span>(syncList) &#123;</span><br><span class="line">    Iterator&lt;String&gt; it = syncList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：在现代 Java 开发中，<strong>更推荐使用 <code>java.util.concurrent</code> 包下的并发集合</strong>（如 <code>CopyOnWriteArrayList</code>, <code>ConcurrentHashMap</code>），它们的性能通常优于这种同步包装器。</p>
<hr>
<h4 id="4-2-3-不可变集合（Unmodifiable-Wrappers）"><a href="#4-2-3-不可变集合（Unmodifiable-Wrappers）" class="headerlink" title="4.2.3 不可变集合（Unmodifiable Wrappers）"></a>4.2.3 不可变集合（Unmodifiable Wrappers）</h4><p>用于创建只读的、不可修改的集合视图。任何试图修改返回集合的操作（如 <code>add</code>, <code>remove</code>, <code>set</code>）都会抛出 <code>UnsupportedOperationException</code>。</p>
<ul>
<li><strong><code>unmodifiableCollection(Collection&lt;? extends T&gt; c)</code></strong></li>
<li><strong><code>unmodifiableList(List&lt;? extends T&gt; list)</code></strong></li>
<li><strong><code>unmodifiableSet(Set&lt;? extends T&gt; s)</code></strong></li>
<li><strong><code>unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></strong></li>
</ul>
<p><strong>用途</strong>：常用于向外部客户端暴露一个内部集合的只读视图，防止内部数据被意外修改。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">originalList.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">originalList.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个不可修改的视图</span></span><br><span class="line">List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(originalList);</span><br><span class="line"></span><br><span class="line">System.out.println(unmodifiableList); <span class="comment">// [A, B]</span></span><br><span class="line"><span class="comment">// unmodifiableList.add(&quot;C&quot;); // 抛出 UnsupportedOperationException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，修改原始集合仍然会影响这个“视图”</span></span><br><span class="line">originalList.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">System.out.println(unmodifiableList); <span class="comment">// [A, B, C]</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：它只是一个“视图”，如果底层的原始集合被修改，不可变视图的内容也会随之改变。如果需要真正的不可变集合，可以考虑使用 Java 9+ 的 <code>List.of()</code>, <code>Set.of()</code>, <code>Map.of()</code> 方法。</p>
<hr>
<h4 id="4-2-4-类型安全检查（Checked-Wrappers）"><a href="#4-2-4-类型安全检查（Checked-Wrappers）" class="headerlink" title="4.2.4 类型安全检查（Checked Wrappers）"></a>4.2.4 类型安全检查（Checked Wrappers）</h4><p>用于在运行时对添加到集合中的元素进行类型检查，确保类型安全，防止在泛型集合中插入错误类型的元素（例如，通过原始类型操作）。</p>
<ul>
<li><strong><code>checkedCollection(Collection&lt;E&gt; c, Class&lt;E&gt; type)</code></strong></li>
<li><strong><code>checkedList(List&lt;E&gt; list, Class&lt;E&gt; type)</code></strong></li>
<li><strong><code>checkedSet(Set&lt;E&gt; s, Class&lt;E&gt; type)</code></strong></li>
<li><strong><code>checkedMap(Map&lt;K, V&gt; m, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType)</code></strong></li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个原本只能存放 String 的 List</span></span><br><span class="line">List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 通过原始类型进行错误的插入（绕过编译期检查）</span></span><br><span class="line"><span class="type">List</span> <span class="variable">rawList</span> <span class="operator">=</span> strings;</span><br><span class="line">rawList.add(<span class="number">100</span>); <span class="comment">// 编译没问题，运行也没问题，但埋下了隐患</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 checkedList 包装</span></span><br><span class="line">List&lt;String&gt; safeStrings = Collections.checkedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), String.class);</span><br><span class="line"><span class="type">List</span> <span class="variable">rawList2</span> <span class="operator">=</span> safeStrings;</span><br><span class="line">rawList2.add(<span class="number">100</span>); <span class="comment">// 这一步会立即抛出 ClassCastException，而不是在后续遍历时才出错</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-5-其他实用方法"><a href="#4-2-5-其他实用方法" class="headerlink" title="4.2.5 其他实用方法"></a>4.2.5 其他实用方法</h4><ul>
<li><strong><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code></strong>: 将源列表中的所有元素复制到目标列表中。</li>
<li><strong><code>fill(List&lt;? super T&gt; list, T obj)</code></strong>: 用指定元素替换列表中的所有元素。</li>
<li><strong><code>max(Collection&lt;? extends T&gt; coll)</code> &#x2F; <code>min(...)</code></strong>: 根据自然顺序或比较器返回集合中的最大或最小元素。</li>
<li><strong><code>replaceAll(List&lt;T&gt; list, T oldVal, T newVal)</code></strong>: 将列表中所有出现的旧值替换为新值。</li>
<li><strong><code>frequency(Collection&lt;?&gt; c, Object o)</code></strong>: 返回指定元素在集合中出现的次数。</li>
<li><strong><code>disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</code></strong>: 如果两个集合没有共同的元素，则返回 <code>true</code>。</li>
<li><strong><code>addAll(Collection&lt;? super T&gt; c, T... elements)</code></strong>: 一种向集合中添加多个元素的便捷方式（变长参数）。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 一次性添加多个元素</span></span><br><span class="line">System.out.println(list); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;最大值: &quot;</span> + Collections.max(list)); <span class="comment">// 5</span></span><br><span class="line">System.out.println(<span class="string">&quot;最小值: &quot;</span> + Collections.min(list)); <span class="comment">// 1</span></span><br><span class="line">System.out.println(<span class="string">&quot;3 出现的频率: &quot;</span> + Collections.frequency(list, <span class="number">3</span>)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">Collections.replaceAll(list, <span class="number">3</span>, <span class="number">99</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;替换后: &quot;</span> + list); <span class="comment">// [1, 2, 99, 4, 5]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5. 迭代器"></a>5. 迭代器</h2><h3 id="5-1-核心概念"><a href="#5-1-核心概念" class="headerlink" title="5.1 核心概念"></a>5.1 核心概念</h3><p><strong>迭代器（Iterator）</strong> 是 Java 集合框架中的一种机制，允许程序员<strong>顺序访问</strong>集合中的元素，而<strong>不需要暴露集合内部的底层实现</strong>（如数组、链表、哈希表等）。</p>
<ul>
<li><strong>设计模式</strong>：基于 <strong>迭代器模式 (Iterator Pattern)</strong>。</li>
<li><strong>主要作用</strong>：统一了不同集合（List, Set, Map）的遍历方式。</li>
</ul>
<hr>
<h3 id="5-2-关键接口体系"><a href="#5-2-关键接口体系" class="headerlink" title="5.2 关键接口体系"></a>5.2 关键接口体系</h3><h4 id="5-2-1-Iterable-vs-Iterator"><a href="#5-2-1-Iterable-vs-Iterator" class="headerlink" title="5.2.1 Iterable vs Iterator"></a>5.2.1 <code>Iterable</code> vs <code>Iterator</code></h4><table>
<thead>
<tr>
<th align="left">接口</th>
<th align="left">定义</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>Iterable&lt;T&gt;</code></strong></td>
<td align="left"><code>java.lang</code> 包</td>
<td align="left"><strong>被遍历者</strong>。表示一个类是“<strong>可迭代的</strong>”。它只有一个核心方法 <code>iterator()</code>，用于返回一个迭代器实例。</td>
</tr>
<tr>
<td align="left"><strong><code>Iterator&lt;T&gt;</code></strong></td>
<td align="left"><code>java.util</code> 包</td>
<td align="left"><strong>遍历工具</strong>。它是实际执行遍历操作的对象，包含 <code>hasNext()</code>、<code>next()</code> 等方法。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>💡 思考：为什么不直接让 List 实现 Iterator 接口？</strong></p>
<p>这样可以将“集合的数据”与“遍历的状态”分离。一个集合可以同时有多个正在进行的遍历（多个 Iterator），互不干扰。如果集合本身就是 Iterator，游标混在一起就乱套了。</p>
</blockquote>
<hr>
<h4 id="5-2-2-常用方法"><a href="#5-2-2-常用方法" class="headerlink" title="5.2.2 常用方法"></a>5.2.2 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;  <span class="comment">// 判断是否还有下一个元素</span></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;           <span class="comment">// 返回下一个元素，并将游标后移</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除最近一次 next() 返回的元素（可选操作）</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; ... &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Java 8 新增：对剩余元素执行操作</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-3-底层原理与源码分析"><a href="#5-3-底层原理与源码分析" class="headerlink" title="5.3 底层原理与源码分析"></a>5.3 底层原理与源码分析</h3><p>以 <code>ArrayList</code> 的内部类 <code>Itr</code> 为例，理解迭代器是如何工作的。</p>
<h4 id="5-3-1-核心变量"><a href="#5-3-1-核心变量" class="headerlink" title="5.3.1 核心变量"></a>5.3.1 核心变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// 游标：下一个要返回元素的索引（默认为0）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 上一个返回元素的索引（如果删除了则为-1）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount; <span class="comment">// 【关键】版本号控制，用于 Fail-Fast 检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-2-执行流程-next-方法"><a href="#5-3-2-执行流程-next-方法" class="headerlink" title="5.3.2 执行流程 (next 方法)"></a>5.3.2 执行流程 (<code>next</code> 方法)</h4><ol>
<li><strong>检查共修改</strong>：<code>checkForComodification()</code>，判断 <code>modCount == expectedModCount</code>。</li>
<li><strong>获取元素</strong>：根据 <code>cursor</code> 获取数组中的元素。</li>
<li><strong>移动指针</strong>：<code>lastRet = cursor</code>，然后 <code>cursor++</code>。</li>
<li><strong>返回元素</strong>。</li>
</ol>
<hr>
<h3 id="5-4-Fail-Fast-机制-快速失败"><a href="#5-4-Fail-Fast-机制-快速失败" class="headerlink" title="5.4 Fail-Fast 机制 (快速失败)"></a>5.4 Fail-Fast 机制 (快速失败)</h3><p>这是迭代器最核心的保护机制。</p>
<h4 id="5-4-1-现象"><a href="#5-4-1-现象" class="headerlink" title="5.4.1 现象"></a>5.4.1 现象</h4><p>当使用迭代器遍历集合时，如果通过<strong>集合自身的方法</strong>（如 <code>list.add</code>, <code>list.remove</code>）修改了集合结构，下次调用 <code>next()</code> 时会抛出 <code>ConcurrentModificationException</code>。</p>
<hr>
<h4 id="5-4-2-原因"><a href="#5-4-2-原因" class="headerlink" title="5.4.2 原因"></a>5.4.2 原因</h4><ul>
<li><strong><code>modCount</code></strong>：集合类（如 ArrayList）记录结构修改次数的变量。</li>
<li><strong><code>expectedModCount</code></strong>：迭代器生成时记录的 <code>modCount</code> 快照。</li>
<li><strong>冲突</strong>：外部修改导致 <code>modCount</code> 增加，而迭代器内的 <code>expectedModCount</code> 未变。两者不一致 -&gt; 抛出异常。</li>
</ul>
<hr>
<h4 id="5-4-3-为什么-Iterator-remove-是安全的？"><a href="#5-4-3-为什么-Iterator-remove-是安全的？" class="headerlink" title="5.4.3 为什么 Iterator.remove() 是安全的？"></a>5.4.3 为什么 <code>Iterator.remove()</code> 是安全的？</h4><p><code>Iterator.remove()</code> 做了两件事：</p>
<ol>
<li>调用集合的 <code>remove()</code> 删除元素（<code>modCount</code> + 1）。</li>
<li><strong>手动同步</strong>：<code>expectedModCount = modCount</code>。<br>这样在下一次调用 <code>next()</code> 时，检查就能通过。</li>
</ol>
<blockquote>
<p><strong>❌ 错误示例 (for-each 中删除)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String s : list) &#123; <span class="comment">// for-each 是迭代器的语法糖</span></span><br><span class="line">    list.remove(s);     <span class="comment">// 修改了 modCount，但没通知迭代器 -&gt; 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p><strong>✅ 正确示例 (迭代器删除)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition(it.next())) &#123;</span><br><span class="line">        it.remove(); <span class="comment">// 内部会自动同步 expectedModCount</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<hr>
<h3 id="5-5-进阶：Fail-Safe-安全失败"><a href="#5-5-进阶：Fail-Safe-安全失败" class="headerlink" title="5.5 进阶：Fail-Safe (安全失败)"></a>5.5 进阶：Fail-Safe (安全失败)</h3><p>并非所有迭代器都会抛异常，<code>java.util.concurrent</code> 包下的并发容器通常是 <strong>Fail-Safe</strong> 的。</p>
<ul>
<li><strong>代表类</strong>：<code>CopyOnWriteArrayList</code>, <code>ConcurrentHashMap</code>。</li>
<li><strong>原理</strong>：<ul>
<li><strong>COW (Copy-On-Write)</strong>：迭代器遍历的是原有数据的<strong>快照</strong>（Snapshot），或者基于弱一致性。</li>
<li>当原集合被修改时，迭代器并不知道（或者不在乎），它继续遍历旧数据或不保证能读到最新数据。</li>
</ul>
</li>
<li><strong>缺点</strong>：无法保证数据的实时一致性；可能占用更多内存（复制副本）。</li>
</ul>
<hr>
<h3 id="5-6-ListIterator-特有的迭代器"><a href="#5-6-ListIterator-特有的迭代器" class="headerlink" title="5.6 ListIterator (特有的迭代器)"></a>5.6 <code>ListIterator</code> (特有的迭代器)</h3><p><code>Iterator</code> 只能单向移动（向后），<code>List</code> 接口特供了 <code>ListIterator</code>。</p>
<ul>
<li><strong>双向遍历</strong>：<code>hasPrevious()</code>, <code>previous()</code>。</li>
<li><strong>修改能力增强</strong>：除了 <code>remove()</code>，还支持 <code>add()</code> (插入), <code>set()</code> (修改当前元素)。</li>
<li><strong>获取索引</strong>：<code>nextIndex()</code>, <code>previousIndex()</code>。</li>
</ul>
<hr>
<h3 id="5-7-最佳实践总结"><a href="#5-7-最佳实践总结" class="headerlink" title="5.7 最佳实践总结"></a>5.7 最佳实践总结</h3><ol>
<li><strong>只读遍历</strong>：优先使用 <strong>for-each</strong> 循环（语法简洁）。</li>
<li><strong>遍历中删除</strong>：<ul>
<li><strong>Java 8 之前</strong>：必须使用 <code>Iterator.remove()</code>。</li>
<li><strong>Java 8 之后</strong>：推荐使用 <code>list.removeIf(obj -&gt; condition)</code> （代码更优雅，底层也是迭代器）。</li>
</ul>
</li>
<li><strong>多线程遍历</strong>：<ul>
<li>手动加锁（<code>synchronized</code>）。</li>
<li>或者使用 <code>CopyOnWriteArrayList</code> 等并发集合（注意数据一致性问题）。</li>
</ul>
</li>
<li><strong>Stream API</strong>：<ul>
<li>大多数时候，使用 <code>list.stream().filter(...).collect(...)</code> 产生新集合比直接修改原集合更安全、更易读。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">三、面向对象编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:10:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:10:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-25 18:14:26" itemprop="dateModified" datetime="2025-11-25T18:14:26+08:00">2025-11-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="三、面向对象编程"><a href="#三、面向对象编程" class="headerlink" title="三、面向对象编程"></a>三、面向对象编程</h1><h2 id="1-核心思想与基础概念"><a href="#1-核心思想与基础概念" class="headerlink" title="1. 核心思想与基础概念"></a>1. 核心思想与基础概念</h2><h3 id="1-1-面向过程和面向对象"><a href="#1-1-面向过程和面向对象" class="headerlink" title="1.1 面向过程和面向对象"></a>1.1 面向过程和面向对象</h3><ul>
<li><strong>面向过程 (POP - Procedure-Oriented Programming)</strong>：<strong>关注的是“怎么做”</strong>。就像一份<strong>菜谱</strong>，它详细记录了做一道菜的每一个步骤：第一步洗菜，第二步切菜，第三步热油，第四步下锅翻炒… 你按照线性的步骤一步一步执行，最终得到结果。<ul>
<li><strong>焦点</strong>：<strong>步骤（过程&#x2F;函数）</strong></li>
<li><strong>思维</strong>：“我先做什么，再做什么，然后做什么？”</li>
</ul>
</li>
<li><strong>面向对象 (OOP - Object-Oriented Programming)</strong>：<strong>关注的是“谁来做”</strong>。就像<strong>开一家餐厅</strong>。你不需要关心一道菜具体怎么炒（过程），你关心的是餐厅里有哪些角色：厨师、服务员、收银员、厨师长。你给每个角色分配任务：厨师负责做菜，服务员负责点菜和上菜，收银员负责收款。这些角色各司其职，通过互相协作来完成整个业务流程。<ul>
<li><strong>焦点</strong>：<strong>对象（类和对象）</strong></li>
<li><strong>思维</strong>：“我需要哪些对象？这些对象有什么属性和能力？对象之间如何交互？”</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">面向过程 (POP)</th>
<th align="left">面向对象 (OOP)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心思想</strong></td>
<td align="left">以<strong>函数</strong>为中心，强调步骤和过程。</td>
<td align="left">以<strong>对象</strong>为中心，强调具备属性和行为的实体。</td>
</tr>
<tr>
<td align="left"><strong>程序组成</strong></td>
<td align="left">一系列的函数&#x2F;方法。数据与函数是分离的。</td>
<td align="left">一系列相互作用的对象。数据与操作数据的方法被捆绑在一起。</td>
</tr>
<tr>
<td align="left"><strong>数据与函数</strong></td>
<td align="left"><strong>数据</strong>和<strong>处理数据的函数</strong>是分离的。</td>
<td align="left"><strong>数据</strong>和<strong>处理数据的函数（方法）</strong> 被封装在对象中。</td>
</tr>
<tr>
<td align="left"><strong>三大特性</strong></td>
<td align="left">不支持继承、多态，封装性也较差。</td>
<td align="left">支持<strong>封装、继承、多态</strong>，大大提升了代码的灵活性。</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">数据是全局的或传递的，任何函数都可以修改，安全性低。</td>
<td align="left">数据被封装在对象内部，通过接口访问，安全性高。</td>
</tr>
<tr>
<td align="left"><strong>代码复用</strong></td>
<td align="left">主要通过<strong>函数</strong>来复用代码。</td>
<td align="left">主要通过<strong>类（Class）</strong> 和<strong>继承（Inheritance）</strong> 来复用代码。</td>
</tr>
<tr>
<td align="left"><strong>设计思维</strong></td>
<td align="left"><strong>自顶向下</strong>、逐步求精。先设计主流程，再分解为小函数。</td>
<td align="left"><strong>自底向上</strong>。先抽象出各种类和对象，再让它们协作完成功能。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">性能要求极高的场景（如单片机、内核）、简单的脚本或工具。</td>
<td align="left">大型复杂系统、需要频繁迭代和维护的业务系统、GUI应用等。</td>
</tr>
<tr>
<td align="left"><strong>优点</strong></td>
<td align="left">性能通常更高，流程直接清晰，适合简单问题。</td>
<td align="left">易维护、易扩展、易复用，更接近现实世界，适合复杂问题。</td>
</tr>
<tr>
<td align="left"><strong>缺点</strong></td>
<td align="left">难以应对复杂需求，代码维护和扩展困难，耦合度高。</td>
<td align="left">性能相对较低（但现代硬件差距已很小），学习曲线稍陡。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-2-类和对象"><a href="#1-2-类和对象" class="headerlink" title="1.2 类和对象"></a>1.2 类和对象</h3><p><strong>类</strong>：是对一类具有相同属性和行为的对象的抽象描述。它是一种<strong>自定义的数据类型</strong>。</p>
<ul>
<li><strong>属性 (成员变量 Field)</strong>：对象具有的各种特征。例如：一个人的年龄、姓名；一部手机的品牌、颜色。</li>
<li><strong>行为 (成员方法 Method)</strong>：对象能够执行的操作。例如：人可以吃饭、睡觉；手机可以打电话、玩游戏。</li>
</ul>
<p><strong>对象</strong>：是根据类这个模板创建出来的一个<strong>具体的、唯一的实例</strong>。创建对象的过程也叫<strong>实例化</strong>。</p>
<ul>
<li>每个对象都拥有其所属类中定义的属性和行为，但每个对象的属性值（<strong>状态</strong>）是独立的。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义一个「类」，作为蓝图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; <span class="comment">// 类名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性/成员变量 (描述状态)</span></span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">int</span> age;     <span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 行为/成员方法 (描述能做什么)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, my name is &quot;</span> + name + <span class="string">&quot;. I&#x27;m &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建并使用「对象」</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 &#x27;new&#x27; 关键字实例化对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// person1 是一个对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// person2 是另一个独立的对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为对象的属性赋值</span></span><br><span class="line">        person1.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        person1.age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">        person2.name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        person2.age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用对象的方法</span></span><br><span class="line">        person1.sayHello(); <span class="comment">// 输出: Hello, my name is Alice. I&#x27;m 25 years old.</span></span><br><span class="line">        person2.sayHello(); <span class="comment">// 输出: Hello, my name is Bob. I&#x27;m 30 years old.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="2-核心特性"><a href="#2-核心特性" class="headerlink" title="2. 核心特性"></a>2. 核心特性</h2><h3 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h3><p><strong>隐藏对象的内部实现细节，仅对外提供公开的访问接口。</strong></p>
<h4 id="2-2-1-目的"><a href="#2-2-1-目的" class="headerlink" title="2.2.1 目的"></a>2.2.1 目的</h4><ol>
<li><strong>保证数据安全</strong>：防止对象的数据被意外或恶意地错误修改和访问。</li>
<li><strong>隐藏实现细节</strong>：类的内部实现可以自由改变，而不会影响使用该类的其他代码。只要公共接口保持不变，一切外部调用都能正常工作。</li>
<li><strong>提高代码可维护性</strong>：将数据和操作数据的方法绑定在一起，使得代码模块化程度更高，更容易理解和调试。</li>
</ol>
<hr>
<h4 id="2-2-2-实现方式（标准的JavaBean）"><a href="#2-2-2-实现方式（标准的JavaBean）" class="headerlink" title="2.2.2. 实现方式（标准的JavaBean）"></a>2.2.2. 实现方式（标准的JavaBean）</h4><ul>
<li>类名见名知意</li>
<li>成员变量使用<strong>private</strong>修饰</li>
<li>提供至少两个构造方法<ul>
<li>无参构造</li>
<li>带全部参数的有参构造</li>
</ul>
</li>
<li>成员方法：提供每个成员变量对应的setXxx()&#x2F;getXxx()</li>
</ul>
<hr>
<h3 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h3><h4 id="2-2-1-核心思想"><a href="#2-2-1-核心思想" class="headerlink" title="2.2.1 核心思想"></a>2.2.1 核心思想</h4><p><strong>基于已存在的类创建新类的过程。新类（子类）继承父类的属性和方法，并可以扩展新的属性和方法。</strong></p>
<p>继承描述的是“is-a”（是一个）的关系。例如，<code>Dog</code> (子类) <code>is an</code> <code>Animal</code> (父类)。</p>
<hr>
<h4 id="2-2-2-目的"><a href="#2-2-2-目的" class="headerlink" title="2.2.2 目的"></a>2.2.2 目的</h4><ol>
<li><strong>代码复用</strong>：子类可以直接使用父类非私有的属性和方法，无需重复编写。</li>
<li><strong>扩展功能</strong>：子类可以添加新的属性和方法，也可以<strong>重写</strong>父类的方法来改变其行为。</li>
<li><strong>为多态提供前提</strong>：多态的实现依赖于继承。</li>
</ol>
<hr>
<h4 id="2-2-3-实现方式"><a href="#2-2-3-实现方式" class="headerlink" title="2.2.3 实现方式"></a>2.2.3 实现方式</h4><ul>
<li>通过 <code>extends</code> 关键字实现单继承（Java 不支持多继承，但支持多重继承和接口实现）。</li>
<li>子类对象可以访问父类的 <code>public</code> 和 <code>protected</code> 成员。</li>
<li>子类<strong>不能继承</strong>父类的 <code>private</code> 成员和构造方法，但可以通过公共的 <code>getter/setter</code> 间接访问 <code>private</code> 属性。</li>
<li>可以使用 <code>super</code> 关键字来引用父类的成员（属性、方法、构造器）。</li>
</ul>
<hr>
<h4 id="2-2-4-代码示例"><a href="#2-2-4-代码示例" class="headerlink" title="2.2.4 代码示例"></a>2.2.4 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类（基类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name; <span class="comment">// protected，子类可以访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is sleeping.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类（派生类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; <span class="comment">// 使用 extends 继承</span></span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, String breed)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 使用 super 调用父类构造器</span></span><br><span class="line">        <span class="built_in">this</span>.breed = breed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展的新方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; (a &quot;</span> + breed + <span class="string">&quot;) says: Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写（Override）父类方法：改变行为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; the dog is gobbling down its food.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>);</span><br><span class="line">        myDog.eat();    <span class="comment">// 调用的是子类重写后的方法</span></span><br><span class="line">        myDog.sleep();  <span class="comment">// 调用从父类继承来的方法</span></span><br><span class="line">        myDog.bark();   <span class="comment">// 调用子类自己的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-多态"><a href="#2-3-多态" class="headerlink" title="2.3 多态"></a>2.3 多态</h3><h4 id="2-3-1-核心思想"><a href="#2-3-1-核心思想" class="headerlink" title="2.3.1 核心思想"></a>2.3.1 核心思想</h4><p><strong>同一操作作用于不同的对象，可以产生不同的执行结果。</strong></p>
<p>更通俗地说：<strong>父类引用可以指向子类对象，且该引用在调用方法时，实际执行的是子类重写后的方法。</strong></p>
<hr>
<h4 id="2-3-2-目的"><a href="#2-3-2-目的" class="headerlink" title="2.3.2 目的"></a>2.3.2 目的</h4><ol>
<li><strong>提高代码的灵活性和可扩展性</strong>：程序可以在运行时才决定调用哪个对象的方法，这使得程序更容易进行扩展和维护。例如，添加一个新的子类，无需修改基于父类的现有代码。</li>
<li><strong>接口统一</strong>：可以用父类类型来统一处理各种子类对象。</li>
</ol>
<hr>
<h4 id="2-3-3-实现条件"><a href="#2-3-3-实现条件" class="headerlink" title="2.3.3 实现条件"></a>2.3.3 实现条件</h4><ol>
<li><strong>继承</strong>：必须存在继承关系。</li>
<li><strong>重写</strong>：子类必须重写父类的方法。</li>
<li><strong>向上转型</strong>：父类引用指向子类对象：<code>Parent p = new Child();</code></li>
</ol>
<hr>
<h4 id="2-3-4-实现机制：动态绑定"><a href="#2-3-4-实现机制：动态绑定" class="headerlink" title="2.3.4 实现机制：动态绑定"></a>2.3.4 实现机制：动态绑定</h4><p>Java 的方法调用是在运行时才确定其具体类型的，而不是在编译时。编译器检查的是父类中是否有该方法，而运行时 JVM 会找到实际对象所属的类的方法来执行。</p>
<hr>
<h4 id="2-3-5-代码示例"><a href="#2-3-5-代码示例" class="headerlink" title="2.3.5 代码示例"></a>2.3.5 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a shape.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; <span class="comment">// 重写draw方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; <span class="comment">// 重写draw方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a square.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试多态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphismTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 多态的经典体现：父类引用指向子类对象</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(); <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>(); <span class="comment">// 向上转型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译时，shape1和shape2都是Shape类型</span></span><br><span class="line">        <span class="comment">// 运行时，JVM会根据它们实际指向的对象类型来调用相应的draw方法</span></span><br><span class="line">        shape1.draw(); <span class="comment">// 输出: Drawing a circle.</span></span><br><span class="line">        shape2.draw(); <span class="comment">// 输出: Drawing a square.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个更强大的例子：使用统一的方法处理不同的对象</span></span><br><span class="line">        Shape[] shapes = &#123;<span class="keyword">new</span> <span class="title class_">Circle</span>(), <span class="keyword">new</span> <span class="title class_">Square</span>(), <span class="keyword">new</span> <span class="title class_">Circle</span>()&#125;;</span><br><span class="line">        <span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">            shape.draw(); <span class="comment">// 同一个调用，产生多种不同的行为</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">           Drawing a circle.</span></span><br><span class="line"><span class="comment">           Drawing a square.</span></span><br><span class="line"><span class="comment">           Drawing a circle.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-抽象类"><a href="#2-4-抽象类" class="headerlink" title="2.4 抽象类"></a>2.4 抽象类</h3><p>抽象类（Abstract Class）在 Java 中是一种特殊的类，它<strong>不能被实例化</strong>（即你不能使用 <code>new</code> 关键字来创建一个抽象类的对象）。它存在的意义是<strong>作为其他类的基类（父类）</strong>，用于被继承。</p>
<h4 id="2-4-1-作用"><a href="#2-4-1-作用" class="headerlink" title="2.4.1. 作用"></a>2.4.1. 作用</h4><p>想象一个场景：我们要设计一个图形（<code>Shape</code>）类体系，包括圆形（<code>Circle</code>）、矩形（<code>Rectangle</code>）等。</p>
<ul>
<li>所有图形都有一个共同的行为：计算面积（<code>calculateArea()</code>）。</li>
<li>但是，<strong>计算面积的具体公式因图形而异</strong>。<code>Shape</code> 类本身无法提供一个通用的、有实际意义的面积计算公式。</li>
</ul>
<p>如果没有抽象类，我们可能会在 <code>Shape</code> 类中这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>; <span class="comment">// 或者抛出一个异常，但这并不优雅</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会导致两个问题：</p>
<ol>
<li>用户可能会错误地实例化 <code>Shape</code> 类，而一个“形状”本身是没有实际意义的。</li>
<li><code>return 0.0</code> 是一个无意义的、妥协的实现，容易引发错误。</li>
</ol>
<p><strong>抽象类解决了这个问题</strong>：它允许我们声明一个方法但不提供实现（即抽象方法），强制其子类<strong>必须</strong>提供这个方法的具体实现。这样就定义了一个清晰的契约（Contract）。</p>
<hr>
<h4 id="2-4-2-定义"><a href="#2-4-2-定义" class="headerlink" title="2.4.2 定义"></a>2.4.2 定义</h4><p>使用 <code>abstract</code> 关键字来修饰一个类。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 abstract 关键字声明一个抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名 &#123;</span><br><span class="line">    <span class="comment">// 类的成员：字段、具体方法、抽象方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键特性：抽象方法</strong></p>
<ul>
<li>抽象方法是一种<strong>只有声明，没有方法体（没有 <code>{}</code> ）</strong> 的方法。</li>
<li>抽象方法也<strong>必须</strong>使用 <code>abstract</code> 关键字来修饰。</li>
<li>包含抽象方法的类<strong>必须是</strong>抽象类。但反过来，抽象类不一定包含抽象方法（虽然这种情况不常见）。</li>
</ul>
<p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象方法没有方法体，以分号结束</span></span><br><span class="line">访问修饰符 <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">abstract</span> 访问修饰符 返回值类型 方法名(参数列表); <span class="comment">// 两种写法均可，通常前者更常见</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-3-特点与规则"><a href="#2-4-3-特点与规则" class="headerlink" title="2.4.3 特点与规则"></a>2.4.3 特点与规则</h4><ol>
<li><strong>不能被实例化</strong>：这是最基本的原则。<code>new AbstractClass()</code> 会导致编译错误。</li>
<li><strong>可以包含抽象方法和具体方法</strong>：抽象类提供了很好的灵活性，既可以定义契约（抽象方法），也可以提供公共的实现（具体方法）供子类复用。</li>
<li><strong>子类必须实现所有抽象方法</strong>：如果一个非抽象类（具体类）继承了一个抽象类，它<strong>必须</strong>实现（Override）父类中所有的抽象方法。否则，这个子类自己也必须声明为 <code>abstract</code>。</li>
<li><strong>可以有构造方法</strong>：虽然不能直接实例化，但抽象类的构造方法可以被子类的构造方法通过 <code>super()</code> 调用，用于初始化从抽象类继承的字段。</li>
<li><strong>可以有 main 方法</strong>：抽象类可以有 <code>static main</code> 方法，甚至可以运行它，但这通常只用于测试类本身的一些静态功能。</li>
<li><strong>可以包含所有普通类的成员</strong>：字段（成员变量）、具体方法、构造方法、静态方法、final 方法等。</li>
</ol>
<hr>
<h3 id="2-5-接口"><a href="#2-5-接口" class="headerlink" title="2.5 接口"></a>2.5 接口</h3><p>接口在 Java 中是一种<strong>完全抽象</strong>的引用类型。它是一组<strong>方法声明</strong>的集合，形成了一种行为契约（Contract）或协议（Protocol）。</p>
<p>核心思想是：<strong>“做什么”与“怎么做”分离</strong>。</p>
<ul>
<li><strong>接口</strong>：只定义“<strong>做什么</strong>”（即有哪些方法）。</li>
<li><strong>实现类</strong>：负责“<strong>怎么做</strong>”（即具体实现这些方法）。</li>
</ul>
<p>一个类通过<strong>实现（implements）</strong> 一个接口，来承诺它将提供接口中所有声明的具体实现。</p>
<hr>
<h4 id="2-5-1-核心目的与设计理念"><a href="#2-5-1-核心目的与设计理念" class="headerlink" title="2.5.1 核心目的与设计理念"></a>2.5.1 核心目的与设计理念</h4><p>接口的核心设计理念是定义 <strong>“can-do”关系</strong>（能够做什么），而不是 <strong>“is-a”关系</strong>（是什么）。</p>
<ul>
<li><strong>抽象类</strong>（如 <code>Shape</code>）：表示“它是一个图形”，这是一种本质上的分类。</li>
<li><strong>接口</strong>（如 <code>Drawable</code>）：表示“它可以被绘制”，这是一种能力或行为，任何不相关的对象（如图形、按钮、游戏角色）都可以拥有这个能力。</li>
</ul>
<p>接口的主要目的有：</p>
<ol>
<li><strong>实现多重继承的效果</strong>：Java 类是单继承的，但一个类可以实现多个接口。这使得类可以具备多种不同的能力。</li>
<li><strong>实现完全抽象</strong>：在早期 Java 版本中，接口是实现完全抽象的唯一方式。</li>
<li><strong>降低耦合，提高扩展性</strong>：程序依赖于接口（抽象）而非具体实现，使得代码更灵活，更容易扩展和维护。这是许多设计模式（如策略模式、工厂模式）的基础。</li>
</ol>
<hr>
<h4 id="2-5-2-接口的演变"><a href="#2-5-2-接口的演变" class="headerlink" title="2.5.2 接口的演变"></a>2.5.2 接口的演变</h4><table>
<thead>
<tr>
<th align="left">版本</th>
<th align="left">允许包含的内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Java 7 及以前</strong></td>
<td align="left">1. <strong>常量</strong> (<code>public static final</code>) 2. <strong>抽象方法</strong> (<code>public abstract</code>)</td>
</tr>
<tr>
<td align="left"><strong>Java 8</strong></td>
<td align="left">3. <strong>默认方法</strong> (<code>default</code>) 4. <strong>静态方法</strong> (<code>static</code>)</td>
</tr>
<tr>
<td align="left"><strong>Java 9</strong></td>
<td align="left">5. <strong>私有方法</strong> (<code>private</code>)</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-5-3-接口的成员解析"><a href="#2-5-3-接口的成员解析" class="headerlink" title="2.5.3 接口的成员解析"></a>2.5.3 接口的成员解析</h4><h5 id="1-抽象方法-Abstract-Methods"><a href="#1-抽象方法-Abstract-Methods" class="headerlink" title="1. 抽象方法 (Abstract Methods)"></a>1. 抽象方法 (Abstract Methods)</h5><p>这是接口最核心的成员。所有方法默认都是 <code>public abstract</code> 的，这些关键字可以省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 完整写法：public abstract void eat();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;   <span class="comment">// 省略写法，依然是公共的抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>; <span class="comment">// 省略写法，依然是公共的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>规则</strong>：任何实现该接口的<strong>非抽象类</strong>，必须提供所有这些抽象方法的具体实现。</p>
<hr>
<h5 id="2-常量-Constants"><a href="#2-常量-Constants" class="headerlink" title="2. 常量 (Constants)"></a>2. 常量 (Constants)</h5><p>接口中声明的字段默认都是 <code>public static final</code> 的（即常量），这些关键字也可以省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="comment">// 完整写法：public static final double PI = 3.14159;</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>; <span class="comment">// 省略写法，依然是公共静态常量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">APPLICATION_NAME</span> <span class="operator">=</span> <span class="string">&quot;MyApp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-默认方法-Default-Methods-Java-8"><a href="#3-默认方法-Default-Methods-Java-8" class="headerlink" title="3. 默认方法 (Default Methods) - Java 8+"></a>3. 默认方法 (Default Methods) - Java 8+</h5><p>使用 <code>default</code> 关键字修饰的方法。它<strong>有方法体</strong>，其主要目的是<strong>接口演化</strong>：允许向现有接口添加新方法，而不会破坏已有的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认方法 - 提供默认实现</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">honk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vehicle is honking!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car starts with key.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以选择不重写 honk() 方法，直接使用默认实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        myCar.start(); <span class="comment">// 输出: Car starts with key.</span></span><br><span class="line">        myCar.honk();  <span class="comment">// 输出: Vehicle is honking! (使用了默认实现)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-静态方法-Static-Methods-Java-8"><a href="#4-静态方法-Static-Methods-Java-8" class="headerlink" title="4. 静态方法 (Static Methods) - Java 8+"></a>4. 静态方法 (Static Methods) - Java 8+</h5><p>使用 <code>static</code> 关键字修饰的方法。它<strong>有方法体</strong>，属于接口本身，只能通过接口名直接调用，不能被实现类继承或重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MathOperations</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> MathOperations.add(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 通过接口名调用</span></span><br><span class="line">        System.out.println(sum); <span class="comment">// 输出: 8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Car myCar = new Car();</span></span><br><span class="line">        <span class="comment">// myCar.add(5, 3); // 错误！静态方法不能通过实现类的实例调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-私有方法-Private-Methods-Java-9"><a href="#5-私有方法-Private-Methods-Java-9" class="headerlink" title="5. 私有方法 (Private Methods) - Java 9+"></a>5. 私有方法 (Private Methods) - Java 9+</h5><p>使用 <code>private</code> 关键字修饰的方法。它<strong>有方法体</strong>，主要用于接口内部，作为默认方法或静态方法的辅助工具，用来抽取公共代码，减少重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">logInfo</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;INFO&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">logError</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;ERROR&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法，为默认方法提供共享代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String level, String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + level + <span class="string">&quot;] &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-5-4-定义与实现"><a href="#2-5-4-定义与实现" class="headerlink" title="2.5.4 定义与实现"></a>2.5.4 定义与实现</h4><h5 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1. 定义接口"></a>1. 定义接口</h5><p>使用 <code>interface</code> 关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名 &#123;</span><br><span class="line">    <span class="comment">// 抽象方法、常量、默认方法、静态方法、私有方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-实现接口"><a href="#2-实现接口" class="headerlink" title="2. 实现接口"></a>2. 实现接口</h5><p>使用 <code>implements</code> 关键字。一个类可以实现多个接口（用逗号分隔）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口<span class="number">1</span>, 接口<span class="number">2</span>, ... &#123;</span><br><span class="line">    <span class="comment">// 必须实现所有接口的所有抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-类的构成与高级特性"><a href="#3-类的构成与高级特性" class="headerlink" title="3. 类的构成与高级特性"></a>3. 类的构成与高级特性</h2><h3 id="3-1-类的成员"><a href="#3-1-类的成员" class="headerlink" title="3.1 类的成员"></a>3.1 类的成员</h3><h4 id="3-1-1-变量"><a href="#3-1-1-变量" class="headerlink" title="3.1.1 变量"></a>3.1.1 变量</h4><h5 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1. 局部变量"></a>1. 局部变量</h5><ul>
<li><strong>定义</strong>：在方法、构造函数或代码块内部声明的变量</li>
<li><strong>作用域</strong>：仅限于声明它的方法、构造函数或代码块内部</li>
<li><strong>生命周期</strong>：从声明处开始，到所在代码块执行结束时销毁</li>
<li><strong>特点</strong>：<ul>
<li>必须初始化后才能使用</li>
<li>不能使用访问修饰符（如public&#x2F;private）</li>
<li>存储在栈内存中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exampleMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    System.out.println(localVar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-成员变量-实例变量"><a href="#2-成员变量-实例变量" class="headerlink" title="2. 成员变量&#x2F;实例变量"></a>2. 成员变量&#x2F;实例变量</h5><ul>
<li><strong>定义</strong>：在类内部但在方法外部声明的变量，没有static修饰</li>
<li><strong>作用域</strong>：整个类内部都可访问</li>
<li><strong>生命周期</strong>：与对象实例相同，对象创建时产生，对象被垃圾回收时销毁</li>
<li><strong>特点</strong>：<ul>
<li>有默认值</li>
<li>可以使用访问修饰符</li>
<li>存储在堆内存中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> instanceVar; <span class="comment">// 成员变量/实例变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInstanceVar</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instanceVar = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-静态变量-类变量"><a href="#3-静态变量-类变量" class="headerlink" title="3. 静态变量&#x2F;类变量"></a>3. 静态变量&#x2F;类变量</h5><ul>
<li><strong>定义</strong>：使用static关键字声明的变量</li>
<li><strong>作用域</strong>：整个类以及可以通过类名访问</li>
<li><strong>生命周期</strong>：程序开始时创建，程序结束时销毁</li>
<li><strong>特点</strong>：<ul>
<li>所有类实例共享同一个静态变量</li>
<li>可以通过类名直接访问</li>
<li>有默认值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 静态变量/类变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyClass.staticVar = <span class="number">10</span>; <span class="comment">// 直接通过类名访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-常量"><a href="#4-常量" class="headerlink" title="4. 常量"></a>4. 常量</h5><ul>
<li><strong>定义</strong>：使用final关键字声明的变量，值一旦设定不能更改</li>
<li><strong>特点</strong>：<ul>
<li>如果是基本数据类型，值不能改变</li>
<li>如果是对象引用，引用不能改变，但对象内容可以改变</li>
<li>通常与static一起使用，表示类常量</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>; <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxValue;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxValue = max; <span class="comment">// 可以在构造函数中初始化final变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-2-方法"><a href="#3-1-2-方法" class="headerlink" title="3.1.2 方法"></a>3.1.2 方法</h4><h5 id="1-方法声明"><a href="#1-方法声明" class="headerlink" title="1. 方法声明"></a>1. 方法声明</h5><p>Java方法的基本结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[访问修饰符] [其他修饰符] 返回类型 方法名(参数列表) [异常列表] &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">addNumbers</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Numbers must be positive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-实例方法"><a href="#2-实例方法" class="headerlink" title="2. 实例方法"></a>2. 实例方法</h5><ul>
<li><strong>定义</strong>：不使用static关键字声明的方法</li>
<li><strong>特点</strong>：<ul>
<li>必须通过对象调用</li>
<li>可以访问类的所有成员变量和方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        result += value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Calculator</span> <span class="variable">calc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">calc.add(<span class="number">5</span>); <span class="comment">// 通过实例调用实例方法</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h5><ul>
<li><strong>定义</strong>：使用static关键字声明的方法</li>
<li><strong>特点</strong>：<ul>
<li>可以通过类名直接调用</li>
<li>只能直接访问静态变量和静态方法</li>
<li>不能使用this关键字</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathUtils</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> MathUtils.multiply(<span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 直接通过类名调用</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-抽象方法"><a href="#4-抽象方法" class="headerlink" title="4. 抽象方法"></a>4. 抽象方法</h5><ul>
<li><strong>定义</strong>：使用abstract关键字声明且没有方法体的方法</li>
<li><strong>特点</strong>：<ul>
<li>只能在抽象类或接口中声明</li>
<li>必须在子类中实现（除非子类也是抽象类）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-final方法"><a href="#5-final方法" class="headerlink" title="5. final方法"></a>5. final方法</h5><ul>
<li><strong>定义</strong>：使用final关键字声明的方法</li>
<li><strong>特点</strong>：不能被子类重写</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cannotOverride</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 此方法不能被子类重写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="6-同步方法"><a href="#6-同步方法" class="headerlink" title="6. 同步方法"></a>6. 同步方法</h5><ul>
<li><strong>定义</strong>：使用synchronized关键字声明的方法</li>
<li><strong>特点</strong>：用于多线程编程，确保同一时间只有一个线程执行该方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 线程安全操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="7-本地方法"><a href="#7-本地方法" class="headerlink" title="7. 本地方法"></a>7. 本地方法</h5><ul>
<li><strong>定义</strong>：使用native关键字声明的方法</li>
<li><strong>特点</strong>：方法实现由本地代码（如C&#x2F;C++）提供</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>; <span class="comment">// 本地方法，实现在外部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="8-可变参数"><a href="#8-可变参数" class="headerlink" title="8. 可变参数"></a>8. 可变参数</h5><p>可变参数（Variable Arguments，简称Varargs）是Java 5中引入的一个重要特性，它允许方法接受数量可变的同类型参数。这个特性大大简化了需要处理不定数量参数的方法编写。</p>
<ul>
<li><strong>语法</strong>：参数类型后添加三个点（…）</li>
<li>**原理：**可变参数在底层是基于数组实现的。编译器会自动将传递的参数转换为数组，因此在方法体内可以像处理数组一样处理可变参数。</li>
<li><strong>使用规则：</strong><ul>
<li><strong>一个方法只能有一个可变参数</strong></li>
<li><strong>可变参数必须是方法的最后一个参数</strong></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-1-3-构造器"><a href="#3-1-3-构造器" class="headerlink" title="3.1.3 构造器"></a>3.1.3 构造器</h4><p>构造方法是一个特殊的成员方法，它的名字<strong>必须与它所在的类名完全相同</strong>，并且<strong>没有返回类型</strong>（连 <code>void</code> 也没有）。它的主要作用是在创建对象时<strong>初始化该对象</strong>，即为对象的成员变量赋初始值。</p>
<h5 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h5><ol>
<li><strong>名称与类名完全相同</strong>。</li>
<li><strong>没有返回类型</strong>：这是它和普通方法最明显的区别。</li>
<li><strong>主要作用是初始化对象</strong>，而不是执行常规操作。</li>
<li><strong>在创建对象时自动调用</strong>：当使用 <code>new</code> 关键字实例化一个对象时，JVM 会自动调用相应的构造方法。</li>
<li><strong>不能被 <code>static</code>, <code>final</code>, <code>abstract</code>, <code>synchronized</code> 等修饰符修饰</strong>：但可以使用访问控制符（<code>public</code>, <code>protected</code>, <code>private</code>）。</li>
</ol>
<hr>
<h5 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h5><p><strong>a. 默认构造函数</strong></p>
<p>如果一个类没有<strong>显式地</strong>定义任何构造方法，Java 编译器会在编译时<strong>自动为你提供一个无参的、方法体为空的默认构造方法</strong>。</p>
<p><strong>格式：</strong><code>[public] ClassName() {}</code> （访问权限与类相同）</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 没有显式定义任何构造方法</span></span><br><span class="line">    <span class="comment">// 编译器会自动提供：public Person() &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用默认构造方法创建对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br></pre></td></tr></table></figure>

<p><strong>重要提示</strong>：一旦你显式地定义了一个或多个构造方法，编译器就<strong>不再提供</strong>默认的无参构造方法。这时如果你还想用 <code>new ClassName()</code> 的方式创建对象，就必须自己手动定义一个无参构造方法。</p>
<p><strong>b. 带参数的构造方法</strong></p>
<p>为了在创建对象时就赋予成员变量特定的值，我们可以定义带参数的构造方法。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 使用 this 关键字来区分同名的成员变量和参数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以同时定义一个无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>); <span class="comment">// 调用带参构造</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 调用无参构造</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-重载"><a href="#3-重载" class="headerlink" title="3. 重载"></a>3. 重载</h5><p>和普通方法一样，构造方法也可以重载。这意味着一个类中可以有多个同名的构造方法，但它们的<strong>参数列表（参数的类型、顺序或数量）必须不同</strong>。重载提供了多种初始化对象的方式，增加了类的灵活性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法1：初始化所有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String title, String author, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法2：只初始化 title 和 author，price 给默认值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String title, String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(title, author, <span class="number">0.0</span>); <span class="comment">// 使用 this() 调用另一个构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法3：无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Untitled&quot;</span>, <span class="string">&quot;Unknown&quot;</span>, <span class="number">0.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-使用-this-调用其他构造方法"><a href="#4-使用-this-调用其他构造方法" class="headerlink" title="4. 使用 this() 调用其他构造方法"></a>4. 使用 <code>this()</code> 调用其他构造方法</h5><p>在一个构造方法中，可以使用 <code>this(参数列表)</code> 的形式来调用本类的其他构造方法。这有助于减少代码重复。</p>
<p><strong>规则：</strong></p>
<ul>
<li><code>this()</code> 必须是构造方法体内的<strong>第一条语句</strong>。</li>
<li>只能在一个构造方法中调用一次其他的构造方法。</li>
</ul>
<p><strong>示例（见上例中的 <code>Book</code> 类）</strong></p>
<hr>
<h5 id="5-继承中的构造方法"><a href="#5-继承中的构造方法" class="headerlink" title="5. 继承中的构造方法"></a>5. 继承中的构造方法</h5><p>在存在继承关系的父子类中，构造方法的调用遵循以下规则：</p>
<ol>
<li><strong>子类构造方法必须调用父类构造方法</strong>：如果子类的构造方法没有显式地使用 <code>super(参数列表)</code> 来调用父类的某个构造方法，那么编译器会自动在子类构造方法的第一句加上 <code>super()</code>，即调用父类的无参构造方法。</li>
<li><code>super()</code> 和 <code>this()</code> 不能同时出现：因为它们都要求是第一条语句。</li>
<li><strong>如果父类没有无参构造方法，子类必须显式调用</strong>：如果父类只定义了带参构造方法（意味着编译器不会提供默认无参构造），那么子类的构造方法<strong>必须</strong>使用 <code>super(参数列表)</code> 显式地调用父类的某个带参构造方法，否则会编译错误。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类定义了带参构造，没有无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类必须显式调用父类的带参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String type, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(type); <span class="comment">// 必须放在第一行</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例：编译器会尝试自动添加 super()，但父类没有，所以会报错</span></span><br><span class="line">    <span class="comment">// public Dog(String name) &#123;</span></span><br><span class="line">    <span class="comment">//     this.name = name;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="6-最佳实践"><a href="#6-最佳实践" class="headerlink" title="6. 最佳实践"></a>6. 最佳实践</h5><ol>
<li><strong>养成好习惯</strong>：即使暂时不需要，也<strong>最好显式地写出无参构造方法</strong>。这可以避免因为后续添加了带参构造方法而导致的意外错误（比如很多框架如 Spring Hibernate 都默认使用无参构造来创建对象）。</li>
<li><strong>保持构造方法简单</strong>：构造方法的主要目的是初始化状态。避免在构造方法中编写复杂的逻辑或调用可能被重写的方法，这可能导致意想不到的行为。</li>
<li><strong>使用重载提供灵活性</strong>：提供多种构造方法，让类的使用者可以用最方便的方式初始化对象。</li>
</ol>
<hr>
<h4 id="3-1-4-代码块"><a href="#3-1-4-代码块" class="headerlink" title="3.1.4 代码块"></a>3.1.4 代码块</h4><h5 id="1-局部代码块"><a href="#1-局部代码块" class="headerlink" title="1. 局部代码块"></a>1. 局部代码块</h5><p>局部代码块定义在方法或语句中，用于限制变量的作用范围 ，提前结束变量的生命周期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalBlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 方法级别的代码</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 局部代码块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// y 只在此代码块内可见</span></span><br><span class="line">            System.out.println(<span class="string">&quot;y = &quot;</span> + y);</span><br><span class="line">            System.out.println(<span class="string">&quot;x inside block = &quot;</span> + x); <span class="comment">// 可以访问外部变量</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// System.out.println(y); // 编译错误: y 无法解析为变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x outside block = &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>限定变量生命周期，提高内存利用率</li>
<li>变量只在代码块内部可见</li>
<li>可以访问外部代码块的变量</li>
</ul>
<hr>
<h5 id="2-构造代码块"><a href="#2-构造代码块" class="headerlink" title="2. 构造代码块"></a>2. 构造代码块</h5><p>构造代码块用于初始化实例变量，在每次创建对象时执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorBlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        value = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块执行，value = &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorBlockExample</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorBlockExample</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        System.out.println(<span class="string">&quot;带参构造函数执行，value = &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConstructorBlockExample</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstructorBlockExample</span>();</span><br><span class="line">        <span class="type">ConstructorBlockExample</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstructorBlockExample</span>(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造代码块执行，value = 10</span><br><span class="line">构造函数执行</span><br><span class="line">构造代码块执行，value = 10</span><br><span class="line">带参构造函数执行，value = 20</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>每次创建对象时都会执行</li>
<li>在构造函数之前执行</li>
<li>多个构造代码块按顺序执行</li>
<li>常用于多个构造函数共享的初始化代码</li>
</ul>
<hr>
<h5 id="3-静态代码块"><a href="#3-静态代码块" class="headerlink" title="3. 静态代码块"></a>3. 静态代码块</h5><p>静态代码块用于初始化静态变量，在类加载时执行且只执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticBlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> staticValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> instanceValue;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staticValue = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行，staticValue = &quot;</span> + staticValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        instanceValue = <span class="number">50</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块执行，instanceValue = &quot;</span> + instanceValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticBlockExample</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主方法开始&quot;</span>);</span><br><span class="line">        <span class="type">StaticBlockExample</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticBlockExample</span>();</span><br><span class="line">        <span class="type">StaticBlockExample</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticBlockExample</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">静态代码块执行，staticValue = 100</span><br><span class="line">主方法开始</span><br><span class="line">构造代码块执行，instanceValue = 50</span><br><span class="line">构造函数执行</span><br><span class="line">构造代码块执行，instanceValue = 50</span><br><span class="line">构造函数执行</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>类加载时执行且只执行一次</li>
<li>在main方法之前执行</li>
<li>只能访问静态成员</li>
<li>常用于加载外部资源或执行一次性初始化操作</li>
</ul>
<hr>
<h5 id="4-同步代码块"><a href="#4-同步代码块" class="headerlink" title="4. 同步代码块"></a>4. 同步代码块</h5><p>同步代码块用于控制多线程对共享资源的访问，防止数据不一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedBlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块，使用lock对象作为锁</span></span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 非同步代码</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行非同步操作&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同步代码块，使用this作为锁</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入同步块&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedBlockExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedBlockExample</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建多个线程测试同步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                example.increment();</span><br><span class="line">                example.performTask();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>确保同一时间只有一个线程执行代码块</li>
<li>需要指定监视器对象（锁）</li>
<li>比同步方法更细粒度地控制同步</li>
<li>可以减少线程等待时间，提高效率</li>
</ul>
<hr>
<h3 id="3-2-关键字"><a href="#3-2-关键字" class="headerlink" title="3.2 关键字"></a>3.2 关键字</h3><h4 id="3-2-1-this、super"><a href="#3-2-1-this、super" class="headerlink" title="3.2.1 this、super"></a>3.2.1 this、super</h4><h5 id="1-this"><a href="#1-this" class="headerlink" title="1. this"></a>1. this</h5><p><code>this</code> 关键字是一个引用变量，它<strong>指向当前正在执行方法的对象实例</strong>。</p>
<p><strong>a. 解决实例变量与局部变量的命名冲突（最常见用途）</strong></p>
<p>当方法的参数名或局部变量名与类的实例变量名相同时，使用 <code>this</code> 可以明确指定要访问的是实例变量，从而避免歧义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 实例变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法参数名与实例变量名相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// this.name 指的是实例变量，等号右边的 name 指的是参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 同上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>如果没有 <code>this</code>，<code>name = name</code> 这条语句实际上只是将参数 <code>name</code> 的值赋给它自己，实例变量 <code>name</code> 的值并未改变。</em></p>
<p><strong>b. 在类的内部调用当前对象的其他方法（通常可省略）</strong></p>
<p>虽然通常可以省略（因为编译器会默认加上），但显式地使用 <code>this.methodName()</code> 可以更清晰地表明调用的是当前对象的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Printing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPrint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.printStatus(); <span class="comment">// 显式使用this调用，等同于直接写 printStatus();</span></span><br><span class="line">        <span class="comment">// ... 其他打印逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>c. 在构造方法中调用同一个类的其他构造方法（<code>this()</code>）</strong></p>
<p>使用 <code>this()</code> 可以在一个构造方法中调用本类的另一个重载的构造方法。<strong>这必须作为构造方法的第一条语句出现</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造，调用有参构造并提供默认值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 调用下面的有参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>这样做的好处是避免了在多个构造方法中重复相同的初始化代码。</em></p>
<p><strong>d. 作为参数传递</strong></p>
<p>可以将当前对象作为参数传递给其他方法或构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ClassB b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前 ClassA 的对象传递给 ClassB 的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">ClassB</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ClassA a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassB</span><span class="params">(ClassA a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-super"><a href="#2-super" class="headerlink" title="2. super"></a>2. super</h5><p><code>super</code> 关键字是一个引用变量，用于<strong>引用直接父类对象</strong>。它主要用于在子类中访问被隐藏或重写的父类成员。</p>
<p><strong>a. 调用父类的构造方法（<code>super()</code>）</strong></p>
<p>在子类的构造方法中，<strong>必须</strong>调用父类的某个构造方法。如果子类构造方法没有显式地使用 <code>super(...)</code> 来调用特定的父类构造方法，编译器会自动插入一个无参的 <code>super()</code>。</p>
<ul>
<li><code>super()</code> 调用也必须放在子类构造方法的<strong>第一行</strong>。</li>
<li><code>this()</code> 和 <code>super()</code> 不能同时存在于同一个构造方法中，因为它们都要求是第一行语句。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, String breed)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 必须放在第一行，调用父类有参构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.breed = breed; <span class="comment">// 然后初始化子类自己的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>b. 访问父类被隐藏的成员变量</strong></p>
<p>如果子类声明了与父类同名的成员变量（不推荐这样做），则父类的变量被“隐藏”。可以使用 <code>super.variableName</code> 来访问父类的版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello from Parent&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello from Child&quot;</span>; <span class="comment">// 隐藏了父类的 message</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessages</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.message); <span class="comment">// 输出: Hello from Parent</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.message);  <span class="comment">// 输出: Hello from Child</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>c. 调用父类被重写的方法</strong></p>
<p>当子类重写了父类的方法后，如果还想在子类内部调用父类该方法的原始实现，就需要使用 <code>super.methodName()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vehicle is starting...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.start(); <span class="comment">// 先调用父类的start方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Car is starting its engine...&quot;</span>); <span class="comment">// 再添加子类特有的行为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>这是一种非常常见的模式，用于扩展而非完全替代父类的功能。</em></p>
<hr>
<h4 id="3-2-2-static"><a href="#3-2-2-static" class="headerlink" title="3.2.2 static"></a>3.2.2 static</h4><p><code>static</code> 关键字的核心含义是 <strong>“静态的”</strong> 或 <strong>“与类相关的，而非与实例相关的”</strong>。</p>
<h5 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><ul>
<li>被 <code>static</code> 修饰的成员（变量、方法、代码块、内部类）属于<strong>类本身</strong>，而不是属于类的某个实例对象。</li>
<li>它是在<strong>类加载过程</strong>（JVM 将类的字节码加载到内存时）中被创建和初始化的。它在内存中只有一份副本，被所有该类的实例所共享。</li>
<li>正因为不依赖于实例，所以<strong>静态成员不能直接访问非静态成员</strong>（因为非静态成员属于实例，此时实例可能还未创建）。反之，非静态成员可以直接访问静态成员。</li>
</ul>
<hr>
<h5 id="2-主要用途"><a href="#2-主要用途" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h5><p><strong>a. 静态变量（类变量）</strong></p>
<ul>
<li><p><strong>定义</strong>：使用 <code>static</code> 修饰的变量。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>内存中只有一个副本，无论创建多少个对象。</li>
<li>当且仅当类初次加载时被初始化一次。</li>
<li>可以通过 <code>ClassName.variableName</code> 直接访问（推荐），也可以通过对象实例访问（不推荐）。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：用于需要被所有实例共享的数据，例如计数器、配置参数、常量池等。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 静态变量，用于分配唯一ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId++; <span class="comment">// 所有Employee对象共享并修改同一个nextId</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>b. 静态方法（类方法）</strong></p>
<ul>
<li><p><strong>定义</strong>：使用 <code>static</code> 修饰的方法。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>不能使用 <code>this</code> 和 <code>super</code> 关键字（因为它们与实例相关）。</li>
<li><strong>不能直接访问类的非静态变量和非静态方法</strong>（因为非静态成员需要先有实例才能存在）。</li>
<li>可以通过 <code>ClassName.methodName()</code> 直接调用。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>工具类方法（如 <code>Math.sqrt()</code>, <code>Arrays.sort()</code>），这些方法的执行不依赖于任何对象状态。</li>
<li>工厂方法，用于创建对象实例。</li>
<li><code>main</code> 方法是程序入口，必须是静态的。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">calculateCircleArea</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius; <span class="comment">// 不依赖任何实例状态，只依赖于输入参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用：double area = MathUtils.calculateCircleArea(5.0);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>c. 静态代码块</strong></p>
<ul>
<li><p><strong>定义</strong>：使用 <code>static</code> 修饰的代码块。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>在<strong>类被加载时</strong>执行，且<strong>只执行一次</strong>。</li>
<li>执行顺序优先于实例代码块和构造方法。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：用于初始化静态变量，或者执行只需要进行一次的复杂操作（例如加载本地库）。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">// 静态代码块，类加载时执行</span></span><br><span class="line">        props = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Files.newInputStream(Paths.get(<span class="string">&quot;db.config&quot;</span>))) &#123;</span><br><span class="line">            props.load(is); <span class="comment">// 初始化静态变量props</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to load config&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>d. 静态内部类</strong></p>
<ul>
<li><p><strong>定义</strong>：使用 <code>static</code> 修饰的内部类（嵌套类）。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>它不持有外部类的引用（与普通内部类最大的区别），因此它<strong>不能直接访问外部类的非静态成员</strong>。</li>
<li>创建静态内部类对象不需要先创建外部类对象：<code>new OuterClass.StaticNestedClass()</code>。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：当内部类不需要访问外部类实例时，应该优先使用静态内部类，因为它更节省内存（没有隐含的对外部类实例的引用）。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;Static Field&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">instanceField</span> <span class="operator">=</span> <span class="string">&quot;Instance Field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNestedClass</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">accessFields</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(staticField); <span class="comment">// 可以访问外部类的静态成员</span></span><br><span class="line">            <span class="comment">// System.out.println(instanceField); // 编译错误！不能访问外部类的非静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象：Outer.StaticNestedClass nested = new Outer.StaticNestedClass();</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-3-final"><a href="#3-2-3-final" class="headerlink" title="3.2.3 final"></a>3.2.3 final</h4><p><code>final</code> 关键字的核心含义是 <strong>“不可改变的”</strong>。</p>
<h5 id="1-核心思想-1"><a href="#1-核心思想-1" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p>它可以修饰类、方法、变量，含义略有不同，但核心都是表示“最终形态”，无法被继承、重写或修改。</p>
<h5 id="2-主要用途-1"><a href="#2-主要用途-1" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h5><p><strong>a. final 变量（常量）</strong></p>
<ul>
<li><p><strong>定义</strong>：一旦被赋值，其值就不能再被修改。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>如果是基本类型，值不能变。</li>
<li>如果是<strong>对象引用</strong>，<strong>引用不能变</strong>（即不能再指向另一个对象），但<strong>对象内部的状态是可以改变的</strong>（除非对象本身也是不可变对象，如 <code>String</code>）。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：用于定义常量。</p>
</li>
<li><p><strong>规范</strong>：常量名通常全部大写，单词间用下划线分隔。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>; <span class="comment">// 基本类型，值不可变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; NAMES = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 引用类型，引用不可变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// NAMES = new ArrayList&lt;&gt;(); // 编译错误！不能修改final引用</span></span><br><span class="line">        NAMES.add(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 可以！修改的是对象内部的状态，引用本身没变</span></span><br><span class="line">        NAMES.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>b. final 方法</strong></p>
<ul>
<li><p><strong>定义</strong>：被 <code>final</code> 修饰的方法。</p>
</li>
<li><p><strong>特点</strong>：<strong>不能被子类重写 (Override)</strong>。</p>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>防止子类改变方法的实现，确保方法的行为在继承体系中保持不变。</li>
<li>早期Java版本中，用于内联优化（现代JVM已经很智能，此作用已减弱）。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">secureMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这个方法很重要，不允许子类修改其实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;This is a critical operation.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// @Override // 编译错误！不能重写final方法</span></span><br><span class="line">    <span class="comment">// public void secureMethod() &#123; ... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>c. final 类</strong></p>
<ul>
<li><p><strong>定义</strong>：被 <code>final</code> 修饰的类。</p>
</li>
<li><p><strong>特点</strong>：<strong>不能被继承</strong>，即不能有子类。</p>
</li>
<li><p><strong>使用场景</strong>：保证类的安全性和不变性，防止他人通过继承来修改其行为。Java 标准库中的 <code>String</code>, <code>Integer</code> 等包装类都是 <code>final</code> 的。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImmutableClass</span> &#123; <span class="comment">// 这个类是最终的，不能被继承</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImmutableClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class SubClass extends ImmutableClass &#123; &#125; // 编译错误！</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-4-static与final组合使用"><a href="#3-2-4-static与final组合使用" class="headerlink" title="3.2.4 static与final组合使用"></a>3.2.4 static与final组合使用</h4><p><code>static</code> 和 <code>final</code> 经常一起使用，用来定义<strong>全局常量</strong>。</p>
<ul>
<li><code>static</code>：强调这个变量属于类，只有一份，不需要创建对象就能访问。</li>
<li><code>final</code>：强调这个变量的值不可改变。</li>
</ul>
<p>它们的组合完美地定义了程序中的常量。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConstants</span> &#123;</span><br><span class="line">    <span class="comment">// 类常量，全局唯一且不可修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APPLICATION_NAME</span> <span class="operator">=</span> <span class="string">&quot;My Awesome App&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">VERSION</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> MAX_CONNECTIONS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 也可以通过静态代码块为复杂的静态final常量赋值</span></span><br><span class="line">        MAX_CONNECTIONS = initializeMaxConnectionsFromConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">initializeMaxConnectionsFromConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 从配置文件读取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时直接通过类名访问：<code>String appName = AppConstants.APPLICATION_NAME;</code></p>
<hr>
<h3 id="3-3-包"><a href="#3-3-包" class="headerlink" title="3.3 包"></a>3.3 包</h3><h4 id="3-3-1-核心概念与作用"><a href="#3-3-1-核心概念与作用" class="headerlink" title="3.3.1 核心概念与作用"></a>3.3.1 核心概念与作用</h4><h5 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><p>包本质上就是<strong>文件系统中的文件夹</strong>。它是一种用于<strong>组织和管理 Java 类与接口</strong>的命名空间机制。它将功能相似或相关的类集合在一起，形成一个逻辑单元。</p>
<hr>
<h5 id="2-核心作用"><a href="#2-核心作用" class="headerlink" title="2. 核心作用"></a>2. 核心作用</h5><p>包的出现主要为了解决以下几个问题：</p>
<ol>
<li><strong>避免命名冲突（Namespace Management）</strong>：这是最核心的作用。全世界那么多开发者，难免会写出同名的类。包提供了唯一的命名空间，只要包名不同，即使类名相同，也被视为不同的类。<ul>
<li>例如：<code>java.util.Date</code> 和 <code>java.sql.Date</code> 是两个完全不同的类。</li>
</ul>
</li>
<li><strong>提高可维护性和可读性</strong>：将成千上万个类分门别类地放在不同的包中，结构清晰，便于查找和管理。就像你不会把所有的文件都放在桌面上，而是会建立不同的文件夹来分类存放。</li>
<li><strong>提供访问控制</strong>：包与访问权限修饰符相结合，可以定义类、接口、变量和方法的可见性，从而实现封装。我们熟知的<code>protected</code>和<strong>默认（包级私有）</strong> 权限都直接与包相关。</li>
</ol>
<hr>
<h4 id="3-3-2-包的定义与命名规则"><a href="#3-3-2-包的定义与命名规则" class="headerlink" title="3.3.2 包的定义与命名规则"></a>3.3.2 包的定义与命名规则</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h5><p>在 Java 源文件（.java）的<strong>第一行（必须是第一行，注释除外）</strong> 使用 <code>package</code> 关键字来声明该文件中所有类所属的包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径: com/companyname/utils/StringUtil.java</span></span><br><span class="line"><span class="keyword">package</span> com.companyname.utils; <span class="comment">// 包声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtil</span> &#123;</span><br><span class="line">    <span class="comment">// 类的代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译后，<code>StringUtil.class</code> 文件必须位于 <code>com/companyname/utils/</code> 目录下。</li>
<li>一个文件中最多只能有一个 <code>package</code> 语句。</li>
<li>如果没有指定 <code>package</code>，则该文件中的类属于<strong>无名包（unnamed package）</strong> 或默认包。这在小型测试程序中很常见，但在正式项目中<strong>强烈不推荐</strong>使用。</li>
</ul>
<hr>
<h5 id="2-规则与约定"><a href="#2-规则与约定" class="headerlink" title="2. 规则与约定"></a>2. 规则与约定</h5><p>包名是类全限定名（Fully Qualified Name）的重要组成部分。其命名遵循以下规范：</p>
<ul>
<li><strong>全部使用小写字母</strong>。</li>
<li><strong>采用反转的互联网域名（Reverse Domain Name）作为前缀</strong>：这是行业通用标准，能极大程度地保证全球唯一性。<ul>
<li>例如，如果你的公司域名是 <code>google.com</code>，那么你的包前缀就应该是 <code>com.google</code>。</li>
</ul>
</li>
<li><strong>后续部分根据项目、模块、功能进行划分</strong>：在域名后缀之后，根据项目的具体结构来定义。<ul>
<li>例如：<code>com.google.gson</code> (Gson 库), <code>org.springframework.boot</code> (Spring Boot 模块)。</li>
</ul>
</li>
<li><strong>使用点号 <code>.</code> 分隔</strong>，点号对应文件系统的目录层级。</li>
<li>不能使用 Java 保留字（如 <code>int</code>, <code>class</code>等）。</li>
</ul>
<hr>
<h4 id="3-3-3-包与作用域"><a href="#3-3-3-包与作用域" class="headerlink" title="3.3.3 包与作用域"></a>3.3.3 包与作用域</h4><p>Java 的四个访问权限修饰符中，有两个与包密切相关：</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="center">同类</th>
<th align="center">同包</th>
<th align="center">子类</th>
<th align="center">不同包</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>private</code></td>
<td align="center">可以访问</td>
<td align="center">不可</td>
<td align="center">不可</td>
<td align="center">不可</td>
<td>仅本类可见</td>
</tr>
<tr>
<td align="left"><strong>默认（无修饰符）</strong></td>
<td align="center">可以访问</td>
<td align="center">可以访问</td>
<td align="center">不可</td>
<td align="center">不可</td>
<td><strong>包级私有（Package-Private）</strong>，同包下的类可以访问</td>
</tr>
<tr>
<td align="left"><code>protected</code></td>
<td align="center">可以访问</td>
<td align="center">可以访问</td>
<td align="center">可以访问</td>
<td align="center">不可</td>
<td>同包和不同包的子类可以访问</td>
</tr>
<tr>
<td align="left"><code>public</code></td>
<td align="center">可以访问</td>
<td align="center">可以访问</td>
<td align="center">可以访问</td>
<td align="center">可以访问</td>
<td>完全公开</td>
</tr>
</tbody></table>
<p><strong>重点理解“默认”权限（包级私有）：</strong></p>
<ul>
<li>如果一个类、方法或变量没有指定任何访问修饰符，它就拥有“默认”权限。</li>
<li>这意味着，<strong>只有在同一个包下的其他类才能访问它</strong>。不同包下的类，即使是其子类，也无法访问。</li>
<li><strong>这是实现包内封装的关键机制</strong>。你可以将只希望在包内部使用的工具类、共享逻辑设置为包级私有，从而对外部隐藏实现细节。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件: com/utils/Logger.java</span></span><br><span class="line"><span class="keyword">package</span> com.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123; <span class="comment">// 注意：没有 public 修饰符，是包级私有的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[LOG] &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件: com/utils/StringUtil.java</span></span><br><span class="line"><span class="keyword">package</span> com.utils; <span class="comment">// 同一个包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        Logger.log(<span class="string">&quot;Something happened!&quot;</span>); <span class="comment">// 可以访问，因为它们在同一个包下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件: com/app/Main.java</span></span><br><span class="line"><span class="keyword">package</span> com.app; <span class="comment">// 不同的包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.StringUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StringUtil</span>().doSomething();</span><br><span class="line">        <span class="comment">// Logger.log(&quot;Hello&quot;); // 编译错误！Logger 在 com.utils 包中是包级私有的，Main 在 com.app 包中无法访问。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-4-导入"><a href="#3-3-4-导入" class="headerlink" title="3.3.4 导入"></a>3.3.4 导入</h4><p>为了不在代码中每次都写类的全限定名（如 <code>java.util.List</code>），我们可以使用 <code>import</code> 语句。</p>
<h5 id="1-导入单个类"><a href="#1-导入单个类" class="headerlink" title="1. 导入单个类"></a>1. 导入单个类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 导入 ArrayList 类</span></span><br><span class="line"><span class="keyword">import</span> java.io.File;        <span class="comment">// 导入 File 类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 现在可以直接使用类名</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-导入整个包"><a href="#2-导入整个包" class="headerlink" title="2. 导入整个包"></a>2. 导入整个包</h5><p>使用通配符 <code>*</code> 可以导入一个包下的所有<strong>公共类</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">// 导入 java.util 包下的所有公共类（如 ArrayList, HashMap, Scanner等）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：不会导入子包中的类！例如 ‘java.util.concurrent’ 下的类不会被导入。</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-静态导入"><a href="#3-静态导入" class="headerlink" title="3. 静态导入"></a>3. 静态导入</h5><p>用于导入类的<strong>静态成员（静态变量和静态方法）</strong>，之后可以直接使用静态成员名，而不用加类名前缀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI;    <span class="comment">// 导入静态变量 PI</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.pow;   <span class="comment">// 导入静态方法 pow</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out; <span class="comment">// 导入静态变量 out</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PI * pow(radius, <span class="number">2</span>); <span class="comment">// 直接使用 PI 和 pow，无需 Math.PI 和 Math.pow</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        out.println(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 直接使用 out，无需 System.out</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>谨慎使用</strong>：过度使用静态导入会使代码难以阅读，因为读者无法一眼看出静态成员来自哪个类。</p>
<hr>
<h5 id="4-导入规则与注意点"><a href="#4-导入规则与注意点" class="headerlink" title="4.导入规则与注意点"></a>4.导入规则与注意点</h5><ul>
<li><p><code>import</code> 语句位于 <code>package</code> 语句之后，类声明之前。</p>
</li>
<li><p><strong>不需要显式导入的类</strong>：</p>
<ul>
<li>同一个包下的其他类。</li>
<li><code>java.lang</code> 包下的所有类（如 <code>String</code>, <code>System</code>, <code>Object</code> 等），这是由编译器自动导入的。</li>
</ul>
</li>
<li><p>如果使用了两个 不同包中同名的类（例如 <code>java.sql.Date</code> 和 <code>java.util.Date</code>），就不能使用通配符导入，必须使用<strong>单类型导入</strong>，或者在代码中<strong>直接使用全限定名</strong>来避免冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">// import java.sql.Date; // 不能再导入另一个Date</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">utilDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 指向 java.util.Date</span></span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">sqlDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(...); <span class="comment">// 必须使用全限定名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-3-5-最佳实践"><a href="#3-3-5-最佳实践" class="headerlink" title="3.3.5 最佳实践"></a>3.3.5 最佳实践</h4><ol>
<li><strong>始终使用包，杜绝默认包</strong>：即使是再小的项目或 demo，也应建立一个有意义的包名（如 <code>com.example.demo</code>）。使用默认包会导致类无法被其他包导入，且容易引发命名冲突。</li>
<li><strong>遵循反转域名约定</strong>：这是 Java 世界的通用语言，能有效避免冲突，并让其他开发者一眼看出代码的来源或所属组织。</li>
<li><strong>包名要有意义，按模块&#x2F;功能划分</strong>：<ul>
<li><code>com.companyname.projectname.model</code> （数据模型）</li>
<li><code>com.companyname.projectname.dao</code> 或 <code>repository</code> （数据访问层）</li>
<li><code>com.companyname.projectname.service</code> （业务逻辑层）</li>
<li><code>com.companyname.projectname.controller</code> （Web控制层）</li>
<li><code>com.companyname.projectname.utils</code> （工具类）</li>
</ul>
</li>
<li><strong>合理使用访问控制符，强化封装</strong>：<ul>
<li>思考“这个类&#x2F;方法真的需要是 <code>public</code> 的吗？”</li>
<li>优先使用<strong>包级私有（无修饰符）</strong> 来隐藏那些只在包内部使用的实现细节。这是设计良好 API 的关键。</li>
</ul>
</li>
<li><strong>明智地选择导入方式</strong>：<ul>
<li>优先使用<strong>单类型导入</strong>（<code>import java.util.ArrayList;</code>），而不是通配符导入（<code>import java.util.*;</code>）。这让代码的依赖关系非常清晰，读者能确切知道使用了哪些类。现代的 IDE 可以自动管理这些导入。</li>
<li><strong>静态导入</strong>应仅用于非常常用且不会引起混淆的静态成员（如 <code>JUnit</code> 的 <code>Assert</code> 方法，<code>Math</code> 的 <code>PI</code>）。</li>
</ul>
</li>
<li><strong>包与物理目录结构严格匹配</strong>：这是 Java 语言的强制要求。包名 <code>com.example.utils</code> 必须对应文件系统中的 <code>com/example/utils</code> 目录。构建工具（Maven&#x2F;Gradle）和 IDE 都遵循并强制这一约定。</li>
</ol>
<hr>
<hr>
<h2 id="4-高级特性和设计模式初探"><a href="#4-高级特性和设计模式初探" class="headerlink" title="4. 高级特性和设计模式初探"></a>4. 高级特性和设计模式初探</h2><h3 id="4-1-Object类"><a href="#4-1-Object类" class="headerlink" title="4.1 Object类"></a>4.1 Object类</h3><h4 id="4-1-1-概述"><a href="#4-1-1-概述" class="headerlink" title="4.1.1 概述"></a>4.1.1 概述</h4><p><code>java.lang.Object</code>类是Java中所有类的<strong>根类</strong>，即所有类都直接或间接地继承自<code>Object</code>类。如果一个类没有使用<code>extends</code>关键字明确指定父类，那么它会<strong>默认继承</strong><code>Object</code>类。</p>
<p>这意味着，你定义的任何一个类，无论是简单的POJO、数组，还是复杂的业务类，都拥有<code>Object</code>类中定义的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两种写法是等价的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-2-主要方法"><a href="#4-1-2-主要方法" class="headerlink" title="4.1.2 主要方法"></a>4.1.2 主要方法</h4><h5 id="1-toString-方法"><a href="#1-toString-方法" class="headerlink" title="1. toString()方法"></a>1. <code>toString()</code>方法</h5><ul>
<li><strong>作用</strong>：返回该对象的字符串表示。这是一个非常重要的方法，主要用于<strong>日志打印</strong>和<strong>调试</strong>，以便于阅读对象的信息。</li>
<li><strong>默认实现</strong>：<code>Object</code>类的默认实现返回的字符串由三部分组成：<code>类名 + @ + 对象的哈希码的无符号十六进制表示</code>。<ul>
<li>例如：<code>com.example.MyClass@1b6d3586</code></li>
</ul>
</li>
<li><strong>重写建议</strong>：<strong>强烈建议重写此方法</strong>，返回一个包含对象有意义信息的、简洁且易于阅读的字符串。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-equals-Object-obj-方法"><a href="#2-equals-Object-obj-方法" class="headerlink" title="2. equals(Object obj)方法"></a>2. <code>equals(Object obj)</code>方法</h5><ul>
<li><strong>作用</strong>：指示<strong>其他某个对象是否与此对象“相等”</strong>。用于判断两个对象在逻辑上是否等价。</li>
<li><strong>默认实现</strong>：默认使用<code>==</code>操作符进行比较，即只判断两个<strong>引用是否指向堆内存中的同一个对象</strong>（判断的是对象地址是否相同）。</li>
<li><strong>重写建议</strong>：当你需要根据对象的<strong>内容</strong>（即字段的值）而不是内存地址来判断相等性时，必须重写此方法。</li>
<li><strong>重写<code>equals()</code>必须遵守的通用约定</strong>：<ol>
<li><strong>自反性</strong>：<code>x.equals(x)</code>必须返回<code>true</code>。</li>
<li><strong>对称性</strong>：如果<code>x.equals(y)</code>为<code>true</code>，那么<code>y.equals(x)</code>也必须为<code>true</code>。</li>
<li><strong>传递性</strong>：如果<code>x.equals(y)</code>为<code>true</code>，且<code>y.equals(z)</code>为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>。</li>
<li><strong>一致性</strong>：只要对象没有被修改，多次调用<code>x.equals(y)</code>应该一直返回相同的结果。</li>
<li><strong>非空性</strong>：<code>x.equals(null)</code>必须返回<code>false</code>。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="3-hashCode-方法"><a href="#3-hashCode-方法" class="headerlink" title="3. hashCode()方法"></a>3. <code>hashCode()</code>方法</h5><ul>
<li><strong>作用</strong>：返回对象的<strong>哈希码值</strong>（一个<code>int</code>类型的整数）。这个方法主要用于支持基于哈希表的集合，如<code>HashMap</code>, <code>HashSet</code>, <code>Hashtable</code>等。</li>
<li><strong>与<code>equals()</code>方法的重写关系</strong>：这是一个<strong>极其重要</strong>的规则！<ul>
<li><strong>规则1</strong>：如果两个对象根据<code>equals(Object)</code>方法是相等的，那么对这两个对象中的每个对象调用<code>hashCode</code>方法都必须生成<strong>相同的</strong>整数结果。</li>
<li><strong>规则2</strong>：如果两个对象根据<code>equals(Object)</code>方法是不相等的，并不要求它们调用<code>hashCode</code>必须产生不同的结果。但是，<strong>为不相等的对象生成不同的哈希码可以提高哈希表的性能</strong>。</li>
</ul>
</li>
<li><strong>为什么有这个规则？</strong> 哈希表（如<code>HashMap</code>）通过哈希码来快速定位对象存储的“桶”（bucket）。如果两个相等的对象有不同的哈希码，它们可能会被放到不同的桶里，导致<code>HashMap</code>无法正常工作（例如，用<code>equals</code>认为相同的key却找不到对应的value）。</li>
</ul>
<p><strong>结论：只要你重写了<code>equals()</code>方法，就必须同时重写<code>hashCode()</code>方法</strong>，以确保上述规则得以遵守。</p>
<hr>
<h5 id="4-getClass-方法"><a href="#4-getClass-方法" class="headerlink" title="4. getClass()方法"></a>4. <code>getClass()</code>方法</h5><ul>
<li><strong>作用</strong>：返回此对象的<strong>运行时类</strong>（Runtime Class）。这是一个<code>final</code>方法，不能被重写。</li>
<li><strong>用途</strong>：通过返回的<code>Class</code>对象，你可以获取类的元信息，如类名、方法、字段等。它通常用于<strong>反射</strong>机制。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass(); <span class="comment">// 返回的是java.lang.String类对象</span></span><br><span class="line">System.out.println(clazz.getName()); <span class="comment">// 输出 &quot;java.lang.String&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-clone-方法"><a href="#5-clone-方法" class="headerlink" title="5. clone()方法"></a>5. <code>clone()</code>方法</h5><ul>
<li><strong>作用</strong>：创建并返回此对象的一个<strong>副本</strong>。“副本”的准确含义取决于该对象的类本身，通常的意图是：对于任何对象<code>x</code>，表达式<code>x.clone() != x</code>为真，且<code>x.clone().getClass() == x.getClass()</code>也为真（但这些不是绝对要求）。</li>
<li><strong>使用限制</strong>：要使用<code>clone()</code>方法，对象的类必须<strong>实现<code>Cloneable</code>接口</strong>。这是一个标记接口（没有任何方法），仅仅表示该类允许被克隆。如果没有实现该接口就调用<code>clone()</code>，会抛出<code>CloneNotSupportedException</code>异常。</li>
<li><strong>深浅拷贝问题</strong>：<code>Object</code>类的<code>clone()</code>方法默认实现的是<strong>浅拷贝</strong>（shallow copy）。它复制对象的所有字段（基本类型拷贝值，引用类型拷贝引用地址）。如果对象包含可变对象的引用，浅拷贝可能会导致问题。如果需要<strong>深拷贝</strong>（deep copy），必须在重写的<code>clone()</code>方法中手动实现。</li>
</ul>
<hr>
<h5 id="6-finalize-方法"><a href="#6-finalize-方法" class="headerlink" title="6. finalize()方法"></a>6. <code>finalize()</code>方法</h5><ul>
<li><strong>作用</strong>：当垃圾回收器（Garbage Collector, GC）确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。它原本的设计目的是用于在对象被回收前执行一些资源释放操作（如关闭文件描述符）。</li>
<li><strong>重要说明</strong>：<strong>此方法已被弃用（deprecated），从Java 9开始标记为<code>@Deprecated</code>，不推荐使用</strong>。它的执行时机是不确定的，甚至不保证一定会被执行（如果程序终止，GC可能永远不会触发）。依赖<code>finalize()</code>来释放关键资源会导致严重的性能问题和资源泄漏。正确的做法是使用<code>try-with-resources</code>语句或显式调用<code>close()</code>方法来管理资源。</li>
</ul>
<hr>
<h5 id="7-多线程相关的方法：wait-notify-notifyAll"><a href="#7-多线程相关的方法：wait-notify-notifyAll" class="headerlink" title="7. 多线程相关的方法：wait(), notify(), notifyAll()"></a>7. 多线程相关的方法：<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code></h5><ul>
<li><strong>作用</strong>：这三个方法用于实现线程间的<strong>等待&#x2F;通知机制</strong>，是Java内置的、最基本的线程间通信方式。它们都是<code>final</code>方法，不能被重写。</li>
<li><strong>重要前提</strong>：这些方法的调用<strong>必须发生在该对象的同步代码块或同步方法中</strong>（即线程必须持有该对象的监视器锁，也称为 intrinsic lock），否则会抛出<code>IllegalMonitorStateException</code>异常。</li>
<li><code>wait()</code>：导致当前线程等待，直到其他线程调用该对象的<code>notify()</code>或<code>notifyAll()</code>方法，或者指定的时间超时。调用后，当前线程会<strong>释放持有的该对象锁</strong>。</li>
<li><code>notify()</code>：唤醒在此对象监视器上等待的<strong>单个</strong>线程。选择是任意性的。</li>
<li><code>notifyAll()</code>：唤醒在此对象监视器上等待的<strong>所有</strong>线程。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：在现代Java并发编程中，更推荐使用<code>java.util.concurrent</code>包（JUC）提供的更高级的同步工具（如<code>Lock</code>, <code>Condition</code>, <code>CountDownLatch</code>, <code>Semaphore</code>等），而不是使用这些底层的<code>wait()</code>&#x2F;<code>notify()</code>方法。</p>
</blockquote>
<hr>
<h4 id="4-1-3-最佳实践"><a href="#4-1-3-最佳实践" class="headerlink" title="4.1.3 最佳实践"></a>4.1.3 最佳实践</h4><ol>
<li><strong>总是重写<code>toString()</code></strong>：让你的对象在打印时更具可读性。</li>
<li><strong>谨慎重写<code>equals()</code>和<code>hashCode()</code></strong>：只有当需要基于内容进行相等性比较时才重写它们，并且一定要同时重写，遵守约定。IDE（如IntelliJ IDEA或Eclipse）通常可以自动生成高质量的实现。</li>
<li><strong>避免使用<code>finalize()</code>和<code>clone()</code></strong>：对于资源管理，使用<code>try-with-resources</code>；对于对象复制，考虑使用<strong>拷贝构造函数</strong>或<strong>静态工厂方法</strong>，它们比<code>clone()</code>更简单安全。</li>
</ol>
<hr>
<h3 id="4-2-内部类"><a href="#4-2-内部类" class="headerlink" title="4.2 内部类"></a>4.2 内部类</h3><p><strong>内部类是定义在另一个类内部的类</strong>。与之相对，普通的类可以称为“顶级类（Top-level Class）”。</p>
<p><strong>为什么需要内部类？</strong></p>
<ol>
<li><strong>增强封装性</strong>：可以将一个类深度隐藏在另一个类中，只为其外部类提供服务，而不被其他任何类访问。</li>
<li><strong>提高可读性和可维护性</strong>：将逻辑上属于同一组的类组织在一起，使得代码更紧凑。</li>
<li><strong>间接实现多重继承</strong>：每个内部类都可以独立地继承一个类或实现一个接口，这使得外部类实际上具备了多种能力，而避免了Java单继承的限制。</li>
<li><strong>轻松访问外部类的所有成员</strong>（包括私有成员）：这是内部类一个非常强大和方便的特性。</li>
</ol>
<hr>
<h4 id="4-2-1-成员内部类（Member-Inner-Class）"><a href="#4-2-1-成员内部类（Member-Inner-Class）" class="headerlink" title="4.2.1 成员内部类（Member Inner Class）"></a>4.2.1 成员内部类（Member Inner Class）</h4><p>这是最普通、最常见的内部类形式，类似于类的成员变量或方法。</p>
<h5 id="1-定义语法："><a href="#1-定义语法：" class="headerlink" title="1. 定义语法："></a>1. 定义语法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;      <span class="comment">// 外部类</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;  <span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-特点："><a href="#2-特点：" class="headerlink" title="2. 特点："></a>2. 特点：</h5><ul>
<li><strong>与实例绑定</strong>：成员内部类的实例<strong>必须</strong>依赖于一个外部类的实例才能存在。不能先创建一个内部类对象而不先创建其外部类对象。</li>
<li><strong>访问权限</strong>：内部类可以自由访问外部类的<strong>所有成员（字段和方法），包括 <code>private</code> 私有成员</strong>。这是因为内部类被看作外部类的一个特殊成员。</li>
<li><strong>外部类访问内部类</strong>：外部类要想访问内部类的成员，则<strong>必须创建内部类的对象</strong>，然后通过这个对象来访问。</li>
</ul>
<hr>
<h5 id="3-如何实例化？"><a href="#3-如何实例化？" class="headerlink" title="3. 如何实例化？"></a>3. 如何实例化？</h5><p>在外部类<strong>外部</strong>实例化成员内部类，语法有点特殊：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OuterClass</span> <span class="variable">outerObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">OuterClass.<span class="type">InnerClass</span> <span class="variable">innerObject</span> <span class="operator">=</span> outerObject.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-代码示例："><a href="#4-代码示例：" class="headerlink" title="4. 代码示例："></a>4. 代码示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">outerPrivateField</span> <span class="operator">=</span> <span class="string">&quot;Outer Private&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer Method&quot;</span>);</span><br><span class="line">        <span class="comment">// 外部类内部创建内部类对象</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 内部类可以直接访问外部类的私有成员</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Accessing from Inner: &quot;</span> + outerPrivateField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 先创建外部类对象</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 通过外部类对象来创建内部类对象</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"></span><br><span class="line">        inner.innerMethod(); <span class="comment">// 输出: Accessing from Inner: Outer Private</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也可以在外部类的方法内部创建，如 outerMethod() 中所示</span></span><br><span class="line">        outer.outerMethod();</span><br><span class="line">        <span class="comment">// 输出:</span></span><br><span class="line">        <span class="comment">// Outer Method</span></span><br><span class="line">        <span class="comment">// Accessing from Inner: Outer Private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-2-静态嵌套类（Static-Nested-Class）"><a href="#4-2-2-静态嵌套类（Static-Nested-Class）" class="headerlink" title="4.2.2 静态嵌套类（Static Nested Class）"></a>4.2.2 静态嵌套类（Static Nested Class）</h4><p>使用 <code>static</code> 修饰的内部类，它的行为更像一个独立的顶级类，只是被嵌套在了另一个类里面。</p>
<h5 id="1-定义语法：-1"><a href="#1-定义语法：-1" class="headerlink" title="1. 定义语法："></a>1. 定义语法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNestedClass</span> &#123; <span class="comment">// 静态嵌套类</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-特点：-1"><a href="#2-特点：-1" class="headerlink" title="2. 特点："></a>2. 特点：</h5><ul>
<li><strong>与类绑定</strong>：静态嵌套类<strong>不依赖于外部类的实例</strong>。你可以把它看作一个放在另一个类命名空间下的普通类。</li>
<li><strong>访问权限</strong>：静态嵌套类<strong>不能直接访问</strong>外部类的非静态成员（实例变量和方法），因为它没有对外部类实例的隐式引用。它只能访问外部类的静态成员。</li>
<li><strong>实例化方式</strong>：不需要外部类实例，直接 <code>new OuterClass.StaticNestedClass()</code>。</li>
</ul>
<hr>
<h5 id="3-代码示例："><a href="#3-代码示例：" class="headerlink" title="3. 代码示例："></a>3. 代码示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">instanceField</span> <span class="operator">=</span> <span class="string">&quot;Instance Field&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;Static Field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNested</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// System.out.println(instanceField); // 错误！不能访问非静态成员</span></span><br><span class="line">            System.out.println(staticField);      <span class="comment">// 正确！可以访问静态成员</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Static Nested Class Method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 无需外部类实例，直接创建</span></span><br><span class="line">        Outer.<span class="type">StaticNested</span> <span class="variable">nestedObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticNested();</span><br><span class="line">        nestedObj.method(); <span class="comment">// 输出: Static Field</span></span><br><span class="line">                            <span class="comment">//       Static Nested Class Method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-3-局部内部类（Local-Inner-Class）"><a href="#4-2-3-局部内部类（Local-Inner-Class）" class="headerlink" title="4.2.3 局部内部类（Local Inner Class）"></a>4.2.3 局部内部类（Local Inner Class）</h4><p>定义在<strong>方法</strong>或<strong>作用域块</strong>（如 <code>if</code> 块、<code>for</code> 循环内）内部的类。</p>
<h5 id="1-特点："><a href="#1-特点：" class="headerlink" title="1. 特点："></a>1. 特点：</h5><ul>
<li><strong>作用域受限</strong>：局部内部类只在定义它的方法或作用域块内可见，外界完全无法访问。</li>
<li><strong>访问外部变量</strong>：它可以访问外部类的成员。此外，从 <strong>Java 8 开始</strong>，它可以访问方法中的 <code>final</code> 或 <strong>有效最终（effectively final）</strong> 的局部变量（即变量初始化后值再未改变）。</li>
</ul>
<hr>
<h5 id="2-代码示例："><a href="#2-代码示例：" class="headerlink" title="2. 代码示例："></a>2. 代码示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">outerField</span> <span class="operator">=</span> <span class="string">&quot;Outer field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">localFinalVar</span> <span class="operator">=</span> <span class="string">&quot;Local Final&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">effectivelyFinalVar</span> <span class="operator">=</span> <span class="string">&quot;Effectively Final&quot;</span>; <span class="comment">// 值从未改变，也是有效的final</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInner</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(outerField);          <span class="comment">// 可以访问外部类字段</span></span><br><span class="line">                System.out.println(localFinalVar);       <span class="comment">// 可以访问final局部变量</span></span><br><span class="line">                System.out.println(effectivelyFinalVar); <span class="comment">// 可以访问有效最终变量</span></span><br><span class="line">                <span class="comment">// effectivelyFinalVar = &quot;changed&quot;;      // 错误！如果在内部类中修改，就不再是有效最终了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只能在方法内部实例化和使用</span></span><br><span class="line">        <span class="type">LocalInner</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInner</span>();</span><br><span class="line">        local.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-4-匿名内部类（Anonymous-Inner-Class）"><a href="#4-2-4-匿名内部类（Anonymous-Inner-Class）" class="headerlink" title="4.2.4 匿名内部类（Anonymous Inner Class）"></a>4.2.4 匿名内部类（Anonymous Inner Class）</h4><p>没有名字的局部内部类。它同时完成了<strong>类的定义</strong>和<strong>对象的实例化</strong>。常用于需要快速实现一个接口或继承一个类，但不想专门写一个类文件的场景。</p>
<h5 id="1-语法："><a href="#1-语法：" class="headerlink" title="1. 语法："></a>1. 语法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类构造器() &#123; 或 接口名() &#123; </span><br><span class="line">    <span class="comment">// 类体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-特点：-2"><a href="#2-特点：-2" class="headerlink" title="2. 特点："></a>2. 特点：</h5><ul>
<li><strong>没有名字</strong>：所以只能使用一次，用于创建一个对象。</li>
<li><strong>常用场景</strong>：<strong>事件监听</strong>、<strong>线程创建</strong>（<code>Runnable</code>）等。</li>
</ul>
<hr>
<h5 id="3-代码示例：-1"><a href="#3-代码示例：-1" class="headerlink" title="3. 代码示例："></a>3. 代码示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 实现一个接口的匿名内部类</span></span><br><span class="line">        <span class="type">Greeting</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>() &#123; <span class="comment">// 这里的 new 是创建接口的实现类对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello from Anonymous Class!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        greeting.greet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 继承一个类的匿名内部类</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123; <span class="comment">// 这里的 new 是创建Thread的子类对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread is running from Anonymous Class.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 更常见的写法：直接在方法参数中创建（例如创建Runnable）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Runnable from Anonymous Class.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：在Java 8+中，上述Runnable的用法通常被Lambda表达式取代：</span></span><br><span class="line">        <span class="comment">// new Thread(() -&gt; System.out.println(&quot;Runnable from Lambda.&quot;)).start();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-枚举类"><a href="#4-3-枚举类" class="headerlink" title="4.3 枚举类"></a>4.3 枚举类</h3><h4 id="4-3-1-传统的弊端"><a href="#4-3-1-传统的弊端" class="headerlink" title="4.3.1 传统的弊端"></a>4.3.1 传统的弊端</h4><p>在枚举出现之前，我们通常使用一系列 <code>static final</code> 常量来表示一组有限的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 古老的方式，存在诸多问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldStyle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATUS_OPEN</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATUS_CLOSE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATUS_PENDING</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line"><span class="type">OldStyle</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OldStyle</span>();</span><br><span class="line">obj.setStatus(OldStyle.STATUS_OPEN); <span class="comment">// 这样OK</span></span><br><span class="line">obj.setStatus(<span class="number">4</span>); <span class="comment">// 编译器不会报错，但逻辑上是错误的！这就是“类型不安全”</span></span><br><span class="line">obj.setStatus(<span class="number">99</span>); <span class="comment">// 甚至是一个毫无意义的数字，运行时可能才出错</span></span><br></pre></td></tr></table></figure>

<p><strong>传统方式的缺点：</strong></p>
<ol>
<li><strong>类型不安全</strong>：<code>setStatus</code> 方法接受任何 <code>int</code> 值，即使传入一个无效的值（如 99），编译器也无法检查。</li>
<li><strong>无命名空间</strong>：常量属于类，使用时需要带上类名前缀，略显冗长。</li>
<li><strong>脆弱性</strong>：如果常量值是整数，在调试时看到的只是一个数字，可读性差。</li>
<li><strong>功能单一</strong>：常量本身只是一个值，无法附加行为（方法）。</li>
</ol>
<hr>
<h4 id="4-3-2-枚举的基本语法和本质"><a href="#4-3-2-枚举的基本语法和本质" class="headerlink" title="4.3.2 枚举的基本语法和本质"></a>4.3.2 枚举的基本语法和本质</h4><h5 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h5><p>使用关键字 <code>enum</code> 来定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    OPEN,      <span class="comment">// 每个标识符都是一个枚举实例</span></span><br><span class="line">    CLOSE,     <span class="comment">// 注意：使用逗号分隔</span></span><br><span class="line">    PENDING    <span class="comment">// 最后一个可以带分号，也可以不带（如果后面没有其他代码）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-本质"><a href="#2-本质" class="headerlink" title="2. 本质"></a>2. 本质</h5><p><strong>枚举的本质是一个继承自 <code>java.lang.Enum</code> 的类</strong>。上面的 <code>Status</code> 枚举编译后，大致相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是JVM和编译器帮我们完成的，我们不能手动这样写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Status</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Status&gt; &#123;</span><br><span class="line">    <span class="comment">// 在类内部预先创建好的几个公共静态常量实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Status</span> <span class="variable">OPEN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Status</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Status</span> <span class="variable">CLOSE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Status</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Status</span> <span class="variable">PENDING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Status</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造器，防止外部new操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Status</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他由Enum类继承来的方法，如values(), valueOf()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个角度看，枚举的每个常量（<code>OPEN</code>, <code>CLOSE</code>）都是该枚举类型的一个<strong>单例对象</strong>。</p>
<hr>
<h4 id="4-3-3-枚举的常用方法"><a href="#4-3-3-枚举的常用方法" class="headerlink" title="4.3.3 枚举的常用方法"></a>4.3.3 枚举的常用方法</h4><p>由于所有枚举都隐式继承自 <code>Enum</code> 类，所以它们自动拥有以下方法：</p>
<ol>
<li><code>name()</code>: 返回枚举常量的名称（String），与声明时完全一致。<strong>通常是首字母大写的单词</strong>。它是 <code>final</code> 的，不能被重写。</li>
<li><code>ordinal()</code>: 返回枚举常量的序数（int），即它在枚举声明中的位置（从 0 开始）。<strong>不建议在业务代码中依赖此值</strong>，因为它的值会随着枚举声明的顺序改变而改变。</li>
<li><code>values()</code>: 是一个静态方法，由编译器生成，返回包含该枚举所有常量的数组（<code>Status[]</code>）。</li>
<li><code>valueOf(String name)</code>: 也是一个静态方法，根据给定的名称字符串返回对应的枚举常量。如果名称不存在，会抛出 <code>IllegalArgumentException</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Status</span> <span class="variable">currentStatus</span> <span class="operator">=</span> Status.OPEN;</span><br><span class="line"></span><br><span class="line">System.out.println(currentStatus.name());      <span class="comment">// 输出: &quot;OPEN&quot;</span></span><br><span class="line">System.out.println(currentStatus.ordinal());   <span class="comment">// 输出: 0</span></span><br><span class="line"></span><br><span class="line">Status[] allStatuses = Status.values();        <span class="comment">// 返回 [OPEN, CLOSE, PENDING]</span></span><br><span class="line"><span class="type">Status</span> <span class="variable">s</span> <span class="operator">=</span> Status.valueOf(<span class="string">&quot;CLOSE&quot;</span>);            <span class="comment">// 返回 Status.CLOSE 对象</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-4-枚举的高级用法"><a href="#4-3-4-枚举的高级用法" class="headerlink" title="4.3.4 枚举的高级用法"></a>4.3.4 枚举的高级用法</h4><p>枚举远不止是常量列表，它可以像普通类一样拥有字段、构造器、方法，甚至实现接口。</p>
<h5 id="1-添加字段和自定义构造器"><a href="#1-添加字段和自定义构造器" class="headerlink" title="1. 添加字段和自定义构造器"></a>1. 添加字段和自定义构造器</h5><p>你可以为每个枚举常量附加额外的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Planet</span> &#123;</span><br><span class="line">    <span class="comment">// 调用带参数的构造器</span></span><br><span class="line">    MERCURY(<span class="number">3.303e+23</span>, <span class="number">2.4397e6</span>),</span><br><span class="line">    VENUS(<span class="number">4.869e+24</span>, <span class="number">6.0518e6</span>),</span><br><span class="line">    EARTH(<span class="number">5.976e+24</span>, <span class="number">6.37814e6</span>),</span><br><span class="line">    MARS(<span class="number">6.421e+23</span>, <span class="number">3.3972e6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字段 (final, 因为枚举常量是 immutable 的更安全)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> mass;   <span class="comment">// in kilograms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> radius; <span class="comment">// in meters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造器（枚举的构造器只能是 private，可省略不写）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Planet</span><span class="params">(<span class="type">double</span> mass, <span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mass = mass;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMass</span><span class="params">()</span> &#123; <span class="keyword">return</span> mass; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span> &#123; <span class="keyword">return</span> radius; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 甚至可以计算星球表面的重力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSurfaceGravity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">double</span> <span class="variable">G</span> <span class="operator">=</span> <span class="number">6.67300E-11</span>; <span class="comment">// 万有引力常数</span></span><br><span class="line">        <span class="keyword">return</span> G * mass / (radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据体重计算在不同星球上的重量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSurfaceWeight</span><span class="params">(<span class="type">double</span> otherMass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> otherMass * getSurfaceGravity();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Planet</span> <span class="variable">earth</span> <span class="operator">=</span> Planet.EARTH;</span><br><span class="line"><span class="type">double</span> <span class="variable">myWeightOnEarth</span> <span class="operator">=</span> earth.getSurfaceWeight(<span class="number">80</span>); <span class="comment">// 计算80kg在地球上的重量</span></span><br><span class="line">System.out.println(myWeightOnEarth);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-为每个常量添加特定行为（抽象方法）"><a href="#2-为每个常量添加特定行为（抽象方法）" class="headerlink" title="2. 为每个常量添加特定行为（抽象方法）"></a>2. 为每个常量添加特定行为（抽象方法）</h5><p>你可以定义一个抽象方法，然后让每个枚举常量都实现它。这是枚举最强大的特性之一，常用于实现<strong>状态模式</strong>或<strong>策略模式</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="comment">// 每个常量都实现了apply方法</span></span><br><span class="line">    PLUS &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个抽象方法，强制每个常量都实现它</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Operation</span> <span class="variable">op</span> <span class="operator">=</span> Operation.PLUS;</span><br><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> op.apply(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// result = 8.0</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-实现接口"><a href="#3-实现接口" class="headerlink" title="3. 实现接口"></a>3. 实现接口</h5><p>枚举可以实现一个或多个接口，为所有常量提供统一的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">FileCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    OPEN &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Opening file...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SAVE &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Saving file...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 实现了Command接口的execute方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-5-经典应用场景"><a href="#4-3-5-经典应用场景" class="headerlink" title="4.3.5 经典应用场景"></a>4.3.5 经典应用场景</h4><ol>
<li><p><strong>替代常量</strong>：最基础的用法，如状态、类型、模式等。</p>
</li>
<li><p><strong>单例模式（Singleton）</strong>：这是实现单例的最佳方式，绝对防止多实例化，且提供序列化机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE; <span class="comment">// 唯一的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加你自己的方法和字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>状态机</strong>：如订单状态（<code>NEW</code>, <code>PAID</code>, <code>SHIPPED</code>, <code>COMPLETED</code>），每个状态可以有不同的行为。</p>
</li>
<li><p><strong>策略模式</strong>：如上文的 <code>Operation</code> 例子，每个枚举常量代表一种策略。</p>
</li>
</ol>
<hr>
<h3 id="4-4-注解"><a href="#4-4-注解" class="headerlink" title="4.4 注解"></a>4.4 注解</h3><h4 id="4-4-1-概念"><a href="#4-4-1-概念" class="headerlink" title="4.4.1 概念"></a>4.4.1 概念</h4><p><strong>注解</strong>是一种形式化的元数据，它可以被添加到 Java 源代码中。它提供了一种向代码添加信息（数据）的方式，这些信息本身不是程序的一部分，但可以被其他程序（如编译器、开发工具或运行时框架）读取并用于不同的目的。</p>
<p><strong>核心思想：</strong> 注解本身没有逻辑，它的行为由处理它的代码决定。</p>
<hr>
<h4 id="4-4-2-注解的作用与用途"><a href="#4-4-2-注解的作用与用途" class="headerlink" title="4.4.2 注解的作用与用途"></a>4.4.2 注解的作用与用途</h4><p>注解的主要用途有：</p>
<ol>
<li><strong>编译检查</strong>：告诉编译器一些信息，让编译器进行基本的验证（如 <code>@Override</code>， <code>@Deprecated</code>）。</li>
<li><strong>编译时和部署时处理</strong>：在编译时，工具可以根据注解信息生成代码、配置文件或其他文件（如 Lombok, Google Auto）。APT 技术。</li>
<li><strong>运行时处理</strong>：在程序运行时，通过反射机制读取注解信息，从而执行相应的逻辑（这是最常用的一种方式，如 Spring, Hibernate, JUnit 等框架）。</li>
</ol>
<hr>
<h4 id="4-4-3-Java-内置的标准注解"><a href="#4-4-3-Java-内置的标准注解" class="headerlink" title="4.4.3 Java 内置的标准注解"></a>4.4.3 Java 内置的标准注解</h4><p>Java 本身提供了一些内置的注解。</p>
<h5 id="1-用于代码的注解"><a href="#1-用于代码的注解" class="headerlink" title="1. 用于代码的注解"></a>1. 用于代码的注解</h5><ul>
<li><p><strong><code>@Override</code></strong>： 检查该方法是否是重写父类的方法。如果不是，编译器会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@Deprecated</code></strong>： 标记该方法或类已过时，不推荐使用。编译器会生成警告。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@SuppressWarnings</code></strong>： 告诉编译器忽略特定的警告信息，接收一个字符串数组。</p>
<p><strong>JLS 标准定义的警告类型</strong></p>
<table>
<thead>
<tr>
<th>警告类型</th>
<th>描述</th>
<th>常见场景示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>unchecked</code></strong></td>
<td><strong>未检查的转换操作</strong>。最常见的警告，通常与泛型一起出现，表示存在类型不安全的转换。</td>
<td><code>List list = new ArrayList(); list.add(&quot;hello&quot;);</code> 当一个原始类型的集合添加元素时，编译器无法检查其类型安全性。</td>
</tr>
<tr>
<td><strong><code>deprecation</code></strong></td>
<td><strong>使用了已过时的方法或类</strong>。当代码调用了被 <code>@Deprecated</code> 注解标记的 API 时出现。</td>
<td><code>Date date = new Date(); int year = date.getYear(); // getYear() 已过时</code></td>
</tr>
<tr>
<td><strong><code>rawtypes</code></strong></td>
<td><strong>使用了原始类型</strong>。当泛型类被用作原始类型（即没有指定泛型参数）时出现。</td>
<td><code>List list = new ArrayList();</code> 这里 <code>List</code> 就是一个原始类型，应该写成 <code>List&lt;Object&gt;</code> 或具体的类型。</td>
</tr>
<tr>
<td><strong><code>serial</code></strong></td>
<td><strong>可序列化的类缺少 <code>serialVersionUID</code></strong>。当一个类实现了 <code>java.io.Serializable</code> 接口，但没有显式声明 <code>serialVersionUID</code> 静态常量时。</td>
<td><code>public class MyClass implements Serializable { ... }</code></td>
</tr>
<tr>
<td><strong><code>fallthrough</code></strong></td>
<td><strong><code>switch</code> 语句中的 case 块没有 <code>break</code></strong>。当一个 <code>case</code> 执行后会“掉落”到下一个 <code>case</code> 中，而没有 <code>break</code> 或 <code>return</code> 时。</td>
<td><code>switch (x) { case 1: System.out.println(&quot;1&quot;); // 缺少 break case 2: System.out.println(&quot;2&quot;); }</code></td>
</tr>
<tr>
<td><strong><code>removal</code></strong></td>
<td><strong>使用了为将来删除而标记的 API</strong>。这是比 <code>deprecation</code> 更强的警告，用于标记那些在未来版本中确定会被移除的API（通过 <code>@Deprecated(forRemoval=true)</code> 标记）。</td>
<td>调用一个被 <code>@Deprecated(forRemoval=true)</code> 注解的 API。</td>
</tr>
<tr>
<td><strong><code>varargs</code></strong></td>
<td><strong>可变参数方法的潜在堆污染</strong>。当一个泛型可变参数方法可能导致类型安全问题（堆污染）时出现。</td>
<td><code>public &lt;T&gt; void addToList(List&lt;T&gt; list, T... elements) { ... }</code></td>
</tr>
</tbody></table>
<p><strong>常见编译器&#x2F;IDE 扩展的警告类型</strong></p>
<table>
<thead>
<tr>
<th align="left">警告类型</th>
<th align="left">描述</th>
<th align="left">常见场景示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>unused</code></strong></td>
<td align="left"><strong>声明了但未使用过的代码</strong>。包括未使用的局部变量、参数、私有方法、私有字段等。</td>
<td align="left"><code>public void myMethod() { int x = 10; // 变量 x 从未被使用 }</code></td>
</tr>
<tr>
<td align="left"><strong><code>static-access</code></strong></td>
<td align="left"><strong>通过实例引用访问静态成员</strong>。建议直接通过类名访问静态成员。</td>
<td align="left"><code>MyClass obj = new MyClass(); obj.staticMethod(); // 应该写成 MyClass.staticMethod();</code></td>
</tr>
<tr>
<td align="left"><strong><code>finally</code></strong></td>
<td align="left"><strong><code>finally</code> 块无法正常完成</strong>。例如，在 <code>finally</code> 块中使用了 <code>return</code> 或 <code>throw</code> 语句。</td>
<td align="left"><code>try { ... } finally { return; // 这会导致 try 块中的任何异常被丢弃 }</code></td>
</tr>
<tr>
<td align="left"><strong><code>cast</code></strong></td>
<td align="left"><strong>不必要的类型转换</strong>。当一个对象已经是目标类型，但代码中仍然进行了强制类型转换。</td>
<td align="left"><code>String s = &quot;hello&quot;; Object obj = s; String s2 = (String) obj; // obj 已经是 String，转换是多余的</code></td>
</tr>
<tr>
<td align="left"><strong><code>all</code></strong></td>
<td align="left"><strong>抑制所有支持的警告</strong>。这是一个“大杀器”，会抑制该注解作用范围内所有类型的警告。<strong>强烈不推荐使用</strong>，因为它会隐藏所有潜在问题。</td>
<td align="left"><code>@SuppressWarnings(&quot;all&quot;)</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 可能产生未检查转换警告的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@FunctionalInterface</code></strong> (Java 8+)： 声明一个接口是函数式接口（只能有一个抽象方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 只能有一个抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-用于其他注解的注解（元注解）"><a href="#2-用于其他注解的注解（元注解）" class="headerlink" title="2. 用于其他注解的注解（元注解）"></a>2. 用于其他注解的注解（元注解）</h5><p>这些注解用于修饰<em>自定义注解</em>，定义了自定义注解的行为。</p>
<ul>
<li><strong><code>@Target</code></strong>： 指定注解可以应用在哪些Java元素上。<ul>
<li><code>ElementType.TYPE</code>： 类、接口、枚举</li>
<li><code>ElementType.FIELD</code>： 字段</li>
<li><code>ElementType.METHOD</code>： 方法</li>
<li><code>ElementType.PARAMETER</code>： 参数</li>
<li><code>ElementType.CONSTRUCTOR</code>： 构造器</li>
<li><code>ElementType.LOCAL_VARIABLE</code>： 局部变量</li>
<li><code>ElementType.ANNOTATION_TYPE</code>： 注解类型</li>
<li><code>ElementType.PACKAGE</code>： 包</li>
<li><code>ElementType.TYPE_PARAMETER</code> (Java 8+)： 类型参数</li>
<li><code>ElementType.TYPE_USE</code> (Java 8+)： 类型使用</li>
</ul>
</li>
<li><strong><code>@Retention</code></strong>： 指定注解的保留策略，即注解的生命周期。<ul>
<li><code>RetentionPolicy.SOURCE</code>： 仅在源代码中保留，编译器会丢弃（如 <code>@Override</code>, <code>@SuppressWarnings</code>）。</li>
<li><code>RetentionPolicy.CLASS</code>： 在 class 文件中保留，但不会被 JVM 在运行时加载（<strong>默认行为</strong>）。</li>
<li><code>RetentionPolicy.RUNTIME</code>： 在运行时可用，可以通过反射读取。这是最常用的策略，用于运行时处理。</li>
</ul>
</li>
<li><strong><code>@Documented</code></strong>： 表示该注解应该被 javadoc 工具记录，生成到 API 文档中。</li>
<li><strong><code>@Inherited</code></strong>： 表示该注解可以被继承。如果一个类用了被 <code>@Inherited</code> 修饰的注解，其子类将自动具有该注解。</li>
<li><strong><code>@Repeatable</code></strong> (Java 8+)： 表示注解可以在同一个声明上多次使用。</li>
</ul>
<hr>
<h4 id="4-4-4-如何自定义注解"><a href="#4-4-4-如何自定义注解" class="headerlink" title="4.4.4 如何自定义注解"></a>4.4.4 如何自定义注解</h4><p>使用 <code>@interface</code> 关键字来定义注解。注解的成员以无参数方法的形式声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用元注解定义我们的自定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 只能用在方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 运行时保留，可通过反射读取</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyCustomAnnotation &#123;</span><br><span class="line">    <span class="comment">// 注解的成员。方法名就是参数名。</span></span><br><span class="line">    <span class="comment">// 可以使用 default 提供默认值</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default value&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">priority</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String[] tags() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>成员的类型只能是基本类型、<code>String</code>、<code>Class</code>、<code>enum</code>、注解类型，以及这些类型的数组。</li>
<li>如果注解只有一个成员，通常命名为 <code>value()</code>。这样在使用时可以省略参数名。</li>
<li>没有默认值的成员，在使用注解时必须显式提供值。</li>
</ul>
<p><strong>使用自定义注解：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@MyCustomAnnotation(</span></span><br><span class="line"><span class="meta">        value = &quot;test method&quot;,</span></span><br><span class="line"><span class="meta">        priority = 10,</span></span><br><span class="line"><span class="meta">        tags = &#123;&quot;important&quot;, &quot;unit-test&quot;&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只有一个 value 成员，可以简写</span></span><br><span class="line">    <span class="meta">@MyCustomAnnotation(&quot;another method&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">anotherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-4-5-如何处理注解（读取注解信息）"><a href="#4-4-5-如何处理注解（读取注解信息）" class="headerlink" title="4.4.5 如何处理注解（读取注解信息）"></a>4.4.5 如何处理注解（读取注解信息）</h4><p>定义注解本身没用，关键是如何处理它。处理方式取决于其 <code>@Retention</code> 策略。</p>
<h5 id="1-运行时处理（通过反射）"><a href="#1-运行时处理（通过反射）" class="headerlink" title="1. 运行时处理（通过反射）"></a>1. 运行时处理（通过反射）</h5><p>这是最常见的方式，主要用于框架。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 获取类的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取目标方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;testMethod&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 检查方法上是否存在指定的注解</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(MyCustomAnnotation.class)) &#123;</span><br><span class="line">            <span class="comment">// 4. 获取注解实例</span></span><br><span class="line">            <span class="type">MyCustomAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(MyCustomAnnotation.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 从注解实例中读取成员值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> annotation.value();</span><br><span class="line">            <span class="type">int</span> <span class="variable">priority</span> <span class="operator">=</span> annotation.priority();</span><br><span class="line">            String[] tags = annotation.tags();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Value: &quot;</span> + value);</span><br><span class="line">            System.out.println(<span class="string">&quot;Priority: &quot;</span> + priority);</span><br><span class="line">            System.out.println(<span class="string">&quot;Tags: &quot;</span> + String.join(<span class="string">&quot;, &quot;</span>, tags));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里就可以根据读取到的注解信息，执行相应的业务逻辑</span></span><br><span class="line">            <span class="comment">// 例如，根据 priority 决定执行顺序，根据 tags 进行分组测试等</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-编译时处理（APT-Annotation-Processing-Tool）"><a href="#2-编译时处理（APT-Annotation-Processing-Tool）" class="headerlink" title="2. 编译时处理（APT - Annotation Processing Tool）"></a>2. 编译时处理（APT - Annotation Processing Tool）</h5><p>更高级的用法，用于在编译期生成代码。需要继承 <code>AbstractProcessor</code> 类并实现 <code>process</code> 方法。Lombok 库就是利用这个机制在编译时生成 getter&#x2F;setter 等方法字节码的。</p>
<hr>
<h3 id="4-5-异常处理"><a href="#4-5-异常处理" class="headerlink" title="4.5 异常处理"></a>4.5 异常处理</h3><h4 id="4-5-1-概念"><a href="#4-5-1-概念" class="headerlink" title="4.5.1 概念"></a>4.5.1 概念</h4><p>异常（Exception）是指在程序运行过程中发生的非正常事件，它中断了正常的指令流。例如：文件找不到、网络连接失败、除零错误、数组下标越界等。</p>
<p>Java 的异常处理机制通过面向对象的方式来解决这些问题，其核心思想是：<strong>将业务逻辑代码和错误处理代码分离</strong>，从而使程序更健壮、更易于维护。</p>
<hr>
<h4 id="4-5-2-分类"><a href="#4-5-2-分类" class="headerlink" title="4.5.2 分类"></a>4.5.2 分类</h4><p>Java 中所有的异常都继承自 <code>java.lang.Throwable</code> 类。其下有两个主要的子类：<code>Error</code> 和 <code>Exception</code>。</p>
<pre><code class="highlight mermaid">graph TD
    A[Throwable] --&gt; B[Error]
    A --&gt; C[Exception]

    subgraph Error
        B --&gt; D[LinkageError]
        B --&gt; E[&quot;VirtualMachineError&lt;br/&gt;如: OutOfMemoryError&quot;]
        E --&gt; F[StackOverflowError]
    end

    subgraph Exception
        C --&gt; G[IOException]
        C --&gt; H[RuntimeException]
        C --&gt; I[&quot;其他Checked Exception&lt;br/&gt;如: InterruptedException&quot;]
    end

    subgraph IOException
        G --&gt; J[FileNotFoundException]
        G --&gt; K[EOFException]
    end

    subgraph RuntimeException
        H --&gt; L[NullPointerException]
        H --&gt; M[ArrayIndexOutOfBoundsException]
        H --&gt; N[ClassCastException]
        H --&gt; O[IllegalArgumentException]
    end</code></pre>

<h5 id="1-Error-错误"><a href="#1-Error-错误" class="headerlink" title="1. Error (错误)"></a>1. Error (错误)</h5><ul>
<li><strong>定义</strong>：<code>Error</code> 及其子类表示的是<strong>严重的、程序无法处理</strong>的系统级错误。</li>
<li><strong>特点</strong>：通常是虚拟机本身的问题，如系统崩溃、虚拟机错误、内存不足等。应用程序通常无法处理或恢复这些错误，因此我们不需要捕获它们（捕获了也通常无能为力）。</li>
<li><strong>例子</strong>：<code>OutOfMemoryError</code>（内存溢出），<code>StackOverflowError</code>（栈溢出）。</li>
</ul>
<hr>
<h5 id="2-Exception-异常"><a href="#2-Exception-异常" class="headerlink" title="2. Exception (异常)"></a>2. Exception (异常)</h5><ul>
<li><strong>定义</strong>：<code>Exception</code> 及其子类表示的是<strong>程序本身可以处理</strong>的非正常情况。这是我们异常处理机制的核心。</li>
<li><strong>分类</strong>：<ul>
<li><strong>Checked Exception (受检异常)</strong>：<ul>
<li>指除了 <code>RuntimeException</code> 以外的 <code>Exception</code> 子类。</li>
<li><strong>特点</strong>：<strong>编译器会检查</strong>这类异常。意味着在编写代码时，你必须要么用 <code>try-catch</code> 语句捕获它，要么用 <code>throws</code> 子句声明抛出它，否则编译无法通过。</li>
<li><strong>例子</strong>：<code>IOException</code>, <code>SQLException</code>, <code>ClassNotFoundException</code>。这些通常是由外部因素（如文件、数据库、网络）引起的，程序应该有能力去处理（如提示用户重试）。</li>
</ul>
</li>
<li><strong>Unchecked Exception (非受检异常)</strong>：<ul>
<li>指 <code>RuntimeException</code> 及其子类。</li>
<li><strong>特点</strong>：<strong>编译器不会检查</strong>这类异常。你不需要在代码中显式地捕获或声明它们。它们通常是由程序的逻辑错误导致的，应该在开发阶段通过代码审查和测试来避免。</li>
<li><strong>例子</strong>：<code>NullPointerException</code>（空指针），<code>ArrayIndexOutOfBoundsException</code>（数组越界），<code>ClassCastException</code>（类型转换错误），<code>IllegalArgumentException</code>（非法参数）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-5-3-异常处理的关键字和机制"><a href="#4-5-3-异常处理的关键字和机制" class="headerlink" title="4.5.3 异常处理的关键字和机制"></a>4.5.3 异常处理的关键字和机制</h4><p>Java 提供了五个关键字来处理异常：<code>try</code>, <code>catch</code>, <code>finally</code>, <code>throw</code>, <code>throws</code>。</p>
<h5 id="1-try-catch-finally-块：捕获和处理异常"><a href="#1-try-catch-finally-块：捕获和处理异常" class="headerlink" title="1. try-catch-finally 块：捕获和处理异常"></a>1. try-catch-finally 块：捕获和处理异常</h5><p>这是处理异常最核心的结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会发生异常的代码块</span></span><br><span class="line">    <span class="comment">// 如果这里的代码抛出了异常，JVM会立即跳出try块，寻找匹配的catch块</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;nonexistent.txt&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理特定的异常（这里是文件未找到异常）</span></span><br><span class="line">    <span class="comment">// 可以有一个或多个catch块，用于捕获不同类型的异常</span></span><br><span class="line">    System.err.println(<span class="string">&quot;文件未找到: &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 可以在这里进行恢复操作，如提示用户、使用默认文件等</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 捕获更一般的IOException</span></span><br><span class="line">    System.err.println(<span class="string">&quot;发生IO错误: &quot;</span> + e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 捕获所有其他异常（通常放在最后）</span></span><br><span class="line">    System.err.println(<span class="string">&quot;发生未知错误: &quot;</span> + e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，finally块中的代码都会被执行</span></span><br><span class="line">    <span class="comment">// 通常用于释放资源，如关闭文件、数据库连接、网络连接等</span></span><br><span class="line">    <span class="comment">// 这是一个可选块，但强烈推荐用于资源清理</span></span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;关闭文件时出错: &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行流程</strong>：</p>
<ol>
<li>执行 <code>try</code> 块中的代码。</li>
<li>如果发生异常，跳转到第一个能匹配该异常类型的 <code>catch</code> 块执行。</li>
<li>无论是否发生异常或是否被捕获，最终都会执行 <code>finally</code> 块（如果存在）。</li>
</ol>
<hr>
<h5 id="2-throw：主动抛出异常"><a href="#2-throw：主动抛出异常" class="headerlink" title="2. throw：主动抛出异常"></a>2. throw：主动抛出异常</h5><p>使用 <code>throw</code> 关键字可以在代码中<strong>主动地、显式地</strong>抛出一个异常对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个异常对象并用throw抛出</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;年龄必须在0到150之间&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-throws：声明方法可能抛出的异常"><a href="#3-throws：声明方法可能抛出的异常" class="headerlink" title="3. throws：声明方法可能抛出的异常"></a>3. throws：声明方法可能抛出的异常</h5><p>当一个方法内部可能会产生<strong>受检异常（Checked Exception）</strong>，但又不打算在当前方法中处理时，可以使用 <code>throws</code> 关键字在方法签名上<strong>声明</strong>该方法可能抛出的异常类型，将异常传递给调用者去处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法声明了它可能会抛出FileNotFoundException和IOException</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;important.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// ... 读取文件操作</span></span><br><span class="line">    file.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>规则</strong>：</p>
<ul>
<li>对于受检异常，必须要么 <code>try-catch</code>，要么 <code>throws</code>。</li>
<li>对于非受检异常（运行时异常），使用 <code>throws</code> 声明是可选的。</li>
<li>子类重写父类方法时，其 <code>throws</code> 声明的异常不能是父类方法声明异常的父类（即子类方法抛出的异常应该更具体）。</li>
</ul>
<hr>
<h4 id="4-5-4-try-with-resources-语句（Java-7-）"><a href="#4-5-4-try-with-resources-语句（Java-7-）" class="headerlink" title="4.5.4 try-with-resources 语句（Java 7+）"></a>4.5.4 try-with-resources 语句（Java 7+）</h4><p>这是一种简化资源管理的语法糖，用于自动关闭实现了 <code>AutoCloseable</code> 或 <code>Closeable</code> 接口的资源（如 <code>InputStream</code>, <code>OutputStream</code>, <code>Connection</code> 等）。</p>
<p><strong>传统方式（繁琐）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br.close(); <span class="comment">// 需要显式关闭，并且还要套一个try-catch</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 try-with-resources（简洁安全）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 资源在try后的括号中声明和创建</span></span><br><span class="line"><span class="comment">// 无论是否发生异常，资源都会在最后被自动正确关闭</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以声明多个资源，用分号隔开，它们会以<strong>相反的顺序</strong>被自动关闭。</p>
<hr>
<h4 id="4-5-5-自定义异常"><a href="#4-5-5-自定义异常" class="headerlink" title="4.5.5 自定义异常"></a>4.5.5 自定义异常</h4><p>虽然 Java 提供了丰富的异常类，但有时你需要创建特定于自己业务的异常。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>继承 <code>Exception</code>（创建受检异常）或 <code>RuntimeException</code>（创建非受检异常）。</li>
<li>通常提供两个构造方法：一个无参构造，一个带有详细错误信息的构造方法。</li>
</ol>
<p><strong>例子</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义一个受检异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsufficientBalanceException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InsufficientBalanceException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InsufficientBalanceException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义一个非受检异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvalidInputException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvalidInputException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvalidInputException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">throws</span> InsufficientBalanceException &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &gt; balance) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientBalanceException</span>(<span class="string">&quot;余额不足。当前余额: &quot;</span> + balance);</span><br><span class="line">    &#125;</span><br><span class="line">    balance -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-5-6-最佳实践"><a href="#4-5-6-最佳实践" class="headerlink" title="4.5.6 最佳实践"></a>4.5.6 最佳实践</h4><ol>
<li><p><strong>只捕获你知道如何处理的异常</strong>：不要用一个空的 <code>catch</code> 块或简单地 <code>printStackTrace()</code> 来忽略异常。</p>
</li>
<li><p><strong>具体异常优先</strong>：在 <code>catch</code> 块中，先捕获最具体的异常，再捕获更一般的异常。</p>
</li>
<li><p><strong>使用非受检异常表示编程错误</strong>：如前置条件检查失败、无效参数等。</p>
</li>
<li><p><strong>使用受检异常表示可恢复的条件</strong>：如用户输入错误、外部服务暂时不可用等。</p>
</li>
<li><p><strong>尽早抛出，延迟捕获</strong>：在检测到错误的地方就抛出异常，在有能力处理这个异常的最高层才捕获它。</p>
</li>
<li><p><strong>在 finally 块或 try-with-resources 中清理资源</strong>：确保资源（文件、连接等）总能被正确释放。</p>
</li>
<li><p><strong>记录异常信息</strong>：使用日志框架（如 Log4j, SLF4J）记录异常的详细信息，而不仅仅是打印到控制台。</p>
</li>
<li><p><strong>异常转译</strong>：有时在捕获一个异常后，可以抛出一个更符合当前抽象层的自定义异常，并将原始异常作为 <code>cause</code>（通过构造方法传入）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... 可能抛出SQLException的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;保存用户信息失败&quot;</span>, e); <span class="comment">// e作为cause</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免在异常中暴露敏感信息</strong>：如密码、密钥等。</p>
</li>
</ol>
<hr>
<h3 id="4-6-反射"><a href="#4-6-反射" class="headerlink" title="4.6 反射"></a>4.6 反射</h3><h4 id="4-6-1-核心思想"><a href="#4-6-1-核心思想" class="headerlink" title="4.6.1 核心思想"></a>4.6.1 核心思想</h4><p>Java反射机制允许一个正在运行的Java程序<strong>在运行时</strong>检查（introspect）和操作（manipulate）自身的内部属性。你可以把它想象成一面镜子，程序可以通过这面镜子看到自己的结构（类、方法、字段等），并且可以动态地改变这些结构。</p>
<p><strong>技术定义：</strong></p>
<p>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种<strong>动态获取信息</strong>以及<strong>动态调用对象方法</strong>的功能被称为Java语言的反射机制。</p>
<p>正常的Java代码是在<strong>编译时</strong>就确定了要调用的类和方法。而反射则是在<strong>运行时</strong>才确定，这赋予了Java极大的灵活性和动态性。</p>
<hr>
<h4 id="4-6-2-核心组成部分"><a href="#4-6-2-核心组成部分" class="headerlink" title="4.6.2 核心组成部分"></a>4.6.2 核心组成部分</h4><p>Java的反射功能主要由<code>java.lang.Class</code>类和<code>java.lang.reflect</code>包下的一系列类来支持。</p>
<h5 id="1-java-lang-Class-类-反射的入口"><a href="#1-java-lang-Class-类-反射的入口" class="headerlink" title="1. java.lang.Class 类 (反射的入口)"></a>1. <code>java.lang.Class</code> 类 (反射的入口)</h5><p><code>Class</code>类的实例代表了Java应用程序中的类和接口。JVM中每加载一个类，都会为其创建一个对应的<code>Class</code>对象。这个对象包含了该类的完整信息，如类名、父类、接口、构造器、方法、字段等。</p>
<p><strong>获取<code>Class</code>对象</strong> 主要有三种方式：</p>
<ol>
<li><p><strong>通过对象实例获取：</strong> <code>person.getClass()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">Class&lt;?&gt; personClass1 = person.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过类名获取：</strong> <code>Person.class</code> (最安全、性能最好)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass2 = Person.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过类的全限定名获取：</strong> <code>Class.forName(&quot;com.example.Person&quot;)</code> (最常用，尤其是在框架中)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; personClass3 = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="2-java-lang-reflect-包"><a href="#2-java-lang-reflect-包" class="headerlink" title="2. java.lang.reflect 包"></a>2. <code>java.lang.reflect</code> 包</h5><p>这个包提供了实现反射功能的关键类：</p>
<ul>
<li><strong><code>Constructor</code></strong>: 代表类的构造方法。</li>
<li><strong><code>Method</code></strong>: 代表类的方法。</li>
<li><strong><code>Field</code></strong>: 代表类的成员变量（字段）。</li>
<li><strong><code>Modifier</code></strong>: 提供静态方法来解码由<code>getModifiers()</code>返回的访问修饰符（如 <code>public</code>, <code>private</code>, <code>static</code>）。</li>
</ul>
<hr>
<h4 id="4-6-3-主要用途"><a href="#4-6-3-主要用途" class="headerlink" title="4.6.3 主要用途"></a>4.6.3 主要用途</h4><ol>
<li><strong>动态创建对象</strong>：在运行时根据类名创建类的实例。</li>
<li><strong>动态调用方法</strong>：在运行时调用任意对象的任意方法，即使是私有方法。</li>
<li><strong>动态访问和修改字段</strong>：在运行时获取和设置任意对象的任意字段值，即使是私有字段。</li>
<li><strong>获取类的完整结构信息</strong>：获取类的父类、接口、构造器、方法、字段、注解等所有信息。</li>
</ol>
<hr>
<h4 id="4-6-4-代码示例"><a href="#4-6-4-代码示例" class="headerlink" title="4.6.4 代码示例"></a>4.6.4 代码示例</h4><p>定义一个简单的<code>Person</code>类作为示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/com/example/Person.java</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单的Person类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;Default&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造（私有）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getDetails</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix + <span class="string">&quot;: &quot;</span> + name + <span class="string">&quot;, &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-获取Class对象并创建实例"><a href="#1-获取Class对象并创建实例" class="headerlink" title="1. 获取Class对象并创建实例"></a>1. 获取Class对象并创建实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用无参构造器创建实例 (推荐方式)</span></span><br><span class="line">Constructor&lt;?&gt; constructor = personClass.getConstructor();</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> (Person) constructor.newInstance();</span><br><span class="line">System.out.println(person1); <span class="comment">// Person&#123;name=&#x27;Default&#x27;, age=0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用私有构造器创建实例</span></span><br><span class="line">Constructor&lt;?&gt; privateConstructor = personClass.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">privateConstructor.setAccessible(<span class="literal">true</span>); <span class="comment">// **关键：解除私有访问限制**</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> (Person) privateConstructor.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">System.out.println(person2); <span class="comment">// Person&#123;name=&#x27;Alice&#x27;, age=25&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: <code>Class.newInstance()</code> 方法在Java 9中已被废弃，因为它只能调用无参构造器且异常处理不明确。推荐使用<code>getConstructor().newInstance()</code>。</p>
<hr>
<h5 id="2-访问和修改字段"><a href="#2-访问和修改字段" class="headerlink" title="2. 访问和修改字段"></a>2. 访问和修改字段</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) personClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 访问公有字段 &#x27;age&#x27;</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> personClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">ageField.set(person, <span class="number">30</span>); <span class="comment">// person.age = 30;</span></span><br><span class="line">System.out.println(<span class="string">&quot;Public age: &quot;</span> + person.age); <span class="comment">// Public age: 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 访问私有字段 &#x27;name&#x27;</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>); <span class="comment">// **关键：解除私有访问限制**</span></span><br><span class="line">nameField.set(person, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// person.name = &quot;Bob&quot;;</span></span><br><span class="line">System.out.println(<span class="string">&quot;Private name: &quot;</span> + nameField.get(person)); <span class="comment">// Private name: Bob</span></span><br></pre></td></tr></table></figure>

<p><strong><code>getField()</code> vs <code>getDeclaredField()</code></strong>:</p>
<ul>
<li><code>getField()</code>: 获取<strong>公有</strong>字段（包括从父类继承的）。</li>
<li><code>getDeclaredField()</code>: 获取<strong>任意</strong>访问修饰符的字段，但<strong>仅限当前类</strong>声明的。</li>
</ul>
<hr>
<h5 id="3-调用方法"><a href="#3-调用方法" class="headerlink" title="3. 调用方法"></a>3. 调用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) personClass.getConstructor().newInstance();</span><br><span class="line">person.age = <span class="number">40</span>; <span class="comment">// 为了演示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 调用公有方法 &#x27;sayHello&#x27;</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">sayHelloMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">sayHelloMethod.invoke(person); <span class="comment">// Hello, I am Default</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用私有方法 &#x27;getDetails&#x27;</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getDetailsMethod</span> <span class="operator">=</span> personClass.getDeclaredMethod(<span class="string">&quot;getDetails&quot;</span>, String.class);</span><br><span class="line">getDetailsMethod.setAccessible(<span class="literal">true</span>); <span class="comment">// **关键：解除私有访问限制**</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> getDetailsMethod.invoke(person, <span class="string">&quot;Details&quot;</span>);</span><br><span class="line">System.out.println(result); <span class="comment">// Details: Default, 40 years old.</span></span><br></pre></td></tr></table></figure>

<p><strong><code>getMethod()</code> vs <code>getDeclaredMethod()</code></strong>:</p>
<ul>
<li><code>getMethod(name, paramTypes)</code>: 获取<strong>公有</strong>方法（包括从父类继承的）。</li>
<li><code>getDeclaredMethod(name, paramTypes)</code>: 获取<strong>任意</strong>访问修饰符的方法，但<strong>仅限当前类</strong>声明的。</li>
</ul>
<p><code>invoke(Object obj, Object... args)</code> 方法：</p>
<ul>
<li><code>obj</code>: 要调用该方法的对象实例。如果方法是静态的，则此参数为 <code>null</code>。</li>
<li><code>args</code>: 传递给方法的参数。</li>
</ul>
<hr>
<h4 id="4-6-5-优缺点"><a href="#4-6-5-优缺点" class="headerlink" title="4.6.5 优缺点"></a>4.6.5 优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li><strong>灵活性和动态性</strong>：这是反射最大的优点。它允许程序在运行时创建对象、调用方法，大大提高了程序的灵活性，特别适合用于编写通用性强的框架和库。</li>
<li><strong>解耦</strong>：反射可以降低代码的耦合度。例如，通过配置文件指定要加载的类，程序就可以在不修改源码的情况下更换具体实现。</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li><strong>性能开销</strong>：反射操作涉及到动态解析类信息，方法调用绕过了常规的JVM优化（如JIT编译），因此其性能远低于直接调用。频繁使用反射会严重影响程序性能。</li>
<li><strong>破坏封装性</strong>：反射可以访问和修改类的私有成员（通过<code>setAccessible(true)</code>），这违背了面向对象的封装原则，可能导致代码逻辑混乱和安全问题。</li>
<li><strong>类型不安全</strong>：反射操作在编译时无法进行类型检查，所有类型错误都只能在运行时才能发现，这增加了运行时错误的风险。</li>
<li><strong>代码可读性差</strong>：大量使用反射的代码通常比常规代码更复杂、更难阅读和维护。</li>
</ol>
<hr>
<h4 id="4-6-6-真实应用场景"><a href="#4-6-6-真实应用场景" class="headerlink" title="4.6.6 真实应用场景"></a>4.6.6 真实应用场景</h4><p>尽管有缺点，反射在许多场景下是不可或缺的。</p>
<ol>
<li><strong>框架开发</strong>：<ul>
<li><strong>Spring&#x2F;Spring Boot</strong>：其核心功能如**依赖注入（DI）<strong>和</strong>面向切面编程（AOP）**都大量使用了反射。Spring容器通过读取配置（XML或注解）来动态创建对象（Bean）并注入其依赖。</li>
<li><strong>ORM框架（Hibernate, MyBatis）</strong>：通过反射读取实体类的注解和字段，自动将数据库记录映射为Java对象。</li>
</ul>
</li>
<li><strong>动态代理</strong>：Java的<code>java.lang.reflect.Proxy</code>类就是基于反射来创建动态代理对象的。</li>
<li><strong>注解处理器</strong>：在运行时，可以通过反射获取类、方法或字段上的注解信息，并根据注解执行相应的逻辑。例如，JUnit就是通过反射查找带有<code>@Test</code>注解的方法来执行测试。</li>
<li><strong>JDBC驱动加载</strong>：在早期的JDBC中，<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>就是通过反射来加载和注册数据库驱动的。</li>
</ol>
<p><strong>使用原则</strong>：应避免在业务逻辑的性能敏感路径上滥用反射。它更适合用在框架、库和需要高度动态性的底层代码中。在能用常规方式解决问题时，尽量不要使用反射。</p>
<hr>
<h3 id="4-7-动态代理"><a href="#4-7-动态代理" class="headerlink" title="4.7 动态代理"></a>4.7 动态代理</h3><h4 id="4-7-1-代理模式"><a href="#4-7-1-代理模式" class="headerlink" title="4.7.1 代理模式"></a>4.7.1 代理模式</h4><p>代理模式的核心思想是：<strong>为其他对象提供一种代理以控制对这个对象的访问</strong>。</p>
<p>可以把代理想象成一个“中介”或“经纪人”。你不想直接和某个对象（目标对象）打交道，而是通过这个中介。这个中介可以在你和目标对象交互的<strong>前后</strong>做一些额外的事情。</p>
<hr>
<h4 id="4-7-2-静态代理与动态代理"><a href="#4-7-2-静态代理与动态代理" class="headerlink" title="4.7.2 静态代理与动态代理"></a>4.7.2 静态代理与动态代理</h4><h5 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h5><p><strong>特点</strong>：代理类是在<strong>编译时</strong>就创建好的。程序员需要手动为每一个需要被代理的接口或类编写一个代理类。</p>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>定义一个接口（例如 <code>UserService</code>）。</li>
<li>创建一个实现该接口的目标类（<code>UserServiceImpl</code>）。</li>
<li>创建一个实现该接口的代理类（<code>UserServiceProxy</code>），代理类内部持有目标类的实例。</li>
<li>在代理类的方法中，调用目标类的同名方法，并在调用前后添加附加逻辑。</li>
</ol>
<p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 目标类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库：添加用户 &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 静态代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 持有目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 事务开始 ---&quot;</span>); <span class="comment">// 增强逻辑</span></span><br><span class="line">        target.addUser(username); <span class="comment">// 调用目标方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 事务提交 ---&quot;</span>); <span class="comment">// 增强逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceProxy</span>(target);</span><br><span class="line">        proxy.addUser(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态代理的缺点</strong>：</p>
<ul>
<li><strong>类爆炸</strong>：如果需要代理的接口很多，就需要为每个接口编写一个代理类，导致类数量急剧增加。</li>
<li><strong>代码重复</strong>：所有代理类的逻辑（如事务、日志）都是相似的，导致大量重复代码。</li>
<li><strong>不易维护</strong>：如果接口增加一个方法，目标类和代理类都需要修改。</li>
</ul>
<hr>
<h5 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2. 动态代理"></a>2. 动态代理</h5><p><strong>特点</strong>：代理类是在<strong>运行时</strong>动态生成的，而不是在编译时。我们不需要手动编写代理类，而是通过Java提供的API来动态创建一个代理对象。</p>
<p><strong>核心思想</strong>：我们不再关心代理类的具体形态，而是只关心在代理过程中需要执行的<strong>附加逻辑（Advice）</strong>。这个逻辑被封装在一个统一的处理器中。</p>
<p>动态代理解决了静态代理的所有缺点，实现了对任意接口的通用代理。</p>
<hr>
<h4 id="4-7-3-Java中的动态代理实现"><a href="#4-7-3-Java中的动态代理实现" class="headerlink" title="4.7.3 Java中的动态代理实现"></a>4.7.3 Java中的动态代理实现</h4><p>Java生态中主要有两种实现动态代理的方式：<strong>JDK动态代理</strong> 和 <strong>CGLIB动态代理</strong>。</p>
<h5 id="1-JDK动态代理"><a href="#1-JDK动态代理" class="headerlink" title="1. JDK动态代理"></a>1. JDK动态代理</h5><p>这是Java官方提供的实现方式，位于 <code>java.lang.reflect</code> 包下。</p>
<p><strong>核心组件</strong>：</p>
<ol>
<li><p><strong><code>Proxy</code></strong>: 创建代理对象的工厂类。最重要的方法是 <code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>。</p>
<p>这是创建代理对象的唯一入口。它的三个参数至关重要：</p>
<ul>
<li><code>ClassLoader loader</code>：<strong>类加载器</strong>。<ul>
<li><strong>作用</strong>：用来加载动态生成的代理类（<code>$Proxy0</code>）。任何类在使用前都必须由一个类加载器加载到 JVM 中。通常我们使用目标类的类加载器 <code>target.getClass().getClassLoader()</code>。</li>
<li><strong>为什么需要</strong>：因为代理类是在运行时动态创建的，它不存在于你的 classpath 中，所以需要一个类加载器在内存中定义并加载它。</li>
</ul>
</li>
<li><code>Class&lt;?&gt;[] interfaces</code>：<strong>目标对象实现的接口数组</strong>。<ul>
<li><strong>作用</strong>：告诉代理类需要实现哪些接口。生成的代理类会实现这个数组里的所有接口。</li>
<li><strong>为什么是数组</strong>：因为一个类可以实现多个接口。代理对象必须模拟目标对象的所有接口行为，才能被安全地替换。这是 JDK 代理<strong>必须基于接口</strong>的根本原因。</li>
</ul>
</li>
<li><code>InvocationHandler h</code>：<strong>调用处理器</strong>。<ul>
<li><strong>作用</strong>：这是代理的核心逻辑所在。所有对代理对象的方法调用，最终都会被路由到这个 <code>InvocationHandler</code> 的 <code>invoke</code> 方法中。你所有的增强逻辑（如日志、事务、权限控制）都写在这里。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>InvocationHandler</code></strong>: 这是一个接口。我们需要编写一个实现该接口的类，这个类就是我们之前提到的“附加逻辑”的封装。所有对代理对象的方法调用，都会被转发到<code>InvocationHandler.invoke(Object proxy, Method method, Object[] args)</code>中。</p>
<ul>
<li><code>Object proxy</code>：<strong>动态生成的代理对象本身</strong>。<ul>
<li><strong>作用</strong>：就是 <code>Proxy.newProxyInstance()</code> 返回的那个对象。</li>
<li><strong>注意</strong>：<strong>在 <code>invoke</code> 方法内部，请尽量不要使用这个 <code>proxy</code> 对象去调用它的任何方法</strong>。例如，如果你在 <code>invoke</code> 内部调用 <code>proxy.toString()</code>，这又会触发一次 <code>invoke</code> 方法的调用，从而导致无限递归，最终引发 <code>StackOverflowError</code>。</li>
</ul>
</li>
<li><code>Method method</code>：<strong>被调用的方法对象</strong>。<ul>
<li><strong>作用</strong>：它是一个 <code>java.lang.reflect.Method</code> 实例，代表了当前被调用的具体方法（例如 <code>addUser</code> 方法）。你可以通过它获取方法名 (<code>method.getName()</code>)、参数类型、注解等元信息。</li>
<li><strong>核心用途</strong>：通过反射调用目标对象的原始方法：<code>method.invoke(target, args)</code>。</li>
</ul>
</li>
<li><code>Object[] args</code>：<strong>调用方法时传入的参数数组</strong>。<ul>
<li><strong>作用</strong>：包含了调用方法时传递的所有参数。如果被调用的方法没有参数，那么 <code>args</code> 就是 <code>null</code> 或者一个空数组。</li>
<li><strong>注意</strong>：如果原始方法的参数是基本类型（如 <code>int</code>），在 <code>args</code> 数组中它会被自动装箱成对应的包装类型（如 <code>Integer</code>）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>实现要求</strong>：</p>
<ul>
<li><strong>目标类必须实现一个或多个接口</strong>。JDK动态代理是基于接口的。</li>
</ul>
<p><strong>实现步骤</strong>：</p>
<ol>
<li><strong>定义一个接口和目标类</strong>（同静态代理）。</li>
<li><strong>创建一个 <code>InvocationHandler</code> 实现类</strong>。在这个类的 <code>invoke</code> 方法中编写统一的代理逻辑。</li>
<li><strong>使用 <code>Proxy.newProxyInstance()</code> 方法创建代理对象</strong>。</li>
<li>通过代理对象调用方法。</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 接口和目标类（与静态代理相同）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span>;</span><br><span class="line">    String <span class="title function_">findUser</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库：添加用户 &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUser</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库：查找用户ID &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 InvocationHandler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  动态生成的代理对象本身（很少使用）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被调用的方法对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   调用方法时传入的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 日志：方法 &quot;</span> + method.getName() + <span class="string">&quot; 开始执行 ---&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标对象的原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 日志：方法 &quot;</span> + method.getName() + <span class="string">&quot; 执行完毕 ---&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkDynamicProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建目标对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建 InvocationHandler</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用 Proxy.newProxyInstance() 创建代理对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载器</span></span><br><span class="line">            target.getClass().getInterfaces(),   <span class="comment">// 目标类实现的接口数组</span></span><br><span class="line">            handler                              <span class="comment">// InvocationHandler 实例</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 通过代理对象调用方法</span></span><br><span class="line">        proxyInstance.addUser(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> proxyInstance.findUser(<span class="number">101</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;找到的用户是: &quot;</span> + user);</span><br><span class="line">        </span><br><span class="line">        System.out.println(proxyInstance.getClass()); <span class="comment">// class com.sun.proxy.$Proxy0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心工作原理</strong></p>
<p>JDK 动态代理的核心在于 <code>Proxy.newProxyInstance()</code> 方法。当调用它时，它并不会返回原始 <code>UserServiceImpl</code> 对象，而是在<strong>运行时动态地生成一个新的类</strong>。这个新类通常被称为代理类（Proxy Class）。</p>
<p>这个动态生成的代理类具有以下特征：</p>
<ol>
<li><strong>类名</strong>：它的名字类似于 <code>com.sun.proxy.$Proxy0</code>，<code>$Proxy1</code> 等，包名是 <code>com.sun.proxy</code>。</li>
<li><strong>继承关系</strong>：它继承自 <code>java.lang.reflect.Proxy</code> 类。</li>
<li><strong>接口实现</strong>：它实现了你在 <code>newProxyInstance()</code> 方法中传入的所有接口（例如，这里的 <code>UserService</code> 接口）。正因为如此，它才能被强制转换为 <code>UserService</code> 类型。</li>
<li><strong>方法实现</strong>：对于接口中的每一个方法（如 <code>addUser</code>, <code>findUser</code>），代理类都会生成一个对应的方法。<strong>这个方法的实现逻辑非常简单：就是去调用你传入的 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法</strong>，并把自己（代理对象）、被调用的方法对象（<code>Method</code>）、以及方法参数（<code>Object[]</code>）传递过去。</li>
</ol>
<p><strong>用伪代码来描述动态生成的 <code>$Proxy0</code> 类，你会看得更清楚：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是在运行时，由 JVM 动态生成的，你永远看不到它的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.reflect.Proxy <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它持有一个 InvocationHandler 的引用，这是在 newProxyInstance 时传入的</span></span><br><span class="line">    <span class="keyword">private</span> InvocationHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler handler) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现接口中的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 关键！所有方法调用都被转发到了 handler.invoke()</span></span><br><span class="line">            <span class="comment">// 1. 获取当前被调用的方法对象</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">addUserMethod</span> <span class="operator">=</span> UserService.class.getMethod(<span class="string">&quot;addUser&quot;</span>, String.class);</span><br><span class="line">            <span class="comment">// 2. 调用 handler 的 invoke 方法</span></span><br><span class="line">            <span class="built_in">this</span>.handler.invoke(<span class="built_in">this</span>, addUserMethod, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;username&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// ... 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUser</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">findUserMethod</span> <span class="operator">=</span> UserService.class.getMethod(<span class="string">&quot;findUser&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">            <span class="comment">// 将调用转发给 handler</span></span><br><span class="line">            <span class="keyword">return</span> (String) <span class="built_in">this</span>.handler.invoke(<span class="built_in">this</span>, findUserMethod, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;id&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// ... 异常处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// equals(), hashCode(), toString() 等方法也会被类似地转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，整个调用链就清晰了：<br><code>proxyInstance.addUser(&quot;Bob&quot;)</code> -&gt; <code>$Proxy0.addUser(&quot;Bob&quot;)</code> -&gt; <code>handler.invoke(...)</code> -&gt; 在 <code>invoke</code> 内部通过反射调用 <code>target.addUser(&quot;Bob&quot;)</code>。</p>
<hr>
<h5 id="2-CGLIB动态代理"><a href="#2-CGLIB动态代理" class="headerlink" title="2. CGLIB动态代理"></a>2. CGLIB动态代理</h5><p>CGLIB (Code Generation Library) 是一个强大的、高性能的代码生成库。它被广泛应用于许多框架中（如Spring、Hibernate），用于在运行时扩展Java类和实现AOP，位于 <code>net.sf.cglib.proxy</code> 包下。</p>
<p><strong>核心思想</strong>：</p>
<p>CGLIB通过<strong>继承</strong>的方式来实现代理。它在运行时动态地生成一个目标类的<strong>子类</strong>，并重写父类（目标类）中的非final方法，在重写的方法中织入增强逻辑。</p>
<p><strong>核心组件</strong>：</p>
<ol>
<li><strong><code>Enhancer</code></strong>: 类似于JDK的<code>Proxy</code>类，是创建代理对象的入口。<ul>
<li><code>enhancer.setSuperclass(Class type)</code>：设置需要被代理的<strong>父类</strong>。CGLIB 将会为这个类动态创建一个子类。</li>
<li><code>enhancer.setCallback(Callback callback)</code>：设置<strong>回调</strong>。<code>MethodInterceptor</code> 是 <code>Callback</code> 的一个子接口。这里就是把我们的拦截逻辑（<code>MyMethodInterceptor</code>）注入进去。</li>
<li><code>enhancer.create()</code>：创建并返回代理对象。这个方法会触发字节码生成、类加载和对象实例化。</li>
</ul>
</li>
<li><strong><code>MethodInterceptor</code></strong>: 类似于JDK的<code>InvocationHandler</code>，用于定义拦截逻辑，核心方法<code>MethodInterceptor.intercept(Object obj, Method method, Object[] args, MethodProxy proxy)</code><ul>
<li><code>Object obj</code>：<strong>CGLIB 生成的代理对象（子类实例）</strong>。</li>
<li><code>Method method</code>：被拦截的方法对象，与 JDK 代理中的 <code>method</code> 作用相同。</li>
<li><code>Object[] args</code>：方法参数数组，与 JDK 代理中的 <code>args</code> 作用相同。</li>
<li><code>MethodProxy proxy</code>：<strong>这是 CGLIB 的一个关键特性，也是其性能优势的来源</strong>。<ul>
<li><strong>作用</strong>：用于调用父类（即目标类）的同名方法。</li>
<li><strong>核心方法</strong>：<ul>
<li><code>proxy.invokeSuper(obj, args)</code>: 这是<strong>推荐使用</strong>的方式。它会调用被代理的原始方法（即父类的方法）。<code>obj</code> 是代理对象，<code>args</code> 是参数。</li>
<li><code>proxy.invoke(target, args)</code>: 这个方法可以调用原始对象 <code>target</code> 的方法，但通常不这么用，且性能不如 <code>invokeSuper</code>。</li>
</ul>
</li>
<li><strong>为什么它比 <code>method.invoke()</code> 快？</strong><ul>
<li><code>method.invoke()</code> 是 Java 的<strong>反射</strong>调用，它包含权限检查、方法查找等一系列相对耗时的操作。</li>
<li><code>MethodProxy.invokeSuper()</code> <strong>不是通过反射调用</strong>。CGLIB 在生成字节码时，就已经为每个方法创建了一个 <code>MethodProxy</code>。这个 <code>proxy</code> 内部记录了快速调用父类方法的<strong>方法索引</strong>。因此，<code>invokeSuper</code> 的调用是<strong>直接的、非反射的</strong>，几乎和直接调用一样快。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>实现要求</strong>：</p>
<ul>
<li><strong>目标类不能是 <code>final</code> 的</strong>。因为CGLIB需要继承这个类。</li>
<li>被代理的方法不能是 <code>final</code> 或 <code>static</code> 的。</li>
</ul>
<p><strong>代码示例</strong> (需要添加CGLIB依赖)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标类（没有实现任何接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库：创建订单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123; <span class="comment">// final 方法无法被代理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数据库：获取订单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MethodInterceptor 实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj    代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  用于调用父类（目标类）的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt; 权限检查开始 &gt;&gt;&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用父类（目标类）的原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt; 权限检查结束 &lt;&lt;&lt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 Enhancer 对象</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 2. 设置父类（目标类）</span></span><br><span class="line">        enhancer.setSuperclass(OrderService.class);</span><br><span class="line">        <span class="comment">// 3. 设置回调（MethodInterceptor）</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 创建代理对象</span></span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (OrderService) enhancer.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 调用方法</span></span><br><span class="line">        proxy.createOrder();</span><br><span class="line">        proxy.getOrder(); <span class="comment">// final 方法不会被拦截，直接调用原始方法</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(proxy.getClass()); <span class="comment">// class com.example.OrderService$$EnhancerByCGLIB$$...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心工作原理</strong></p>
<p>CGLIB 的实现方式与 JDK 完全不同。它不要求接口，而是通过<strong>继承</strong>来实现。</p>
<p>当你调用 <code>Enhancer.create()</code> 时，CGLIB 会利用一个名为 <strong>ASM</strong> 的字节码操作库，在运行时动态地生成一个<strong>目标类的子类</strong>。</p>
<p>这个动态生成的子类具有以下特征：</p>
<ol>
<li><strong>类名</strong>：它的名字类似于 <code>OrderService$$EnhancerByCGLIB$$&lt;hash_code&gt;</code>。</li>
<li><strong>继承关系</strong>：它继承自你的目标类（例如，<code>extends OrderService</code>）。这就是为什么目标类不能是 <code>final</code> 的。</li>
<li><strong>方法实现</strong>：它会<strong>重写（Override）目标类中所有非 <code>final</code></strong> 的、<strong>非 <code>static</code></strong> 的、<strong>非 <code>private</code></strong> 的方法。</li>
<li><strong>方法拦截</strong>：在重写的方法内部，它不会直接调用父类（即目标类）的原始方法，而是转而去调用你设置的 <code>MethodInterceptor</code> 的 <code>intercept()</code> 方法。</li>
</ol>
<p><strong>用伪代码来描述 CGLIB 动态生成的子类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是 CGLIB 在运行时动态生成的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService$$EnhancerByCGLIB$$</span>... <span class="keyword">extends</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它持有一个 MethodInterceptor 的引用</span></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor interceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 构造函数等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写父类的非 final 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 关键！所有调用都被转发给了 interceptor.intercept()</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.interceptor != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取当前方法的 MethodProxy 对象</span></span><br><span class="line">                <span class="type">MethodProxy</span> <span class="variable">methodProxy</span> <span class="operator">=</span> ...;</span><br><span class="line">                <span class="comment">// 调用拦截器</span></span><br><span class="line">                <span class="built_in">this</span>.interceptor.intercept(<span class="built_in">this</span>, createOrderMethod, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;, methodProxy);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有拦截器，则调用原始方法</span></span><br><span class="line">            <span class="built_in">super</span>.createOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// final 方法 getOrder() 无法被重写，所以它不会出现在这个子类中。</span></span><br><span class="line">    <span class="comment">// 调用 proxy.getOrder() 会直接执行 OrderService 中的原始代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用链：<code>proxy.createOrder()</code> -&gt; <code>OrderService$$EnhancerByCGLIB.createOrder()</code> -&gt; <code>interceptor.intercept(...)</code> -&gt; 在 <code>intercept</code> 内部通过 <code>MethodProxy</code> 调用 <code>super.createOrder()</code>。</p>
<hr>
<h4 id="4-7-4-总结"><a href="#4-7-4-总结" class="headerlink" title="4.7.4 总结"></a>4.7.4 总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JDK 动态代理</th>
<th align="left">CGLIB 动态代理</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现原理</strong></td>
<td align="left">基于<strong>接口</strong>，运行时动态生成接口的实现类。</td>
<td align="left">基于<strong>继承</strong>，运行时动态生成目标类的子类。</td>
</tr>
<tr>
<td align="left"><strong>代理对象要求</strong></td>
<td align="left">目标类必须实现至少一个接口。</td>
<td align="left">目标类不能是<code>final</code>类，被代理的方法不能是<code>final</code>或<code>static</code>。</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">Java JDK 自带，无需额外依赖。</td>
<td align="left">需要引入第三方CGLIB库。</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">在早期版本中，性能略低于CGLIB。但在现代JDK版本中，通过不断优化，两者性能差距已经非常小，有时JDK代理甚至更快。</td>
<td align="left">传统上认为性能更高，因为它通过方法索引直接调用，而非反射。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">适用于目标对象有接口的情况。</td>
<td align="left">适用于没有接口，但需要代理的普通类。</td>
</tr>
</tbody></table>
<p><strong>Spring AOP中的选择</strong>：</p>
<p>Spring AOP会智能地在这两者之间进行选择：</p>
<ul>
<li>如果目标对象<strong>实现了接口</strong>，Spring默认使用<strong>JDK动态代理</strong>。</li>
<li>如果目标对象<strong>没有实现接口</strong>，Spring会使用<strong>CGLIB动态代理</strong>。</li>
<li>你也可以强制Spring全部使用CGLIB代理（通过配置<code>proxy-target-class=&quot;true&quot;</code>）。</li>
</ul>
<hr>
<h4 id="4-7-5-真实应用场景"><a href="#4-7-5-真实应用场景" class="headerlink" title="4.7.5 真实应用场景"></a>4.7.5 真实应用场景</h4><p>动态代理是实现许多高级功能的核心技术，尤其是在**面向切面编程（AOP）**中。</p>
<ol>
<li><strong>Spring AOP</strong>：实现事务管理（<code>@Transactional</code>）、日志记录、权限控制、性能监控等横切关注点。</li>
<li><strong>RPC 框架</strong>：如Dubbo、gRPC的客户端，你调用的远程服务接口实际上是一个本地的代理对象，该代理对象负责网络通信、序列化等底层细节。</li>
<li><strong>ORM 框架</strong>：如MyBatis，你编写的Mapper接口并没有实现类，MyBatis通过动态代理为你生成一个实现类，该类负责执行SQL语句。</li>
<li><strong>数据库连接池</strong>：当调用<code>connection.close()</code>时，连接池并不会真正关闭物理连接，而是通过代理将连接归还给连接池。</li>
</ol>
<hr>
<h3 id="4-8-泛型"><a href="#4-8-泛型" class="headerlink" title="4.8 泛型"></a>4.8 泛型</h3><h4 id="4-8-1-简介"><a href="#4-8-1-简介" class="headerlink" title="4.8.1 简介"></a>4.8.1 简介</h4><p><strong>泛型 (Generics)</strong> 的本质是 <strong>参数化类型 (Parameterized Type)</strong>，也就是说，将类型像参数一样传递。它允许我们在定义类、接口和方法时使用类型参数，而在使用时再指定具体的类型。</p>
<p><strong>为什么需要泛型？</strong></p>
<p>在泛型出现之前（JDK 1.5 以前），Java 的集合类（如 <code>ArrayList</code>）只能存储 <code>Object</code> 类型的对象。这样做有两个主要弊端：</p>
<ol>
<li><p><strong>类型不安全</strong>：你可以向一个集合中添加任何类型的对象，编译器不会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型出现前</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 编译时完全正常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>需要强制类型转换</strong>：从集合中取出元素时，必须手动进行强制类型转换，这不仅繁琐，而且可能在运行时抛出 <code>ClassCastException</code> 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行时会抛出 ClassCastException</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> (String) list.get(<span class="number">1</span>); <span class="comment">// 错误！123无法转换为String</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>泛型带来的好处：</strong></p>
<ol>
<li><p><strong>编译时类型检查 (Type Safety)</strong>：编译器会在编译阶段检查类型，防止将错误类型的对象放入集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用泛型后</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// list.add(123); // 编译时就会报错！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消除强制类型转换 (Eliminates Casts)</strong>：从集合中获取元素时，不再需要手动转换，代码更简洁、更安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 无需强制转换</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码重用与抽象 (Code Reusability)</strong>：可以编写出更通用、更灵活的代码，一套代码可以适用于多种数据类型。</p>
</li>
</ol>
<hr>
<h4 id="4-8-2-泛型的核心用法"><a href="#4-8-2-泛型的核心用法" class="headerlink" title="4.8.2 泛型的核心用法"></a>4.8.2 泛型的核心用法</h4><h5 id="1-泛型类-Generic-Class"><a href="#1-泛型类-Generic-Class" class="headerlink" title="1. 泛型类 (Generic Class)"></a>1. 泛型类 (Generic Class)</h5><p>在类名后添加 <code>&lt;T&gt;</code>（T 是一个约定的类型参数名，可以是任何合法的标识符）来定义一个泛型类。</p>
<p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例：一个通用的 “盒子” 类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型类</span></span><br><span class="line">Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">integerBox.set(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// integerBox.set(&quot;hello&quot;); // 编译错误</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> integerBox.get();</span><br><span class="line"></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">stringBox.set(<span class="string">&quot;Java Generics&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> stringBox.get();</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-泛型接口-Generic-Interface"><a href="#2-泛型接口-Generic-Interface" class="headerlink" title="2. 泛型接口 (Generic Interface)"></a>2. 泛型接口 (Generic Interface)</h5><p>与泛型类类似，在接口名后添加 <code>&lt;T&gt;</code>。</p>
<p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceName</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例：一个通用的 “生成器” 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">generate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现泛型接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomIntegerGenerator</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticStringGenerator</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-泛型方法-Generic-Method"><a href="#3-泛型方法-Generic-Method" class="headerlink" title="3. 泛型方法 (Generic Method)"></a>3. 泛型方法 (Generic Method)</h5><p>泛型方法允许方法的类型参数独立于类的类型参数。</p>
<p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">methodName</span><span class="params">(T argument)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;T&gt;</code>：类型参数声明，必须放在返回值类型之前。</li>
<li><code>T</code>：可以作为方法的返回类型、参数类型等。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>泛型方法可以是静态的或非静态的。</li>
<li>方法的类型参数 <code>&lt;T&gt;</code> 作用域仅限于该方法。</li>
</ul>
<p><strong>示例：一个打印任意类型数组的工具方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(E[] inputArray)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (E element : inputArray) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s &quot;</span>, element);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型方法</span></span><br><span class="line">Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">String[] stringArray = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">Utils.printArray(intArray);   <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">Utils.printArray(stringArray); <span class="comment">// 输出: Hello World</span></span><br></pre></td></tr></table></figure>

<p><strong>类型推断</strong>：大多数情况下，编译器可以根据传入的参数自动推断出 <code>E</code> 的具体类型，所以我们不需要显式指定，如 <code>Utils.&lt;Integer&gt;printArray(intArray)</code>。</p>
<hr>
<h4 id="4-8-3-通配符-Wildcards"><a href="#4-8-3-通配符-Wildcards" class="headerlink" title="4.8.3 通配符 (Wildcards)"></a>4.8.3 通配符 (Wildcards)</h4><p>通配符 <code>?</code> 用于表示未知的类型，主要用于解决泛型类型不具备继承性的问题。</p>
<h5 id="1-为什么需要通配符？"><a href="#1-为什么需要通配符？" class="headerlink" title="1. 为什么需要通配符？"></a>1. 为什么需要通配符？</h5><p><strong>核心问题</strong>：<code>List&lt;Integer&gt;</code> <strong>不是</strong> <code>List&lt;Number&gt;</code> 的子类。</p>
<p>虽然 <code>Integer</code> 是 <code>Number</code> 的子类，但包含它们的泛型类型之间没有继承关系。这被称为 <strong>泛型的不变性 (Invariance)</strong>。</p>
<p><strong>为什么？</strong> 假设 <code>List&lt;Integer&gt;</code> 是 <code>List&lt;Number&gt;</code> 的子类，那么下面的代码在编译时将是合法的，但在运行时会产生严重问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 假设这是合法的</span></span><br><span class="line">List&lt;Number&gt; numList = intList; </span><br><span class="line"><span class="comment">// 那么我们可以向 numList 中添加 Double</span></span><br><span class="line">numList.add(<span class="number">3.14</span>); <span class="comment">// 合法，因为 Double 是 Number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题来了：我们从 intList 中取出了一个 Double！</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">myInt</span> <span class="operator">=</span> intList.get(<span class="number">0</span>); <span class="comment">// ClassCastException: Double cannot be cast to Integer</span></span><br></pre></td></tr></table></figure>

<p>为了在保证类型安全的前提下，让泛型代码更灵活，通配符应运而生。</p>
<hr>
<h5 id="2-上界通配符-extends-T"><a href="#2-上界通配符-extends-T" class="headerlink" title="2. 上界通配符 (? extends T)"></a>2. 上界通配符 (<code>? extends T</code>)</h5><p><strong>含义</strong>：表示一个未知的类型，但这个类型是 <code>T</code> 或 <code>T</code> 的子类。</p>
<p><strong>用途</strong>：主要用于 <strong>读取</strong> 数据（作为生产者），不用于写入。</p>
<p><strong>示例</strong>：计算一个数字列表的总和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法可以接受 List&lt;Integer&gt;, List&lt;Double&gt;, List&lt;Float&gt; 等</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sumOfList</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Number n : list) &#123;</span><br><span class="line">        sum += n.doubleValue(); <span class="comment">// 安全读取：因为我们知道每个元素至少是 Number</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list.add(123); // 编译错误！</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写入限制</strong>：你不能向 <code>List&lt;? extends Number&gt;</code> 中添加任何元素（<code>null</code> 除外），因为编译器无法确定 <code>?</code> 的具体类型。如果是 <code>List&lt;Double&gt;</code>，你不能添加 <code>Integer</code>；如果是 <code>List&lt;Integer&gt;</code>，你不能添加 <code>Double</code>。为了安全，编译器干脆禁止所有添加操作。</p>
<hr>
<h5 id="3-下界通配符-super-T"><a href="#3-下界通配符-super-T" class="headerlink" title="3. 下界通配符 (? super T)"></a>3. 下界通配符 (<code>? super T</code>)</h5><p><strong>含义</strong>：表示一个未知的类型，但这个类型是 <code>T</code> 或 <code>T</code> 的超类。</p>
<p><strong>用途</strong>：主要用于 <strong>写入</strong> 数据（作为消费者），不适合读取。</p>
<p><strong>示例</strong>：向一个列表中添加整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法可以接受 List&lt;Integer&gt;, List&lt;Number&gt;, List&lt;Object&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addIntegers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">1</span>); <span class="comment">// 安全写入：因为 1 是 Integer，而列表可以容纳 Integer 或其父类</span></span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Object obj = list.get(0); // 读取是有限制的</span></span><br><span class="line">    <span class="comment">// Integer i = list.get(0); // 编译错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读取限制</strong>：当你从 <code>List&lt;? super Integer&gt;</code> 中读取时，你只能保证得到的是一个 <code>Object</code>，因为你不知道它的具体类型是 <code>Integer</code>、<code>Number</code> 还是 <code>Object</code>。</p>
<hr>
<h5 id="4-无界通配符"><a href="#4-无界通配符" class="headerlink" title="4. 无界通配符 (?)"></a>4. 无界通配符 (<code>?</code>)</h5><p><strong>含义</strong>：表示任何类型，等同于 <code>? extends Object</code>。</p>
<p><strong>用途</strong>：当元素的具体类型不重要时使用，通常用于只读操作，且不依赖于具体类型的方法。</p>
<p><strong>示例</strong>：打印任何类型的列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object elem : list) &#123; <span class="comment">// 只能按 Object 读取</span></span><br><span class="line">        System.out.print(elem + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list.add(new Object()); // 编译错误！与 extends 一样，不能写入</span></span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-PECS-原则"><a href="#5-PECS-原则" class="headerlink" title="5. PECS 原则"></a>5. PECS 原则</h5><p>这是一个非常有用的助记法则，用于决定使用 <code>extends</code> 还是 <code>super</code>：</p>
<p><strong>PECS: Producer Extends, Consumer Super</strong></p>
<ul>
<li><strong>Producer Extends</strong>：如果你的方法需要一个列表作为生产者（你从中 <strong>读取</strong> T 类型的元素），请使用 <code>? extends T</code>。</li>
<li><strong>Consumer Super</strong>：如果你的方法需要一个列表作为消费者（你向其中 <strong>写入</strong> T 类型的元素），请使用 <code>? super T</code>。</li>
</ul>
<p><strong>经典示例：<code>Collections.copy()</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; src.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// src 是生产者 (Producer)，从中读取，用 extends</span></span><br><span class="line">        <span class="comment">// dest 是消费者 (Consumer)，向其中写入，用 super</span></span><br><span class="line">        dest.set(i, src.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-8-4-类型擦除-Type-Erasure"><a href="#4-8-4-类型擦除-Type-Erasure" class="headerlink" title="4.8.4 类型擦除 (Type Erasure)"></a>4.8.4 类型擦除 (Type Erasure)</h4><h5 id="1-什么是类型擦除？"><a href="#1-什么是类型擦除？" class="headerlink" title="1. 什么是类型擦除？"></a>1. 什么是类型擦除？</h5><p>Java 的泛型是通过 <strong>类型擦除</strong> 来实现的。这意味着泛型信息 <strong>只存在于编译期</strong>，在运行时（<code>.class</code> 文件中）会被 “擦除” 掉。</p>
<p><strong>擦除规则：</strong></p>
<ol>
<li>对于无界泛型（如 <code>&lt;T&gt;</code>），<code>T</code> 被替换为 <code>Object</code>。</li>
<li>对于有界泛型（如 <code>&lt;T extends Number&gt;</code>），<code>T</code> 被替换为它的上界，即 <code>Number</code>。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T content;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> content; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（在字节码层面）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object content;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> content; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器在必要时会自动插入强制类型转换，以保证类型安全。这就是为什么你从 <code>List&lt;String&gt;</code> 中 <code>get()</code> 元素时不需要手动转换，因为编译器帮你做了。</p>
<hr>
<h5 id="2-类型擦除带来的问题与桥接方法"><a href="#2-类型擦除带来的问题与桥接方法" class="headerlink" title="2. 类型擦除带来的问题与桥接方法"></a>2. 类型擦除带来的问题与桥接方法</h5><p>类型擦除会导致一些看似矛盾的现象，比如重写（Override）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T data)</span> &#123; <span class="built_in">this</span>.data = data; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123; <span class="built_in">this</span>.data = data; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyNode</span><span class="params">(Integer data)</span> &#123; <span class="built_in">super</span>(data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法重写了父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Integer data)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Node&lt;T&gt;</code> 擦除后，<code>setData</code> 方法的签名是 <code>setData(Object data)</code>。</li>
<li><code>MyNode</code> 中，<code>setData</code> 方法的签名是 <code>setData(Integer data)</code>。</li>
</ul>
<p>这两个方法的签名在字节码层面是不同的，不符合重写规则。为了解决这个问题，编译器会自动生成一个 <strong>桥接方法 (Bridge Method)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 MyNode 类中，编译器自动生成的桥接方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用我们自己写的、更具体的方法</span></span><br><span class="line">    setData((Integer) data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个桥接方法才是真正重写了父类的方法，它内部再调用我们自己定义的 <code>setData(Integer data)</code> 方法。</p>
<hr>
<h4 id="4-8-5-泛型的限制"><a href="#4-8-5-泛型的限制" class="headerlink" title="4.8.5 泛型的限制"></a>4.8.5 泛型的限制</h4><p>由于类型擦除，泛型有一些使用上的限制：</p>
<ol>
<li><strong>不能使用基本数据类型</strong>：不能是 <code>List&lt;int&gt;</code>，必须使用包装类 <code>List&lt;Integer&gt;</code>。</li>
<li><strong>不能创建类型参数的实例</strong>：不能 <code>new T()</code>，因为 <code>T</code> 在运行时被擦除了。<ul>
<li><strong>解决方案</strong>：通过反射创建，需要传入 <code>Class&lt;T&gt;</code> 对象。<code>T instance = clazz.newInstance();</code></li>
</ul>
</li>
<li><strong>不能声明静态字段为泛型类型</strong>：<code>private static T instance;</code> 是非法的。因为静态字段是类级别的，所有实例（<code>Box&lt;Integer&gt;</code>, <code>Box&lt;String&gt;</code>）共享同一个静态字段，类型会冲突。</li>
<li><strong>不能使用 <code>instanceof</code> 检查参数化类型</strong>：<code>if (obj instanceof List&lt;String&gt;)</code> 是非法的，因为运行时没有 <code>String</code> 的信息。<ul>
<li><strong>可以</strong>：<code>if (obj instanceof List&lt;?&gt;)</code> 或 <code>if (obj instanceof List)</code>。</li>
</ul>
</li>
<li><strong>不能创建泛型数组</strong>：<code>T[] array = new T[10];</code> 是非法的。<ul>
<li><strong>原因</strong>：Java 数组是协变的（<code>Integer[]</code> 是 <code>Number[]</code> 的子类），而泛型是不变的。如果允许创建泛型数组，会破坏类型安全（参考 <code>List&lt;Integer&gt;</code> 和 <code>List&lt;Number&gt;</code> 的例子）。</li>
<li><strong>解决方案</strong>：创建 <code>Object[]</code> 然后强转，或者使用 <code>List</code> 代替。</li>
</ul>
</li>
<li><strong>不能创建、捕获或抛出泛型异常</strong>：不能 <code>class MyException&lt;T&gt; extends Exception {}</code>。</li>
</ol>
<hr>
<h4 id="4-8-6-泛型使用的最佳实践"><a href="#4-8-6-泛型使用的最佳实践" class="headerlink" title="4.8.6 泛型使用的最佳实践"></a>4.8.6 泛型使用的最佳实践</h4><ol>
<li><strong>始终使用泛型</strong>：在代码中，尽量避免使用原始类型（如 <code>List</code>），而是使用 <code>List&lt;String&gt;</code> 等。这能让编译器帮你检查类型。</li>
<li><strong>遵循 PECS 原则</strong>：在设计 API 时，合理使用 <code>extends</code> 和 <code>super</code> 通配符，使你的方法更具灵活性。</li>
<li><strong>优先使用 <code>List</code> 而非 <code>T[]</code></strong>：<code>List</code> 在泛型支持、类型安全和功能上都优于数组。</li>
<li><strong>编程到接口</strong>：声明变量时使用接口类型，如 <code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>，而不是 <code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</code>。</li>
</ol>
<hr>
<h4 id="4-8-7-总结"><a href="#4-8-7-总结" class="headerlink" title="4.8.7 总结"></a>4.8.7 总结</h4><ul>
<li><strong>核心目的</strong>：提供编译时类型安全，避免运行时 <code>ClassCastException</code>。</li>
<li><strong>核心用法</strong>：泛型类、泛型接口、泛型方法。</li>
<li><strong>高级用法</strong>：使用通配符 <code>?</code>（<code>extends</code>, <code>super</code>）来增加 API 的灵活性，遵循 <strong>PECS</strong> 原则。</li>
<li><strong>实现机制</strong>：通过 <strong>类型擦除</strong> 实现，泛型信息在运行时不可用。</li>
<li><strong>主要限制</strong>：不能用于基本类型、不能创建 <code>T</code> 实例、不能创建泛型数组等。</li>
</ul>
<hr>
<h2 id="5-综合与对比"><a href="#5-综合与对比" class="headerlink" title="5. 综合与对比"></a>5. 综合与对比</h2><h3 id="5-1-抽象类-Abstract-Class-vs-接口-Interface"><a href="#5-1-抽象类-Abstract-Class-vs-接口-Interface" class="headerlink" title="5.1 抽象类 (Abstract Class) vs 接口 (Interface)"></a>5.1 抽象类 (Abstract Class) vs 接口 (Interface)</h3><p>自从 Java 8 引入默认方法和静态方法，以及 Java 9 引入私有方法后，接口的能力大大增强。以下是它们在现代 Java 中的对比。</p>
<table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">抽象类 (Abstract Class)</th>
<th align="left">接口 (Interface)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>设计目的</strong></td>
<td align="left">表示 <strong>“是一个 (IS-A)”</strong> 关系。代码复用，为相关类提供模板。</td>
<td align="left">表示 <strong>“具有某种能力 (CAN-DO)”</strong> 关系。定义行为契约，实现多继承。</td>
</tr>
<tr>
<td align="left"><strong>方法</strong></td>
<td align="left">可以包含<strong>抽象方法</strong>和<strong>具体实现的方法</strong>。</td>
<td align="left">Java 8以前：只能是<strong>抽象方法</strong>。 Java 8+：可包含 <strong><code>abstract</code></strong>, <strong><code>default</code></strong>, <strong><code>static</code></strong> 方法。 Java 9+：可包含 <strong><code>private</code></strong> 方法。</td>
</tr>
<tr>
<td align="left"><strong>成员变量</strong></td>
<td align="left">可以是<strong>常量</strong>、<strong>普通成员变量</strong>（各种访问权限）。</td>
<td align="left">默认且只能是 <code>public static final</code> 的<strong>常量</strong>（即静态常量）。</td>
</tr>
<tr>
<td align="left"><strong>构造器</strong></td>
<td align="left"><strong>有构造器</strong>（但不能直接实例化，用于子类初始化）。</td>
<td align="left"><strong>没有构造器</strong>。</td>
</tr>
<tr>
<td align="left"><strong>继承</strong></td>
<td align="left"><strong>单继承</strong>：一个子类只能继承<strong>一个</strong>抽象类。</td>
<td align="left"><strong>多实现</strong>：一个类可以实现<strong>多个</strong>接口。</td>
</tr>
<tr>
<td align="left"><strong>访问修饰符</strong></td>
<td align="left">方法可以使用任意访问修饰符（<code>public</code>, <code>protected</code>, <code>private</code>）。</td>
<td align="left">在 Java 9 之前，方法默认且只能是 <code>public</code>。Java 9 后 <code>private</code> 方法可用。</td>
</tr>
</tbody></table>
<p><strong>如何选择？</strong></p>
<ul>
<li>如果你要定义一些类的模板，强调代码复用和“是一个”的关系，使用<strong>抽象类</strong>。</li>
<li>如果你要定义一种行为契约，让毫不相干的类都能拥有某种能力，或者需要实现多继承，使用<strong>接口</strong>。</li>
</ul>
<hr>
<h3 id="5-2-重载-Overload-vs-重写-Override"><a href="#5-2-重载-Overload-vs-重写-Override" class="headerlink" title="5.2 重载 (Overload) vs 重写 (Override)"></a>5.2 重载 (Overload) vs 重写 (Override)</h3><table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">重载 (Overload)</th>
<th align="left">重写 (Override)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>定义</strong></td>
<td align="left">同一个类中，方法名相同，但<strong>参数列表不同</strong>。</td>
<td align="left">子类中定义一个与父类<strong>方法签名完全相同</strong>的方法。</td>
</tr>
<tr>
<td align="left"><strong>范围</strong></td>
<td align="left">发生在<strong>同一个类</strong>内部。</td>
<td align="left">发生在<strong>继承体系</strong>的子类与父类之间。</td>
</tr>
<tr>
<td align="left"><strong>参数列表</strong></td>
<td align="left"><strong>必须不同</strong>（类型、个数、顺序至少有一个不同）。</td>
<td align="left"><strong>必须完全相同</strong>。</td>
</tr>
<tr>
<td align="left"><strong>返回类型</strong></td>
<td align="left">可以相同也可以<strong>不同</strong>。</td>
<td align="left">返回类型必须<strong>相同</strong>或是父类方法返回类型的<strong>子类</strong>（协变返回类型）。</td>
</tr>
<tr>
<td align="left"><strong>异常</strong></td>
<td align="left">对抛出异常<strong>没有要求</strong>。</td>
<td align="left">子类方法抛出的异常必须和父类方法抛出的异常<strong>相同</strong>，或者是其<strong>子类</strong>，或者<strong>更少</strong>（更不通用）。</td>
</tr>
<tr>
<td align="left"><strong>访问权限</strong></td>
<td align="left">访问修饰符可以<strong>不同</strong>。</td>
<td align="left">子类方法的访问权限不能比父类方法<strong>更严格</strong>（例如，父类是<code>protected</code>，子类可以是<code>public</code>，但不能是<code>private</code>）。</td>
</tr>
<tr>
<td align="left"><strong>调用</strong></td>
<td align="left">编译器在<strong>编译期</strong>根据方法的<strong>签名（方法名+参数）</strong> 来确定调用哪个方法。</td>
<td align="left">JVM 在<strong>运行期</strong>根据对象的<strong>实际类型</strong>（而不是引用类型）来确定调用哪个方法（多态的核心）。</td>
</tr>
</tbody></table>
<p><strong>简单记忆：</strong></p>
<ul>
<li><strong>重载 (Overload)</strong>：<strong>横向</strong>的，同类之间的“多个版本”。</li>
<li><strong>重写 (Override)</strong>：<strong>纵向</strong>的，父子类之间的“覆盖更新”。</li>
</ul>
<hr>
<h3 id="5-3-和-equals-的区别"><a href="#5-3-和-equals-的区别" class="headerlink" title="5.3 == 和 equals() 的区别"></a>5.3 <code>==</code> 和 <code>equals()</code> 的区别</h3><table>
<thead>
<tr>
<th align="left">操作符&#x2F;方法</th>
<th align="left"><code>==</code></th>
<th align="left"><code>equals()</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left">是一个<strong>操作符</strong>。</td>
<td align="left">是一个<strong>方法</strong>，定义在 <code>Object</code> 类中。</td>
</tr>
<tr>
<td align="left"><strong>比较对象</strong></td>
<td align="left">比较两个变量保存的<strong>值</strong>。</td>
<td align="left">默认行为（未重写时）与 <code>==</code> 完全相同，比较两个对象的<strong>内存地址</strong>。</td>
</tr>
<tr>
<td align="left"><strong>作用</strong></td>
<td align="left">1. 比较<strong>基本数据类型</strong>：比较它们的<strong>数值</strong>是否相等。<br>2. 比较<strong>引用类型</strong>：比较两个引用是否指向<strong>同一个对象</strong>（即内存地址是否相同）。</td>
<td align="left">用于比较两个<strong>对象</strong>在<strong>逻辑上</strong>是否“相等”（例如，两个String对象的内容是否相同）。</td>
</tr>
<tr>
<td align="left"><strong>可定制性</strong></td>
<td align="left"><strong>不可定制</strong>，行为由语言本身定义。</td>
<td align="left"><strong>可重写</strong>，类可以根据自己的业务逻辑来定义怎样的两个对象才算“相等”（如<code>String</code>, <code>Integer</code>等类都已重写）。</td>
</tr>
</tbody></table>
<p><strong>核心总结：</strong></p>
<ul>
<li><code>==</code> 永远比较的是<strong>值</strong>。对于引用，这个值就是<strong>内存地址</strong>。</li>
<li><code>equals()</code> 的默认行为是比较<strong>内存地址</strong>，但可以被重写为比较<strong>对象内容</strong>。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);      <span class="comment">// false，比较地址，两个不同的对象</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true，比较内容，内容都是&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-4-值传递和引用传递：Java中只有值传递！"><a href="#5-4-值传递和引用传递：Java中只有值传递！" class="headerlink" title="5.4 值传递和引用传递：Java中只有值传递！"></a>5.4 值传递和引用传递：Java中只有值传递！</h3><p>这是一个非常重要的概念，也是常见的误解。</p>
<h4 id="5-4-1-核心结论："><a href="#5-4-1-核心结论：" class="headerlink" title="5.4.1 核心结论："></a>5.4.1 核心结论：</h4><p><strong>Java中只有值传递（Pass by Value），没有引用传递（Pass by Reference）。</strong></p>
<hr>
<h4 id="5-4-2-如何理解："><a href="#5-4-2-如何理解：" class="headerlink" title="5.4.2 如何理解："></a>5.4.2 如何理解：</h4><ol>
<li><p><strong>基本数据类型作为参数</strong>：<br>传递的是该变量的<strong>值的拷贝</strong>。在方法内部修改参数值，<strong>不会影响</strong>原始变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">changeValue</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    x = <span class="number">10</span>; <span class="comment">// 修改的是拷贝的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">changeValue(num);</span><br><span class="line">System.out.println(num); <span class="comment">// 输出 5，原始值未改变</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用数据类型（对象）作为参数</strong>：<br>传递的是该<strong>引用的值的拷贝</strong>（即对象内存地址的拷贝）。</p>
<ul>
<li>因为两个引用（原始引用和拷贝后的引用）指向的是<strong>同一个对象</strong>，所以通过这个拷贝的引用<strong>修改对象的状态</strong>（例如修改对象的成员变量），会影响到原始引用所指向的对象。</li>
<li>但是，如果试图在方法内部<strong>改变拷贝引用的指向</strong>（让它指向一个新对象），这个改变<strong>不会影响</strong>到原始的引用，原始引用依然指向原来的对象。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-4-3-示例与图解："><a href="#5-4-3-示例与图解：" class="headerlink" title="5.4.3 示例与图解："></a>5.4.3 示例与图解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 方法参数是一个MyClass类型的引用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyObject</span><span class="params">(MyClass ref)</span> &#123;</span><br><span class="line">        ref.value = <span class="number">100</span>; <span class="comment">// 动作1：通过拷贝的引用修改对象状态（有效）</span></span><br><span class="line">        ref = <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 动作2：让拷贝的引用指向一个新对象（无效！）</span></span><br><span class="line">        ref.value = <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        obj.value = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before: &quot;</span> + obj.value); <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">        modifyObject(obj);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;After: &quot;</span> + obj.value); <span class="comment">// 输出 100，而不是50或1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存图解：</strong></p>
<ol>
<li><code>main</code>方法中<code>obj</code>创建，指向对象A（<code>value=1</code>）。</li>
<li>调用<code>modifyObject(obj)</code>，将<code>obj</code>的值（对象A的地址）<strong>拷贝</strong>给形参<code>ref</code>。现在<code>obj</code>和<code>ref</code>都指向对象A。</li>
<li><strong>动作1</strong>：<code>ref.value = 100;</code> 通过<code>ref</code>找到对象A，将其<code>value</code>改为100。此时对象A的<code>value</code>变为100。</li>
<li><strong>动作2</strong>：<code>ref = new MyClass();</code> 让<code>ref</code>这个<strong>拷贝的引用</strong>指向了一个全新的对象B。<code>ref</code>和<code>obj</code>不再指向同一个对象。后续对<code>ref.value</code>的修改只影响对象B。</li>
<li>方法调用结束，形参<code>ref</code>生命周期结束被销毁。<code>obj</code>依然指向已经被修改过的对象A（<code>value=100</code>）。对象B因失去引用将被GC回收。</li>
</ol>
<p><strong>最终结论：</strong> Java中对象作为参数传递时，传递的是引用的副本（值），而不是引用本身。因此，可以修改原对象的内容，但无法让原引用指向新的对象。这完美地证明了Java是<strong>值传递</strong>。</p>
<hr>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84&%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84&%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">二、数组&字符串</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:05:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:05:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-14 15:39:31" itemprop="dateModified" datetime="2025-11-14T15:39:31+08:00">2025-11-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="二、数组-字符串"><a href="#二、数组-字符串" class="headerlink" title="二、数组&amp;字符串"></a>二、数组&amp;字符串</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><h3 id="1-1-数组的核心特性"><a href="#1-1-数组的核心特性" class="headerlink" title="1.1 数组的核心特性"></a>1.1 数组的核心特性</h3><p><strong>定义</strong>：数组是一种用于存储<strong>固定大小的</strong>、<strong>相同类型元素</strong>的线性数据结构。</p>
<p><strong>核心特点</strong>：</p>
<ol>
<li><strong>固定长度</strong>：一旦数组被创建，其长度就不可改变。</li>
<li><strong>相同类型</strong>：数组中的所有元素必须是相同的数据类型（无论是基本类型还是引用类型）。</li>
<li><strong>内存连续</strong>：数组在内存中占据一块连续的空间，这使得通过索引访问元素非常高效（时间复杂度为 O(1)）。</li>
<li><strong>索引访问</strong>：每个元素都有一个从 0 开始的数字索引，通过索引可以快速访问或修改对应的元素。</li>
<li><strong>是对象</strong>：在 Java 中，数组是<strong>对象</strong>（即使它存储的是基本数据类型）。它继承自 <code>Object</code> 类，具有 <code>length</code> 等属性和方法。</li>
</ol>
<hr>
<h3 id="1-2-数组的声明与初始化"><a href="#1-2-数组的声明与初始化" class="headerlink" title="1.2 数组的声明与初始化"></a>1.2 数组的声明与初始化</h3><h4 id="1-2-1-声明数组"><a href="#1-2-1-声明数组" class="headerlink" title="1.2.1 声明数组"></a>1.2.1 声明数组</h4><p>声明数组时，并不分配内存，只是告诉编译器数组的类型和名称。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐写法： 类型[] 数组名;</span></span><br><span class="line"><span class="type">int</span>[] myArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以（C风格，不推荐）： 类型 数组名[];</span></span><br><span class="line"><span class="type">int</span> myArray[];</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-2-初始化数组"><a href="#1-2-2-初始化数组" class="headerlink" title="1.2.2 初始化数组"></a>1.2.2 初始化数组</h4><p>初始化是为数组分配内存并可能赋予初始值的过程。</p>
<p><strong>方式一：静态初始化（声明的同时直接赋值）</strong></p>
<p>在声明数组的同时，直接给出所有元素的值。由编译器决定数组长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整格式</span></span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化格式（最常用）</span></span><br><span class="line"><span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">String[] names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方式二：动态初始化（先声明，再使用 <code>new</code> 分配空间）</strong></p>
<p>只指定数组的长度，系统会自动为每个元素分配默认值。</p>
<ul>
<li>整数类型（<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>）：默认值 <code>0</code></li>
<li>浮点类型（<code>float</code>, <code>double</code>）：默认值 <code>0.0</code></li>
<li>字符类型（<code>char</code>）：默认值 <code>&#39;\u0000&#39;</code> (空字符)</li>
<li>布尔类型（<code>boolean</code>）：默认值 <code>false</code></li>
<li>引用类型（<code>String</code>, 自定义类等）：默认值 <code>null</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法： 数组名 = new 类型[数组长度];</span></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 创建一个长度为5的int数组，所有元素初始为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明和分配空间合二为一</span></span><br><span class="line"><span class="type">int</span>[] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// &#123;0, 0, 0, 0, 0&#125;</span></span><br><span class="line">String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>]; <span class="comment">// &#123;null, null, null&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-数组的访问与遍历"><a href="#1-3-数组的访问与遍历" class="headerlink" title="1.3 数组的访问与遍历"></a>1.3 数组的访问与遍历</h3><h4 id="1-3-1-访问元素"><a href="#1-3-1-访问元素" class="headerlink" title="1.3.1 访问元素"></a>1.3.1 访问元素</h4><p>通过<strong>索引</strong>（下标）访问，索引范围从 <code>0</code> 到 <code>数组长度 - 1</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] scores = &#123;<span class="number">90</span>, <span class="number">85</span>, <span class="number">78</span>, <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">firstScore</span> <span class="operator">=</span> scores[<span class="number">0</span>]; <span class="comment">// 获取第一个元素：90</span></span><br><span class="line">scores[<span class="number">1</span>] = <span class="number">95</span>; <span class="comment">// 修改第二个元素为95</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// System.out.println(scores[4]); // 错误！ArrayIndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-3-2-遍历数组"><a href="#1-3-2-遍历数组" class="headerlink" title="1.3.2 遍历数组"></a>1.3.2 遍历数组</h4><p><strong>1. for 循环（最常用，可控索引）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; scores.length; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + scores[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 增强 for 循环（for-each，只读遍历）</strong><br>	语法更简洁，但无法获取当前元素的索引，也无法修改数组元素（对于基本数据类型）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> score : scores) &#123;</span><br><span class="line">    System.out.println(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用 <code>Arrays.toString()</code>（快速打印）</strong><br>	<code>java.util.Arrays</code> 工具类提供了方便的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(scores)); </span><br><span class="line"><span class="comment">// 输出：[90, 95, 78, 100]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-4-多维数组"><a href="#1-4-多维数组" class="headerlink" title="1.4 多维数组"></a>1.4 多维数组</h3><p>多维数组本质上是“数组的数组”，最常见的是二维数组。</p>
<h4 id="1-4-1-声明和初始化"><a href="#1-4-1-声明和初始化" class="headerlink" title="1.4.1 声明和初始化"></a>1.4.1 声明和初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态初始化（不规则数组）</span></span><br><span class="line"><span class="type">int</span>[][] arr2D = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][]; <span class="comment">// 先确定第一维（行）的长度</span></span><br><span class="line">arr2D[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; <span class="comment">// 第一行有2列</span></span><br><span class="line">arr2D[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">// 第二行有3列</span></span><br><span class="line">arr2D[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>]; <span class="comment">// 第三行有1列</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-4-2-访问与遍历"><a href="#1-4-2-访问与遍历" class="headerlink" title="1.4.2 访问与遍历"></a>1.4.2 访问与遍历</h4><p>需要使用嵌套循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123; <span class="comment">// 遍历行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123; <span class="comment">// 遍历当前行的每一列</span></span><br><span class="line">        System.out.print(matrix[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 1 2 3 </span></span><br><span class="line"><span class="comment">// 4 5 6 </span></span><br><span class="line"><span class="comment">// 7 8 9 </span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-4-3-注意事项"><a href="#1-4-3-注意事项" class="headerlink" title="1.4.3 注意事项"></a>1.4.3 注意事项</h4><p>在处理多维数组时，尽量<strong>将内存访问模式与数据存储顺序对齐</strong></p>
<p>例如：二维数组将每个元素+1；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10000</span>][<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先行后列访问</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">            array[i][j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;先行后列访问时间：&quot;</span> + (endTime - startTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先列后行访问</span></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            array[i][j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;先列后行访问时间：&quot;</span> + (endTime - startTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先行后列访问时间：54毫秒</span></span><br><span class="line"><span class="comment">// 先列后行访问时间：1075毫秒</span></span><br></pre></td></tr></table></figure>

<p>可以发现速度差的不是一点，原因在于：</p>
<ol>
<li>二维数组 <code>int[10000][10000]</code> 在内存中被分配为<strong>连续块</strong>，但实际是由多个一维数组（每个行是一个一维数组）组成的。</li>
<li><strong>CPU缓存会预加载连续内存地址的数据</strong>（缓存行通常为64字节）。当按行访问时（<code>array[i][j]</code> 中 <code>i</code> 固定，<code>j</code> 连续变化），每次访问的元素在内存中是相邻的，缓存命中率高。</li>
<li><strong>按列访问时（<code>j</code> 固定，<code>i</code> 变化）</strong>，每次访问的元素间隔很大（间隔 <code>10000 * sizeof(int)</code> 字节），导致缓存无法有效预加载，频繁发生<strong>缓存未命中</strong>，需要从主内存读取数据，速度大幅下降。</li>
</ol>
<hr>
<h3 id="1-5-数组的常用操作与工具类-Arrays"><a href="#1-5-数组的常用操作与工具类-Arrays" class="headerlink" title="1.5 数组的常用操作与工具类 Arrays"></a>1.5 数组的常用操作与工具类 <code>Arrays</code></h3><p>Java 提供了 <code>java.util.Arrays</code> 工具类，包含大量操作数组的静态方法，非常实用。</p>
<ol>
<li><p><strong>排序：<code>Arrays.sort()</code></strong></p>
<p>**底层：**双轴快速排序(Dual-Pivot Quicksort)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Arrays.sort(numbers); <span class="comment">// 数组变为 [1, 3, 5, 8]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查找：<code>Arrays.binarySearch()</code></strong><br><strong>注意：使用前必须先对数组进行排序！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">5</span>); <span class="comment">// 返回元素5的索引：2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">notFound</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">10</span>); <span class="comment">// 返回负数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>填充：<code>Arrays.fill()</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(arr, <span class="number">100</span>); <span class="comment">// 将数组所有元素填充为100 -&gt; [100,100,100,100,100]</span></span><br><span class="line">Arrays.fill(arr, <span class="number">1</span>, <span class="number">3</span>, <span class="number">50</span>); <span class="comment">// 将索引[1,3)的元素填充为50 -&gt; [100,50,50,100,100]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>比较：<code>Arrays.equals()</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> Arrays.equals(a, b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复制：<code>Arrays.copyOf()</code> &#x2F; <code>Arrays.copyOfRange()</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] original = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] copyAll = Arrays.copyOf(original, original.length); <span class="comment">// 复制整个数组</span></span><br><span class="line"><span class="type">int</span>[] copyPart = Arrays.copyOfRange(original, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 复制索引[1,3) -&gt; [2,3]</span></span><br><span class="line"><span class="type">int</span>[] biggerCopy = Arrays.copyOf(original, <span class="number">10</span>); <span class="comment">// 新数组长度为10，多出的元素为默认值0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层是 System.arraycopy() 平时经常使用Arrays提供的更抽象的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      src      源数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      srcPos   源数组中的起始复制位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      dest     目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      destPos  目标数据中的起始粘贴位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      length   要复制的数组元素的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     如果复制操作会导致访问数组边界之外的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     如果因为类型不匹配，src 数组中的某个元素无法存储到 dest 数组中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     如果 src 或 dest 为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// @IntrinsicCandidate 表明此方法是一个“内在候选者”，意味着JVM可能会使用高度优化的机器代码来替代原本的Java实现，以极大地提升其性能</span></span><br><span class="line"><span class="meta">@IntrinsicCandidate</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,</span></span><br><span class="line"><span class="params">                                    Object dest, <span class="type">int</span> destPos,</span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转换为字符串：<code>Arrays.toString()</code> &#x2F; <code>Arrays.deepToString()</code></strong><br><code>deepToString()</code> 用于打印多维数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] deepArray = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.toString(deepArray)); <span class="comment">// 输出[[I@1db9742, [I@106d69c]</span></span><br><span class="line">System.out.println(Arrays.deepToString(deepArray)); <span class="comment">// 输出[[1, 2], [3, 4]]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-6-数组的注意事项与常见错误"><a href="#1-6-数组的注意事项与常见错误" class="headerlink" title="1.6 数组的注意事项与常见错误"></a>1.6 数组的注意事项与常见错误</h3><ol>
<li><p><strong><code>ArrayIndexOutOfBoundsException</code>（数组越界异常）</strong><br>这是最常见的运行时错误。访问了不存在的索引（如 <code>index &lt; 0</code> 或 <code>index &gt;= array.length</code>）。</p>
</li>
<li><p><strong><code>NullPointerException</code>（空指针异常）</strong><br>数组是引用类型，如果只是声明了数组引用但未初始化（<code>int[] arr = null;</code>），此时访问 <code>arr[0]</code> 或 <code>arr.length</code> 就会抛出此异常。</p>
</li>
<li><p><strong>长度不可变</strong><br>数组一旦创建，大小就固定了。如果需要动态扩容，需要手动创建新数组并拷贝数据（<code>Arrays.copyOf()</code> 内部就是这么做的），或者使用更高级的集合类（如 <code>ArrayList</code>）。</p>
</li>
<li><p><strong>数组作为参数传递</strong><br>数组是对象，所以作为参数传递给方法时，传递的是<strong>引用（地址）的副本</strong>。这意味着在方法内部修改数组的元素内容，会影响到原始的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">100</span>; <span class="comment">// 这会改变原始数组的第一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h2><h3 id="2-1-使用"><a href="#2-1-使用" class="headerlink" title="2.1 使用"></a>2.1 使用</h3><h4 id="2-1-1-创建-String-对象"><a href="#2-1-1-创建-String-对象" class="headerlink" title="2.1.1 创建 String 对象"></a>2.1.1 创建 String 对象</h4><p>主要有两种方式：</p>
<ul>
<li><p><strong>通过字面量直接创建（最常用）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这种方式会优先检查字符串常量池（String Constant Pool），如果池中已有相同内容的字符串，则直接返回其引用；如果没有，则在池中创建一个新的字符串对象再返回引用。<strong>这种方式能利用常量池，避免重复创建对象，节省内存。</strong></p>
</li>
<li><p><strong>通过 <code>new</code> 关键字创建</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种方式会<strong>强制</strong>在堆内存（Heap）中创建一个新的、独立的 <code>String</code> 对象，无论常量池中是否已存在相同内容的字符串。通常不推荐这样使用，除非有特殊需求。</p>
</li>
</ul>
<hr>
<h4 id="2-1-2-字符串的基本操作"><a href="#2-1-2-字符串的基本操作" class="headerlink" title="2.1.2 字符串的基本操作"></a>2.1.2 字符串的基本操作</h4><p><code>String</code> 类提供了极其丰富的方法来操作字符串：</p>
<ul>
<li><p><strong>获取信息</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取长度</span></span><br><span class="line"><span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>); <span class="comment">// &#x27;J&#x27;，获取指定位置的字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串比较</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual1</span> <span class="operator">=</span> (a == b); <span class="comment">// false，比较的是对象内存地址</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual2</span> <span class="operator">=</span> a.equals(b); <span class="comment">// true，比较的是字符串内容（重要！）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual3</span> <span class="operator">=</span> a.equalsIgnoreCase(<span class="string">&quot;JAVA&quot;</span>); <span class="comment">// true，忽略大小写比较内容</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串查找</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;I love Java!&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> text.contains(<span class="string">&quot;love&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> text.indexOf(<span class="string">&quot;Java&quot;</span>); <span class="comment">// 返回首次出现的索引</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> text.lastIndexOf(<span class="string">&quot;a&quot;</span>); <span class="comment">// 返回最后一次出现的索引</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">starts</span> <span class="operator">=</span> text.startsWith(<span class="string">&quot;I&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">ends</span> <span class="operator">=</span> text.endsWith(<span class="string">&quot;!&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串截取与分割</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;usr/local/bin&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">sub1</span> <span class="operator">=</span> path.substring(<span class="number">4</span>); <span class="comment">// &quot;local/bin&quot;，从索引4开始到末尾</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sub2</span> <span class="operator">=</span> path.substring(<span class="number">4</span>, <span class="number">9</span>); <span class="comment">// &quot;local&quot;，从索引4到索引9（不含）</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;apple,orange,banana&quot;</span>;</span><br><span class="line">String[] fruits = data.split(<span class="string">&quot;,&quot;</span>); <span class="comment">// [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]，按逗号分割</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串替换</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">oldStr</span> <span class="operator">=</span> <span class="string">&quot;I like C.&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> oldStr.replace(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;Java&quot;</span>); <span class="comment">// &quot;I like Java.&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>大小写转换</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">mixed</span> <span class="operator">=</span> <span class="string">&quot;HeLLo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">lower</span> <span class="operator">=</span> mixed.toLowerCase(); <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">upper</span> <span class="operator">=</span> mixed.toUpperCase(); <span class="comment">// &quot;HELLO&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>去除首尾空白字符</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">withSpaces</span> <span class="operator">=</span> <span class="string">&quot;  Hello World  &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">trimmed</span> <span class="operator">=</span> withSpaces.trim(); <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">// JDK 11+ 提供了 strip()，功能更强，能去除所有Unicode空白字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串拼接</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 + 运算符（最方便，但大量循环拼接时性能差）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 concat() 方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>.concat(<span class="string">&quot; Smith&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 高性能场景使用 StringBuilder 或 StringBuffer</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot; &quot;</span>).append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-2-底层机制详解"><a href="#2-2-底层机制详解" class="headerlink" title="2.2 底层机制详解"></a>2.2 底层机制详解</h3><h4 id="2-2-1-字符串的创建与内存分配（深入常量池）"><a href="#2-2-1-字符串的创建与内存分配（深入常量池）" class="headerlink" title="2.2.1 字符串的创建与内存分配（深入常量池）"></a>2.2.1 字符串的创建与内存分配（深入常量池）</h4><p>创建 <code>String</code> 对象主要有两种方式，它们在内存分配上有根本区别，核心在于<strong>字符串常量池 (String Constant Pool)</strong>。</p>
<ul>
<li><p><strong>字面量方式 (String Literal)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>机制</strong>：JVM 会首先检查字符串常量池中是否存在内容为 <code>&quot;hello&quot;</code> 的字符串对象的<strong>引用</strong>。<ul>
<li><strong>如果存在</strong>：则 <code>s1</code> 直接指向池中的那个引用，<strong>不会创建新对象</strong>。</li>
<li><strong>如果不存在</strong>：则在 <strong>堆 (Heap)</strong> 上创建一个新的 <code>String</code> 对象，然后将其<strong>引用</strong>保存在字符串常量池中，最后让 <code>s1</code> 指向这个引用。</li>
</ul>
</li>
<li><strong>结论</strong>：<code>s1 == s2</code> 为 <code>true</code>，因为它们指向<strong>同一个内存地址</strong>（常量池中的同一个引用）。这是实现字符串复用的关键。</li>
</ul>
</li>
<li><p><strong><code>new</code> 关键字方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>机制</strong>：<ol>
<li><code>&quot;hello&quot;</code> 这个字面量会首先按照上述规则在常量池中查找或创建。</li>
<li><code>new</code> 关键字会<strong>强制</strong>在 Java <strong>堆</strong>上创建一个全新的、独立的 <code>String</code> 对象。这个新对象的内部字符数组（<code>value</code>）可能会指向池中对象的字符数组，也可能拷贝一份（取决于JDK版本和实现优化）。</li>
</ol>
</li>
<li><strong>结论</strong>：<code>s3 == s4</code> 为 <code>false</code>，因为它们是堆上两个不同的对象。但 <code>s3.equals(s4)</code> 为 <code>true</code>，因为内容相同。</li>
</ul>
</li>
<li><p><strong>拼接字符串的特殊情况</strong><br><strong>针对没有使用双引号声明的字符串对象来说</strong>，即通过 <code>new</code> 和拼接操作在运行时动态创建的字符串，<strong>不会自动放入字符串常量池</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该操作会在堆上创建多个对象，但&quot;hello&quot;和&quot;world&quot;会进入常量池，而最终结果&quot;helloworld&quot;不会自动入池。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">// 此时，字符串常量池中有&quot;hello&quot;和&quot;world&quot;，但没有&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>如果想把 s1 的内容也放入字符串常量池的话，可以调用 <code>intern()</code> 方法来完成。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = s1.intern(); <span class="comment">// 将&quot;helloworld&quot;的引用存入常量池并返回</span></span><br><span class="line"><span class="comment">// 之后，任何直接使用字面量 &quot;helloworld&quot; 的声明都将指向这个池中的引用。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-2-intern-方法：手动入池"><a href="#2-2-2-intern-方法：手动入池" class="headerlink" title="2.2.2 intern() 方法：手动入池"></a>2.2.2 <code>intern()</code> 方法：手动入池</h4><p>这是一个 <code>native</code> 方法，用于手动将运行时动态创建的字符串添加到常量池。</p>
<ul>
<li><strong>作用</strong>：调用 <code>s.intern()</code> 时，JVM 会：<ol>
<li>检查常量池中是否有与 <code>s</code> 内容相同的字符串的引用。</li>
<li><strong>如果存在</strong>，则直接返回池中的那个引用。</li>
<li><strong>如果不存在（对于动态创建的字符串，这是常见情况）</strong>：在 JDK 1.7+ 之后，会将 <strong><code>s</code> 自身在堆中的引用</strong>添加到常量池中，然后返回这个引用。（在 JDK 1.6 及之前，是拷贝一份字符串对象到永久代）。</li>
</ol>
</li>
<li><strong>目的</strong>：可以将运行时动态生成（如通过 <code>new</code>、<code>StringBuilder</code> 拼接等）的字符串也纳入池化管理，后续就可以通过字面量或 <code>intern()</code> 来复用这个对象，节省内存。<strong>这是将拼接字符串加入常量池的标准方法。</strong></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>); <span class="comment">// s1 指向堆中的 &quot;helloworld&quot; 对象，池中无此引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>; <span class="comment">// 池中没有，因此在堆上创建新对象，引用放入池中，s2指向它</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();  <span class="comment">// JDK7+: 尝试将s1的引用放入常量池。发现池中已有s2的引用(内容相同)，因此返回s2的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>; <span class="comment">// s4 直接指向池中已有的引用（即s2的引用）</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false, 两个不同的堆对象</span></span><br><span class="line">System.out.println(s2 == s3); <span class="comment">// true, s3得到的是池中s2的引用</span></span><br><span class="line">System.out.println(s2 == s4); <span class="comment">// true, 都指向池中的同一个引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;java&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;script&quot;</span>); <span class="comment">// 堆中创建&quot;javascript&quot;，池中无</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s5.intern(); <span class="comment">// JDK7+: 池中无此字符串，将s5的引用放入池中，并返回s5的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;javascript&quot;</span>; <span class="comment">// 池中已有(s5的引用)，直接返回该引用</span></span><br><span class="line"></span><br><span class="line">System.out.println(s5 == s6); <span class="comment">// true! 因为s6得到的就是s5自身的引用</span></span><br><span class="line">System.out.println(s5 == s7); <span class="comment">// true! 因为s7从池中拿到的是s5的引用</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-3-字符串常量池的位置演变"><a href="#2-2-3-字符串常量池的位置演变" class="headerlink" title="2.2.3 字符串常量池的位置演变"></a>2.2.3 字符串常量池的位置演变</h4><ul>
<li><strong>JDK 1.6 及以前</strong>：位于<strong>方法区 (Method Area)</strong>，具体实现是<strong>永久代 (PermGen)</strong>。<ul>
<li><strong>问题</strong>：永久代大小有限且难以调整，容易发生 <code>OutOfMemoryError: PermGen space</code>。且该区域的垃圾回收效率不高。</li>
</ul>
</li>
<li><strong>JDK 1.7</strong>：<strong>字符串常量池被移到了堆 (Heap) 中</strong>。<ul>
<li><strong>好处</strong>：堆内存更大，且由垃圾回收器统一管理。即使字符串不再被引用，也可以从池中回收，避免了内存泄漏问题。</li>
</ul>
</li>
<li><strong>JDK 1.8 及以后</strong>：<strong>永久代 (PermGen) 被彻底移除</strong>，取而代之的是<strong>元空间 (Metaspace)</strong>。<strong>字符串常量池仍在堆中</strong>。类元信息、方法信息等移到了元空间。<ul>
<li><strong>好处</strong>：元空间使用本地内存，默认情况下只受本机可用内存限制，极大减少了 <code>OutOfMemoryError</code> 的风险。</li>
</ul>
</li>
</ul>
<p><strong>总结关系</strong>：</p>
<ul>
<li><strong>方法区</strong>是 JVM 规范定义的一个逻辑概念&#x2F;内存区域。</li>
<li><strong>永久代</strong>是 HotSpot 虚拟机对方法区的一种实现（JDK 8之前）。</li>
<li><strong>元空间</strong>是 HotSpot 虚拟机对方法区的另一种实现（JDK 8+），位于本地内存。</li>
<li><strong>字符串常量池</strong>在物理上，从 JDK 7 开始就存在于<strong>堆内存</strong>中。</li>
</ul>
<hr>
<h4 id="2-2-4-String-的不可变性-Immutability"><a href="#2-2-4-String-的不可变性-Immutability" class="headerlink" title="2.2.4 String 的不可变性 (Immutability)"></a>2.2.4 String 的不可变性 (Immutability)</h4><p>这是 <code>String</code> 类设计的基石。</p>
<ul>
<li><strong>如何实现？</strong> <ol>
<li><strong><code>final</code> 类</strong>：防止被继承，从而被子类重写方法破坏不可变性。</li>
<li><strong><code>private final byte[] value</code> (JDK9+) &#x2F; <code>char[] value</code> (JDK8-)</strong>：<code>private</code> 阻止了外部直接访问，<code>final</code> 确保了数组引用不可变（但不能阻止数组元素被改，所以需要第3点）。</li>
<li><strong>无修改内部状态的方法</strong>：所有看似修改的方法（如 <code>concat</code>, <code>replace</code>）内部都返回一个<strong>新创建的 <code>String</code> 对象</strong>。</li>
</ol>
</li>
<li><strong>为何如此设计？</strong><ol>
<li><strong>安全</strong>：广泛用于类加载、网络连接、文件路径等。若可变，可能被恶意修改，造成安全漏洞。也保证了 <code>HashSet&lt;String&gt;</code>、<code>HashMap&lt;String, ...&gt;</code> 等集合键值的稳定性。</li>
<li><strong>线程安全</strong>：不可变对象天生线程安全，可在多线程间无忧共享。</li>
<li><strong>支持常量池</strong>：只有不变，才能让多个引用放心地指向同一个对象。</li>
<li><strong>性能</strong>：缓存哈希码（<code>hashCode</code>），作为 <code>HashMap</code> 的键时效率极高。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-2-5-JDK-9-的底层优化：byte-coder"><a href="#2-2-5-JDK-9-的底层优化：byte-coder" class="headerlink" title="2.2.5 JDK 9 的底层优化：byte[] + coder"></a>2.2.5 JDK 9 的底层优化：<code>byte[]</code> + <code>coder</code></h4><ul>
<li><p><strong>背景</strong>：在 JDK 8 及以前，<code>String</code> 使用 <code>char[]</code>（每个 <code>char</code> 2字节）存储数据。但大量实际应用（如JSON、XML、HTTP头）中的字符串仅包含 <strong>Latin-1</strong> 字符（如英文、数字），这些字符只需 <strong>1 字节</strong>即可表示。使用 <code>char[]</code> 存储造成了近 <strong>50%</strong> 的空间浪费。</p>
</li>
<li><p><strong>优化</strong>：JDK 9 将内部存储改为 <code>byte[]</code>，并引入了一个编码标志字段 <code>coder</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value; <span class="comment">// 存储字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;   <span class="comment">// 0 代表 Latin-1，1 代表 UTF-16</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当字符串全部是 Latin-1 字符时，<code>coder = 0</code>，<code>value</code> 数组紧凑地存储每个字符的1字节编码。</li>
<li>当字符串包含任何非 Latin-1 字符（如中文）时，<code>coder = 1</code>，<code>value</code> 数组改用 UTF-16 编码（每个字符通常占2或4字节）。</li>
</ul>
</li>
<li><p><strong>好处</strong>：</p>
<ul>
<li><strong>显著减少内存占用</strong>：对大量西方语言文本，内存占用大幅降低。</li>
<li><strong>减少 GC 压力</strong>：对象体积变小，内存分配和回收的效率更高。</li>
</ul>
</li>
<li><p><strong>对开发者的影响</strong>：<strong>完全透明</strong>。这是一项底层实现优化，所有 <code>String</code> 的公共API和行为没有任何变化，现有代码无需任何修改即可获益。</p>
</li>
</ul>
<hr>
<h3 id="2-3-StringBuilder、StringBuffer和StringJoiner"><a href="#2-3-StringBuilder、StringBuffer和StringJoiner" class="headerlink" title="2.3 StringBuilder、StringBuffer和StringJoiner"></a>2.3 StringBuilder、StringBuffer和StringJoiner</h3><h4 id="2-3-1-StringBuilder"><a href="#2-3-1-StringBuilder" class="headerlink" title="2.3.1 StringBuilder"></a>2.3.1 StringBuilder</h4><p><code>StringBuilder</code> 是一个可变的字符序列，用于高效地进行字符串的拼接、插入、删除等操作。它是对 <code>String</code> 不可变性的重要补充，解决了频繁修改字符串时产生的性能问题。</p>
<h5 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h5><ol>
<li><strong>可变性 (Mutability)</strong>：内部维护一个可变的字符数组（JDK9 后同为 <code>byte[]</code>），修改操作（如 <code>append</code>, <code>insert</code>）都是在原有对象上进行的，不会创建大量新的临时对象。</li>
<li><strong>非线程安全 (Not Thread-Safe)</strong>：它的方法<strong>没有</strong>使用 <code>synchronized</code> 关键字修饰。因此，它在单线程环境下性能最高，但在多线程环境下同时修改可能会导致数据不一致。</li>
<li><strong>高性能</strong>：由于避免了同步开销和大量对象的创建，它在单线程下的字符串操作性能是最优的。</li>
</ol>
<h5 id="主要构造方法"><a href="#主要构造方法" class="headerlink" title="主要构造方法"></a>主要构造方法</h5><ul>
<li><code>StringBuilder()</code>：构造一个空容器，初始容量为 <strong>16</strong> 个字符。</li>
<li><code>StringBuilder(int capacity)</code>：构造一个指定初始容量的空容器。</li>
<li><code>StringBuilder(String str)</code>：构造一个初始化为指定字符串内容的容器。</li>
</ul>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li><code>append(xxx)</code>：最核心的方法，支持重载多种数据类型（<code>String</code>, <code>int</code>, <code>char</code>, <code>Object</code>…），将其追加到序列末尾。</li>
<li><code>insert(int offset, xxx)</code>：在指定位置插入数据。</li>
<li><code>delete(int start, int end)</code>：删除子序列。</li>
<li><code>replace(int start, int end, String str)</code>：替换子序列。</li>
<li><code>reverse()</code>：将此字符序列反转。</li>
<li><code>toString()</code>：将当前容器中的字符序列转换为一个 <code>String</code> 对象。</li>
<li><code>length()</code>：返回长度（字符数）。</li>
<li><code>capacity()</code>：返回当前容器的总容量。</li>
</ul>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p><strong>几乎所有需要进行字符串拼接、修改的场景，尤其是在循环体内。</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在循环中拼接字符串，必须使用StringBuilder</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sb.append(i).append(<span class="string">&quot;, &quot;</span>); <span class="comment">// 链式调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">System.out.println(result); <span class="comment">// 输出: 0, 1, 2, ..., 99,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他操作</span></span><br><span class="line">sb.insert(<span class="number">0</span>, <span class="string">&quot;Start: &quot;</span>); <span class="comment">// 在开头插入</span></span><br><span class="line">sb.replace(sb.length()-<span class="number">2</span>, sb.length(), <span class="string">&quot;. End&quot;</span>); <span class="comment">// 替换最后的逗号和空格</span></span><br><span class="line">System.out.println(sb.toString()); <span class="comment">// 输出: Start: 0, 1, 2, ..., 99. End</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-2-StringBuffer"><a href="#2-3-2-StringBuffer" class="headerlink" title="2.3.2 StringBuffer"></a>2.3.2 StringBuffer</h4><p><code>StringBuffer</code> 可以看作是 <code>StringBuilder</code> 的线程安全版本。它们在 API 和功能上几乎是完全一致的。</p>
<h5 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a>核心特性</h5><ol>
<li><strong>可变性 (Mutability)</strong>：与 <code>StringBuilder</code> 相同。</li>
<li><strong>线程安全 (Thread-Safe)</strong>：它的关键方法（如 <code>append</code>）都使用了 <strong><code>synchronized</code></strong> 关键字修饰，保证了多个线程无法同时修改它。因此，它是线程安全的。</li>
<li><strong>性能较低</strong>：由于同步锁的获取和释放会带来额外的开销，它的性能在单线程环境下通常低于 <code>StringBuilder</code>。</li>
</ol>
<h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><p><strong>需要在多线程环境下对同一个字符串序列进行修改的场景。</strong> 但由于现代开发中，多个线程竞争同一资源的情况相对较少，或者可以通过其他同步机制（如 <code>ThreadLocal</code>）来避免，<code>StringBuffer</code> 的使用频率已远低于 <code>StringBuilder</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;ThreadSafe&quot;</span>);</span><br><span class="line"><span class="comment">// 用法与StringBuilder完全一样</span></span><br><span class="line">sBuffer.append(<span class="string">&quot; String&quot;</span>).append(<span class="string">&quot; Buffer&quot;</span>);</span><br><span class="line">System.out.println(sBuffer.toString()); <span class="comment">// 输出: ThreadSafe String Buffer</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-3-StringJoiner"><a href="#2-3-3-StringJoiner" class="headerlink" title="2.3.3 StringJoiner"></a>2.3.3 StringJoiner</h4><p><code>StringJoiner</code> 是 Java 8 引入的一个专门用于<strong>构造由分隔符分隔的字符序列</strong>的实用工具类。它极大地简化了拼接带有固定分隔符（如逗号、冒号）的字符串序列的操作。</p>
<h5 id="核心特性-2"><a href="#核心特性-2" class="headerlink" title="核心特性"></a>核心特性</h5><ol>
<li><strong>目的明确</strong>：专为拼接带有<strong>分隔符 (Delimiter)</strong>、<strong>前缀 (Prefix)</strong> 和<strong>后缀 (Suffix)</strong> 的序列而设计。</li>
<li><strong>底层实现</strong>：其内部通常使用 <code>StringBuilder</code> 来高效完成拼接。</li>
<li><strong>与 Stream API 无缝集成</strong>：<code>Collectors.joining()</code> 方法内部就使用了 <code>StringJoiner</code>，使其在流操作中极为方便。</li>
</ol>
<h5 id="主要构造方法-1"><a href="#主要构造方法-1" class="headerlink" title="主要构造方法"></a>主要构造方法</h5><ul>
<li><code>StringJoiner(CharSequence delimiter)</code>：使用指定的分隔符，无前缀后缀。</li>
<li><code>StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</code>：使用指定的分隔符、前缀和后缀。</li>
</ul>
<h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li><code>add(CharSequence newElement)</code>：添加一个新元素，它会自动在后面加上分隔符（除了最后一个元素）。</li>
<li><code>merge(StringJoiner other)</code>：合并另一个 <code>StringJoiner</code> 的内容。</li>
<li><code>toString()</code>：返回拼接好的字符串，包含前缀和后缀。</li>
</ul>
<h5 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h5><p><strong>拼接集合元素、生成 CSV 行、SQL 语句的 IN 条件、输出格式化列表等。</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 简单拼接列表</span></span><br><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    sj1.add(name);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sj1.toString()); <span class="comment">// 输出: Alice, Bob, Charlie</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 带前缀和后缀（非常实用！）</span></span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;&#x27;, &#x27;&quot;</span>, <span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"><span class="comment">// 分隔符是 &quot;&#x27;, &#x27;&quot;, 前缀是 &quot;&#x27;&quot;, 后缀是 &quot;&#x27;&quot;</span></span><br><span class="line">sj2.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">sj2.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">sj2.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">System.out.println(sj2.toString()); <span class="comment">// 输出: &#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Orange&#x27;</span></span><br><span class="line"><span class="comment">// 这非常适合拼接SQL语句：SELECT * FROM fruits WHERE name IN (&#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Orange&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 与Stream API结合（最优雅的方式）</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                       .map(String::valueOf)</span><br><span class="line">                       .collect(Collectors.joining(<span class="string">&quot; - &quot;</span>, <span class="string">&quot;[ &quot;</span>, <span class="string">&quot; ]&quot;</span>));</span><br><span class="line">System.out.println(result); <span class="comment">// 输出: [ 1 - 2 - 3 - 4 ]</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-4-对比总结与选择指南"><a href="#2-3-4-对比总结与选择指南" class="headerlink" title="2.3.4 对比总结与选择指南"></a>2.3.4 对比总结与选择指南</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">StringBuilder</th>
<th align="left">StringBuffer</th>
<th align="left">StringJoiner</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可变性</strong></td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是（内部基于StringBuilder）</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong>（ synchronized ）</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>高</strong>（单线程）</td>
<td align="left">较低（因同步开销）</td>
<td align="left">高（专用场景）</td>
</tr>
<tr>
<td align="left"><strong>主要用途</strong></td>
<td align="left"><strong>通用字符串拼接与修改</strong></td>
<td align="left"><strong>多线程下的字符串拼接与修改</strong></td>
<td align="left"><strong>拼接带分隔符、前缀后缀的序列</strong></td>
</tr>
<tr>
<td align="left"><strong>引入版本</strong></td>
<td align="left">Java 5</td>
<td align="left">Java 1.0</td>
<td align="left">Java 8</td>
</tr>
</tbody></table>
<h5 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a><strong>如何选择？</strong></h5><ol>
<li><strong><code>StringBuilder</code></strong>：<strong>默认选择</strong>。适用于 99% 的字符串拼接和修改场景，尤其是在循环、方法内部等单线程环境下。</li>
<li><strong><code>StringBuffer</code></strong>：<strong>非常罕见</strong>。仅在需要在线程间共享并修改<strong>同一个</strong> <code>StringBuffer</code> 对象时使用。通常可以被 <code>StringBuilder</code> 配合其他同步机制替代。</li>
<li><strong><code>StringJoiner</code></strong>：<strong>目的驱动</strong>。当你需要拼接一个带有<strong>固定分隔符</strong>的列表，特别是还需要<strong>前缀和后缀</strong>时，它就是最清晰、最优雅的选择。与 Java 8 Stream API 是天作之合。</li>
</ol>
<p><strong>一句话总结：单线程拼接用 <code>StringBuilder</code>，要格式化成串用 <code>StringJoiner</code>，<code>StringBuffer</code> 基本被遗忘。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
