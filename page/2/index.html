<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="冉的技术宝典">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">冉的技术宝典</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/18/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/WebSocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/18/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/WebSocket/" class="post-title-link" itemprop="url">WebSocket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-18 11:22:31" itemprop="dateCreated datePublished" datetime="2025-10-18T11:22:31+08:00">2025-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 09:38:51" itemprop="dateModified" datetime="2025-10-21T09:38:51+08:00">2025-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、-实时通信的演进"><a href="#一、-实时通信的演进" class="headerlink" title="一、 实时通信的演进"></a>一、 实时通信的演进</h1><h2 id="1-HTTP-的无状态性"><a href="#1-HTTP-的无状态性" class="headerlink" title="1. HTTP 的无状态性"></a>1. HTTP 的无状态性</h2><p>我们在”HTTP协议“这一笔  记中介绍了HTTP的核心特点<strong>无状态</strong>，这里简单回顾一下</p>
<ul>
<li><strong>定义</strong>：“无状态”指的是<strong>协议本身对于事务处理没有记忆能力</strong>。每一次 HTTP 请求都是完全独立的，服务器不会保留前一次请求的任何信息。</li>
<li>**优点 **：<ul>
<li><strong>简化服务器设计</strong>：服务器不需要花费额外的资源（如内存）来存储海量的客户端状态信息。</li>
<li><strong>提升服务器的可伸缩性</strong>：由于服务器不存储状态，任何一台服务器都可以处理任何一个客户端的请求。这使得在服务器集群中做<strong>负载均衡</strong>变得非常容易。如果一台服务器宕机，请求可以无缝切换到另一台，因为新服务器不需要任何历史上下文。</li>
</ul>
</li>
<li><strong>缺点与解决方案</strong>：<ul>
<li><strong>功能受限</strong>：然而，现代 Web 应用（如购物车、用户登录）恰恰需要“记住状态”。</li>
<li><strong>解决方案</strong>：为了弥补 HTTP 的无状态性，Web 应用通过<strong>Cookie 和 Session 机制</strong>来“创造”状态。<ul>
<li><strong>Cookie</strong>: 服务器通过 <code>Set-Cookie</code> 响应头给客户端一个“通行证”（一小段文本）。</li>
<li>之后，客户端在每次请求时都会通过 <code>Cookie</code> 请求头带上这个“通行证”。</li>
<li>服务器通过检查这个“通行证”就能识别出用户，从而维持登录状态或购物车内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>HTTP 的无状态性和“客户端发起”的特性，对于需要 <strong>服务端主动推送信息</strong> 的实时应用（如在线聊天、股票行情、实时通知、游戏等）来说，就成了一个天然的障碍。</p>
<p>想象一下开发一个网页聊天室：</p>
<ul>
<li>用户 A 发送了一条消息。</li>
<li>服务器如何将这条新消息实时地告诉在线的其他用户 B 和 C？</li>
</ul>
<p>在纯粹的 HTTP 模型下，服务器无法做到这一点。因为服务器处理完 A 的“发送消息”请求后，就“忘记”了 B 和 C 的存在，它没有任何机制可以主动联系 B 和 C 并告诉他们：“嘿，有新消息了！”，虽然 <code>Cookie-Session</code> 机制解决了身份认证和会话保持的问题，但它并没有解决 <strong>服务端无法主动推送</strong> 这一根本性矛盾。</p>
<hr>
<h2 id="2-基于-HTTP-的伪实时通信"><a href="#2-基于-HTTP-的伪实时通信" class="headerlink" title="2. 基于 HTTP 的伪实时通信"></a>2. 基于 HTTP 的伪实时通信</h2><p>正如上一节所述，HTTP 的无状态性和“请求-响应”模式，天然地阻碍了服务端主动向客户端推送数据。然而，对实时性的需求是真实存在的。为了绕过这一限制，开发者们发明了一系列“模拟”实时通信的技术，它们统称为“伪实时通信”或“Comet”技术。这些方案的核心思想都是：<strong>既然服务器不能主动“推”，那就让客户端不知疲倦地“拉”</strong>。</p>
<hr>
<h3 id="2-1-短轮询-Short-Polling"><a href="#2-1-短轮询-Short-Polling" class="headerlink" title="2.1 短轮询 (Short Polling)"></a>2.1 短轮询 (Short Polling)</h3><p>短轮询是最简单、最直观的实现方式。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li>客户端以一个固定的、较短的时间间隔（例如每隔 1-3 秒）向服务器发送一个 HTTP 请求，询问“是否有新消息？”。</li>
<li>服务器立即检查是否有新数据。</li>
<li><strong>如果有新数据</strong>，服务器将其放在 HTTP 响应中返回给客户端。</li>
<li><strong>如果没新数据</strong>，服务器也立即返回一个空的或表示“无新内容”的响应。</li>
<li>客户端收到响应后，无论有无数据，都会在等待预设的间隔时间后，再次发起下一次请求。这个过程会无限循环下去。</li>
</ol>
</li>
<li><p><strong>图解流程</strong>:</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client
    participant Server

    Client-&gt;&gt;Server: (1) Request
    Server--&gt;&gt;Client: (2) Response(No Data)
    note over Client: (wait 2s)

    Client-&gt;&gt;Server: (3) Request
    Server--&gt;&gt;Client: (4) Response(No Data)
    note over Client: (wait 2s)

    Client-&gt;&gt;Server: (5) Request
    note over Server: Has new data
    Server--&gt;&gt;Client: (6) Response(With Data)
    note over Client: (wait 2s)

    Client-&gt;&gt;Server: (7) Request
    note over Client,Server: ...</code></pre>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>实现简单</strong>：前后端实现都非常容易，逻辑清晰。</li>
<li><strong>兼容性好</strong>：几乎所有浏览器都支持，没有兼容性问题。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>延迟性高</strong>：消息的实时性取决于轮询间隔。如果间隔设为3秒，那么一条消息最多会有3秒的延迟才能被客户端接收到。</li>
<li><strong>服务器压力大</strong>：无论有无新消息，客户端都会持续不断地发起请求，其中绝大多数是无效的“空请求”（无功请求），这会极大地消耗服务器的 CPU 和带宽资源。</li>
<li><strong>网络拥堵</strong>：大量的 HTTP 请求头（Header）在网络中传输，造成了不必要的带宽浪费。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-长轮询-Long-Polling"><a href="#2-2-长轮询-Long-Polling" class="headerlink" title="2.2 长轮询 (Long Polling)"></a>2.2 长轮询 (Long Polling)</h3><p>长轮询是短轮询的优化版，旨在减少无效请求，降低延迟。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li>客户端向服务器发起一个请求，询问“是否有新消息？”。</li>
<li>服务器收到请求后，<strong>并不立即响应</strong>。它会“挂起”（hold）这个连接，检查是否有新数据。</li>
<li><strong>如果在一定超时时间（例如30秒）内有新数据</strong>，服务器立即将数据放入响应中，返回给客户端，并关闭当前连接。</li>
<li><strong>如果在超时时间内一直没有新数据</strong>，服务器会返回一个表示超时的空响应，并关闭当前连接。</li>
<li>客户端在收到响应（无论是带数据的还是超时的）后，会<strong>立即</strong>发起下一个长轮询请求。</li>
</ol>
</li>
<li><p><strong>图解流程</strong>:</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client
    participant Server

    Client-&gt;&gt;Server: (1) Request
    note over Server: Holds connection...

    note over Server: ... after 15s, new data arrives
    Server--&gt;&gt;Client: (2) Response(With Data)

    note over Client: Client immediately re-requests
    Client-&gt;&gt;Server: (3) Request
    note over Server: Holds connection...

    note over Server: ... after 30s, connection times out
    Server--&gt;&gt;Client: (4) Response(Timeout)

    note over Client: Client immediately re-requests
    Client-&gt;&gt;Server: (5) Request
    note over Server: Holds connection...
    note over Client, Server: ...</code></pre>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>准实时性</strong>：一旦有数据，服务器会立即发送，大大降低了消息的延迟。</li>
<li><strong>减少无效请求</strong>：相比短轮询，极大地减少了客户端发起的请求总数，节省了网络带宽和服务器的瞬时处理压力。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>服务器资源占用</strong>：服务器需要长时间维持（hold）客户端的连接。在高并发场景下，大量的挂起连接会占用大量的服务器内存和线程（或其他连接句柄），容易导致服务器连接数耗尽，这是著名的 <strong>C10K 问题</strong> 的一个典型场景。</li>
<li><strong>实现相对复杂</strong>：服务器端需要管理连接的挂起、超时和唤醒，逻辑比短轮询复杂。</li>
<li><strong>消息传递仍有延迟</strong>：每次数据传输后，连接会断开，客户端需要重新建立连接，这个过程（TCP握手、HTTP请求）仍然存在开销和延迟。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-HTTP-流-HTTP-Streaming"><a href="#2-3-HTTP-流-HTTP-Streaming" class="headerlink" title="2.3 HTTP 流 (HTTP Streaming)"></a>2.3 HTTP 流 (HTTP Streaming)</h3><p>这是一种更为激进的方案，试图在单个 HTTP 连接上实现持续的数据传输。</p>
<ul>
<li><strong>工作原理</strong>：<ol>
<li>客户端发起一个 HTTP 请求。</li>
<li>服务器返回一个 <code>Content-Type</code> 为 <code>application/octet-stream</code> 或类似类型的响应，并且响应头中不包含 <code>Content-Length</code> (或使用 <code>Transfer-Encoding: chunked</code>)。</li>
<li>关键在于，服务器<strong>不关闭这个响应连接</strong>。它会周期性地向这个打开的连接中“冲刷”（flush）数据块。</li>
<li>客户端通过监听 <code>XMLHttpRequest</code> 的 <code>onprogress</code> 事件或使用隐藏的 <code>&lt;iframe&gt;</code> 来持续接收这些数据块。</li>
</ol>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>低延迟</strong>：在连接的生命周期内，消息几乎可以无延迟地从服务器推送到客户端。</li>
<li><strong>连接开销小</strong>：只需建立一次连接，后续所有消息都在这个连接上传输，省去了重复建立连接的开销。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>单向通信</strong>：这种方式本质上只解决了“服务器 -&gt; 客户端”的推送问题。如果客户端需要向服务器发送数据，仍然需要发起一个新的 HTTP 请求。它不是一个真正的双向通道。</li>
<li><strong>代理和防火墙问题</strong>：很多网络中间设备（如代理服务器、防火墙）可能会对这种“永不结束”的响应进行缓存或中断，导致连接不可靠。</li>
<li><strong>控制复杂</strong>：客户端和服务器对连接状态的控制比较复杂，例如如何判断连接真正断开。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-WebSocket-的诞生"><a href="#3-WebSocket-的诞生" class="headerlink" title="3. WebSocket 的诞生"></a>3. WebSocket 的诞生</h2><p>在短轮询、长轮询等“伪实时”方案的种种妥协与挣扎之后，Web 开发社区迫切需要一个原生的、高效的、真正的双向通信解决方案。终于，在 2011 年，IETF 将其标准化为 RFC 6455，HTML5 标准中也包含了 WebSocket API。一个为实时而生的协议——WebSocket——正式登上了历史舞台。</p>
<h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>WebSocket 从根本上改变了客户端与服务器的交互方式，其核心特性可以概括为以下三点：</p>
<ol>
<li><strong>一次握手 (Single Handshake)</strong><br>WebSocket 的连接建立过程非常巧妙。它并非一个全新的协议，而是“寄生”于 HTTP 协议之上。客户端首先发起一个特殊的 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code> 等字段。服务器如果支持 WebSocket，就会响应一个状态码为 <code>101 Switching Protocols</code> 的 HTTP 响应。这个过程被称为“WebSocket 握手”。一旦握手成功，底层的 TCP 连接就不再用于传输 HTTP 数据，而是切换为 WebSocket 协议的专属通道。</li>
<li><strong>持久连接 (Persistent Connection)</strong><br>握手成功后，该 TCP 连接会一直保持打开状态，直到客户端或服务器某一方主动关闭连接，或者网络发生中断。这与 HTTP 的“请求-响应-断开”模式完全不同。在一个持久的连接上，双方可以随时进行通信，免去了反复建立和断开连接所带来的巨大开销和延迟。</li>
<li><strong>全双工通信 (Full-Duplex Communication)</strong><br>这是 WebSocket 最具革命性的特点。在建立的持久连接上，客户端和服务器处于完全平等的地位，双方都可以<strong>在任何时刻、主动地</strong>向对方发送数据，无需等待对方的请求。这就像从使用“对讲机”（一次只能一方说）升级到了使用“电话”（双方可以同时自由交谈）。</li>
</ol>
<hr>
<h3 id="3-2-核心优势"><a href="#3-2-核心优势" class="headerlink" title="3.2 核心优势"></a>3.2 核心优势</h3><p>基于以上定义，WebSocket 带来了碾压式的优势：</p>
<ul>
<li><strong>极低延迟 (Low Latency)</strong>：数据可以直接在已建立的持久连接上发送，无需等待客户端轮询，也无需重新进行 TCP 和 TLS 握手。消息几乎可以瞬时从一端到达另一端，这是实现高实时性应用（如在线游戏、金融交易）的基石。</li>
<li><strong>极低开销 (Low Overhead)</strong>：<ul>
<li><strong>连接开销</strong>：只需一次握手，后续通信不再有建立连接的开销。</li>
<li><strong>协议开销</strong>：一旦握手完成，后续传输的数据单元是“数据帧 (Frame)”。WebSocket 的数据帧头部非常小，最小仅为 2 字节。相比之下，HTTP 请求&#x2F;响应的头部动辄数百字节，每次通信都携带大量的冗余信息。在频繁通信的场景下，WebSocket 能节省巨量的带宽。</li>
</ul>
</li>
<li><strong>真正的双向通信 (True Bidirectional Communication)</strong>：服务器可以主动向客户端推送数据，客户端也可以随时向服务器发送数据。这极大地简化了需要双向交互的应用的开发模型。开发者不再需要用复杂的技巧去“模拟”服务器推送，而是可以直接调用 <code>send()</code> 方法。</li>
<li><strong>更好的兼容性</strong>：WebSocket 握手通过 HTTP 协议进行，默认使用与 HTTP 相同的 80 和 443 端口。这使得它能够很好地穿透大多数企业防火墙和网络代理服务器，而这些中间设备往往会阻碍非标准的自定义 TCP 协议。</li>
</ul>
<hr>
<h1 id="二、协议底层"><a href="#二、协议底层" class="headerlink" title="二、协议底层"></a>二、协议底层</h1><h2 id="1-连接的桥梁：HTTP-Upgrade-握手机制"><a href="#1-连接的桥梁：HTTP-Upgrade-握手机制" class="headerlink" title="1. 连接的桥梁：HTTP Upgrade 握手机制"></a>1. 连接的桥梁：HTTP Upgrade 握手机制</h2><p>WebSocket 的设计者非常聪明，他们没有发明一个需要开放新端口的全新协议，因为这很可能会被企业防火墙或代理服务器拦截。相反，他们让 WebSocket 连接“伪装”成一个普通的 HTTP 请求开始，一旦双方确认“身份”，再“摇身一变”，切换到 WebSocket 协议。</p>
<h3 id="1-1-客户端握手请求"><a href="#1-1-客户端握手请求" class="headerlink" title="1.1 客户端握手请求"></a>1.1 客户端握手请求</h3><p>一切始于客户端（如浏览器）向服务器发起的一个特殊的 HTTP GET 请求。这个请求看起来和普通的 HTTP 请求很像，但包含了几个关键的请求头，它们是升级协议的“暗号”。</p>
<p>一个典型的客户端握手请求如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13 </span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br></pre></td></tr></table></figure>

<p>让我们来逐一解读这些关键的头部字段：</p>
<ul>
<li><strong><code>GET /chat HTTP/1.1</code></strong><ul>
<li>请求行本身是标准的。路径 <code>/chat</code> 告诉服务器，客户端希望在哪个端点上建立 WebSocket 连接。服务器可以根据不同的路径提供不同的 WebSocket 服务。</li>
</ul>
</li>
<li><strong><code>Upgrade: websocket</code></strong> (<strong>核心暗号①</strong>)<ul>
<li>这是最直接的信号。它明确告诉服务器：“我（客户端）希望将当前这个 HTTP 连接升级到 WebSocket 协议。”</li>
</ul>
</li>
<li><strong><code>Connection: Upgrade</code></strong> (<strong>核心暗号②</strong>)<ul>
<li>HTTP 的 <code>Connection</code> 头通常用于管理连接的持续性（如 <code>keep-alive</code>）。在这里，<code>Upgrade</code> 值是一个补充说明，它告诉服务器以及路径上的所有中间代理：“请注意，这个连接即将发生协议转换，<code>Upgrade</code> 头中指定的协议就是要转换的目标。” 这是一个标准的 HTTP&#x2F;1.1 机制，用于协议升级。</li>
</ul>
</li>
<li><strong><code>Sec-WebSocket-Key</code></strong> (<strong>安全与身份验证</strong>)<ul>
<li>这是一个非常重要的字段，主要有两个作用：<ol>
<li><strong>证明服务器是真正的 WebSocket 服务器</strong>：客户端会发送一个由 Base64 编码的 16 字节随机字符串。服务器必须使用这个 <code>key</code> 和一个固定的“魔法字符串”通过特定算法计算出一个 <code>Sec-WebSocket-Accept</code> 值并返回。如果客户端收到的 <code>Accept</code> 值是正确的，它就知道对方确实是一个 WebSocket 服务器，而不是一个恰好返回了错误响应的普通 HTTP 服务器。</li>
<li><strong>防止代理缓存攻击</strong>：一些代理服务器可能会缓存 HTTP GET 请求的响应。如果一个恶意的 WebSocket 请求被代理缓存，当一个普通的 HTTP 客户端发出相同的 GET 请求时，代理可能会错误地返回一个 WebSocket 握手响应，导致客户端解析混乱。由于 <code>Sec-WebSocket-Key</code> 对于每次握手都是随机且唯一的，这保证了每次握手的响应都不同，从而有效防止了缓存污染。</li>
</ol>
</li>
</ul>
</li>
<li><strong><code>Sec-WebSocket-Version: 13</code></strong><ul>
<li>指定了客户端期望使用的 WebSocket 协议版本。<code>13</code> 是当前最广泛使用的版本，对应 RFC 6455 标准。如果服务器不支持此版本，它应该返回一个错误。</li>
</ul>
</li>
<li><strong><code>Origin</code></strong><ul>
<li>这个头部用于浏览器环境，提供了发起请求的源地址。服务器可以使用它来实施安全策略，例如判断是否允许该来源的页面建立 WebSocket 连接，以防止跨站 WebSocket 劫持 (Cross-Site WebSocket Hijacking)。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-服务端握手响应"><a href="#1-2-服务端握手响应" class="headerlink" title="1.2 服务端握手响应"></a>1.2 服务端握手响应</h3><p>如果服务器理解并同意客户端的升级请求，它会返回一个 HTTP 状态码为 <code>101 Switching Protocols</code> 的响应。</p>
<p>一个典型的服务端握手响应如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>HTTP/1.1 101 Switching Protocols</code></strong></p>
<ul>
<li>这个状态码是明确的协议转换信号，告诉客户端：“好的，我同意你的请求，我们现在开始切换协议。”</li>
</ul>
</li>
<li><p><strong><code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code></strong></p>
<ul>
<li>服务器会原样返回这两个头部，作为对客户端请求的确认。</li>
</ul>
</li>
<li><p><strong><code>Sec-WebSocket-Accept</code></strong> (<strong>握手成功的凭证</strong>)</p>
<ul>
<li>这是握手成功的关键凭证。它的值是服务器根据客户端发送的 <code>Sec-WebSocket-Key</code> 精心计算出来的。计算逻辑在 RFC 6455 中有严格规定：<ol>
<li><strong>拼接</strong>：将客户端发送的 <code>Sec-WebSocket-Key</code> 的值与一个固定的“魔法字符串” <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code> 进行拼接。<br>例如：<code>dGhlIHNhbXBsZSBub25jZQ==</code> + <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code></li>
<li><strong>哈希</strong>：对拼接后的字符串计算 <strong>SHA-1</strong> 哈希值。这将得到一个 20 字节的二进制结果。</li>
<li><strong>编码</strong>：将这个 20 字节的二进制哈希值进行 <strong>Base64</strong> 编码。</li>
</ol>
</li>
</ul>
<p>客户端收到响应后，会用同样的算法在本地计算一遍，然后比较自己计算出的结果和服务器返回的 <code>Sec-WebSocket-Accept</code> 值是否完全一致。如果一致，握手成功；如果不一致，连接将立即关闭。</p>
</li>
</ul>
<hr>
<h3 id="1-3-握手成功之后：-连接正式从-HTTP-切换到-WebSocket-协议。"><a href="#1-3-握手成功之后：-连接正式从-HTTP-切换到-WebSocket-协议。" class="headerlink" title="1.3 握手成功之后： 连接正式从 HTTP 切换到 WebSocket 协议。"></a>1.3 握手成功之后： 连接正式从 HTTP 切换到 WebSocket 协议。</h3><p>一旦客户端验证 <code>Sec-WebSocket-Accept</code> 成功，这次 HTTP “对话”就宣告结束。但底层的 TCP 连接并未断开。此时，这条连接的“控制权”就从 HTTP 协议转移到了 WebSocket 协议。</p>
<ul>
<li><strong>协议转换</strong>：这条通道不再遵循 HTTP 的请求-响应模式。</li>
<li><strong>数据格式改变</strong>：之后在这条通道上传输的数据，将不再是 HTTP 报文，而是遵循 WebSocket 协议格式的 <strong>数据帧 (Data Frame)</strong>。</li>
<li><strong>全双工开启</strong>：客户端和服务器现在都可以随时、主动地通过这个连接向对方发送数据帧，实现了真正的全双工通信。</li>
</ul>
<p>这个巧妙的握手过程，既保证了与现有 Web 基础设施的兼容性，又通过 challenge-response 机制确保了连接的可靠性和安全性，为后续高效的实时通信铺平了道路。接下来，我们将深入了解在这条新建立的通道上奔跑的“信使”——数据帧。</p>
<hr>
<h2 id="2-通信的最小单元：数据帧-Data-Frame"><a href="#2-通信的最小单元：数据帧-Data-Frame" class="headerlink" title="2. 通信的最小单元：数据帧 (Data Frame)"></a>2. 通信的最小单元：数据帧 (Data Frame)</h2><p>握手成功后，WebSocket 连接就进入了数据传输阶段。与 HTTP 这种基于文本、格式冗长的协议不同，WebSocket 定义了一种紧凑的、基于二进制的帧结构来承载数据。这使得协议开销极小，传输效率极高。无论是客户端发送给服务器，还是服务器推送给客户端，所有消息都被切割并封装成一个或多个数据帧进行传输。</p>
<h3 id="2-1-帧结构图解"><a href="#2-1-帧结构图解" class="headerlink" title="2.1 帧结构图解"></a>2.1 帧结构图解</h3><p>一个 WebSocket 数据帧由一个固定长度的头部和可变长度的载荷（Payload）组成。其结构如下图所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>让我们来详细解析每个关键字段的作用：</p>
<ul>
<li><strong><code>FIN</code> (1 bit)</strong>: <strong>结束标志位 (Final Fragment)</strong><ul>
<li><code>1</code>: 当前帧是该消息的最后一个帧。如果消息不大，只用一个数据帧就能装下，那么这个帧的 <code>FIN</code> 位就是 <code>1</code>.</li>
<li><code>0</code>: 还有更多帧。</li>
<li>这个机制允许 WebSocket 将一个大消息分割成多个帧来发送，接收方可以逐帧接收，避免了因等待完整大消息而造成的延迟。接收方需要缓存这些 <code>FIN</code> 为 <code>0</code> 的帧，直到收到一个 <code>FIN</code> 为 <code>1</code> 的帧，然后将所有分片按序组合成完整的消息。</li>
</ul>
</li>
<li><strong><code>RSV1</code>, <code>RSV2</code>, <code>RSV3</code> (1 bit each)</strong>: <strong>保留位</strong><ul>
<li>这三个是保留位，必须设置为 <code>0</code>，除非有扩展协议定义了它们的用途。如果接收方收到的帧中这些位不为 <code>0</code> 且没有协商过任何扩展，就必须关闭连接。</li>
</ul>
</li>
<li><strong><code>Opcode</code> (4 bits)</strong>: <strong>操作码 (Operation Code)</strong><ul>
<li>这是至关重要的字段，它定义了该帧的数据类型。具体分类见下一节。</li>
</ul>
</li>
<li><strong><code>MASK</code> (1 bit)</strong>: <strong>掩码标志位</strong><ul>
<li><code>1</code>: 表示“载荷数据”被掩码（XOR异或加密）处理过。<strong>客户端发送给服务器的帧必须置 <code>1</code> (MASKED)</strong>。</li>
<li><code>0</code>: 表示“载荷数据”没有被掩码。<strong>服务器发送给客户端的帧必须置 <code>0</code> (UNMASKED)</strong>。</li>
<li><strong>为什么需要掩码？</strong> 这是为了防止代理缓存污染攻击 (Cache Poisoning)。一些设计不佳的代理服务器可能会解析并缓存 WebSocket 流量。如果客户端数据是明文的，攻击者可以构造一个特殊的 WebSocket 消息，让其看起来像一个 HTTP 响应，从而毒化代理的缓存。通过对客户端数据进行掩码，可以使数据变得不可预测，避免了这种风险。掩码密钥 (<code>Masking-key</code>) 是由客户端随机生成的，每次发送数据帧时都会变化。</li>
</ul>
</li>
<li><strong><code>Payload len</code> (7 bits), <code>Extended payload length</code> (16 or 64 bits)</strong>: <strong>载荷长度</strong><ul>
<li>这个区域用于表示 <code>Payload Data</code> 的长度，设计得非常精巧以节省空间：<ul>
<li><strong>如果 <code>Payload len</code> 在 0-125 之间</strong>：它的值就是载荷的实际长度（字节）。</li>
<li><strong>如果 <code>Payload len</code> 是 126</strong>：那么紧随其后的 2 个字节（16 bits）表示一个无符号整数，这个整数才是载荷的实际长度。用于传输长度在 126 到 65535 字节之间的载荷。</li>
<li><strong>如果 <code>Payload len</code> 是 127</strong>：那么紧随其后的 8 个字节（64 bits）表示一个无符号整数，这个整数才是载荷的实际长度。用于传输超大载荷。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>Masking-key</code> (0 or 4 bytes)</strong>: <strong>掩码密钥</strong><ul>
<li>如果 <code>MASK</code> 位是 <code>1</code>，那么这个字段就存在，占用 4 个字节。</li>
<li>如果 MASK 位是 0，则没有此字段。</li>
<li>它是由客户端随机生成的 32 位值。用于对载荷数据进行异或（XOR）掩码操作，以防止中间件干扰（即使数据是明文，看起来也是随机的）。服务器需要用这个密钥来解开 <code>Payload Data</code> 的掩码。解密算法很简单：<code>decoded[i] = encoded[i] XOR masking-key[i % 4]</code>。</li>
</ul>
</li>
<li><strong><code>Payload Data</code> (x bytes)</strong>: <strong>载荷数据</strong><ul>
<li>实际传输的应用数据。长度由 Payload Length 字段定义。</li>
<li>如果存在 Masking-Key，这部分数据是经过掩码（异或加密）的。服务器收到后需要先解掩码才能使用。服务器发送的数据则是明文的。</li>
<li>载荷数据的内容由 Opcode 决定（文本、二进制、控制帧的特定数据如关闭原因等）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-操作码-Opcode-分类"><a href="#2-2-操作码-Opcode-分类" class="headerlink" title="2.2 操作码 (Opcode) 分类"></a>2.2 操作码 (Opcode) 分类</h3><p><code>Opcode</code> 字段决定了如何解释 <code>Payload Data</code>。主要分为三类：</p>
<ul>
<li><strong>数据帧 (Data Frames)</strong><ul>
<li><code>%x1</code> (<strong>Text Frame</strong>): 文本帧。<code>Payload Data</code> 是 UTF-8 编码的文本数据。一个完整的文本消息由一个或多个文本帧组成。</li>
<li><code>%x2</code> (<strong>Binary Frame</strong>): 二进制帧。<code>Payload Data</code> 是任意的二进制数据。一个完整的二进制消息由一个或多个二进制帧组成。例如，可以用来传输图片、音频、Protobuf 或任何自定义的二进制格式。</li>
<li><code>%x0</code> (<strong>Continuation Frame</strong>): 连续帧。当一个消息被分割成多个帧时，第一个帧的 <code>Opcode</code> 是 <code>%x1</code> 或 <code>%x2</code>，后续所有帧的 <code>Opcode</code> 都必须是 <code>%x0</code>，直到 <code>FIN</code> 位为 <code>1</code> 的帧为止。</li>
</ul>
</li>
<li><strong>控制帧 (Control Frames)</strong><ul>
<li>控制帧用于处理 WebSocket 连接本身的状态，它们 <strong>不能被分片</strong>（即 <code>FIN</code> 位必须为 <code>1</code>），且其载荷长度不能超过 125 字节。</li>
<li><code>%x8</code> (<strong>Close Frame</strong>): 关闭帧。用于发起一个“优雅的”关闭握手。发送方可以包含一个状态码和关闭原因，接收方收到后应回复一个关闭帧，然后双方关闭连接。</li>
<li><code>%x9</code> (<strong>Ping Frame</strong>): Ping 帧。主要用于心跳检测，以确认连接仍然存活。发送方可以包含任意载荷数据，接收方收到 Ping 帧后，<strong>必须</strong> 尽快回复一个 Pong 帧，并将 Ping 帧的载荷数据一模一样地返回。</li>
<li><code>%xA</code> (<strong>Pong Frame</strong>): Pong 帧。是对 Ping 帧的响应。也可以由任意一方主动发送，作为一种单向的心跳。</li>
</ul>
</li>
<li><strong>保留的操作码</strong><ul>
<li><code>%x3</code> - <code>%x7</code> 和 <code>%xB</code> - <code>%xF</code> 是为未来扩展保留的。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-安全与地址：ws-vs-wss"><a href="#3-安全与地址：ws-vs-wss" class="headerlink" title="3. 安全与地址：ws:// vs wss://"></a>3. 安全与地址：<code>ws://</code> vs <code>wss://</code></h2><p>与 HTTP 协议拥有 <code>http://</code> 和 <code>https://</code> 两种模式一样，WebSocket 也有两种对应的 URI 类型：<code>ws://</code> (WebSocket) 和 <code>wss://</code> (WebSocket Secure)。选择哪一种，直接决定了你的通信内容在网络中是“裸奔”还是“加密传输”。</p>
<ul>
<li><strong><code>ws://</code> (WebSocket)</strong><ul>
<li><strong>定义</strong>：一个<strong>未加密</strong>的 WebSocket 连接。</li>
<li><strong>工作方式</strong>：<ul>
<li>它通过标准的 HTTP 握手建立连接，默认使用 <strong>80</strong> 端口。</li>
<li>握手成功后，所有的数据帧（Data Frame）都以<strong>明文</strong>形式在 TCP 连接上传输。</li>
</ul>
</li>
<li><strong>风险</strong>：这意味着任何在网络路径上的中间节点（如路由器、ISP、恶意攻击者）都可以轻易地监听、窃取甚至篡改你的通信内容。这对于涉及敏感信息（如用户凭证、私人消息、交易数据）的应用来说是绝对不可接受的。</li>
<li><strong>适用场景</strong>：仅限于在完全可信的内部网络或本地开发环境中进行测试和调试。<strong>严禁在任何公共网络（互联网）的生产环境中使用 <code>ws://</code>。</strong></li>
</ul>
</li>
<li><strong><code>wss://</code> (WebSocket Secure)</strong><ul>
<li><strong>定义</strong>：一个<strong>加密</strong>的 WebSocket 连接。</li>
<li><strong>工作方式</strong>：<ul>
<li>它并非一个全新的协议，而是将标准的 WebSocket 协议运行在 <strong>TLS (Transport Layer Security)</strong> 层之上。TLS 是 <code>https://</code> 使用的同一种加密协议。</li>
<li>连接过程如下：<ol>
<li>首先，客户端和服务之间会建立一个标准的 <strong>TLS 握手</strong>，创建一个安全的加密通道。这个过程与访问一个 <code>https://</code> 网站完全相同，服务器需要提供一个有效的 SSL&#x2F;TLS 证书。</li>
<li>然后，在这个已经建立的加密通道内，再进行标准的 WebSocket HTTP Upgrade 握手。</li>
<li>握手成功后，所有后续的 WebSocket 数据帧都会在发送前被 TLS 层加密，在接收后被 TLS 层解密。</li>
</ol>
</li>
</ul>
</li>
<li><strong>默认端口</strong>：<code>wss://</code> 默认使用 <strong>443</strong> 端口，这也是 <code>https://</code> 的标准端口。这使得 <code>wss://</code> 连接更容易穿透那些只允许标准 Web 流量（HTTP&#x2F;HTTPS）的防火墙。</li>
</ul>
</li>
</ul>
<p><strong><code>wss://</code> 的重要性：基于 TLS 的加密传输</strong></p>
<p>在现代 Web 应用中，<strong>使用 <code>wss://</code> 而不是 <code>ws://</code> 是一个强制性的安全最佳实践</strong>。其重要性体味在以下几个方面：</p>
<ol>
<li><strong>机密性 (Confidentiality)</strong><ul>
<li><code>wss://</code> 通过 TLS 加密了客户端和服务器之间的所有通信内容。这意味着即使数据包被网络嗅探工具（如 Wireshark）截获，攻击者看到的也只是一堆无意义的乱码，无法解析出原始的聊天消息、用户数据或其他敏感信息。</li>
</ul>
</li>
<li><strong>完整性 (Integrity)</strong><ul>
<li>TLS 协议包含了消息认证码 (MAC) 机制。每一条消息都会附加一个校验码，接收方会验证该校验码。如果数据在传输过程中被篡改（哪怕只修改了一个比特），校验码将不再匹配，连接会立即中断。这确保了你收到的数据就是对方发送的原始数据，未被篡改。</li>
</ul>
</li>
<li><strong>身份认证 (Authentication)</strong><ul>
<li>在 TLS 握手期间，服务器会向客户端出示其 SSL&#x2F;TLS 证书。客户端（浏览器）会验证该证书的有效性（例如，是否由受信任的证书颁发机构 CA 签发、域名是否匹配、是否在有效期内）。这向客户端证明了它正在与之通信的服务器是它声称的那个服务器（例如 <code>your-app.com</code>），而不是一个伪装的中间人攻击者。</li>
</ul>
</li>
<li><strong>浏览器安全策略的要求</strong><ul>
<li>现代浏览器正在强制推行“HTTPS Everywhere”策略。如果你的主页面是通过 <code>https://</code> 加载的，浏览器会出于安全考虑（混合内容 Mixed Content 策略），<strong>禁止</strong>该页面发起不安全的 <code>ws://</code> 连接。你只能从 <code>https://</code> 页面连接到 <code>wss://</code> 服务器。这意味着，只要你的网站启用了 HTTPS，你就必须使用 <code>wss://</code>。</li>
</ul>
</li>
</ol>
<p><strong>总结与实践建议</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>ws://</code></th>
<th align="left"><code>wss://</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>加密</strong></td>
<td align="left">否 (明文传输)</td>
<td align="left"><strong>是 (基于 TLS 加密)</strong></td>
</tr>
<tr>
<td align="left"><strong>默认端口</strong></td>
<td align="left">80</td>
<td align="left"><strong>443</strong></td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">极低，易受窃听和篡改</td>
<td align="left"><strong>高</strong>，提供机密性、完整性、身份认证</td>
</tr>
<tr>
<td align="left"><strong>浏览器限制</strong></td>
<td align="left"><code>https://</code> 页面无法连接到 <code>ws://</code></td>
<td align="left"><strong>无限制</strong>，兼容 <code>http://</code> 和 <code>https://</code> 页面</td>
</tr>
<tr>
<td align="left"><strong>生产环境</strong></td>
<td align="left"><strong>禁止使用</strong></td>
<td align="left"><strong>强制要求</strong></td>
</tr>
</tbody></table>
<p><strong>结论</strong>：在项目规划和开发阶段，就应该将 <code>wss://</code> 作为唯一的选择。这意味着 WebSocket 服务器（无论是 Java、Node.js 还是其他语言实现）必须配置 SSL&#x2F;TLS 证书。在 Spring Boot 中，这通常与为整个 Web 应用启用 HTTPS 的配置是集成在一起的，非常方便。</p>
<hr>
<h1 id="三、Java-原生-API-JSR-356"><a href="#三、Java-原生-API-JSR-356" class="headerlink" title="三、Java 原生 API (JSR 356)"></a>三、Java 原生 API (JSR 356)</h1><h2 id="1-概述与依赖"><a href="#1-概述与依赖" class="headerlink" title="1. 概述与依赖"></a>1. 概述与依赖</h2><h3 id="1-1-JSR-356-是什么？Java-EE-Jakarta-EE-的标准"><a href="#1-1-JSR-356-是什么？Java-EE-Jakarta-EE-的标准" class="headerlink" title="1.1 JSR 356 是什么？Java EE&#x2F;Jakarta EE 的标准"></a>1.1 JSR 356 是什么？Java EE&#x2F;Jakarta EE 的标准</h3><ul>
<li><strong>定义</strong>：<strong>JSR 356</strong>，其标题为 <strong>“Java API for WebSocket”</strong>，是 Java Community Process (JCP) 定义的一个官方规范 (Java Specification Request)。它为 Java 平台提供了一套标准的、用于构建 WebSocket 应用的 API。</li>
<li><strong>标准化意味着什么？</strong><ul>
<li><strong>统一接口</strong>：JSR 356 定义了一系列的注解 (Annotations) 和接口，如 <code>@ServerEndpoint</code>、<code>@OnOpen</code>、<code>Session</code>、<code>Endpoint</code> 等。开发者只需要面向这些标准接口编程，而无需关心底层的具体实现。</li>
<li><strong>厂商实现</strong>：各大 Servlet 容器（应用服务器）厂商，如 Apache Tomcat, Eclipse Jetty, WildFly 等，都需要遵循 JSR 356 规范来提供自己的 WebSocket 功能实现。这就好比 JDBC 是数据库访问的标准，而各大数据库厂商提供自己的驱动程序一样。</li>
<li><strong>可移植性</strong>：只要你的代码是基于 JSR 356 API 编写的，理论上它可以不加修改地部署在任何兼容该规范的 Servlet 容器上。</li>
</ul>
</li>
<li><strong>历史演进</strong>：<ul>
<li>JSR 356 最初是作为 <strong>Java EE 7</strong> (Java Enterprise Edition 7) 的一部分被引入的。</li>
<li>随着 Java EE 迁移到 Eclipse 基金会并更名为 <strong>Jakarta EE</strong>，该规范也随之演进。在 Jakarta EE 8 及更高版本中，它被称为 <strong>Jakarta WebSocket</strong>。核心 API 和注解基本保持不变，只是包名从 <code>javax.websocket.*</code> 迁移到了 <code>jakarta.websocket.*</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-依赖配置"><a href="#1-2-依赖配置" class="headerlink" title="1.2 依赖配置"></a>1.2 依赖配置</h3><p>由于 JSR 356 是一个“规范”，你需要的依赖通常是一个 <code>api</code> 包，它只包含接口和注解，不包含具体实现。</p>
<ul>
<li><p><strong>Maven 依赖 (适用于 Jakarta EE)</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用与你的服务器兼容的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Maven 依赖 (适用于旧版 Java EE)</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 经典的 Java EE 7/8 版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>scope</code> 设置为 <code>provided</code> 的原因</strong>：<br>我们将 <code>scope</code> 设置为 <code>provided</code>，是因为我们期望最终的应用是部署在一个已经内置了 JSR 356 实现的 Servlet 容器（如 Tomcat 8+、Jetty 9+）中的。容器在运行时会提供具体的实现类。我们只需要这个 API 依赖在<strong>编译时</strong>可用，以便我们的代码能够通过编译检查。如果将实现打包到我们的 <code>.war</code> 文件中，可能会与容器自带的实现产生冲突。</p>
</li>
</ul>
<hr>
<h3 id="1-3-何时使用？"><a href="#1-3-何时使用？" class="headerlink" title="1.3 何时使用？"></a>1.3 何时使用？</h3><p>虽然 Spring 提供了更高级的抽象，但在某些场景下，直接使用 JSR 356 仍然是一个非常好的选择：</p>
<ol>
<li><strong>原生 Servlet 容器环境</strong><ul>
<li>当项目是一个不使用 Spring 或其他大型框架的、标准的 Web 应用（打包成 <code>.war</code> 文件），并直接部署在 Tomcat, Jetty, Undertow 等 Servlet 容器上时，JSR 356 是最自然、最轻量级的选择。这些容器都内置了对 JSR 356 的原生支持。</li>
</ul>
</li>
<li><strong>轻量级应用与微服务</strong><ul>
<li>对于一些简单的、功能单一的微服务，如果引入整个 Spring Boot 框架显得过于臃肿，使用如 JAX-RS (用于 REST) + JSR 356 (用于 WebSocket) 的组合，可以构建出非常轻量级的服务。</li>
</ul>
</li>
<li><strong>追求极致性能与底层控制</strong><ul>
<li>JSR 356 提供了相对底层的 API，让你能更直接地控制 <code>Session</code>、消息分片、超时等。对于需要进行深度性能调优或实现复杂协议交互的场景，直接使用原生 API 可能比经过多层封装的框架更灵活。</li>
</ul>
</li>
<li><strong>学习和理解 WebSocket 基础</strong><ul>
<li>从学习的角度看，先掌握 JSR 356 有助于你深刻理解 WebSocket 的生命周期和事件模型。这些基础知识对于后续学习和排查 Spring WebSocket 的问题也大有裨益。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-服务端实现"><a href="#2-服务端实现" class="headerlink" title="2. 服务端实现"></a>2. 服务端实现</h2><p>使用 JSR 356 实现 WebSocket 服务端非常直观，其核心是创建一个普通的 Java 类 (POJO)，并使用一系列注解来标记它，使其成为一个“服务端点 (Server Endpoint)”。容器会自动扫描、实例化并管理这些端点。</p>
<h3 id="2-1-服务端点类：-ServerEndpoint-注解详解"><a href="#2-1-服务端点类：-ServerEndpoint-注解详解" class="headerlink" title="2.1 服务端点类：@ServerEndpoint 注解详解"></a>2.1 服务端点类：<code>@ServerEndpoint</code> 注解详解</h3><p><code>@ServerEndpoint</code> 是 JSR 356 中最核心的注解。一个类一旦被此注解标记，容器就会将其识别为一个 WebSocket 端点，并为指定的 URI 路径提供服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat/&#123;room&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatEndpoint</span> &#123;</span><br><span class="line">    <span class="comment">// ... 生命周期方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@ServerEndpoint</code> 注解有多个常用属性：</p>
<ul>
<li><strong><code>value</code> (必需)</strong>:<ul>
<li><strong>作用</strong>：定义此端点对外暴露的 URI 路径。客户端需要连接到这个路径才能建立 WebSocket 通信。</li>
<li><strong>示例</strong>：<code>@ServerEndpoint(&quot;/chat&quot;)</code>，客户端需要连接 <code>ws://your-host/your-context/chat</code>。</li>
<li><strong>路径参数 (Path Parameters)</strong>：支持类似 JAX-RS 的路径模板。你可以使用 <code>{}</code> 来定义路径变量，并在生命周期方法中通过 <code>@PathParam</code> 注解获取。<ul>
<li><strong>示例</strong>：<code>@ServerEndpoint(&quot;/chat/{room}&quot;)</code>，客户端连接 <code>ws://.../chat/gaming</code> 时，<code>room</code> 变量的值就是 “gaming”。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>configurator</code> (可选)</strong>:<ul>
<li><strong>作用</strong>：指定一个自定义的 <code>ServerEndpointConfig.Configurator</code> 类的实例。这是一个高级特性，允许你在握手阶段进行深度定制，例如：<ul>
<li>在连接建立前修改 WebSocket 的配置。</li>
<li>根据 HTTP 握手请求头中的信息（如 <code>Origin</code> 或自定义 <code>token</code>）来决定是否允许连接。</li>
<li>在创建端点实例之前或之后执行特定逻辑。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>decoders</code> (可选)</strong>:<ul>
<li><strong>作用</strong>：指定一个或多个 <code>Decoder</code> 类的数组。Decoder 用于将传入的文本或二进制消息（如                                                                                                                                                                                                                                                                                                                                                     JSON 字符串）自动解码为自定义的 Java 对象。</li>
<li><strong>示例</strong>：<code>decoders = {MessageDecoder.class}</code></li>
</ul>
</li>
<li><strong><code>encoders</code> (可选)</strong>:<ul>
<li><strong>作用</strong>：指定一个或多个 <code>Encoder</code> 类的数组。Encoder 用于将传出的 Java 对象自动编码为 WebSocket 能发送的文本或二进制消息（如序列化为 JSON 字符串）。</li>
<li><strong>示例</strong>：<code>encoders = {MessageEncoder.class}</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-生命周期注解"><a href="#2-2-生命周期注解" class="headerlink" title="2.2 生命周期注解"></a>2.2 生命周期注解</h3><p>JSR 356 定义了四个注解，用于标记在 WebSocket 连接生命周期的不同阶段应该被调用的方法。</p>
<ul>
<li><p><strong><code>@OnOpen</code></strong>: <strong>连接建立时</strong></p>
<ul>
<li>当一个客户端成功与服务端点建立 WebSocket 连接后，被此注解标记的方法会被调用。</li>
<li><strong>方法签名</strong>：可以接受 <code>Session</code> 对象作为参数，也可以通过 <code>@PathParam</code> 获取 URI 中的路径变量。</li>
<li><strong>用途</strong>：通常用于初始化操作，如记录新用户上线、将会话 <code>Session</code> 存入一个全局集合以便后续广播、向新连接的用户发送欢迎消息等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnOpen</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;room&quot;)</span> String room)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Client connected to room: &quot;</span> + room);</span><br><span class="line">    <span class="comment">// session.getBasicRemote().sendText(&quot;Welcome to the chat!&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@OnMessage</code></strong>: <strong>收到消息时</strong></p>
<ul>
<li>当服务器从客户端收到一个完整的消息时，被此注解标记的方法会被调用。</li>
<li><strong>方法签名</strong>：<ul>
<li>可以接受消息内容作为参数，类型可以是 <code>String</code> (文本消息)、<code>byte[]</code> 或 <code>ByteBuffer</code> (二进制消息)、<code>Reader</code> (流式处理文本)、<code>InputStream</code> (流式处理二进制)。</li>
<li>如果配置了 <code>Decoder</code>，参数类型可以是解码后的自定义 Java 对象。</li>
<li>也可以接受 <code>Session</code> 参数来识别消息来源。</li>
</ul>
</li>
<li><strong>用途</strong>：处理业务逻辑的核心。例如，接收聊天消息并广播给其他人。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Received message: &quot;</span> + message);</span><br><span class="line">    <span class="comment">// 广播消息给聊天室其他人...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@OnClose</code></strong>: <strong>连接关闭时</strong></p>
<ul>
<li>当连接被关闭时（无论由客户端、服务端主动关闭，还是因网络异常中断），被此注解标记的方法会被调用。</li>
<li><strong>方法签名</strong>：可以接受 <code>Session</code> 和 <code>CloseReason</code> 对象作为参数。<code>CloseReason</code> 包含了关闭状态码和原因描述。</li>
<li><strong>用途</strong>：执行清理工作，如用户下线通知、从全局会话集合中移除该 <code>Session</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnClose</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + closeReason.getReasonPhrase());</span><br><span class="line">    <span class="comment">// 从会话集合中移除 session</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@OnError</code></strong>: <strong>发生错误时</strong></p>
<ul>
<li>当通信过程中发生错误时（如网络异常、消息编解码失败等），被此注解标记的方法会被调用。</li>
<li><strong>方法签名</strong>：必须接受一个 <code>Throwable</code> 类型的参数，用于表示发生的异常。也可以接受一个 <code>Session</code> 参数。</li>
<li><strong>用途</strong>：记录错误日志、进行必要的资源清理。<strong>注意</strong>：在很多实现中，一个错误发生后，连接通常会紧接着被关闭，所以 <code>@OnClose</code> 方法也常常会被调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnError</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;An error occurred: &quot;</span> + throwable.getMessage());</span><br><span class="line">    throwable.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-3-核心组件"><a href="#2-3-核心组件" class="headerlink" title="2.3 核心组件"></a>2.3 核心组件</h3><p>在生命周期方法中，<code>Session</code> 对象是你与客户端交互的唯一桥梁。</p>
<ul>
<li><strong><code>Session</code></strong><ul>
<li><strong>定义</strong>：代表一个客户端与服务端点之间的<strong>单一连接会话</strong>。每个成功连接的客户端都有一个独立的 <code>Session</code> 实例。</li>
<li><strong>关键方法</strong>：<ul>
<li><code>getId()</code>: 获取此会话的唯一ID。</li>
<li><code>isOpen()</code>: 检查连接是否仍然打开。</li>
<li><code>close()</code> &#x2F; <code>close(CloseReason reason)</code>: 主动关闭连接。</li>
<li><code>getRequestURI()</code>: 获取建立此连接的完整 URI。</li>
<li><code>getPathParameters()</code>: 获取一个 <code>Map</code>，包含 URI 模板中的所有路径参数。</li>
<li><code>getUserProperties()</code>: 提供一个 <code>Map&lt;String, Object&gt;</code>，可以在会话期间存储与该连接相关的自定义数据（如用户名、状态等）。这是一个非常有用的“会话状态”存储空间。</li>
<li><code>getBasicRemote()</code>: 获取<strong>同步</strong>消息发送器。</li>
<li><code>getAsyncRemote()</code>: 获取<strong>异步</strong>消息发送器。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>RemoteEndpoint.Basic</code> &#x2F; <code>RemoteEndpoint.Async</code></strong><ul>
<li><code>RemoteEndpoint</code> 是 <code>Session</code> 的一个属性，代表了“远程的那一端”（即客户端），用于向其发送消息。它提供了两种发送模式：</li>
<li><strong><code>RemoteEndpoint.Basic</code> (同步发送)</strong><ul>
<li><strong>获取方式</strong>：<code>session.getBasicRemote()</code></li>
<li><strong>特点</strong>：调用发送方法（如 <code>sendText(String text)</code>）时，当前线程会被<strong>阻塞</strong>，直到消息完全发送出去。</li>
<li><strong>优点</strong>：简单直接，易于理解。</li>
<li><strong>缺点</strong>：如果网络状况不佳或者发送的数据量大，会导致处理线程长时间阻塞，影响服务器处理其他连接的能力。在高并发场景下可能成为性能瓶颈。</li>
<li><strong>常用方法</strong>：<code>sendText(String)</code>, <code>sendBinary(ByteBuffer)</code>, <code>sendObject(Object)</code> (需配置 Encoder)。</li>
</ul>
</li>
<li><strong><code>RemoteEndpoint.Async</code> (异步发送)</strong><ul>
<li><strong>获取方式</strong>：<code>session.getAsyncRemote()</code></li>
<li><strong>特点</strong>：调用发送方法时，方法会<strong>立即返回</strong>，消息的发送操作会在另一个后台线程中进行。</li>
<li><strong>优点</strong>：非阻塞，不会占用当前业务处理线程，能显著提升服务器的吞吐量和响应能力，是<strong>生产环境推荐</strong>的方式。</li>
<li><strong>缺点</strong>：编程模型稍复杂，需要通过回调 (<code>Future</code> 或 <code>SendHandler</code>) 来处理发送成功或失败的结果。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>sendText(String text)</code>: 立即返回，不关心结果。</li>
<li><code>sendText(String text, SendHandler handler)</code>: 传入一个回调处理器，当发送完成（成功或失败）时，<code>handler</code> 的 <code>onResult</code> 方法会被调用。</li>
<li><code>sendObject(Object obj)</code>: 立即返回一个 <code>Future&lt;Void&gt;</code>，可以通过 <code>Future</code> 来检查发送是否完成或捕获异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-高级特性"><a href="#3-高级特性" class="headerlink" title="3. 高级特性"></a>3. 高级特性</h2><h3 id="3-1-路径参数处理：-ServerEndpoint-与-PathParam"><a href="#3-1-路径参数处理：-ServerEndpoint-与-PathParam" class="headerlink" title="3.1 路径参数处理：@ServerEndpoint 与 @PathParam"></a>3.1 路径参数处理：<code>@ServerEndpoint</code> 与 <code>@PathParam</code></h3><p>在实际应用中，我们往往不希望所有 WebSocket 连接都混在同一个“大厅”里。我们可能需要根据业务逻辑对连接进行分组，例如创建不同的聊天室、为特定用户推送消息等。JSR 356 借鉴了 JAX-RS (Java API for RESTful Web Services) 的设计，通过在 <code>@ServerEndpoint</code> 的路径中使用模板变量，并结合 <code>@PathParam</code> 注解来实现这一点。</p>
<ul>
<li><p><strong>定义带参数的路径</strong></p>
<p>在 <code>@ServerEndpoint</code> 注解的 <code>value</code> 属性中，使用 <code>{variableName}</code> 的形式来定义路径参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(&quot;/websocket/chat/&#123;room&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdvancedChatEndpoint</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了两个路径参数：<code>room</code> 和 <code>username</code>。</p>
</li>
<li><p><strong>在方法中获取参数值</strong></p>
<p>在任何生命周期方法（<code>@OnOpen</code>, <code>@OnMessage</code>, <code>@OnClose</code>, <code>@OnError</code>）的参数列表中，使用 <code>@PathParam(&quot;variableName&quot;)</code> 注解来注入对应的路径参数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(&quot;/websocket/chat/&#123;room&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdvancedChatEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session,</span></span><br><span class="line"><span class="params">                       <span class="meta">@PathParam(&quot;room&quot;)</span> String room,</span></span><br><span class="line"><span class="params">                       <span class="meta">@PathParam(&quot;username&quot;)</span> String username)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Session %s connected. User &#x27;%s&#x27; joined room &#x27;%s&#x27;.%n&quot;</span>,</span><br><span class="line">                          session.getId(), username, room);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们可以利用这些信息来管理会话</span></span><br><span class="line">        <span class="comment">// 例如，将会话按房间分组存储</span></span><br><span class="line">        <span class="comment">// chatRooms.computeIfAbsent(room, k -&gt; new CopyOnWriteArraySet&lt;&gt;()).add(session);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将用户信息存储在会话中，方便后续使用</span></span><br><span class="line">        session.getUserProperties().put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        session.getUserProperties().put(<span class="string">&quot;room&quot;</span>, room);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        <span class="comment">// 从会话中直接获取用户信息，而无需再次解析路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">room</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;room&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.printf(<span class="string">&quot;Received message from &#x27;%s&#x27; in room &#x27;%s&#x27;: %s%n&quot;</span>,</span><br><span class="line">                          username, room, message);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接下来可以实现只向同一个 room 的其他用户广播消息</span></span><br><span class="line">        <span class="comment">// broadcastToRoom(room, username + &quot;: &quot; + message);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他生命周期方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong></p>
<ul>
<li><strong>动态路由</strong>：使得一个端点类可以服务于多个逻辑隔离的 WebSocket 通道。</li>
<li><strong>语义清晰</strong>：URI 本身就携带了连接的上下文信息，非常直观。</li>
<li><strong>简化逻辑</strong>：避免了在连接建立后再通过第一条消息来传递“房间号”之类的元数据，简化了客户端和服务器的协议。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-配置类-ServerEndpointConfig-Configurator-的使用"><a href="#3-2-配置类-ServerEndpointConfig-Configurator-的使用" class="headerlink" title="3.2 配置类 ServerEndpointConfig.Configurator 的使用"></a>3.2 配置类 <code>ServerEndpointConfig.Configurator</code> 的使用</h3><p><code>ServerEndpointConfig.Configurator</code> 是一个强大的钩子 (hook)，它允许你在 WebSocket 握手和端点实例化的过程中进行深度干预。这对于实现认证、授权或动态修改配置等高级功能至关重要。</p>
<ul>
<li><p><strong>使用步骤</strong>：</p>
<ol>
<li><strong>创建一个自定义的 Configurator 类</strong>：<br>这个类需要继承 <code>ServerEndpointConfig.Configurator</code>。</li>
<li><strong>重写关键方法</strong>：<ul>
<li><code>modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</code>:<br>这是最有用的方法。它在 HTTP Upgrade 握手期间被调用。你可以在这里：<ul>
<li><strong>访问 HTTP 请求头</strong> (<code>request.getHeaders()</code>)：可以获取 <code>Cookie</code>, <code>Authorization</code>, <code>Origin</code> 或任何自定义的请求头，用于身份验证或安全检查。</li>
<li><strong>拒绝连接</strong>：如果验证失败，可以抛出一个异常，或者修改 <code>HandshakeResponse</code> 来返回一个非 101 的 HTTP 状态码，从而阻止 WebSocket 连接的建立。</li>
<li><strong>传递信息</strong>：可以将从 HTTP 请求中获取的信息（如用户 ID）存入 <code>ServerEndpointConfig</code> 的 <code>userProperties</code> 中，这些属性随后可以在端点实例中被访问。</li>
</ul>
</li>
<li><code>getEndpointInstance(Class&lt;T&gt; endpointClass)</code>:<br>这个方法用于创建端点类的实例。默认行为是简单地调用 <code>endpointClass.newInstance()</code>。你可以重写它来实现：<ul>
<li><strong>依赖注入</strong>：如果你想在一个非 Spring 环境下为 WebSocket 端点注入依赖（比如一个 <code>UserService</code>），可以在这里手动创建实例并注入。</li>
<li><strong>实例池</strong>：实现一个端点实例池来复用对象（尽管在大多数情况下，每个连接一个新实例是更清晰的模型）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>在 <code>@ServerEndpoint</code> 中关联 Configurator</strong>：<br>使用 <code>configurator</code> 属性指向你的自定义 Configurator 类。</li>
</ol>
</li>
<li><p><strong>示例：基于 Token 的身份验证</strong></p>
<p>假设客户端在建立 WebSocket 连接时，会通过一个名为 <code>X-Auth-Token</code> 的 HTTP 请求头来传递认证令牌。</p>
<p><strong>Step 1: 创建 Configurator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthConfigurator</span> <span class="keyword">extends</span> <span class="title class_">ServerEndpointConfig</span>.Configurator &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyHandshake</span><span class="params">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 HTTP 请求头中的 token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeaders().get(<span class="string">&quot;X-Auth-Token&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 伪代码：验证 token 的有效性</span></span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; isValidToken(token)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Token validation successful.&quot;</span>);</span><br><span class="line">            <span class="comment">// Token 有效，可以将解析出的用户信息存入 userProperties</span></span><br><span class="line">            <span class="comment">// 以便在 @OnOpen 中使用</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> getUserIdFromToken(token);</span><br><span class="line">            sec.getUserProperties().put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Token validation failed. Refusing connection.&quot;</span>);</span><br><span class="line">            <span class="comment">// Token 无效，可以采取措施拒绝连接</span></span><br><span class="line">            <span class="comment">// 抛出异常是 JSR 356 规范中没有明确定义但一些容器支持的方式。</span></span><br><span class="line">            <span class="comment">// 更标准的方式是修改响应，但这在 modifyHandshake 中不易做到。</span></span><br><span class="line">            <span class="comment">// 实际开发中通常在此处记录日志，并在 @OnOpen 中检查属性并立即关闭。</span></span><br><span class="line">            <span class="comment">// 或者直接在此处抛出未检查异常，多数容器会捕获并中止握手。</span></span><br><span class="line">            <span class="comment">// 这里我们简单地设置一个标志</span></span><br><span class="line">            sec.getUserProperties().put(<span class="string">&quot;auth_failed&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="comment">// 实现你的 token 验证逻辑，例如查询数据库或调用认证服务</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;valid-token-string&quot;</span>.equals(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getUserIdFromToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 在端点中应用 Configurator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(value = &quot;/secure/data&quot;, configurator = AuthConfigurator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureDataEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        <span class="comment">// 在 OnOpen 中检查认证结果</span></span><br><span class="line">        <span class="keyword">if</span> (session.getUserProperties().containsKey(<span class="string">&quot;auth_failed&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Authentication failed, closing session.&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.close(<span class="keyword">new</span> <span class="title class_">CloseReason</span>(CloseReason.CloseCodes.VIOLATED_POLICY, <span class="string">&quot;Authentication Failed&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// handle error</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Secure connection established for user: %s (Session ID: %s)%n&quot;</span>, userId, session.getId());</span><br><span class="line">        <span class="comment">// 后续可以将 session 与 userId 关联起来</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>通过这种方式，<code>AuthConfigurator</code> 扮演了一个“门卫”的角色，在连接真正建立之前就完成了安全检查，将业务逻辑与认证逻辑清晰地分离开来。</p>
<hr>
<h2 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h2><h3 id="4-1-项目结构和依赖"><a href="#4-1-项目结构和依赖" class="headerlink" title="4.1 项目结构和依赖"></a>4.1 项目结构和依赖</h3><p>首先，确保你的项目是一个标准的 Web 应用（例如 Maven 的 <code>war</code> packaging），并已添加 <code>jakarta.websocket-api</code> 或 <code>javax.websocket-api</code> 依赖，且 <code>scope</code> 为 <code>provided</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 你还需要一个 Servlet API 依赖，通常也是 provided --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-服务端点-ChatRoomEndpoint-java"><a href="#4-2-服务端点-ChatRoomEndpoint-java" class="headerlink" title="4.2 服务端点 ChatRoomEndpoint.java"></a>4.2 服务端点 <code>ChatRoomEndpoint.java</code></h3><p>这是我们的核心逻辑所在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的多房间聊天室 WebSocket 端点。</span></span><br><span class="line"><span class="comment"> * 用户通过 ws://&lt;host&gt;:&lt;port&gt;/&lt;context&gt;/chat/&#123;username&#125;/&#123;room&#125; 连接。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat/&#123;username&#125;/&#123;room&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatRoomEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态集合，用于存储所有聊天室的会话。</span></span><br><span class="line">    <span class="comment">// Key: 房间名, Value: 该房间内所有会话的 Set。</span></span><br><span class="line">    <span class="comment">// 使用 ConcurrentHashMap 和 CopyOnWriteArraySet 来保证线程安全。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, CopyOnWriteArraySet&lt;Session&gt;&gt; rooms = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个新的 WebSocket 连接建立时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session  代表当前连接的会话对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 从 URL 路径中提取的用户名。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> room     从 URL 路径中提取的房间名。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;username&quot;)</span> String username, <span class="meta">@PathParam(&quot;room&quot;)</span> String room)</span> &#123;</span><br><span class="line">        <span class="comment">// 将用户信息存储在 session 的 userProperties 中，方便后续使用。</span></span><br><span class="line">        session.getUserProperties().put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        session.getUserProperties().put(<span class="string">&quot;room&quot;</span>, room);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将会话加入对应房间的集合中。</span></span><br><span class="line">        <span class="comment">// computeIfAbsent 是一个原子操作，如果 room 不存在，则创建一个新的 Set。</span></span><br><span class="line">        rooms.computeIfAbsent(room, k -&gt; <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;()).add(session);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;User &#x27;%s&#x27; joined room &#x27;%s&#x27;. Session ID: %s%n&quot;</span>, username, room, session.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备一条加入通知消息。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">joinMessage</span> <span class="operator">=</span> String.format(<span class="string">&quot;System: User &#x27;%s&#x27; has joined the room.&quot;</span>, username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向房间内的所有用户广播这条加入消息。</span></span><br><span class="line">        broadcast(room, joinMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当服务器从客户端收到消息时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送的文本消息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 发送消息的会话。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">room</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;room&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;Received message from &#x27;%s&#x27; in room &#x27;%s&#x27;: %s%n&quot;</span>, username, room, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化消息，附带发送者信息。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedMessage</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s: %s&quot;</span>, username, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将消息广播给同一房间内的所有用户（包括发送者自己）。</span></span><br><span class="line">        broadcast(room, formattedMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个 WebSocket 连接关闭时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session     被关闭的会话。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> closeReason 关闭的原因。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">room</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;room&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从房间的会话集合中移除当前会话。</span></span><br><span class="line">        CopyOnWriteArraySet&lt;Session&gt; roomSessions = rooms.get(room);</span><br><span class="line">        <span class="keyword">if</span> (roomSessions != <span class="literal">null</span>) &#123;</span><br><span class="line">            roomSessions.remove(session);</span><br><span class="line">            <span class="comment">// 如果房间变空，可以考虑从 rooms Map 中移除。</span></span><br><span class="line">            <span class="keyword">if</span> (roomSessions.isEmpty()) &#123;</span><br><span class="line">                rooms.remove(room);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;User &#x27;%s&#x27; left room &#x27;%s&#x27;. Reason: %s%n&quot;</span>, username, room, closeReason.getReasonPhrase());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备一条离开通知消息。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">leaveMessage</span> <span class="operator">=</span> String.format(<span class="string">&quot;System: User &#x27;%s&#x27; has left the room.&quot;</span>, username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向房间内剩余的用户广播这条离开消息。</span></span><br><span class="line">        broadcast(room, leaveMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通信过程中发生错误时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session   发生错误的会话。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable 抛出的异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.err.printf(<span class="string">&quot;Error for user &#x27;%s&#x27; in session %s: %s%n&quot;</span>, username, session.getId(), throwable.getMessage());</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">        <span class="comment">// 发生错误后，通常连接会随之关闭，onClose 方法会被调用。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 辅助方法：向指定房间的所有会话广播消息。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> room    房间名。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要广播的消息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">broadcast</span><span class="params">(String room, String message)</span> &#123;</span><br><span class="line">        CopyOnWriteArraySet&lt;Session&gt; sessionsInRoom = rooms.get(room);</span><br><span class="line">        <span class="keyword">if</span> (sessionsInRoom != <span class="literal">null</span>) &#123;</span><br><span class="line">            sessionsInRoom.forEach(session -&gt; &#123;</span><br><span class="line">                <span class="comment">// 使用异步方式发送消息，避免阻塞。</span></span><br><span class="line">                <span class="keyword">synchronized</span> (session) &#123; <span class="comment">// 简单同步，防止多线程同时操作一个 session</span></span><br><span class="line">                    <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                        session.getAsyncRemote().sendText(message, result -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (result.isOK()) &#123;</span><br><span class="line">                                <span class="comment">// System.out.println(&quot;Async message sent to &quot; + session.getId());</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.err.printf(<span class="string">&quot;Failed to send message to session %s: %s%n&quot;</span>,</span><br><span class="line">                                        session.getId(), result.getException().getMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-启用-WebSocket-支持-ApplicationConfig-java"><a href="#4-3-启用-WebSocket-支持-ApplicationConfig-java" class="headerlink" title="4.3 启用 WebSocket 支持 (ApplicationConfig.java)"></a>4.3 启用 WebSocket 支持 (<code>ApplicationConfig.java</code>)</h3><p>为了让 Servlet 容器（如 Tomcat）能够扫描到我们的 <code>@ServerEndpoint</code>，我们需要一个配置类来初始化 WebSocket 环境。最简单的方法是创建一个实现了 <code>ServerApplicationConfig</code> 接口的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类用于告诉容器哪些类是 WebSocket 端点。</span></span><br><span class="line"><span class="comment"> * 容器启动时会自动扫描并加载这个配置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketAppConfig</span> <span class="keyword">implements</span> <span class="title class_">ServerApplicationConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;ServerEndpointConfig&gt; <span class="title function_">getEndpointConfigs</span><span class="params">(Set&lt;Class&lt;? extends Endpoint&gt;&gt; endpointClasses)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个方法可以用于动态创建和配置端点，我们这里用不到，返回空集合即可。</span></span><br><span class="line">        <span class="keyword">return</span> Set.of();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getAnnotatedEndpointClasses(Set&lt;Class&lt;?&gt;&gt; scanned) &#123;</span><br><span class="line">        <span class="comment">// 这个方法是关键。容器会传入所有扫描到的类，我们在这里筛选出带有 @ServerEndpoint 注解的类。</span></span><br><span class="line">        <span class="comment">// 如果你的端点类在扫描路径下，直接返回 scanned 也可以。</span></span><br><span class="line">        <span class="comment">// 为了清晰，我们这里显式地返回我们的端点类。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Scanning for WebSocket endpoints... Found: &quot;</span> + scanned.size());</span><br><span class="line">        </span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; endpoints = Stream.of(</span><br><span class="line">            com.example.websocket.chat.ChatRoomEndpoint.class</span><br><span class="line">        ).collect(Collectors.toSet());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Registering WebSocket endpoints: &quot;</span> + endpoints);</span><br><span class="line">        <span class="keyword">return</span> endpoints;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在实际项目中，更通用的做法是不过滤，让容器自己处理：</span></span><br><span class="line">        <span class="comment">// return scanned;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-客户端测试-index-html"><a href="#4-4-客户端测试-index-html" class="headerlink" title="4.4 客户端测试 (index.html)"></a>4.4 客户端测试 (<code>index.html</code>)</h3><p>创建一个简单的 HTML 页面来测试我们的聊天室。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSR 356 WebSocket Chat<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>: sans-serif; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#chat-window</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>; <span class="attribute">height</span>: <span class="number">300px</span>; <span class="attribute">overflow-y</span>: scroll; <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="attribute">margin-bottom</span>: <span class="number">10px</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#chat-window</span> <span class="selector-tag">p</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#controls</span> <span class="selector-tag">input</span> &#123; <span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">margin-right</span>: <span class="number">10px</span>; &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Simple WebSocket Chat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;connect-controls&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Your Username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;User_&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;room&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Room Name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;general&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;connectBtn&quot;</span>&gt;</span>Connect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;disconnectBtn&quot;</span> <span class="attr">disabled</span>&gt;</span>Disconnect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;chat-window&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;message-controls&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Type a message...&quot;</span> <span class="attr">disabled</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;sendBtn&quot;</span> <span class="attr">disabled</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> usernameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> roomInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;room&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> connectBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;connectBtn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> disconnectBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;disconnectBtn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> chatWindow = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;chat-window&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> messageInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;message&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> sendBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;sendBtn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> websocket;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 动态生成一个唯一用户名</span></span></span><br><span class="line"><span class="language-javascript">        usernameInput.<span class="property">value</span> += <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">logMessage</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            p.<span class="property">textContent</span> = message;</span></span><br><span class="line"><span class="language-javascript">            chatWindow.<span class="title function_">appendChild</span>(p);</span></span><br><span class="line"><span class="language-javascript">            chatWindow.<span class="property">scrollTop</span> = chatWindow.<span class="property">scrollHeight</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        connectBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> username = usernameInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> room = roomInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!username || !room) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&#x27;Username and Room Name cannot be empty.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 注意：这里的 URL 路径需要与你的 Web 应用部署路径匹配。</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 如果你的应用部署在根路径，就是 ws://.../chat/...</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 如果部署在 /my-app，就是 ws://.../my-app/chat/...</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> wsUrl = <span class="string">`ws://<span class="subst">$&#123;<span class="variable language_">window</span>.location.host&#125;</span>/your-app-context/chat/<span class="subst">$&#123;username&#125;</span>/<span class="subst">$&#123;room&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">logMessage</span>(<span class="string">`Connecting to <span class="subst">$&#123;wsUrl&#125;</span>...`</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(wsUrl);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">logMessage</span>(<span class="string">&#x27;Connection established.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                connectBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                disconnectBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                messageInput.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                sendBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">logMessage</span>(event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">logMessage</span>(<span class="string">`Connection closed. Code: <span class="subst">$&#123;event.code&#125;</span>, Reason: <span class="subst">$&#123;event.reason&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                connectBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                disconnectBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                messageInput.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                sendBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">logMessage</span>(<span class="string">&#x27;An error occurred.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket Error:&#x27;</span>, event);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        disconnectBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (websocket) &#123;</span></span><br><span class="line"><span class="language-javascript">                websocket.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        sendBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> message = messageInput.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (message &amp;&amp; websocket &amp;&amp; websocket.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                websocket.<span class="title function_">send</span>(message);</span></span><br><span class="line"><span class="language-javascript">                messageInput.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        messageInput.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (event.<span class="property">key</span> === <span class="string">&#x27;Enter&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                sendBtn.<span class="title function_">click</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：请将 <code>wsUrl</code> 中的 <code>/your-app-context/</code> 替换为你的 Web 应用的实际上下文路径。如果应用部署在根目录，就直接删除它。</p>
<hr>
<h3 id="4-5-部署与测试"><a href="#4-5-部署与测试" class="headerlink" title="4.5 部署与测试"></a>4.5 部署与测试</h3><ol>
<li>将项目打包成 <code>.war</code> 文件。</li>
<li>将 <code>.war</code> 文件部署到任何支持 JSR 356 的 Servlet 容器中，如 Tomcat 8.5+ 或 Jetty 9+。</li>
<li>启动容器。</li>
<li>在浏览器中打开多个标签页，访问 <code>index.html</code>。</li>
<li>在不同的标签页中输入不同的用户名，可以进入相同或不同的房间。</li>
<li>测试发送消息，观察消息是否只在同一房间内广播，以及加入&#x2F;离开的系统通知是否正常工作。</li>
</ol>
<hr>
<h1 id="四、Spring-Boot-集成原生-WebSocket"><a href="#四、Spring-Boot-集成原生-WebSocket" class="headerlink" title="四、Spring Boot 集成原生 WebSocket"></a>四、Spring Boot 集成原生 WebSocket</h1><h2 id="1-核心三步走"><a href="#1-核心三步走" class="headerlink" title="1. 核心三步走"></a>1. 核心三步走</h2><h3 id="1-1-添加依赖"><a href="#1-1-添加依赖" class="headerlink" title="1.1 添加依赖"></a>1.1 添加依赖</h3><p>首先，在你的 <code>pom.xml</code> 文件中添加 Spring Boot 的 WebSocket starter 依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-编写处理器"><a href="#1-2-编写处理器" class="headerlink" title="1.2 编写处理器"></a>1.2 编写处理器</h3><p>在 JSR 356 中，我们使用带注解的 POJO (<code>@ServerEndpoint</code>)。在 Spring 中，我们创建一个<strong>处理器类 (Handler)</strong>，并将其注册为 Spring Bean。这个处理器负责处理 WebSocket 连接的整个生命周期。</p>
<p>Spring 提供了两个方便的抽象基类：</p>
<ul>
<li><code>TextWebSocketHandler</code>: 用于处理文本消息。</li>
<li><code>BinaryWebSocketHandler</code>: 用于处理二进制消息。</li>
</ul>
<p>你需要创建一个类继承其中之一，并重写其关键方法，这些方法与 JSR 356 的生命周期注解一一对应：</p>
<ul>
<li><code>afterConnectionEstablished(WebSocketSession session)</code>: 对应 <code>@OnOpen</code>，在连接建立后调用。</li>
<li><code>handleTextMessage(WebSocketSession session, TextMessage message)</code>: 对应 <code>@OnMessage</code>，在收到文本消息时调用。</li>
<li><code>afterConnectionClosed(WebSocketSession session, CloseStatus status)</code>: 对应 <code>@OnClose</code>，在连接关闭后调用。</li>
<li><code>handleTransportError(WebSocketSession session, Throwable exception)</code>: 对应 <code>@OnError</code>，在发生传输错误时调用。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 关键：将这个 Handler 注册为 Spring Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebSocketHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存储所有活动会话的线程安全集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;WebSocketSession&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sessions.add(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;New connection established: &quot;</span> + session.getId());</span><br><span class="line">        <span class="comment">// 可以向新连接发送欢迎消息</span></span><br><span class="line">        session.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(<span class="string">&quot;Welcome to the WebSocket server!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> message.getPayload();</span><br><span class="line">        System.out.println(<span class="string">&quot;Received message: &quot;</span> + payload + <span class="string">&quot; from session: &quot;</span> + session.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单的广播逻辑：将收到的消息发给所有其他会话</span></span><br><span class="line">        <span class="keyword">for</span> (WebSocketSession webSocketSession : sessions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (webSocketSession.isOpen() &amp;&amp; !session.getId().equals(webSocketSession.getId())) &#123;</span><br><span class="line">                webSocketSession.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(<span class="string">&quot;Broadcast: &quot;</span> + payload));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + session.getId() + <span class="string">&quot; with status: &quot;</span> + status.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Error for session &quot;</span> + session.getId() + <span class="string">&quot;: &quot;</span> + exception.getMessage());</span><br><span class="line">        <span class="comment">// 发生错误后，Spring 通常会自动关闭会话，所以 afterConnectionClosed 也会被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-注册处理器"><a href="#1-3-注册处理器" class="headerlink" title="1.3 注册处理器"></a>1.3 注册处理器</h3><p>我们已经创建了处理器 Bean，但 Spring 并不知道应该在哪个 URL 路径上激活这个处理器。我们需要一个配置类来完成这个“映射”。</p>
<ol>
<li>创建一个 Java 配置类，并注解为 <code>@Configuration</code>。</li>
<li>使用 <code>@EnableWebSocket</code> 注解来开启 Spring 的 WebSocket 功能。</li>
<li>实现 <code>WebSocketConfigurer</code> 接口。</li>
<li>重写 <code>registerWebSocketHandlers(WebSocketHandlerRegistry registry)</code> 方法，在其中注册你的处理器。</li>
</ol>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span> <span class="comment">// 开启 WebSocket 支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyWebSocketHandler myWebSocketHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造器注入我们之前创建的 Handler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WebSocketConfig</span><span class="params">(MyWebSocketHandler myWebSocketHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myWebSocketHandler = myWebSocketHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(myWebSocketHandler, <span class="string">&quot;/my-handler&quot;</span>) <span class="comment">// 注册 Handler 到指定的路径</span></span><br><span class="line">                .setAllowedOrigins(<span class="string">&quot;*&quot;</span>); <span class="comment">// 解决跨域问题</span></span><br><span class="line">                <span class="comment">// .withSockJS(); // (可选) 如果需要支持不支持 WebSocket 的旧浏览器，可以开启 SockJS 后备选项</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>registry.addHandler(myWebSocketHandler, &quot;/my-handler&quot;)</code>: 这行代码是核心，它告诉 Spring：“当有 WebSocket 连接请求访问 <code>/my-handler</code> 这个路径时，请交由 <code>myWebSocketHandler</code> 这个 Bean 来处理。”</li>
<li><code>.setAllowedOrigins(&quot;*&quot;)</code>: 这是非常重要的配置，用于处理浏览器的跨域请求。<code>&quot;*&quot;</code> 表示允许来自任何源的连接，在生产环境中应配置为具体的域名列表。</li>
<li><code>.withSockJS()</code>: 这是一个强大的后备选项。如果客户端的浏览器不支持 WebSocket，SockJS 会自动降级，使用 HTTP 长轮询等技术来模拟 WebSocket 通信，对上层应用代码是透明的。</li>
</ul>
<p>完成这三步之后，启动你的 Spring Boot 应用。一个位于 <code>ws://localhost:8080/my-handler</code> 的 WebSocket 服务就已经在运行了。这套流程充分体现了 Spring 框架“约定优于配置”和“依赖注入”的设计哲学。</p>
<hr>
<h2 id="2-核心组件详解"><a href="#2-核心组件详解" class="headerlink" title="2. 核心组件详解"></a>2. 核心组件详解</h2><p>在 Spring WebSocket 中，我们不直接与底层的 Servlet API 或 JSR-356 API 交互，而是通过 Spring 提供的一系列高度封装和抽象的组件。理解这些核心组件是掌握 Spring WebSocket 的关键。</p>
<hr>
<h3 id="2-1-Spring-封装的会话对象"><a href="#2-1-Spring-封装的会话对象" class="headerlink" title="2.1 Spring 封装的会话对象"></a>2.1 Spring 封装的会话对象</h3><p><code>WebSocketSession</code> 是 Spring 对一个 WebSocket 连接的抽象，可以将其理解为一个特定客户端连接的会话句柄。它在原生 <code>javax.websocket.Session</code> 的基础上进行了功能增强和整合，使其与 Spring 生态无缝集成。</p>
<p><strong><code>WebSocketSession</code> 与原生 <code>Session</code> 的异同：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Spring <code>WebSocketSession</code></th>
<th align="left">原生 <code>javax.websocket.Session</code> (JSR-356)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left">Spring WebSocket 模块提供的接口，是 Spring 对 WebSocket 连接的统一抽象。</td>
<td align="left">Java EE 规范 (JSR-356) 中定义的标准接口。</td>
</tr>
<tr>
<td align="left"><strong>获取方式</strong></td>
<td align="left">作为 <code>WebSocketHandler</code> 方法的参数传入。</td>
<td align="left">通过 <code>@OnOpen</code> 等注解的方法参数传入。</td>
</tr>
<tr>
<td align="left"><strong>发送消息</strong></td>
<td align="left"><code>sendMessage(WebSocketMessage&lt;?&gt; message)</code></td>
<td align="left"><code>getBasicRemote().sendText(String text)</code> 或 <code>getAsyncRemote().sendBinary(ByteBuffer data)</code></td>
</tr>
<tr>
<td align="left"><strong>会话属性</strong></td>
<td align="left"><code>Map&lt;String, Object&gt; getAttributes()</code>，与 <code>HandshakeInterceptor</code> 强关联，是传递认证信息和业务数据的核心。</td>
<td align="left"><code>Map&lt;String, Object&gt; getUserProperties()</code>，功能类似，但与 Spring 生态集成度低。</td>
</tr>
<tr>
<td align="left"><strong>用户身份</strong></td>
<td align="left"><code>getPrincipal()</code> 方法，可以方便地与 Spring Security 集成，直接获取认证后的用户信息 (<code>Principal</code> 对象)。</td>
<td align="left">需要手动从 <code>getUserProperties()</code> 中获取或通过其他方式管理用户身份。</td>
</tr>
<tr>
<td align="left"><strong>实现无关性</strong></td>
<td align="left">屏蔽了底层 WebSocket 服务器（如 Tomcat, Jetty, Undertow）的实现差异，提供统一的编程模型。</td>
<td align="left">实现由具体的 Servlet 容器提供，理论上可移植，但 Spring 提供了更高层次的抽象。</td>
</tr>
<tr>
<td align="left"><strong>关闭连接</strong></td>
<td align="left"><code>close()</code> 或 <code>close(CloseStatus status)</code></td>
<td align="left"><code>close()</code> 或 <code>close(CloseReason reason)</code></td>
</tr>
</tbody></table>
<p><strong>核心方法与属性解读：</strong></p>
<ul>
<li><strong><code>String getId()</code></strong>: 获取 Spring 自动生成的唯一会话 ID。</li>
<li><strong><code>URI getUri()</code></strong>: 获取客户端连接的 URI。</li>
<li><strong><code>Map&lt;String, Object&gt; getAttributes()</code></strong>: <strong>【极其重要】</strong> 获取在握手阶段 <code>HandshakeInterceptor</code> 中存入的属性。这是从 HTTP 握手上下文向 WebSocket 会话传递数据的<strong>核心桥梁</strong>。例如，可以存放用户 ID、租户信息等。</li>
<li><strong><code>Principal getPrincipal()</code></strong>: 如果集成了 Spring Security，此方法可以直接返回当前会-话关联的认证主体。</li>
<li><strong><code>void sendMessage(WebSocketMessage&lt;?&gt; message)</code></strong>: 发送消息到客户端。参数是 <code>TextMessage</code> 或 <code>BinaryMessage</code> 的实例。</li>
<li><strong><code>boolean isOpen()</code></strong>: 判断连接是否依然处于打开状态。</li>
<li><strong><code>void close(CloseStatus status)</code></strong>: 以指定的状态码和原因关闭连接。</li>
</ul>
<p><strong>使用场景示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 WebSocketHandler 的实现中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 从 session 的 attributes 中获取握手时存入的用户ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getAttributes().get(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;用户 &quot;</span> + userId + <span class="string">&quot; 连接成功，会话ID: &quot;</span> + session.getId());</span><br><span class="line">    <span class="comment">// 将 session 存入一个Map，以便后续根据用户ID查找并发送消息</span></span><br><span class="line">    sessionMap.put(userId, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-握手拦截器"><a href="#2-2-握手拦截器" class="headerlink" title="2.2 握手拦截器"></a>2.2 握手拦截器</h3><p><code>HandshakeInterceptor</code> 是一个典型的拦截器（或AOP）模式应用。它在 WebSocket 的“握手”阶段（即客户端发起 HTTP Upgrade 请求时）介入，允许你在连接正式建立之前执行自定义逻辑。</p>
<p><strong>核心用途：</strong></p>
<ol>
<li><strong>身份验证与授权</strong>：这是最常见的用途。拦截器可以检查 HTTP 请求中的 <code>Cookie</code>, <code>Authorization</code> Header (如 JWT)，或者 <code>HttpSession</code>，判断用户是否已登录、是否有权限建立 WebSocket 连接。</li>
<li><strong>传递属性</strong>：将从 HTTP 请求中获取的信息（如用户ID、设备信息等）存入 <code>WebSocketSession</code> 的 <code>attributes</code> 中，供后续的 <code>WebSocketHandler</code> 使用。</li>
<li><strong>连接拒绝</strong>：如果验证失败，可以直接中断握手过程，拒绝 WebSocket 连接。</li>
</ol>
<p><strong>核心方法详解：</strong></p>
<ul>
<li><strong><code>boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</code></strong>:<ul>
<li><strong>执行时机</strong>：在握手发生之前调用。</li>
<li><strong>参数解读</strong>：<ul>
<li><code>request</code>: 强转为 <code>ServletServerHttpRequest</code> 后，可从中获取 <code>HttpServletRequest</code>，进而拿到 <code>HttpSession</code>、<code>Headers</code>、<code>Cookies</code> 等所有 HTTP 相关信息。</li>
<li><code>response</code>: 如果需要拒绝连接，可以通过它设置 HTTP 状态码，例如 <code>response.setStatusCode(HttpStatus.FORBIDDEN)</code>。</li>
<li><code>wsHandler</code>: 即将处理此 WebSocket 连接的 <code>WebSocketHandler</code> 实例。</li>
<li><code>attributes</code>: <strong>【关键】</strong> 一个空的 <code>Map</code>。你可以在此方法中向这个 <code>Map</code> 填充数据，这些数据随后会被复制到 <code>WebSocketSession</code> 的 <code>attributes</code> 中。</li>
</ul>
</li>
<li><strong>返回值</strong>：<ul>
<li><code>true</code>: 握手继续，连接将建立。</li>
<li><code>false</code>: 握手被中断，连接建立失败。此时应通过 <code>response</code> 对象返回一个合适的 HTTP 错误码。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception exception)</code></strong>:<ul>
<li><strong>执行时机</strong>：在握手成功或失败之后调用。</li>
<li><strong>参数解读</strong>：<ul>
<li><code>exception</code>: 如果握手过程中发生异常，此参数将不为 <code>null</code>。</li>
</ul>
</li>
<li><strong>主要用途</strong>：记录日志、资源清理等。无论握手成功与否，此方法都会被调用。</li>
</ul>
</li>
</ul>
<p><strong>实践代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                                   WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 将 request 强转为 ServletServerHttpRequest 以获取 HttpSession</span></span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletServerHttpRequest) &#123;</span><br><span class="line">            <span class="type">ServletServerHttpRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> (ServletServerHttpRequest) request;</span><br><span class="line">            <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> servletRequest.getServletRequest().getSession(<span class="literal">false</span>); <span class="comment">// false表示不创建新session</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (session != <span class="literal">null</span> &amp;&amp; session.getAttribute(<span class="string">&quot;LOGGED_IN_USER_ID&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 用户已登录，将用户ID存入WebSocket的attributes</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;LOGGED_IN_USER_ID&quot;</span>);</span><br><span class="line">                attributes.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">                System.out.println(<span class="string">&quot;握手拦截器：用户 &quot;</span> + userId + <span class="string">&quot; 验证通过。&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 允许握手</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用户未登录或 session 不存在，拒绝握手</span></span><br><span class="line">        System.out.println(<span class="string">&quot;握手拦截器：未认证用户，拒绝连接。&quot;</span>);</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED); <span class="comment">// 401 Unauthorized</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 拒绝握手</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                               WebSocketHandler wsHandler, Exception exception)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处可以记录日志，例如 &quot;Handshake completed&quot; or &quot;Handshake failed with exception: ...&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-消息载体对象"><a href="#2-3-消息载体对象" class="headerlink" title="2.3 消息载体对象"></a>2.3 消息载体对象</h3><p>WebSocket 协议支持两种基本的数据帧类型：文本帧（Text Frame）和二进制帧（Binary Frame）。Spring WebSocket 提供了 <code>TextMessage</code> 和 <code>BinaryMessage</code> 这两个具体的类来分别承载这两种类型的消息。它们都继承自抽象类 <code>WebSocketMessage</code>。</p>
<p><strong><code>TextMessage</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：用于传输纯文本数据，最常见的如 <strong>JSON</strong>、XML、或者简单的字符串命令。</p>
</li>
<li><p><strong>构造</strong>：<code>new TextMessage(&quot;your string payload&quot;)</code>。</p>
</li>
<li><p><strong>获取内容</strong>：<code>getPayload()</code> 方法返回一个 <code>String</code>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送JSON字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;type\&quot;:\&quot;chat\&quot;, \&quot;content\&quot;:\&quot;Hello, world!\&quot;&#125;&quot;</span>;</span><br><span class="line">session.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(json));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 handleTextMessage 方法中接收</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> message.getPayload(); <span class="comment">// payload 是 &quot;&#123;\&quot;type\&quot;:\&quot;chat\&quot;, ...&#125;&quot;</span></span><br><span class="line">    <span class="comment">// 后续通常会用 Jackson 或 Gson 等库将 payload 解析为 Java 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>BinaryMessage</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：用于传输非文本数据，如图片、音频、视频流、文件，或者经过 Protobuf&#x2F;Thrift 等序列化框架编码后的二进制数据。</p>
</li>
<li><p><strong>构造</strong>：<code>new BinaryMessage(byte[] payload)</code> 或 <code>new BinaryMessage(ByteBuffer payload)</code>。</p>
</li>
<li><p><strong>获取内容</strong>：<code>getPayload()</code> 方法返回一个 <code>ByteBuffer</code>。你可以通过 <code>byteBuffer.array()</code> 转换为 <code>byte[]</code>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一张图片的字节数据</span></span><br><span class="line"><span class="type">byte</span>[] imageBytes = readImageFromFile(<span class="string">&quot;path/to/image.jpg&quot;</span>);</span><br><span class="line">session.sendMessage(<span class="keyword">new</span> <span class="title class_">BinaryMessage</span>(imageBytes));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 handleBinaryMessage 方法中接收</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleBinaryMessage</span><span class="params">(WebSocketSession session, BinaryMessage message)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">payload</span> <span class="operator">=</span> message.getPayload();</span><br><span class="line">    <span class="type">byte</span>[] binaryData = <span class="keyword">new</span> <span class="title class_">byte</span>[payload.remaining()];</span><br><span class="line">    payload.get(binaryData);</span><br><span class="line">    <span class="comment">// 后续可以处理这些二进制数据，如存为文件、显示图片等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>补充：消息分片（Message Fragmentation）</strong></p>
<p>对于非常大的消息，WebSocket 允许将其分割成多个帧进行传输。</p>
<ul>
<li><code>WebSocketMessage</code> 有一个 <code>isLast()</code> 方法，<code>true</code> 表示这是消息的最后一个分片。</li>
<li>在 <code>AbstractWebSocketHandler</code> 中，默认行为是<strong>缓冲所有分片</strong>，直到接收完最后一个分片，然后将它们合并成一个完整的 <code>TextMessage</code> 或 <code>BinaryMessage</code>，再调用 <code>handleTextMessage</code> 或 <code>handleBinaryMessage</code>。</li>
<li>这意味着在大多数情况下，你无需关心消息分片问题，Spring 已经为你处理好了。如果需要处理流式大数据，可以重写 <code>supportsPartialMessages()</code> 返回 <code>true</code>，并实现 <code>handleMessage()</code> 来处理每一个分片。但这属于高级用法。</li>
</ul>
<hr>
<h2 id="3-实践技巧"><a href="#3-实践技巧" class="headerlink" title="3. 实践技巧"></a>3. 实践技巧</h2><h4 id="3-1-管理所有-WebSocketSession-实现广播功能"><a href="#3-1-管理所有-WebSocketSession-实现广播功能" class="headerlink" title="3.1 管理所有 WebSocketSession 实现广播功能"></a>3.1 管理所有 <code>WebSocketSession</code> 实现广播功能</h4><p>广播（Broadcast）是指向所有当前连接的客户端发送同一条消息。这是许多实时应用的常见需求，例如系统公告、在线用户列表更新等。</p>
<p>要实现广播，服务器端必须持有一个所有活动 <code>WebSocketSession</code> 的引用集合。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><strong>选择一个线程安全的集合</strong>：<br>由于 WebSocket 的连接和断开是并发操作（可能多个用户同时连接或断开），用于存储 <code>WebSocketSession</code> 的集合<strong>必须是线程安全的</strong>。<ul>
<li><strong><code>CopyOnWriteArraySet&lt;WebSocketSession&gt;</code></strong>：<strong>强烈推荐用于广播场景</strong>。它是一个线程安全的 <code>Set</code>。其特点是“写入时复制”，读操作（迭代）非常快且不需要加锁，非常适合“读多写少”的场景。广播就是典型的读多场景，而连接&#x2F;断开（写操作）相对较少。</li>
<li><code>ConcurrentHashMap&lt;String, WebSocketSession&gt;</code>：当你不仅需要广播，还需要根据特定标识（如用户ID）快速查找并向单个用户发送消息时，这是更好的选择。键（<code>String</code>）可以是 <code>session.getId()</code> 或更业务化的用户ID。</li>
</ul>
</li>
<li><strong>在 <code>WebSocketHandler</code> 中维护该集合</strong>：<br>在你的 <code>WebSocketHandler</code> 实现类中，声明这个线程安全的集合作为成员变量。</li>
<li><strong>在连接生命周期方法中更新集合</strong>：<ul>
<li>在 <code>afterConnectionEstablished()</code> 方法中，将新建立的 <code>WebSocketSession</code> 添加到集合中。</li>
<li>在 <code>afterConnectionClosed()</code> 方法中，将已关闭的 <code>WebSocketSession</code> 从集合中移除，以防内存泄漏和向无效连接发送消息。</li>
</ul>
</li>
<li><strong>实现广播方法</strong>：<br>遍历集合，对每一个 <code>WebSocketSession</code> 调用 <code>sendMessage()</code> 方法。</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBroadcastHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用 CopyOnWriteArraySet 存储所有 session，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;WebSocketSession&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 2. 连接建立后，将 session 添加到集合中</span></span><br><span class="line">        sessions.add(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;新连接加入! 当前在线人数: &quot;</span> + sessions.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// (可选) 可以向新连接发送一条欢迎消息或当前状态</span></span><br><span class="line">        session.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(<span class="string">&quot;欢迎连接到广播服务！&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 当一个客户端发送消息时，我们将其广播给所有客户端</span></span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息: &quot;</span> + message.getPayload());</span><br><span class="line">        broadcast(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 3. 连接关闭后，将 session 从集合中移除</span></span><br><span class="line">        sessions.remove(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;一个连接关闭! 当前在线人数: &quot;</span> + sessions.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 传输发生错误时，也需要从集合中移除 session</span></span><br><span class="line">        System.err.println(<span class="string">&quot;连接出现错误: &quot;</span> + exception.getMessage());</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4. 实现广播消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">broadcast</span><span class="params">(TextMessage message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (WebSocketSession session : sessions) &#123;</span><br><span class="line">            <span class="comment">// 检查 session 是否还打开</span></span><br><span class="line">            <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 发送消息</span></span><br><span class="line">                    session.sendMessage(message);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// 记录错误，通常这里不需要做特别处理，因为 afterConnectionClosed 会处理会话移除</span></span><br><span class="line">                    System.err.println(<span class="string">&quot;广播消息失败: &quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-结合-HandshakeInterceptor-和-WebSocketSession-实现用户身份识别"><a href="#3-2-结合-HandshakeInterceptor-和-WebSocketSession-实现用户身份识别" class="headerlink" title="3.2 结合 HandshakeInterceptor 和 WebSocketSession 实现用户身份识别"></a>3.2 结合 <code>HandshakeInterceptor</code> 和 <code>WebSocketSession</code> 实现用户身份识别</h4><p>匿名连接在很多场景下是无用的。我们通常需要知道每个 <code>WebSocketSession</code> 对应的是哪个用户。这个身份识别的过程完美地体现了 <code>HandshakeInterceptor</code> 和 <code>WebSocketSession</code> 的协同工作。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><strong>客户端在握手时提供身份信息</strong>：<ul>
<li><strong>对于有状态Web应用</strong>：通常浏览器在发起 WebSocket 连接请求时会自动带上 <code>Cookie</code>，其中包含了 <code>JSESSIONID</code>。</li>
<li><strong>对于无状态&#x2F;前后端分离应用</strong>：客户端通常会在 URL 查询参数 (<code>ws://.../?token=xxx</code>) 或 HTTP Header (<code>Authorization: Bearer xxx</code>) 中携带认证凭证（如 JWT）。</li>
</ul>
</li>
<li><strong>创建 <code>HandshakeInterceptor</code> 进行身份验证</strong>：<ul>
<li>实现 <code>HandshakeInterceptor</code> 接口，重点是 <code>beforeHandshake</code> 方法。</li>
<li>在 <code>beforeHandshake</code> 中，从 <code>ServerHttpRequest</code> 中获取身份信息。</li>
<li>验证身份。如果验证失败，返回 <code>false</code> 拒绝连接。</li>
<li>如果验证成功，将用户的唯一标识（如用户ID）存入 <code>attributes</code> 这个 <code>Map</code> 中。</li>
</ul>
</li>
<li><strong>在 <code>WebSocketHandler</code> 中获取并使用用户身份</strong>：<ul>
<li>在 <code>afterConnectionEstablished</code> 或其他处理器方法中，通过 <code>session.getAttributes().get(&quot;yourKey&quot;)</code> 来获取之前存入的用户ID。</li>
<li>利用这个ID，你可以实现更复杂的逻辑，例如：<ul>
<li>维护一个 <code>ConcurrentHashMap&lt;String, WebSocketSession&gt;</code> 来实现<strong>向指定用户发送消息</strong>。</li>
<li>记录用户行为日志。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>代码示例：</strong></p>
<p><strong>第一步：创建握手拦截器 <code>AuthHandshakeInterceptor</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                                   WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 场景：从 HttpSession 中获取登录用户ID</span></span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletServerHttpRequest) &#123;</span><br><span class="line">            <span class="type">ServletServerHttpRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> (ServletServerHttpRequest) request;</span><br><span class="line">            <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> servletRequest.getServletRequest().getSession(<span class="literal">false</span>); <span class="comment">// false:不创建新session</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 假设登录后，用户ID被存储在HttpSession的 &quot;userId&quot; 属性中</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (userId != <span class="literal">null</span> &amp;&amp; !userId.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 验证通过，将 userId 放入 WebSocketSession 的 attributes 中</span></span><br><span class="line">                    attributes.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">                    System.out.println(<span class="string">&quot;握手成功，用户ID: &quot;</span> + userId);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 允许握手</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是JWT，则可以这样获取:</span></span><br><span class="line">        <span class="comment">// String token = request.getHeaders().getFirst(&quot;Authorization&quot;);</span></span><br><span class="line">        <span class="comment">// if (jwtUtil.validate(token)) &#123;</span></span><br><span class="line">        <span class="comment">//     String userId = jwtUtil.getUserIdFrom(token);</span></span><br><span class="line">        <span class="comment">//     attributes.put(&quot;userId&quot;, userId);</span></span><br><span class="line">        <span class="comment">//     return true;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;握手失败，用户未认证！&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证失败，拒绝握手</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                               WebSocketHandler wsHandler, Exception exception)</span> &#123;</span><br><span class="line">        <span class="comment">// 握手后的操作，无论成功失败都会执行，可用于记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：在 <code>WebSocketConfig</code> 中注册拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(myBroadcastHandler(), <span class="string">&quot;/broadcast&quot;</span>)</span><br><span class="line">                .addInterceptors(<span class="keyword">new</span> <span class="title class_">AuthHandshakeInterceptor</span>()) <span class="comment">// &lt;-- 在这里添加拦截器</span></span><br><span class="line">                .setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBroadcastHandler <span class="title function_">myBroadcastHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBroadcastHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：在 <code>WebSocketHandler</code> 中使用身份信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 从 session 的 attributes 中获取握手时存入的用户ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getAttributes().get(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (userId != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户 &quot;</span> + userId + <span class="string">&quot; 连接成功！&quot;</span>);</span><br><span class="line">        <span class="comment">// 此时，你可以将 userId 和 session 的关系存储起来，用于后续的单点消息发送</span></span><br><span class="line">        <span class="comment">// userSessionMap.put(userId, session);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-示例代码-1"><a href="#4-示例代码-1" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h2><p><strong>业务目标：</strong></p>
<ol>
<li>当一个新用户连接时，所有已在线的用户都会收到通知，告知新用户加入了，并更新自己的在线用户列表。</li>
<li>当一个用户断开连接时，所有剩余的在线用户都会收到通知，告知该用户已离开，并更新自己的在线用户列表。</li>
<li>客户端通过 WebSocket URL 的查询参数传递自己的用户名，例如 <code>ws://localhost:8080/status?username=Alice</code>。</li>
<li>服务器拒绝重名用户的连接。</li>
</ol>
<p>这个示例将完美地演示 <code>HandshakeInterceptor</code>（用于身份识别和验证）和 <code>WebSocketHandler</code>（用于会话管理和广播）的协同工作。</p>
<hr>
<h3 id="4-1-项目设置-pom-xml"><a href="#4-1-项目设置-pom-xml" class="headerlink" title="4.1 项目设置 (pom.xml)"></a>4.1 项目设置 (pom.xml)</h3><p>确保你的 Spring Boot 项目中包含了 WebSocket 的启动器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... 其他依赖 ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-创建握手拦截器-UserStatusHandshakeInterceptor"><a href="#4-2-创建握手拦截器-UserStatusHandshakeInterceptor" class="headerlink" title="4.2 创建握手拦截器 (UserStatusHandshakeInterceptor)"></a>4.2 创建握手拦截器 (<code>UserStatusHandshakeInterceptor</code>)</h3><p>这个拦截器的职责是：</p>
<ol>
<li>从连接请求的 URI 中解析出 <code>username</code>。</li>
<li>验证 <code>username</code> 是否存在且不重复。</li>
<li>如果验证通过，将 <code>username</code> 存入 <code>attributes</code>，以便后续的 <code>WebSocketHandler</code> 使用。</li>
<li>如果验证失败，中断握手。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserStatusHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                                   WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从 URI 中解析出 username</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> UriComponentsBuilder.fromUri(request.getURI())</span><br><span class="line">                .build()</span><br><span class="line">                .getQueryParams()</span><br><span class="line">                .getFirst(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 验证 username 是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(username)) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;握手失败：username 参数为空&quot;</span>);</span><br><span class="line">            response.setStatusCode(HttpStatus.BAD_REQUEST); <span class="comment">// 400 Bad Request</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 验证 username 是否已在线 (简单起见，我们直接访问 Handler 里的静态 Map)</span></span><br><span class="line">        <span class="keyword">if</span> (OnlineStatusHandler.isUserOnline(username)) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;握手失败：用户 &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; 已在线&quot;</span>);</span><br><span class="line">            response.setStatusCode(HttpStatus.CONFLICT); <span class="comment">// 409 Conflict</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将 username 存入 attributes，传递给 WebSocketHandler</span></span><br><span class="line">        attributes.put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        System.out.println(<span class="string">&quot;握手成功，用户: &quot;</span> + username);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                               WebSocketHandler wsHandler, Exception exception)</span> &#123;</span><br><span class="line">        <span class="comment">// 无需实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-创建-WebSocket-处理器-OnlineStatusHandler"><a href="#4-3-创建-WebSocket-处理器-OnlineStatusHandler" class="headerlink" title="4.3 创建 WebSocket 处理器 (OnlineStatusHandler)"></a>4.3 创建 WebSocket 处理器 (<code>OnlineStatusHandler</code>)</h3><p>这个处理器的职责是：</p>
<ol>
<li>管理所有在线用户的 <code>WebSocketSession</code>。我们使用 <code>ConcurrentHashMap&lt;String, WebSocketSession&gt;</code> 来存储用户名到会话的映射。</li>
<li>在 <code>afterConnectionEstablished</code> 中，将新用户加入 Map，并广播“用户加入”的消息。</li>
<li>在 <code>afterConnectionClosed</code> 中，将用户从 Map 中移除，并广播“用户离开”的消息。</li>
<li>提供一个 <code>broadcastStatusUpdate</code> 方法来统一处理广播逻辑。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnlineStatusHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ConcurrentHashMap 存储在线用户的 session，key 是 username</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, WebSocketSession&gt; userSessions = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>(); <span class="comment">// 用于序列化 JSON</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getAttributes().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        userSessions.put(username, session);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户 &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; 连接成功. 当前在线人数: &quot;</span> + userSessions.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广播状态更新</span></span><br><span class="line">        broadcastStatusUpdate(<span class="string">&quot;USER_JOIN&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getAttributes().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        userSessions.remove(username);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户 &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; 断开连接. 当前在线人数: &quot;</span> + userSessions.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广播状态更新</span></span><br><span class="line">        broadcastStatusUpdate(<span class="string">&quot;USER_LEAVE&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广播用户状态更新</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type &quot;USER_JOIN&quot; 或 &quot;USER_LEAVE&quot;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 发生状态改变的用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">broadcastStatusUpdate</span><span class="params">(String type, String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 构建消息体</span></span><br><span class="line">        Map&lt;String, Object&gt; messagePayload = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        messagePayload.put(<span class="string">&quot;type&quot;</span>, type);</span><br><span class="line">        messagePayload.put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        messagePayload.put(<span class="string">&quot;onlineUsers&quot;</span>, userSessions.keySet()); <span class="comment">// 发送当前所有在线用户的列表</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TextMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextMessage</span>(objectMapper.writeValueAsString(messagePayload));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向所有在线用户广播</span></span><br><span class="line">        <span class="keyword">for</span> (WebSocketSession session : userSessions.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                session.sendMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法，用于拦截器检查用户是否已在线</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isUserOnline</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userSessions.containsKey(username);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这个示例中，我们不处理客户端发来的消息，但保留该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 可以用于实现心跳等功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;收到来自 &quot;</span> + session.getAttributes().get(<span class="string">&quot;username&quot;</span>) + <span class="string">&quot; 的消息: &quot;</span> + message.getPayload());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Pro Tip</strong>: 在更大型的应用中，<code>userSessions</code> 这个 Map 最好放在一个单独的 <code>@Service</code> Bean 中，然后注入到 Handler 和 Interceptor 里，而不是使用 <code>static</code> 变量。这更符合 Spring 的依赖注入思想。</p>
<hr>
<h3 id="4-4-配置-WebSocket-WebSocketConfig"><a href="#4-4-配置-WebSocket-WebSocketConfig" class="headerlink" title="4.4 配置 WebSocket (WebSocketConfig)"></a>4.4 配置 WebSocket (<code>WebSocketConfig</code>)</h3><p>将我们创建的 Handler 和 Interceptor 注册到 Spring WebSocket 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span> <span class="comment">// 开启 WebSocket 支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OnlineStatusHandler onlineStatusHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserStatusHandshakeInterceptor userStatusHandshakeInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(onlineStatusHandler, <span class="string">&quot;/status&quot;</span>) <span class="comment">// 注册处理器到 &quot;/status&quot; 路径</span></span><br><span class="line">                .addInterceptors(userStatusHandshakeInterceptor) <span class="comment">// 添加握手拦截器</span></span><br><span class="line">                .setAllowedOrigins(<span class="string">&quot;*&quot;</span>); <span class="comment">// 允许跨域访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-5-创建前端测试页面-index-html"><a href="#4-5-创建前端测试页面-index-html" class="headerlink" title="4.5 创建前端测试页面 (index.html)"></a>4.5 创建前端测试页面 (<code>index.html</code>)</h3><p>创建一个简单的 HTML 文件来测试我们的服务。你可以将它放在 <code>src/main/resources/static/index.html</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket Online Status Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>: sans-serif; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#controls</span>, <span class="selector-id">#status</span>, <span class="selector-id">#users</span> &#123; <span class="attribute">margin-bottom</span>: <span class="number">20px</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#user-list</span> &#123; <span class="attribute">list-style-type</span>: none; <span class="attribute">padding</span>: <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#user-list</span> <span class="selector-tag">li</span> &#123; <span class="attribute">background</span>: <span class="number">#f0f0f0</span>; <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">8px</span>; <span class="attribute">border-radius</span>: <span class="number">4px</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#log</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>; <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="attribute">height</span>: <span class="number">200px</span>; <span class="attribute">overflow-y</span>: scroll; <span class="attribute">background</span>: <span class="number">#fafafa</span>; &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>在线用户状态广播服务<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;controls&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username-input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入你的用户名&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;connect()&quot;</span>&gt;</span>连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;disconnect()&quot;</span> <span class="attr">disabled</span>&gt;</span>断开<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>在线用户 (<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;user-count&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>)<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;user-list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;status&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>系统日志<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> websocket = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> usernameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username-input&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> connectBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button[onclick=&quot;connect()&quot;]&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> disconnectBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button[onclick=&quot;disconnect()&quot;]&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> logDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;log&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> userList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;user-list&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> userCount = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;user-count&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            logDiv.<span class="property">innerHTML</span> += <span class="string">`&lt;p&gt;<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;</span>: <span class="subst">$&#123;message&#125;</span>&lt;/p&gt;`</span>;</span></span><br><span class="line"><span class="language-javascript">            logDiv.<span class="property">scrollTop</span> = logDiv.<span class="property">scrollHeight</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> username = usernameInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!username) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&#x27;请输入用户名!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> url = <span class="string">`ws://localhost:8080/status?username=<span class="subst">$&#123;username&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">            websocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(url);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">log</span>(<span class="string">`与服务器连接成功！`</span>);</span></span><br><span class="line"><span class="language-javascript">                usernameInput.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                connectBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                disconnectBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">log</span>(<span class="string">`收到消息: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;USER_JOIN&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">log</span>(<span class="string">`[系统] 用户 &quot;<span class="subst">$&#123;data.username&#125;</span>&quot; 加入了聊天室。`</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;USER_LEAVE&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">log</span>(<span class="string">`[系统] 用户 &quot;<span class="subst">$&#123;data.username&#125;</span>&quot; 离开了聊天室。`</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 更新在线用户列表</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">updateUserList</span>(data.<span class="property">onlineUsers</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">log</span>(<span class="string">`连接已关闭。原因: <span class="subst">$&#123;event.reason || <span class="string">&#x27;未知&#x27;</span>&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">resetUI</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">log</span>(<span class="string">`发生错误: <span class="subst">$&#123;event.message || <span class="string">&#x27;连接失败&#x27;</span>&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">resetUI</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">disconnect</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (websocket) &#123;</span></span><br><span class="line"><span class="language-javascript">                websocket.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">updateUserList</span>(<span class="params">users</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            userList.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            users.<span class="title function_">forEach</span>(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                li.<span class="property">textContent</span> = user;</span></span><br><span class="line"><span class="language-javascript">                userList.<span class="title function_">appendChild</span>(li);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            userCount.<span class="property">textContent</span> = users.<span class="property">length</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">resetUI</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            usernameInput.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            connectBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            disconnectBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">            websocket = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">            userList.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            userCount.<span class="property">textContent</span> = <span class="string">&#x27;0&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-6-运行和测试"><a href="#4-6-运行和测试" class="headerlink" title="4.6 运行和测试"></a>4.6 运行和测试</h3><ol>
<li>启动你的 Spring Boot 应用程序。</li>
<li>在浏览器中打开 <code>http://localhost:8080/index.html</code>。</li>
<li><strong>打开多个浏览器标签页或窗口</strong>，都访问该地址。</li>
<li>在第一个标签页，输入用户名 “Alice”，点击“连接”。你会看到日志显示连接成功，在线用户列表显示 “Alice”。</li>
<li>在第二个标签页，输入用户名 “Bob”，点击“连接”。<ul>
<li>“Bob” 的窗口会显示连接成功，在线用户列表为 [“Alice”, “Bob”]。</li>
<li>“Alice” 的窗口会收到一条广播消息，日志显示 “用户 Bob 加入了聊天室”，同时其在线用户列表也会更新为 [“Alice”, “Bob”]。</li>
</ul>
</li>
<li>尝试在第三个标签页使用已在线的用户名（如 “Alice”）连接，连接会失败（检查浏览器开发者工具的 Console 和 Network 面板，会看到 WebSocket 握手失败，HTTP 状态码为 409 Conflict）。</li>
<li>关闭 “Alice” 的浏览器标签页或点击“断开”。<ul>
<li>“Bob” 的窗口会收到一条广播消息，日志显示 “用户 Alice 离开了聊天室”，其在线用户列表更新为只有 “Bob”。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="五、Spring-Boot-STOMP"><a href="#五、Spring-Boot-STOMP" class="headerlink" title="五、Spring Boot + STOMP"></a>五、Spring Boot + STOMP</h1><h2 id="1-为什么需要-STOMP？"><a href="#1-为什么需要-STOMP？" class="headerlink" title="1. 为什么需要 STOMP？"></a>1. 为什么需要 STOMP？</h2><p>原生 WebSocket (JSR-356) 协议本身非常强大，它提供了一个全双工、低延迟的持久化连接通道。然而，它也仅仅是一个<strong>传输层协议</strong>，就像 TCP 一样。它只规定了如何建立连接和如何传输“一帧一帧”的数据（文本或二进制），但<strong>并未规定这些数据内容的具体格式和含义</strong>。</p>
<p>这就好比我们建好了一条双向高速公路（WebSocket 连接），但是路上没有任何交通规则、路牌或导航系统。每辆车（消息）都需要自己决定开往哪里，并且到达目的地后，接收方还需要自己解析这辆车里装的是什么。</p>
<p>在实际应用开发中，只使用原生 WebSocket 会遇到以下几个核心痛点：</p>
<h3 id="1-1-缺乏结构化的消息语义"><a href="#1-1-缺乏结构化的消息语义" class="headerlink" title="1.1 缺乏结构化的消息语义"></a>1.1 缺乏结构化的消息语义</h3><ul>
<li><p><strong>原生 WebSocket 的困境</strong>：服务器收到一个字符串消息，比如 <code>&quot;{&quot;user&quot;:&quot;Alice&quot;, &quot;message&quot;:&quot;Hello Bob&quot;}&quot;</code>。这个消息是什么意图？是发送给特定用户的私聊消息？还是广播到聊天室的公共消息？服务器必须解析 JSON 内容，然后根据自定义的字段（如 <code>type</code>, <code>action</code>, <code>toUser</code> 等）来编写大量的 <code>if-else</code> 或 <code>switch-case</code> 逻辑来分发消息。</p>
</li>
<li><p><strong>STOMP 的解决方案</strong>：STOMP (Simple Text Oriented Messaging Protocol) 是一种<strong>应用层协议</strong>，它定义了一套标准化的消息格式和命令。客户端不再是简单地 <code>send(&quot;some string&quot;)</code>，而是发送一个带有明确“意图”的<strong>命令帧 (Command Frame)</strong>。</p>
<p>例如，客户端想订阅一个主题：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE</span><br><span class="line">id:sub-1</span><br><span class="line">destination:/topic/chatRoom-A</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>客户端想发送一条消息到某个目的地：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SEND</span><br><span class="line">destination:/app/chat</span><br><span class="line">content-type:application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;from&quot;:&quot;Alice&quot;, &quot;text&quot;:&quot;Hello!&quot;&#125;</span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>服务器（或 Broker）看到 <code>SEND</code> 和 <code>destination</code> 就立刻明白了消息的目的地和意图，无需再解析消息体来做路由判断。</p>
</li>
</ul>
<hr>
<h3 id="1-2-没有内置的发布-订阅（Pub-Sub）和路由机制"><a href="#1-2-没有内置的发布-订阅（Pub-Sub）和路由机制" class="headerlink" title="1.2 没有内置的发布&#x2F;订阅（Pub&#x2F;Sub）和路由机制"></a>1.2 没有内置的发布&#x2F;订阅（Pub&#x2F;Sub）和路由机制</h3><ul>
<li><p><strong>原生 WebSocket 的困境</strong>：如果要实现一个聊天室，你需要手动维护一个映射关系，比如 <code>Map&lt;String, Set&lt;Session&gt;&gt;</code>，其中 Key 是聊天室 ID，Value 是该聊天室中所有用户的 WebSocket <code>Session</code> 集合。当收到一条发往该聊天室的消息时，你需要：</p>
<ol>
<li>从 Map 中找到对应的 <code>Set&lt;Session&gt;</code>。</li>
<li>遍历这个 Set。</li>
<li>对每一个 <code>Session</code> 调用 <code>session.getBasicRemote().sendText(...)</code>。<br>这个过程完全是手动编码，容易出错且难以扩展。</li>
</ol>
</li>
<li><p><strong>STOMP 的解决方案</strong>：STOMP 的核心就是<strong>基于“目的地”（Destination）的路由</strong>。它天然支持两种主流的消息模型：</p>
<ul>
<li><strong>发布&#x2F;订阅（Topics）</strong>：通常以 <code>/topic/</code> 开头。一个消息被发送到 <code>/topic/news</code>，所有订阅了该主题的客户端都会收到这个消息。非常适合广播场景，如股票行情、在线状态更新、公共聊天室。</li>
<li><strong>点对点（Queues）</strong>：通常以 <code>/queue/</code> 或 <code>/user/</code> 开头。一个消息被发送到队列，只有一个消费者（订阅者）会收到并处理它。非常适合任务处理、私聊消息等。</li>
</ul>
<p>开发者只需要让客户端 <code>SUBSCRIBE</code> 到某个 destination，然后向这个 destination <code>SEND</code> 消息即可。Spring 的 STOMP 支持会自动将消息路由给所有正确的订阅者，完全解耦了消息的生产者和消费者。</p>
</li>
</ul>
<hr>
<h3 id="1-3-缺乏高级消息特性"><a href="#1-3-缺乏高级消息特性" class="headerlink" title="1.3 缺乏高级消息特性"></a>1.3 缺乏高级消息特性</h3><ul>
<li><strong>原生 WebSocket 的困境</strong>：像消息确认（ACK）、事务、回执等企业级消息队列（MQ）中的常见功能，原生 WebSocket 均不提供。如果需要确保消息被客户端成功处理，你必须自己设计一套复杂的回执和重发机制。</li>
<li><strong>STOMP 的解决方案</strong>：STOMP 协议的设计深受传统 MQ 的影响，它支持更丰富的交互模式。例如，客户端可以在 <code>SUBSCRIBE</code> 时指定 <code>ack</code> 模式（<code>auto</code>, <code>client</code>, <code>client-individual</code>），从而实现消息的可靠消费。服务器发送消息后，需要等待客户端发回 <code>ACK</code> 或 <code>NACK</code> 帧，才能决定是否将消息从队列中移除。</li>
</ul>
<hr>
<h3 id="1-4-总结与类比"><a href="#1-4-总结与类比" class="headerlink" title="1.4 总结与类比"></a>1.4 总结与类比</h3><p>一个绝佳的类比是 <strong>HTTP 与 TCP</strong> 的关系：</p>
<ul>
<li><strong>WebSocket 就像 TCP</strong>：它提供了可靠的、双向的字节流传输通道。它很底层，很纯粹，给了你最大的灵活性，但也意味着你需要自己构建上层的一切。</li>
<li><strong>STOMP over WebSocket 就像 HTTP over TCP</strong>：它在底层的通道之上，定义了一套标准的、语义化的通信规则（命令、头信息、目的地）。它让你不再关心底层的字节流，而是专注于“发送一个请求”或“订阅一个资源”这样的业务逻辑。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">原生 WebSocket</th>
<th align="left">STOMP over WebSocket</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>抽象层级</strong></td>
<td align="left">传输层协议 (Transport-level)</td>
<td align="left">应用层协议 (Application-level)</td>
</tr>
<tr>
<td align="left"><strong>消息格式</strong></td>
<td align="left">无规定，通常是自定义 JSON&#x2F;XML</td>
<td align="left">标准化帧 (Frame)，包含命令、头部、内容</td>
</tr>
<tr>
<td align="left"><strong>路由</strong></td>
<td align="left">手动实现，管理 Session 集合</td>
<td align="left">基于 “Destination” 的自动路由</td>
</tr>
<tr>
<td align="left"><strong>消息模型</strong></td>
<td align="left">无内置模型，需手动实现</td>
<td align="left">内置 Pub&#x2F;Sub (<code>/topic</code>) 和 P2P (<code>/queue</code>)</td>
</tr>
<tr>
<td align="left"><strong>高级特性</strong></td>
<td align="left">无 (如 ACK, 事务)</td>
<td align="left">支持 (ACK, NACK, 事务等)</td>
</tr>
<tr>
<td align="left"><strong>开发复杂度</strong></td>
<td align="left">较高，需要处理大量底层细节</td>
<td align="left">较低，专注于业务逻辑和消息目的地</td>
</tr>
</tbody></table>
<p><strong>结论：</strong></p>
<p>虽然对于极简的场景，原生 WebSocket 已经足够，但只要你的应用涉及到任何形式的广播、路由、分类消息或需要与消息队列类似的行为时，<strong>使用 STOMP 就能极大地简化你的服务器和客户端代码，提供更健壮、更具扩展性的消息处理架构。</strong> Spring 对 STOMP 的完美支持更是让这一切变得唾手可得。</p>
<hr>
<h2 id="2-Spring-STOMP-核心配置"><a href="#2-Spring-STOMP-核心配置" class="headerlink" title="2. Spring STOMP 核心配置"></a>2. Spring STOMP 核心配置</h2><p>当你在 Spring Boot 项目中引入 <code>spring-boot-starter-websocket</code> 依赖后，Spring 的自动配置机制就已经为 WebSocket 和 STOMP 准备好了基础环境。我们接下来的配置，就是通过实现 <code>WebSocketMessageBrokerConfigurer</code> 接口，来定制和覆盖这些默认行为，使其符合我们的业务需求。</p>
<p>这整个配置可以看作是在绘制一张<strong>消息流转的蓝图</strong>。</p>
<h3 id="2-1-EnableWebSocketMessageBroker"><a href="#2-1-EnableWebSocketMessageBroker" class="headerlink" title="2.1 @EnableWebSocketMessageBroker"></a>2.1 <code>@EnableWebSocketMessageBroker</code></h3><p>这是一个核心注解，通常放在一个 <code>@Configuration</code> 类上。它不仅仅是一个开关，它的作用是<strong>启用 Spring 的 WebSocket 消息代理功能</strong>。</p>
<p>当 Spring 容器扫描到这个注解时，它会：</p>
<ol>
<li><strong>创建和注册处理 WebSocket 消息的核心组件 (Bean)</strong>。其中最重要的两个是：<ul>
<li>一个负责接收和解析客户端消息，并将其路由到 <code>@MessageMapping</code> 或 <code>@SubscribeMapping</code> 注解的方法。</li>
<li>另一个是内置的消息代理（Message Broker），用于处理订阅和广播。</li>
</ul>
</li>
<li><strong>使得 <code>WebSocketMessageBrokerConfigurer</code> 的配置生效</strong>。没有这个注解，你实现的配置类将不会被 Spring 用来配置 STOMP。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 开启STOMP协议的WebSocket消息代理支持</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// ... 配置方法将在这里实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-WebSocketMessageBrokerConfigurer-接口详解"><a href="#2-2-WebSocketMessageBrokerConfigurer-接口详解" class="headerlink" title="2.2 WebSocketMessageBrokerConfigurer 接口详解"></a>2.2 <code>WebSocketMessageBrokerConfigurer</code> 接口详解</h3><p>这个接口提供了多个 <code>default</code> 方法，我们只需要重写需要定制的部分即可。最核心的是以下两个方法：</p>
<h4 id="2-2-1-registerStompEndpoints-StompEndpointRegistry-registry"><a href="#2-2-1-registerStompEndpoints-StompEndpointRegistry-registry" class="headerlink" title="2.2.1 registerStompEndpoints(StompEndpointRegistry registry)"></a>2.2.1 <code>registerStompEndpoints(StompEndpointRegistry registry)</code></h4><ul>
<li><strong>作用</strong>：注册 STOMP “端点” (Endpoint)。</li>
<li><strong>什么是端点？</strong> 这是 WebSocket 或 SockJS 客户端为了进行 WebSocket 握手而需要连接的 <strong>HTTP URL</strong>。可以把它理解为 WebSocket 服务的**“入口”<strong>或</strong>“接入点”**。</li>
<li><strong>核心代码与解释</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 注册一个名为 &quot;/ws-stomp&quot; 的 STOMP 端点。</span></span><br><span class="line">    <span class="comment">//    客户端将连接到 &quot;ws://localhost:8080/ws-stomp&quot;</span></span><br><span class="line">    <span class="type">StompEndpointRegistration</span> <span class="variable">endpoint</span> <span class="operator">=</span> registry.addEndpoint(<span class="string">&quot;/ws-stomp&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. setAllowedOrigins(&quot;*&quot;)：解决跨域问题。允许所有域的客户端连接。</span></span><br><span class="line">    <span class="comment">//    在生产环境中，应该指定具体的域名，如 &quot;https://example.com&quot;。</span></span><br><span class="line">    endpoint.setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. withSockJS()：启用 SockJS 后备选项。</span></span><br><span class="line">    <span class="comment">//    如果浏览器不支持 WebSocket，SockJS 会自动降级为其他通信方式（如 HTTP Polling）。</span></span><br><span class="line">    <span class="comment">//    这极大地提高了应用的兼容性。客户端也需要使用 SockJS 库。</span></span><br><span class="line">    endpoint.withSockJS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>小结</strong>：这个方法定义了<strong>客户端如何连接到我们的服务</strong>。你可以注册多个端点，用于不同场景或不同类型的客户端。</li>
</ul>
<hr>
<h4 id="2-2-2-configureMessageBroker-MessageBrokerRegistry-registry"><a href="#2-2-2-configureMessageBroker-MessageBrokerRegistry-registry" class="headerlink" title="2.2.2 configureMessageBroker(MessageBrokerRegistry registry)"></a>2.2.2 <code>configureMessageBroker(MessageBrokerRegistry registry)</code></h4><ul>
<li><strong>作用</strong>：配置消息代理（Message Broker），它是 STOMP 消息处理的<strong>核心</strong>，负责<strong>路由、存储和广播消息</strong>。</li>
<li><strong>核心概念：消息流转路径</strong><ul>
<li><strong>发往应用 (Application)</strong>：客户端发送的消息，需要经过服务器端的 <code>@MessageMapping</code> 方法处理。这些消息的目的地通常有一个特定的前缀，如 <code>/app</code>。</li>
<li><strong>发往代理 (Broker)</strong>：消息直接由代理进行广播，无需应用层代码处理。这些消息的目的地前缀通常是 <code>/topic</code> (发布&#x2F;订阅) 或 <code>/queue</code> (点对点)。</li>
</ul>
</li>
<li><strong>核心代码与解释</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 配置应用程序目标前缀 (Application Destination Prefix)</span></span><br><span class="line">    <span class="comment">//    所有目的地以 &quot;/app&quot; 开头的 STOMP 消息都将被路由到 @MessageMapping 注解的方法中。</span></span><br><span class="line">    <span class="comment">//    例如，客户端发送目的地为 &quot;/app/chat&quot; 的消息，将由一个 @MessageMapping(&quot;/chat&quot;) 的方法处理。</span></span><br><span class="line">    registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 配置消息代理 (Message Broker)</span></span><br><span class="line">    <span class="comment">//    这里我们启用一个简单的、基于内存的消息代理。</span></span><br><span class="line">    <span class="comment">//    它将处理目的地以 &quot;/topic&quot; 或 &quot;/queue&quot; 开头的消息。</span></span><br><span class="line">    <span class="comment">//    - &quot;/topic&quot; 通常用于发布/订阅模式（一对多广播）。</span></span><br><span class="line">    <span class="comment">//    - &quot;/queue&quot; 通常用于点对点模式（一对一消息）。</span></span><br><span class="line">    registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. (可选) 配置用户目的地前缀 (User Destination Prefix)</span></span><br><span class="line">    <span class="comment">//    当使用 @SendToUser 或 SimpMessagingTemplate.convertAndSendToUser() 时，</span></span><br><span class="line">    <span class="comment">//    Spring 会自动将消息的目的地重写为类似 &quot;/user/&#123;sessionId&#125;/...&quot; 的形式，</span></span><br><span class="line">    <span class="comment">//    确保消息只发送给特定的用户。默认就是 &quot;/user&quot;，一般无需修改。</span></span><br><span class="line">    <span class="comment">//    registry.setUserDestinationPrefix(&quot;/user&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>代理的两种模式：</strong></p>
<ul>
<li><p><strong>简单代理 (Simple Broker)</strong>：<code>enableSimpleBroker()</code></p>
<ul>
<li><strong>特点</strong>：内置，基于内存，无需任何外部依赖。</li>
<li><strong>优点</strong>：配置简单，启动快，非常适合开发、测试和单体小型应用。</li>
<li><strong>缺点</strong>：<ul>
<li>功能有限，不支持复杂的路由和持久化。</li>
<li><strong>无法横向扩展</strong>。如果是多实例部署，一个实例内存中的消息无法被另一个实例的客户端接收到。</li>
<li>服务重启后，所有订阅关系和未发送的消息都会丢失。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>外部代理 (External Broker)</strong>：<code>enableStompBrokerRelay()</code></p>
<ul>
<li><strong>特点</strong>：将消息代理的任务委托给一个专业的外部消息中间件（MQ），如 RabbitMQ, ActiveMQ。Spring 只是作为一个<strong>中继 (Relay)</strong>。</li>
<li><strong>优点</strong>：<ul>
<li><strong>天然支持集群和横向扩展</strong>。</li>
<li><strong>高可用和高可靠</strong>：MQ 通常支持消息持久化、ACK 确认机制等。</li>
<li><strong>功能强大</strong>：支持更复杂的路由拓扑、延迟队列等。</li>
<li><strong>异构系统集成</strong>：其他非 WebSocket 的服务也可以通过 MQ 与你的应用进行消息交互。</li>
</ul>
</li>
<li><strong>配置示例 (RabbitMQ)</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.enableStompBrokerRelay(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>)</span><br><span class="line">        .setRelayHost(<span class="string">&quot;localhost&quot;</span>)</span><br><span class="line">        .setRelayPort(<span class="number">61613</span>) <span class="comment">// STOMP 插件默认端口</span></span><br><span class="line">        .setClientLogin(<span class="string">&quot;guest&quot;</span>)</span><br><span class="line">        .setClientPasscode(<span class="string">&quot;guest&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-总结：一张完整的配置蓝图"><a href="#2-3-总结：一张完整的配置蓝图" class="headerlink" title="2.3 总结：一张完整的配置蓝图"></a>2.3 总结：一张完整的配置蓝图</h3><p>将以上部分组合起来，我们就得到了一个完整的 <code>WebSocketConfig</code> 类，它清晰地定义了整个 STOMP 消息系统的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 STOMP 协议的端点。</span></span><br><span class="line"><span class="comment">     * 客户端将通过这个端点进行 WebSocket 握手。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义客户端连接的入口地址 &quot;/ws-stomp&quot;，并开启 SockJS 支持以便在浏览器不支持 WebSocket 时回退</span></span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/ws-stomp&quot;</span>).setAllowedOrigins(<span class="string">&quot;*&quot;</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置消息代理。</span></span><br><span class="line"><span class="comment">     * 定义了消息的路由规则。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义了服务器处理消息的前缀，发往这些前缀的消息将由 @MessageMapping 方法处理</span></span><br><span class="line">        registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义了消息代理的前缀，发往这些前缀的消息将由消息代理直接路由到订阅者</span></span><br><span class="line">        <span class="comment">// 使用内置的简单代理，处理 &quot;/topic&quot; 和 &quot;/queue&quot;</span></span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这份配置，我们告诉 Spring：</p>
<ol>
<li><strong>入口</strong>：请在 <code>/ws-stomp</code> 这个 URL 上监听 WebSocket 连接请求，并做好兼容性处理 (SockJS)。</li>
<li><strong>分流</strong>：当收到客户端的 STOMP 消息时：<ul>
<li>如果目的地是 <code>/app/xxx</code>，请把它交给我的 Controller (<code>@MessageMapping</code>) 去处理。</li>
<li>如果目的地是 <code>/topic/yyy</code> 或 <code>/queue/zzz</code>，请直接把它广播给所有订阅了这些主题的客户端。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-消息收发与路由"><a href="#3-消息收发与路由" class="headerlink" title="3. 消息收发与路由"></a>3. 消息收发与路由</h2><p>在 <code>WebSocketConfig</code> 中配置好“蓝图”后，我们现在需要构建实际的“交通枢纽”和“目的地”。这主要通过在 Controller 中使用一系列注解来完成，其模式与 Spring MVC 的 <code>@RestController</code> 和 <code>@RequestMapping</code> 非常相似。</p>
<p>首先，创建一个用于处理 WebSocket 消息的 Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 @Controller 注解，而非 @RestController。</span></span><br><span class="line"><span class="comment">// 因为我们不是返回 JSON body，而是处理 STOMP 消息。</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketController</span> &#123;</span><br><span class="line">    <span class="comment">// ... 消息处理方法将在这里实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-1-消息接收：-MessageMapping"><a href="#3-1-消息接收：-MessageMapping" class="headerlink" title="3.1 消息接收：@MessageMapping"></a>3.1 消息接收：<code>@MessageMapping</code></h3><ul>
<li><p><strong>作用</strong>: 这是 STOMP 消息的<strong>主要入口</strong>。它将一个方法映射到一个消息目的地，类似于 <code>@RequestMapping</code> 映射一个 HTTP URL。</p>
</li>
<li><p><strong>工作原理</strong>:</p>
<ol>
<li>客户端使用 STOMP <code>SEND</code> 命令，将消息发送到一个以 <code>/app</code> (我们在配置中定义的应用前缀) 开头的目的地，例如 <code>/app/chat</code>。</li>
<li>Spring 的 STOMP 处理器接收到此消息，剥离 <code>/app</code> 前缀，得到 <code>/chat</code>。</li>
<li>它会在所有 <code>@Controller</code> 中寻找一个被 <code>@MessageMapping(&quot;/chat&quot;)</code> 注解的方法，并将消息的 payload 传递给该方法。</li>
<li>Spring 会自动将 JSON 格式的 payload 反序列化为方法的参数对象（POJO）。</li>
</ol>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有 ChatMessage 类: &#123; &quot;from&quot;: &quot;userA&quot;, &quot;text&quot;: &quot;hello&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理发往 &quot;/app/chat&quot; 的消息。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 客户端发送的 JSON 数据会自动转为 ChatMessage 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 方法的返回值将作为新消息的 payload</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MessageMapping(&quot;/chat&quot;)</span> <span class="comment">// 映射目的地 /app/chat</span></span><br><span class="line"><span class="meta">@SendTo(&quot;/topic/public&quot;)</span> <span class="comment">// 将返回值广播到 /topic/public</span></span><br><span class="line"><span class="keyword">public</span> ChatMessage <span class="title function_">handleChatMessage</span><span class="params">(ChatMessage message)</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里可以进行消息处理，如过滤敏感词、存入数据库等</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Received message: &quot;</span> + message.getText());</span><br><span class="line">    <span class="comment">// 方法返回的对象将被序列化为 JSON 并发送出去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChatMessage</span>(<span class="string">&quot;Server&quot;</span>, <span class="string">&quot;Processed: &quot;</span> + message.getText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端交互</strong>: 客户端需要执行 <code>stompClient.send(&quot;/app/chat&quot;, {}, JSON.stringify({from: &#39;Alice&#39;, text: &#39;Hello World!&#39;}));</code></p>
</li>
</ul>
<hr>
<h3 id="3-2-消息发送-广播"><a href="#3-2-消息发送-广播" class="headerlink" title="3.2 消息发送&#x2F;广播"></a>3.2 消息发送&#x2F;广播</h3><h4 id="3-2-1-SendTo：广播到指定目的地"><a href="#3-2-1-SendTo：广播到指定目的地" class="headerlink" title="3.2.1 @SendTo：广播到指定目的地"></a>3.2.1 <code>@SendTo</code>：广播到指定目的地</h4><ul>
<li><p><strong>作用</strong>: 通常与 <code>@MessageMapping</code> 结合使用，用于声明方法返回值的<strong>目标地址</strong>。</p>
</li>
<li><p><strong>工作原理</strong>: 方法执行完毕后，返回值会被发送到 <code>@SendTo</code> 指定的 broker 目的地（如 <code>/topic/public</code>）。然后，消息代理 (Simple Broker) 会将此消息广播给所有订阅了 <code>/topic/public</code> 的客户端。</p>
</li>
<li><p><strong>动态目的地</strong>: <code>@SendTo</code> 的值可以包含占位符，这些占位符会从 <code>@MessageMapping</code> 的路径变量中解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端发送到 /app/chat/room123</span></span><br><span class="line"><span class="meta">@MessageMapping(&quot;/chat/&#123;roomId&#125;&quot;)</span></span><br><span class="line"><span class="comment">// 返回值会被广播到 /topic/messages/room123</span></span><br><span class="line"><span class="meta">@SendTo(&quot;/topic/messages/&#123;roomId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ChatMessage <span class="title function_">handleRoomChat</span><span class="params">(<span class="meta">@DestinationVariable</span> String roomId, ChatMessage message)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-2-SendToUser：向当前用户发送私信"><a href="#3-2-2-SendToUser：向当前用户发送私信" class="headerlink" title="3.2.2 @SendToUser：向当前用户发送私信"></a>3.2.2 <code>@SendToUser</code>：向当前用户发送私信</h4><ul>
<li><p><strong>作用</strong>: 将消息只发送给<strong>发起请求的那个用户</strong>。非常适合实现“请求-响应”模式或发送私有错误&#x2F;确认信息。</p>
</li>
<li><p><strong>工作原理</strong>:</p>
<ol>
<li>Spring 会将 <code>@SendToUser</code> 的目的地（如 <code>/queue/errors</code>）转换为一个对该用户唯一的目的地，通常是 <code>/user/{username}/queue/errors</code>。</li>
<li>要使其工作，客户端必须订阅这个<strong>用户特定的</strong>目的地。通常客户端库（如 <code>stomp.js</code>）会简化这个过程，你只需要订阅 <code>/user/queue/errors</code>，库会自动处理底层的会话 ID 映射。</li>
<li>需要结合 Spring Security 或其他认证机制来识别用户 (<code>Principal</code>)。</li>
</ol>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理一个需要私密回复的请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> principal Spring Security 注入的当前用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MessageMapping(&quot;/private-request&quot;)</span></span><br><span class="line"><span class="meta">@SendToUser(&quot;/queue/replies&quot;)</span> <span class="comment">// 将返回值发送到 /user/&#123;username&#125;/queue/replies</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handlePrivateRequest</span><span class="params">(Principal principal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (principal != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is a private reply for &quot;</span> + principal.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Error: User not authenticated.&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端交互</strong>: 客户端需要 <code>stompClient.subscribe(&#39;/user/queue/replies&#39;, callback);</code> 才能收到消息。</p>
</li>
</ul>
<hr>
<h4 id="3-2-3-SimpMessagingTemplate：主动发送消息的“神器”"><a href="#3-2-3-SimpMessagingTemplate：主动发送消息的“神器”" class="headerlink" title="3.2.3 SimpMessagingTemplate：主动发送消息的“神器”"></a>3.2.3 <code>SimpMessagingTemplate</code>：主动发送消息的“神器”</h4><ul>
<li><p><strong>作用</strong>: 让你可以在<strong>任何地方</strong>（<code>@Service</code>, <code>@RestController</code>, 定时任务等），而不仅仅是在 <code>@MessageMapping</code> 方法中，主动向客户端发送消息。</p>
</li>
<li><p><strong>工作原理</strong>: 这是一个可以被 <code>@Autowired</code> 注入的 Bean。你只需调用它的方法，并指定目的地和 payload。</p>
</li>
<li><p><strong>核心方法</strong>:</p>
<ul>
<li><code>convertAndSend(destination, payload)</code>: 发送到一个公共目的地 (如 <code>/topic/notifications</code>)。</li>
<li><code>convertAndSendToUser(user, destination, payload)</code>: 发送给一个特定用户。<code>user</code> 参数是用户名（<code>Principal.getName()</code>）。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationService</span><span class="params">(SimpMessagingTemplate messagingTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messagingTemplate = messagingTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景1：由一个 HTTP 请求触发 WebSocket 广播</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllUsers</span><span class="params">(String notification)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Broadcasting notification: &quot;</span> + notification);</span><br><span class="line">        <span class="comment">// 向 /topic/notifications 广播消息</span></span><br><span class="line">        messagingTemplate.convertAndSend(<span class="string">&quot;/topic/notifications&quot;</span>, notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景2：发送私信给特定用户</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendPrivateNotification</span><span class="params">(String userId, String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending private message to &quot;</span> + userId);</span><br><span class="line">        <span class="comment">// 向 /user/&#123;userId&#125;/queue/private 发送消息</span></span><br><span class="line">        messagingTemplate.convertAndSendToUser(userId, <span class="string">&quot;/queue/private&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景3：定时任务，每5秒广播一次服务器时间</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">broadcastServerTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;Server time is: &quot;</span> + <span class="keyword">new</span> <span class="title class_">java</span>.util.Date();</span><br><span class="line">        messagingTemplate.convertAndSend(<span class="string">&quot;/topic/time&quot;</span>, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-4-消息订阅：-SubscribeMapping-特殊用途"><a href="#3-2-4-消息订阅：-SubscribeMapping-特殊用途" class="headerlink" title="3.2.4 消息订阅：@SubscribeMapping (特殊用途)"></a>3.2.4 消息订阅：<code>@SubscribeMapping</code> (特殊用途)</h4><ul>
<li><p><strong>作用</strong>: 这个注解很容易被误解。它<strong>不是</strong>用来处理所有订阅的通用钩子。它的特定用途是：当一个客户端<strong>首次订阅</strong>某个目的地时，触发该方法，并<strong>立即</strong>将返回值作为一条消息<strong>只</strong>发送给这个订阅者。</p>
</li>
<li><p><strong>工作原理</strong>:</p>
<ol>
<li>客户端 <code>SUBSCRIBE</code> 一个以 <code>/app</code> 开头的目的地，例如 <code>/app/initial-users</code>。</li>
<li>Spring 找到 <code>@SubscribeMapping(&quot;/initial-users&quot;)</code> 方法，并执行它。</li>
<li>方法的返回值会直接发送给刚刚订阅的客户端，其行为类似于 <code>@SendToUser</code>。</li>
</ol>
</li>
<li><p><strong>典型场景</strong>: 当用户加入聊天室时，立即给他发送当前的在线用户列表。</p>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当客户端订阅 &quot;/app/online-users&quot; 时，立即向其返回在线用户列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回值将只发送给发起订阅的客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SubscribeMapping(&quot;/online-users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getOnlineUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Client subscribed for online users, sending initial list.&quot;</span>);</span><br><span class="line">    <span class="comment">// 在实际应用中，这里应该从一个服务中获取真实的在线用户列表</span></span><br><span class="line">    <span class="keyword">return</span> List.of(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端交互</strong>: 客户端执行 <code>stompClient.subscribe(&#39;/app/online-users&#39;, callback);</code>，<code>callback</code> 会立即被调用一次，并收到 <code>[&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]</code>。</p>
</li>
</ul>
<hr>
<h2 id="4-安全与拦截"><a href="#4-安全与拦截" class="headerlink" title="4. 安全与拦截"></a>4. 安全与拦截</h2><p>默认情况下，任何人都可以连接到你的 WebSocket 端点并订阅任何主题，这在生产环境中是极其危险的。我们需要一套机制来确保只有经过身份验证的用户才能连接，并且他们只能收发自己有权限的消息。</p>
<h3 id="4-1-ChannelInterceptor：消息管道的“守卫”"><a href="#4-1-ChannelInterceptor：消息管道的“守卫”" class="headerlink" title="4.1 ChannelInterceptor：消息管道的“守卫”"></a>4.1 <code>ChannelInterceptor</code>：消息管道的“守卫”</h3><p><code>ChannelInterceptor</code> 是 Spring Messaging 提供的一个强大拦截器接口，它允许你在消息被发送或接收的各个阶段插入自定义逻辑。它就像是消息流经的管道上的一个个阀门和检查点。</p>
<ul>
<li><strong>核心作用</strong>：<ul>
<li><strong>认证 (Authentication)</strong>：在连接建立后，从消息头中提取令牌（如 JWT），验证用户身份，并将其与 WebSocket <code>Session</code> 关联起来。</li>
<li><strong>授权 (Authorization)</strong>：在处理 <code>SUBSCRIBE</code> 或 <code>SEND</code> 命令时，检查用户是否有权订阅该目的地或向该目的地发送消息。</li>
<li><strong>日志记录</strong>：记录所有进出的消息，用于调试和审计。</li>
<li><strong>消息修改</strong>：在消息发送前修改其内容或头部信息。</li>
</ul>
</li>
<li><strong>关键方法</strong>：<ul>
<li><code>preSend(Message&lt;?&gt; message, MessageChannel channel)</code>: 在消息发送到 Channel <strong>之前</strong>被调用。这是最常用的方法，用于认证和授权。如果返回 <code>null</code>，则消息处理流程会中止。</li>
<li><code>postSend(Message&lt;?&gt; message, MessageChannel channel, boolean sent)</code>: 在消息发送<strong>之后</strong>被调用，无论成功与否。</li>
<li><code>afterSendCompletion(...)</code>: 在消息发送<strong>完成</strong>后（包括所有事务提交）被调用。</li>
</ul>
</li>
<li><strong>配置方式</strong>：<br><code>ChannelInterceptor</code> 需要注册到 <code>clientInboundChannel</code> (处理客户端发来消息的通道) 或 <code>clientOutboundChannel</code> (处理发往客户端消息的通道) 上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 WebSocketConfig.java 中</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureClientInboundChannel</span><span class="params">(ChannelRegistration registration)</span> &#123;</span><br><span class="line">        registration.interceptors(<span class="keyword">new</span> <span class="title class_">MyChannelInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>示例：使用拦截器进行 JWT 认证</strong></p>
<p>这是一个典型的认证场景：客户端在 STOMP 连接的 <code>CONNECT</code> 帧的 header 中携带 JWT。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtChannelInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ChannelInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) &#123;</span><br><span class="line">        <span class="type">StompHeaderAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 判断是否为 CONNECT 命令，如果是，则进行认证</span></span><br><span class="line">        <span class="keyword">if</span> (StompCommand.CONNECT.equals(accessor.getCommand())) &#123;</span><br><span class="line">            <span class="comment">// 2. 从 header 中获取 token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> accessor.getFirstNativeHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (jwtToken != <span class="literal">null</span> &amp;&amp; jwtToken.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">                jwtToken = jwtToken.substring(<span class="number">7</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 3. 使用 JWT 工具类或 Spring Security 进行 token 验证</span></span><br><span class="line">                <span class="comment">//    如果验证成功，会返回一个 Authentication 对象</span></span><br><span class="line">                <span class="type">Authentication</span> <span class="variable">userAuth</span> <span class="operator">=</span> JwtUtil.getAuthentication(jwtToken);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (userAuth != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 4. 将认证信息设置到 STOMP 的 session 中</span></span><br><span class="line">                    <span class="comment">//    这样在后续的 @MessageMapping 方法中，就可以通过 Principal 参数获取到用户信息</span></span><br><span class="line">                    accessor.setUser(userAuth);</span><br><span class="line">                    <span class="keyword">return</span> message;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5. 如果认证失败，可以抛出异常，连接将被拒绝</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Authentication failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于非 CONNECT 命令，直接放行（后续可以结合 Spring Security 做更细粒度的授权）</span></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端配合 (stomp.js)</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwtToken = <span class="string">&#x27;your-jwt-token&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> headers = &#123;</span><br><span class="line">  <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">`Bearer <span class="subst">$&#123;jwtToken&#125;</span>`</span></span><br><span class="line">&#125;;</span><br><span class="line">stompClient.<span class="title function_">connect</span>(headers, onConnected, onError);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-2-结合-Spring-Security：实现声明式安全"><a href="#4-2-结合-Spring-Security：实现声明式安全" class="headerlink" title="4.2 结合 Spring Security：实现声明式安全"></a>4.2 结合 Spring Security：实现声明式安全</h3><p>虽然 <code>ChannelInterceptor</code> 功能强大，但对于复杂的授权规则（例如，只有 “ADMIN” 角色的用户才能订阅 <code>/topic/admin</code>），手动编写 <code>if-else</code> 逻辑会变得非常繁琐。Spring Security 提供了与 WebSocket 的深度集成，让我们能够以<strong>声明式</strong>的方式配置安全规则。</p>
<ul>
<li><p><strong>核心思想</strong>：将 WebSocket 的消息类型（CONNECT, SUBSCRIBE, MESSAGE, SEND）类比于 HTTP 的方法（GET, POST），将消息目的地（Destination）类比于 HTTP 的 URL。这样，我们就可以用与保护 Web 端点类似的方式来保护 WebSocket 消息。</p>
</li>
<li><p><strong>配置步骤</strong>：</p>
<ol>
<li><p><strong>添加依赖</strong>: 确保项目中包含 <code>spring-boot-starter-security</code> 和 <code>spring-security-messaging</code>。</p>
</li>
<li><p><strong>创建安全配置类</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.socket.AbstractSecurityWebSocketMessageBrokerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.messaging.MessageSecurityMetadataSourceRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractSecurityWebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置消息的安全规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureInbound</span><span class="params">(MessageSecurityMetadataSourceRegistry messages)</span> &#123;</span><br><span class="line">        messages</span><br><span class="line">            <span class="comment">// 1. 所有目的地以 /app/admin/ 开头的消息，需要 ADMIN 角色</span></span><br><span class="line">            .simpDestMatchers(<span class="string">&quot;/app/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">            <span class="comment">// 2. 所有目的地以 /user/ 开头的消息（通常是私信），要求用户已认证</span></span><br><span class="line">            .simpDestMatchers(<span class="string">&quot;/user/**&quot;</span>).authenticated()</span><br><span class="line">            <span class="comment">// 3. 订阅 /topic/private 主题，需要 &quot;SPECIAL_USER&quot; 权限</span></span><br><span class="line">            .simpSubscribeDestMatchers(<span class="string">&quot;/topic/private&quot;</span>).hasAuthority(<span class="string">&quot;SPECIAL_USER&quot;</span>)</span><br><span class="line">            <span class="comment">// 4. 对其他所有消息（如公共聊天室），允许所有访问</span></span><br><span class="line">            .anyMessage().permitAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 禁用 CSRF token 验证 for WebSocket</span></span><br><span class="line"><span class="comment">     * 在现代 JWT/Token-based 认证中，CSRF 保护通常是不必要的，</span></span><br><span class="line"><span class="comment">     * 因为客户端不会在 cookie 中自动发送凭证。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">sameOriginDisabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>关键点解释</strong>：</p>
<ul>
<li><code>AbstractSecurityWebSocketMessageBrokerConfigurer</code>: 这是配置 WebSocket 安全的专用基类。</li>
<li><code>configureInbound()</code>: 这是配置入口，用于定义对<strong>入站消息</strong>（来自客户端）的安全约束。</li>
<li><code>simpDestMatchers()</code>: 匹配消息的目的地（Destination）。适用于 <code>MESSAGE</code> 和 <code>SEND</code> 类型的消息。</li>
<li><code>simpSubscribeDestMatchers()</code>: 专门匹配 <code>SUBSCRIBE</code> 类型的消息。</li>
<li><code>simpTypeMatchers()</code>: 可以匹配消息的类型，如 <code>CONNECT</code>, <code>DISCONNECT</code>。例如，<code>.simpTypeMatchers(SimpMessageType.CONNECT).permitAll()</code> 允许所有连接。</li>
<li><code>.authenticated()</code>: 要求用户必须已登录。</li>
<li><code>.hasRole(&quot;ADMIN&quot;)</code> &#x2F; <code>.hasAuthority(&quot;WRITE&quot;)</code>: 要求用户拥有指定的角色或权限。</li>
<li><code>sameOriginDisabled()</code>: 返回 <code>true</code> 以禁用 Spring Security 的同源策略保护。对于非浏览器的 WebSocket 客户端或需要跨域的场景，这通常是必需的。</li>
</ul>
</li>
<li><p><strong>认证如何进行？</strong><br>Spring Security 的 WebSocket 集成<strong>重用了 Web 层的认证机制</strong>。这意味着：</p>
<ol>
<li>如果你的应用使用 Session + Cookie，当 WebSocket 握手时，HTTP 请求中携带的 Cookie 会被用来识别用户身份。</li>
<li>如果你的应用使用 JWT，你需要像前面 <code>ChannelInterceptor</code> 示例那样，在握手阶段或第一个 STOMP <code>CONNECT</code> 帧中验证 JWT，并将 <code>Authentication</code> 对象与会话关联。一旦关联成功，Spring Security 的授权规则就能自动生效。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h3><p>在实际项目中，<code>ChannelInterceptor</code> 和 Spring Security 通常结合使用：</p>
<ol>
<li><strong>使用 <code>ChannelInterceptor</code></strong>：<ul>
<li>在 STOMP <code>CONNECT</code> 阶段，从 header 中解析 Token (如 JWT)。</li>
<li>验证 Token 并构建 <code>Authentication</code> 对象。</li>
<li>通过 <code>StompHeaderAccessor.setUser()</code> 将 <code>Authentication</code> 对象关联到当前会话。</li>
</ul>
</li>
<li><strong>使用 <code>WebSocketSecurityConfig</code></strong>：<ul>
<li>利用 Spring Security 声明式的强大能力，轻松配置各种目的地的访问控制规则 (<code>hasRole</code>, <code>authenticated</code> 等)。</li>
<li>这些规则会自动作用于第一步中已认证的用户。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-客户端交互（简述）"><a href="#5-客户端交互（简述）" class="headerlink" title="5. 客户端交互（简述）"></a>5. 客户端交互（简述）</h2><p>后端搭建了强大的 STOMP 服务，但其价值最终需要通过客户端的交互来体现。对于 Web 前端，最流行和健壮的组合是使用 <code>SockJS</code> 作为底层传输，<code>stomp.js</code> (或其现代变体 <code>@stomp/stompjs</code>) 作为上层协议库。</p>
<ul>
<li><strong>SockJS</strong>: 一个浏览器 JavaScript 库，它提供了一个类似 WebSocket 的对象。其核心价值在于<strong>兼容性</strong>：如果浏览器不支持原生 WebSocket，它会自动降级 (fallback) 到其他可用的双向通信技术，如 HTTP Long Polling。这确保了你的应用在老旧浏览器或特殊网络环境下依然可以工作。</li>
<li><strong>stomp.js</strong>: 一个实现了 STOMP 协议的 JavaScript 客户端库。它负责将你的业务操作（如“订阅&#x2F;topic&#x2F;news”）封装成标准格式的 STOMP 帧，并通过底层的 WebSocket 或 SockJS 连接发送出去。</li>
</ul>
<p><strong>1. 引入库</strong></p>
<p>通常通过 CDN 或 npm&#x2F;yarn 包管理器引入。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过 CDN --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/@stomp/stompjs@7/bundles/stomp.umd.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 建立连接 (<code>CONNECT</code>)</strong></p>
<p>这是所有交互的起点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 StompJs 客户端实例</span></span><br><span class="line"><span class="keyword">const</span> stompClient = <span class="keyword">new</span> <span class="title class_">StompJs</span>.<span class="title class_">Client</span>(&#123;</span><br><span class="line">    <span class="comment">// 2. 底层传输配置：使用 SockJS</span></span><br><span class="line">    <span class="comment">//    这里的 URL &#x27;/ws-stomp&#x27; 必须与后端 `registerStompEndpoints` 中配置的端点一致</span></span><br><span class="line">    <span class="attr">webSocketFactory</span>: <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">SockJS</span>(<span class="string">&#x27;http://localhost:8080/ws-stomp&#x27;</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (可选) 连接成功时的回调函数</span></span><br><span class="line">    <span class="attr">onConnect</span>: <span class="function">(<span class="params">frame</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connected: &#x27;</span> + frame);</span><br><span class="line">        <span class="comment">// 连接成功后，通常在这里进行订阅</span></span><br><span class="line">        <span class="title function_">subscribeToTopics</span>(); </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (可选) 连接失败时的回调函数</span></span><br><span class="line">    <span class="attr">onStompError</span>: <span class="function">(<span class="params">frame</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Broker reported error: &#x27;</span> + frame.<span class="property">headers</span>[<span class="string">&#x27;message&#x27;</span>]);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Additional details: &#x27;</span> + frame.<span class="property">body</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (可选) 用于调试，打印所有 STOMP 帧</span></span><br><span class="line">    <span class="attr">debug</span>: <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), str);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (可选) 如果需要携带认证信息（如JWT），在 connectHeaders 中设置</span></span><br><span class="line">    <span class="attr">connectHeaders</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer your-jwt-token&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 激活连接</span></span><br><span class="line">stompClient.<span class="title function_">activate</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>:<ul>
<li><code>webSocketFactory</code>: 指定了底层的传输方式。这里我们使用 SockJS，它会首先尝试 WebSocket，失败则降级。</li>
<li><code>onConnect</code>: 连接成功的回调至关重要，后续的订阅和发送操作都应该在连接成功后进行。</li>
<li><code>connectHeaders</code>: 这是向后端传递认证令牌（如 JWT）的标准方式，对应后端 <code>ChannelInterceptor</code> 中的 <code>accessor.getFirstNativeHeader(&quot;Authorization&quot;)</code>。</li>
</ul>
</li>
</ul>
<p><strong>3. 订阅目的地 (<code>SUBSCRIBE</code>)</strong></p>
<p>订阅一个“频道”，以便接收来自该频道的广播消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">subscribeToTopics</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 订阅公共聊天室主题</span></span><br><span class="line">    stompClient.<span class="title function_">subscribe</span>(<span class="string">&#x27;/topic/public&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当收到消息时，此回调函数被触发</span></span><br><span class="line">        <span class="comment">// message.body 通常是一个 JSON 字符串</span></span><br><span class="line">        <span class="keyword">const</span> chatMessage = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message.<span class="property">body</span>);</span><br><span class="line">        <span class="title function_">showGreeting</span>(chatMessage.<span class="property">from</span> + <span class="string">&quot;: &quot;</span> + chatMessage.<span class="property">text</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅一个用户私有队列，用于接收私信或个人通知</span></span><br><span class="line">    <span class="comment">// stomp.js 会自动处理 /user 前缀</span></span><br><span class="line">    stompClient.<span class="title function_">subscribe</span>(<span class="string">&#x27;/user/queue/replies&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received private message: &#x27;</span>, message.<span class="property">body</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>:<ul>
<li><code>stompClient.subscribe(destination, callback)</code>: 第一个参数是 STOMP 目的地，与后端 <code>@SendTo</code> 或 <code>SimpMessagingTemplate</code> 的目标地址对应。第二个参数是收到消息后的处理函数。</li>
<li>订阅 <code>/user/...</code> 格式的目的地时，库会自动将其映射到与当前用户会话相关的唯一地址。</li>
</ul>
</li>
</ul>
<p><strong>4. 发送消息 (<code>SEND</code>)</strong></p>
<p>向一个目的地发送消息，通常由用户操作触发（如点击“发送”按钮）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">from</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;from&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;text&#x27;</span>).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">from</span> &amp;&amp; text) &#123;</span><br><span class="line">        <span class="comment">// 使用 publish 方法 (等同于 send)</span></span><br><span class="line">        stompClient.<span class="title function_">publish</span>(&#123;</span><br><span class="line">            <span class="comment">// 目的地，与后端 @MessageMapping(&quot;/chat&quot;) 对应</span></span><br><span class="line">            <span class="attr">destination</span>: <span class="string">&#x27;/app/chat&#x27;</span>,</span><br><span class="line">            <span class="comment">// 消息体，通常是 JSON 字符串</span></span><br><span class="line">            <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="string">&#x27;from&#x27;</span>: <span class="keyword">from</span>, <span class="string">&#x27;text&#x27;</span>: text&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>:<ul>
<li><code>stompClient.publish({destination, body, headers})</code>:<ul>
<li><code>destination</code>: 目标地址。如果需要后端 <code>@MessageMapping</code> 方法处理，通常以 <code>/app</code> 开头。</li>
<li><code>body</code>: 消息的 payload，需要手动序列化成字符串（如 JSON.stringify）。</li>
<li><code>headers</code>: (可选) 可以添加自定义的 STOMP 消息头。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>5. 断开连接 (<code>DISCONNECT</code>)</strong></p>
<p>在页面卸载或用户登出时，应主动断开连接以释放服务器资源。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">disconnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    stompClient.<span class="title function_">deactivate</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Disconnected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，在浏览器窗口关闭前断开连接</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">disconnect</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>:<ul>
<li><code>stompClient.deactivate()</code>: 会向服务器发送一个 <code>DISCONNECT</code> 帧，优雅地关闭连接。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、生产环境最佳实践与高级主题"><a href="#六、生产环境最佳实践与高级主题" class="headerlink" title="六、生产环境最佳实践与高级主题"></a>六、生产环境最佳实践与高级主题</h1><h2 id="1-连接的稳定性：心跳机制"><a href="#1-连接的稳定性：心跳机制" class="headerlink" title="1. 连接的稳定性：心跳机制"></a>1. 连接的稳定性：心跳机制</h2><p>心跳机制是维持 WebSocket 长连接稳定性的核心手段。它通过在客户端和服务器之间定期发送“心跳”消息，来解决两个核心问题：<strong>防止意外断开</strong> 和 <strong>检测僵尸连接</strong>。</p>
<h3 id="1-1-为什么需要心跳？"><a href="#1-1-为什么需要心跳？" class="headerlink" title="1.1 为什么需要心跳？"></a>1.1 为什么需要心跳？</h3><p>在一个理想的网络环境中，TCP 连接一旦建立，只要双方不主动关闭，就会一直保持。但在现实世界中，情况要复杂得多：</p>
<ul>
<li><strong>防止代理&#x2F;防火墙超时 (Preventing Proxy Timeouts):</strong><ul>
<li><strong>问题描述:</strong> 生产环境中，客户端和服务器之间通常会经过多个网络中间件，如负载均衡器（Nginx、F5）、防火墙、NAT 网关等。这些设备为了节省自身资源，通常会设置一个“空闲连接超时”（Idle Timeout）。如果一个 TCP 连接在指定时间（例如 60 秒）内没有任何数据传输，中间件会单方面认为该连接已失效并将其关闭，而此时客户端和服务器可能对此毫不知情。</li>
<li><strong>解决方案:</strong> 心跳机制通过定期发送一个极小的数据包（心跳包），模拟“通信正在进行”的状态，从而重置所有中间件的空闲计时器，确保连接不会因为“空闲”而被意外切断。这就像是告诉沿途的所有设备：“我还活着，别挂断我！”</li>
</ul>
</li>
<li><strong>检测僵尸连接 (Detecting Zombie Connections):</strong><ul>
<li><strong>问题描述:</strong> 当一方发生异常掉线时（如客户端应用崩溃、用户关闭浏览器页签、手机网络突然切换、服务器宕机重启），TCP 连接可能不会被优雅地关闭（即没有发送 <code>FIN</code> 包）。另一方会一直维持着这个“已死亡”的连接，持续占用服务器的内存、文件句柄等宝贵资源。这种无法通信但仍占用资源的连接被称为“僵尸连接”。大量的僵尸连接会耗尽服务器资源，导致无法接受新的连接。</li>
<li><strong>解决方案:</strong> 心跳机制提供了一种主动检测连接状态的手段。<ul>
<li><strong>单向检测:</strong> 服务器定期向客户端发送心跳请求（如 Ping）。如果在一定时间内没有收到客户端的响应（如 Pong），服务器就可以判定客户端已失联，从而主动关闭这个僵尸连接，释放资源。</li>
<li><strong>双向检测:</strong> 同样，客户端也可以向服务器发送心跳，以检测服务器是否在线，从而实现更及时的断线重连逻辑。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong> 心跳的核心作用有两个：</p>
<ol>
<li><strong>主动保活 (Keep-Alive):</strong> 告知网络中间件连接是活动的。</li>
<li><strong>被动检测 (Health-Check):</strong> 确认对方是否仍然在线。</li>
</ol>
<hr>
<h3 id="1-2-Spring-STOMP-的内置心跳配置"><a href="#1-2-Spring-STOMP-的内置心跳配置" class="headerlink" title="1.2 Spring STOMP 的内置心跳配置"></a>1.2 Spring STOMP 的内置心跳配置</h3><p>Spring 对 STOMP over WebSocket 提供了非常完善且易于配置的内置心跳支持。配置是<strong>双向</strong>的，即服务器和客户端需要进行协商。</p>
<ul>
<li><p><strong>服务端配置 (<code>WebSocketMessageBrokerConfigurer</code>):</strong></p>
<p>心跳在 <code>configureMessageBroker</code> 方法中通过 <code>TaskScheduler</code> 来启用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.simp.config.MessageBrokerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">taskScheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();</span><br><span class="line">        taskScheduler.setPoolSize(<span class="number">1</span>);</span><br><span class="line">        taskScheduler.setThreadNamePrefix(<span class="string">&quot;websocket-heartbeat-&quot;</span>);</span><br><span class="line">        taskScheduler.initialize();</span><br><span class="line"></span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>)</span><br><span class="line">                .setHeartbeatValue(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;</span><br><span class="line">                    <span class="number">10000</span>, <span class="comment">// server -&gt; client: 服务器每 10 秒向客户端发送一次心跳</span></span><br><span class="line">                    <span class="number">10000</span>  <span class="comment">// client -&gt; server: 服务器期望每 10 秒从客户端接收一次心跳</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .setTaskScheduler(taskScheduler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>setHeartbeatValue(new long[]{ outgoing, incoming })</code>:<ul>
<li><code>outgoing</code> (10000 ms): 服务器保证至少每 10 秒向客户端发送一次心跳。如果在此期间有其他消息发送，则心跳可以省略。<code>0</code> 表示服务器不主动发送心跳。</li>
<li><code>incoming</code> (10000 ms): 服务器期望至少每 10 秒从客户端那里收到一次心跳。如果超过这个时间（通常会有一个宽限期）没有收到任何消息（包括心跳），服务器将判定客户端断开并关闭连接。<code>0</code> 表示服务器不要求客户端发送心跳。</li>
</ul>
</li>
<li><code>setTaskScheduler</code>: 为心跳任务提供一个专用的线程池，避免与业务线程混用，是推荐的最佳实践。</li>
</ul>
</li>
<li><p><strong>客户端配置 (以 <code>stompjs</code> 为例):</strong></p>
<p>客户端在连接时也需要声明自己的心跳期望。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Client</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@stomp/stompjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">Client</span>(&#123;</span><br><span class="line">    <span class="attr">brokerURL</span>: <span class="string">&#x27;ws://localhost:8080/your-websocket-endpoint&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 心跳配置</span></span><br><span class="line">    <span class="attr">heartbeatIncoming</span>: <span class="number">10000</span>, <span class="comment">// 期望从服务器每 10 秒接收一次心跳</span></span><br><span class="line">    <span class="attr">heartbeatOutgoing</span>: <span class="number">10000</span>, <span class="comment">// 保证每 10 秒向服务器发送一次心跳</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">reconnectDelay</span>: <span class="number">5000</span>, <span class="comment">// 断线后 5 秒尝试重连</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.<span class="property">onConnect</span> = <span class="keyword">function</span>(<span class="params">frame</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connected: &#x27;</span> + frame);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.<span class="property">onStompError</span> = <span class="keyword">function</span>(<span class="params">frame</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Broker reported error: &#x27;</span> + frame.<span class="property">headers</span>[<span class="string">&#x27;message&#x27;</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Additional details: &#x27;</span> + frame.<span class="property">body</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.<span class="title function_">activate</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>心跳协商机制:</strong><br>最终的心跳间隔是<strong>客户端与服务器配置的较大值</strong>。例如：</p>
<ul>
<li>Server 配置 <code>[10000, 10000]</code>，Client 配置 <code>[5000, 5000]</code>。</li>
<li>最终结果：<ul>
<li>Server -&gt; Client：<code>max(10000, 5000) = 10000</code> ms。服务器每 10 秒发一次。</li>
<li>Client -&gt; Server：<code>max(10000, 5000) = 10000</code> ms。客户端每 10 秒发一次。<br>这种设计避免了一方过于频繁地发送心跳给另一方造成压力。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-原生-WebSocket-的手动实现-Ping-Pong"><a href="#1-3-原生-WebSocket-的手动实现-Ping-Pong" class="headerlink" title="1.3 原生 WebSocket 的手动实现 (Ping&#x2F;Pong)"></a>1.3 原生 WebSocket 的手动实现 (Ping&#x2F;Pong)</h3><p>如果你使用原生 WebSocket API（JSR 356 或 Spring 的 <code>WebSocketHandler</code>），则需要手动实现心跳逻辑。WebSocket 协议本身定义了 <code>Ping</code> 和 <code>Pong</code> 两种<strong>控制帧 (Control Frame)</strong>，它们是实现心跳的理想选择。</p>
<ul>
<li><p><strong>协议特性:</strong></p>
<ul>
<li><code>Ping</code> 帧: 由一方发送，用于检测连接或作为保活信号。可以携带少量数据。</li>
<li><code>Pong</code> 帧: 当收到 <code>Ping</code> 帧时，另一方<strong>必须</strong>自动回复一个 <code>Pong</code> 帧。这个响应是 WebSocket 协议栈底层自动完成的，你通常不需要手动编码发送 <code>Pong</code> 来回应 <code>Ping</code>。</li>
</ul>
</li>
<li><p><strong>服务端实现思路:</strong></p>
<ol>
<li><strong>定时发送 Ping:</strong> 创建一个定时任务（如 <code>@Scheduled</code>），遍历所有已连接的 <code>WebSocketSession</code>。</li>
<li><strong>检测 Pong 响应:</strong> 虽然 <code>Pong</code> 是自动回复的，但我们可以监听 <code>PongMessage</code> 事件来确认客户端是否还活着。</li>
<li><strong>关闭僵尸连接:</strong> 记录每个会话的“最后活跃时间”（收到任何消息或 Pong 时更新）。另一个定时任务检查这个时间，如果长时间未更新，则认为连接已死，并主动关闭。</li>
</ol>
</li>
<li><p><strong>示例代码 (基于 Spring 原生 WebSocketHandler):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHeartbeatHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ConcurrentHashMap 存储 session 和最后活跃时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;WebSocketSession, Long&gt; sessionActivityMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">HEARTBEAT_INTERVAL</span> <span class="operator">=</span> <span class="number">15_000</span>; <span class="comment">// 15 秒发送一次 ping</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SESSION_TIMEOUT</span> <span class="operator">=</span> <span class="number">45_000</span>;    <span class="comment">// 45 秒未收到任何消息则超时</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sessionActivityMap.put(session, System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;New connection: &quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 收到任何文本消息，都更新活跃时间</span></span><br><span class="line">        sessionActivityMap.put(session, System.currentTimeMillis());</span><br><span class="line">        <span class="comment">// ... 处理业务消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handlePongMessage</span><span class="params">(WebSocketSession session, PongMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 收到 Pong 消息，是心跳响应，更新活跃时间</span></span><br><span class="line">        sessionActivityMap.put(session, System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;Pong received from: &quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sessionActivityMap.remove(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + session.getId() + <span class="string">&quot; with status: &quot;</span> + status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务：发送 Ping</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = HEARTBEAT_INTERVAL)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendPingToClients</span><span class="params">()</span> &#123;</span><br><span class="line">        sessionActivityMap.keySet().forEach(session -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Ping 消息可以携带一个 payload，客户端的 Pong 响应会原样返回</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">payload</span> <span class="operator">=</span> ByteBuffer.wrap(String.valueOf(System.currentTimeMillis()).getBytes());</span><br><span class="line">                    session.sendMessage(<span class="keyword">new</span> <span class="title class_">PingMessage</span>(payload));</span><br><span class="line">                    System.out.println(<span class="string">&quot;Ping sent to: &quot;</span> + session.getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;Error sending ping to &quot;</span> + session.getId() + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务：检查僵尸连接</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = SESSION_TIMEOUT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkZombieConnections</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        sessionActivityMap.forEach((session, lastActivity) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> ((now - lastActivity) &gt; SESSION_TIMEOUT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Closing zombie connection: &quot;</span> + session.getId());</span><br><span class="line">                        session.close(CloseStatus.SESSION_NOT_RELIABLE);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                         System.err.println(<span class="string">&quot;Error closing zombie session &quot;</span> + session.getId() + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sessionActivityMap.remove(session);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端实现思路:</strong></p>
<ul>
<li><p><strong>响应 Ping:</strong> 现代浏览器 WebSocket API 会自动处理收到的 <code>Ping</code> 帧并回复 <code>Pong</code>。你<strong>不需要</strong>也<strong>无法</strong>通过 JavaScript 监听 <code>ping</code> 事件或手动发送 <code>pong</code>。</p>
</li>
<li><p><strong>主动发送心跳:</strong> 如果需要客户端主动检测服务端状态，由于浏览器 API 没有提供 <code>sendPing()</code> 方法，通常的做法是发送一个<strong>应用层心跳</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/my-heartbeat-handler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> heartbeatInterval;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection opened.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 每 20 秒发送一个应用层心跳包</span></span><br><span class="line">    heartbeatInterval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ws.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span><br><span class="line">            ws.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;heartbeat&#x27;</span>, <span class="attr">timestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>() &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">20000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection closed.&#x27;</span>);</span><br><span class="line">    <span class="built_in">clearInterval</span>(heartbeatInterval); <span class="comment">// 清除定时器</span></span><br><span class="line">    <span class="comment">// 这里可以加入断线重连逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 收到服务器消息，可以认为连接是健康的</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message from server &#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>服务端对应的 <code>handleTextMessage</code> 需要能识别并忽略这种应用层心跳消息，但仍然用它来更新 <code>sessionActivityMap</code> 中的活跃时间。</p>
</li>
</ul>
<hr>
<h2 id="2-健壮性：断线重连与异常处理"><a href="#2-健壮性：断线重连与异常处理" class="headerlink" title="2. 健壮性：断线重连与异常处理"></a>2. 健壮性：断线重连与异常处理</h2><p>网络是不可靠的，用户操作是不可预测的。一个健壮的 WebSocket 应用必须能够优雅地处理各种异常情况，并在连接中断时尝试恢复，以提供无缝的用户体验。</p>
<h3 id="2-1-客户端重连策略-指数退避"><a href="#2-1-客户端重连策略-指数退避" class="headerlink" title="2.1 客户端重连策略 (指数退避)"></a>2.1 客户端重连策略 (指数退避)</h3><p>当 WebSocket 连接意外断开时（例如网络波动、服务器重启），客户端不应该立即、持续地尝试重连。这种行为会带来两个严重问题：</p>
<ol>
<li><strong>服务器风暴 (Thundering Herd):</strong> 如果服务器短暂离线后重启，成千上万的客户端同时发起重连请求，会瞬间耗尽服务器的连接资源，导致“雪崩效应”，使服务器再次宕机。</li>
<li><strong>客户端资源消耗:</strong> 在服务器长时间不可用或网络完全断开的情况下，持续的重连尝试会耗尽客户端（尤其是移动设备）的电量和网络流量。</li>
</ol>
<p><strong>指数退避 (Exponential Backoff)</strong> 是一种被广泛采用的、优雅的重连算法。</p>
<ul>
<li><p><strong>核心思想:</strong> 每次重连失败后，将下一次重连的等待时间加倍，并设置一个最大等待时间上限，同时引入随机性（Jitter）来打乱重连时机。</p>
</li>
<li><p><strong>算法步骤:</strong></p>
<ol>
<li>从一个较短的基础延迟开始（如 1 秒）。</li>
<li>尝试连接。如果失败，将延迟时间乘以一个因子（通常是 2）。</li>
<li>增加一个随机的“抖动”时间（Jitter），以防止客户端在同一时刻同步重连。</li>
<li>等待计算出的延迟时间后，返回步骤 2。</li>
<li>设置一个最大延迟时间（如 60 秒），防止等待时间无限增长。</li>
<li>一旦连接成功，重置所有计数器和延迟时间，以便下次断开时从头开始。</li>
</ol>
</li>
<li><p><strong>使用 <code>stompjs</code> 库实现:</strong><br><code>@stomp/stompjs</code> 库内置了非常完善的重连机制，我们只需要通过配置启用它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Client</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@stomp/stompjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">Client</span>(&#123;</span><br><span class="line">    <span class="attr">brokerURL</span>: <span class="string">&#x27;ws://localhost:8080/your-websocket-endpoint&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心配置：自动重连</span></span><br><span class="line">    <span class="comment">// stompjs 内部已经实现了带抖动的指数退避算法</span></span><br><span class="line">    <span class="attr">reconnectDelay</span>: <span class="number">5000</span>, <span class="comment">// 初始重连延迟为 5 秒。之后会指数增长。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以手动实现更复杂的逻辑</span></span><br><span class="line">    <span class="comment">// beforeConnect: () =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&#x27;Trying to connect...&#x27;);</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.<span class="property">onWebSocketClose</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket closed. Will attempt to reconnect.&#x27;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.<span class="title function_">activate</span>();</span><br></pre></td></tr></table></figure>

<p><code>reconnectDelay</code> 设置了初始延迟，后续的重连会自动遵循指数退避策略。这是最推荐的方式。</p>
</li>
<li><p><strong>原生 WebSocket 手动实现:</strong><br>如果你使用原生 <code>WebSocket</code> API，需要自己实现这个逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> reconnectAttempts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> baseDelay = <span class="number">1000</span>; <span class="comment">// 基础延迟 1 秒</span></span><br><span class="line">    <span class="keyword">const</span> maxDelay = <span class="number">30000</span>; <span class="comment">// 最大延迟 30 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">attemptConnection</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/your-endpoint&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        ws.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection established.&#x27;</span>);</span><br><span class="line">            <span class="comment">// 连接成功，重置尝试次数</span></span><br><span class="line">            reconnectAttempts = <span class="number">0</span>; </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ws.<span class="property">onclose</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection closed.&#x27;</span>, event.<span class="property">code</span>, event.<span class="property">reason</span>);</span><br><span class="line">            reconnectAttempts++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算下一次重连的延迟（指数退避 + 随机抖动）</span></span><br><span class="line">            <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">min</span>(maxDelay, baseDelay * <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, reconnectAttempts));</span><br><span class="line">            <span class="keyword">const</span> jitter = delay * <span class="number">0.2</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>(); <span class="comment">// 增加最多 20% 的抖动</span></span><br><span class="line">            <span class="keyword">const</span> reconnectTimeout = delay + jitter;</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Will attempt to reconnect in <span class="subst">$&#123;<span class="built_in">Math</span>.round(reconnectTimeout / <span class="number">1000</span>)&#125;</span> seconds.`</span>);</span><br><span class="line">            <span class="built_in">setTimeout</span>(attemptConnection, reconnectTimeout);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ws.<span class="property">onerror</span> = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket error:&#x27;</span>, error);</span><br><span class="line">            <span class="comment">// onerror 事件之后通常会立即触发 onclose 事件，所以重连逻辑放在 onclose 中处理</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">attemptConnection</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">connect</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-2-服务端优雅处理连接断开事件"><a href="#2-2-服务端优雅处理连接断开事件" class="headerlink" title="2.2 服务端优雅处理连接断开事件"></a>2.2 服务端优雅处理连接断开事件</h3><p>当一个客户端连接断开时，无论是正常关闭还是异常掉线，服务端都必须能够捕获这个事件并执行相应的清理工作。这被称为“优雅处理”。</p>
<ul>
<li><p><strong>核心任务:</strong></p>
<ol>
<li><strong>释放资源:</strong> 从内存中移除与该会话相关的数据结构（如 Session 对象、用户状态 Map 等），避免内存泄漏。</li>
<li><strong>更新业务状态:</strong> 例如，在聊天室中将用户状态更新为“离线”，在协作文档中释放文档锁。</li>
<li><strong>通知其他用户:</strong> 如果需要，向其他相关的客户端广播该用户离线的消息。</li>
</ol>
</li>
<li><p><strong>Spring STOMP 实现 (<code>SessionDisconnectEvent</code>):</strong><br>Spring 提供了一个非常方便的事件监听机制来处理断连。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketDisconnectListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;SessionDisconnectEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设有一个服务来管理在线用户</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OnlineUserService onlineUserService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(SessionDisconnectEvent event)</span> &#123;</span><br><span class="line">        <span class="type">SimpMessageHeaderAccessor</span> <span class="variable">headerAccessor</span> <span class="operator">=</span> SimpMessageHeaderAccessor.wrap(event.getMessage());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从会话属性中获取用户信息（在握手拦截器中存入）</span></span><br><span class="line">        <span class="type">Principal</span> <span class="variable">user</span> <span class="operator">=</span> headerAccessor.getUser();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sessionId</span> <span class="operator">=</span> headerAccessor.getSessionId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> user.getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;User disconnected: &quot;</span> + username + <span class="string">&quot; (Session ID: &quot;</span> + sessionId + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 更新业务状态：移除在线用户</span></span><br><span class="line">            onlineUserService.removeUser(username);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 通知其他用户：广播更新后的在线用户列表</span></span><br><span class="line">            <span class="comment">// 假设有一个 &quot;/topic/online-users&quot; 主题</span></span><br><span class="line">            messagingTemplate.convertAndSend(<span class="string">&quot;/topic/online-users&quot;</span>, onlineUserService.getOnlineUsers());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;Anonymous session disconnected: &quot;</span> + sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 释放其他资源（如果需要）</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点:</strong> 在握手阶段（<code>HandshakeInterceptor</code>）将用户信息（如 <code>Principal</code> 或自定义 User 对象）存入 <code>session.getAttributes()</code>，这样在断开连接时才能识别是哪个用户离线了。</p>
</li>
</ul>
<hr>
<h3 id="2-3-使用-MessageExceptionHandler-统一处理-STOMP-异常"><a href="#2-3-使用-MessageExceptionHandler-统一处理-STOMP-异常" class="headerlink" title="2.3 使用 @MessageExceptionHandler 统一处理 STOMP 异常"></a>2.3 使用 <code>@MessageExceptionHandler</code> 统一处理 STOMP 异常</h3><p>在处理 STOMP 消息（即 <code>@MessageMapping</code> 方法）的过程中，可能会抛出各种异常（如业务校验失败、数据库访问错误等）。如果不加处理，异常会导致连接被关闭。更好的方式是捕获这些异常，并向触发异常的客户端发送一条错误消息。</p>
<p><code>@MessageExceptionHandler</code> 类似于 Spring MVC 中的 <code>@ExceptionHandler</code>，但专用于 WebSocket 消息处理。</p>
<ul>
<li><p><strong>核心优势:</strong></p>
<ul>
<li><strong>集中处理:</strong> 将异常处理逻辑从业务代码中分离出来，保持 <code>@MessageMapping</code> 方法的整洁。</li>
<li><strong>定向发送:</strong> 可以方便地将错误消息只发送给引发异常的用户，而不是广播给所有人。</li>
</ul>
</li>
<li><p><strong>实现步骤:</strong></p>
<ol>
<li>创建一个带有 <code>@ControllerAdvice</code> 注解的类，使其成为一个全局的异常处理器。</li>
<li>在类中定义方法，并使用 <code>@MessageExceptionHandler</code> 注解。该注解可以指定要处理的异常类型。</li>
<li>使用 <code>@SendToUser</code> 注解，将方法的返回值发送到该用户的特定队列（默认为 <code>/user/queue/errors</code>）。</li>
</ol>
</li>
<li><p><strong>示例代码:</strong></p>
<p><strong>1. 可能抛出异常的 Controller:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping(&quot;/chat.sendMessage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@Payload</span> ChatMessage chatMessage, Principal user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (chatMessage.getContent() == <span class="literal">null</span> || chatMessage.getContent().trim().isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 抛出业务异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message content cannot be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chatMessage.getContent().contains(<span class="string">&quot;spam&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SpamMessageException</span>(<span class="string">&quot;Your message was detected as spam.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 正常处理消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpamMessageException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SpamMessageException</span><span class="params">(String message)</span> &#123; <span class="built_in">super</span>(message); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 全局异常处理器:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个简单的错误响应体</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ErrorResponse</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String error;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ErrorResponse</span><span class="params">(String error)</span> &#123; <span class="built_in">this</span>.error = error; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理特定类型的业务异常</span></span><br><span class="line">    <span class="meta">@MessageExceptionHandler(SpamMessageException.class)</span></span><br><span class="line">    <span class="meta">@SendToUser(&quot;/queue/errors&quot;)</span> <span class="comment">// 将错误消息发送到 /user/queue/errors</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleSpamMessage</span><span class="params">(SpamMessageException ex)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Caught a spam message: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="string">&quot;Spam detected! Message rejected.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理通用的校验异常</span></span><br><span class="line">    <span class="meta">@MessageExceptionHandler(IllegalArgumentException.class)</span></span><br><span class="line">    <span class="meta">@SendToUser(&quot;/queue/errors&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleIllegalArgument</span><span class="params">(IllegalArgumentException ex)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Invalid argument: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理所有其他未捕获的异常</span></span><br><span class="line">    <span class="meta">@MessageExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@SendToUser(&quot;/queue/errors&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleGenericException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;An unexpected error occurred: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="comment">// 注意：生产环境不应将原始异常信息直接暴露给客户端</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="string">&quot;An internal server error occurred. Please try again later.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 客户端订阅错误队列:</strong><br>客户端需要订阅这个私有的错误队列来接收错误通知。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 stompjs</span></span><br><span class="line">client.<span class="property">onConnect</span> = <span class="function">(<span class="params">frame</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connected: &#x27;</span> + frame);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 订阅业务主题</span></span><br><span class="line">    client.<span class="title function_">subscribe</span>(<span class="string">&#x27;/topic/public&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅个人错误队列</span></span><br><span class="line">    client.<span class="title function_">subscribe</span>(<span class="string">&#x27;/user/queue/errors&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> error = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message.<span class="property">body</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Received an error from server:&#x27;</span>, error.<span class="property">error</span>);</span><br><span class="line">        <span class="comment">// 在 UI 上显示错误提示</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;Error: &#x27;</span> + error.<span class="property">error</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3-横向扩展：多实例部署"><a href="#3-横向扩展：多实例部署" class="headerlink" title="3. 横向扩展：多实例部署"></a>3. 横向扩展：多实例部署</h2><p>当单个应用实例无法满足高并发或高可用性需求时，就需要进行横向扩展（Horizontal Scaling），即部署多个应用实例并使用负载均衡器分发流量。然而，由于 WebSocket 的<strong>有状态性</strong>，这带来了独特的挑战。</p>
<h3 id="3-1-原生-WebSocket-Spring-原生-WebSocket-的挑战：Sticky-Session"><a href="#3-1-原生-WebSocket-Spring-原生-WebSocket-的挑战：Sticky-Session" class="headerlink" title="3.1 原生 WebSocket&#x2F;Spring 原生 WebSocket 的挑战：Sticky Session"></a><strong>3.1 原生 WebSocket&#x2F;Spring 原生 WebSocket 的挑战：Sticky Session</strong></h3><ul>
<li><p><strong>问题根源：有状态的连接</strong></p>
<ul>
<li>当一个客户端通过 WebSocket 连接到你的服务时，这个 TCP 连接是与<strong>某一个特定</strong>的应用实例（例如 Server A）建立的。</li>
<li>该实例的内存中维护着这个连接的 <code>WebSocketSession</code> 对象以及所有相关状态。</li>
<li>负载均衡器（如 Nginx）默认情况下会使用轮询（Round-Robin）等策略，将请求随机分发到后端的不同服务器上。</li>
</ul>
</li>
<li><p><strong>场景分析：为什么会失败？</strong></p>
<ol>
<li><strong>Client A</strong> 的 WebSocket 连接被负载均衡器分配到了 <strong>Server A</strong>。</li>
<li><strong>Client B</strong> 的 WebSocket 连接被分配到了 <strong>Server B</strong>。</li>
<li>现在，<strong>Client B</strong> 想给 <strong>Client A</strong> 发送一条消息。它将消息通过自己的 WebSocket 连接发送给 <strong>Server B</strong>。</li>
<li><strong>Server B</strong> 接收到消息，但它在其内存中找不到 <strong>Client A</strong> 的 <code>WebSocketSession</code>。这个 Session 存在于 <strong>Server A</strong> 的内存中。</li>
<li><strong>消息无法送达！</strong> Server B 不知道如何将消息路由到 Server A。</li>
</ol>
</li>
<li><p><strong>传统解决方案：Sticky Session (会话保持)</strong></p>
<ul>
<li><p><strong>概念:</strong> 配置负载均衡器，使其能够识别来自同一客户端的所有请求，并始终将它们转发到<strong>同一个</strong>后端服务器。这通常通过 IP 哈希（<code>ip_hash</code> in Nginx）或设置特定的 Cookie 来实现。</p>
</li>
<li><p><strong>Nginx 配置示例 (<code>ip_hash</code>):</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> websocket_backend &#123;</span><br><span class="line">    ip_hash; // 核心配置：基于客户端 <span class="attribute">IP</span> 地址进行哈希</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="section">location</span> /ws/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://websocket_backend;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;Upgrade&quot;</span>;</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Sticky Session 的严重缺陷:</strong></p>
<ol>
<li><strong>破坏了负载均衡的初衷:</strong> 如果某些“粘性”会话的用户活动非常频繁，可能会导致某些服务器负载过高，而其他服务器却很空闲，无法做到真正的负载均衡。</li>
<li><strong>单点故障风险:</strong> 如果 Client A 所在的 Server A 宕机或重启，Client A 的连接会中断。即使它能立即重连，负载均衡器也可能会因为 <code>ip_hash</code> 而继续尝试连接到已经宕机的 Server A，或者即使连接到了 Server B，它之前的会话状态也全部丢失了。</li>
<li><strong>广播&#x2F;群聊实现的复杂性:</strong> 即使使用了 Sticky Session，如果要实现一个跨所有服务器的广播（如系统公告）或群聊，你仍然需要自己实现一套<strong>服务器间的通信机制</strong>（例如，使用 Redis Pub&#x2F;Sub、Kafka 或 Hazelcast），让一个服务器能通知其他所有服务器向它们各自连接的客户端推送消息。这大大增加了系统的复杂性。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-2-STOMP-外部消息代理-RabbitMQ-的天然优势"><a href="#3-2-STOMP-外部消息代理-RabbitMQ-的天然优势" class="headerlink" title="3.2 STOMP + 外部消息代理 (RabbitMQ) 的天然优势"></a>3.2 STOMP + 外部消息代理 (RabbitMQ) 的天然优势</h3><p>这套架构是解决 WebSocket 水平扩展问题的<strong>黄金标准</strong>。它通过引入一个外部的、专业的消息中间件（Message Broker）来解耦应用服务器和消息路由。</p>
<ul>
<li><p><strong>核心思想：</strong><br>让应用服务器（你的 Spring Boot 应用）只充当一个“哑”网关（Dumb Gateway）。它的职责是：</p>
<ol>
<li>维护与客户端的 WebSocket 连接。</li>
<li>在 STOMP 协议层面与客户端和外部消息代理进行中继（Relay）。<br>消息的路由、分发、订阅管理等“有状态”的复杂工作全部交给外部的专业消息代理来完成。</li>
</ol>
</li>
<li><p><strong>架构与消息流：</strong></p>
<ol>
<li><strong>连接:</strong> Client 通过负载均衡器（无需 Sticky Session）连接到<strong>任意一个</strong>应用实例（如 Server A）。</li>
<li><strong>订阅:</strong> Client 发送一个 <code>SUBSCRIBE</code> 帧到某个主题（如 <code>/topic/news</code>）。Server A 收到后，并<strong>不是在自己内存中记录</strong>，而是代表该 Client 在外部消息代理（RabbitMQ）上创建一个订阅。</li>
<li><strong>发送消息:</strong> 另一个 Client（可能连接在 Server B）发送一个 <code>SEND</code> 帧到 <code>/topic/news</code>。</li>
<li><strong>中继到代理:</strong> Server B 收到消息后，直接将其<strong>转发</strong>给 RabbitMQ。</li>
<li><strong>代理分发:</strong> RabbitMQ 作为消息中心，知道所有关于 <code>/topic/news</code> 的订阅（包括来自 Server A 和 Server B 的）。它会将消息分发给所有订阅了此主题的应用服务器实例。</li>
<li><strong>推送到客户端:</strong> Server A 收到来自 RabbitMQ 的消息后，查询其<strong>本地</strong>维护的 WebSocket 连接，找到订阅了 <code>/topic/news</code> 的 Client，并将消息通过 WebSocket 推送给它。Server B 也做同样的事情。</li>
</ol>
</li>
<li><p><strong>配置 Spring Boot 使用 STOMP Broker Relay</strong></p>
<p>你需要在 <code>WebSocketMessageBrokerConfigurer</code> 中启用 <code>stompBrokerRelay</code>，并配置外部代理的地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 设置客户端发送消息的目标前缀</span></span><br><span class="line">        registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 启用外部消息代理中继</span></span><br><span class="line">        registry.enableStompBrokerRelay(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>) <span class="comment">// 声明哪些前缀由外部代理处理</span></span><br><span class="line">                .setRelayHost(<span class="string">&quot;localhost&quot;</span>)     <span class="comment">// RabbitMQ 主机地址</span></span><br><span class="line">                .setRelayPort(<span class="number">61613</span>)           <span class="comment">// RabbitMQ STOMP 插件默认端口</span></span><br><span class="line">                .setClientLogin(<span class="string">&quot;guest&quot;</span>)       <span class="comment">// 连接 RabbitMQ 的用户名</span></span><br><span class="line">                .setClientPasscode(<span class="string">&quot;guest&quot;</span>);   <span class="comment">// 连接 RabbitMQ 的密码</span></span><br><span class="line">                <span class="comment">// 对于生产环境，还应配置 systemLogin/systemPasscode 用于服务器自身的连接</span></span><br><span class="line">                <span class="comment">// .setSystemLogin(&quot;user&quot;)</span></span><br><span class="line">                <span class="comment">// .setSystemPasscode(&quot;password&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... registerStompEndpoints 配置保持不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 你需要确保你的 RabbitMQ 已经安装并启用了 <code>rabbitmq_stomp</code> 插件。<br><code>rabbitmq-plugins enable rabbitmq_stomp</code></p>
</li>
<li><p><strong>天然优势总结:</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Sticky Session 方案</th>
<th align="left">STOMP + Broker Relay 方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>架构复杂度</strong></td>
<td align="left">高（需要手动实现服务器间通信）</td>
<td align="left">低（配置即可，复杂性由 Broker 处理）</td>
</tr>
<tr>
<td align="left"><strong>可扩展性</strong></td>
<td align="left">差（负载不均，难以扩展）</td>
<td align="left"><strong>极好</strong>（应用实例无状态，可随意增减）</td>
</tr>
<tr>
<td align="left"><strong>可用性</strong></td>
<td align="left">差（服务器宕机导致会话丢失）</td>
<td align="left"><strong>高</strong>（客户端可重连至任何实例，Broker 可集群）</td>
</tr>
<tr>
<td align="left"><strong>负载均衡</strong></td>
<td align="left">策略受限 (ip_hash)</td>
<td align="left">灵活（Round-Robin, Least Connections 等）</td>
</tr>
<tr>
<td align="left"><strong>耦合度</strong></td>
<td align="left">应用服务器间紧密耦合</td>
<td align="left"><strong>松散耦合</strong>（应用服务器与 Broker 通信）</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>结论：</strong> 对于任何需要横向扩展的生产级 WebSocket 应用，采用 <strong>STOMP 配合外部消息代理（如 RabbitMQ、ActiveMQ）</strong> 的方案是目前业界公认的最佳实践。它将你的应用服务器变成了易于扩展和维护的无状态节点，而将状态管理的重任交给了为此而生的专业消息中间件。</p>
<hr>
<h2 id="4-安全加固"><a href="#4-安全加固" class="headerlink" title="4. 安全加固"></a>4. 安全加固</h2><p>一旦 WebSocket 连接建立，它就为客户端和服务器之间打开了一条双向通信的“隧道”。这条隧道绕过了常规的 HTTP 请求&#x2F;响应周期，因此必须在连接建立时和连接期间都实施严格的安全策略。</p>
<h3 id="4-1-强制-WSS：数据传输加密"><a href="#4-1-强制-WSS：数据传输加密" class="headerlink" title="4.1 强制 WSS：数据传输加密"></a>4.1 强制 WSS：数据传输加密</h3><ul>
<li><p><strong>是什么？</strong></p>
<ul>
<li><code>ws://</code> (WebSocket) 类似于 <code>http://</code>，其传输的数据是<strong>未加密的明文</strong>。</li>
<li><code>wss://</code> (WebSocket Secure) 类似于 <code>https://</code>，它在标准的 WebSocket 协议基础上，通过 TLS&#x2F;SSL 加密层进行数据传输。</li>
</ul>
</li>
<li><p><strong>为什么必须使用？</strong><br>在生产环境中，如果使用 <code>ws://</code>，任何处在客户端和服务器之间的中间节点（如不安全的 Wi-Fi、代理、ISP）都可以轻易地<strong>窃听</strong>（读取消息内容）和<strong>篡改</strong>（修改消息内容）通信数据，这被称为中间人攻击（Man-in-the-Middle, MITM）。<code>wss://</code> 通过加密可以有效防止这类攻击，确保通信的<strong>机密性</strong>和<strong>完整性</strong>。</p>
</li>
<li><p><strong>如何实现？</strong></p>
<ol>
<li><p><strong>应用服务器配置 SSL&#x2F;TLS：</strong><br>在 Spring Boot 中，最简单的方式是在 <code>application.properties</code> 或 <code>application.yml</code> 中配置 SSL。你需要一个 SSL 证书（例如 <code>.p12</code> 或 <code>.jks</code> 格式）。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8443</span></span><br><span class="line"><span class="attr">server.ssl.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.ssl.key-store-type</span>=<span class="string">PKCS12</span></span><br><span class="line"><span class="attr">server.ssl.key-store</span>=<span class="string">classpath:keystore/your-certificate.p12</span></span><br><span class="line"><span class="attr">server.ssl.key-store-password</span>=<span class="string">your_password</span></span><br><span class="line"><span class="attr">server.ssl.key-alias</span>=<span class="string">your_alias</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在反向代理中终止 SSL (推荐的生产实践):</strong><br>在大多数生产环境中，SSL&#x2F;TLS 通常在反向代理层（如 Nginx、API Gateway）被终止。客户端连接到 Nginx 的 <code>wss://</code> 地址，而 Nginx 再通过内网的 <code>ws://</code> 连接到后端的 Spring Boot 应用。这样可以集中管理证书，并减轻应用服务器的加解密负担。<br><strong>Nginx 配置示例：</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> your.domain.com;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">ssl_certificate</span> /path/to/your/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/your/privkey.pem;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /ws/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://&lt;your_spring_boot_app_ip&gt;:8080/ws/;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 关键头信息，用于协议升级</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;Upgrade&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 传递真实 IP 和协议信息</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端修改连接地址：</strong><br>客户端只需将连接 URL 从 <code>ws://your.domain.com/ws</code> 修改为 <code>wss://your.domain.com/ws</code> 即可。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-2-身份验证-Authentication"><a href="#4-2-身份验证-Authentication" class="headerlink" title="4.2 身份验证 (Authentication)"></a>4.2 身份验证 (Authentication)</h3><p>匿名 WebSocket 连接在大多数应用中是无用的，我们必须知道是<strong>谁</strong>在连接。</p>
<ul>
<li><p><strong>1. 基于 Token 的验证 (适用于前后端分离&#x2F;SPA)</strong><br>这是最常见的方式。用户通过 HTTP 登录获取一个 Token (如 JWT)，然后在建立 WebSocket 连接时携带此 Token。</p>
<ul>
<li><strong>实现方式：</strong> 在握手拦截器 <code>HandshakeInterceptor</code> 的 <code>beforeHandshake</code> 方法中进行校验。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServletServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.HandshakeInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.Principal;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入你的 Token 验证服务</span></span><br><span class="line">    <span class="comment">// @Autowired private JwtTokenProvider tokenProvider;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletServerHttpRequest) &#123;</span><br><span class="line">            <span class="type">ServletServerHttpRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> (ServletServerHttpRequest) request;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从 HTTP Header 中获取 Token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> servletRequest.getServletRequest().getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 简单的 Bearer Token 格式校验</span></span><br><span class="line">            <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; token.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">                token = token.substring(<span class="number">7</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 验证 Token (伪代码)</span></span><br><span class="line">                <span class="comment">// if (tokenProvider.validateToken(token)) &#123;</span></span><br><span class="line">                <span class="comment">//    String username = tokenProvider.getUsernameFromJWT(token);</span></span><br><span class="line">                <span class="keyword">if</span> (isValid(token)) &#123; <span class="comment">// 替换为真实的 Token 验证逻辑</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> getUsernameFrom(token);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 创建一个 Principal 对象代表已认证的用户</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Principal</span> <span class="variable">userPrincipal</span> <span class="operator">=</span> () -&gt; username;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将认证信息放入 WebSocket Session 的 attributes 中</span></span><br><span class="line">                    <span class="comment">// 后续在 STOMP 的事件或控制器中可以通过 HeaderAccessor.getUser() 获取</span></span><br><span class="line">                    attributes.put(<span class="string">&quot;user&quot;</span>, userPrincipal);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 握手成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证失败，拒绝握手</span></span><br><span class="line">        System.err.println(<span class="string">&quot;WebSocket handshake rejected: Invalid or missing token.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... afterHandshake 方法 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 WebSocket 配置中注册此拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">    registry.addEndpoint(<span class="string">&quot;/ws&quot;</span>)</span><br><span class="line">            .addInterceptors(<span class="keyword">new</span> <span class="title class_">AuthHandshakeInterceptor</span>()) <span class="comment">// 添加拦截器</span></span><br><span class="line">            .setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端在连接时，需要在 <code>stompjs</code> 的 <code>connectHeaders</code> 中传入 Token。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">Client</span>(&#123;</span><br><span class="line">    <span class="attr">brokerURL</span>: <span class="string">&#x27;wss://your.domain.com/ws&#x27;</span>,</span><br><span class="line">    <span class="attr">connectHeaders</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer your-jwt-token-here&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>2. 集成 Spring Security (适用于传统 Session 或统一安全框架)</strong><br>如果你的应用已经在使用 Spring Security，那么集成 WebSocket 认证会非常自然。</p>
<ul>
<li><strong>原理：</strong> WebSocket 的 HTTP Upgrade 握手请求本身就是一个 HTTP 请求，它会经过 Spring Security 的 Filter 链。如果用户已经通过 HTTP 登录（例如，持有 Session Cookie），Spring Security 会自动将认证信息（<code>Principal</code>）填充到 <code>HttpServletRequest</code> 中。</li>
<li><strong>实现：</strong> Spring WebSocket 会<strong>自动</strong>从握手请求中获取 <code>Principal</code> 并将其与 <code>WebSocketSession</code> 关联。你几乎不需要做任何额外配置！</li>
<li><strong>使用：</strong> 在你的 <code>@MessageMapping</code> 方法中，可以直接注入 <code>Principal</code> 对象来获取当前用户信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateMessageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping(&quot;/private.message&quot;)</span></span><br><span class="line">    <span class="meta">@SendToUser(&quot;/queue/reply&quot;)</span> <span class="comment">// 发送给当前用户</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendPrivateMessage</span><span class="params">(<span class="meta">@Payload</span> String message, Principal principal)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> principal.getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Received a private message from &quot;</span> + username + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 处理私信逻辑...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Reply to &quot;</span> + username + <span class="string">&quot;: message received.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-3-跨站-WebSocket-劫持-CSWSH-防御"><a href="#4-3-跨站-WebSocket-劫持-CSWSH-防御" class="headerlink" title="4.3 跨站 WebSocket 劫持 (CSWSH) 防御"></a>4.3 跨站 WebSocket 劫持 (CSWSH) 防御</h3><ul>
<li><p><strong>攻击原理 (Cross-Site WebSocket Hijacking):</strong><br>这是一种类似于 CSRF 的攻击。假设用户已登录你的网站 <code>A.com</code>。然后，用户访问了一个恶意网站 <code>B.com</code>。<code>B.com</code> 的页面中的 JavaScript 可以尝试向你的 WebSocket 端点 <code>wss://A.com/ws</code> 发起连接。由于浏览器会自动携带 <code>A.com</code> 的 Cookie，如果你的认证是基于 Cookie 的，这个连接就会被认证成功。此时，<code>B.com</code> 就能以用户的身份与你的服务器进行 WebSocket 通信，窃取信息或执行恶意操作。</p>
</li>
<li><p><strong>防御手段：校验 <code>Origin</code> 头部</strong><br>浏览器在发起跨域请求（包括 WebSocket 握手）时，会自动在请求头中添加一个 <code>Origin</code> 字段，标明请求发起的源（例如 <code>https://B.com</code>）。服务器端必须校验这个 <code>Origin</code> 头部，只允许来自受信任域名的连接。</p>
</li>
<li><p><strong>Spring 实现：</strong><br>Spring WebSocket 提供了非常便捷的配置方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">    registry.addEndpoint(<span class="string">&quot;/ws&quot;</span>)</span><br><span class="line">            <span class="comment">// 只允许来自 &quot;https://your-frontend.com&quot; 的连接</span></span><br><span class="line">            .setAllowedOrigins(<span class="string">&quot;https://your-frontend.com&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 或者使用模式匹配，允许所有子域名</span></span><br><span class="line">            <span class="comment">// .setAllowedOriginPatterns(&quot;https://*.your-domain.com&quot;, &quot;http://localhost:3000&quot;)</span></span><br><span class="line">            </span><br><span class="line">            .withSockJS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践：</strong></p>
<ul>
<li><strong>永远不要使用 <code>setAllowedOrigins(&quot;\*&quot;)</code> 在生产环境！</strong> 这会完全禁用 Origin 检查，使你的应用暴露在 CSWSH 攻击之下。</li>
<li>尽可能使用 <code>setAllowedOrigins</code> 提供精确的域名列表。</li>
<li>如果需要支持多个子域或开发环境，谨慎使用 <code>setAllowedOriginPatterns</code>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-性能与调优"><a href="#5-性能与调优" class="headerlink" title="5. 性能与调优"></a>5. 性能与调优</h2><p>当 WebSocket 应用的用户量和消息吞吐量增长时，性能瓶颈可能会出现在网络、CPU 或内存等多个方面。合理的调优可以显著提升应用的吞吐能力和稳定性。</p>
<h3 id="5-1-消息大小与缓冲区配置"><a href="#5-1-消息大小与缓冲区配置" class="headerlink" title="5.1 消息大小与缓冲区配置"></a>5.1 消息大小与缓冲区配置</h3><ul>
<li><p><strong>背景：</strong><br>为了处理网络 I&#x2F;O，WebSocket 服务器（如 Tomcat, Undertow）和 Spring 框架本身都会使用缓冲区（Buffer）。当应用发送消息时，消息数据会先被写入这些缓冲区，然后由 I&#x2F;O 线程异步发送到网络上。缓冲区的大小直接影响了消息处理的方式和效率。</p>
</li>
<li><p><strong>核心参数：</strong><br>在 Spring Boot 中，主要有两层配置需要关注：</p>
<ol>
<li><p><strong>Spring WebSocket 消息缓冲区 (<code>spring.websocket.messaging.\*</code>):</strong><br>这些配置控制 Spring <code>StompSubProtocolHandler</code> 的行为。</p>
<ul>
<li><code>send-buffer-size-limit</code>: 发送缓冲区的总大小限制（默认 512KB）。当缓冲区满时，尝试发送消息的线程会被<strong>阻塞</strong>，直到缓冲区有可用空间。这是一种背压（Back-pressure）机制，防止应用因生产消息过快而耗尽内存。</li>
<li><code>send-time-limit</code>: 发送消息的超时时间（默认 10秒）。如果一个消息因为缓冲区持续满而无法在规定时间内发送，连接将被关闭。这可以防止一个缓慢的客户端拖垮整个服务器。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="comment"># 将发送缓冲区上限增加到 1MB</span></span><br><span class="line"><span class="attr">spring.websocket.messaging.send-buffer-size-limit</span>=<span class="string">1048576 </span></span><br><span class="line"><span class="comment"># 将发送超时时间增加到 20 秒</span></span><br><span class="line"><span class="attr">spring.websocket.messaging.send-time-limit</span>=<span class="string">20000 </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Web 容器 I&#x2F;O 缓冲区 (<code>server.tomcat.\*</code> or <code>server.undertow.\*</code>):</strong><br>这控制了底层 Web 容器的 TCP 缓冲区大小。如果一条 WebSocket 消息的大小超过了这个缓冲区，它将被<strong>分片 (Fragmented)</strong> 成多个 WebSocket 帧进行传输。</p>
<ul>
<li><strong>Tomcat:</strong> <code>server.tomcat.max-http-post-size</code> (虽然名字是post，但也影响WebSocket消息大小)</li>
<li><strong>Undertow:</strong> <code>server.undertow.buffer-size</code></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>调优策略：</strong></p>
<ul>
<li><strong>对于大量小消息：</strong> 默认配置通常表现良好。过大的缓冲区可能会造成内存浪费。</li>
<li><strong>对于需要发送大消息的场景（如文件传输、大数据可视化）：</strong><ul>
<li>必须适当<strong>增大 <code>send-buffer-size-limit</code></strong>，否则发送线程会频繁阻塞，导致吞吐量下降。</li>
<li>同时，可能需要增大底层容器的缓冲区（如 <code>server.undertow.buffer-size</code>），以<strong>避免消息被过度分片</strong>。消息分片和重组会带来额外的 CPU 和网络开销。</li>
<li><strong>原则：</strong> 容器的 I&#x2F;O 缓冲区大小应略大于你预期的最大单条消息大小。</li>
</ul>
</li>
<li><strong>监控：</strong> 在生产环境中，监控发送缓冲区的利用率和因缓冲区满而导致的阻塞时间，是决定是否需要调优的关键依据。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-2-同步与异步发送的选择"><a href="#5-2-同步与异步发送的选择" class="headerlink" title="5.2 同步与异步发送的选择"></a>5.2 同步与异步发送的选择</h3><ul>
<li><strong>Spring STOMP 的默认行为：异步发送</strong><br>当你使用 <code>SimpMessagingTemplate.convertAndSend()</code> 时，这个调用是<strong>异步</strong>的。<ul>
<li><strong>工作原理：</strong> 你的调用线程（例如，一个处理 HTTP 请求的线程）将消息交给 Spring 的 <code>clientOutboundChannel</code> 后会<strong>立即返回</strong>。专门的 <code>outbound-channel-executor</code> 线程池会负责将消息实际写入 WebSocket 连接。</li>
<li><strong>优势：</strong><ol>
<li><strong>高吞吐量：</strong> 应用线程不会因为网络 I&#x2F;O 或慢客户端而被阻塞，可以快速处理更多业务请求。</li>
<li><strong>隔离性：</strong> WebSocket 的发送性能问题不会直接影响到应用的其它部分（如 HTTP API 的响应时间）。</li>
</ol>
</li>
<li><strong>结论：</strong> 在绝大多数情况下，<strong>你应该坚持使用默认的异步发送</strong>。这是 Spring 设计的精髓所在，旨在构建高并发、响应迅速的应用。</li>
</ul>
</li>
<li><strong>原生 WebSocket API 的行为：同步发送</strong><br>如果你使用原生的 <code>WebSocketSession.sendMessage()</code>，这个调用通常是<strong>同步阻塞</strong>的。<ul>
<li><strong>潜在风险：</strong> 调用线程会一直等待，直到消息被完全写入操作系统的 TCP 发送缓冲区。如果网络拥塞或者客户端接收缓慢，这个调用可能会<strong>阻塞很长时间</strong>。</li>
<li><strong>严重后果：</strong> 如果你在一个处理 HTTP 请求的关键线程中调用了 <code>session.sendMessage()</code>，一个慢速的 WebSocket 客户端就可能耗尽你的 HTTP 线程池，导致整个应用无响应。</li>
<li><strong>解决方案：</strong> 如果你必须使用原生 API 并且需要发送大量数据，你应该将 <code>sendMessage()</code> 的调用<strong>包装在自己的异步任务中</strong>（例如，提交给一个专用的线程池），以避免阻塞关键线程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-3-消息格式选择：JSON-vs-Protobuf"><a href="#5-3-消息格式选择：JSON-vs-Protobuf" class="headerlink" title="5.3 消息格式选择：JSON vs Protobuf"></a>5.3 消息格式选择：JSON vs Protobuf</h3><p>消息格式的选择直接影响到<strong>网络带宽占用</strong>、<strong>CPU 序列化&#x2F;反序列化开销</strong>和<strong>开发调试效率</strong>。</p>
<ul>
<li><strong>JSON (JavaScript Object Notation)</strong><ul>
<li><strong>优点：</strong><ul>
<li><strong>可读性强：</strong> 纯文本，易于人类阅读和调试。</li>
<li><strong>通用性好：</strong> Web 前端原生支持（<code>JSON.parse</code>, <code>JSON.stringify</code>），几乎所有语言都有完善的库。</li>
<li><strong>开发友好：</strong> 无需预定义 schema，动态修改结构方便。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>冗余：</strong> 包含大量的键名、括号、引号，体积较大。</li>
<li><strong>性能：</strong> 基于文本的解析比二进制解析慢。</li>
<li><strong>类型不安全：</strong> 无法在协议层面保证数据类型和结构的正确性。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Protobuf (Protocol Buffers)</strong><ul>
<li><strong>优点：</strong><ul>
<li><strong>极致紧凑：</strong> 二进制格式，移除了所有冗余信息，消息体积通常比 JSON 小 3-10 倍。</li>
<li><strong>高性能：</strong> 序列化和反序列化速度极快，CPU 占用低。</li>
<li><strong>强类型与 schema：</strong> 通过 <code>.proto</code> 文件预定义消息结构，具有严格的类型检查，减少运行时错误。</li>
<li><strong>向后&#x2F;向前兼容：</strong> 良好的版本管理机制，便于协议升级。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>不可读：</strong> 二进制格式，无法直接阅读，调试需要借助工具。</li>
<li><strong>需要编译：</strong> <code>.proto</code> 文件需要编译成特定语言的代码（如 Java, JS）。</li>
<li><strong>前期工作量大：</strong> 需要预先设计和维护 <code>.proto</code> 文件。</li>
</ul>
</li>
</ul>
</li>
<li><strong>选型指南与对比</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JSON</th>
<th align="left">Protobuf</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可读性</strong></td>
<td align="left"><strong>高</strong></td>
<td align="left">低 (二进制)</td>
</tr>
<tr>
<td align="left"><strong>消息体积</strong></td>
<td align="left">大 (冗余)</td>
<td align="left"><strong>小</strong> (紧凑)</td>
</tr>
<tr>
<td align="left"><strong>序列化性能</strong></td>
<td align="left">中等</td>
<td align="left"><strong>高</strong></td>
</tr>
<tr>
<td align="left"><strong>Schema 约束</strong></td>
<td align="left">无 (灵活但易错)</td>
<td align="left"><strong>强</strong> (<code>.proto</code> 文件)</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left"><strong>高</strong> (快速上手)</td>
<td align="left">低 (需要预定义和编译)</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">Web 应用、管理后台、API</td>
<td align="left">高性能游戏、金融行情、IoT、移动端</td>
</tr>
</tbody></table>
<p><strong>如何在 Spring 中使用 Protobuf？</strong></p>
<p>你需要创建一个自定义的 <code>MessageConverter</code>。</p>
<ol>
<li><p><strong>添加依赖:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.21.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- Use an appropriate version --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 <code>ProtobufMessageConverter</code>:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtobufMessageConverter</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessageConverter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProtobufMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 定义此转换器支持的 MimeType</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">MimeType</span>(<span class="string">&quot;application&quot;</span>, <span class="string">&quot;x-protobuf&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否是 Protobuf 生成的类</span></span><br><span class="line">        <span class="keyword">return</span> GeneratedMessageV3.class.isAssignableFrom(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">convertFromInternal</span><span class="params">(Message&lt;?&gt; message, Class&lt;?&gt; targetClass, Object conversionHint)</span> &#123;</span><br><span class="line">        <span class="comment">// 反序列化逻辑（省略）</span></span><br><span class="line">        <span class="comment">// 从 message.getPayload() (byte[]) 反序列化为 targetClass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.convertFromInternal(message, targetClass, conversionHint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">convertToInternal</span><span class="params">(Object payload, MessageHeaders headers, Object conversionHint)</span> &#123;</span><br><span class="line">        <span class="comment">// 序列化逻辑</span></span><br><span class="line">        <span class="comment">// 将 payload (Protobuf 对象) 序列化为 byte[]</span></span><br><span class="line">        <span class="keyword">return</span> ((GeneratedMessageV3) payload).toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 WebSocket 配置中注册转换器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;MessageConverter&gt; messageConverters)</span> &#123;</span><br><span class="line">    messageConverters.add(<span class="keyword">new</span> <span class="title class_">ProtobufMessageConverter</span>());</span><br><span class="line">    <span class="comment">// 返回 false 以保留 Spring 默认的转换器 (如 Jackson2JsonMessageConverter)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="七、总结与展望"><a href="#七、总结与展望" class="headerlink" title="七、总结与展望"></a>七、总结与展望</h1><h2 id="1-技术选型指南"><a href="#1-技术选型指南" class="headerlink" title="1. 技术选型指南"></a>1. 技术选型指南</h2><p>在 Java 生态中，实现 WebSocket 有多种层次的抽象。选择哪一种技术取决于你的项目需求、团队熟悉度、以及对未来扩展性的预期。下面是三种主流方案的选型对比。</p>
<h3 id="1-1-何时使用-JSR-356-Java-原生-API-？"><a href="#1-1-何时使用-JSR-356-Java-原生-API-？" class="headerlink" title="1.1 何时使用 JSR 356 (Java 原生 API)？"></a>1.1 何时使用 JSR 356 (Java 原生 API)？</h3><p><strong>一句话总结：当你不使用 Spring 框架，或者你需要对 WebSocket 协议进行“像素级”的底层控制时。</strong></p>
<ul>
<li><strong>核心特征：</strong><ul>
<li><strong>标准规范：</strong> 作为 Java EE 的一部分，它保证了在不同实现了该规范的应用服务器（Tomcat, Jetty, Undertow 等）之间的可移植性。</li>
<li><strong>轻量级：</strong> 无需任何额外的框架依赖，非常轻量。</li>
<li><strong>最大控制权：</strong> 你可以直接操作 <code>Session</code>、处理 <code>Ping/Pong</code> 控制帧、自定义消息分片等，拥有对连接最底层的完全控制。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li><strong>非 Spring 环境：</strong> 在一个未使用 Spring 或 Spring Boot 的传统 Java Web 项目中。</li>
<li><strong>高度定制的协议：</strong> 当你需要实现一个完全自定义的、非 STOMP 的二进制或文本协议时。</li>
<li><strong>极限性能压榨：</strong> 在某些需要极致优化内存和 CPU 的场景下，你希望避免任何框架开销，并手动管理所有资源。</li>
<li><strong>构建 WebSocket 框架或代理：</strong> 如果你的目标是开发一个基于 WebSocket 的中间件或库，直接使用标准 API 是最合适的。</li>
</ul>
</li>
<li><strong>局限性：</strong><ul>
<li><strong>所有事情都得自己做：</strong> 你需要手动管理 Session 列表、实现用户与 Session 的映射、编写消息广播&#x2F;群发&#x2F;单发的路由逻辑、手动实现心跳检测和重连策略。工作量巨大且容易出错。</li>
<li><strong>与 Spring 生态脱节：</strong> 无法直接利用 Spring 的依赖注入、AOP、安全管理等便利特性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-何时使用-Spring-原生-WebSocket-WebSocketHandler-？"><a href="#1-2-何时使用-Spring-原生-WebSocket-WebSocketHandler-？" class="headerlink" title="1.2 何时使用 Spring 原生 WebSocket (WebSocketHandler)？"></a>1.2 何时使用 Spring 原生 WebSocket (<code>WebSocketHandler</code>)？</h3><p><strong>一句话总结：当你需要一个简单的、事件驱动的 WebSocket 实现，并且希望与 Spring 生态无缝集成时。</strong></p>
<ul>
<li><strong>核心特征：</strong><ul>
<li><strong>Spring 生态集成：</strong> 完美融入 Spring，可以自由使用 <code>@Autowired</code> 注入任何 Bean。<code>WebSocketHandler</code> 本身就是一个 Spring Bean。</li>
<li><strong>事件驱动模型：</strong> 提供了清晰的生命周期方法，如 <code>afterConnectionEstablished</code>, <code>handleMessage</code>, <code>afterConnectionClosed</code>。逻辑清晰，易于理解。</li>
<li><strong>中间层抽象：</strong> 它隐藏了 JSR 356 的底层细节，但又不像 STOMP 那样引入完整的消息协议。你处理的是 <code>WebSocketMessage</code>，而不是更复杂的 STOMP 帧。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li><strong>简单的服务器推送 (Server-Push)：</strong> 例如，向客户端推送系统状态、股票行情、日志更新等，客户端主要是接收方。</li>
<li><strong>简单的请求-响应：</strong> 客户端发送一个请求，服务器处理后返回一个结果，没有复杂的路由需求。</li>
<li><strong>自定义协议原型：</strong> 你想在 Spring 环境中实现一个简单的自定义 JSON 协议，但又觉得 STOMP 太重。</li>
<li><strong>SockJS 兼容性：</strong> 当你需要利用 Spring 提供的 SockJS 后备方案来兼容不支持 WebSocket 的旧浏览器时。</li>
</ul>
</li>
<li><strong>局限性：</strong><ul>
<li><strong>缺少协议层支持：</strong> 你仍然需要自己定义消息的格式（例如，在 JSON 中包含 “type”, “payload” 字段）并手动解析和路由。</li>
<li><strong>广播&#x2F;订阅逻辑需自建：</strong> 仍然需要手动维护 Session 列表来实现向多个用户发送消息。</li>
<li><strong>无内置用户目标：</strong> 不支持像 STOMP 那样方便的 <code>/user/queue/private</code> 私有消息。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-何时使用-Spring-STOMP？"><a href="#1-3-何时使用-Spring-STOMP？" class="headerlink" title="1.3 何时使用 Spring + STOMP？"></a>1.3 何时使用 Spring + STOMP？</h3><p><strong>一句话总结：对于绝大多数需要复杂交互（如聊天、协作、通知）的现代 Web 应用，这应该是你的</strong>默认<strong>和</strong>首选<strong>方案。</strong></p>
<ul>
<li><strong>核心特征：</strong><ul>
<li><strong>完整的消息协议：</strong> STOMP 是一个成熟的、轻量级的消息协议。它定义了 <code>SUBSCRIBE</code>, <code>SEND</code>, <code>MESSAGE</code> 等命令，让通信变得结构化。</li>
<li><strong>面向消息的编程模型：</strong> 使用 <code>@MessageMapping</code> 和 <code>@SubscribeMapping</code>，就像使用 Spring MVC 的 <code>@RequestMapping</code> 一样自然，极大地提高了开发效率。</li>
<li><strong>内置路由和广播：</strong> 基于目标地址（Destination）的发布-订阅（Pub-Sub）模型。你只需要向一个主题（如 <code>/topic/news</code>）发送消息，所有订阅了该主题的客户端都会收到，无需手动遍历 Session。</li>
<li><strong>强大的用户私信：</strong> 内置的 <code>/user</code> 目标前缀可以轻松实现向特定用户发送消息，这是许多应用的核心需求。</li>
<li><strong>完美的横向扩展能力：</strong> 可以无缝地从内置的简单代理切换到外部消息代理（如 RabbitMQ, ActiveMQ），以支持多实例集群部署，这是企业级应用的关键。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li><strong>聊天室&#x2F;即时通讯（IM）</strong></li>
<li><strong>在线协作工具</strong>（如协同编辑、白板）</li>
<li><strong>实时通知系统</strong></li>
<li><strong>实时数据仪表盘</strong>（Dashboard）</li>
<li><strong>任何需要 Pub-Sub、点对点消息、且未来可能需要水平扩展的应用。</strong></li>
</ul>
</li>
<li><strong>局限性：</strong><ul>
<li><strong>有一定学习成本：</strong> 需要理解 STOMP 协议的基本概念（Destination, Frame, Broker 等）。</li>
<li><strong>协议开销：</strong> 相比原生 WebSocket，STOMP 帧会增加一些协议头的开销，但对于大多数应用来说，这种开销可以忽略不计，换来的是巨大的开发便利性和可扩展性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-技术选型对比速查表"><a href="#1-4-技术选型对比速查表" class="headerlink" title="1.4 技术选型对比速查表"></a>1.4 技术选型对比速查表</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JSR 356 (原生)</th>
<th align="left">Spring 原生 WebSocket</th>
<th align="left">Spring + STOMP (推荐)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>抽象级别</strong></td>
<td align="left"><strong>底层</strong> (直接操作 Session 和帧)</td>
<td align="left"><strong>中层</strong> (事件驱动，消息对象)</td>
<td align="left"><strong>高层</strong> (消息协议，注解驱动)</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left">低</td>
<td align="left">中</td>
<td align="left"><strong>高</strong></td>
</tr>
<tr>
<td align="left"><strong>功能完备性</strong></td>
<td align="left">基础</td>
<td align="left">中等</td>
<td align="left"><strong>非常完备</strong> (路由, 用户目标, 心跳…)</td>
</tr>
<tr>
<td align="left"><strong>横向扩展</strong></td>
<td align="left">困难 (需手动实现)</td>
<td align="left">困难 (需手动实现)</td>
<td align="left"><strong>简单</strong> (切换到外部 Broker)</td>
</tr>
<tr>
<td align="left"><strong>典型用例</strong></td>
<td align="left">非 Spring 环境，定制协议</td>
<td align="left">简单的服务器推送，简单请求响应</td>
<td align="left"><strong>聊天、通知、协作、任何复杂交互</strong></td>
</tr>
<tr>
<td align="left"><strong>推荐指数</strong></td>
<td align="left">★☆☆☆☆</td>
<td align="left">★★☆☆☆</td>
<td align="left">★★★★★</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-常用调试工具"><a href="#2-常用调试工具" class="headerlink" title="2. 常用调试工具"></a>2. 常用调试工具</h2><p>调试 WebSocket 不像调试 HTTP 那样直观，因为连接是持久的，通信是异步的。幸运的是，我们有多种强大的工具来帮助我们窥探 WebSocket 的内部世界。</p>
<h3 id="2-1-浏览器开发者工具-Network-WS"><a href="#2-1-浏览器开发者工具-Network-WS" class="headerlink" title="2.1 浏览器开发者工具 (Network -&gt; WS)"></a>2.1 浏览器开发者工具 (Network -&gt; WS)</h3><p>这是最直接、最常用的前端 WebSocket 调试工具，每个现代浏览器（Chrome, Firefox, Edge, Safari）都内置了它。</p>
<ul>
<li><strong>如何找到它？</strong><ol>
<li>在你的网页上按 <code>F12</code> 或右键选择“检查”打开开发者工具。</li>
<li>切换到 <strong>Network (网络)</strong> 面板。</li>
<li>在筛选器中，点击 <strong>WS</strong> (WebSocket) 来过滤出 WebSocket 连接。</li>
<li>刷新页面或执行建立 WebSocket 连接的操作。</li>
</ol>
</li>
<li><strong>核心功能与解读：</strong><ol>
<li><strong>Headers (标头) 面板：</strong><ul>
<li><strong>General (常规):</strong> 显示请求 URL (<code>wss://...</code>)、请求方法（<code>GET</code>）和最重要的<strong>状态码 <code>101 Switching Protocols</code></strong>。如果不是 101，说明 WebSocket 握手失败了，你需要检查 URL、服务器配置或拦截器逻辑。</li>
<li><strong>Response Headers (响应标头):</strong> 确认服务器返回了 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code>。</li>
<li><strong>Request Headers (请求标头):</strong> 检查客户端是否正确发送了 <code>Upgrade: websocket</code>、<code>Connection: Upgrade</code> 以及重要的 <code>Sec-WebSocket-Key</code>。这也是检查 <code>Origin</code> 头和自定义认证头（如 <code>Authorization</code>）的地方。</li>
</ul>
</li>
<li><strong>Messages (消息&#x2F;帧) 面板：</strong><ul>
<li>这是<strong>最核心</strong>的调试区域。它实时显示客户端和服务器之间传输的所有数据帧。</li>
<li><strong>绿色向上箭头 (<code>↑</code>):</strong> 表示由客户端<strong>发送</strong>到服务器的消息。</li>
<li><strong>红色向下箭头 (<code>↓</code>):</strong> 表示由服务器<strong>接收</strong>到客户端的消息。</li>
<li><strong>Data (数据) 列：</strong> 显示消息的内容。如果内容是 JSON，通常可以直接展开查看。对于 STOMP，你会看到完整的 STOMP 帧，包括命令（<code>CONNECT</code>, <code>SUBSCRIBE</code>, <code>MESSAGE</code>）、头部和 Body。</li>
<li><strong>Time (时间) 列：</strong> 显示消息的时间戳，有助于分析延迟和消息顺序。</li>
<li><strong>筛选器：</strong> 你可以在顶部输入关键词来筛选特定的消息，这在消息流非常快时特别有用。</li>
</ul>
</li>
</ol>
</li>
<li><strong>调试技巧：</strong><ul>
<li><strong>握手失败：</strong> 首先检查 <code>Headers</code> 面板，确认状态码和请求&#x2F;响应头是否正确。检查控制台（Console）是否有相关的错误信息。</li>
<li><strong>消息未收到：</strong> 在 <code>Messages</code> 面板确认消息是否真的被发送或接收。检查 STOMP 帧的目标地址（<code>destination</code> header）是否正确。</li>
<li><strong>消息格式错误：</strong> 点击具体的消息行，查看原始数据，确认 JSON 格式是否正确，或者 STOMP 帧的结构是否符合规范。</li>
<li><strong>心跳观察：</strong> 如果配置了 STOMP 心跳，你会在 <code>Messages</code> 面板中看到周期性的换行符（<code>\n</code>）或 <code>MESSAGE</code> 帧（取决于代理实现），这可以用来确认心跳机制是否在正常工作。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-Postman-Apifox-的-WebSocket-测试功能"><a href="#2-2-Postman-Apifox-的-WebSocket-测试功能" class="headerlink" title="2.2 Postman &#x2F; Apifox 的 WebSocket 测试功能"></a>2.2 Postman &#x2F; Apifox 的 WebSocket 测试功能</h3><p>虽然浏览器是调试前端的好地方，但有时我们需要一个独立的、功能更强大的客户端来模拟各种场景或进行后端接口测试。Postman 和 Apifox 等 API 工具提供了出色的 WebSocket 测试支持。</p>
<ul>
<li><strong>核心优势：</strong><ul>
<li><strong>独立于前端：</strong> 无需编写任何前端代码，可以直接连接到 WebSocket 服务器，非常适合后端开发人员自测接口。</li>
<li><strong>强大的请求定制能力：</strong> 可以方便地设置 URL、自定义握手请求头（如 <code>Authorization</code> Token）、URL 参数等。</li>
<li><strong>保存和复用：</strong> 可以将 WebSocket 请求保存到集合中，方便团队协作和回归测试。</li>
<li><strong>清晰的消息流展示：</strong> 提供了独立的发送和接收消息面板，并且可以格式化显示 JSON 或其他格式。</li>
</ul>
</li>
<li><strong>使用方法 (以 Postman 为例):</strong><ol>
<li><strong>新建请求：</strong> 在 Postman 中，点击 “New”，然后选择 “WebSocket Request”。</li>
<li><strong>输入 URL：</strong> 在地址栏输入你的 WebSocket 端点 URL（例如 <code>ws://localhost:8080/ws</code>）。</li>
<li><strong>配置握手 (Handshake):</strong><ul>
<li>切换到 <strong>Headers</strong> 标签页。</li>
<li>添加必要的头信息，例如 <code>Authorization</code> <code>Bearer your-jwt-token</code>。</li>
</ul>
</li>
<li><strong>连接 (Connect):</strong> 点击 “Connect” 按钮。如果连接成功，下方会显示 “CONNECTED” 状态，并且 “Messages” 区域会被激活。</li>
<li><strong>发送&#x2F;接收消息 (Compose &amp; View):</strong><ul>
<li>在下方的 “Message” 输入框中编写你要发送的消息内容。</li>
<li>点击 “Send” 按钮。</li>
<li>你发送的消息和从服务器收到的消息都会按时间顺序显示在主窗口中，并用不同的颜色和图标区分方向。</li>
</ul>
</li>
<li><strong>断开连接 (Disconnect):</strong> 测试完成后，点击 “Disconnect” 关闭连接。</li>
</ol>
</li>
<li><strong>调试场景：</strong><ul>
<li><strong>后端接口测试：</strong> 在后端开发完一个 <code>@MessageMapping</code> 接口后，立即用 Postman&#x2F;Apifox 模拟客户端发送消息，验证接口逻辑是否正确，而不需要等待前端开发完成。</li>
<li><strong>异常场景模拟：</strong> 发送格式错误的消息、不合法的 STOMP 帧，测试服务器的异常处理能力 (<code>@MessageExceptionHandler</code>)。</li>
<li><strong>认证测试：</strong> 快速测试不同的 Token 或认证凭据是否能成功建立连接。</li>
<li><strong>性能&#x2F;压力测试：</strong> 某些工具的高级版本或插件支持编写脚本来模拟大量并发连接和消息，进行简单的压力测试。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><strong>浏览器开发者工具</strong> 是调试<strong>前端与后端集成</strong>时的首选，它真实反映了用户浏览器中的情况。</li>
<li><strong>Postman&#x2F;Apifox</strong> 则是<strong>后端开发和纯接口测试</strong>的利器，它将后端逻辑与前端界面完全解耦，让测试更纯粹、更高效。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/17/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/17/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">HTTP协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-17 16:09:23" itemprop="dateCreated datePublished" datetime="2025-10-17T16:09:23+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-20 12:15:14" itemprop="dateModified" datetime="2025-10-20T12:15:14+08:00">2025-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">Web协议与服务器</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、HTTP-基础入门"><a href="#一、HTTP-基础入门" class="headerlink" title="一、HTTP 基础入门"></a>一、HTTP 基础入门</h1><h2 id="1-什么是-HTTP？"><a href="#1-什么是-HTTP？" class="headerlink" title="1. 什么是 HTTP？"></a>1. 什么是 HTTP？</h2><h3 id="1-1-HTTP-的全称：HyperText-Transfer-Protocol"><a href="#1-1-HTTP-的全称：HyperText-Transfer-Protocol" class="headerlink" title="1.1 HTTP 的全称：HyperText Transfer Protocol"></a>1.1 HTTP 的全称：HyperText Transfer Protocol</h3><p>HTTP 的全称是 <strong>HyperText Transfer Protocol</strong>，即“<strong>超文本传输协议</strong>”。我们可以把这个名字拆开来理解：</p>
<ul>
<li><strong>HyperText (超文本)</strong><ul>
<li>它不仅仅是普通的纯文本。超文本指的是包含<strong>超链接 (Hyperlink)</strong> 的文本，可以从一个文本跳转到另一个文本或资源。</li>
<li>我们今天所说的“超文本”已经是一个广义的概念，它包括了网页中的所有内容，如：文字、图片、音频、视频、CSS 样式、JavaScript 脚本等。<strong>HTML (超文本标记语言)</strong> 是创建超文本最核心的语言。</li>
</ul>
</li>
<li><strong>Transfer (传输)</strong><ul>
<li>指将数据从一个地方搬运到另一个地方的过程。在 Web 中，通常是从<strong>服务器 (Server)</strong> 传输到<strong>客户端 (Client)</strong>。</li>
</ul>
</li>
<li><strong>Protocol (协议)</strong><ul>
<li>结合我们上面对协议的定义，它就是用来规范“超文本传输”这个过程的一整套规则。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>核心定义</strong>：将以上三部分组合起来，HTTP 的核心定义就非常清晰了：<strong>HTTP 是一个用于在万维网（World Wide Web）中，从 Web 服务器传输超文本资源到本地浏览器的传输协议。</strong></p>
</blockquote>
<p>简单来说，打开浏览器，输入一个网址（如 <code>www.google.com</code>）并按下回车时，浏览器就会使用 HTTP 协议，向谷歌的服务器发送一个“请求”，告诉它“我想要你的首页”；服务器收到请求后，同样使用 HTTP 协议，将首页的 HTML、CSS、图片等资源打包成一个“响应”，发送回浏览器。</p>
<hr>
<h3 id="1-2-HTTP-的诞生与使命：为-Web-而生"><a href="#1-2-HTTP-的诞生与使命：为-Web-而生" class="headerlink" title="1.2 HTTP 的诞生与使命：为 Web 而生"></a>1.2 HTTP 的诞生与使命：为 Web 而生</h3><p>HTTP 不是凭空出现的，它的诞生与<strong>万维网 (World Wide Web, WWW)</strong> 紧密相连。</p>
<ul>
<li><strong>背景</strong>：在 20 世纪 80 年代末，欧洲核子研究中心 (CERN) 的科学家们面临一个难题：研究资料和文档分散在世界各地不同的计算机上，查阅和分享极为不便。</li>
<li><strong>诞生</strong>：为了解决这个问题，英国科学家<strong>蒂姆·伯纳斯-李 (Tim Berners-Lee)</strong> 在 1989-1991 年间，发明了构建现代 Web 的三项核心技术：<ol>
<li><strong>HTML (HyperText Markup Language)</strong>：一种用于创建和组织网页内容的语言。</li>
<li><strong>URL (Uniform Resource Locator)</strong>：一种为互联网上每个资源提供唯一地址的方案，俗称“网址”。</li>
<li><strong>HTTP (HyperText Transfer Protocol)</strong>：一种用于获取这些资源的协议。</li>
</ol>
</li>
<li><strong>使命</strong>：<ul>
<li><strong>HTTP 的根本使命，就是作为万维网的信使和基石，实现全球范围内信息的自由流通和链接。</strong></li>
<li>它定义了一种简单、标准化的方式，让任何一个客户端（如浏览器）都可以向任何一个服务器请求任何一种资源（通过 URL 定位），并能正确地接收和解析它。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>总结一下</strong>：HTTP 的出现，使得“点击一个链接，就能跳转到另一个页面”这个革命性的想法得以实现。它就像是 Web 世界的快递系统，负责根据你提供的地址（URL），将你想要的包裹（HTML、图片等超文本资源）准确无误地送到你的手中（浏览器）。没有 HTTP，就没有我们今天丰富多彩的互联网世界。</p>
</blockquote>
<hr>
<h2 id="2-HTTP-在网络世界中的位置"><a href="#2-HTTP-在网络世界中的位置" class="headerlink" title="2. HTTP 在网络世界中的位置"></a>2. HTTP 在网络世界中的位置</h2><p>我们在Java第八章的网络编程中介绍了网络分层模型，HTTP 协议位于模型的最顶端——<strong>应用层</strong>。</p>
<hr>
<h3 id="2-1-应用层协议的角色"><a href="#2-1-应用层协议的角色" class="headerlink" title="2.1 应用层协议的角色"></a>2.1 应用层协议的角色</h3><p>现在我们知道 HTTP 位于最高层的应用层，那么它的具体角色是什么？</p>
<ol>
<li><strong>定义“业务语义”</strong>：应用层协议不关心数据如何可靠传输（那是 TCP 的事），也不关心数据如何跨网络路由（那是 IP 的事）。它只关心**“我们这次通信是要干什么”**。<ul>
<li>HTTP 定义了 <code>GET</code>（获取资源）、<code>POST</code>（提交数据）等方法，这就是在定义业务目的。</li>
<li>SMTP 定义了 <code>MAIL FROM</code>（发件人）、<code>RCPT TO</code>（收件人）等命令，这是在定义邮件投递的业务。</li>
</ul>
</li>
<li><strong>规定数据格式</strong>：应用层协议明确规定了应用程序之间交换的报文（Message）应该长什么样。<ul>
<li>HTTP 规定了请求必须包含“请求行、请求头、请求体”，响应必须包含“状态行、响应头、响应体”。</li>
</ul>
</li>
<li><strong>服务于最终用户</strong>：应用层是唯一直接与用户（或用户使用的软件）交互的层。你点击浏览器的一个链接，就是触发了一个 HTTP 应用层协议的动作。</li>
</ol>
<blockquote>
<p><strong>一句话总结</strong>：HTTP 作为应用层协议，其角色就是<strong>专注于定义“浏览器”和“Web服务器”这对应用程序之间如何沟通、交换“超文本文档”这件事</strong>，而将底层的网络传输细节完全委托给 TCP&#x2F;IP 协议栈去处理。</p>
</blockquote>
<hr>
<h3 id="2-2-HTTP-与-TCP、DNS-的关系：一次完整的网页请求过程"><a href="#2-2-HTTP-与-TCP、DNS-的关系：一次完整的网页请求过程" class="headerlink" title="2.2 HTTP 与 TCP、DNS 的关系：一次完整的网页请求过程"></a>2.2 HTTP 与 TCP、DNS 的关系：一次完整的网页请求过程</h3><p>这是理解 HTTP 在网络中位置的最佳实践。让我们以你在浏览器地址栏输入 <code>http://www.example.com</code> 并按回车为例，看看发生了什么：</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant 用户
    participant 浏览器
    participant DNS服务器
    participant Web服务器

    %% 1. 【应用层】DNS 解析
    rect rgb(240, 248, 255)
        note over 用户, Web服务器: 1. 【应用层】DNS 解析
        用户 -&gt;&gt; 浏览器: 输入 www.example.com
        浏览器 -&gt;&gt; DNS服务器: [DNS] 查询 www.example.com 的 IP 地址
        note over 浏览器, DNS服务器: DNS 就像互联网的“电话本”
        DNS服务器 --&gt;&gt; 浏览器: [DNS] 返回 IP 地址 93.184.216.34
    end

    %% 2. 【传输层】建立 TCP 连接
    rect rgb(230, 245, 230)
        note over 用户, Web服务器: 2. 【传输层】建立 TCP 连接 (三次握手)
        note over 浏览器, Web服务器: 拨通电话，确认对方在线
        浏览器 -&gt;&gt; Web服务器: [TCP] SYN (请求建立连接)
        Web服务器 --&gt;&gt; 浏览器: [TCP] SYN/ACK (同意并请求建立连接)
        浏览器 -&gt;&gt; Web服务器: [TCP] ACK (确认连接)
    end

    %% 3. 【应用层】发送 HTTP 请求
    rect rgb(255, 245, 230)
        note over 用户, Web服务器: 3. 【应用层】发送 HTTP 请求
        浏览器 -&gt;&gt; Web服务器: [HTTP] GET / HTTP/1.1
        note right of 浏览器: Host: www.example.com&lt;br/&gt;User-Agent: ...
    end

    %% 4. 【服务器】处理请求并发送 HTTP 响应
    rect rgb(255, 235, 235)
        note over 用户, Web服务器: 4. 服务器处理 &amp; 发送 HTTP 响应
        activate Web服务器
        note over Web服务器: 解析请求，找到 index.html
        Web服务器 --&gt;&gt; 浏览器: [HTTP] 200 OK 响应
        note left of Web服务器: Content-Type: text/html&lt;br/&gt;...&lt;br/&gt;&lt;!doctype html&gt;...
        deactivate Web服务器
    end
    
    %% 5. 【传输层】关闭 TCP 连接
    rect rgb(230, 245, 230)
        note over 用户, Web服务器: 5. 【传输层】关闭 TCP 连接 (可选)
        alt 连接保持 (Connection: keep-alive)
            note over 浏览器, Web服务器: 连接被复用，等待后续请求
        else 关闭连接 (四次挥手)
            浏览器 -&gt;&gt; Web服务器: [TCP] FIN (请求关闭)
            Web服务器 --&gt;&gt; 浏览器: [TCP] ACK (确认)
            Web服务器 --&gt;&gt; 浏览器: [TCP] FIN (请求关闭)
            浏览器 -&gt;&gt; Web服务器: [TCP] ACK (确认)
        end
    end

    %% 6. 【应用层】浏览器渲染
    rect rgb(240, 248, 255)
        note over 用户, Web服务器: 6. 【应用层】浏览器渲染
        activate 浏览器
        浏览器 -&gt;&gt; 用户: 显示五彩斑斓的网页
        note over 浏览器: 解析 HTML, 渲染页面
        deactivate 浏览器
        note right of 浏览器: 如有 CSS/JS/图片, &lt;br/&gt;会重复步骤 3-5 获取资源
    end</code></pre>

<ol>
<li><p><strong>【应用层】DNS 解析</strong>：</p>
<ul>
<li>浏览器首先看到的是 <code>www.example.com</code> 这个<strong>域名</strong>。但计算机网络通信需要的是 <strong>IP 地址</strong>（比如 <code>93.184.216.34</code>）。</li>
<li>浏览器会向 <strong>DNS</strong> 服务器发起一个查询请求（DNS 本身也是一个应用层协议），询问“<code>www.example.com</code> 的 IP 地址是什么？”</li>
<li>DNS 服务器回答：“是 <code>93.184.216.34</code>”。</li>
<li><strong>角色</strong>：<strong>DNS 就像是互联网的“电话本”</strong>，负责将人类易记的域名转换成机器使用的 IP 地址。</li>
</ul>
</li>
<li><p><strong>【传输层】建立 TCP 连接</strong>：</p>
<ul>
<li>浏览器现在拿到了 IP 地址。HTTP 协议默认使用 80 端口。</li>
<li>浏览器会通过操作系统的 TCP 协议栈，向服务器 <code>93.184.216.34</code> 的 <code>80</code> 端口发起一个 TCP 连接请求。</li>
<li>这个过程会经历著名的“<strong>三次握手</strong>”（SYN -&gt; SYN&#x2F;ACK -&gt; ACK），以确保双方都准备好通信，建立一条可靠的连接通道。</li>
<li><strong>角色</strong>：<strong>TCP 就像是“拨通了对方的电话”</strong>，并确认对方在线，随时可以开始通话。</li>
</ul>
</li>
<li><p><strong>【应用层】发送 HTTP 请求</strong>：</p>
<ul>
<li><p>TCP 连接建立成功后，浏览器就可以开始“说话”了。</p>
</li>
<li><p>浏览器会按照 HTTP 协议定义的格式，构建一个<strong>请求报文</strong>，例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器将这个报文通过刚才建立好的 TCP 连接发送给服务器。</p>
</li>
</ul>
</li>
<li><p><strong>【服务器】处理请求并发送 HTTP 响应</strong>：</p>
<ul>
<li><p>Web 服务器在 <code>80</code> 端口上一直监听着。当它收到这个 HTTP 请求报文后，会进行解析。</p>
</li>
<li><p>服务器发现客户端想要根目录 <code>/</code> 的资源，于是找到对应的 <code>index.html</code> 文件，并准备一个<strong>响应报文</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1256</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span>...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器将这个响应报文通过 TCP 连接发回给浏览器。</p>
</li>
</ul>
</li>
<li><p><strong>【传输层】关闭 TCP 连接</strong>：</p>
<ul>
<li>浏览器接收完所有响应数据后，根据 HTTP 头部（如 <code>Connection: keep-alive</code>）的指示，决定是保持连接以便后续请求复用，还是通过“<strong>四次挥手</strong>”关闭这条 TCP 连接。</li>
</ul>
</li>
<li><p><strong>【应用层】浏览器渲染</strong>：</p>
<ul>
<li>浏览器收到响应报文，解析其中的 HTML 内容，并将其渲染成你看到的五彩斑斓的网页。如果 HTML 中还引用了其他资源（如 CSS 文件、图片），浏览器会<strong>重复上述过程</strong>（从第2步或第3步开始）去获取这些资源。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-HTTP-的核心特点"><a href="#3-HTTP-的核心特点" class="headerlink" title="3. HTTP 的核心特点"></a>3. HTTP 的核心特点</h2><h3 id="3-1-C-S-架构"><a href="#3-1-C-S-架构" class="headerlink" title="3.1 C&#x2F;S 架构"></a>3.1 C&#x2F;S 架构</h3><p>这是 HTTP 最基本的运作模型。</p>
<ul>
<li><strong>定义</strong>：<br>在 HTTP 通信中，角色被明确地划分为两方：<ol>
<li><strong>客户端 (Client)</strong>：发起请求的一方。它主动向服务器请求资源。我们日常使用的网页浏览器 (Chrome, Firefox)、手机 App、或者命令行工具 cURL 都属于客户端。</li>
<li><strong>服务器 (Server)</strong>：接收请求并提供响应的一方。它被动地等待客户端的请求，并根据请求内容返回相应的资源（如 HTML 页面、图片、数据等）。常见的 Web 服务器有 Apache, Nginx, Tomcat 等。</li>
</ol>
</li>
<li><strong>通信流程</strong>：<ol>
<li>通信总是由<strong>客户端</strong>发起。</li>
<li>服务器<strong>不能</strong>主动向客户端推送信息。（<em>注：这在传统 HTTP 模型中是成立的，像 WebSocket、Server-Sent Events 等技术是为了突破这一限制而出现的</em>）。</li>
<li>一次完整的交互是“客户端请求 -&gt; 服务器响应”的循环。</li>
</ol>
</li>
<li><strong>意义</strong>：<br>这种职责分离的模式极大地促进了 Web 的发展。客户端和服务器可以独立发展和演进，只要它们都遵守 HTTP 这套共同的协议。服务器可以专注于提供高性能、高可用的服务；而客户端则可以专注于提供丰富的用户界面和交互体验。</li>
</ul>
<hr>
<h3 id="3-2-简单可扩展"><a href="#3-2-简单可扩展" class="headerlink" title="3.2 简单可扩展"></a>3.2 简单可扩展</h3><p>这是 HTTP 能够长盛不衰、适应时代变化的关键。</p>
<ul>
<li><strong>简单 (Simple)</strong>：<ul>
<li>HTTP&#x2F;1.1 及之前的版本，其报文（请求和响应）是<strong>人类可读的纯文本</strong>。</li>
<li>其基本结构非常简单，由“起始行 + 头部 + 空行 + 实体”构成。这种简洁性使得早期开发者很容易实现和调试 HTTP 客户端与服务器。</li>
<li>例如，一个最简单的 <code>GET</code> 请求可以手动通过 <code>telnet</code> 工具打出来，非常直观。</li>
</ul>
</li>
<li><strong>可扩展 (Extensible)</strong>：<ul>
<li>这是 HTTP 最强大的特性。HTTP 协议的核心只定义了基本的框架（如请求方法、URL、状态码），但通过<strong>HTTP 头部 (Headers)</strong>，它可以被无限扩展。</li>
<li>头部是 <code>Key: Value</code> 格式的键值对，允许客户端和服务器之间传递任意的元数据。</li>
<li>当需要增加新功能时，通常只需要<strong>定义一个新的头部字段</strong>即可，而无需改变协议的整体结构。</li>
</ul>
</li>
<li><strong>例子</strong>：<ul>
<li>为了解决“无状态”问题，引入了 <code>Cookie</code> 和 <code>Set-Cookie</code> 头部。</li>
<li>为了提高性能，引入了 <code>Cache-Control</code> 头部用于缓存控制，引入了 <code>Content-Encoding</code> 头部用于数据压缩。</li>
<li>为了增强安全性，引入了 <code>Content-Security-Policy</code>, <code>Strict-Transport-Security</code> 等安全相关的头部。</li>
<li>开发者甚至可以自定义以 <code>X-</code> 开头的头部（现在已不推荐，可以直接使用自定义名称）来传递应用特定的信息。</li>
</ul>
</li>
<li><strong>意义</strong>：<br>可扩展性使得 HTTP 可以根据不断出现的新需求（如身份验证、缓存、数据压缩、安全策略等）添加新的头部，从而在 30 多年的发展中保持了强大的生命力。</li>
</ul>
<hr>
<h3 id="3-3-无状态"><a href="#3-3-无状态" class="headerlink" title="3.3 无状态"></a>3.3 无状态</h3><p>这个特点既是优点也是“缺点”，深刻影响了 Web 应用的开发模式。</p>
<ul>
<li><strong>定义</strong>：<br>“无状态”指的是<strong>协议本身对于事务处理没有记忆能力</strong>。每一次 HTTP 请求都是完全独立的，服务器不会保留前一次请求的任何信息。<ul>
<li>换句话说，服务器处理完一个请求并发送响应后，它就<strong>完全忘记了</strong>与这个客户端之间发生过的一切。</li>
<li>当同一个客户端再次发送请求时，服务器无法知道它就是刚才那个客户端。</li>
</ul>
</li>
<li><strong>类比</strong>：<br>可以想象成<strong>与一个记忆只有七秒的鱼对话</strong>。<ol>
<li>你问它：“你好吗？” 它回答：“我很好。” 然后它就忘了你。</li>
<li>你接着问：“我叫什么名字？” 它无法回答，因为它不记得你刚刚跟它打过招呼。</li>
<li>如果你想让它记住你，你必须在每次提问时都重新自我介绍：“你好，我叫小明。我叫什么名字？”</li>
</ol>
</li>
<li><strong>优点 (Scalability)</strong>：<ul>
<li><strong>简化服务器设计</strong>：服务器不需要花费额外的资源（如内存）来存储海量的客户端状态信息。</li>
<li><strong>提升服务器的可伸缩性</strong>：由于服务器不存储状态，任何一台服务器都可以处理任何一个客户端的请求。这使得在服务器集群中做<strong>负载均衡</strong>变得非常容易。如果一台服务器宕机，请求可以无缝切换到另一台，因为新服务器不需要任何历史上下文。</li>
</ul>
</li>
<li><strong>缺点与解决方案</strong>：<ul>
<li><strong>功能受限</strong>：然而，现代 Web 应用（如购物车、用户登录）恰恰需要“记住状态”。</li>
<li><strong>解决方案</strong>：为了弥补 HTTP 的无状态性，Web 应用通过<strong>Cookie 和 Session 机制</strong>来“创造”状态。<ul>
<li><strong>Cookie</strong>: 服务器通过 <code>Set-Cookie</code> 响应头给客户端一个“通行证”（一小段文本）。</li>
<li>之后，客户端在每次请求时都会通过 <code>Cookie</code> 请求头带上这个“通行证”。</li>
<li>服务器通过检查这个“通行证”就能识别出用户，从而维持登录状态或购物车内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-4-可靠传输"><a href="#3-4-可靠传输" class="headerlink" title="3.4 可靠传输"></a>3.4 可靠传输</h3><p>HTTP 本身不负责传输的可靠性，它“站在了巨人的肩膀上”。</p>
<ul>
<li><strong>定义</strong>：<br>HTTP 协议通常是构建在<strong>传输层的 TCP 协议</strong>之上的。TCP 是一个<strong>可靠的</strong>传输协议，它为 HTTP 提供了以下保障：<ol>
<li><strong>数据完整性</strong>：通过校验和机制，确保数据在传输过程中没有损坏。</li>
<li><strong>按序到达</strong>：确保数据包能够按照发送的顺序被接收端正确地重组。</li>
<li><strong>无丢失</strong>：通过确认和重传机制，确保所有发送的数据都能到达目的地。</li>
</ol>
</li>
<li><strong>类比</strong>：<br>HTTP 协议就像是<strong>写信的人</strong>，他只负责写信的内容（请求报文&#x2F;响应报文）。而 TCP 协议就像是一个<strong>非常靠谱的邮政系统</strong>。<ul>
<li>写信的人（HTTP）把信交给邮局（TCP），就完全不用担心信件会不会寄丢、会不会被撕坏、或者信件页码会不会乱掉。</li>
<li>邮政系统（TCP）会负责安全、完整、按顺序地把信送到收件人手中。</li>
</ul>
</li>
<li><strong>意义</strong>：<br>将可靠传输的任务委托给下层的 TCP，极大地简化了 HTTP 协议的设计。HTTP 的设计者可以专注于应用层面的逻辑，即如何定义和交换超文本文档，而无需处理复杂的网络传输问题。</li>
<li><strong>演进</strong>：<br>最新的 <strong>HTTP&#x2F;3 协议改为使用 QUIC 协议</strong>，而 QUIC 是基于 UDP（一个不可靠协议）构建的。但 QUIC 协议自身内部实现了类似 TCP 的可靠性、流量控制等功能，因此，从应用层的角度看，HTTP&#x2F;3 依然享受着可靠传输的保障。</li>
</ul>
<hr>
<h1 id="二、HTTP-报文结构详解"><a href="#二、HTTP-报文结构详解" class="headerlink" title="二、HTTP 报文结构详解"></a>二、HTTP 报文结构详解</h1><h2 id="1-请求报文-Request-Message"><a href="#1-请求报文-Request-Message" class="headerlink" title="1. 请求报文 (Request Message)"></a>1. 请求报文 (Request Message)</h2><p>当客户端（如浏览器）想要从服务器获取资源或向其提交数据时，它会构造并发送一个<strong>请求报文</strong>。这个报文就像一封格式化的信件，详细说明了客户端的意图。</p>
<p>一个完整的 HTTP 请求报文由三部分组成：<strong>请求行 (Request Line)</strong>、<strong>请求头 (Request Headers)</strong> 和 <strong>请求体 (Request Body)</strong>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-target&gt; &lt;http-version&gt;  \r\n   &lt;-- 请求行</span><br><span class="line">&lt;header-key1&gt;: &lt;header-value1&gt;             \r\n   &lt;-- 请求头</span><br><span class="line">&lt;header-key2&gt;: &lt;header-value2&gt;             \r\n</span><br><span class="line">...</span><br><span class="line">&lt;header-keyN&gt;: &lt;header-valueN&gt;             \r\n</span><br><span class="line">                                          \r\n   &lt;-- 标志头部结束的空行</span><br><span class="line">&lt;request-body-data&gt;                              &lt;-- 请求体 (可选)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：每一行的末尾都有一个回车换行符 <code>\r\n</code> (CRLF)，并且头部区域和请求体之间必须有一个<strong>空行</strong> (<code>\r\n</code>)。这个空行是强制性的，用来区分头部和主体。</p>
<hr>
<h3 id="1-1-请求行-Request-Line"><a href="#1-1-请求行-Request-Line" class="headerlink" title="1.1 请求行 (Request Line)"></a>1.1 请求行 (Request Line)</h3><p>请求行是请求报文的<strong>第一行</strong>，永远位于最开始，它简明扼要地概括了本次请求的核心信息。它由三个部分组成，以空格分隔。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>请求方法 (Method)</strong><ul>
<li><strong>作用</strong>：表明客户端希望对资源执行的操作。</li>
<li><strong>示例</strong>：<code>GET</code></li>
<li><strong>常见方法</strong>：<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>HEAD</code>, <code>OPTIONS</code> 等。<ul>
<li><code>GET</code>: 获取资源。</li>
<li><code>POST</code>: 创建或提交数据。</li>
</ul>
</li>
<li>方法是大小写敏感的，通常使用大写。</li>
</ul>
</li>
<li><strong>请求目标 (Request Target &#x2F; URI)</strong><ul>
<li><strong>作用</strong>：指定了所请求资源的位置，通常是 URL 的路径和查询参数部分。</li>
<li><strong>示例</strong>：<code>/index.html</code></li>
<li><strong>不同形式</strong>：<ul>
<li><strong>源格式 (origin-form)</strong>：最常见的形式，只包含路径和查询字符串。例如 <code>/path/to/file.html?key=value</code>。这是发送给源服务器的标准形式。</li>
<li><strong>绝对格式 (absolute-form)</strong>：包含完整的 URL。主要在请求代理服务器时使用，例如 <code>GET http://www.example.com/index.html HTTP/1.1</code>。</li>
<li><strong>星号格式 (asterisk-form)</strong>：一个星号 <code>*</code>，用于 <code>OPTIONS</code> 方法，询问服务器的整体能力，而不是特定资源。</li>
</ul>
</li>
</ul>
</li>
<li><strong>HTTP 版本 (Version)</strong><ul>
<li><strong>作用</strong>：指明客户端使用的 HTTP 协议版本。</li>
<li><strong>示例</strong>：<code>HTTP/1.1</code></li>
<li>服务器会根据这个版本来决定如何处理请求以及使用哪个版本的协议进行响应。常见的有 <code>HTTP/1.0</code>, <code>HTTP/1.1</code>, <code>HTTP/2</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-请求头-Request-Headers"><a href="#1-2-请求头-Request-Headers" class="headerlink" title="1.2 请求头 (Request Headers)"></a>1.2 请求头 (Request Headers)</h3><p>请求头紧跟在请求行之后，由一系列的键值对 (<code>Key: Value</code>) 组成，每对占一行。它们向服务器提供了关于请求的更多上下文信息，例如客户端的类型、期望接收的数据格式等。</p>
<p>请求头可以分为几类（这是一个概念上的划分，实际报文中它们混在一起）：</p>
<ul>
<li><strong>通用头 (General Headers)</strong>：请求和响应报文中都可以出现，如 <code>Date</code>, <code>Connection</code>。</li>
<li><strong>请求头 (Request Headers)</strong>：专用于请求报文，包含更多关于要获取的资源或客户端本身的信息，如 <code>Host</code>, <code>User-Agent</code>, <code>Accept</code>。</li>
<li><strong>实体头 (Entity Headers)</strong>：描述请求体（或响应体）的元数据，如 <code>Content-Type</code>, <code>Content-Length</code>。</li>
</ul>
<p><strong>常用请求头详解：</strong></p>
<table>
<thead>
<tr>
<th>头部 (Header)</th>
<th>示例值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Host</code></strong></td>
<td><code>www.example.com</code></td>
<td><strong>HTTP&#x2F;1.1 必需</strong>。指定了服务器的域名。这使得一台服务器可以托管多个网站（虚拟主机）。</td>
</tr>
<tr>
<td><strong><code>User-Agent</code></strong></td>
<td><code>Mozilla/5.0 (Windows NT 10.0; ...)</code></td>
<td>包含了发起请求的客户端（浏览器、爬虫等）的信息。服务器可以据此返回不同的内容或进行统计。</td>
</tr>
<tr>
<td><strong><code>Accept</code></strong></td>
<td><code>text/html,application/xhtml+xml,...</code></td>
<td>告诉服务器客户端能够理解和处理的内容类型（MIME 类型）。服务器会据此进行内容协商。</td>
</tr>
<tr>
<td><strong><code>Accept-Language</code></strong></td>
<td><code>en-US,en;q=0.9,zh-CN;q=0.8</code></td>
<td>告诉服务器客户端偏好的自然语言。<code>q</code> 是权重因子，表示偏好程度。</td>
</tr>
<tr>
<td><strong><code>Accept-Encoding</code></strong></td>
<td><code>gzip, deflate, br</code></td>
<td>告诉服务器客户端支持的内容压缩算法。服务器可以使用其中一种算法压缩响应体，以减少传输大小。</td>
</tr>
<tr>
<td><strong><code>Connection</code></strong></td>
<td><code>keep-alive</code> &#x2F; <code>close</code></td>
<td>控制 TCP 连接在请求完成后是否保持打开状态。<code>keep-alive</code> 表示长连接，<code>close</code> 表示短连接。</td>
</tr>
<tr>
<td><strong><code>Content-Type</code></strong></td>
<td><code>application/json</code></td>
<td><strong>当有请求体时非常重要</strong>。说明请求体中的数据格式。</td>
</tr>
<tr>
<td><strong><code>Content-Length</code></strong></td>
<td><code>348</code></td>
<td><strong>当有请求体时非常重要</strong>。表示请求体的字节长度。</td>
</tr>
<tr>
<td><strong><code>Cookie</code></strong></td>
<td><code>name=value; name2=value2</code></td>
<td>客户端向服务器发送之前由服务器通过 <code>Set-Cookie</code> 设置的 Cookie。用于维持用户状态。</td>
</tr>
<tr>
<td><strong><code>Referer</code></strong></td>
<td><code>https://www.google.com/</code></td>
<td>表示当前请求是从哪个页面跳转过来的。可用于分析用户来源。注意：单词拼写错误 <code>Referer</code> 是历史遗留问题。</td>
</tr>
<tr>
<td><strong><code>Authorization</code></strong></td>
<td><code>Bearer &lt;token&gt;</code></td>
<td>包含了用于身份验证的凭证信息。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-请求体-Request-Body"><a href="#1-3-请求体-Request-Body" class="headerlink" title="1.3 请求体 (Request Body)"></a>1.3 请求体 (Request Body)</h3><p>请求体是<strong>可选的</strong>。它用于承载需要提交给服务器的数据。</p>
<ul>
<li><strong>什么情况下会有请求体？</strong><ul>
<li><code>GET</code>, <code>HEAD</code>, <code>DELETE</code>, <code>OPTIONS</code> 等方法通常<strong>没有</strong>请求体，因为它们的操作目标由 URL 指定。</li>
<li><code>POST</code>, <code>PUT</code>, <code>PATCH</code> 等方法通常<strong>有</strong>请求体，因为它们需要向服务器发送数据（如创建新用户、更新文章内容等）。</li>
</ul>
</li>
<li><strong>常见的数据格式 (由 <code>Content-Type</code> 头部指定)：</strong><ol>
<li><strong><code>application/x-www-form-urlencoded</code></strong><ul>
<li>这是 HTML 表单提交的默认格式。</li>
<li>数据被编码成 <code>key1=value1&amp;key2=value2</code> 的形式，和 URL 查询参数的格式一样。</li>
<li>特殊字符（如空格）会被 URL 编码（空格变为 <code>+</code> 或 <code>%20</code>）。</li>
</ul>
</li>
<li><strong><code>multipart/form-data</code></strong><ul>
<li>当表单中包含文件上传（<code>&lt;input type=&quot;file&quot;&gt;</code>）时，必须使用这种格式。</li>
<li>它将表单数据分割成多个部分（part），每个部分都有自己的描述头。这种格式可以同时传输文本数据和二进制文件数据。</li>
<li>请求体会包含一个 <code>boundary</code> 字符串，用于分隔不同的数据部分。</li>
</ul>
</li>
<li><strong><code>application/json</code></strong><ul>
<li>现代 Web API（尤其是 RESTful API）最常用的格式。</li>
<li>请求体是一个 JSON 格式的字符串。</li>
<li>例如：<code>{&quot;username&quot;: &quot;alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;}</code></li>
</ul>
</li>
<li><strong><code>text/xml</code> 或 <code>application/xml</code></strong><ul>
<li>用于传输 XML 格式的数据，在早期的 Web Services (SOAP) 中很常见。</li>
</ul>
</li>
<li><strong><code>text/plain</code></strong><ul>
<li>纯文本格式。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>请求报文示例 (一个典型的 POST 请求)</strong></p>
<p>这个例子模拟了一个用户登录的场景，提交的数据是 JSON 格式。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/api/login</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>54</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>MyCoolApiClient/1.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"></span><br><span class="line"><span class="language-json"><span class="punctuation">&#123;</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;testuser&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SuperSecret123&quot;</span><span class="punctuation">&#125;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>请求行</strong>: <code>POST /api/login HTTP/1.1</code> -&gt; 使用 POST 方法，请求 <code>/api/login</code> 资源，协议版本是 HTTP&#x2F;1.1。</li>
<li><strong>请求头</strong>:<ul>
<li><code>Host</code>: 目标服务器是 <code>api.example.com</code>。</li>
<li><code>Content-Type</code>: 告诉服务器，我发送的数据是 JSON 格式。</li>
<li><code>Content-Length</code>: 告诉服务器，请求体的大小是 54 字节。</li>
<li>其他头部提供了客户端信息和期望的响应格式。</li>
</ul>
</li>
<li><strong>空行</strong>: 分隔头部和主体。</li>
<li><strong>请求体</strong>: 包含了实际的登录凭证，是一个 JSON 对象。</li>
</ul>
<hr>
<h2 id="2-响应报文-Response-Message"><a href="#2-响应报文-Response-Message" class="headerlink" title="2. 响应报文 (Response Message)"></a>2. 响应报文 (Response Message)</h2><p>当服务器成功接收并处理了客户端的请求后，它会构建并发送一个<strong>响应报文</strong>。这个报文包含了请求的处理结果（成功、失败、重定向等）以及客户端请求的资源（如果适用）。</p>
<p>与请求报文类似，一个 HTTP 响应报文也由三部分组成：<strong>状态行 (Status Line)</strong>、<strong>响应头 (Response Headers)</strong> 和 <strong>响应体 (Response Body)</strong>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;http-version&gt; &lt;status-code&gt; &lt;reason-phrase&gt; \r\n   &lt;-- 状态行</span><br><span class="line">&lt;header-key1&gt;: &lt;header-value1&gt;              \r\n   &lt;-- 响应头</span><br><span class="line">&lt;header-key2&gt;: &lt;header-value2&gt;              \r\n</span><br><span class="line">...</span><br><span class="line">&lt;header-keyN&gt;: &lt;header-valueN&gt;              \r\n</span><br><span class="line">                                           \r\n   &lt;-- 标志头部结束的空行</span><br><span class="line">&lt;response-body-data&gt;                               &lt;-- 响应体 (可选)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-1-状态行-Status-Line"><a href="#2-1-状态行-Status-Line" class="headerlink" title="2.1 状态行 (Status Line)"></a>2.1 状态行 (Status Line)</h3><p>状态行是响应报文的<strong>第一行</strong>，它用最简洁的方式总结了服务器对请求的处理结果。它也由三个部分组成，以空格分隔。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>HTTP 版本 (Version)</strong><ul>
<li><strong>作用</strong>：指明服务器使用的 HTTP 协议版本。通常与客户端请求的版本相匹配。</li>
<li><strong>示例</strong>：<code>HTTP/1.1</code></li>
</ul>
</li>
<li><strong>状态码 (Status Code)</strong><ul>
<li><strong>作用</strong>：这是一个<strong>三位数的数字</strong>，是响应报文中最核心的部分。它用标准化的代码告诉客户端请求的结果。</li>
<li><strong>示例</strong>：<code>200</code></li>
<li>状态码按其第一位数字分为五大类，每一类代表一种响应状态（我们将在第三章详细讲解）：<ul>
<li><strong>1xx</strong>: 信息性 - 请求已接收，正在处理。</li>
<li><strong>2xx</strong>: 成功 - 请求已成功被接收、理解、并接受。</li>
<li><strong>3xx</strong>: 重定向 - 需要采取进一步操作才能完成请求。</li>
<li><strong>4xx</strong>: 客户端错误 - 请求有语法错误或无法实现。</li>
<li><strong>5xx</strong>: 服务器错误 - 服务器未能实现合法的请求。</li>
</ul>
</li>
</ul>
</li>
<li><strong>原因短语 (Reason Phrase)</strong><ul>
<li><strong>作用</strong>：这是对状态码的一个简短的、人类可读的文本描述。</li>
<li><strong>示例</strong>：<code>OK</code></li>
<li>原因短语的主要目的是为了方便人类阅读和调试，<strong>程序不应该依赖原因短语来判断结果</strong>，而应严格依赖状态码。例如，即使服务器返回 <code>HTTP/1.1 200 All is well</code>，客户端也应将其视为 <code>200 OK</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-2-响应头-Response-Headers"><a href="#2-2-响应头-Response-Headers" class="headerlink" title="2.2 响应头 (Response Headers)"></a>2.2 响应头 (Response Headers)</h3><p>响应头紧跟在状态行之后，同样是一系列的键值对 (<code>Key: Value</code>)。它们提供了关于响应的更多信息，例如响应内容的类型、长度、服务器信息、缓存策略等。</p>
<p><strong>常用响应头详解：</strong></p>
<table>
<thead>
<tr>
<th>头部 (Header)</th>
<th>示例值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Content-Type</code></strong></td>
<td><code>text/html; charset=utf-8</code></td>
<td><strong>极其重要</strong>。告诉客户端响应体中的数据是什么类型（MIME 类型），以及其字符编码。浏览器据此决定如何渲染内容。</td>
</tr>
<tr>
<td><strong><code>Content-Length</code></strong></td>
<td><code>1256</code></td>
<td>表示响应体的字节长度。浏览器可以据此判断响应是否已接收完整。对于长连接，这是区分报文边界的关键。</td>
</tr>
<tr>
<td><strong><code>Content-Encoding</code></strong></td>
<td><code>gzip</code></td>
<td>表明响应体使用了哪种压缩算法（如 <code>gzip</code>, <code>br</code>）。浏览器收到后需要先解压缩，才能得到原始数据。</td>
</tr>
<tr>
<td><strong><code>Server</code></strong></td>
<td><code>nginx/1.18.0</code></td>
<td>包含了处理请求的 Web 服务器软件的信息。出于安全考虑，有些服务器会隐藏或修改此信息。</td>
</tr>
<tr>
<td><strong><code>Date</code></strong></td>
<td><code>Wed, 21 Oct 2023 07:28:00 GMT</code></td>
<td>服务器生成并发送该响应的日期和时间（格林尼治标准时间）。</td>
</tr>
<tr>
<td><strong><code>Location</code></strong></td>
<td><code>https://www.example.com/new-page</code></td>
<td><strong>在 3xx 重定向响应中必需</strong>。告诉客户端应该自动跳转到这个新的 URL 去获取资源。</td>
</tr>
<tr>
<td><strong><code>Set-Cookie</code></strong></td>
<td><code>session_id=abcde12345; HttpOnly; Secure</code></td>
<td>指示客户端保存一个 Cookie。浏览器会在后续对该域名的请求中自动带上这个 Cookie。</td>
</tr>
<tr>
<td><strong><code>Cache-Control</code></strong></td>
<td><code>max-age=3600</code></td>
<td>指示客户端和代理服务器如何缓存此响应。<code>max-age=3600</code> 表示此响应可以被缓存 3600 秒。</td>
</tr>
<tr>
<td><strong><code>Expires</code></strong></td>
<td><code>Wed, 21 Oct 2023 08:28:00 GMT</code></td>
<td>(HTTP&#x2F;1.0) 提供一个绝对的过期时间，作用与 <code>Cache-Control</code> 类似，但优先级较低。</td>
</tr>
<tr>
<td><strong><code>ETag</code></strong></td>
<td><code>W/&quot;xyz...abc&quot;</code></td>
<td>资源的唯一标识符，像文件的“指纹”。用于协商缓存。</td>
</tr>
<tr>
<td><strong><code>Last-Modified</code></strong></td>
<td><code>Tue, 15 Nov 2022 12:45:26 GMT</code></td>
<td>资源在服务器上最后被修改的时间。也用于协商缓存。</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-3-响应体-Response-Body"><a href="#2-3-响应体-Response-Body" class="headerlink" title="2.3 响应体 (Response Body)"></a>2.3 响应体 (Response Body)</h3><p>响应体是响应报文的<strong>可选</strong>部分，包含了服务器返回给客户端的实际资源内容。</p>
<ul>
<li><strong>什么情况下会有响应体？</strong><ul>
<li>对于成功的 <code>GET</code> 请求，响应体通常就是请求的资源本身，如 HTML 文档、图片文件、JSON 数据等。</li>
<li>对于成功的 <code>POST</code> 请求，响应体可能包含了操作成功后的结果信息，比如新建资源的信息。</li>
</ul>
</li>
<li><strong>什么情况下可能没有响应体？</strong><ul>
<li><strong><code>204 No Content</code></strong>: 请求成功，但服务器没有新的信息要发送，响应中不包含响应体。</li>
<li><strong><code>301 Moved Permanently</code> &#x2F; <code>302 Found</code></strong>: 重定向响应，客户端的关注点是 <code>Location</code> 头，通常不需要响应体。</li>
<li><strong><code>304 Not Modified</code></strong>: 协商缓存命中，告诉客户端可以使用本地缓存的副本，因此不需要再次发送资源，响应中没有响应体。</li>
<li><strong><code>HEAD</code> 请求</strong>：客户端只请求资源的元信息（头部），服务器的响应与 <code>GET</code> 请求完全相同，但<strong>没有响应体</strong>。</li>
</ul>
</li>
</ul>
<p><strong>响应报文示例 (一个典型的成功响应)</strong></p>
<p>这个例子是对一个 <code>GET</code> 请求的响应，返回了一个 HTML 页面。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1354</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Wed, 21 Oct 2023 07:30:00 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.4.1 (Unix)</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=600</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>An Example Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World, this is a very simple HTML document.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>状态行</strong>: <code>HTTP/1.1 200 OK</code> -&gt; 表示请求成功。</li>
<li><strong>响应头</strong>:<ul>
<li><code>Content-Type</code>: 告诉浏览器，下面发送的是一个 UTF-8 编码的 HTML 文档。</li>
<li><code>Content-Length</code>: 浏览器可以预期接收 1354 字节的 HTML 内容。</li>
<li>其他头部提供了服务器信息、时间和缓存指令。</li>
</ul>
</li>
<li><strong>空行</strong>: 分隔头部和主体。</li>
<li><strong>响应体</strong>: 包含了完整的 HTML 文档内容，浏览器将解析并渲染它。</li>
</ul>
<hr>
<h1 id="三、HTTP-请求方法与状态码"><a href="#三、HTTP-请求方法与状态码" class="headerlink" title="三、HTTP 请求方法与状态码"></a>三、HTTP 请求方法与状态码</h1><h2 id="1-请求方法-Methods"><a href="#1-请求方法-Methods" class="headerlink" title="1. 请求方法 (Methods)"></a>1. 请求方法 (Methods)</h2><p>HTTP 请求方法，也常被称为“HTTP 动词 (Verbs)”，是位于请求行开头的命令。它告诉服务器，客户端期望执行的具体操作类型。可以将其理解为一句话中的“动词”，指定了对“宾语”（即 URL 所指向的资源）的行为。</p>
<hr>
<h3 id="1-1-GET-获取资源"><a href="#1-1-GET-获取资源" class="headerlink" title="1.1 GET: 获取资源"></a>1.1 GET: 获取资源</h3><ul>
<li><p><strong>核心作用</strong>：从服务器<strong>获取 (Retrieve)</strong> 指定的资源。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li><code>GET</code> 请求<strong>不应包含请求体 (Request Body)</strong>，需要传递的参数通常附加在 URL 的查询字符串 (Query String) 中（例如 <code>?id=123</code>）。</li>
<li>它是<strong>安全的 (Safe)</strong> 和<strong>幂等的 (Idempotent)</strong>。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>浏览网页。</li>
<li>查看文章、商品详情。</li>
<li>请求图片、CSS、JavaScript 文件。</li>
<li>调用一个只返回数据的 API。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/users/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br></pre></td></tr></table></figure>

<p>这个请求意图是获取 ID 为 123 的用户的信息。</p>
</li>
</ul>
<hr>
<h3 id="1-2-POST-创建-提交资源"><a href="#1-2-POST-创建-提交资源" class="headerlink" title="1.2 POST: 创建&#x2F;提交资源"></a>1.2 POST: 创建&#x2F;提交资源</h3><ul>
<li><p><strong>核心作用</strong>：向服务器<strong>提交 (Submit)</strong> 数据，请求服务器进行处理，这可能导致<strong>创建新资源</strong>或<strong>更新现有资源</strong>。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li><code>POST</code> 请求<strong>通常包含请求体</strong>，用于携带要提交的数据。</li>
<li>它是<strong>不安全的 (Not Safe)</strong>，因为它会改变服务器上的状态（例如，在数据库中创建一条新记录）。</li>
<li>它<strong>不是幂等的 (Not Idempotent)</strong>。连续发送两次相同的 <code>POST</code> 请求，通常会导致创建两个不同的资源。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>用户注册、登录。</li>
<li>提交表单数据（如发布评论、创建文章）。</li>
<li>下订单。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/users</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line"><span class="language-perl">&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;email&quot;</span>: <span class="string">&quot;alice<span class="variable">@example</span>.com&quot;</span>&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个请求意图是在服务器上创建一个新用户。</p>
</li>
</ul>
<hr>
<h3 id="1-3-PUT-完整更新资源"><a href="#1-3-PUT-完整更新资源" class="headerlink" title="1.3 PUT: 完整更新资源"></a>1.3 PUT: 完整更新资源</h3><ul>
<li><p><strong>核心作用</strong>：用请求体中的数据<strong>替换 (Replace)</strong> 目标资源的所有当前表示。可以理解为“<strong>整体覆盖</strong>”。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li><code>PUT</code> 请求<strong>必须包含请求体</strong>，代表了该资源的最终完整状态。</li>
<li>它是<strong>不安全的</strong>，因为它会修改资源。</li>
<li>它<strong>是幂等的</strong>。多次发送同一个 <code>PUT</code> 请求，其效果与发送一次完全相同（最终资源的状态是一样的）。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>更新一个用户的完整个人资料。</li>
<li>替换一篇文章的全部内容。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/users/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line"><span class="language-perl">&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice Smith&quot;</span>, <span class="string">&quot;email&quot;</span>: <span class="string">&quot;alice.smith<span class="variable">@example</span>.com&quot;</span>&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个请求意图是将 ID 为 123 的用户的全部信息替换为请求体中的新信息。</p>
</li>
</ul>
<hr>
<h3 id="1-4-DELETE-删除资源"><a href="#1-4-DELETE-删除资源" class="headerlink" title="1.4 DELETE: 删除资源"></a>1.4 DELETE: 删除资源</h3><ul>
<li><p><strong>核心作用</strong>：<strong>删除 (Delete)</strong> 指定的资源。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li><code>DELETE</code> 请求通常<strong>不包含请求体</strong>。</li>
<li>它是<strong>不安全的</strong>，因为它会删除资源。</li>
<li>它<strong>是幂等的</strong>。删除一个已删除的资源，其最终状态（不存在）与第一次删除时相同。服务器可能会返回 <code>404 Not Found</code> 或 <code>204 No Content</code>。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>删除一篇文章。</li>
<li>删除用户的某个地址。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="string">/users/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br></pre></td></tr></table></figure>

<p>这个请求意图是删除 ID 为 123 的用户。</p>
</li>
</ul>
<hr>
<h3 id="1-5-HEAD-获取资源的元信息"><a href="#1-5-HEAD-获取资源的元信息" class="headerlink" title="1.5 HEAD: 获取资源的元信息"></a>1.5 HEAD: 获取资源的元信息</h3><ul>
<li><p><strong>核心作用</strong>：与 <code>GET</code> 方法完全相同，但服务器的响应中<strong>只包含头部 (Headers)，不包含响应体 (Body)</strong>。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li>它是<strong>安全的</strong>和<strong>幂等的</strong>。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>在下载大文件前，先用 <code>HEAD</code> 请求检查文件大小 (<code>Content-Length</code>)。</li>
<li>检查资源的最后修改时间 (<code>Last-Modified</code>)，以判断是否需要重新下载。</li>
<li>检查资源是否存在，而无需传输整个资源。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="string">/large-video.mp4</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>media.example.com</span><br></pre></td></tr></table></figure>

<p>服务器会返回 <code>200 OK</code> 以及 <code>Content-Length</code>, <code>Content-Type</code> 等头部，但不会传输视频数据。</p>
</li>
</ul>
<hr>
<h3 id="1-6-OPTIONS-查询服务器支持的方法"><a href="#1-6-OPTIONS-查询服务器支持的方法" class="headerlink" title="1.6 OPTIONS: 查询服务器支持的方法"></a>1.6 OPTIONS: 查询服务器支持的方法</h3><ul>
<li><p><strong>核心作用</strong>：查询指定 URL 的服务器支持哪些 HTTP 请求方法。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li>它是<strong>安全的</strong>和<strong>幂等的</strong>。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><strong>CORS (跨源资源共享)</strong> 中的“预检请求 (Preflight Request)”。在发送复杂的跨域请求（如 <code>PUT</code> 或带自定义头部的 <code>POST</code>）之前，浏览器会自动发送一个 <code>OPTIONS</code> 请求，以确认服务器是否允许该跨域操作。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/users/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br></pre></td></tr></table></figure>

<p>服务器的响应头中会包含 <code>Allow: GET, PUT, DELETE, HEAD, OPTIONS</code> 这样的字段。</p>
</li>
</ul>
<hr>
<h3 id="1-7-PATCH-部分更新资源"><a href="#1-7-PATCH-部分更新资源" class="headerlink" title="1.7 PATCH: 部分更新资源"></a>1.7 PATCH: 部分更新资源</h3><ul>
<li><p><strong>核心作用</strong>：对资源进行<strong>局部修改 (Partial Modification)</strong>。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li><code>PATCH</code> 请求<strong>必须包含请求体</strong>，其中描述了要进行的更改（例如，要修改哪个字段，改成什么值）。</li>
<li>它是<strong>不安全的</strong>。</li>
<li>它<strong>不一定是幂等的</strong>。例如，一个“将商品价格加 10 元”的 <code>PATCH</code> 请求，执行多次效果就不同。但一个“将商品价格设为 100 元”的 <code>PATCH</code> 请求就是幂等的。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>只修改用户的手机号，而无需上传用户的全部信息。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PATCH</span> <span class="string">/users/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json-patch+json</span><br><span class="line"></span><br><span class="line"><span class="language-css"><span class="selector-attr">[&#123;<span class="string">&quot;op&quot;</span>: <span class="string">&quot;replace&quot;</span>, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/email&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;new.email@example.com&quot;</span>&#125;]</span></span></span><br></pre></td></tr></table></figure>

<p>这个请求意图是只将 ID 为 123 的用户的 <code>email</code> 字段替换为新值。</p>
</li>
</ul>
<hr>
<h3 id="1-8-安全与幂等性-Safety-and-Idempotence"><a href="#1-8-安全与幂等性-Safety-and-Idempotence" class="headerlink" title="1.8 安全与幂等性 (Safety and Idempotence)"></a>1.8 安全与幂等性 (Safety and Idempotence)</h3><p>这两个概念是理解和正确使用 HTTP 方法的关键。</p>
<ul>
<li><strong>安全 (Safe)</strong><ul>
<li><strong>定义</strong>：一个方法被称为“安全”的，是指执行它<strong>不会改变服务器上的资源状态</strong>。换句话说，它是“只读”的。</li>
<li><strong>安全的方法</strong>：<code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>。</li>
<li><strong>目的</strong>：客户端（包括搜索引擎爬虫）可以无顾虑地、自动地发起安全请求，因为它们知道这不会产生任何副作用。</li>
</ul>
</li>
<li><strong>幂等 (Idempotent)</strong><ul>
<li><strong>定义</strong>：一个方法被称为“幂等”的，是指<strong>对同一个资源执行一次或多次相同的请求，产生的最终效果是完全相同的</strong>。</li>
<li><strong>幂等的方法</strong>：<code>GET</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>, <code>OPTIONS</code>。</li>
<li><strong>不幂等的方法</strong>：<code>POST</code> (通常)，<code>PATCH</code> (可能)。</li>
<li><strong>目的</strong>：幂等性在网络不稳定的情况下非常重要。如果一个请求超时，客户端不知道服务器是否已处理。如果方法是幂等的，客户端就可以<strong>安全地重试</strong>该请求，而不用担心会创建重复数据或产生意外的副作用。</li>
</ul>
</li>
</ul>
<p><strong>总结表</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">核心作用</th>
<th align="left">请求体</th>
<th align="left">安全性</th>
<th align="left">幂等性</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>GET</strong></td>
<td align="left">获取资源</td>
<td align="left">无</td>
<td align="left">安全</td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>POST</strong></td>
<td align="left">创建&#x2F;提交资源</td>
<td align="left">有</td>
<td align="left">不安全</td>
<td align="left"><strong>否</strong></td>
</tr>
<tr>
<td align="left"><strong>PUT</strong></td>
<td align="left">完整更新资源</td>
<td align="left">有</td>
<td align="left">不安全</td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>DELETE</strong></td>
<td align="left">删除资源</td>
<td align="left">无</td>
<td align="left">不安全</td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>HEAD</strong></td>
<td align="left">获取元信息</td>
<td align="left">无</td>
<td align="left">安全</td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>PATCH</strong></td>
<td align="left">部分更新资源</td>
<td align="left">有</td>
<td align="left">不安全</td>
<td align="left"><strong>不一定</strong></td>
</tr>
<tr>
<td align="left"><strong>OPTIONS</strong></td>
<td align="left">查询支持方法</td>
<td align="left">无</td>
<td align="left">安全</td>
<td align="left"><strong>是</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="2-状态码-Status-Codes"><a href="#2-状态码-Status-Codes" class="headerlink" title="2. 状态码 (Status Codes)"></a>2. 状态码 (Status Codes)</h2><p>HTTP 状态码是包含在响应报文状态行中的一个三位数字代码。它的第一个数字定义了响应的类别，共有五大类。</p>
<ul>
<li><strong>1xx (信息性)</strong>: 表示请求已被接收，继续处理。</li>
<li><strong>2xx (成功)</strong>: 表示请求已成功被服务器接收、理解、并接受。</li>
<li><strong>3xx (重定向)</strong>: 表示需要客户端采取进一步的操作才能完成请求。</li>
<li><strong>4xx (客户端错误)</strong>: 表示客户端的请求有错误，服务器无法处理。</li>
<li><strong>5xx (服务器错误)</strong>: 表示服务器在处理一个看似有效的请求时发生了错误。</li>
</ul>
<hr>
<h3 id="2-1-1xx-信息性-Informational"><a href="#2-1-1xx-信息性-Informational" class="headerlink" title="2.1 1xx (信息性) - Informational"></a>2.1 1xx (信息性) - Informational</h3><p>这类状态码表示服务器已收到请求的一部分，并告知客户端可以继续发送剩余部分，或者如果请求已经完成，就忽略这个响应。在日常开发中很少直接处理它们。</p>
<ul>
<li><strong><code>100 Continue</code></strong><ul>
<li><strong>含义</strong>: 服务器已收到请求的头部，客户端应继续发送请求体。</li>
<li><strong>使用场景</strong>: 当客户端需要发送一个很大的请求体（如上传大文件）时，它可以先发送一个带有 <code>Expect: 100-continue</code> 头部的请求。服务器如果愿意接收，就返回 <code>100 Continue</code>，客户端再开始传输数据。如果服务器不愿接收（如因权限不足），它可以直接返回一个 4xx 错误，从而避免了大量数据的无效传输。</li>
<li><strong>类比</strong>: 你想给朋友一个大包裹，你先打电话问：“我准备好了一个大包裹要送给你，你方便收吗？” 朋友回答：“方便，你送过来吧！” (<code>100 Continue</code>)。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-2xx-成功-Success"><a href="#2-2-2xx-成功-Success" class="headerlink" title="2.2 2xx (成功) - Success"></a>2.2 2xx (成功) - Success</h3><p>这是我们最希望看到的响应，表示请求被成功处理。</p>
<ul>
<li><strong><code>200 OK</code></strong><ul>
<li><strong>含义</strong>: 请求成功。这是最常见的成功状态码。</li>
<li><strong>使用场景</strong>:<ul>
<li>对于 <code>GET</code> 和 <code>HEAD</code> 请求，表示资源已成功获取，并在响应体中包含了该资源。</li>
<li>对于 <code>POST</code> 请求，响应体中可能包含了操作的结果。</li>
</ul>
</li>
<li><strong>类比</strong>: 你去餐厅点了一份“宫保鸡丁”，服务员成功地把“宫保鸡丁”端到了你的桌上。</li>
</ul>
</li>
<li><strong><code>201 Created</code></strong><ul>
<li><strong>含义</strong>: 请求成功，并且服务器创建了一个新的资源。</li>
<li><strong>使用场景</strong>: 通常是 <code>POST</code> 或 <code>PUT</code> 请求的结果。例如，通过 API <code>POST /users</code> 创建一个新用户后，服务器返回 <code>201 Created</code>。响应头中的 <code>Location</code> 字段通常会包含新资源的 URL，例如 <code>Location: /users/123</code>。</li>
<li><strong>类比</strong>: 你在网上提交了自定义手机的订单，系统回复你：“订单已创建，您的订单号是 XXX”。</li>
</ul>
</li>
<li><strong><code>204 No Content</code></strong><ul>
<li><strong>含义</strong>: 服务器成功处理了请求，但没有返回任何内容。响应报文中不包含响应体。</li>
<li><strong>使用场景</strong>:<ul>
<li><code>DELETE</code> 请求成功删除资源后。资源已经没了，自然没有内容可返回。</li>
<li>客户端通过 <code>PUT</code> 请求更新了资源，服务器只想确认操作已完成，而不想把整个资源再发回一遍。</li>
</ul>
</li>
<li><strong>类比</strong>: 你让智能音箱“关灯”，它执行了操作，然后就安静了。任务完成，无需多言。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-3xx-重定向-Redirection"><a href="#2-3-3xx-重定向-Redirection" class="headerlink" title="2.3 3xx (重定向) - Redirection"></a>2.3 3xx (重定向) - Redirection</h3><p>这类状态码告诉客户端，为了完成请求，需要执行一些额外的操作，通常是跳转到另一个 URL。</p>
<ul>
<li><strong><code>301 Moved Permanently</code> (永久重定向)</strong><ul>
<li><strong>含义</strong>: 请求的资源已被<strong>永久</strong>移动到 <code>Location</code> 头部指定的新 URL。</li>
<li><strong>使用场景</strong>: 网站更换域名（<code>http://old.com</code> -&gt; <code>http://new.com</code>），或者 URL 结构重构。</li>
<li><strong>客户端行为</strong>: 浏览器会自动跳转到新地址。搜索引擎会更新其索引，将权重从旧地址转移到新地址。</li>
<li><strong>类比</strong>: 一家商店永久搬迁，在旧店门上贴了告示：“我们已搬至新街 1 号，请前往新址”。</li>
</ul>
</li>
<li><strong><code>302 Found</code> (临时重定向)</strong><ul>
<li><strong>含义</strong>: 请求的资源<strong>临时</strong>位于 <code>Location</code> 头部指定的新 URL。</li>
<li><strong>使用场景</strong>:<ul>
<li>未登录用户访问需要登录的页面，服务器将其重定向到登录页，登录成功后再跳回原页面。</li>
<li>网站A&#x2F;B测试，临时将部分用户导向不同版本的页面。</li>
</ul>
</li>
<li><strong>客户端行为</strong>: 浏览器会自动跳转到新地址，但搜索引擎不会更新索引，仍然会抓取原始 URL。</li>
<li><strong>类比</strong>: 你常走的路因为临时施工被封了，交警指示你走旁边的绕行路线。你知道明天这条路可能就恢复通行了。</li>
</ul>
</li>
<li><strong><code>304 Not Modified</code> (未修改)</strong><ul>
<li><strong>含义</strong>: 资源未被修改，客户端可以使用本地缓存的版本。</li>
<li><strong>使用场景</strong>: 这是<strong>协商缓存</strong>的核心。客户端在请求时带上 <code>If-None-Match</code> 或 <code>If-Modified-Since</code> 头部，服务器发现资源没有变化，就返回 <code>304</code>。这个响应<strong>不包含响应体</strong>，极大地节省了带宽。</li>
<li><strong>类比</strong>: 你问朋友：“昨天跟你聊完之后，有啥新情况吗？” 朋友回答：“没，一切照旧。” (<code>304</code>)，于是你就不需要再听一遍同样的故事了。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-4-4xx-客户端错误-Client-Error"><a href="#2-4-4xx-客户端错误-Client-Error" class="headerlink" title="2.4 4xx (客户端错误) - Client Error"></a>2.4 4xx (客户端错误) - Client Error</h3><p>这类状态码表示错误是由客户端引起的。</p>
<ul>
<li><strong><code>400 Bad Request</code></strong><ul>
<li><strong>含义</strong>: 服务器无法理解客户端的请求。这是一个通用的客户端错误。</li>
<li><strong>使用场景</strong>: 请求的语法有误（如头部格式错误），或请求的参数无效（如 API 要求一个数字，你却传了字符串）。</li>
<li><strong>类比</strong>: 你用含糊不清的语言点菜，服务员完全听不懂，只能说：“抱歉，您能再说一遍吗？”</li>
</ul>
</li>
<li><strong><code>401 Unauthorized</code> (未授权)</strong><ul>
<li><strong>含义</strong>: 请求需要身份验证。客户端没有提供凭证，或者提供的凭证无效。</li>
<li><strong>使用场景</strong>: 访问需要登录才能查看的页面或 API。</li>
<li><strong>关键点</strong>: 它表示“<strong>你谁啊？请先登录&#x2F;证明你的身份</strong>”。</li>
<li><strong>类比</strong>: 你想进一个会员制俱乐部，但门口的保安拦住了你，说：“请出示您的会员卡。”</li>
</ul>
</li>
<li><strong><code>403 Forbidden</code> (禁止访问)</strong><ul>
<li><strong>含义</strong>: 服务器理解你的请求，但拒绝执行。与 <code>401</code> 不同，即使提供了身份验证，也无权访问。</li>
<li><strong>使用场景</strong>: 一个普通用户尝试访问管理员才能进入的后台管理页面。服务器知道你是谁 (<code>401</code> 已通过)，但你的“权限”不够。</li>
<li><strong>关键点</strong>: 它表示“<strong>我知道你是谁，但你没资格来这里</strong>”。</li>
<li><strong>类比</strong>: 你出示了会员卡（通过了 <code>401</code>），但想进入“仅限白金会员”的区域，保安拦住你说：“抱歉，您的会员等级不够，不能进入此区域。”</li>
</ul>
</li>
<li><strong><code>404 Not Found</code> (未找到)</strong><ul>
<li><strong>含义</strong>: 服务器上没有找到请求的资源。这是互联网上最著名的状态码之一。</li>
<li><strong>使用场景</strong>: 访问一个不存在的 URL。</li>
<li><strong>类比</strong>: 你去图书馆按书号找一本书，但图书管理员告诉你：“对不起，我们馆里没有这本书。”</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-5-5xx-服务器错误-Server-Error"><a href="#2-5-5xx-服务器错误-Server-Error" class="headerlink" title="2.5 5xx (服务器错误) - Server Error"></a>2.5 5xx (服务器错误) - Server Error</h3><p>这类状态码表示服务器在处理请求的过程中发生了内部错误。</p>
<ul>
<li><strong><code>500 Internal Server Error</code> (内部服务器错误)</strong><ul>
<li><strong>含义</strong>: 服务器遇到了一个未曾预料的状况，导致其无法完成请求。这是一个非常笼统的错误。</li>
<li><strong>使用场景</strong>: 应用程序代码出现 Bug（如空指针、数据库异常未捕获等）。这是开发人员最不希望用户看到，但也最常用来捕获未知异常的状态码。</li>
<li><strong>类比</strong>: 餐厅后厨突然着火了，一片混乱，你的菜肯定做不出来了。</li>
</ul>
</li>
<li><strong><code>502 Bad Gateway</code> (错误网关)</strong><ul>
<li><strong>含义</strong>: 服务器作为网关或代理，从上游服务器收到了无效的响应。</li>
<li><strong>使用场景</strong>: 你的请求先到达一个 Nginx 反向代理，Nginx 再把请求转发给后端的应用服务器（如 Tomcat）。如果此时 Tomcat 应用崩溃了或没响应，Nginx 就会向客户端返回 <code>502</code>。</li>
<li><strong>关键点</strong>: 问题出在“上游”，而不是当前的网关服务器本身。</li>
<li><strong>类比</strong>: 你打电话给公司总机（网关），总机帮你转接到销售部（上游服务器），但销售部的电话是忙音或无人接听。总机只好告诉你：“抱歉，无法接通销售部。”</li>
</ul>
</li>
<li><strong><code>503 Service Unavailable</code> (服务不可用)</strong><ul>
<li><strong>含义</strong>: 服务器当前无法处理请求，通常是暂时的。</li>
<li><strong>使用场景</strong>:<ul>
<li>服务器因过载而无法处理更多请求（如双十一抢购）。</li>
<li>服务器正在停机维护。</li>
</ul>
</li>
<li><strong>关键点</strong>: 这是一个<strong>临时</strong>状态，稍后可能会恢复。响应中可能会包含 <code>Retry-After</code> 头部，建议客户端在多久之后再试。</li>
<li><strong>类比</strong>: 你常去的餐厅因为今天客人太多，门口挂上了“今日客满，请稍后再来”的牌子。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="四、HTTP-核心机制与特性"><a href="#四、HTTP-核心机制与特性" class="headerlink" title="四、HTTP 核心机制与特性"></a>四、HTTP 核心机制与特性</h1><h2 id="1-连接管理"><a href="#1-连接管理" class="headerlink" title="1. 连接管理"></a>1. 连接管理</h2><p>HTTP 协议本身是无状态的，但它需要依赖下层有状态的 TCP 协议来传输报文。如何管理和使用这些 TCP 连接，对 Web 的性能有着决定性的影响。</p>
<h3 id="1-1-短连接-vs-长连接-Persistent-Connection-Keep-Alive"><a href="#1-1-短连接-vs-长连接-Persistent-Connection-Keep-Alive" class="headerlink" title="1.1 短连接 vs 长连接 (Persistent Connection &#x2F; Keep-Alive)"></a>1.1 短连接 vs 长连接 (Persistent Connection &#x2F; Keep-Alive)</h3><p>这是 HTTP 连接管理的两种基本模式，代表了从 HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的一个重要演进。</p>
<h4 id="1-1-1-短连接-Short-lived-Connections-HTTP-1-0-默认模式"><a href="#1-1-1-短连接-Short-lived-Connections-HTTP-1-0-默认模式" class="headerlink" title="1.1.1 短连接 (Short-lived Connections) - HTTP&#x2F;1.0 默认模式"></a>1.1.1 短连接 (Short-lived Connections) - HTTP&#x2F;1.0 默认模式</h4><ul>
<li><p><strong>工作方式</strong>: 每次 HTTP 通信，客户端都需要与服务器建立一个新的 TCP 连接。通信结束后（即收到响应报文后），该 TCP 连接立即被关闭。</p>
</li>
<li><p><strong>流程</strong>:</p>
<ol>
<li>建立 TCP 连接（三次握手）。</li>
<li>客户端发送 HTTP 请求。</li>
<li>服务器发送 HTTP 响应。</li>
<li>关闭 TCP 连接（四次挥手）。</li>
</ol>
<ul>
<li><em>如果页面上还有其他资源（如图片、CSS），则对每个资源重复以上 4 个步骤。</em></li>
</ul>
</li>
<li><p><strong>缺点</strong>:</p>
<ul>
<li><strong>性能极差</strong>: 每个资源都需要一次完整的 TCP 连接建立和关闭过程。TCP 的三次握手本身就需要至少 1 个 RTT（Round-Trip Time，往返时间），这在请求大量小文件时会累积成巨大的延迟。</li>
<li><strong>资源消耗</strong>: 频繁地创建和销毁连接，对客户端和服务器都造成了不小的 CPU 和内存开销。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-2-长连接-Persistent-Connections-Keep-Alive-HTTP-1-1-默认模式"><a href="#1-1-2-长连接-Persistent-Connections-Keep-Alive-HTTP-1-1-默认模式" class="headerlink" title="1.1.2 长连接 (Persistent Connections &#x2F; Keep-Alive) - HTTP&#x2F;1.1 默认模式"></a>1.1.2 长连接 (Persistent Connections &#x2F; Keep-Alive) - HTTP&#x2F;1.1 默认模式</h4><ul>
<li><strong>工作方式</strong>: 在一次 HTTP 通信结束后，TCP 连接不会立即关闭，而是保持打开状态（“keep-alive”）。后续对该服务器的 HTTP 请求可以<strong>复用</strong>这条已经建立的 TCP 连接。</li>
<li><strong>流程</strong>:<ol>
<li>建立 TCP 连接（三次握手）。</li>
<li>客户端发送请求 #1 (e.g., <code>index.html</code>)。</li>
<li>服务器发送响应 #1。</li>
<li>客户端在<strong>同一条连接上</strong>发送请求 #2 (e.g., <code>style.css</code>)。</li>
<li>服务器发送响应 #2。</li>
<li>…（重复4和5）…</li>
<li>当一方决定关闭（如浏览器关闭页面）或连接空闲超时后，关闭 TCP 连接。</li>
</ol>
</li>
<li><strong>优点</strong>:<ul>
<li><strong>显著提升性能</strong>: 避免了多次 TCP 握手和慢启动的开销，大大降低了延迟。</li>
<li><strong>减少资源消耗</strong>: 减少了服务器和客户端因建立和关闭连接而产生的负担。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-Connection-头部的作用"><a href="#1-2-Connection-头部的作用" class="headerlink" title="1.2 Connection 头部的作用"></a>1.2 <code>Connection</code> 头部的作用</h3><p><code>Connection</code> 头部是控制连接模式的核心开关。它是一个“逐跳 (hop-by-hop)”头部，只对单次 TCP 连接有效，不会被代理服务器转发。</p>
<ul>
<li><p><strong>在 HTTP&#x2F;1.0 中</strong>:</p>
<ul>
<li><p>默认是短连接。</p>
</li>
<li><p>如果客户端希望使用长连接，需要在请求头中明确指出：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果服务器也同意，它会在响应头中同样返回 <code>Connection: keep-alive</code>。</p>
</li>
</ul>
</li>
<li><p><strong>在 HTTP&#x2F;1.1 中</strong>:</p>
<ul>
<li><p><strong>默认就是长连接</strong>。因此，理论上不再需要发送 <code>Connection: keep-alive</code>（但为了兼容旧的代理，很多浏览器仍然会发送它）。</p>
</li>
<li><p>如果任何一方希望在本次通信后<strong>关闭连接</strong>，则需要明确声明：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br></pre></td></tr></table></figure>
</li>
<li><p>当客户端或服务器在报文中包含了 <code>Connection: close</code>，就意味着本次响应发送完毕后，TCP 连接将被关闭。这通常用于客户端确定不再有请求，或服务器处于高负载希望释放连接时。</p>
</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：</p>
<table>
<thead>
<tr>
<th>HTTP 版本</th>
<th>默认模式</th>
<th>如何开启长连接</th>
<th>如何关闭连接</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HTTP&#x2F;1.0</strong></td>
<td>短连接</td>
<td><code>Connection: keep-alive</code></td>
<td>(默认行为)</td>
</tr>
<tr>
<td><strong>HTTP&#x2F;1.1</strong></td>
<td>长连接</td>
<td>(默认行为)</td>
<td><code>Connection: close</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-队头阻塞问题-Head-of-Line-Blocking-HOL-Blocking"><a href="#1-3-队头阻塞问题-Head-of-Line-Blocking-HOL-Blocking" class="headerlink" title="1.3 队头阻塞问题 (Head-of-Line Blocking, HOL Blocking)"></a>1.3 队头阻塞问题 (Head-of-Line Blocking, HOL Blocking)</h3><p>长连接虽然极大地提升了性能，但也引入了一个新的、非常棘手的问题——<strong>队头阻塞</strong>。这是 HTTP&#x2F;1.1 时代最主要的性能瓶颈。</p>
<ul>
<li><strong>核心定义</strong>:<br>在一条长连接中，HTTP 请求和响应是<strong>严格的“先进先出” (FIFO) 管道模型</strong>。客户端发送请求 1，必须等待响应 1 完全返回后，才能发送请求 2。此时，队头阻塞发生在<strong>请求端</strong>，整个连接的效率被“一问一答”的模式严重限制。</li>
</ul>
<p>为了解决这个顽固的问题，人们进行了不同的尝试，但结果却大相径庭。</p>
<p><strong>1. 理论上的解决方案：管道化 (Pipelining) —— 一个失败的尝试</strong></p>
<p>HTTP&#x2F;1.1 规范中提出了一种看似聪明的技术——“管道化”。</p>
<ul>
<li><strong>设想</strong>：允许客户端在不等待响应的情况下，连续发送多个请求（比如请求1, 2, 3一口气全发出去），以提高连接利用率。</li>
<li><strong>致命缺陷</strong>：规范同时要求，服务器<strong>必须严格按照接收请求的顺序（1, 2, 3）来返回响应</strong>。这导致队头阻塞问题并未解决，只是从“请求发送端”转移到了“响应返回端”。一个处理缓慢的响应1，依然会阻塞住已经处理完成的响应2和响应3。</li>
<li><strong>最终结局</strong>：由于这个致命缺陷，加上网络中大量代理服务器对其兼容性极差，导致实现复杂且极易出错。因此，<strong>管道化技术在实践中基本被所有主流浏览器默认禁用或彻底放弃</strong>。它成了一个存在于纸面上的理论，而非实用的解决方案。</li>
</ul>
<p><strong>2. 现实中的权宜之计：并发TCP连接 (Concurrent Connections)</strong></p>
<p>既然“管道化”这条路走不通，浏览器厂商只能采取一个更简单粗暴、但行之有效的办法：<strong>多开几条路</strong>。</p>
<ul>
<li><strong>做法</strong>：浏览器被允许对同一个域名<strong>同时建立多条并行的TCP长连接</strong>（通常是6-8条）。当有多个资源需要请求时，浏览器会将它们分配到这些不同的连接上去。</li>
<li><strong>效果</strong>：这就像把原来的“单行道”拓宽成了“6车道高速公路”。一个连接（车道）上的慢请求（慢车），不会再阻塞其他连接（车道）上的快请求。这极大地缓解了队头阻塞问题，是 <strong>HTTP&#x2F;1.1 时代浏览器提升页面加载速度最主要的实用手段</strong>。</li>
<li><strong>局限性</strong>：这并非完美的解决方案。建立和维护多条TCP连接本身会消耗更多客户端和服务器资源，且连接数终究有限，当资源数量远超连接数时，局部排队依然会发生。</li>
</ul>
<p><strong>队头阻塞的最终解决：HTTP&#x2F;2</strong></p>
<p>这个问题的根本解决，要等到 <strong>HTTP&#x2F;2</strong> 的出现。HTTP&#x2F;2 引入了<strong>多路复用 (Multiplexing)</strong> 技术，允许在<strong>一条TCP连接</strong>上真正地、并行地传输多个请求和响应，彻底废除了“并发连接”这个权宜之计，从根源上解决了 HTTP&#x2F;1.1 的队头阻塞问题。我们将在后续章节详细讨论。</p>
<hr>
<h2 id="2-状态管理：Cookie-与-Session"><a href="#2-状态管理：Cookie-与-Session" class="headerlink" title="2. 状态管理：Cookie 与 Session"></a>2. 状态管理：Cookie 与 Session</h2><h3 id="2-1-为什么需要状态管理？-弥补-HTTP-无状态特性"><a href="#2-1-为什么需要状态管理？-弥补-HTTP-无状态特性" class="headerlink" title="2.1 为什么需要状态管理？(弥补 HTTP 无状态特性)"></a>2.1 为什么需要状态管理？(弥补 HTTP 无状态特性)</h3><p>我们在第一章讲过，HTTP 的一个核心特点是<strong>无状态 (Stateless)</strong>。这意味着服务器不会记录任何关于客户端请求的历史信息。每一次请求对于服务器来说都是一个全新的、独立的事件。</p>
<ul>
<li><strong>无状态的优点</strong>: 简化服务器设计，易于实现负载均衡和横向扩展。</li>
<li><strong>无状态的挑战</strong>: 现实世界的 Web 应用几乎都需要“状态”。比如：<ul>
<li><strong>用户登录</strong>: 用户登录后，在网站的不同页面间跳转，服务器必须知道该用户仍然处于登录状态。</li>
<li><strong>购物车</strong>: 用户将商品加入购物车，切换到其他页面，再返回时，购物车中的商品必须还在。</li>
<li><strong>个性化推荐</strong>: 网站需要记住用户的偏好，为其推荐相关内容。</li>
</ul>
</li>
</ul>
<p>为了在无状态的 HTTP 协议之上构建有状态的应用，<strong>Cookie 和 Session</strong> 机制应运而生。它们就像是服务器发给客户端的“通行证”或“会员卡”，让服务器能够在一次次独立的请求中识别出同一个用户。</p>
<hr>
<h3 id="2-2-Cookie：工作原理"><a href="#2-2-Cookie：工作原理" class="headerlink" title="2.2 Cookie：工作原理"></a>2.2 Cookie：工作原理</h3><p>Cookie 是一种由服务器发送到客户端（浏览器），并由客户端保存在本地的一小段文本数据。之后，客户端每次向该服务器发送请求时，都会自动带上这段数据。</p>
<p><strong>工作流程 (四步)</strong>：</p>
<ol>
<li><p><strong>首次请求</strong>: 客户端（浏览器）向服务器发起请求。此时，请求中不包含任何 Cookie 信息。</p>
</li>
<li><p><strong>服务器响应与 <code>Set-Cookie</code></strong>: 服务器处理完请求后，在响应报文的头部中加入一个 <code>Set-Cookie</code> 字段。这个字段包含了要设置的 Cookie 信息（一个键值对和一些属性）。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>user_id=12345</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端存储 Cookie</strong>: 浏览器收到这个响应后，会解析 <code>Set-Cookie</code> 头部，并将 <code>user_id=12345</code> 这条信息与该服务器的域名（例如 <code>example.com</code>）关联起来，存储在本地。</p>
</li>
<li><p><strong>后续请求与 <code>Cookie</code></strong>: 当用户再次访问 <code>example.com</code> 上的任何页面时，浏览器会自动在请求报文的头部中加入一个 <code>Cookie</code> 字段，将之前存储的信息发送给服务器。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/profile</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>user_id=12345</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过这个流程，服务器就能在后续的请求中通过读取 <code>Cookie</code> 头部的 <code>user_id</code>，识别出这是 ID 为 12345 的用户，从而为其提供个性化的服务（如显示“欢迎回来！”）。</p>
<hr>
<h3 id="2-3-Cookie-的属性"><a href="#2-3-Cookie-的属性" class="headerlink" title="2.3 Cookie 的属性"></a>2.3 Cookie 的属性</h3><p><code>Set-Cookie</code> 头部不仅可以设置键值对，还可以附加多个属性来控制 Cookie 的行为。这些属性至关重要，直接影响到 Cookie 的生命周期、作用域和安全性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;; Max-Age=&lt;seconds&gt;; Domain=&lt;domain&gt;; Path=&lt;path&gt;; Secure; HttpOnly; SameSite=&lt;Strict|Lax|None&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">示例值</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>Expires</code></strong></td>
<td align="left"><code>Wed, 21 Oct 2025 07:28:00 GMT</code></td>
<td align="left">设置 Cookie 的<strong>绝对过期时间</strong>。到期后，浏览器会自动删除该 Cookie。</td>
</tr>
<tr>
<td align="left"><strong><code>Max-Age</code></strong></td>
<td align="left"><code>3600</code></td>
<td align="left">设置 Cookie 的<strong>相对存活时间</strong>（单位：秒）。<code>Max-Age</code> 的优先级高于 <code>Expires</code>。如果设为 0 或负数，Cookie 会立即失效。</td>
</tr>
<tr>
<td align="left"><strong><code>Domain</code></strong></td>
<td align="left"><code>.example.com</code></td>
<td align="left">指定 Cookie 所属的域名。浏览器在向该域名及其子域名（如 <code>api.example.com</code>）发送请求时都会带上此 Cookie。</td>
</tr>
<tr>
<td align="left"><strong><code>Path</code></strong></td>
<td align="left"><code>/</code></td>
<td align="left">指定 Cookie 生效的路径。只有当请求的路径是该路径或其子路径时，才会发送此 Cookie。<code>Path=/</code> 表示对整个域名都有效。</td>
</tr>
<tr>
<td align="left"><strong><code>Secure</code></strong></td>
<td align="left">(无值)</td>
<td align="left"><strong>安全标志</strong>。如果设置了此属性，浏览器只会在 HTTPS 连接中发送该 Cookie，在不安全的 HTTP 连接中则不会发送。</td>
</tr>
<tr>
<td align="left"><strong><code>HttpOnly</code></strong></td>
<td align="left">(无值)</td>
<td align="left"><strong>HTTP-Only 标志</strong>。如果设置了此属性，该 Cookie <strong>不能被客户端的 JavaScript 脚本访问</strong>（通过 <code>document.cookie</code>）。这是防止 XSS 攻击窃取 Cookie 的一道重要防线。</td>
</tr>
<tr>
<td align="left"><strong><code>SameSite</code></strong></td>
<td align="left"><code>Strict</code>, <code>Lax</code>, <code>None</code></td>
<td align="left">控制 Cookie 在<strong>跨站请求</strong>中的发送策略。这是防止 CSRF 攻击的关键机制。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>Strict</code></td>
<td align="left">完全禁止第三方 Cookie，只有在当前网站内部跳转时才会发送 Cookie。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>Lax</code> (现代浏览器默认值)</td>
<td align="left">允许在一些安全的顶级导航（如点击链接跳转）中发送 Cookie，但在表单提交、图片加载等场景下会限制。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>None</code></td>
<td align="left">允许在任何跨站请求中发送 Cookie。<strong>使用 <code>SameSite=None</code> 时必须同时设置 <code>Secure</code> 属性</strong>。</td>
</tr>
</tbody></table>
<p><strong>会话 Cookie (Session Cookie)</strong> vs <strong>持久性 Cookie (Persistent Cookie)</strong>:</p>
<ul>
<li>如果一个 Cookie <strong>没有</strong>设置 <code>Expires</code> 或 <code>Max-Age</code> 属性，它就是一个<strong>会话 Cookie</strong>。它存储在内存中，当浏览器关闭时就会被删除。</li>
<li>如果设置了 <code>Expires</code> 或 <code>Max-Age</code>，它就是一个<strong>持久性 Cookie</strong>，会被存储在硬盘上，直到过期或被手动删除。</li>
</ul>
<hr>
<h3 id="2-4-Session：基于-Cookie-的服务端状态管理机制"><a href="#2-4-Session：基于-Cookie-的服务端状态管理机制" class="headerlink" title="2.4 Session：基于 Cookie 的服务端状态管理机制"></a>2.4 Session：基于 Cookie 的服务端状态管理机制</h3><p>虽然 Cookie 可以实现状态管理，但它有几个明显的缺点：</p>
<ul>
<li><strong>安全性差</strong>: Cookie 的内容直接存储在客户端，敏感信息（如用户权限、密码等）直接存在 Cookie 中容易被窃取或篡改。</li>
<li><strong>大小受限</strong>: 浏览器对单个 Cookie 的大小（通常 4KB）和每个域名下的 Cookie 数量都有限制。</li>
<li><strong>网络开销</strong>: 每次请求都需要携带 Cookie，如果 Cookie 内容过多，会增加网络传输的负担。</li>
</ul>
<p>为了解决这些问题，<strong>Session</strong> 机制应运而生。</p>
<ul>
<li><strong>核心思想</strong>: <strong>将核心的、敏感的用户状态数据存储在服务器端，而只在客户端的 Cookie 中存储一个唯一的、无意义的标识符（Session ID）。</strong></li>
</ul>
<p><strong>工作流程</strong>:</p>
<ol>
<li><p><strong>用户首次访问&#x2F;登录</strong>:</p>
<ul>
<li>客户端向服务器发送请求。</li>
<li>服务器验证用户信息（如用户名密码）通过后，在<strong>服务器端</strong>创建一个 Session 对象（可以是一个内存中的哈希表、Redis 缓存等），用来存储该用户的具体信息（如用户ID、姓名、权限等）。</li>
<li>服务器为这个 Session 对象生成一个<strong>唯一的 Session ID</strong>（一个随机字符串）。</li>
<li>服务器通过 <code>Set-Cookie</code> 响应头，将这个 <strong>Session ID</strong> 发送给客户端。</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>session_id=aBcDeFg12345; HttpOnly</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端存储 Session ID</strong>: 浏览器收到响应后，将 <code>session_id=aBcDeFg12345</code> 这条 Cookie 存储起来。注意，这个 Cookie 里只有无意义的 ID，没有任何敏感数据。</p>
</li>
<li><p><strong>后续请求</strong>:</p>
<ul>
<li>客户端再次向服务器发起请求时，会自动带上这条包含 Session ID 的 Cookie。</li>
<li>服务器收到请求后，从 Cookie 中读取 Session ID (<code>aBcDeFg12345</code>)。</li>
<li>服务器用这个 Session ID 在自己的 Session 存储中进行查找，找到对应的 Session 对象。</li>
<li>从 Session 对象中读取用户的状态信息（如“已登录”、“管理员权限”），然后进行相应的处理。</li>
</ul>
</li>
</ol>
<p><strong>Cookie 与 Session 的关系与区别</strong></p>
<ul>
<li><strong>关系</strong>: Session 通常是<strong>依赖于 Cookie</strong> 来实现的。Cookie 是承载 Session ID 的载体。</li>
<li><strong>区别</strong>:<ul>
<li><strong>存储位置</strong>: Cookie 数据存在<strong>客户端</strong>；Session 数据存在<strong>服务器端</strong>。</li>
<li><strong>安全性</strong>: Session 比 Cookie <strong>更安全</strong>，因为敏感数据不离开服务器。</li>
<li><strong>数据大小</strong>: Cookie 有大小限制；Session 理论上可以存储任意大小的数据（取决于服务器资源）。</li>
<li><strong>服务器压力</strong>: Session 会增加服务器的存储和计算压力。每个在线用户都需要一个 Session 对象。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>: Cookie 和 Session 是协同工作的，它们共同解决了 HTTP 无状态的问题，使得构建复杂的、有状态的 Web 应用成为可能。在现代 Web 开发中，通常将 Session ID 存储在设置为 <code>HttpOnly</code> 的 Cookie 中，以兼顾功能和安全性。</p>
<hr>
<h2 id="3-缓存控制"><a href="#3-缓存控制" class="headerlink" title="3. 缓存控制"></a>3. 缓存控制</h2><h3 id="3-1-缓存的价值"><a href="#3-1-缓存的价值" class="headerlink" title="3.1 缓存的价值"></a>3.1 缓存的价值</h3><p>HTTP 缓存是一种将已经获取过的资源副本存储起来，以便在下次请求相同资源时可以直接使用，而无需再次向源服务器请求的技术。</p>
<ul>
<li><strong>缓存的位置</strong>: 缓存可以存在于请求链路的多个环节，最常见的是<strong>浏览器缓存</strong>，此外还有代理服务器缓存、CDN 边缘节点缓存等。</li>
<li><strong>核心价值</strong>:<ol>
<li><strong>提升性能，加快加载速度</strong>: 直接从本地磁盘或内存中读取资源，速度远快于通过网络请求。这使得页面加载更快，用户体验更好。</li>
<li><strong>减少网络带宽消耗</strong>: 对于未改变的资源，无需重复下载，节省了用户的流量，也减轻了服务器的带宽压力。</li>
<li><strong>降低服务器负载</strong>: 减少了服务器需要处理的请求数量，让服务器可以更专注于处理动态请求。</li>
</ol>
</li>
</ul>
<p>HTTP 缓存主要分为两大类：<strong>强制缓存</strong>和<strong>协商缓存</strong>。浏览器在请求资源时，会按照以下流程来判断：</p>
<ol>
<li>先检查本地是否有该资源的<strong>强制缓存</strong>，并且缓存是否有效（未过期）。<ul>
<li>如果<strong>有效</strong>，则直接使用缓存，不向服务器发送任何请求。这个过程非常快，HTTP 状态码是 <code>200 OK (from memory cache / from disk cache)</code>。</li>
</ul>
</li>
<li>如果强制缓存<strong>无效</strong>（不存在或已过期），则进入<strong>协商缓存</strong>阶段。<ul>
<li>浏览器向服务器发送一个包含特定验证头部的请求。</li>
<li>服务器根据这些头部判断资源是否有更新。<ul>
<li>如果<strong>无更新</strong>，服务器返回 <code>304 Not Modified</code> 响应，不包含响应体。浏览器使用本地的旧缓存。</li>
<li>如果有<strong>更新</strong>，服务器返回 <code>200 OK</code> 响应，并附带全新的资源内容。浏览器使用新资源并更新本地缓存。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-2-强制缓存"><a href="#3-2-强制缓存" class="headerlink" title="3.2 强制缓存"></a>3.2 强制缓存</h3><p>强制缓存也叫强缓存，是当缓存有效时，浏览器<strong>无需向服务器发送任何请求</strong>，直接使用本地副本。控制强制缓存的主要是两个响应头：<code>Expires</code> 和 <code>Cache-Control</code>。</p>
<ul>
<li><strong><code>Expires</code> (HTTP&#x2F;1.0)</strong><ul>
<li><strong>作用</strong>: 指定一个<strong>绝对的过期时间</strong>。</li>
<li><strong>格式</strong>: <code>Expires: Wed, 21 Oct 2025 07:28:00 GMT</code></li>
<li><strong>工作方式</strong>: 浏览器会将这个过期时间与客户端的当前时间进行比较。如果当前时间还没到过期时间，就命中强制缓存。</li>
<li><strong>缺点</strong>:<ul>
<li><strong>依赖客户端时间</strong>: 如果用户本地的系统时间不准确，可能会导致缓存提前失效或永远不失效。</li>
<li>格式复杂，可读性差。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>Cache-Control: max-age=&lt;seconds&gt;</code> (HTTP&#x2F;1.1)</strong><ul>
<li><strong>作用</strong>: 指定一个<strong>相对的存活时间</strong>，单位是秒。</li>
<li><strong>格式</strong>: <code>Cache-Control: max-age=3600</code> (表示资源在被获取后的 3600 秒内有效)。</li>
<li><strong>工作方式</strong>: 浏览器记录下资源被获取的时间点，之后每次判断时，只需检查 <code>(当前时间 - 获取时间)</code> 是否超过了 <code>max-age</code>。</li>
<li><strong>优点</strong>: 不依赖客户端时间，更加精确可靠。</li>
<li><strong>优先级</strong>: <strong>如果 <code>Cache-Control: max-age</code> 和 <code>Expires</code> 同时存在，<code>Cache-Control</code> 的优先级更高。</strong></li>
</ul>
</li>
<li><strong><code>Cache-Control</code> 的其他常用指令</strong>:<ul>
<li><code>public</code>: 表明响应可以被任何缓存（包括浏览器、代理服务器）缓存。</li>
<li><code>private</code>: 表明响应只能被单个用户的浏览器缓存，不能被共享缓存（如代理服务器）缓存。</li>
<li><code>no-cache</code>: <strong>不是不缓存！</strong> 它的意思是，你可以缓存这个资源，但每次使用前<strong>必须</strong>去服务器进行<strong>协商缓存</strong>验证，不能直接使用强制缓存。</li>
<li><code>no-store</code>: <strong>这才是真正的不缓存！</strong> 指示浏览器和代理服务器完全不要缓存这个响应的任何内容。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-3-协商缓存"><a href="#3-3-协商缓存" class="headerlink" title="3.3 协商缓存"></a>3.3 协商缓存</h3><p>当强制缓存失效后（或被设置为 <code>no-cache</code>），浏览器会向服务器发起一个“条件请求”，由服务器来判断资源是否真的发生了变化。这个过程就是协商缓存。它通过两组成对的请求&#x2F;响应头来实现。</p>
<p><strong>第一组：<code>Last-Modified</code> &amp; <code>If-Modified-Since</code></strong></p>
<ol>
<li><p><strong>首次响应</strong>: 服务器在响应头中包含 <code>Last-Modified</code> 字段，表示资源在服务器上的最后修改时间。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Tue, 15 Nov 2022 12:45:26 GMT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后续请求</strong>: 浏览器在下次请求该资源时，会在请求头中带上 <code>If-Modified-Since</code> 字段，其值就是上次服务器返回的 <code>Last-Modified</code> 的值。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-Modified-Since</span><span class="punctuation">: </span>Tue, 15 Nov 2022 12:45:26 GMT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>服务器判断</strong>:</p>
<ul>
<li>服务器比较 <code>If-Modified-Since</code> 的时间和资源的当前最后修改时间。</li>
<li>如果时间<strong>一致</strong>，说明资源未变，返回 <code>304 Not Modified</code>。</li>
<li>如果时间<strong>不一致</strong>，说明资源已更新，返回 <code>200 OK</code>，并附带新的资源和新的 <code>Last-Modified</code> 时间。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>缺点</strong>:<ul>
<li><strong>时间精度问题</strong>: <code>Last-Modified</code> 只能精确到秒。如果一个文件在 1 秒内被多次修改，服务器无法感知到变化。</li>
<li><strong>内容未变但时间变了</strong>: 有时文件内容没变，但元数据（如被重新保存）变了，<code>Last-Modified</code> 也会更新，导致不必要的传输。</li>
</ul>
</li>
</ul>
<p><strong>第二组：<code>ETag</code> &amp; <code>If-None-Match</code> (更优的方案)</strong></p>
<p>为了解决 <code>Last-Modified</code> 的问题，HTTP&#x2F;1.1 引入了 ETag。</p>
<ol>
<li><p><strong>首次响应</strong>: 服务器在响应头中包含 <code>ETag</code> 字段。ETag 是资源的一个唯一标识符，像一个“指纹”或“版本号”。它可以是文件内容的哈希值、版本 ID 等。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后续请求</strong>: 浏览器在下次请求时，会在请求头中带上 <code>If-None-Match</code> 字段，其值就是上次服务器返回的 <code>ETag</code> 的值。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-None-Match</span><span class="punctuation">: </span>&quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>服务器判断</strong>:</p>
<ul>
<li>服务器比较 <code>If-None-Match</code> 的值和资源当前的 ETag 值。</li>
<li>如果值<strong>一致</strong>，说明资源未变，返回 <code>304 Not Modified</code>。</li>
<li>如果值<strong>不一致</strong>，说明资源已更新，返回 <code>200 OK</code>，并附带新的资源和新的 <code>ETag</code> 值。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>优点</strong>:<ul>
<li><strong>精度高</strong>: 只要资源内容有任何变化，ETag 就会改变。</li>
<li><strong>解决了 <code>Last-Modified</code> 的所有问题</strong>。</li>
</ul>
</li>
<li><strong>优先级</strong>: <strong>如果 <code>ETag</code> 和 <code>Last-Modified</code> 同时存在，<code>ETag</code> 的优先级更高。</strong></li>
</ul>
<hr>
<h3 id="3-4-用户操作对缓存的影响"><a href="#3-4-用户操作对缓存的影响" class="headerlink" title="3.4 用户操作对缓存的影响"></a>3.4 用户操作对缓存的影响</h3><p>用户的不同刷新操作会向浏览器发送不同的缓存策略指令，从而影响缓存的行为。</p>
<ol>
<li><strong>地址栏回车 &#x2F; 点击链接 &#x2F; 前进后退按钮</strong><ul>
<li><strong>行为</strong>: 这是最常规的页面访问方式。</li>
<li><strong>缓存策略</strong>: 浏览器会严格按照上述流程，<strong>先检查强制缓存，再检查协商缓存</strong>。这是缓存机制最有效的场景。</li>
</ul>
</li>
<li><strong>F5 刷新 &#x2F; 点击刷新按钮</strong><ul>
<li><strong>行为</strong>: 用户希望看到页面的最新状态。</li>
<li><strong>缓存策略</strong>: 浏览器会<strong>跳过强制缓存</strong>，直接发起协商缓存。</li>
<li>具体表现是，请求头中会加入 <code>Cache-Control: max-age=0</code> 或 <code>Cache-Control: no-cache</code>。这意味着浏览器会向服务器发送 <code>If-Modified-Since</code> 或 <code>If-None-Match</code> 来验证资源是否过期。如果资源未变，服务器返回 <code>304</code>。</li>
</ul>
</li>
<li><strong>Ctrl + F5 强制刷新 (或 Cmd+Shift+R)</strong><ul>
<li><strong>行为</strong>: 用户希望彻底地、无条件地从服务器获取最新的资源，忽略所有本地缓存。</li>
<li><strong>缓存策略</strong>: 浏览器会<strong>同时跳过强制缓存和协商缓存</strong>。</li>
<li>具体表现是，请求头中<strong>不会包含</strong> <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 字段。服务器无法进行协商，只能无条件地返回 <code>200 OK</code> 和完整的资源内容。</li>
</ul>
</li>
</ol>
<p><strong>总结表</strong></p>
<table>
<thead>
<tr>
<th>用户操作</th>
<th>强制缓存检查</th>
<th>协商缓存检查</th>
<th>典型请求头</th>
</tr>
</thead>
<tbody><tr>
<td><strong>地址栏回车&#x2F;链接跳转</strong></td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
<td>(无特殊头部)</td>
</tr>
<tr>
<td><strong>F5 刷新</strong></td>
<td><strong>否</strong></td>
<td><strong>是</strong></td>
<td><code>Cache-Control: max-age=0</code>, <code>If-None-Match</code>, …</td>
</tr>
<tr>
<td><strong>Ctrl+F5 强制刷新</strong></td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
<td>(无 <code>If-None-Match</code> 等协商缓存头部)</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-内容协商"><a href="#4-内容协商" class="headerlink" title="4. 内容协商"></a>4. 内容协商</h2><p>内容协商是指客户端和服务器之间就如何为给定资源选择最佳表示形式（representation）而进行“协商”的过程。同一个资源可以有多种不同的表示，例如：</p>
<ul>
<li><strong>不同语言的版本</strong>: 同一篇文章可以有英文版、中文版。</li>
<li><strong>不同内容格式的版本</strong>: 同一份数据可以提供 HTML 格式（用于浏览器展示）和 JSON 格式（用于 API 调用）。</li>
<li><strong>不同压缩格式的版本</strong>: 同一个文件可以用 <code>gzip</code> 压缩，也可以用 <code>br</code> 压缩。</li>
</ul>
<p>内容协商机制使得服务器可以根据客户端声明的能力和偏好，从这些版本中选择最合适的一个返回。</p>
<hr>
<h3 id="4-1-客户端通过-Accept-系列头部声明期望格式"><a href="#4-1-客户端通过-Accept-系列头部声明期望格式" class="headerlink" title="4.1 客户端通过 Accept-\* 系列头部声明期望格式"></a>4.1 客户端通过 <code>Accept-\*</code> 系列头部声明期望格式</h3><p>协商的发起方是客户端。客户端通过在 HTTP 请求中加入一系列 <code>Accept-*</code> 头部，来告知服务器它能理解和偏好哪些类型的资源表示。</p>
<p>这些头部通常使用<strong>质量值 (quality value)</strong>，即 <code>q</code> 因子，来表示偏好程度。<code>q</code> 的取值范围是 0 到 1（0 表示不接受，1 表示最偏好），权重越高，代表客户端越希望得到该格式。如果不指定 <code>q</code> 值，默认为 1.0。</p>
<p><strong>常用 <code>Accept-\*</code> 头部详解</strong></p>
<table>
<thead>
<tr>
<th>头部 (Header)</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Accept</code></strong></td>
<td>声明客户端可以理解的 <strong>MIME 类型</strong>。</td>
<td><code>text/html, application/json;q=0.9, */*;q=0.8</code></td>
</tr>
<tr>
<td><strong><code>Accept-Language</code></strong></td>
<td>声明客户端偏好的<strong>自然语言</strong>。</td>
<td><code>fr-CH, fr;q=0.9, en;q=0.8, de;q=0.7, *;q=0.5</code></td>
</tr>
<tr>
<td><strong><code>Accept-Encoding</code></strong></td>
<td>声明客户端支持的<strong>内容压缩编码</strong>算法。</td>
<td><code>gzip, deflate, br</code></td>
</tr>
</tbody></table>
<p><strong>1. <code>Accept</code>: MIME 类型协商</strong></p>
<ul>
<li><strong>作用</strong>: 告诉服务器客户端能够处理哪些媒体类型（也称 MIME 类型）。</li>
<li><strong>示例分析</strong>: <code>Accept: text/html, application/xhtml+xml, application/xml;q=0.9, image/webp, */*;q=0.8</code><ul>
<li><code>text/html</code>, <code>application/xhtml+xml</code>, <code>image/webp</code>: 客户端最希望接收这些类型（<code>q</code> 默认为 1.0）。</li>
<li><code>application/xml</code>: 也能接受，但偏好度稍低（<code>q=0.9</code>）。</li>
<li><code>*/*</code>: <code>*</code> 是通配符，<code>*/*</code> 表示能接受任何类型，但这是最后的选择，偏好度最低（<code>q=0.8</code>）。</li>
</ul>
</li>
<li><strong>应用场景</strong>:<ul>
<li>浏览器访问网页时，会优先请求 <code>text/html</code>。</li>
<li>一个 AJAX 请求可能优先请求 <code>application/json</code>。</li>
</ul>
</li>
</ul>
<p><strong>2. <code>Accept-Language</code>: 语言协商</strong></p>
<ul>
<li><strong>作用</strong>: 告诉服务器客户端偏好的语言。</li>
<li><strong>示例分析</strong>: <code>Accept-Language: zh-CN, zh;q=0.9, en-US;q=0.8, en;q=0.7</code><ul>
<li><code>zh-CN</code>: 客户端最偏好中国大陆的简体中文。</li>
<li><code>zh;q=0.9</code>: 其次是任何种类的中文。</li>
<li><code>en-US;q=0.8</code>: 再次是美式英语。</li>
<li><code>en;q=0.7</code>: 最后是任何种类的英语。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 国际化网站（如 Google, Apple）会根据这个头部，自动为用户展示对应语言的页面。</li>
</ul>
<p><strong>3. <code>Accept-Encoding</code>: 压缩编码协商</strong></p>
<ul>
<li><strong>作用</strong>: 告诉服务器客户端支持哪些解压缩算法，以便服务器可以对响应体进行压缩，减少传输大小。</li>
<li><strong>示例分析</strong>: <code>Accept-Encoding: gzip, deflate, br</code><ul>
<li>客户端告诉服务器，它能解压 <code>gzip</code>, <code>deflate</code>, <code>br</code> 这三种格式的数据。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 现代浏览器都支持多种压缩算法。服务器会选择其中一种（通常是压缩率最高的 <code>br</code> 或最通用的 <code>gzip</code>）来压缩响应，并通过 <code>Content-Encoding</code> 响应头告知客户端。</li>
</ul>
<hr>
<h3 id="4-2-服务器如何根据请求头选择最佳表示"><a href="#4-2-服务器如何根据请求头选择最佳表示" class="headerlink" title="4.2 服务器如何根据请求头选择最佳表示"></a>4.2 服务器如何根据请求头选择最佳表示</h3><p>服务器在收到带有 <code>Accept-*</code> 头部的请求后，会执行以下逻辑来决定返回哪种表示：</p>
<ol>
<li><strong>解析 <code>Accept-\*</code> 头部</strong>: 服务器首先读取并解析客户端发送的所有内容协商相关的头部，了解客户端的能力和偏好（包括 <code>q</code> 值）。</li>
<li><strong>检查可用表示</strong>: 服务器检查对于请求的 URL，它自己拥有哪些可用的资源表示。<ul>
<li>例如，对于 <code>/article/123</code> 这个资源，服务器可能有：<ul>
<li><code>article.en.html</code> (英文 HTML)</li>
<li><code>article.fr.html</code> (法文 HTML)</li>
<li><code>article.en.json</code> (英文 JSON)</li>
<li>并且服务器配置了 <code>gzip</code> 和 <code>br</code> 压缩能力。</li>
</ul>
</li>
</ul>
</li>
<li><strong>匹配与选择</strong>: 服务器将客户端的偏好列表与自己的可用列表进行匹配，寻找<strong>质量值最高的最佳匹配项</strong>。<ul>
<li>服务器会遍历 <code>Accept-Language</code>, <code>Accept</code>, <code>Accept-Encoding</code> 等头部。</li>
<li>它会计算每个可用表示的“总得分”，并选择得分最高的那个。</li>
<li>例如，如果客户端请求 <code>Accept-Language: fr;q=1.0, en;q=0.8</code>，服务器会优先选择法文版本。</li>
</ul>
</li>
<li><strong>准备响应</strong>: 一旦确定了最佳表示，服务器就：<ul>
<li>准备相应的资源内容。</li>
<li>使用协商好的压缩算法（如果有）对响应体进行压缩。</li>
<li>在<strong>响应头部</strong>中设置相应的 <code>Content-*</code> 字段，明确告知客户端它最终发送的是什么版本：<ul>
<li><strong><code>Content-Type</code></strong>: 告知最终的 MIME 类型。</li>
<li><strong><code>Content-Language</code></strong>: 告知最终的语言。</li>
<li><strong><code>Content-Encoding</code></strong>: 告知使用的压缩算法。</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理无法匹配的情况</strong>: 如果服务器没有任何表示能够满足客户端的 <code>Accept-*</code> 要求（例如，客户端只接受 <code>image/gif</code>，但服务器只有 <code>image/jpeg</code>），服务器会返回一个 <code>406 Not Acceptable</code> 状态码，表示无法提供可接受的表示。但在实际应用中，很多服务器会忽略 <code>Accept</code> 头，直接返回一个默认的表示（如 <code>text/html</code>），以避免给用户展示错误页面。</li>
</ol>
<p><strong>一个完整的例子</strong></p>
<ol>
<li><p><strong>客户端请求</strong> (一个希望看法文页面，支持 Brotli 压缩的浏览器)</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/news</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>fr, en;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>服务器的可用资源与能力</strong></p>
<ul>
<li>语言: 有 <code>fr</code> 和 <code>en</code> 两个版本的 <code>/news</code> 页面。</li>
<li>MIME 类型: 只有 <code>text/html</code>。</li>
<li>压缩: 支持 <code>gzip</code> 和 <code>br</code>。</li>
</ul>
</li>
<li><p><strong>服务器的决策过程</strong></p>
<ul>
<li><strong>语言</strong>: 客户端最偏好 <code>fr</code> (q&#x3D;1.0)，服务器正好有，选择 <code>fr</code>。</li>
<li><strong>MIME 类型</strong>: 客户端最偏好 <code>text/html</code> (q&#x3D;1.0)，服务器有，选择 <code>text/html</code>。</li>
<li><strong>编码</strong>: 客户端支持 <code>br</code>，服务器也支持，<code>br</code> 通常效率更高，选择 <code>br</code>。</li>
</ul>
</li>
<li><p><strong>服务器最终的响应</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Language</span><span class="punctuation">: </span>fr</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>br</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept-Encoding, Accept-Language</span><br><span class="line"></span><br><span class="line"><span class="language-jboss-cli"><span class="string">...</span> <span class="params">(经过 br 压缩的、法文版的 HTML 内容)</span> <span class="string">...</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong><code>Vary</code> 头部</strong></p>
<p>注意上面响应中的 <code>Vary</code> 头部。这是一个非常重要的响应头，它告诉缓存服务器（如代理、CDN），对于同一个 URL，服务器的响应内容会<strong>因</strong>（Vary on）请求头中的 <code>Accept-Encoding</code> 和 <code>Accept-Language</code> 字段的不同而不同。缓存服务器必须将 URL 和这些请求头组合起来作为缓存的 key，以避免将法文版的页面错误地返回给一个请求英文版的用户。</p>
<hr>
<h1 id="五、HTTP-安全：从-HTTP-到-HTTPS-Security"><a href="#五、HTTP-安全：从-HTTP-到-HTTPS-Security" class="headerlink" title="五、HTTP 安全：从 HTTP 到 HTTPS (Security)"></a>五、HTTP 安全：从 HTTP 到 HTTPS (Security)</h1><h2 id="1-HTTP-的安全风险"><a href="#1-HTTP-的安全风险" class="headerlink" title="1. HTTP 的安全风险"></a>1. HTTP 的安全风险</h2><p>HTTP 协议以<strong>明文 (Plaintext)</strong> 的方式在客户端和服务器之间传输数据。这意味着，任何能够截获这条通信链路的中间方（如同一 Wi-Fi下的黑客、网络运营商、路由器等），都可以轻易地读取、修改甚至冒充通信内容。这主要带来了以下三大风险：</p>
<hr>
<h3 id="1-1-窃听风险-Eavesdropping-：通信内容为明文"><a href="#1-1-窃听风险-Eavesdropping-：通信内容为明文" class="headerlink" title="1.1 窃听风险 (Eavesdropping)：通信内容为明文"></a>1.1 窃听风险 (Eavesdropping)：通信内容为明文</h3><ul>
<li><strong>核心问题</strong>: HTTP 报文（包括请求头、请求体、响应头、响应体）在网络中传输时，完全没有经过任何加密。它们就像一张张写满了内容的“明信片”。</li>
<li><strong>工作原理</strong>: 当你通过一个公共 Wi-Fi（如咖啡馆、机场）访问一个 <code>http://</code> 网站时，你的数据包会经过多个网络节点才到达目标服务器。攻击者只需在其中任何一个节点上使用抓包工具（如 Wireshark），就能完整地截获并阅读你的所有通信内容。</li>
<li><strong>具体危害</strong>:<ul>
<li><strong>密码泄露</strong>: 在非加密的登录页面输入用户名和密码，攻击者可以直接看到你的账号密码。</li>
<li><strong>个人信息泄露</strong>: 提交包含姓名、身份证号、手机号、银行卡号的表单，这些信息都会被暴露。</li>
<li><strong>会话劫持</strong>: 许多网站使用 Cookie 来维持登录状态。如果 Cookie 被窃听，攻击者就可以利用这个 Cookie 冒充你，直接访问你的账户，无需知道密码。</li>
<li><strong>隐私暴露</strong>: 攻击者可以知道你正在浏览哪些网页、搜索了什么关键词、看了哪些商品。</li>
</ul>
</li>
</ul>
<p><strong>图解窃听风险</strong>:</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant 客户端 as 你的电脑
    participant 攻击者
    participant 服务器 as 网站服务器

    rect rgb(255, 224, 224)
        Note over 客户端,服务器: 传输通道: 不安全的网络 (如公共Wi-Fi)
        客户端-&gt;&gt;服务器: 发送明文数据 (账号: user, 密码: 123)
    end

    Note right of 攻击者: 监听并轻易截获&lt;br&gt;明文数据 user/123</code></pre>

<hr>
<h3 id="1-2-篡改风险-Tampering-：内容可被中间人修改"><a href="#1-2-篡改风险-Tampering-：内容可被中间人修改" class="headerlink" title="1.2 篡改风险 (Tampering)：内容可被中间人修改"></a>1.2 篡改风险 (Tampering)：内容可被中间人修改</h3><ul>
<li><strong>核心问题</strong>: 由于 HTTP 没有验证机制来确保数据的完整性，中间人不仅能窃听，还能在数据传输过程中<strong>任意修改</strong>内容，而通信的双方毫不知情。</li>
<li><strong>工作原理</strong>: 攻击者截获你的 HTTP 报文后，可以先不转发，而是修改其中的内容，然后再发送给真正的目的地。例如，修改服务器返回给你的网页内容，或者修改你发送给服务器的请求数据。</li>
<li><strong>具体危害</strong>:<ul>
<li><strong>植入广告&#x2F;恶意软件</strong>: 这是最常见的篡改。攻击者可以在你正常浏览的网页中强行插入弹窗广告、色情内容，甚至下载恶意软件的 JavaScript 脚本，导致你的电脑中毒。</li>
<li><strong>篡改下载文件</strong>: 你从一个官方网站下载软件，攻击者在传输途中将其替换为带病毒的版本。</li>
<li><strong>钓鱼攻击</strong>: 将你访问银行网站的请求，不知不觉地重定向到一个假的银行网站，或者在真实的网页上把登录表单的目标地址改成攻击者的服务器。</li>
<li><strong>修改交易信息</strong>: 修改你向服务器发送的转账请求，将收款人账号改成攻击者自己的账号。</li>
</ul>
</li>
</ul>
<p><strong>图解篡改风险</strong>:</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant 客户端 as 你的电脑
    participant 攻击者
    participant 服务器 as 网站服务器

    Note over 客户端,服务器: 用户发起正常的网页请求
    客户端-&gt;&gt;服务器: 请求网页 (GET /)

    rect rgb(255, 224, 224)
        Note over 攻击者: 攻击者位于通信链路中间
        服务器--&gt;&gt;攻击者: 1. 发送真实的网页
        Note over 攻击者: 截获并篡改内容&lt;br&gt;(插入广告/病毒脚本)
        攻击者--&gt;&gt;客户端: 2. 发送伪造的网页
    end

    Note over 客户端: 用户收到并渲染了被篡改的页面，&lt;br&gt;可能导致信息泄露或电脑中毒。</code></pre>

<hr>
<h3 id="1-3-冒充风险-Impersonation-：无法验证通信双方身份"><a href="#1-3-冒充风险-Impersonation-：无法验证通信双方身份" class="headerlink" title="1.3 冒充风险 (Impersonation)：无法验证通信双方身份"></a>1.3 冒充风险 (Impersonation)：无法验证通信双方身份</h3><ul>
<li><strong>核心问题</strong>: HTTP 协议中没有任何机制来验证通信对方的身份。客户端无法确认它正在对话的服务器就是它想访问的那个；同样，服务器也无法确认发起请求的客户端就是它所声称的那个。</li>
<li><strong>工作原理</strong>: 攻击者可以搭建一个伪装的服务器，并冒充成一个合法的网站（如银行网站）。通过 DNS 劫持等手段，当你尝试访问真正的银行网站时，你的请求被导向了这个假冒的服务器。由于界面一模一样，你很难分辨真伪。</li>
<li><strong>类比</strong>: <strong>电信诈骗</strong>。<br>你接到一个电话，对方声称是银行客服，要求你提供银行卡号和密码。你无法确认电话那头的人是否真的是银行客服，他很可能是一个冒充的骗子。</li>
<li><strong>具体危害</strong>:<ul>
<li><strong>钓鱼网站 (Phishing)</strong>: 这是冒充风险最直接、最危险的应用。用户在假冒的网站上输入敏感信息（如账号密码、支付信息），这些信息会直接被攻击者获取。这是前面两种风险的综合体现：攻击者<strong>冒充</strong>了服务器，然后对你输入的信息进行<strong>窃听</strong>。</li>
<li><strong>恶意服务器</strong>: 客户端（如一个 App）可能会被引导连接到一个恶意服务器，该服务器可以下发错误的指令或窃取 App 发送的数据。</li>
</ul>
</li>
</ul>
<p><strong>图解冒充风险 (钓鱼攻击)</strong>:</p>
<pre><code class="highlight mermaid">graph TD
    subgraph &quot;用户视角&quot;
        C[&quot;客户端&lt;br&gt;(你的电脑)&quot;]
    end

    subgraph &quot;攻击者的陷阱&quot;
        style FakeBank fill:#ffcccc,stroke:#333,stroke-width:2px
        FakeBank[&quot;假·银行服务器&lt;br&gt;fakebank.com&lt;br&gt;界面与真银行一模一样&quot;] --&gt; Attacker&#123;攻击者&lt;br&gt;获取账号密码&#125;
    end

    subgraph &quot;真实世界&quot;
        style RealBank fill:#cceeff,stroke:#333,stroke-width:2px
        RealBank[(&quot;真·银行服务器&lt;br&gt;realbank.com&quot;)]
        Note(用户本想访问这里) --&gt; RealBank
    end

    C -- &quot;以为在访问真银行...&quot; --&gt; FakeBank
    C -- &quot;DNS劫持/点击钓鱼链接&quot; --&gt; FakeBank</code></pre>

<p><strong>总结</strong>:</p>
<p>这三大风险——<strong>窃听、篡改、冒充</strong>——是环环相扣的。正是因为 HTTP 的明文、无校验、无身份认证的特性，才使得互联网早期充满了不安全感。为了解决这三大问题，<strong>HTTPS (HTTP Secure)</strong> 应运而生，它通过引入 SSL&#x2F;TLS 协议层，提供了<strong>加密、完整性校验和身份认证</strong>三大核心能力，从根本上保障了网络通信的安全。</p>
<hr>
<h2 id="2-HTTPS-是什么？"><a href="#2-HTTPS-是什么？" class="headerlink" title="2. HTTPS 是什么？"></a>2. HTTPS 是什么？</h2><p>在理解了 HTTP 的三大安全风险（窃听、篡改、冒充）之后，解决方案便呼之欲出——我们需要一个能够加密数据、防止篡改并能验证身份的协议。这个解决方案就是 <strong>HTTPS</strong>。</p>
<hr>
<h3 id="2-1-HTTPS-HTTP-SSL-TLS"><a href="#2-1-HTTPS-HTTP-SSL-TLS" class="headerlink" title="2.1 HTTPS &#x3D; HTTP + SSL&#x2F;TLS"></a>2.1 HTTPS &#x3D; HTTP + SSL&#x2F;TLS</h3><p>HTTPS 的全称是 <strong>Hypertext Transfer Protocol Secure</strong>，即“<strong>安全超文本传输协议</strong>”。</p>
<p>从字面意思上看，它就是 HTTP 的“安全版”。但它并不是一个全新的应用层协议，而是在原有的 HTTP 协议基础上，增加了一层安全层。这个安全层就是 <strong>SSL&#x2F;TLS</strong> 协议。</p>
<p>我们可以用一个简单的公式来理解它的结构：</p>
<p><strong>HTTPS &#x3D; HTTP + SSL&#x2F;TLS</strong></p>
<p>这个公式揭示了 HTTPS 的工作模式：</p>
<ul>
<li><strong>HTTP 协议本身没有改变</strong>: 请求行、请求头、请求体，以及响应行、响应头、响应体的格式和语义都和原来一样。</li>
<li><strong>增加了一个“安全壳”</strong>: HTTP 报文在发送前，不再是直接交给 TCP 层，而是先经过 SSL&#x2F;TLS 协议层进行“加密”和“打包”。</li>
<li><strong>通信过程</strong>:<ol>
<li><strong>应用层 (HTTP)</strong>: 浏览器准备好一个标准的 HTTP 请求报文。</li>
<li><strong>表示层&#x2F;安全层 (SSL&#x2F;TLS)</strong>: 这个 HTTP 报文被完整地交给 SSL&#x2F;TLS 协议处理。SSL&#x2F;TLS 会对整个报文进行加密，并附加一些用于验证完整性的信息（如 MAC 值）。</li>
<li><strong>传输层 (TCP)</strong>: SSL&#x2F;TLS 将加密后的数据包交给 TCP 层进行分段和传输。</li>
</ol>
</li>
</ul>
<p><strong>网络协议栈中的位置</strong>：</p>
<p>如果说 HTTP 直接运行在 TCP 之上，那么 HTTPS 就是运行在 SSL&#x2F;TLS 之上，而 SSL&#x2F;TLS 又运行在 TCP 之上。SSL&#x2F;TLS 就像一个插入到 HTTP 和 TCP 之间的“安全中间件”。</p>
<p><strong>HTTP 的通信模型</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|   HTTP        | (应用层)</span><br><span class="line">+---------------+</span><br><span class="line">|   TCP         | (传输层)</span><br><span class="line">+---------------+</span><br><span class="line">|   IP          | (网络层)</span><br><span class="line">+---------------+</span><br><span class="line">|   Data Link   | (数据链路层)</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure>

<p><strong>HTTPS 的通信模型</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|   HTTP        | (应用层)</span><br><span class="line">+---------------+</span><br><span class="line">|   SSL/TLS     | (安全层) &lt;-- 新增的安全层</span><br><span class="line">+---------------+</span><br><span class="line">|   TCP         | (传输层)</span><br><span class="line">+---------------+</span><br><span class="line">|   IP          | (网络层)</span><br><span class="line">+---------------+</span><br><span class="line">|   Data Link   | (数据链路层)</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure>

<p><strong>SSL (Secure Sockets Layer)</strong> 和 <strong>TLS (Transport Layer Security)</strong> 的关系:</p>
<ul>
<li>SSL 是由网景公司 (Netscape) 在 1990 年代发明的。</li>
<li>TLS 是 SSL 的标准化和升级版本。</li>
<li>SSL 3.0 之后，IETF 接管并发布了 TLS 1.0。目前，SSL 协议已因安全漏洞被弃用，我们现在所说的 SSL&#x2F;TLS 通常指的就是 TLS 协议 (目前主流版本是 TLS 1.2 和 1.3)。</li>
</ul>
<hr>
<h3 id="2-2-SSL-TLS-的作用：加密、身份验证、数据完整性"><a href="#2-2-SSL-TLS-的作用：加密、身份验证、数据完整性" class="headerlink" title="2.2 SSL&#x2F;TLS 的作用：加密、身份验证、数据完整性"></a>2.2 SSL&#x2F;TLS 的作用：加密、身份验证、数据完整性</h3><p>SSL&#x2F;TLS 协议通过一套复杂的握手流程和加密算法，精准地解决了 HTTP 的三大安全风险。它提供了以下三个核心安全保证：</p>
<h4 id="2-2-1-数据加密-Confidentiality-解决窃听风险"><a href="#2-2-1-数据加密-Confidentiality-解决窃听风险" class="headerlink" title="2.2.1 数据加密 (Confidentiality) - 解决窃听风险"></a>2.2.1 数据加密 (Confidentiality) - 解决窃听风险</h4><ul>
<li><strong>作用</strong>: 将应用层（HTTP）传输的数据进行加密，使得中间人即使截获了数据，也无法读懂其内容。</li>
<li><strong>实现方式</strong>: SSL&#x2F;TLS 采用<strong>混合加密 (Hybrid Encryption)</strong> 的方式。<ul>
<li>在<strong>握手阶段</strong>，使用<strong>非对称加密</strong>（如 RSA, ECDHE）来安全地协商出一个<strong>对称密钥</strong>。这个过程慢但安全。</li>
<li>在<strong>握手结束后的通信阶段</strong>，使用这个对称密钥和<strong>对称加密</strong>算法（如 AES, ChaCha20）来加密所有的 HTTP 报文。这个过程快而高效。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-2-身份验证-Authentication-解决冒充风险"><a href="#2-2-2-身份验证-Authentication-解决冒充风险" class="headerlink" title="2.2.2 身份验证 (Authentication) - 解决冒充风险"></a>2.2.2 身份验证 (Authentication) - 解决冒充风险</h4><ul>
<li><strong>作用</strong>: 验证通信对方的身份，确保你正在访问的确实是你想访问的服务器（如真正的银行网站），而不是一个假冒的钓鱼网站。</li>
<li><strong>实现方式</strong>: 主要通过 <strong>数字证书 (Digital Certificate)</strong> 和 <strong>数字签名 (Digital Signature)</strong> 实现。<ul>
<li>服务器会持有一个由权威的 <strong>证书颁发机构 (Certificate Authority, CA)</strong> 签发的数字证书。</li>
<li>这个证书包含了服务器的公钥、域名信息，以及 CA 对这些信息真实性的<strong>数字签名</strong>。</li>
<li>客户端（浏览器）内置了所有受信任的 CA 的根证书。当收到服务器证书时，浏览器会用对应的 CA 根证书来验证该证书的签名是否有效，以及证书中的域名是否与当前访问的域名匹配。如果验证通过，就证明服务器的身份是可信的。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-3-数据完整性校验-Integrity-解决篡改风险"><a href="#2-2-3-数据完整性校验-Integrity-解决篡改风险" class="headerlink" title="2.2.3 数据完整性校验 (Integrity) - 解决篡改风险"></a>2.2.3 数据完整性校验 (Integrity) - 解决篡改风险</h4><ul>
<li><strong>作用</strong>: 确保数据在传输过程中没有被中间人篡改。</li>
<li><strong>实现方式</strong>: 通过 <strong>消息认证码 (Message Authentication Code, MAC)</strong> 实现。<ul>
<li>发送方在发送数据时，会使用协商好的对称密钥和哈希算法（如 SHA-256）对原始数据计算出一个 MAC 值，并将其附加在加密数据包的末尾。</li>
<li>接收方收到数据后，先解密得到原始数据，然后用同样的方法独立计算出一个 MAC 值。</li>
<li>最后，比较自己计算出的 MAC 值和接收到的 MAC 值是否完全一致。<ul>
<li>如果一致，说明数据在传输过程中是完整的，未被篡改。</li>
<li>如果不一致，说明数据已被篡改，接收方会立即丢弃该数据包并中止连接。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>: HTTPS 通过在 HTTP 和 TCP 之间增加 SSL&#x2F;TLS 安全层，利用<strong>加密</strong>技术对抗<strong>窃听</strong>，利用<strong>身份验证</strong>技术对抗<strong>冒充</strong>，利用<strong>完整性校验</strong>技术对抗<strong>篡改</strong>，从而为我们的网络通信构建起一道坚实的安全防线。</p>
<hr>
<h2 id="3-SSL-TLS-握手过程"><a href="#3-SSL-TLS-握手过程" class="headerlink" title="3. SSL&#x2F;TLS 握手过程"></a>3. SSL&#x2F;TLS 握手过程</h2><p>SSL&#x2F;TLS 握手过程可以看作是通信双方在正式“加密对话”前的一系列“暗号对接”和“身份确认”步骤。整个过程涉及多次往返通信，主要可以分为以下四个阶段。</p>
<hr>
<h3 id="3-1-阶段一：客户端发起请求-Client-Hello"><a href="#3-1-阶段一：客户端发起请求-Client-Hello" class="headerlink" title="3.1 阶段一：客户端发起请求 (Client Hello)"></a>3.1 阶段一：客户端发起请求 (Client Hello)</h3><p>这是握手的开始。当你在浏览器地址栏输入 <code>https://www.google.com</code> 并回车时，浏览器（客户端）会向服务器的 443 端口发起一个 TCP 连接，连接建立后，立即发送第一个 TLS 报文，即 <strong><code>Client Hello</code></strong>。</p>
<p><code>Client Hello</code> 报文中包含了客户端希望与服务器沟通所需的所有信息，主要内容如下：</p>
<ul>
<li><strong>支持的 TLS 版本号</strong>: 客户端告诉服务器它最高支持哪个版本的 TLS 协议（如 TLS 1.2, TLS 1.3）。</li>
<li><strong>一个客户端生成的随机数 (Client Random)</strong>: 这是一个 32 字节的随机数，稍后将用于生成最终的会话密钥。</li>
<li><strong>支持的密码套件 (Cipher Suites) 列表</strong>: 这是<strong>最关键</strong>的信息之一。密码套件定义了一整套加密方案，包括：<ul>
<li>密钥交换算法 (如 <code>RSA</code>, <code>ECDHE</code>)</li>
<li>对称加密算法 (如 <code>AES_128_GCM</code>, <code>CHACHA20_POLY1305</code>)</li>
<li>哈希算法 (如 <code>SHA256</code>)<br>客户端会把自己支持的所有套件按偏好顺序列出来，让服务器从中选择一个。</li>
</ul>
</li>
<li><strong>支持的压缩算法列表</strong>: 客户端告诉服务器它支持哪些压缩方法（现在通常不使用）。</li>
</ul>
<hr>
<h3 id="3-2-阶段二：服务器响应与证书下发"><a href="#3-2-阶段二：服务器响应与证书下发" class="headerlink" title="3.2 阶段二：服务器响应与证书下发"></a>3.2 阶段二：服务器响应与证书下发</h3><p>服务器收到 <code>Client Hello</code> 后，会从中选择一套双方都支持的加密方案，并准备好自己的身份证明，然后向客户端发回一系列报文。</p>
<p>这一阶段通常包含三个报文：</p>
<ol>
<li><strong><code>Server Hello</code></strong>:<ul>
<li><strong>确认的 TLS 版本号</strong>: 服务器从客端支持的版本中选择一个自己也支持的最高版本。</li>
<li><strong>一个服务器生成的随机数 (Server Random)</strong>: 同样是一个 32 字节的随机数，也用于生成会话密钥。</li>
<li><strong>确认的密码套件</strong>: 服务器从客户端的列表中选择一个自己也支持且安全性较高的密码套件。</li>
</ul>
</li>
<li><strong><code>Certificate</code></strong>:<ul>
<li><strong>服务器的数字证书</strong>: 这是<strong>服务器身份的证明</strong>。服务器会将其证书（或证书链）发送给客户端。这个证书中包含了<strong>服务器的公钥</strong>、域名信息以及 CA 的签名。</li>
</ul>
</li>
<li><strong><code>Server Hello Done</code></strong>:<ul>
<li>一个简单的通知报文，告诉客户端：“好了，我这边该说的都说完了，该你了。”</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-3-阶段三：客户端验证证书、生成密钥"><a href="#3-3-阶段三：客户端验证证书、生成密钥" class="headerlink" title="3.3 阶段三：客户端验证证书、生成密钥"></a>3.3 阶段三：客户端验证证书、生成密钥</h3><p>客户端收到服务器的响应后，会执行一系列关键操作：</p>
<ol>
<li><strong>验证证书 (Authentication)</strong>:<ul>
<li>客户端会检查证书的<strong>有效期</strong>是否过期。</li>
<li>检查证书中的<strong>域名</strong>是否与当前正在访问的域名一致。</li>
<li>最重要的是，使用操作系统或浏览器内置的<strong>受信任的 CA 根证书</strong>，来验证服务器证书的数字签名是否真实有效。如果证书链中的任何一环验证失败，浏览器就会弹出“不安全”的警告。</li>
<li>如果证书验证通过，客户端就确认了服务器的身份是可信的，并从证书中<strong>取出了服务器的公钥</strong>。</li>
</ul>
</li>
<li><strong>生成预主密钥 (Pre-Master Secret)</strong>:<ul>
<li>客户端再生成一个<strong>第三个随机数</strong>，称为“<strong>预主密钥 (Pre-Master Secret)</strong>”。这个随机数是后续对称密钥的“种子”。</li>
</ul>
</li>
<li><strong>用服务器公钥加密预主密钥</strong>:<ul>
<li>为了安全地把这个预主密钥告诉服务器，客户端会使用刚刚从证书中获取的<strong>服务器公钥</strong>，对这个预主密钥进行<strong>非对称加密</strong>。</li>
<li>加密后的结果，只有持有<strong>服务器私钥</strong>的服务器才能解开。这就保证了即使被中间人截获，也无法得到预主密钥。</li>
</ul>
</li>
<li><strong>发送 <code>Client Key Exchange</code></strong>:<ul>
<li>客户端将这个<strong>加密后的预主密钥</strong>放在 <code>Client Key Exchange</code> 报文中发送给服务器。</li>
</ul>
</li>
<li><strong>生成会话密钥与发送 <code>Change Cipher Spec</code> 和 <code>Finished</code></strong>:<ul>
<li>此时，客户端同时拥有了三个关键的随机数：<strong>Client Random</strong>, <strong>Server Random</strong>, <strong>Pre-Master Secret</strong>。</li>
<li>客户端使用这三个随机数，通过一个<strong>伪随机函数 (PRF)</strong>，“计算”出本次会话所使用的<strong>对称密钥（也称会话密钥，Session Key）</strong>。</li>
<li>然后，客户端发送一个 <strong><code>Change Cipher Spec</code></strong> 报文，通知服务器：“我准备好了，从现在开始，我们都用刚算出来的对称密钥来加密通信了！”</li>
<li>紧接着，客户端会发送一个 <strong><code>Finished</code></strong> 报文。这个报文是<strong>第一个使用新生成的对称密钥加密</strong>的报文，它包含了之前所有握手消息的哈希值。服务器可以用它来验证握手过程是否被篡改。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-4-阶段四：服务器确认，建立安全通道"><a href="#3-4-阶段四：服务器确认，建立安全通道" class="headerlink" title="3.4 阶段四：服务器确认，建立安全通道"></a>3.4 阶段四：服务器确认，建立安全通道</h3><p>服务器收到客户端发来的一系列报文后，进行最后的工作：</p>
<ol>
<li><strong>解密预主密钥</strong>:<ul>
<li>服务器收到 <code>Client Key Exchange</code> 报文后，使用自己的<strong>私钥</strong>解密，得到客户端发送的<strong>预主密钥 (Pre-Master Secret)</strong>。</li>
</ul>
</li>
<li><strong>生成会话密钥</strong>:<ul>
<li>此时，服务器也拥有了 <strong>Client Random</strong>, <strong>Server Random</strong>, <strong>Pre-Master Secret</strong> 这三个相同的随机数。</li>
<li>服务器使用<strong>完全相同</strong>的伪随机函数，计算出与客户端一模一样的<strong>会话密钥</strong>。</li>
</ul>
</li>
<li><strong>验证与回应</strong>:<ul>
<li>服务器收到客户端的 <code>Change Cipher Spec</code> 后，也切换到使用新的会话密钥进行加密和解密。</li>
<li>服务器使用新的会话密钥解密客户端发来的 <code>Finished</code> 报文，并验证其中的哈希值是否正确。如果正确，说明握手过程未被篡改。</li>
<li>验证通过后，服务器也发送一个 <strong><code>Change Cipher Spec</code></strong> 和一个用新密钥加密的 <strong><code>Finished</code></strong> 报文给客户端，作为最终的确认。</li>
</ul>
</li>
</ol>
<p><strong>握手结束，加密通信开始</strong>:</p>
<p>客户端收到服务器的 <code>Finished</code> 报文并成功解密验证后，TLS 握手过程正式完成。此时，双方都已经拥有了相同的、安全的会话密钥。后续的所有 HTTP 请求和响应，都会使用这个会话密钥进行对称加密，从而建立起一条<strong>安全的数据通道</strong>。</p>
<p><strong>图解总结 (TLS 1.2 RSA 握手)</strong>:</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client as 客户端
    participant Server as 服务器

    %% 1. Client Hello
    Client-&gt;&gt;Server: Client Hello
    note right of Client: TLS版本, ClientRandom, 密码套件

    %% 2. Server Hello &amp; Certificate
    Server-&gt;&gt;Client: Server Hello, Certificate, Server Hello Done
    note left of Server: 确认版本, ServerRandom, 确认套件, 服务器证书+公钥

    %% 3. 客户端处理并发送密钥
    activate Client
    note over Client: 1. 验证证书，取出公钥&lt;br/&gt;2. 生成 Pre-Master Secret&lt;br/&gt;3. 用公钥加密 Pre-Master Secret&lt;br/&gt;4. 根据三个随机数生成会话密钥
    
    Client-&gt;&gt;Server: Client Key Exchange (加密后的 Pre-Master Secret)
    Client-&gt;&gt;Server: Change Cipher Spec
    Client-&gt;&gt;Server: Finished (Encrypted)
    deactivate Client

    %% 4. 服务器处理并确认
    activate Server
    note over Server: 1. 用私钥解密，得到 Pre-Master Secret&lt;br/&gt;2. 根据三个随机数生成会话密钥&lt;br/&gt;3. 解密并验证 Finished

    Server-&gt;&gt;Client: Change Cipher Spec
    Server-&gt;&gt;Client: Finished (Encrypted)
    deactivate Server

    %% 5. 握手结束
    Note over Client,Server: 握手结束

    %% 6. 加密通信
    Client-&gt;&gt;Server: Encrypted Application Data (HTTP)
    Server-&gt;&gt;Client: Encrypted Application Data (HTTP)</code></pre>



<p><strong>关于 TLS 1.3 的简化</strong>:</p>
<p>TLS 1.3 对握手过程进行了大幅简化和优化，将握手时间从 2-RTT（两次往返）减少到了 1-RTT，甚至在某些情况下可以实现 0-RTT，极大地提升了 HTTPS 的性能。但其核心思想——安全地协商密钥和验证身份——依然不变。</p>
<hr>
<h2 id="4-常见的-Web-安全威胁"><a href="#4-常见的-Web-安全威胁" class="headerlink" title="4. 常见的 Web 安全威胁"></a>4. 常见的 Web 安全威胁</h2><p>即使使用了 HTTPS 确保了传输层的安全，应用层的漏洞依然可能导致严重的安全问题。以下是三种最常见且与 HTTP 机制紧密相关的 Web 安全威胁。</p>
<hr>
<h3 id="4-1-跨站脚本-XSS-Cross-Site-Scripting"><a href="#4-1-跨站脚本-XSS-Cross-Site-Scripting" class="headerlink" title="4.1 跨站脚本 (XSS - Cross-Site Scripting)"></a>4.1 跨站脚本 (XSS - Cross-Site Scripting)</h3><ul>
<li><strong>攻击原理</strong>:<br>XSS 攻击的核心是<strong>将恶意的 JavaScript 脚本注入到受信任的网页中</strong>，当其他用户访问这个网页时，这些恶意脚本就会在他们的浏览器中执行。攻击者利用的是网站对用户输入内容的<strong>盲目信任和未充分过滤</strong>。</li>
<li><strong>类比</strong>: <strong>在公共留言板上贴小广告</strong>。<br>一个网站有一个留言板，正常用户会在上面写下“今天天气真好”。攻击者却在留言内容中偷偷夹带了一段恶意脚本，比如 <code>&lt;script&gt;alert(&#39;你被攻击了！&#39;)&lt;/script&gt;</code>。当网站展示这条留言时，没有对 <code>&lt;script&gt;</code> 标签进行处理，直接将其作为 HTML 的一部分输出。其他用户浏览器在渲染页面时，就会执行这段脚本。</li>
<li><strong>攻击类型</strong>:<ol>
<li><strong>存储型 XSS</strong>: 恶意脚本被<strong>永久存储</strong>在服务器的数据库中（如文章、评论、用户资料）。每当有用户请求包含该内容的页面时，攻击就会发生。危害最大。</li>
<li><strong>反射型 XSS</strong>: 恶意脚本包含在 URL 的参数中。攻击者通常会诱骗用户点击一个构造好的恶意链接，例如 <code>http://example.com/search?q=&lt;script&gt;...&lt;/script&gt;</code>。服务器将 URL 中的参数直接反射到响应页面中，导致脚本执行。这种攻击是一次性的。</li>
<li><strong>DOM 型 XSS</strong>: 攻击不经过服务器，完全在客户端发生。恶意脚本通过修改页面的 DOM（文档对象模型）结构来触发，例如通过 URL 的片段标识符（<code>#</code>）注入。</li>
</ol>
</li>
<li><strong>危害</strong>:<ul>
<li><strong>窃取 Cookie</strong>: <code>document.cookie</code> 可以获取用户的 Cookie，攻击者可以利用它劫持用户会话，冒充用户身份。</li>
<li><strong>键盘记录</strong>: 监听用户的键盘输入，窃取密码、银行卡等敏感信息。</li>
<li><strong>页面篡改</strong>: 修改网页内容，植入广告、钓鱼表单。</li>
<li><strong>发起恶意请求</strong>: 利用用户的身份向网站发送恶意请求（如删除文章、转账）。</li>
</ul>
</li>
<li><strong>HTTP 相关的防御手段</strong>:<ol>
<li><strong><code>Content-Type</code> 响应头</strong>:<ul>
<li>正确设置 <code>Content-Type</code>（如 <code>application/json</code>, <code>text/plain</code>）并配合 <code>X-Content-Type-Options: nosniff</code> 头部，可以防止浏览器错误地将本应是数据的响应解析为 HTML，从而执行其中的脚本。</li>
</ul>
</li>
<li><strong><code>Content-Security-Policy</code> (CSP) 响应头</strong>:<ul>
<li>这是<strong>防御 XSS 最强大、最现代的手段</strong>。CSP 允许网站管理员定义一个“白名单”，明确告知浏览器哪些来源的脚本、样式、图片等资源是可信的，可以被加载和执行。</li>
<li><strong>示例</strong>: <code>Content-Security-Policy: script-src &#39;self&#39; https://apis.google.com</code></li>
<li>这条策略告诉浏览器：只允许执行来自<strong>同源</strong>（<code>&#39;self&#39;</code>）和 <code>httpsis.google.com</code> 的脚本。任何来自其他地方的脚本（包括内联脚本和 <code>eval</code>）都会被直接阻止。</li>
<li>CSP 能够有效地从根本上杜绝大部分 XSS 攻击。</li>
</ul>
</li>
<li><strong><code>HttpOnly</code> Cookie 属性</strong>:<ul>
<li>在 <code>Set-Cookie</code> 时加上 <code>HttpOnly</code> 标志，可以防止客户端 JavaScript 访问该 Cookie。这使得即使 XSS 攻击成功，攻击者也无法通过 <code>document.cookie</code> 窃取用于会话管理的敏感 Cookie。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-2-跨站请求伪造-CSRF-Cross-Site-Request-Forgery"><a href="#4-2-跨站请求伪造-CSRF-Cross-Site-Request-Forgery" class="headerlink" title="4.2 跨站请求伪造 (CSRF - Cross-Site Request Forgery)"></a>4.2 跨站请求伪造 (CSRF - Cross-Site Request Forgery)</h3><ul>
<li><strong>攻击原理</strong>:<br>CSRF 攻击的核心是<strong>利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义发送恶意的 HTTP 请求</strong>。攻击者并不窃取信息，而是<strong>伪造请求</strong>去执行某些操作（如转账、修改密码、发帖）。</li>
<li><strong>类比</strong>: <strong>冒用你的名义写信</strong>。<br>你（用户）已经登录了你的银行网站 (<code>bank.com</code>)，你的浏览器保存了 <code>bank.com</code> 的登录 Cookie。这时，你收到了一个邮件，里面有一个诱人的链接：“点击查看可爱猫咪图片”。你点击后，进入了一个恶意网站 <code>evil.com</code>。这个网站的页面中隐藏了一个自动提交的表单，其目标地址是银行的转账接口，例如：<br><code>&lt;form action=&quot;https://bank.com/transfer&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;to&quot; value=&quot;attacker_account&quot;&gt; ... &lt;/form&gt;</code><br>当你的浏览器加载这个页面时，会自动提交这个表单。因为请求的目标是 <code>bank.com</code>，浏览器会<strong>自动带上</strong>你之前保存的 <code>bank.com</code> 的 <strong>Cookie</strong>。银行服务器收到这个请求后，检查 Cookie，发现你是合法的登录用户，于是执行了转账操作。整个过程你完全不知情。</li>
<li><strong>关键前提</strong>:<ol>
<li>用户已登录目标网站，且浏览器存有该网站的 Cookie。</li>
<li>用户访问了攻击者构造的恶意页面。</li>
<li>目标网站的敏感操作接口没有对请求来源进行充分验证。</li>
</ol>
</li>
<li><strong>HTTP 相关的防御手段</strong>:<ol>
<li><strong><code>SameSite</code> Cookie 属性</strong>:<ul>
<li>这是<strong>防御 CSRF 最有效、最简单的现代方法</strong>。通过在 <code>Set-Cookie</code> 头部设置 <code>SameSite</code> 属性，可以控制 Cookie 在跨站请求中的发送行为。</li>
<li><code>SameSite=Strict</code>: 完全禁止第三方请求携带 Cookie。在任何从外部网站发起的请求中，Cookie 都不会被发送。防御效果最好，但可能影响某些正常的跨站跳转体验。</li>
<li><code>SameSite=Lax</code>: (现代浏览器默认值) 在大多数跨站请求中（如 <code>POST</code> 表单、<code>&lt;img&gt;</code>、AJAX），不发送 Cookie。但在一些顶层导航（如点击链接 <code>&lt;a&gt;</code>）的 <code>GET</code> 请求中会发送。能防御绝大多数 CSRF 攻击。</li>
<li><code>SameSite=None</code>: 允许在任何跨站请求中发送 Cookie。必须配合 <code>Secure</code> 属性使用。</li>
</ul>
</li>
<li><strong>验证 <code>Origin</code> 和 <code>Referer</code> 请求头</strong>:<ul>
<li>服务器可以检查请求头中的 <code>Origin</code> (指示请求的来源域) 或 <code>Referer</code> (指示请求来源的完整 URL)。如果这些值不是来自可信的域名列表，就拒绝该请求。这是一种简单有效的补充手段。</li>
</ul>
</li>
<li><strong>使用 CSRF Token</strong>:<ul>
<li>在 <code>SameSite</code> 属性普及之前，这是最主流的防御方式。服务器在用户访问表单页面时，生成一个随机的、一次性的 Token，并将其隐藏在表单中。当用户提交表单时，这个 Token 会一起发送到服务器。服务器在处理请求前，会验证这个 Token 是否与自己之前下发的一致。由于攻击者无法获取这个随机 Token，他构造的恶意请求中就不包含合法的 Token，从而被服务器拒绝。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-3-CORS-跨源资源共享"><a href="#4-3-CORS-跨源资源共享" class="headerlink" title="4.3 CORS (跨源资源共享)"></a>4.3 CORS (跨源资源共享)</h3><p>CORS 本身不是一种攻击，而是一种<strong>安全机制</strong>，用于解决浏览器的<strong>同源策略 (Same-Origin Policy, SOP)</strong> 带来的限制。</p>
<ul>
<li><strong>同源策略 (SOP)</strong>:<ul>
<li>这是浏览器最核心、最重要的安全策略。它规定，一个源（<code>origin</code>）的网页脚本，在没有明确授权的情况下，不能访问来自另一个源的资源。</li>
<li><strong>源 (Origin)</strong> 由 <strong>协议 (Scheme) + 主机 (Host) + 端口 (Port)</strong> 三者共同定义。只要有一个不同，就是<strong>跨源 (Cross-Origin)</strong>。</li>
<li>SOP 主要限制的是<strong>脚本发起的 HTTP 请求</strong>（如 AJAX），而像 <code>&lt;img&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;iframe&gt;</code> 等标签的资源加载不受此限制（但脚本也无法读取这些标签加载的跨源内容）。</li>
</ul>
</li>
<li><strong>为什么需要 CORS?</strong>:<br>随着 Web 应用的发展（尤其是前后端分离架构和 API 的兴起），跨源请求变得非常普遍（例如，<code>app.com</code> 的前端代码需要请求 <code>api.com</code> 的数据）。为了在保证安全的前提下实现这种合法的跨源访问，CORS 机制应运而生。</li>
<li><strong>CORS 工作原理</strong>:<br>CORS 是一种基于 <strong>HTTP 头部</strong>的机制，它允许服务器声明哪些源站有权限访问其资源。它将跨源请求分为两类：<ol>
<li><strong>简单请求 (Simple Requests)</strong>:<ul>
<li>满足一定条件的请求（如 <code>GET</code>, <code>HEAD</code>, <code>POST</code> 方法，且 <code>Content-Type</code> 为特定值等）被视为简单请求。</li>
<li>浏览器直接发送请求，并在请求头中自动加入 <code>Origin</code> 字段，表明请求来源。</li>
<li>服务器收到请求后，检查 <code>Origin</code> 值。如果该来源被允许，服务器就在响应头中加入 <code>Access-Control-Allow-Origin: &lt;origin&gt;</code> 或 <code>*</code>。</li>
<li>浏览器检查响应头，如果 <code>Access-Control-Allow-Origin</code> 存在且匹配，就将响应数据交给 JavaScript 处理；否则，就拦截响应，并在控制台报错。</li>
</ul>
</li>
<li><strong>非简单请求 (Preflighted Requests)</strong>:<ul>
<li>不满足简单请求条件的请求（如 <code>PUT</code>, <code>DELETE</code> 方法，或带有自定义请求头），在发送实际请求之前，浏览器会先自动发送一个<strong>预检请求 (Preflight Request)</strong>。</li>
<li><strong>预检请求</strong>使用 <code>OPTIONS</code> 方法，并包含 <code>Access-Control-Request-Method</code> (实际请求的方法) 和 <code>Access-Control-Request-Headers</code> (实际请求的自定义头部) 等头部。</li>
<li>服务器收到预检请求后，根据其策略决定是否允许接下来的实际请求，并通过一系列 <code>Access-Control-Allow-*</code> 响应头（如 <code>Access-Control-Allow-Origin</code>, <code>Access-Control-Allow-Methods</code>, <code>Access-Control-Allow-Headers</code>）来告知浏览器。</li>
<li>如果预检通过，浏览器才会发送真正的、包含业务数据的实际请求。如果预检失败，则实际请求不会被发送。</li>
</ul>
</li>
</ol>
</li>
<li><strong>核心 CORS 响应头</strong>:<ul>
<li><code>Access-Control-Allow-Origin</code>: <strong>必需</strong>。指定允许访问的源。</li>
<li><code>Access-Control-Allow-Methods</code>: 在预检响应中使用，指定允许的 HTTP 方法。</li>
<li><code>Access-control-Allow-Headers</code>: 在预检响应中使用，指定允许的自定义请求头。</li>
<li><code>Access-Control-Allow-Credentials</code>: <code>true</code> 或 <code>false</code>。指示是否允许跨域请求携带 Cookie。</li>
<li><code>Access-Control-Max-Age</code>: 指定预检请求结果的缓存时间（秒）。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、HTTP-的演进"><a href="#六、HTTP-的演进" class="headerlink" title="六、HTTP 的演进"></a>六、HTTP 的演进</h1><h2 id="1-HTTP-1-0-的时代"><a href="#1-HTTP-1-0-的时代" class="headerlink" title="1. HTTP&#x2F;1.0 的时代"></a>1. HTTP&#x2F;1.0 的时代</h2><p>HTTP&#x2F;1.0 在 1996 年通过 RFC 1945 正式发布，它是第一个被广泛应用的 HTTP 版本。这个版本的协议设计相对简单，主要目标是满足当时以“图文”为主的网页浏览需求。其核心设计理念是“一次请求-一次响应”，反映了早期 Web 的简单交互模式。</p>
<hr>
<h3 id="1-1-核心特性与局限性"><a href="#1-1-核心特性与局限性" class="headerlink" title="1.1 核心特性与局限性"></a>1.1 核心特性与局限性</h3><h4 id="1-1-1-短连接-Short-lived-Connections"><a href="#1-1-1-短连接-Short-lived-Connections" class="headerlink" title="1.1.1 短连接 (Short-lived Connections)"></a>1.1.1 短连接 (Short-lived Connections)</h4><ul>
<li><strong>特性</strong>: 这是 HTTP&#x2F;1.0 最显著的特点。默认情况下，每一个 HTTP 请求都需要建立一个新的 TCP 连接。在服务器返回响应后，该 TCP 连接会立即关闭。</li>
<li><strong>流程</strong>:<ol>
<li>浏览器请求 <code>index.html</code> -&gt; 建立 TCP 连接 -&gt; 请求 -&gt; 响应 -&gt; <strong>关闭 TCP 连接</strong>。</li>
<li>页面中有一张图片 <code>image.jpg</code> -&gt; 建立新的 TCP 连接 -&gt; 请求 -&gt; 响应 -&gt; <strong>关闭 TCP 连接</strong>。</li>
<li>页面中有一个 CSS 文件 <code>style.css</code> -&gt; 建立新的 TCP 连接 -&gt; 请求 -&gt; 响应 -&gt; <strong>关闭 TCP 连接</strong>。</li>
</ol>
</li>
<li><strong>局限性 (性能瓶颈)</strong>:<ul>
<li><strong>高延迟</strong>: TCP 连接的建立（三次握手）和关闭（四次挥手）本身就需要消耗网络往返时间 (RTT)。对于一个包含大量小文件（图片、脚本）的网页，这种开销会迅速累积，导致页面加载速度非常慢。</li>
<li><strong>服务器压力大</strong>: 频繁地创建和销毁连接，对服务器的 CPU 和内存资源造成了巨大压力。</li>
<li><strong>慢启动惩罚</strong>: TCP 协议有一个“慢启动”机制，即新建立的连接会从一个较低的传输速率开始，然后逐渐提升。短连接意味着每个请求都必须重新经历这个慢启动过程，无法利用已经“热身”完毕的连接，传输效率低下。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-2-无-Host-头部-No-Host-Header"><a href="#1-1-2-无-Host-头部-No-Host-Header" class="headerlink" title="1.1.2 无 Host 头部 (No Host Header)"></a>1.1.2 无 Host 头部 (No Host Header)</h4><ul>
<li><p><strong>特性</strong>: 在最初的 HTTP&#x2F;1.0 设计中，请求报文中并<strong>没有 <code>Host</code> 头部</strong>。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 一个典型的 HTTP/1.0 请求</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.0</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>NCSA_Mosaic/2.0</span><br></pre></td></tr></table></figure>

<p>请求行中的路径 <code>/index.html</code> 是相对路径，没有指明目标服务器的域名。</p>
</li>
<li><p><strong>局限性</strong>:</p>
<ul>
<li><strong>无法实现虚拟主机 (Virtual Hosting)</strong>: 这意味着<strong>一台服务器（一个 IP 地址）只能托管一个网站</strong>。因为当服务器收到一个请求时，它无法知道客户端想要访问的是哪个域名下的资源。这在 IP 地址资源日益紧张的背景下，是极大的浪费。</li>
<li><strong>背景</strong>: 在互联网早期，域名和 IP 地址几乎是一一对应的，所以这个问题并不突出。但随着 Web 的发展，一个 IP 托管多个网站的需求变得非常迫切。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-3-有限的缓存能力"><a href="#1-1-3-有限的缓存能力" class="headerlink" title="1.1.3 有限的缓存能力"></a>1.1.3 有限的缓存能力</h4><ul>
<li><strong>特性</strong>: HTTP&#x2F;1.0 引入了初步的缓存控制机制，主要通过以下两个头部：<ul>
<li><strong><code>Expires</code> (响应头)</strong>: 服务器通过一个绝对的过期时间来告诉浏览器缓存的有效期。</li>
<li><strong><code>If-Modified-Since</code> (请求头) &#x2F; <code>Last-Modified</code> (响应头)</strong>: 用于实现协商缓存。</li>
</ul>
</li>
<li><strong>局限性</strong>:<ul>
<li><code>Expires</code> 依赖于客户端本地时间，如果客户端时间不准，缓存策略就会出错。</li>
<li><code>Last-Modified</code> 的时间精度只能到秒，并且对于内容没变但元数据变动的情况无法正确处理。</li>
<li>缓存控制的指令不够丰富和灵活。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-4-简单的请求方法"><a href="#1-1-4-简单的请求方法" class="headerlink" title="1.1.4 简单的请求方法"></a>1.1.4 简单的请求方法</h4><ul>
<li><strong>特性</strong>: HTTP&#x2F;1.0 主要定义了三个请求方法：<ul>
<li><code>GET</code>: 获取资源。</li>
<li><code>POST</code>: 提交数据。</li>
<li><code>HEAD</code>: 获取资源的元信息（头部）。</li>
</ul>
</li>
<li><strong>局限性</strong>: 缺少 <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code>, <code>OPTIONS</code> 等更精细化的操作方法，这使得通过 HTTP 实现符合 RESTful 风格的 API 变得困难。开发者常常需要通过 <code>POST</code> 请求来模拟更新和删除操作。</li>
</ul>
<hr>
<h3 id="1-2-HTTP-1-0-的“改进”与过渡"><a href="#1-2-HTTP-1-0-的“改进”与过渡" class="headerlink" title="1.2 HTTP&#x2F;1.0 的“改进”与过渡"></a>1.2 HTTP&#x2F;1.0 的“改进”与过渡</h3><p>面对上述种种局限，特别是由短连接和无 Host 头带来的严重问题，社区和浏览器厂商在 HTTP&#x2F;1.0 的后期进行了一些非正式的扩展，为向 HTTP&#x2F;1.1 过渡铺平了道路。</p>
<ul>
<li><p><strong><code>Connection: Keep-Alive</code></strong>:</p>
<ul>
<li>一些浏览器和服务器开始支持一个非官方的 <code>Connection: Keep-Alive</code> 头部。</li>
<li>如果客户端在请求中加入这个头部，并且服务器也支持，那么服务器在响应后就不会立即关闭 TCP 连接，从而实现了<strong>长连接（或称持久连接）</strong>。</li>
<li>这大大缓解了短连接带来的性能问题，是 HTTP 性能优化的一个里程碑。</li>
</ul>
</li>
<li><p><strong><code>Host</code> 头部的引入</strong>:</p>
<ul>
<li>为了解决虚拟主机的问题，<code>Host</code> 头部被作为 HTTP&#x2F;1.0 的一个扩展引入，并最终在 HTTP&#x2F;1.1 中成为<strong>必需</strong>的头部。</li>
<li>有了 <code>Host</code> 头部，客户端可以在请求中明确指出要访问的域名，服务器便可以根据这个域名将请求分发到对应的网站。</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 一个带 Host 头的 HTTP/1.0 请求</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.0</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>NCSA_Mosaic/2.0</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="2-HTTP-1-1-至今仍是主流"><a href="#2-HTTP-1-1-至今仍是主流" class="headerlink" title="2. HTTP&#x2F;1.1 (至今仍是主流)"></a>2. HTTP&#x2F;1.1 (至今仍是主流)</h2><p>HTTP&#x2F;1.1 并非对 HTTP&#x2F;1.0 的推倒重来，而是一次意义重大的<strong>增强和完善</strong>。它的设计目标非常明确：<strong>在保持协议简单性的同时，大幅提升性能、可扩展性和功能性</strong>。</p>
<hr>
<h3 id="2-1-主要改进"><a href="#2-1-主要改进" class="headerlink" title="2.1 主要改进"></a>2.1 主要改进</h3><p>HTTP&#x2F;1.1 的核心改进可以概括为以下几点，它们几乎都是针对 HTTP&#x2F;1.0 的痛点进行优化的。</p>
<h4 id="2-1-1-默认长连接-Persistent-Connections"><a href="#2-1-1-默认长连接-Persistent-Connections" class="headerlink" title="2.1.1 默认长连接 (Persistent Connections)"></a>2.1.1 默认长连接 (Persistent Connections)</h4><ul>
<li><strong>改进点</strong>: 这是 HTTP&#x2F;1.1 <strong>最重要的性能改进</strong>。它将 HTTP&#x2F;1.0 中需要手动开启的 <code>Keep-Alive</code> 机制，变为了<strong>默认行为</strong>。</li>
<li><strong>工作方式</strong>: 除非在请求或响应中明确包含 <code>Connection: close</code> 头部，否则 TCP 连接在一次请求-响应周期后会保持打开状态，以便后续的请求可以<strong>复用</strong>这条连接。</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>减少延迟</strong>: 避免了为每个资源都重新进行 TCP 三次握手的开销。</li>
<li><strong>提升效率</strong>: 允许 TCP 连接进入“热身”状态，利用 TCP 慢启动结束后的高速传输阶段。</li>
<li><strong>降低资源消耗</strong>: 减少了客户端和服务器因频繁创建和销毁连接而产生的 CPU 和内存负担。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-2-管道化-Pipelining"><a href="#2-1-2-管道化-Pipelining" class="headerlink" title="2.1.2 管道化 (Pipelining)"></a>2.1.2 管道化 (Pipelining)</h4><ul>
<li><strong>改进点</strong>: 在长连接的基础上，HTTP&#x2F;1.1 引入了“管道化”技术，试图进一步提升效率。</li>
<li><strong>工作方式</strong>: 允许客户端在<strong>收到上一个响应之前</strong>，就连续发送多个 HTTP 请求。这就像把多个请求一次性“塞进”TCP 连接这个管道里，减少了等待响应所浪费的往返时间。<ul>
<li><strong>HTTP&#x2F;1.0 (无管道)</strong>: 请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 …</li>
<li><strong>HTTP&#x2F;1.1 (管道化)</strong>: 请求1, 请求2, 请求3 -&gt; 响应1, 响应2, 响应3 …</li>
</ul>
</li>
<li><strong>致命缺陷 (队头阻塞)</strong>:<ul>
<li>虽然请求可以一起发送，但服务器<strong>必须严格按照接收请求的顺序来返回响应</strong>。</li>
<li>如果第一个请求（如一个复杂的 API 调用）的处理时间很长，那么即使后续请求（如请求一个小图标）已经处理完毕，也必须排队等待第一个响应发送完成。这就是<strong>队头阻塞 (Head-of-Line Blocking)</strong>。</li>
<li>由于队头阻塞问题以及在代理服务器中实现的复杂性，<strong>现代浏览器默认都禁用了管道化</strong>。所以，管道化在理论上是一个进步，但在实践中几乎没有被成功应用。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-3-Host-头部成为必需"><a href="#2-1-3-Host-头部成为必需" class="headerlink" title="2.1.3 Host 头部成为必需"></a>2.1.3 <code>Host</code> 头部成为必需</h4><ul>
<li><p><strong>改进点</strong>: HTTP&#x2F;1.1 强制要求所有请求报文中<strong>必须包含 <code>Host</code> 头部</strong>。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>带来的好处</strong>:</p>
<ul>
<li><strong>正式支持虚拟主机</strong>: 允许多个不同域名的网站托管在同一台服务器（同一个 IP 地址）上。服务器通过检查 <code>Host</code> 头部，就能知道请求是发往哪个网站的，从而返回正确的内容。这极大地节省了宝贵的 IPv4 地址资源，是现代网站托管服务的基石。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-4-更丰富和强大的缓存控制"><a href="#2-1-4-更丰富和强大的缓存控制" class="headerlink" title="2.1.4 更丰富和强大的缓存控制"></a>2.1.4 更丰富和强大的缓存控制</h4><ul>
<li><strong>改进点</strong>: 引入了全新的 <code>Cache-Control</code> 头部，提供了比 HTTP&#x2F;1.0 的 <code>Expires</code> 更加灵活和强大的缓存控制能力。</li>
<li><strong><code>Cache-Control</code> 的优势</strong>:<ul>
<li><strong>相对时间 (<code>max-age</code>)</strong>: 使用相对时间（如 <code>max-age=3600</code>）代替 <code>Expires</code> 的绝对时间，避免了客户端与服务器时间不一致的问题。</li>
<li><strong>丰富的指令</strong>: 提供了 <code>public</code>, <code>private</code>, <code>no-cache</code>, <code>no-store</code>, <code>must-revalidate</code> 等多种指令，让开发者可以对缓存策略进行精细化控制。</li>
</ul>
</li>
<li><strong><code>ETag</code> 的引入</strong>:<ul>
<li>引入 <code>ETag</code> &#x2F; <code>If-None-Match</code> 这一对头部，作为对 <code>Last-Modified</code> &#x2F; <code>If-Modified-Since</code> 的补充和改进。</li>
<li><code>ETag</code> 基于资源内容的“指纹”，能够更精确地判断资源是否发生变化，解决了 <code>Last-Modified</code> 的时间精度和元数据变动问题。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-5-增加新的请求方法和状态码"><a href="#2-1-5-增加新的请求方法和状态码" class="headerlink" title="2.1.5 增加新的请求方法和状态码"></a>2.1.5 增加新的请求方法和状态码</h4><ul>
<li><strong>请求方法</strong>: 新增了 <code>PUT</code>, <code>DELETE</code>, <code>OPTIONS</code>, <code>PATCH</code>, <code>TRACE</code>, <code>CONNECT</code> 等方法，使得 HTTP 协议的功能更加完善，能够更好地支持 RESTful API 等应用场景。</li>
<li><strong>状态码</strong>: 增加了更多状态码，如 <code>201 Created</code>, <code>204 No Content</code> 等用于 API 交互，<code>307 Temporary Redirect</code> 对 <code>302</code> 进行了细化，以及 <code>409 Conflict</code>, <code>410 Gone</code> 等更丰富的错误表示。</li>
</ul>
<hr>
<h4 id="2-1-6-支持分块传输编码-Chunked-Transfer-Encoding"><a href="#2-1-6-支持分块传输编码-Chunked-Transfer-Encoding" class="headerlink" title="2.1.6 支持分块传输编码 (Chunked Transfer Encoding)"></a>2.1.6 支持分块传输编码 (Chunked Transfer Encoding)</h4><ul>
<li><strong>改进点</strong>: 允许服务器在<strong>响应生成的同时</strong>，将内容分成一个个“块 (chunk)”来发送，而无需在发送前知道响应体的总大小。</li>
<li><strong>工作方式</strong>: 通过在响应头中加入 <code>Transfer-Encoding: chunked</code> 来启用。每个块包含块大小和块内容，最后一个块是大小为 0 的“结束块”。</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>支持动态内容</strong>: 对于那些需要服务器实时生成、无法预知最终大小的内容（如数据库查询结果、直播流），可以立即开始传输，提升首字节时间 (TTFB)，改善用户体验。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-核心瓶颈：队头阻塞-HOL-Blocking"><a href="#2-2-核心瓶颈：队头阻塞-HOL-Blocking" class="headerlink" title="2.2 核心瓶颈：队头阻塞 (HOL Blocking)"></a>2.2 核心瓶颈：队头阻塞 (HOL Blocking)</h3><p>尽管 HTTP&#x2F;1.1 带来了巨大的进步，但它的核心模型——<strong>一个 TCP 连接在同一时间只能处理一个请求-响应</strong>——并未改变。这导致了其最主要的性能瓶颈：</p>
<ol>
<li><strong>协议层面的队头阻塞</strong>: 如前所述，管道化技术因服务器必须按序响应而失效。</li>
<li><strong>浏览器层面的变通与限制</strong>: 为了缓解队头阻塞，浏览器通常会为每个域名<strong>并发建立多条（通常是 6-8 条）TCP 连接</strong>。这在一定程度上实现了并行请求，但：<ul>
<li><strong>连接数有限</strong>: 浏览器对同域名的并发连接数有限制，超过限制的请求仍然需要排队。</li>
<li><strong>资源浪费</strong>: 建立和维护这些额外的 TCP 连接本身就是一种开销。</li>
<li><strong>竞争带宽</strong>: 多条 TCP 连接之间会相互竞争网络带宽，可能导致整体效率下降。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-HTTP-2：性能的巨大飞跃"><a href="#3-HTTP-2：性能的巨大飞跃" class="headerlink" title="3. HTTP&#x2F;2：性能的巨大飞跃"></a>3. HTTP&#x2F;2：性能的巨大飞跃</h2><p>HTTP&#x2F;2 的诞生，源于 Google 在 2009 年推出的实验性协议 <strong>SPDY</strong> (读作 “speedy”)。SPDY 的成功实践证明了其核心思想的有效性，最终被采纳为 HTTP&#x2F;2 标准的基础。HTTP&#x2F;2 引入了几个革命性的新特性，从根本上解决了 HTTP&#x2F;1.1 的性能瓶颈。</p>
<hr>
<h3 id="3-1-二进制分帧-Binary-Framing"><a href="#3-1-二进制分帧-Binary-Framing" class="headerlink" title="3.1 二进制分帧 (Binary Framing)"></a>3.1 二进制分帧 (Binary Framing)</h3><ul>
<li><p><strong>核心变革</strong>: 这是 HTTP&#x2F;2 所有其他性能改进的<strong>基础</strong>。HTTP&#x2F;2 不再使用 HTTP&#x2F;1.1 的纯文本格式报文，而是将所有传输的信息分割为更小的<strong>消息 (Message)</strong> 和<strong>帧 (Frame)</strong>，并采用<strong>二进制格式</strong>进行编码。</p>
</li>
<li><p><strong>HTTP&#x2F;1.1 的文本格式</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /resource HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>: 人类可读，调试方便。</li>
<li><strong>缺点</strong>: 格式不紧凑，解析复杂且容易出错（如需要处理空格、换行符等）。</li>
</ul>
</li>
<li><p><strong>HTTP&#x2F;2 的二进制分帧层</strong>:</p>
<ul>
<li><strong>帧 (Frame)</strong>: HTTP&#x2F;2 中数据传输的<strong>最小单位</strong>。每种帧都有不同的类型，承载不同类型的信息，如 <code>HEADERS</code> 帧用于传输头部，<code>DATA</code> 帧用于传输请求&#x2F;响应体。所有帧都共享一个通用的 9 字节帧头，其中包含了帧长度、类型、流标识符等信息。</li>
<li><strong>消息 (Message)</strong>: 逻辑上的 HTTP 请求或响应，由一个或多个帧组成。例如，一个 HTTP 请求消息可以由一个 <code>HEADERS</code> 帧和多个 <code>DATA</code> 帧组成。</li>
<li><strong>流 (Stream)</strong>: 一个存在于 TCP 连接内的<strong>虚拟双向通道</strong>，用于承载一次完整的请求-响应交换。每个流都有一个唯一的 ID。</li>
</ul>
</li>
<li><p><strong>带来的好处</strong>:</p>
<ul>
<li><strong>解析高效且不易出错</strong>: 二进制格式的解析是确定性的，计算机处理起来更快、更简单，不再有解析纯文本时的歧义。</li>
<li><strong>为多路复用铺平道路</strong>: 将数据分解为独立的、带标识的帧，使得在同一连接上交错发送来自不同流的数据成为可能。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-多路复用-Multiplexing"><a href="#3-2-多路复用-Multiplexing" class="headerlink" title="3.2 多路复用 (Multiplexing)"></a>3.2 多路复用 (Multiplexing)</h3><ul>
<li><strong>核心变革</strong>: 这是 HTTP&#x2F;2 <strong>最重要的特性</strong>，它从根本上<strong>解决了 HTTP&#x2F;1.1 的队头阻塞问题</strong>。</li>
<li><strong>工作方式</strong>:<ol>
<li><strong>单一 TCP 连接</strong>: 客户端与服务器之间只需要建立<strong>一条 TCP 连接</strong>，就可以处理所有并发的请求。</li>
<li><strong>并发的流</strong>: 在这条 TCP 连接上，可以同时存在<strong>多个并行的流 (Stream)</strong>。每个流对应一个 HTTP 请求-响应对。</li>
<li><strong>帧的交错传输</strong>: 来自不同流的帧可以<strong>被打乱顺序、交错地</strong>在同一条 TCP 连接中传输。</li>
<li><strong>按流 ID 重组</strong>: 接收方根据帧头中的<strong>流 ID</strong>，将这些乱序的帧重新组合成完整的请求或响应消息。</li>
</ol>
</li>
<li><strong>类比</strong>: <strong>多车道高速公路 vs 单车道</strong>。<ul>
<li><strong>HTTP&#x2F;1.1</strong>: 像一条单车道，一辆慢车（一个慢响应）会堵住后面所有车。</li>
<li><strong>HTTP&#x2F;2</strong>: 像一条拥有多个车道的高速公路。即使某个车道（某个流）上的卡车（大响应）行驶缓慢，其他车道的小汽车（小响应）依然可以畅通无阻地并行前进。所有车辆共享同一条高速公路（同一条 TCP 连接），但互不阻塞。</li>
</ul>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>彻底解决队头阻塞</strong>: 一个请求的阻塞不会影响其他请求的传输。</li>
<li><strong>更高的连接利用率</strong>: 只需一条 TCP 连接即可实现高并发，避免了 HTTP&#x2F;1.1 时代开启多条连接的开销。</li>
<li><strong>性能提升</strong>: 降低了延迟，加快了页面加载速度，尤其是在加载大量小资源的场景下效果显著。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-3-头部压缩-Header-Compression-HPACK"><a href="#3-3-头部压缩-Header-Compression-HPACK" class="headerlink" title="3.3 头部压缩 (Header Compression - HPACK)"></a>3.3 头部压缩 (Header Compression - HPACK)</h3><ul>
<li><strong>核心变革</strong>: 针对 HTTP&#x2F;1.1 中头部信息冗余的问题，HTTP&#x2F;2 引入了专门的 <strong>HPACK 算法</strong>来压缩请求和响应的头部。</li>
<li><strong>HTTP&#x2F;1.1 的问题</strong>:<ul>
<li>在同一连接上，连续的多个请求通常包含大量重复的头部字段（如 <code>Host</code>, <code>User-Agent</code>, <code>Accept</code> 等）。</li>
<li>这些头部以纯文本形式传输，未经压缩，在请求数量多时会带来不小的网络开销，尤其是在上行带宽有限的移动网络中。</li>
</ul>
</li>
<li><strong>HPACK 的工作原理</strong>:<ol>
<li><strong>动态维护共享字典</strong>: 客户端和服务器共同维护一个“头部字典”。</li>
<li><strong>索引化传输</strong>: 对于字典中已有的头部字段（如 <code>User-Agent</code>），后续请求只需发送其<strong>索引号</strong>即可，而无需重复发送完整的字符串。</li>
<li><strong>哈夫曼编码</strong>: 对于新的或不常见的头部值，使用哈夫曼编码进行压缩，进一步减小体积。</li>
</ol>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>大幅减少头部大小</strong>: 显著降低了因头部传输而产生的网络开销，从而降低延迟。</li>
<li><strong>增强安全性</strong>: 由于压缩上下文是与特定连接相关的，这在一定程度上也增加了防范某些头部注入攻击的难度。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-4-服务器推送-Server-Push"><a href="#3-4-服务器推送-Server-Push" class="headerlink" title="3.4 服务器推送 (Server Push)"></a>3.4 服务器推送 (Server Push)</h3><ul>
<li><strong>核心变革</strong>: 允许服务器在<strong>客户端明确请求之前</strong>，就<strong>主动地</strong>将它认为客户端即将需要的资源推送给客户端。</li>
<li><strong>HTTP&#x2F;1.1 的请求模型</strong>: <strong>“拉 (Pull)”</strong> 模型。<br>浏览器必须先请求并解析 <code>index.html</code>，然后才能发现其中引用了 <code>style.css</code> 和 <code>script.js</code>，再发起对这些资源的请求。这个过程至少需要 2 个 RTT 的延迟。</li>
<li><strong>HTTP&#x2F;2 的推送模型</strong>: <strong>“推 (Push)”</strong> 模型。<ol>
<li>客户端请求 <code>index.html</code>。</li>
<li>服务器在返回 <code>index.html</code> 的同时，<strong>预见到</strong>客户端肯定会需要 <code>style.css</code> 和 <code>script.js</code>。</li>
<li>服务器不等客户端请求，就<strong>主动地</strong>将 <code>style.css</code> 和 <code>script.js</code> 的内容通过新的流推送给客户端。</li>
<li>当客户端解析完 <code>index.html</code> 并准备请求这些资源时，发现它们已经存在于本地缓存中了，可以直接使用。</li>
</ol>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>减少关键渲染路径的延迟</strong>: 避免了浏览器解析 HTML 后再发起请求的往返延迟，理论上可以提升页面加载速度。</li>
</ul>
</li>
<li><strong>实践中的挑战</strong>:<ul>
<li>服务器推送在实践中被证明<strong>难以有效利用</strong>。服务器很难精确判断哪些资源是客户端真正需要且本地没有缓存的。如果推送了不必要的资源，反而会浪费带宽。</li>
<li>由于这些复杂性，服务器推送功能并未被广泛采用，甚至在 <strong>HTTP&#x2F;3 中已被提议废弃</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-HTTP-3：面向未来的协议"><a href="#4-HTTP-3：面向未来的协议" class="headerlink" title="4. HTTP&#x2F;3：面向未来的协议"></a>4. HTTP&#x2F;3：面向未来的协议</h2><p>HTTP&#x2F;3 (发布于 2022 年，RFC 9114) 是 HTTP 协议的最新一代。它最大的变革是<strong>放弃了 TCP，转而使用一个全新的、基于 UDP 的传输层协议——QUIC</strong>。</p>
<hr>
<h3 id="4-1-为什么需要-HTTP-3？-TCP-层的队头阻塞"><a href="#4-1-为什么需要-HTTP-3？-TCP-层的队头阻塞" class="headerlink" title="4.1. 为什么需要 HTTP&#x2F;3？(TCP 层的队头阻塞)"></a>4.1. 为什么需要 HTTP&#x2F;3？(TCP 层的队头阻塞)</h3><p>HTTP&#x2F;2 通过多路复用技术，完美地解决了 <strong>HTTP 应用层</strong>的队头阻塞问题。在一条 HTTP&#x2F;2 连接上，一个流的阻塞不会影响其他流。</p>
<p>然而，一个新的、更深层次的瓶颈暴露了出来——<strong>TCP 层的队头阻塞</strong>。</p>
<ul>
<li><strong>问题根源</strong>: HTTP&#x2F;2 的所有流都运行在<strong>一条 TCP 连接</strong>之上。而 TCP 协议本身是一个<strong>可靠的、按序传输</strong>的协议。这意味着，TCP 必须保证所有数据包（Segment）都按顺序到达。</li>
<li><strong>阻塞发生</strong>: 如果在网络传输过程中，一个 TCP 数据包<strong>丢失</strong>了，那么 TCP 协议会启动其重传机制，等待这个丢失的数据包被重新传回。在此期间，即使后续的数据包已经到达了接收端，TCP 的接收缓冲区也<strong>必须等待</strong>，不能将这些数据包交付给上层（HTTP&#x2F;2）。</li>
<li><strong>影响</strong>: 这一个丢失的数据包，就<strong>阻塞了该 TCP 连接上承载的所有 HTTP&#x2F;2 流</strong>。即使丢失的数据包只属于流 A，但流 B、流 C、流 D 的数据也都被卡在了 TCP 层，无法被 HTTP&#x2F;2 层解析。</li>
<li><strong>类比</strong>: <strong>所有货物装在同一辆卡车上</strong>。<ul>
<li>HTTP&#x2F;2 的多路复用，就像是把不同客户的货物（不同的 HTTP 流）都打包好，放进了<strong>同一辆大卡车</strong>（一条 TCP 连接）里运输。</li>
<li>如果这辆卡车在路上因为一个轮胎爆了（一个 TCP 包丢失）而停下修理，那么车上<strong>所有客户的货物</strong>都会被延误，无论他们的货物在车厢的哪个位置。</li>
</ul>
</li>
</ul>
<p>这个问题在网络状况良好时并不明显，但在<strong>高延迟、高丢包率</strong>的网络环境（如移动网络、跨境网络）下，TCP 层的队头阻塞会严重影响 HTTP&#x2F;2 的性能优势。</p>
<hr>
<h3 id="4-2-基于-QUIC-协议-构建于-UDP-之上"><a href="#4-2-基于-QUIC-协议-构建于-UDP-之上" class="headerlink" title="4.2. 基于 QUIC 协议 (构建于 UDP 之上)"></a>4.2. 基于 QUIC 协议 (构建于 UDP 之上)</h3><p>为了从根本上解决 TCP 层的队头阻塞，HTTP&#x2F;3 做出了一个大胆的决定：<strong>将传输层从 TCP 换成 QUIC</strong>。</p>
<ul>
<li><p><strong>QUIC (Quick UDP Internet Connections)</strong>:</p>
<ul>
<li>QUIC 是由 Google 开发的一个全新的传输层协议，它“站在了 UDP 的肩膀上”。</li>
<li><strong>UDP (User Datagram Protocol)</strong> 是一个非常基础、“不靠谱”的传输协议。它不保证数据包的顺序，也不保证数据包一定能到达（会丢包），没有重传机制。</li>
<li>QUIC 的巧妙之处在于，它利用了 UDP 的“简单”特性（没有 TCP 那些固有的限制），然后在<strong>应用层（QUIC 自己的协议栈内）</strong>，重新实现了 TCP 的那些可靠性功能，如<strong>流量控制、拥塞控制、可靠传输</strong>等，并且做得更好。</li>
</ul>
</li>
<li><p><strong>HTTP&#x2F;3 的新架构</strong>:<br><code>HTTP/3 = HTTP/2 的语义 + QUIC</code></p>
<p><strong>协议栈对比</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1          HTTP/2            HTTP/3</span><br><span class="line">+---------+         +---------+         +---------+</span><br><span class="line">|  HTTP   |         |  HTTP   |         |  HTTP   |  (应用层)</span><br><span class="line">+---------+         +---------+         +---------+</span><br><span class="line">|   TCP   |         |   TCP   |         |  QUIC   |  (传输层)</span><br><span class="line">+---------+         +---------+         +---------+</span><br><span class="line">|   IP    |         |   IP    |         |   UDP   |</span><br><span class="line">+---------+         +---------+         +---------+</span><br><span class="line">|  ...    |         |  ...    |         |   IP    |</span><br><span class="line">                                        +---------+</span><br><span class="line">                                        |  ...    |</span><br></pre></td></tr></table></figure>

<p>QUIC 实际上将原本属于操作系统内核实现的 TCP 功能，转移到了用户空间的应用程序（如浏览器、服务器软件）中去实现，这使得协议的迭代和优化变得更加快速和灵活。</p>
</li>
</ul>
<hr>
<h3 id="4-3-QUIC-的优势"><a href="#4-3-QUIC-的优势" class="headerlink" title="4.3. QUIC 的优势"></a>4.3. QUIC 的优势</h3><p>QUIC 作为 HTTP&#x2F;3 的基石，带来了几项超越 TCP 的革命性优势：</p>
<p><strong>1. 真正的多路复用，无队头阻塞</strong></p>
<ul>
<li><strong>优势</strong>: 这是 QUIC <strong>最核心的优势</strong>。QUIC 连接上也可以承载多个独立的流，但与 HTTP&#x2F;2 不同，这些流在 QUIC 层面是<strong>完全独立</strong>的。</li>
<li><strong>工作方式</strong>: 如果一个流中的某个数据包丢失，<strong>只有那一个流会受到影响</strong>，需要等待数据重传。其他流的数据包，即使在 UDP 层是后到的，也可以被 QUIC 层正常处理并交付给上层的 HTTP&#x2F;3，不会被阻塞。</li>
<li><strong>类比</strong>: <strong>各自开自己的小货车</strong>。<br>每个客户的货物（每个 HTTP 流）都由一辆独立的小货车（一个 QUIC 流）运输。即使其中一辆小货车在路上抛锚了，也完全不影响其他小货车继续前进。</li>
</ul>
<p><strong>2. 更少的 RTT，连接建立更快 (0-RTT &amp; 1-RTT)</strong></p>
<ul>
<li><strong>TCP+TLS 的握手</strong>: 建立一个安全的 HTTPS 连接，需要先进行 TCP 的三次握手（1-RTT），然后再进行 TLS 的握手（1-2 RTT），总共需要 2-3 次网络往返。</li>
<li><strong>QUIC 的握手</strong>: QUIC 将<strong>传输层握手 (类似 TCP) 和加密握手 (TLS) 合二为一</strong>。<ul>
<li><strong>首次连接</strong>: 只需要 <strong>1-RTT</strong> 即可完成连接建立和密钥协商。</li>
<li><strong>后续连接 (0-RTT)</strong>: 如果客户端之前连接过该服务器，QUIC 允许客户端在发送第一个包时就携带加密的应用数据，从而实现 <strong>0-RTT</strong> 的连接恢复。这极大地降低了移动设备在网络切换后重新建立连接的延迟。</li>
</ul>
</li>
</ul>
<p><strong>3. 连接迁移 (Connection Migration)</strong></p>
<ul>
<li><strong>TCP 的问题</strong>: TCP 连接是通过一个<strong>四元组</strong>（源IP, 源端口, 目的IP, 目的端口）来唯一标识的。当你的网络环境发生变化时（如手机从 Wi-Fi 切换到 4G），你的 IP 地址和端口会改变，<strong>TCP 连接就会中断</strong>，必须重新建立。</li>
<li><strong>QUIC 的优势</strong>: QUIC 连接不依赖于 IP 地址和端口，而是通过一个<strong>唯一的 64 位连接 ID (Connection ID)</strong> 来标识。</li>
<li><strong>工作方式</strong>: 当网络切换时，客户端只需用新的 IP 地址和端口，继续向服务器发送带有相同连接 ID 的数据包即可。服务器收到后，通过连接 ID 就能识别出这是之前的那个连接，从而<strong>无缝地维持连接</strong>，无需重新握手。这对于移动设备的用户体验是颠覆性的提升。</li>
</ul>
<hr>
<h3 id="4-4-当前现状与未来展望"><a href="#4-4-当前现状与未来展望" class="headerlink" title="4.4. 当前现状与未来展望"></a>4.4. 当前现状与未来展望</h3><ul>
<li><strong>当前现状</strong>:<ul>
<li>HTTP&#x2F;3 已经成为正式标准 (RFC 9114)。</li>
<li>主流的浏览器（Chrome, Firefox, Safari）和 Web 服务器（Nginx, Caddy, Litespeed）以及大型 CDN 服务商（Cloudflare, Akamai）都已经提供了对 HTTP&#x2F;3 和 QUIC 的广泛支持。</li>
<li>根据 W3Techs 的数据，截至 2023 年，全球已有超过 25% 的网站支持 HTTP&#x2F;3。这个数字还在快速增长，尤其是在大型互联网公司和对性能要求高的网站中。</li>
</ul>
</li>
<li><strong>挑战</strong>:<ul>
<li><strong>中间设备僵化</strong>: 许多网络中的防火墙、NAT 设备等只对 TCP 和 UDP 的常见端口（如 80, 443）进行优化或放行，可能会对运行在 UDP 上的 QUIC 流量进行限制或丢弃。</li>
<li><strong>协议栈在用户空间</strong>: 虽然带来了灵活性，但也增加了 CPU 的消耗，因为部分原本由硬件和操作系统内核处理的工作转移到了应用层面。</li>
</ul>
</li>
<li><strong>未来展望</strong>:<br>HTTP&#x2F;3 代表了 Web 协议演进的明确方向：<strong>更低的延迟、更高的可靠性和更好的移动性</strong>。随着网络设备对 QUIC 的支持不断完善和 CPU 性能的提升，HTTP&#x2F;3 必将逐步取代 HTTP&#x2F;2，成为下一代互联网的核心通信协议。它为物联网 (IoT)、实时通信 (WebRTC)、在线游戏以及未来更多对网络延迟和稳定性有极致要求的应用场景，奠定了坚实的基础。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/17/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E4%B8%8E%E9%9B%86%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/17/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E4%B8%8E%E9%9B%86%E6%88%90/" class="post-title-link" itemprop="url">Spring全家桶-功能扩展与集成</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-17 13:20:07 / 修改时间：13:20:59" itemprop="dateCreated datePublished" datetime="2025-10-17T13:20:07+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="六、功能扩展与集成"><a href="#六、功能扩展与集成" class="headerlink" title="六、功能扩展与集成"></a>六、功能扩展与集成</h1><h2 id="1-任务调度-Task-Scheduling"><a href="#1-任务调度-Task-Scheduling" class="headerlink" title="1. 任务调度 (Task Scheduling)"></a>1. 任务调度 (Task Scheduling)</h2><p>在软件开发中，任务调度是指在预定的时间点或按固定的时间间隔自动执行特定代码逻辑的机制。它是一种常见的非用户触发的后台处理模式，广泛应用于各种业务场景。</p>
<p><strong>为什么需要任务调度？</strong></p>
<ul>
<li><strong>自动化处理：</strong> 无需人工干预，系统能自动执行重复性任务，如数据备份、报表生成。</li>
<li><strong>异步与解耦：</strong> 将耗时的、非核心的任务（如发送通知邮件、数据同步）从主业务流程中分离出来，放到后台定时执行，提升系统响应速度和用户体验。</li>
<li><strong>资源削峰：</strong> 将高并发的请求或计算密集型任务分散到系统负载较低的时间段（如凌晨）执行。</li>
</ul>
<p><strong>常见应用场景：</strong></p>
<ul>
<li><strong>数据清理：</strong> 每天凌晨清理过期日志、临时文件或无效数据。</li>
<li><strong>报表生成：</strong> 每周一凌晨自动生成上周的业务统计报表。</li>
<li><strong>数据同步：</strong> 每隔10分钟从第三方系统拉取最新数据。</li>
<li><strong>状态检查与通知：</strong> 定时扫描订单表，对超时的未支付订单进行关闭，并发送通知。</li>
</ul>
<p>Spring 框架提供了强大的内置任务调度支持，通过简单的注解就能实现复杂的调度需求，极大地简化了开发过程。</p>
<hr>
<h3 id="1-1-Scheduled-注解"><a href="#1-1-Scheduled-注解" class="headerlink" title="1.1 @Scheduled 注解"></a>1.1 <code>@Scheduled</code> 注解</h3><p><code>@Scheduled</code> 是 Spring 提供的一个注解，用于将一个普通方法标记为需要定时执行的任务。这是实现任务调度的最简单、最快捷的方式。</p>
<h4 id="1-1-1-使用步骤"><a href="#1-1-1-使用步骤" class="headerlink" title="1.1.1 使用步骤"></a>1.1.1 使用步骤</h4><h5 id="1-开启调度功能"><a href="#1-开启调度功能" class="headerlink" title="1. 开启调度功能"></a>1. 开启调度功能</h5><p>要使 <code>@Scheduled</code> 注解生效，必须在 Spring Boot 的主启动类或任何一个配置类（<code>@Configuration</code>）上添加 <code>@EnableScheduling</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务调度功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-创建定时任务"><a href="#2-创建定时任务" class="headerlink" title="2. 创建定时任务"></a>2. 创建定时任务</h5><p>在一个 Spring管理的 Bean（如 <code>@Component</code>, <code>@Service</code>）中，创建一个 public、void、无参的方法，并在其上添加 <code>@Scheduled</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTasks</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例任务</span></span><br><span class="line">    <span class="meta">@Scheduled(...)</span> <span class="comment">// 在这里配置调度规则</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myTaskMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;定时任务执行于: &quot;</span> + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-2-常用调度策略"><a href="#1-1-2-常用调度策略" class="headerlink" title="1.1.2 常用调度策略"></a>1.1.2 常用调度策略</h4><p><code>@Scheduled</code> 注解提供了多种属性来定义任务的执行时机：</p>
<h5 id="1-fixedRate：固定频率执行"><a href="#1-fixedRate：固定频率执行" class="headerlink" title="1. fixedRate：固定频率执行"></a><strong>1. <code>fixedRate</code>：固定频率执行</strong></h5><ul>
<li><strong>含义：</strong> 上一次任务<strong>开始执行</strong>后，间隔固定时间再次执行。单位为毫秒。</li>
<li><strong>特点：</strong> 任务的启动时间是固定的，不受任务执行时长的影响。如果任务执行时间超过了 <code>fixedRate</code> 的间隔，那么上一个任务结束后，下一个任务会立即执行。</li>
<li><strong>示例：</strong> 每隔5秒执行一次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedRate = 5000)</span> <span class="comment">// 5000 毫秒 = 5秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTaskAtFixedRate</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;fixedRate 任务执行...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-fixedDelay：固定延迟执行"><a href="#2-fixedDelay：固定延迟执行" class="headerlink" title="2. fixedDelay：固定延迟执行"></a>2. <code>fixedDelay</code>：固定延迟执行</h5><ul>
<li><strong>含义：</strong> 上一次任务<strong>执行完毕</strong>后，等待固定时间再执行下一次。单位为毫秒。</li>
<li><strong>特点：</strong> 两次任务执行的间隔是固定的，即 <code>(上一次任务结束时间)</code> + <code>fixedDelay</code> &#x3D; <code>(下一次任务开始时间)</code>。</li>
<li><strong>示例：</strong> 任务执行完成后，延迟3秒再执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedDelay = 3000)</span> <span class="comment">// 3000 毫秒 = 3秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTaskWithFixedDelay</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;fixedDelay 任务执行...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务耗时2秒</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行流程：执行(2s) -&gt; 等待(3s) -&gt; 执行(2s) -&gt; 等待(3s) -&gt; ...</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-cron：Cron-表达式"><a href="#3-cron：Cron-表达式" class="headerlink" title="3. cron：Cron 表达式"></a>3. <code>cron</code>：Cron 表达式</h5><ul>
<li><p><strong>含义：</strong> 最灵活的调度方式，使用标准的 Cron 表达式来定义复杂的执行计划。</p>
</li>
<li><p><strong>格式：</strong> <code>秒 分 时 日 月 周</code> (共6个或7个字段，Spring 支持6个字段，年是可选的)。</p>
<ul>
<li><code>*</code>：匹配所有值。</li>
<li><code>?</code>：仅在“日”和“周”字段中使用，表示不指定值。</li>
<li><code>/</code>：表示步长，如 <code>0/15</code> 在秒字段表示每15秒。</li>
</ul>
</li>
<li><p><strong>示例：</strong> 每天凌晨2点整执行。</p>
<blockquote>
<p><strong>Tip:</strong> 可以使用在线 Cron 表达式生成器来创建和验证表达式。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;秒 分 时 日 月 周&quot;</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 2 * * ?&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTaskWithCron</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cron 任务在每天凌晨2点执行...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-initialDelay：初始延迟"><a href="#4-initialDelay：初始延迟" class="headerlink" title="4. initialDelay：初始延迟"></a>4. <code>initialDelay</code>：初始延迟</h5><ul>
<li><strong>含义：</strong> 指定任务首次执行前的延迟时间，可与 <code>fixedRate</code> 或 <code>fixedDelay</code> 配合使用。单位为毫秒。</li>
<li><strong>示例：</strong> 服务启动后，延迟10秒，然后每5秒执行一次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(initialDelay = 10000, fixedRate = 5000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTaskWithInitialDelay</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;首次延迟10秒后，每5秒执行一次的任务...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-3-深入理解与注意事项"><a href="#1-1-3-深入理解与注意事项" class="headerlink" title="1.1.3 深入理解与注意事项"></a>1.1.3 深入理解与注意事项</h4><ul>
<li><strong>默认单线程执行：</strong> Spring 调度的所有 <code>@Scheduled</code> 任务<strong>默认使用一个单线程的线程池</strong>。这意味着，如果一个任务执行时间过长，它会阻塞其他任务的执行。</li>
<li><strong>解决方案（自定义线程池）：</strong> 在生产环境中，强烈建议为定时任务配置一个独立的线程池，以避免任务间的相互影响。</li>
</ul>
<p><strong>配置示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulingConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个包含10个线程的线程池</span></span><br><span class="line">        taskRegistrar.setScheduler(Executors.newScheduledThreadPool(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个配置，所有的 <code>@Scheduled</code> 任务就会在这个容量为10的线程池中并发执行。</p>
<hr>
<h3 id="1-2-Cron-表达式"><a href="#1-2-Cron-表达式" class="headerlink" title="1.2 Cron 表达式"></a>1.2 Cron 表达式</h3><p><code>@Scheduled</code> 注解中的 <code>fixedRate</code> 和 <code>fixedDelay</code> 适用于简单的、固定间隔的调度。但对于更复杂的业务场景，例如“每个工作日的上午10点”、“每个月最后一天”或“每季度第一个周一”，我们就需要使用 Cron 表达式。</p>
<p>Cron 表达式是一个字符串，由 6 到 7 个由空格分隔的字段组成，它精确地定义了任务触发的时间规则。</p>
<h4 id="1-2-1-Cron-表达式的语法结构"><a href="#1-2-1-Cron-表达式的语法结构" class="headerlink" title="1.2.1 Cron 表达式的语法结构"></a>1.2.1 Cron 表达式的语法结构</h4><p>Spring 的 Cron 表达式包含 6 个必填字段，其顺序和含义如下：</p>
<table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">字段</th>
<th align="left">允许值</th>
<th align="left">允许的特殊字符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>秒 (Second)</strong></td>
<td align="left"><code>0-59</code></td>
<td align="left"><code>* , - /</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>分 (Minute)</strong></td>
<td align="left"><code>0-59</code></td>
<td align="left"><code>* , - /</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>时 (Hour)</strong></td>
<td align="left"><code>0-23</code></td>
<td align="left"><code>* , - /</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>日 (Day of Month)</strong></td>
<td align="left"><code>1-31</code></td>
<td align="left"><code>* , - / ? L W</code></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>月 (Month)</strong></td>
<td align="left"><code>1-12</code> 或 <code>JAN-DEC</code></td>
<td align="left"><code>* , - /</code></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>周 (Day of Week)</strong></td>
<td align="left"><code>1-7</code> 或 <code>MON-SUN</code></td>
<td align="left"><code>* , - / ? L #</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>重要提示</strong>：在 “日 (Day of Month)” 和 “周 (Day of Week)” 字段中，通常必须有一个使用 <code>?</code> 来表示“不指定”，以避免冲突。例如，你不能同时指定“每月的15号”并且“是周五”。</p>
</blockquote>
<hr>
<h4 id="1-2-2-特殊字符详解"><a href="#1-2-2-特殊字符详解" class="headerlink" title="1.2.2 特殊字符详解"></a>1.2.2 特殊字符详解</h4><table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>*</code></td>
<td align="left">星号 (任意值)</td>
<td align="left">代表该字段的每一个可能的值。例如，在“分”字段中表示“每分钟”。</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">问号 (不指定)</td>
<td align="left">仅用于“日”和“周”字段。当其中一个字段被指定了值，另一个字段就应该使用 <code>?</code> 来表示不关心。</td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left">减号 (范围)</td>
<td align="left">指定一个范围。例如，在“时”字段中使用 <code>10-12</code> 表示 10点、11点和12点。</td>
</tr>
<tr>
<td align="left"><code>,</code></td>
<td align="left">逗号 (列表)</td>
<td align="left">指定一个值的列表。例如，在“周”字段中使用 <code>MON,WED,FRI</code> 表示周一、周三和周五。</td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td align="left">斜杠 (步长)</td>
<td align="left">指定增量。例如，在“秒”字段中使用 <code>0/15</code> 表示从第0秒开始，每隔15秒执行一次（即 0, 15, 30, 45秒）。</td>
</tr>
<tr>
<td align="left"><code>L</code></td>
<td align="left">Last (最后)</td>
<td align="left">仅用于“日”和“周”字段。<br/>- 在“日”字段中，<code>L</code> 表示这个月的最后一天（31、30、29或28）。<br/>- 在“周”字段中，<code>L</code> 表示一周的最后一天（即周六 <code>SAT</code> 或 <code>7</code>）。<code>5L</code> 则表示这个月最后一个周四。</td>
</tr>
<tr>
<td align="left"><code>W</code></td>
<td align="left">Weekday (工作日)</td>
<td align="left">仅用于“日”字段。<code>15W</code> 表示离15号最近的那个工作日（周一到周五）。如果15号是周六，则在14号（周五）触发；如果15号是周日，则在16号（周一）触发。<code>LW</code> 组合表示这个月最后一个工作日。</td>
</tr>
<tr>
<td align="left"><code>#</code></td>
<td align="left">井号 (第几个)</td>
<td align="left">仅用于“周”字段。<code>5#3</code> 表示这个月的第三个星期四。</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-2-3-常见-Cron-表达式示例"><a href="#1-2-3-常见-Cron-表达式示例" class="headerlink" title="1.2.3 常见 Cron 表达式示例"></a>1.2.3 常见 Cron 表达式示例</h4><p>下面是一些实际应用中的例子，可以直接在 <code>@Scheduled</code> 注解中使用。</p>
<p><strong>示例1：每分钟的第30秒执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;30 * * * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：每天凌晨 1:00 整执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 秒 分 时 日 月 周</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例3：每个工作日 (周一至周五) 的上午 10:15 执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 15 10 ? * MON-FRI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例4：每个月1号、11号、21号的凌晨 2:00 执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 2 1,11,21 * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例5：每隔 5 分钟执行一次</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0/5 * * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例6：每个月最后一个周五的晚上 10:00 执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 22 ? * 5L&quot;)</span> <span class="comment">// 5L 表示最后一个周四</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task6</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-4-使用技巧与注意事项"><a href="#1-2-4-使用技巧与注意事项" class="headerlink" title="1.2.4 使用技巧与注意事项"></a>1.2.4 使用技巧与注意事项</h4><ul>
<li><p><strong>在线生成器：</strong> 对于复杂的 Cron 表达式，强烈建议使用在线 Cron 表达式生成和校验工具 (如 Cron Maker, Crontab Guru)。这可以有效避免手动编写错误。</p>
</li>
<li><p><strong>时区问题 (Time Zone)：</strong> Spring 的 <code>@Scheduled</code> 默认使用服务器的本地时区。如果你的应用需要基于特定时区进行调度（例如，所有任务都按 <code>UTC+8</code> 执行），可以在注解中指定 <code>zone</code> 属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;, zone = &quot;Asia/Shanghai&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskInSpecificTimeZone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个任务总是在北京时间凌晨1点执行，无论服务器在哪个时区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码可读性：</strong> 复杂的 Cron 表达式会降低代码的可读性。建议在 <code>@Scheduled</code> 注解上方添加一行注释，用自然语言解释该表达式的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute at 10:15 AM every weekday</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 15 10 ? * MON-FRI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDailyReport</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置化：</strong> 在生产环境中，将 Cron 表达式配置在 <code>application.properties</code> 或 <code>application.yml</code> 中是更好的实践，这样可以在不重新编译和部署代码的情况下调整任务执行时间。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="attr">myapp.scheduling.report-task.cron</span>=<span class="string">0 15 10 ? * MON-FRI</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;$&#123;myapp.scheduling.report-task.cron&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDailyReport</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="1-3-动态与分布式调度"><a href="#1-3-动态与分布式调度" class="headerlink" title="1.3 动态与分布式调度"></a>1.3 动态与分布式调度</h3><p>虽然 <code>@Scheduled</code> 注解非常方便，但它存在一些固有的局限性，尤其是在现代化的、可扩展的应用程序中：</p>
<ol>
<li><strong>静态性 (Static Nature):</strong> 任务的触发规则（如 Cron 表达式）通常硬编码在代码或配置文件中。如果需要修改执行时间、暂停任务或新增任务，必须修改代码、重新打包并部署应用，缺乏灵活性。</li>
<li><strong>单点问题 (Single Point of Execution):</strong> 在分布式环境中，如果将应用部署为多个实例（集群），每个实例都会独立执行相同的 <code>@Scheduled</code> 任务，这会导致任务被重复执行，可能引发数据错乱或资源浪费。</li>
<li><strong>功能局限 (Limited Functionality):</strong> <code>@Scheduled</code> 缺少一些高级的企业级功能，如：<ul>
<li>可视化的管理和监控界面。</li>
<li>失败重试、任务依赖、历史日志查询。</li>
<li>任务分片（将一个大任务拆分给多个节点执行）。</li>
<li>故障转移（一个节点宕机后，任务自动由其他节点接管）。</li>
</ul>
</li>
</ol>
<p>为了解决这些问题，我们需要引入更专业的调度框架，它们主要分为两大类：<strong>企业级调度框架（如 Quartz）</strong> 和 <strong>分布式任务调度中心（如 XXL-Job, PowerJob）</strong>。</p>
<hr>
<h4 id="1-3-1-Quartz：强大的企业级调度框架"><a href="#1-3-1-Quartz：强大的企业级调度框架" class="headerlink" title="1.3.1 Quartz：强大的企业级调度框架"></a>1.3.1 Quartz：强大的企业级调度框架</h4><p>Quartz 是一个功能丰富、历史悠久的开源作业调度库，可以紧密集成在 Java 应用中。你可以把它看作是 Spring 内置调度的“超级增强版”。</p>
<p><strong>核心概念:</strong></p>
<ul>
<li><strong><code>Scheduler</code>：</strong> 调度器核心，负责管理和触发任务。</li>
<li><strong><code>Job</code>：</strong> 一个接口，定义了需要被执行的具体业务逻辑。</li>
<li><strong><code>Trigger</code>：</strong> 触发器，定义了 <code>Job</code> 何时被执行（例如，使用 <code>CronTrigger</code> 或 <code>SimpleTrigger</code>）。</li>
<li><strong><code>JobDetail</code>：</strong> <code>Job</code> 的实例，包含了 <code>Job</code> 的身份信息（名称、组）和相关的状态数据 (<code>JobDataMap</code>)。</li>
</ul>
<p><strong>关键特性:</strong></p>
<ol>
<li><strong>持久化 (Persistence):</strong> Quartz 可以将任务（<code>Job</code> 和 <code>Trigger</code>）的信息存储在数据库中。这样即使应用重启，之前定义的任务也不会丢失，保证了任务的可靠性。</li>
<li><strong>动态管理 (Dynamic Management):</strong> 你可以通过代码（API调用）在运行时动态地创建、修改、暂停、恢复和删除任务，而无需重启服务。这解决了 <code>@Scheduled</code> 的静态性问题。</li>
<li><strong>集群支持 (Clustering):</strong> Quartz 支持集群模式。多个应用实例可以连接到同一个数据库，Quartz 通过数据库锁机制来确保在同一时刻，一个任务只会被集群中的一个节点执行，从而避免了任务重复执行的问题。</li>
<li><strong>丰富的触发器:</strong> 除了 Cron 触发器，还支持 <code>SimpleTrigger</code>（在指定时间点执行，可设置重复次数和间隔）等多种触发方式。</li>
</ol>
<p><strong>与 Spring Boot 集成:</strong></p>
<p>通过引入 <code>spring-boot-starter-quartz</code> 依赖，可以非常方便地将 Quartz 集成到 Spring Boot 项目中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-3-2-分布式任务调度中心"><a href="#1-3-2-分布式任务调度中心" class="headerlink" title="1.3.2 分布式任务调度中心"></a>1.3.2 分布式任务调度中心</h4><p>对于微服务架构或大规模分布式系统，更好的选择是使用一个独立的、可视化的<strong>分布式任务调度中心</strong>。</p>
<p>这种架构将 <strong>调度器 (Scheduler)</strong> 和 <strong>执行器 (Executor)</strong> 分离开来：</p>
<ul>
<li><strong>调度中心 (Scheduler Center):</strong> 一个独立的、高可用的服务。它负责任务的统一管理（增删改查）、触发、监控、路由和故障转移。通常提供一个 Web 管理界面。</li>
<li><strong>执行器 (Executor):</strong> 通常是一个轻量级的 Agent 或 SDK，内嵌在你的业务应用中。它负责接收来自调度中心的指令，并执行具体的业务代码。</li>
</ul>
<p><strong>主流框架:</strong></p>
<ul>
<li><strong>XXL-Job:</strong> 由大众点评开源，是一个轻量级、易于上手的分布式任务调度平台。它功能完善，社区活跃，在国内被广泛使用。</li>
<li><strong>PowerJob:</strong> 新一代分布式计算与任务调度框架，功能更强大，支持 DAG（有向无环图）任务编排、MapReduce、任务分片等高级特性。</li>
</ul>
<p><strong>核心优势:</strong></p>
<ol>
<li><strong>可视化管理:</strong> 提供统一的 Web 界面，可以方便地管理所有任务、查看执行日志、监控执行器状态等，运维非常友好。</li>
<li><strong>高可用与解耦:</strong> 调度中心和业务应用完全解耦。调度中心可以独立部署为高可用集群，业务应用的扩缩容或宕机不影响调度中心的稳定性。</li>
<li><strong>强大的分布式特性:</strong><ul>
<li><strong>路由策略:</strong> 可以灵活地选择哪个执行器实例来运行任务（如轮询、随机、故障转移、分片广播等）。</li>
<li><strong>任务分片:</strong> 可以将一个海量数据处理任务平均分配给多个执行器实例并行处理，极大提升处理效率。</li>
<li><strong>故障转移:</strong> 当某个执行器节点宕机时，调度中心能自动将任务 перенаправить (redirect) 到其他健康的节点上执行。</li>
<li><strong>生命周期管理:</strong> 完善的任务生命周期管理，包括任务超时控制、失败告警、执行日志追踪等。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-3-3-总结与选型对比"><a href="#1-3-3-总结与选型对比" class="headerlink" title="1.3.3 总结与选型对比"></a>1.3.3 总结与选型对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Scheduled</code> (Spring 内置)</th>
<th align="left">Quartz (企业级框架)</th>
<th align="left">分布式调度中心 (XXL-Job&#x2F;PowerJob)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>易用性</strong></td>
<td align="left"><strong>极高</strong> (一个注解搞定)</td>
<td align="left">较高 (需要理解核心概念)</td>
<td align="left">中等 (需要部署调度中心和集成执行器)</td>
</tr>
<tr>
<td align="left"><strong>动态管理</strong></td>
<td align="left">不支持 (需重启)</td>
<td align="left"><strong>支持</strong> (通过 API 动态管理)</td>
<td align="left"><strong>核心特性</strong> (通过 Web 界面管理)</td>
</tr>
<tr>
<td align="left"><strong>分布式支持</strong></td>
<td align="left">不支持 (会重复执行)</td>
<td align="left">支持集群模式 (通过DB锁)</td>
<td align="left"><strong>核心特性</strong> (原生分布式设计)</td>
</tr>
<tr>
<td align="left"><strong>监控与管理</strong></td>
<td align="left">无</td>
<td align="left">弱 (需自行实现)</td>
<td align="left"><strong>强大</strong> (提供统一的可视化管理后台)</td>
</tr>
<tr>
<td align="left"><strong>高级功能</strong></td>
<td align="left">无 (失败重试、分片等)</td>
<td align="left">有限支持</td>
<td align="left"><strong>非常丰富</strong> (分片、路由、故障转移、依赖)</td>
</tr>
<tr>
<td align="left"><strong>架构</strong></td>
<td align="left">内嵌在应用中</td>
<td align="left">内嵌在应用中 (可配置DB持久化)</td>
<td align="left"><strong>调度与执行分离</strong></td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">单体应用、简单的后台任务</td>
<td align="left">复杂的单体应用、需要动态管理任务的场景</td>
<td align="left"><strong>微服务架构、大规模分布式系统</strong>、复杂任务编排</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-缓存抽象-Caching-Abstraction"><a href="#2-缓存抽象-Caching-Abstraction" class="headerlink" title="2. 缓存抽象 (Caching Abstraction)"></a>2. 缓存抽象 (Caching Abstraction)</h2><p>Spring 缓存抽象的目标是提供一个统一的、与具体缓存技术无关的编程模型。开发者只需通过简单的注解，就能将缓存逻辑透明地集成到现有代码中，而无需关心底层使用的是 Redis、Caffeine 还是其他缓存实现。这极大地实现了<strong>业务逻辑与缓存逻辑的解耦</strong>。</p>
<p>与任务调度类似，使用缓存注解前，必须在 Spring Boot 的主启动类或任何配置类（<code>@Configuration</code>）上添加 <code>@EnableCaching</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span> <span class="comment">// 开启基于注解的缓存功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-核心注解"><a href="#2-1-核心注解" class="headerlink" title="2.1 核心注解"></a>2.1 核心注解</h3><h4 id="2-1-1-Cacheable：查询缓存"><a href="#2-1-1-Cacheable：查询缓存" class="headerlink" title="2.1.1 @Cacheable：查询缓存"></a>2.1.1 <code>@Cacheable</code>：查询缓存</h4><ul>
<li><strong>作用：</strong> 这是最常用的缓存注解。在方法执行前，Spring 会先根据 <code>key</code> 检查缓存中是否存在对应的数据。<ul>
<li><strong>如果缓存存在</strong>：直接返回缓存中的数据，<strong>方法体内的代码不会被执行</strong>。</li>
<li><strong>如果缓存不存在</strong>：执行方法，并将方法的返回值存入缓存，然后返回结果。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 主要用于数据<strong>查询</strong>操作，对于读多写少的场景效果显著。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> &#x2F; <code>cacheNames</code>：指定要使用的缓存名称（可以是一个或多个）。例如，<code>cacheNames = &quot;users&quot;</code>。</li>
<li><code>key</code>：缓存的键。这是缓存中数据的唯一标识。支持使用 <strong>SpEL (Spring Expression Language)</strong> 动态生成。<ul>
<li>如果省略，Spring 会使用默认策略生成 key（通常是方法的参数组合）。</li>
<li><strong>强烈建议手动指定 <code>key</code></strong> 以保证其唯一性和可读性。</li>
</ul>
</li>
<li><code>condition</code>：条件成立时才进行缓存。SpEL 表达式，返回 <code>true</code> 时缓存，<code>false</code> 则不缓存。例如 <code>condition = &quot;#id &gt; 0&quot;</code>。</li>
<li><code>unless</code>：条件成立时<strong>不</strong>缓存方法的返回值。用于否决缓存，例如 <code>unless = &quot;#result == null&quot;</code>，表示如果方法返回 <code>null</code>，则不缓存。</li>
</ul>
</li>
<li><strong>代码示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是从数据库查询的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable(cacheNames = &quot;users&quot;, key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing findById from DB for ID: &quot;</span> + id);</span><br><span class="line">        <span class="comment">// 模拟数据库查询</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;User&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>调用分析</strong>：</p>
<ul>
<li>第一次调用 <code>findById(1L)</code>：控制台打印 “Executing findById from DB…”，方法执行，返回值被存入名为 “users” 的缓存中，key 为 “1”。</li>
<li>第二次调用 <code>findById(1L)</code>：直接从缓存返回数据，控制台<strong>不会</strong>有任何打印，方法体未被执行。</li>
</ul>
</blockquote>
<hr>
<h4 id="2-1-2-CachePut：更新缓存"><a href="#2-1-2-CachePut：更新缓存" class="headerlink" title="2.1.2 @CachePut：更新缓存"></a>2.1.2 <code>@CachePut</code>：更新缓存</h4><ul>
<li><strong>作用：</strong> 与 <code>@Cacheable</code> 不同，<code>@CachePut</code> 会<strong>始终执行方法体</strong>，然后将方法的返回值更新（或放入）到缓存中。</li>
<li><strong>适用场景：</strong> 主要用于数据<strong>更新</strong>操作。它确保了在更新数据库的同时，也更新了缓存中的数据，保持数据一致性。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> &#x2F; <code>cacheNames</code>：同上。</li>
<li><code>key</code>：必须指定，且通常需要与查询时（<code>@Cacheable</code>）使用的 <code>key</code> 保持一致，这样才能正确更新同一条数据。</li>
</ul>
</li>
<li><strong>代码示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CachePut(cacheNames = &quot;users&quot;, key = &quot;#user.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing updateUser in DB for user: &quot;</span> + user.getId());</span><br><span class="line">        <span class="comment">// 模拟更新数据库</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> user; <span class="comment">// 返回更新后的对象，该对象将被放入缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>调用分析</strong>：每次调用 <code>updateUser(user)</code>，控制台<strong>总是</strong>会打印 “Executing updateUser…”，并且缓存 “users” 中对应 key 的数据会被更新为方法返回的新 <code>user</code> 对象。</p>
</blockquote>
<hr>
<h4 id="2-1-3-CacheEvict：失效缓存"><a href="#2-1-3-CacheEvict：失效缓存" class="headerlink" title="2.1.3 @CacheEvict：失效缓存"></a>2.1.3 <code>@CacheEvict</code>：失效缓存</h4><ul>
<li><strong>作用：</strong> 从缓存中移除一条或多条数据。</li>
<li><strong>适用场景：</strong> 主要用于数据<strong>删除</strong>操作，或在某些更新操作后需要清除相关缓存的场景。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> &#x2F; <code>cacheNames</code>：同上。</li>
<li><code>key</code>：指定要移除的缓存键。</li>
<li><code>allEntries</code>：布尔值，默认为 <code>false</code>。如果设置为 <code>true</code>，则会清空整个缓存（<code>cacheNames</code> 指定的那个），而不仅仅是移除某个 <code>key</code> 对应的数据。</li>
<li><code>beforeInvocation</code>：布尔值，默认为 <code>false</code>。<ul>
<li><code>false</code>（默认）：在方法成功执行<strong>之后</strong>才清除缓存。如果方法执行失败并抛出异常，缓存不会被清除，保证了数据一致性。</li>
<li><code>true</code>：在方法执行<strong>之前</strong>就清除缓存。这种方式存在风险，如果方法后续执行失败，会导致缓存已删但数据未删的不一致状态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>代码示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CacheEvict(cacheNames = &quot;users&quot;, key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing deleteById from DB for ID: &quot;</span> + id);</span><br><span class="line">        <span class="comment">// 模拟从数据库删除</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(cacheNames = &quot;users&quot;, allEntries = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearAllUsersCache</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Clearing all users cache...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-4-Caching-和-CacheConfig：组合与配置"><a href="#2-1-4-Caching-和-CacheConfig：组合与配置" class="headerlink" title="2.1.4 @Caching 和 @CacheConfig：组合与配置"></a>2.1.4 <code>@Caching</code> 和 <code>@CacheConfig</code>：组合与配置</h4><ul>
<li><p><strong><code>@Caching</code>：</strong> 当一个方法需要应用多个不同类型的缓存注解时，可以使用 <code>@Caching</code> 将它们组合在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(</span></span><br><span class="line"><span class="meta">    put = &#123; @CachePut(cacheNames = &quot;user&quot;, key = &quot;#user.id&quot;) &#125;,</span></span><br><span class="line"><span class="meta">    evict = &#123; @CacheEvict(cacheNames = &quot;userList&quot;, allEntries = true) &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述代码表示，在保存用户后，更新单个用户缓存，并清空用户列表缓存。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@CacheConfig</code>：</strong> 类级别的注解，用于抽取该类中所有缓存注解的公共配置，如 <code>cacheNames</code>。这有助于简化代码，避免重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;users&quot;)</span> <span class="comment">// 在类级别统一配置缓存名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#user.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-2-CacheManager-与-Cache-接口"><a href="#2-2-CacheManager-与-Cache-接口" class="headerlink" title="2.2 CacheManager 与 Cache 接口"></a>2.2 <code>CacheManager</code> 与 <code>Cache</code> 接口</h3><p><code>@Cacheable</code> 等注解之所以能工作，是因为 Spring AOP 在背后做了一系列操作。当我们调用一个带有缓存注解的方法时，Spring 的一个拦截器会介入，而这个拦截器正是通过 <code>CacheManager</code> 和 <code>Cache</code> 这两个核心接口来完成实际的缓存读写。</p>
<p><strong>从注解到接口：揭秘幕后工作原理</strong></p>
<p>让我们以 <code>@Cacheable(cacheNames = &quot;users&quot;, key = &quot;#id&quot;)</code> 为例，看看其背后发生了什么：</p>
<ol>
<li><strong>方法调用被拦截</strong>：当 <code>findById(1L)</code> 方法被调用时，Spring AOP 的缓存切面（<code>CacheInterceptor</code>）会首先拦截这个调用。</li>
<li><strong>获取 <code>CacheManager</code></strong>：拦截器会从 Spring 容器中获取已配置的 <code>CacheManager</code> Bean。</li>
<li><strong>获取 <code>Cache</code> 对象</strong>：拦截器调用 <code>cacheManager.getCache(&quot;users&quot;)</code> 方法，向管理器索要一个名为 “users” 的 <code>Cache</code> 实例。如果这个 <code>Cache</code> 不存在，<code>CacheManager</code> 可能会动态创建一个。</li>
<li><strong>在 <code>Cache</code> 中查找数据</strong>：拦截器根据注解中的 <code>key</code> 属性（<code>#id</code>，解析为 <code>1L</code>）作为键，调用 <code>cache.get(1L)</code> 方法在 <code>Cache</code> 实例中查找数据。</li>
<li><strong>决策与执行</strong>：<ul>
<li><strong>缓存命中</strong>：如果 <code>cache.get(1L)</code> 返回了非 <code>null</code> 的值，拦截器就直接将这个值返回给调用方，<strong>原始的 <code>findById</code> 方法体完全不会执行</strong>。</li>
<li><strong>缓存未命中</strong>：如果 <code>cache.get(1L)</code> 返回 <code>null</code>，拦截器会继续执行原始的 <code>findById</code> 方法。</li>
</ul>
</li>
<li><strong>填充缓存</strong>：方法执行成功后，拦截器会获取其返回值，然后调用 <code>cache.put(1L, returnedUserObject)</code>，将结果存入缓存中，以便下次使用。</li>
</ol>
<hr>
<h4 id="2-2-1-CacheManager-接口：缓存管理器"><a href="#2-2-1-CacheManager-接口：缓存管理器" class="headerlink" title="2.2.1 CacheManager 接口：缓存管理器"></a>2.2.1 <code>CacheManager</code> 接口：缓存管理器</h4><p><code>CacheManager</code> 是 Spring 缓存抽象的中心接口。你可以把它理解为一个<strong>工厂和注册中心</strong>，它负责管理应用中所有 <code>Cache</code> 实例的生命周期。</p>
<p><strong>核心职责：</strong></p>
<ul>
<li><strong>管理缓存集合</strong>：它维护着一个 <code>Cache</code> 实例的集合，每个 <code>Cache</code> 都有一个唯一的名称。</li>
<li><strong>提供 <code>Cache</code> 实例</strong>：其最核心的方法是 <code>getCache(String name)</code>，用于根据名称获取一个具体的 <code>Cache</code> 对象。</li>
<li><strong>配置入口</strong>：在 Spring 配置中，我们主要配置的就是 <code>CacheManager</code>。通过配置不同的 <code>CacheManager</code> 实现类，我们可以决定应用底层使用哪种缓存技术（如 Redis, Caffeine, EhCache 等），并对其进行统一的全局设置（如过期时间、最大容量等）。</li>
</ul>
<p><strong>常见的 <code>CacheManager</code> 实现类（由 Spring Boot 自动配置提供）：</strong></p>
<ul>
<li><code>ConcurrentMapCacheManager</code>：默认的实现，使用 <code>ConcurrentHashMap</code>作为底层存储，主要用于开发和测试，功能简单，不支持持久化和过期策略。</li>
<li><code>CaffeineCacheManager</code>：集成高性能的本地缓存库 Caffeine。</li>
<li><code>RedisCacheManager</code>：集成 Redis 作为分布式缓存。</li>
<li><code>EhCacheCacheManager</code>：集成经典的 EhCache 缓存库。</li>
<li><code>CompositeCacheManager</code>：一个组合管理器，可以让你同时使用多种不同类型的 <code>CacheManager</code>。</li>
</ul>
<hr>
<h4 id="2-2-2-Cache-接口：缓存本身"><a href="#2-2-2-Cache-接口：缓存本身" class="headerlink" title="2.2.2 Cache 接口：缓存本身"></a>2.2.2 <code>Cache</code> 接口：缓存本身</h4><p><code>Cache</code> 接口是对缓存这一概念的直接抽象，它定义了所有缓存都应具备的基本操作。无论底层是 <code>HashMap</code> 还是 Redis，它们都被统一封装为 <code>Cache</code> 接口。</p>
<p><strong>核心方法：</strong></p>
<ul>
<li><code>String getName()</code>: 获取此缓存的名称。</li>
<li><code>Object getNativeCache()</code>: 返回底层的、实际的缓存对象（例如，返回一个 <code>com.github.benmanes.caffeine.cache.Cache</code> 实例或一个 Redis 连接），这允许你在需要时绕过 Spring 的抽象，直接使用特定缓存技术的高级功能。</li>
<li><code>ValueWrapper get(Object key)</code>: 根据键从缓存中获取值。注意返回值是 <code>ValueWrapper</code>，这是为了能区分“缓存值为 <code>null</code>”和“缓存中不存在该键”这两种情况。如果键不存在，此方法返回 <code>null</code>；如果键存在但其值为 <code>null</code>，则返回一个包含 <code>null</code> 的 <code>ValueWrapper</code> 对象。</li>
<li><code>&lt;T&gt; T get(Object key, Class&lt;T&gt; type)</code>: 一个方便的泛型版本，直接返回指定类型的值。</li>
<li><code>void put(Object key, Object value)</code>: 将一个键值对存入缓存。</li>
<li><code>void evict(Object key)</code>: 从缓存中移除一个键对应的数据。</li>
<li><code>void clear()</code>: 清空整个缓存中的所有数据。</li>
</ul>
<hr>
<h4 id="2-2-3-配置-CacheManager-Bean-以-Caffeine-为例"><a href="#2-2-3-配置-CacheManager-Bean-以-Caffeine-为例" class="headerlink" title="2.2.3 配置 CacheManager Bean (以 Caffeine 为例)"></a>2.2.3 配置 <code>CacheManager</code> Bean (以 Caffeine 为例)</h4><p>虽然 Spring Boot 提供了强大的自动配置，但有时我们需要更精细化的控制，比如为不同的缓存设置不同的过期时间。这时，我们可以自定义一个 <code>CacheManager</code> Bean 来覆盖默认配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 CaffeineCacheManager</span></span><br><span class="line">        <span class="type">CaffeineCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaffeineCacheManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置默认的缓存行为：写入后 10 分钟过期，最大容量 500</span></span><br><span class="line">        cacheManager.setCaffeine(Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">                .maximumSize(<span class="number">500</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要为特定的 cache name (如 &quot;users&quot;) 进行单独配置，可以这样做：</span></span><br><span class="line">        <span class="comment">// cacheManager.registerCustomCache(&quot;users&quot;,</span></span><br><span class="line">        <span class="comment">//     Caffeine.newBuilder()</span></span><br><span class="line">        <span class="comment">//         .expireAfterWrite(30, TimeUnit.MINUTES)</span></span><br><span class="line">        <span class="comment">//         .maximumSize(100)</span></span><br><span class="line">        <span class="comment">//         .build()</span></span><br><span class="line">        <span class="comment">// );</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：一旦你在配置类中定义了这样一个 <code>CacheManager</code> Bean，Spring Boot 将不会再使用它的默认自动配置，而是采用你提供的这个实例。</p>
</blockquote>
<hr>
<h4 id="2-2-4-编程式缓存操作：手动控制缓存"><a href="#2-2-4-编程式缓存操作：手动控制缓存" class="headerlink" title="2.2.4 编程式缓存操作：手动控制缓存"></a>2.2.4 编程式缓存操作：手动控制缓存</h4><p>除了使用注解，我们也可以在代码中直接注入 <code>CacheManager</code>，手动地对缓存进行读写。这在一些逻辑复杂、注解难以表达的场景下非常有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManualCacheService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取名为 &quot;users&quot; 的 Cache 对象</span></span><br><span class="line">        <span class="type">Cache</span> <span class="variable">usersCache</span> <span class="operator">=</span> cacheManager.getCache(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (usersCache == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cache &#x27;users&#x27; is not configured.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 尝试从缓存中获取数据</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> usersCache.get(id, User.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Manual cache hit for ID: &quot;</span> + id);</span><br><span class="line">            <span class="keyword">return</span> user; <span class="comment">// 缓存命中，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 缓存未命中，从数据库查询</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Manual cache miss. Fetching from DB for ID: &quot;</span> + id);</span><br><span class="line">        user = findUserInDatabase(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将查询结果放入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            usersCache.put(id, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">findUserInDatabase</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟数据库查询</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;User&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子完整地展示了不使用注解的情况下，如何通过 <code>CacheManager</code> 和 <code>Cache</code> 接口实现与 <code>@Cacheable</code> 完全相同的逻辑。</p>
<hr>
<h3 id="2-3-常用缓存提供商集成"><a href="#2-3-常用缓存提供商集成" class="headerlink" title="2.3 常用缓存提供商集成"></a>2.3 常用缓存提供商集成</h3><p>Spring 的缓存抽象本身不提供缓存的存储实现，它只是一套标准和规范。我们需要集成第三方的缓存技术来作为“提供商”（Provider），为这套规范提供具体的实现。</p>
<p>得益于 Spring Boot 强大的自动配置能力，集成这些提供商通常只需要两步：</p>
<ol>
<li><strong>添加依赖</strong>：在 <code>pom.xml</code> 中引入相应的 Starter。</li>
<li><strong>修改配置</strong>：在 <code>application.properties</code> 或 <code>application.yml</code> 中指定使用哪种缓存类型。</li>
</ol>
<p>下面我们介绍三种最主流的缓存提供商：<strong>Caffeine</strong>（本地缓存）、<strong>Redis</strong>（分布式缓存）和 <strong>EhCache</strong>（传统本地&#x2F;磁盘缓存）。</p>
<hr>
<h4 id="2-3-1-Caffeine：高性能本地缓存"><a href="#2-3-1-Caffeine：高性能本地缓存" class="headerlink" title="2.3.1 Caffeine：高性能本地缓存"></a>2.3.1 Caffeine：高性能本地缓存</h4><ul>
<li><strong>简介</strong>：Caffeine 是一个基于 Java 8 的、近乎最优的高性能本地缓存库，被认为是 Google Guava Cache 的“继任者”。它提供了丰富的缓存过期策略、容量控制和命中率统计等功能。</li>
<li><strong>适用场景</strong>：<ul>
<li>单体应用或对性能要求极高的场景。</li>
<li>缓存那些读多写少、可以接受短暂不一致的数据（因为每个应用实例都有自己的独立缓存）。</li>
<li>不需要在多个服务实例间共享缓存。</li>
</ul>
</li>
</ul>
<p><strong>集成步骤：</strong></p>
<p><strong>① 添加依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot 缓存抽象的 Starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Caffeine 缓存库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 开启缓存：</strong> 确保主类上有 <code>@EnableCaching</code> 注解。</p>
<p><strong>③ 修改配置 (<code>application.yml</code>)：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment"># 1. 告诉 Spring Boot 使用 Caffeine 作为缓存提供商</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">caffeine</span></span><br><span class="line">    <span class="comment"># 2. 配置 Caffeine 的规格 (spec)</span></span><br><span class="line">    <span class="attr">caffeine:</span></span><br><span class="line">      <span class="comment"># spec 是一种简洁的字符串格式，用于定义缓存的各种行为</span></span><br><span class="line">      <span class="comment"># initialCapacity: 初始容量</span></span><br><span class="line">      <span class="comment"># maximumSize: 最大容量</span></span><br><span class="line">      <span class="comment"># expireAfterWrite: 写入后多久过期</span></span><br><span class="line">      <span class="comment"># expireAfterAccess: 最后一次访问后多久过期</span></span><br><span class="line">      <span class="comment"># refreshAfterWrite: 写入后多久异步刷新</span></span><br><span class="line">      <span class="attr">spec:</span> <span class="string">initialCapacity=100,maximumSize=500,expireAfterWrite=10m</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>完成！</strong> 现在你项目中的所有 <code>@Cacheable</code> 等注解都会自动使用配置好的 Caffeine 缓存。无需修改任何 Java 代码。</p>
</blockquote>
<hr>
<h4 id="2-3-2-Redis：行业标准的分布式缓存"><a href="#2-3-2-Redis：行业标准的分布式缓存" class="headerlink" title="2.3.2 Redis：行业标准的分布式缓存"></a>2.3.2 Redis：行业标准的分布式缓存</h4><ul>
<li><strong>简介</strong>：Redis 是一个开源的、基于内存的键值对数据库，常被用作数据库、缓存和消息中间件。作为分布式缓存，它的数据独立于应用服务，可以被多个服务实例共享。</li>
<li><strong>适用场景</strong>：<ul>
<li>微服务架构或分布式集群环境。</li>
<li>需要跨多个服务实例共享缓存数据（例如，用户登录状态 Session 共享）。</li>
<li>缓存数据需要在应用重启后依然存在。</li>
</ul>
</li>
</ul>
<p><strong>集成步骤：</strong></p>
<p><strong>① 添加依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot 缓存抽象的 Starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring Boot Data Redis 的 Starter (它包含了 Redis 客户端和核心依赖) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 开启缓存：</strong> 确保主类上有 <code>@EnableCaching</code> 注解。</p>
<p><strong>③ 修改配置 (<code>application.yml</code>)：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># Redis 服务器连接配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># password: your-password</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment"># 1. 告诉 Spring Boot 使用 Redis 作为缓存提供商</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="comment"># 2. 配置 Redis 缓存的全局行为</span></span><br><span class="line">      <span class="comment"># 设置全局的缓存过期时间，例如 30 分钟</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="string">30m</span></span><br><span class="line">      <span class="comment"># 是否缓存 null 值，防止缓存穿透</span></span><br><span class="line">      <span class="attr">cache-null-values:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># key 的前缀，避免与其他 Redis 应用的 key 冲突</span></span><br><span class="line">      <span class="attr">key-prefix: myapp:cache:</span></span><br><span class="line">      <span class="comment"># 是否使用前缀</span></span><br><span class="line">      <span class="attr">use-key-prefix:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>④ (重要) 配置序列化方式：</strong></p>
<p>默认情况下，Spring 使用 JDK 的序列化方式将 Java 对象存入 Redis，这会导致 Redis 中存储的是二进制乱码，可读性差且有跨语言兼容性问题。<strong>生产环境中强烈推荐使用 JSON 格式序列化</strong>。</p>
<p>创建一个配置类来定义 <code>RedisCacheConfiguration</code> Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisCacheConfiguration <span class="title function_">redisCacheConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            <span class="comment">// 设置 key 的序列化方式为 String</span></span><br><span class="line">            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()))</span><br><span class="line">            <span class="comment">// 设置 value 的序列化方式为 JSON</span></span><br><span class="line">            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-3-EhCache：传统的-JCache-实现"><a href="#2-3-3-EhCache：传统的-JCache-实现" class="headerlink" title="2.3.3 EhCache：传统的 JCache 实现"></a>2.3.3 EhCache：传统的 JCache 实现</h4><ul>
<li><strong>简介</strong>：EhCache 是一个成熟的、开源的 Java 缓存框架，它完全实现了 JCache (JSR-107) 标准。它支持内存、堆外内存和磁盘等多种存储层级。</li>
<li><strong>适用场景</strong>：<ul>
<li>需要遵循 JCache 标准的项目。</li>
<li>需要在应用重启后从磁盘恢复缓存数据的单体应用。</li>
<li>一些遗留项目或对 EhCache 有深厚技术栈依赖的团队。</li>
</ul>
</li>
</ul>
<p><strong>集成步骤：</strong></p>
<p><strong>① 添加依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JCache API --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.cache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cache-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- EhCache 3 实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 创建配置文件 <code>ehcache.xml</code></strong>：</p>
<p>在 <code>src/main/resources</code> 目录下创建 <code>ehcache.xml</code> 文件来定义缓存。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.ehcache.org/v3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个名为 &quot;users&quot; 的缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">alias</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key-type</span>&gt;</span>java.lang.Long<span class="tag">&lt;/<span class="name">key-type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value-type</span>&gt;</span>com.example.myapp.model.User<span class="tag">&lt;/<span class="name">value-type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">expiry</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 缓存 10 分钟 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ttl</span> <span class="attr">unit</span>=<span class="string">&quot;minutes&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">ttl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">expiry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 堆内存中最多存储 100 个条目 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">heap</span> <span class="attr">unit</span>=<span class="string">&quot;entries&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">heap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>③ 修改配置 (<code>application.yml</code>)：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment"># 1. 告诉 Spring Boot 使用 JCache (EhCache 是其实现)</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">jcache</span></span><br><span class="line">    <span class="comment"># 2. 指定 JCache 配置文件的位置</span></span><br><span class="line">    <span class="attr">jcache:</span></span><br><span class="line">      <span class="attr">config:</span> <span class="string">classpath:ehcache.xml</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-4-总结与对比"><a href="#2-3-4-总结与对比" class="headerlink" title="2.3.4 总结与对比"></a>2.3.4 总结与对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Caffeine</th>
<th align="left">Redis</th>
<th align="left">EhCache</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型</strong></td>
<td align="left"><strong>本地缓存</strong> (In-Memory)</td>
<td align="left"><strong>分布式缓存</strong> (Remote)</td>
<td align="left"><strong>本地缓存</strong> (In-Memory, Disk)</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">单体应用、高性能读缓存</td>
<td align="left">微服务、分布式集群、需要数据共享</td>
<td align="left">JCache 标准项目、需要磁盘持久化的单体应用</td>
</tr>
<tr>
<td align="left"><strong>数据共享</strong></td>
<td align="left">否 (各实例独立)</td>
<td align="left">是 (所有实例共享)</td>
<td align="left">否 (可持久化到磁盘)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>极高</strong> (无网络开销)</td>
<td align="left">高 (有网络开销)</td>
<td align="left">较高 (磁盘模式下较慢)</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">仅 Java 库</td>
<td align="left">需要独立的 Redis Server</td>
<td align="left">仅 Java 库</td>
</tr>
<tr>
<td align="left"><strong>配置复杂度</strong></td>
<td align="left">简单 (yml)</td>
<td align="left">中等 (yml + 序列化配置)</td>
<td align="left">中等 (yml + xml)</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-邮件发送-Mail"><a href="#3-邮件发送-Mail" class="headerlink" title="3. 邮件发送 (Mail)"></a>3. 邮件发送 (Mail)</h2><p>在现代 Web 应用中，邮件发送是一项基础且不可或缺的功能，广泛应用于用户注册验证、消息通知、营销推广等场景。</p>
<p>Spring Framework 通过 <code>spring-context-support</code> 模块提供了对 JavaMail API 的高级抽象，极大地简化了邮件发送的实现。开发者无需再处理底层的、复杂的邮件协议（如 SMTP）和会话管理，只需与 Spring 提供的高层接口交互即可。</p>
<h3 id="3-1-JavaMailSender"><a href="#3-1-JavaMailSender" class="headerlink" title="3.1 JavaMailSender"></a>3.1 <code>JavaMailSender</code></h3><p><code>JavaMailSender</code> 是 Spring 邮件抽象的核心接口，它继承自 JavaMail 的 <code>MailSender</code> 接口，并为其增加了对 <code>MimeMessage</code> 的支持，使其能够发送更复杂的邮件（如包含 HTML 内容、附件或内联图片的邮件）。</p>
<p>你可以将 <code>JavaMailSender</code> 理解为 Spring 为你准备好的一个“邮件发送客户端”，它已经封装好了所有与邮件服务器通信的细节。</p>
<h4 id="3-1-1-集成-spring-boot-starter-mail"><a href="#3-1-1-集成-spring-boot-starter-mail" class="headerlink" title="3.1.1 集成 spring-boot-starter-mail"></a>3.1.1 集成 <code>spring-boot-starter-mail</code></h4><p>Spring Boot 提供了专门的 Mail Starter，它会自动配置 <code>JavaMailSender</code> Bean，我们只需要添加依赖并提供必要的配置。</p>
<p><strong>① 添加 Maven 依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 在 <code>application.yml</code> 中配置邮件服务器信息：</strong></p>
<p>以 QQ 邮箱为例（其他邮箱类似，如 163、Gmail 等）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="comment"># 邮件服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="comment"># 邮件服务器端口 (SSL 加密通常是 465 或 587)</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">465</span></span><br><span class="line">    <span class="comment"># 发件人邮箱账号</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">your-email@qq.com</span></span><br><span class="line">    <span class="comment"># 关键：这里不是邮箱的登录密码，而是开启 SMTP 服务后生成的 &quot;授权码&quot;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your-authorization-code</span></span><br><span class="line">    <span class="comment"># 协议</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">smtp</span></span><br><span class="line">    <span class="comment"># 其他属性</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail:</span></span><br><span class="line">        <span class="attr">smtp:</span></span><br><span class="line">          <span class="comment"># 开启 SSL 加密</span></span><br><span class="line">          <span class="attr">ssl:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 身份验证</span></span><br><span class="line">          <span class="attr">auth:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重要提示</strong>：<code>spring.mail.password</code> 属性对于大多数公共邮箱服务（如 QQ、163、Gmail）来说，<strong>不是你的登录密码</strong>，而是在邮箱设置中开启 SMTP 服务时生成的专用<strong>授权码</strong>或<strong>应用密码</strong>。</p>
</blockquote>
<hr>
<h4 id="3-1-2-注入并使用-JavaMailSender"><a href="#3-1-2-注入并使用-JavaMailSender" class="headerlink" title="3.1.2 注入并使用 JavaMailSender"></a>3.1.2 注入并使用 <code>JavaMailSender</code></h4><p>配置完成后，Spring Boot 会自动创建一个 <code>JavaMailSender</code> 的实例并放入 IoC 容器。我们可以在任何 Spring Bean（如 <code>@Service</code>）中直接 <code>@Autowired</code> 注入它。</p>
<p><strong>1. 发送简单文本邮件 (<code>SimpleMailMessage</code>)</strong></p>
<p><code>SimpleMailMessage</code> 是一个简单的 JavaBean，用于封装纯文本邮件的基本信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从配置文件中获取发件人邮箱</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fromEmail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送一封简单的文本邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to 收件人地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 邮件正文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSimpleMail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">        message.setFrom(fromEmail); <span class="comment">// 发件人</span></span><br><span class="line">        message.setTo(to); <span class="comment">// 收件人</span></span><br><span class="line">        message.setSubject(subject); <span class="comment">// 主题</span></span><br><span class="line">        message.setText(content); <span class="comment">// 正文</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            System.out.println(<span class="string">&quot;简单邮件发送成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;发送简单邮件时发生异常！&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 发送复杂邮件 (<code>MimeMessage</code>)</strong></p>
<p>对于需要发送 HTML、附件或内联图片的邮件，我们需要使用 <code>MimeMessage</code>。Spring 提供了 <code>MimeMessageHelper</code> 类来简化 <code>MimeMessage</code> 的创建过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="comment">// ... (注入 mailSender 和 fromEmail 同上)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送一封复杂的邮件（HTML + 附件 + 内联资源）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to 收件人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> htmlContent HTML 内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attachmentPath 附件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inlineImagePath 内联图片路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rscId 内联资源的 Content-ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendComplexMail</span><span class="params">(String to, String subject, String htmlContent,</span></span><br><span class="line"><span class="params">                                String attachmentPath, String inlineImagePath, String rscId)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 MimeMessage 实例</span></span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// MimeMessageHelper：true 表示创建一个 multipart message</span></span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            helper.setFrom(fromEmail);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置 HTML 内容 (第二个参数 true 表示这是一个 HTML)</span></span><br><span class="line">            helper.setText(htmlContent, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加附件</span></span><br><span class="line">            <span class="keyword">if</span> (attachmentPath != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">FileSystemResource</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(attachmentPath));</span><br><span class="line">                <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getFilename();</span><br><span class="line">                helper.addAttachment(fileName, file);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加内联资源 (例如，在 HTML 中通过 cid:rscId 引用)</span></span><br><span class="line">            <span class="comment">// &lt;img src=&#x27;cid:rscId&#x27; /&gt;</span></span><br><span class="line">            <span class="keyword">if</span> (inlineImagePath != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">FileSystemResource</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(inlineImagePath));</span><br><span class="line">                helper.addInline(rscId, res);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mailSender.send(mimeMessage);</span><br><span class="line">            System.out.println(<span class="string">&quot;复杂邮件发送成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;发送复杂邮件时发生异常！&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-3-最佳实践与注意事项"><a href="#3-1-3-最佳实践与注意事项" class="headerlink" title="3.1.3 最佳实践与注意事项"></a>3.1.3 最佳实践与注意事项</h4><ul>
<li><strong>异步发送</strong>：邮件发送是一个网络 I&#x2F;O 操作，可能会有延迟，阻塞当前线程。在 Web 应用中，强烈建议将邮件发送操作<strong>异步化</strong>。只需在发送方法上添加 <code>@Async</code> 注解，并开启异步支持（<code>@EnableAsync</code>），即可让邮件在后台线程池中发送，从而立即响应用户请求。</li>
<li><strong>模板引擎</strong>：硬编码 HTML 字符串是不好的实践。应该集成模板引擎（如 Thymeleaf, FreeMarker）来动态生成邮件内容，实现视图与逻辑的分离，使邮件模板更易于维护。</li>
<li><strong>异常处理</strong>：邮件发送可能会因为网络问题、认证失败等原因抛出 <code>MailException</code>。必须进行适当的 <code>try-catch</code> 处理，记录日志，甚至可以实现失败重试机制。</li>
<li><strong>安全性</strong>：避免在代码中硬编码敏感信息（如邮箱密码&#x2F;授权码），应始终将其放在配置文件中，并通过版本控制系统（如 Git）的 <code>.gitignore</code> 文件忽略该配置文件，防止敏感信息泄露。</li>
</ul>
<hr>
<h3 id="3-2-发送简单邮件、附件邮件、内联资源邮件"><a href="#3-2-发送简单邮件、附件邮件、内联资源邮件" class="headerlink" title="3.2 发送简单邮件、附件邮件、内联资源邮件"></a>3.2 发送简单邮件、附件邮件、内联资源邮件</h3><p>在 <code>JavaMailSender</code> 的基础上，Spring 提供了不同的消息对象和辅助类来构建这三类邮件。我们将分别展示它们的具体实现。</p>
<p>为了方便演示，我们假设已经创建了一个 <code>MailService</code> 类，并注入了 <code>JavaMailSender</code> 和发件人邮箱地址 <code>fromEmail</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fromEmail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 下面的方法都将定义在这个类中 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-发送简单文本邮件-Simple-Text-Mail"><a href="#3-2-1-发送简单文本邮件-Simple-Text-Mail" class="headerlink" title="3.2.1 发送简单文本邮件 (Simple Text Mail)"></a>3.2.1 发送简单文本邮件 (Simple Text Mail)</h4><p>这是最基础的邮件形式，只包含纯文本内容，没有任何格式、图片或附件。</p>
<ul>
<li><strong>核心类</strong>：<code>org.springframework.mail.SimpleMailMessage</code></li>
<li><strong>特点</strong>：构建简单，开销小，适用于发送验证码、系统通知等场景。</li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送一封简单的文本邮件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to 收件人地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content 邮件正文 (纯文本)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSimpleMail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个简单的邮件消息对象</span></span><br><span class="line">    <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置邮件的基本信息</span></span><br><span class="line">    message.setFrom(fromEmail);</span><br><span class="line">    message.setTo(to);</span><br><span class="line">    message.setSubject(subject);</span><br><span class="line">    message.setText(content);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 发送邮件</span></span><br><span class="line">        mailSender.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;简单文本邮件发送成功！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;发送简单文本邮件时发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-2-发送带附件的邮件-Mail-with-Attachments"><a href="#3-2-2-发送带附件的邮件-Mail-with-Attachments" class="headerlink" title="3.2.2 发送带附件的邮件 (Mail with Attachments)"></a>3.2.2 发送带附件的邮件 (Mail with Attachments)</h4><p>当需要在邮件中附加文件（如报告、发票、图片等）时，就需要创建一封 “multipart” (多部分) 格式的邮件。</p>
<ul>
<li><strong>核心类</strong>：<code>javax.mail.internet.MimeMessage</code></li>
<li><strong>辅助类</strong>：<code>org.springframework.mail.javamail.MimeMessageHelper</code></li>
<li><strong>关键方法</strong>：<code>helper.addAttachment(String attachmentFilename, InputStreamSource inputStreamSource)</code></li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送一封带附件的邮件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to 收件人地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content 邮件正文 (可以是 HTML)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath 附件的文件路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendAttachmentMail</span><span class="params">(String to, String subject, String content, String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 MimeMessage 对象</span></span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 MimeMessageHelper 来构建邮件，true 表示需要创建一个 multipart message</span></span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置邮件的基本信息</span></span><br><span class="line">        helper.setFrom(fromEmail);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content, <span class="literal">true</span>); <span class="comment">// true 表示邮件内容为 HTML 格式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加附件</span></span><br><span class="line">        <span class="type">FileSystemResource</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getFilename(); <span class="comment">// 获取文件名</span></span><br><span class="line">        <span class="keyword">if</span> (fileName != <span class="literal">null</span>) &#123;</span><br><span class="line">            helper.addAttachment(fileName, file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送邮件</span></span><br><span class="line">        mailSender.send(mimeMessage);</span><br><span class="line">        System.out.println(<span class="string">&quot;附件邮件发送成功！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;发送附件邮件时发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-3-发送带内联资源的邮件-Mail-with-Inline-Resources"><a href="#3-2-3-发送带内联资源的邮件-Mail-with-Inline-Resources" class="headerlink" title="3.2.3 发送带内联资源的邮件 (Mail with Inline Resources)"></a>3.2.3 发送带内联资源的邮件 (Mail with Inline Resources)</h4><p>内联资源（通常是图片）是指嵌入到邮件正文中、作为内容一部分显示的资源，而不是作为单独的附件。这常用于创建图文并茂的富文本邮件。</p>
<ul>
<li><strong>核心类</strong>：<code>javax.mail.internet.MimeMessage</code></li>
<li><strong>辅助类</strong>：<code>org.springframework.mail.javamail.MimeMessageHelper</code></li>
<li><strong>关键方法</strong>：<code>helper.addInline(String contentId, Resource resource)</code></li>
<li><strong>核心机制</strong>：通过 <code>Content-ID</code> (cid) 将 HTML 中的 <code>&lt;img&gt;</code> 标签与邮件中的内联资源关联起来。</li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送一封带内联资源的邮件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to 收件人地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imagePath 内联图片的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInlineResourceMail</span><span class="params">(String to, String subject, String imagePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 这是我们的 HTML 邮件内容，注意看 img 标签的 src 属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">rscId</span> <span class="operator">=</span> <span class="string">&quot;logo001&quot;</span>; <span class="comment">// 定义一个内容ID (Content-ID)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">htmlContent</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span> +</span><br><span class="line">                         <span class="string">&quot;&lt;h1&gt;这是一封带内联图片的邮件&lt;/h1&gt;&quot;</span> +</span><br><span class="line">                         <span class="string">&quot;&lt;h3&gt;图片如下：&lt;/h3&gt;&quot;</span> +</span><br><span class="line">                         <span class="string">&quot;&lt;img src=&#x27;cid:&quot;</span> + rscId + <span class="string">&quot;&#x27; /&gt;&quot;</span> + <span class="comment">// 使用 cid: 引用内联资源</span></span><br><span class="line">                         <span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        helper.setFrom(fromEmail);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(htmlContent, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加内联资源</span></span><br><span class="line">        <span class="type">FileSystemResource</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(imagePath));</span><br><span class="line">        <span class="comment">// 使用 addInline 方法，第一个参数是 Content-ID，必须与 HTML 中的 cid 一致</span></span><br><span class="line">        helper.addInline(rscId, res);</span><br><span class="line"></span><br><span class="line">        mailSender.send(mimeMessage);</span><br><span class="line">        System.out.println(<span class="string">&quot;内联资源邮件发送成功！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;发送内联资源邮件时发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-4-总结与对比"><a href="#3-2-4-总结与对比" class="headerlink" title="3.2.4 总结与对比"></a>3.2.4 总结与对比</h4><table>
<thead>
<tr>
<th align="left">邮件类型</th>
<th align="left">核心类&#x2F;辅助类</th>
<th align="left">关键方法&#x2F;步骤</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>简单文本邮件</strong></td>
<td align="left"><code>SimpleMailMessage</code></td>
<td align="left">直接设置 <code>from</code>, <code>to</code>, <code>subject</code>, <code>text</code> 属性。</td>
<td align="left">发送纯文本通知、验证码等。</td>
</tr>
<tr>
<td align="left"><strong>附件邮件</strong></td>
<td align="left"><code>MimeMessage</code> + <code>MimeMessageHelper</code></td>
<td align="left"><code>new MimeMessageHelper(mimeMessage, true)</code><br/><code>helper.addAttachment(...)</code></td>
<td align="left">发送报告、文档、合同等文件。</td>
</tr>
<tr>
<td align="left"><strong>内联资源邮件</strong></td>
<td align="left"><code>MimeMessage</code> + <code>MimeMessageHelper</code></td>
<td align="left"><code>helper.addInline(contentId, ...)</code><br/>在HTML中使用 <code>&lt;img src=&#39;cid:contentId&#39;&gt;</code></td>
<td align="left">创建图文并茂的营销邮件、欢迎邮件等。</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-3-模板邮件发送"><a href="#3-3-模板邮件发送" class="headerlink" title="3.3 模板邮件发送"></a>3.3 模板邮件发送</h3><p>在前面的示例中，我们直接在 Java 代码中拼接 HTML 字符串来构建邮件内容。这种方式存在明显的问题：</p>
<ul>
<li><strong>难以维护</strong>：HTML 代码和 Java 逻辑混杂在一起，可读性差。如果邮件样式需要修改，就必须改动 Java 代码并重新编译部署。</li>
<li><strong>职责不清</strong>：开发人员需要关心邮件的视觉样式，而 UI&#x2F;UX 设计师无法直接参与邮件模板的设计。</li>
<li><strong>复用性差</strong>：无法轻松地复用邮件的布局和结构。</li>
</ul>
<p><strong>解决方案</strong>：使用<strong>模板引擎</strong>。模板引擎允许我们将邮件的结构和样式定义在独立的模板文件中，将动态数据与静态布局分离。在发送邮件时，程序会加载模板，用具体的数据填充模板中的占位符，最终生成完整的 HTML 内容。</p>
<p>Spring Boot 与多种模板引擎都能完美集成，其中最常用的是 <strong>Thymeleaf</strong> 和 <strong>FreeMarker</strong>。我们以 Thymeleaf 为例进行详细说明。</p>
<p><strong>核心流程</strong></p>
<ol>
<li><strong>添加依赖</strong>：引入模板引擎的 Starter。</li>
<li><strong>创建模板</strong>：在 <code>src/main/resources/templates/</code> 目录下创建一个 HTML 模板文件。</li>
<li><strong>处理模板</strong>：在 Java 代码中，注入 <code>TemplateEngine</code>，创建一个数据模型（<code>Context</code>），然后调用 <code>process</code> 方法来渲染模板，生成最终的 HTML 字符串。</li>
<li><strong>发送邮件</strong>：将生成的 HTML 字符串作为邮件正文发送。</li>
</ol>
<hr>
<h4 id="3-3-1-集成-Thymeleaf"><a href="#3-3-1-集成-Thymeleaf" class="headerlink" title="3.3.1 集成 Thymeleaf"></a>3.3.1 集成 Thymeleaf</h4><p>在 <code>pom.xml</code> 中添加 Thymeleaf 的 Starter。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-2-创建邮件模板"><a href="#3-3-2-创建邮件模板" class="headerlink" title="3.3.2 创建邮件模板"></a>3.3.2 创建邮件模板</h4><p>在 <code>src/main/resources/templates/</code> 目录下创建一个名为 <code>mailTemplate.html</code> 的文件。Thymeleaf 的语法非常自然，可以直接用浏览器打开预览。</p>
<p><strong><code>mailTemplate.html</code> 示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>邮件模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>您好, <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>!<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>欢迎您注册我们的服务！这是您的验证码：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: blue; font-weight: bold; font-size: 20px;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;verificationCode&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>请在5分钟内使用。如果您没有请求此验证码，请忽略本邮件。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>感谢您的支持！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>-- Spring Boot 团队<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code>: 引入 Thymeleaf 的命名空间。</li>
<li><code>th:text=&quot;${...}&quot;</code>: 这是 Thymeleaf 的核心语法，用于将 <code>${...}</code> 中变量的值替换掉标签内的文本。<code>${username}</code> 和 <code>${verificationCode}</code> 就是我们稍后需要从 Java 代码中传入的动态数据。</li>
</ul>
<hr>
<h4 id="3-3-3-实现模板邮件发送服务"><a href="#3-3-3-实现模板邮件发送服务" class="headerlink" title="3.3.3 实现模板邮件发送服务"></a>3.3.3 实现模板邮件发送服务</h4><p>在 <code>MailService</code> 中，我们需要注入 Thymeleaf 的 <code>TemplateEngine</code>，并创建一个新方法来处理和发送模板邮件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine; <span class="comment">// 注入模板引擎</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fromEmail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送基于 Thymeleaf 模板的邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to 收件人</span></span><br><span class="line"><span class="comment">     *   subject 主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名 (模板中的变量)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verificationCode 验证码 (模板中的变量)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTemplateMail</span><span class="params">(String to, String subject, String username, String verificationCode)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个 Thymeleaf 的上下文对象 (Context)</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 设置模板中需要替换的变量</span></span><br><span class="line">        context.setVariable(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        context.setVariable(<span class="string">&quot;verificationCode&quot;</span>, verificationCode);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 使用模板引擎渲染模板，生成最终的 HTML 字符串</span></span><br><span class="line">        <span class="comment">// 第一个参数是模板文件的名称 (相对于 templates/ 目录，无需 .html 后缀)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">emailContent</span> <span class="operator">=</span> templateEngine.process(<span class="string">&quot;mailTemplate&quot;</span>, context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 创建 MimeMessage 并发送</span></span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line">            helper.setFrom(fromEmail);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(emailContent, <span class="literal">true</span>); <span class="comment">// true 表示内容是 HTML</span></span><br><span class="line"></span><br><span class="line">            mailSender.send(mimeMessage);</span><br><span class="line">            System.out.println(<span class="string">&quot;模板邮件发送成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;发送模板邮件时发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优势与最佳实践</strong></p>
<ul>
<li><strong>彻底的职责分离</strong>：设计师可以专注于 <code>mailTemplate.html</code> 的美化，而程序员只需关心如何准备数据和调用发送逻辑。</li>
<li><strong>代码整洁</strong>：Java 代码中不再有大段的、丑陋的 HTML 字符串。</li>
<li><strong>国际化 (i18n)</strong>：Thymeleaf 等模板引擎通常具有强大的国际化支持。你可以为不同语言创建不同的模板或资源文件，根据用户的语言环境发送相应语言的邮件。</li>
<li><strong>逻辑处理</strong>：模板引擎通常支持条件判断（<code>th:if</code>）、循环（<code>th:each</code>）等简单逻辑，可以构建非常复杂的动态邮件内容（如订单确认邮件中的商品列表）。</li>
<li><strong>异步发送</strong>：模板渲染和邮件发送都应该是异步的。在 <code>sendTemplateMail</code> 方法上添加 <code>@Async</code> 注解，可以确保用户请求被立即响应，而耗时的邮件任务在后台执行。</li>
</ul>
<hr>
<h2 id="4-异步执行-Asynchronous-Execution"><a href="#4-异步执行-Asynchronous-Execution" class="headerlink" title="4. 异步执行 (Asynchronous Execution)"></a>4. 异步执行 (Asynchronous Execution)</h2><p>在同步执行模型中，当一个方法被调用时，调用者必须等待该方法完全执行完毕并返回结果后，才能继续执行后续的代码。对于一些耗时较长的操作（如文件上传、数据批量处理、发送邮件&#x2F;短信、调用慢速的第三方 API），这种同步等待会严重影响系统性能和用户体验，导致线程长时间阻塞，降低系统的吞吐量。</p>
<p>异步执行则解决了这个问题。它允许将耗时的任务提交给一个独立的后台线程（通常来自一个线程池）来执行，而调用者线程则可以立即返回，继续处理其他事情，无需等待。</p>
<p><strong>核心优势：</strong></p>
<ul>
<li><strong>提升响应速度</strong>：特别是在 Web 应用中，可以将非核心的耗时操作异步化，从而快速响应用户请求，改善用户体验。</li>
<li><strong>提高系统吞吐量</strong>：通过将任务分配给专门的线程池，可以更有效地利用 CPU 资源，并发处理更多任务。</li>
<li><strong>任务解耦</strong>：将主流程与耗时任务解耦，使系统架构更清晰、更具弹性。</li>
</ul>
<p>Spring 框架通过 <code>@Async</code> 注解，提供了一种非侵入式的、声明式的方式来实现方法的异步调用。</p>
<h3 id="4-1-Async-注解"><a href="#4-1-Async-注解" class="headerlink" title="4.1 @Async 注解"></a>4.1 <code>@Async</code> 注解</h3><p><code>@Async</code> 是 Spring 提供的一个方法级别的注解。当它被应用到一个方法上时，Spring 会为该方法创建一个代理。当这个被代理的方法被调用时，Spring 会将实际的方法执行逻辑提交到一个线程池中异步执行，并立即返回一个 <code>Future</code> 对象给调用者。</p>
<h4 id="4-1-1-开启异步支持"><a href="#4-1-1-开启异步支持" class="headerlink" title="4.1.1 开启异步支持"></a>4.1.1 开启异步支持</h4><p>要使 <code>@Async</code> 注解生效，必须在 Spring Boot 的主启动类或任何一个配置类（<code>@Configuration</code>）上添加 <code>@EnableAsync</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">// 开启异步方法执行功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@EnableAsync</code> 注解会激活 Spring 对 <code>@Async</code> 注解的发现和代理机制。</p>
<h4 id="4-1-2-创建异步方法"><a href="#4-1-2-创建异步方法" class="headerlink" title="4.1.2 创建异步方法"></a>4.1.2 创建异步方法</h4><p>在一个 Spring Bean 中（如 <code>@Service</code> 或 <code>@Component</code>），将 <code>@Async</code> 注解添加到需要异步执行的 public 方法上。</p>
<h5 id="1-无返回值的异步方法-void"><a href="#1-无返回值的异步方法-void" class="headerlink" title="1. 无返回值的异步方法 (void)"></a>1. 无返回值的异步方法 (<code>void</code>)</h5><p>这是最简单的异步场景，常用于“执行并忘记”(fire-and-forget) 的任务，如记录日志、发送通知等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始发送邮件... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时 3 秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;邮件发送完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncTaskService asyncTaskService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test-async&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testAsync</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Controller 开始执行... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        asyncTaskService.sendEmail(); <span class="comment">// 立即返回，不会等待 3 秒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Controller 执行完毕！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Async task submitted!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>执行结果分析</strong>：</p>
<p>访问 <code>/test-async</code> 接口，你会立即在控制台看到：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Controller 开始执行... 当前线程: http-nio-8080-exec-1</span><br><span class="line">Controller 执行完毕！</span><br><span class="line">开始发送邮件... 当前线程: task-1  &lt;-- 注意！线程名变了</span><br></pre></td></tr></table></figure>

<p>大约 3 秒后，才会看到：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">邮件发送完成！</span><br></pre></td></tr></table></figure>

<p>这证明了 <code>sendEmail()</code> 方法是在一个名为 <code>task-1</code> 的后台线程中执行的，而主线程 <code>http-nio-8080-exec-1</code> 没有被阻塞。</p>
</blockquote>
<hr>
<h5 id="2-有返回值的异步方法-Future-CompletableFuture"><a href="#2-有返回值的异步方法-Future-CompletableFuture" class="headerlink" title="2. 有返回值的异步方法 (Future &#x2F; CompletableFuture)"></a>2. 有返回值的异步方法 (<code>Future</code> &#x2F; <code>CompletableFuture</code>)</h5><p>如果调用者需要获取异步任务的执行结果（或检查其执行状态），异步方法的返回值类型必须是 <code>java.util.concurrent.Future</code>、<code>java.util.concurrent.CompletableFuture</code> 或 Spring 的 <code>org.springframework.util.concurrent.ListenableFuture</code>。</p>
<p><code>CompletableFuture</code> (Java 8+) 是目前推荐的方式，因为它功能更强大，支持链式调用和回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">fetchUserData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始获取用户数据... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时 5 秒</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;User data fetched successfully!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户数据获取完成！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(result); <span class="comment">// 将结果包装在 CompletableFuture 中返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callAsyncWithResult</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始调用异步任务...&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;String&gt; future = asyncTaskService.fetchUserData();</span><br><span class="line">    System.out.println(<span class="string">&quot;异步任务已提交，主线程继续执行其他事情...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 在这里可以做其他工作 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当需要结果时，调用 get() 方法阻塞等待</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 这行会阻塞，直到异步任务完成</span></span><br><span class="line">    System.out.println(<span class="string">&quot;获取到异步任务的结果: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-3-重要使用规则与陷阱"><a href="#4-1-3-重要使用规则与陷阱" class="headerlink" title="4.1.3 重要使用规则与陷阱"></a>4.1.3 重要使用规则与陷阱</h4><p><code>@Async</code> 的实现依赖于 Spring AOP 代理，因此必须遵守 AOP 的使用规则，否则注解会失效：</p>
<ol>
<li><p><strong>只能应用于 public 方法</strong>：<code>@Async</code> 对 <code>protected</code>、<code>private</code> 或包级私有的方法无效。</p>
</li>
<li><p><strong>方法必须定义在 Spring Bean 中</strong>：该方法所在的类必须被 Spring 容器管理（例如，有 <code>@Service</code>, <code>@Component</code> 等注解）。</p>
</li>
<li><p><strong>避免类内部调用 (self-invocation)</strong>：</p>
<ul>
<li><p><strong>错误示例</strong>：在同一个类中，一个 <code>public</code> 方法调用同一个类的另一个 <code>@Async</code> 方法，异步会失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这样调用是错误的！异步不会生效！</span></span><br><span class="line">        <span class="built_in">this</span>.asyncMethod(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原因</strong>：<code>syncMethod</code> 通过 <code>this</code> 关键字调用 <code>asyncMethod</code>，这是直接的对象内部调用，绕过了 Spring 创建的代理对象，因此 AOP 切面无法拦截，异步逻辑也就无法触发。</p>
</li>
<li><p><strong>解决方案</strong>：将 <code>@Async</code> 方法移到另一个独立的 Bean 中，然后通过注入的方式来调用它。</p>
</li>
</ul>
</li>
<li><p><strong>默认线程池</strong>：Spring Boot 会自动配置一个 <code>ThreadPoolTaskExecutor</code> 作为默认的异步线程池。如果需要更精细的控制（如核心线程数、队列容量、拒绝策略等），建议自定义线程池。我们将在下一节详细讨论。</p>
</li>
</ol>
<hr>
<h3 id="4-2-自定义线程池"><a href="#4-2-自定义线程池" class="headerlink" title="4.2 自定义线程池"></a>4.2 自定义线程池</h3><h4 id="4-2-1-为什么需要自定义线程池？"><a href="#4-2-1-为什么需要自定义线程池？" class="headerlink" title="4.2.1 为什么需要自定义线程池？"></a>4.2.1 为什么需要自定义线程池？</h4><p>Spring Boot 会为 <code>@Async</code>  提供一个默认的线程池（<code>ThreadPoolTaskExecutor</code>）。虽然开箱即用很方便，但在生产环境中，依赖默认配置通常是不够的，原因如下：</p>
<ol>
<li><strong>资源隔离与控制</strong>：默认情况下，所有 <code>@Async</code> 任务共享同一个线程池。如果一种类型的异步任务（如文件处理）执行得非常慢且数量巨大，它可能会占满所有线程，导致其他更重要的异步任务（如发送验证码）被阻塞或延迟执行。通过为不同类型的业务创建不同的线程池，可以实现资源隔离。</li>
<li><strong>精细化配置</strong>：默认线程池的参数（如核心线程数、最大线程数、队列容量）可能不适合你的应用负载。例如，对于 I&#x2F;O 密集型任务，你可能需要更多的线程；对于 CPU 密集型任务，线程数通常设置为 CPU 核心数左右。自定义线程池允许你根据业务特性进行精细化配置。</li>
<li><strong>命名与监控</strong>：为线程池指定一个有意义的名称（如 <code>email-task-executor</code>），可以在日志和监控工具（如 JMX, Prometheus）中清晰地识别出是哪个线程池在执行任务，便于问题排查和性能分析。</li>
<li><strong>拒绝策略</strong>：当线程池和任务队列都满了之后，新提交的任务该如何处理？默认的拒绝策略可能会抛出异常。你可以自定义拒绝策略，例如记录日志后丢弃、由调用者线程自己执行等。</li>
</ol>
<hr>
<h4 id="4-2-2-实现方式"><a href="#4-2-2-实现方式" class="headerlink" title="4.2.2 实现方式"></a>4.2.2 实现方式</h4><p>在 Spring 中自定义线程池主要有两种方式：</p>
<ol>
<li><strong>重写默认线程池</strong>：通过定义一个特定类型的 Bean 来覆盖 Spring Boot 的默认配置。</li>
<li><strong>创建多个线程池</strong>：定义多个 <code>TaskExecutor</code> Bean，并在 <code>@Async</code> 注解中指定使用哪一个。</li>
</ol>
<h5 id="1-重写默认的异步线程池"><a href="#1-重写默认的异步线程池" class="headerlink" title="1. 重写默认的异步线程池"></a>1. 重写默认的异步线程池</h5><p>如果你希望整个应用的所有 <code>@Async</code> 调用都使用统一的、自定义配置的线程池，可以创建一个 <code>TaskExecutor</code> 类型的 Bean。Spring Boot 在自动配置时，如果发现容器中已经存在一个 <code>TaskExecutor</code> Bean，就会使用它，而不再创建默认的。</p>
<p><strong>实现步骤：</strong></p>
<p>在一个配置类（<code>@Configuration</code>）中定义一个 <code>Bean</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;taskExecutor&quot;)</span> <span class="comment">// Bean 的名称可以自定义，Spring 会优先寻找名为 &quot;taskExecutor&quot; 的 Bean</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 核心线程数：线程池创建时初始化的线程数</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>); </span><br><span class="line">        <span class="comment">// 最大线程数：线程池最大的线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>); </span><br><span class="line">        <span class="comment">// 缓冲队列：用来缓冲执行任务的队列</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 允许线程的空闲时间 (当超过核心线程数时，多余的线程会被销毁)</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">// 线程池名的前缀：设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;default-async-&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拒绝策略：当线程池和队列都满了，表明达到了最大处理能力，该如何处理新来的任务</span></span><br><span class="line">        <span class="comment">// AbortPolicy: 直接抛出 RejectedExecutionException 异常 (默认)</span></span><br><span class="line">        <span class="comment">// CallerRunsPolicy: 由调用者线程处理该任务</span></span><br><span class="line">        <span class="comment">// DiscardPolicy: 丢弃最新的任务，不处理</span></span><br><span class="line">        <span class="comment">// DiscardOldestPolicy: 丢弃队列最前面的任务，然后重新尝试执行当前任务</span></span><br><span class="line">        <span class="comment">// executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待所有任务结束后再关闭线程池</span></span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：完成以上配置后，所有未指定线程池的 <code>@Async</code> 方法都会自动使用这个名为 <code>taskExecutor</code> 的线程池。</p>
</blockquote>
<hr>
<h5 id="2-创建并使用多个线程池"><a href="#2-创建并使用多个线程池" class="headerlink" title="2. 创建并使用多个线程池"></a>2. 创建并使用多个线程池</h5><p>这是一种更灵活、更推荐的方式，尤其是在复杂的应用中。你可以为不同业务场景创建专用的线程池。</p>
<p><strong>实现步骤：</strong></p>
<p><strong>在配置类中定义多个 <code>Executor</code> Bean，并为它们指定唯一的名称。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultipleAsyncConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池一：用于处理邮件发送任务</span></span><br><span class="line">    <span class="meta">@Bean(&quot;emailTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">emailTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">50</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;email-async-&quot;</span>);</span><br><span class="line">        <span class="comment">// 拒绝策略：由调用者线程执行，确保邮件不会轻易丢失</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程池二：用于处理数据分析任务 (CPU 密集型)</span></span><br><span class="line">    <span class="meta">@Bean(&quot;dataAnalysisTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">dataAnalysisTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">// CPU 密集型任务，线程数不宜过多</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">coreCount</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        executor.setCorePoolSize(coreCount);</span><br><span class="line">        executor.setMaxPoolSize(coreCount * <span class="number">2</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;data-analysis-async-&quot;</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在使用 <code>@Async</code> 注解时，通过其 <code>value</code> 属性指定要使用的线程池 Bean 的名称。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定使用名为 &quot;emailTaskExecutor&quot; 的线程池</span></span><br><span class="line">    <span class="meta">@Async(&quot;emailTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送邮件... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// ... 邮件发送逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAnalysisService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定使用名为 &quot;dataAnalysisTaskExecutor&quot; 的线程池</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataAnalysisTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">analyzeData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;分析数据... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// ... 复杂的数据计算逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：如果 <code>@Async</code> 注解没有指定 <code>value</code>，它会去寻找名为 <code>taskExecutor</code> 的 Bean，或者 Spring Boot 的默认线程池。</p>
</blockquote>
<hr>
<h4 id="4-2-3-总结"><a href="#4-2-3-总结" class="headerlink" title="4.2.3 总结"></a>4.2.3 总结</h4><ul>
<li><strong>默认配置用于开发</strong>：Spring Boot 的默认异步线程池适合快速开发和简单场景。</li>
<li><strong>自定义用于生产</strong>：在生产环境中，<strong>强烈建议</strong>根据业务需求自定义一个或多个线程池。</li>
<li><strong>资源隔离是关键</strong>：为不同类型的异步任务（特别是重要程度、耗时特性不同的任务）分配独立的线程池，是保证系统稳定性的重要手段。</li>
<li><strong>合理配置参数</strong>：线程池的核心参数（<code>corePoolSize</code>, <code>maxPoolSize</code>, <code>queueCapacity</code>）需要根据任务是 <strong>CPU 密集型</strong>还是 <strong>I&#x2F;O 密集型</strong>，以及系统的负载情况来综合评估和调整。</li>
</ul>
<hr>
<h3 id="4-3-异步返回值"><a href="#4-3-异步返回值" class="headerlink" title="4.3 异步返回值"></a>4.3 异步返回值</h3><p>当一个 <code>@Async</code> 方法的返回类型是 <code>void</code> 时，它是一个“即发即忘”(fire-and-forget)的任务。调用者无法得知任务何时完成，也无法获取其执行结果或捕获其内部抛出的异常。</p>
<p>为了解决这个问题，Spring 的 <code>@Async</code> 方法支持返回特定的类型，这些类型充当了未来某个时间点才会产生的“结果占位符”。</p>
<p>主流的异步返回值类型有三种：<code>Future</code>、<code>CompletableFuture</code> 和 Spring 自带的 <code>ListenableFuture</code>。</p>
<hr>
<h4 id="4-3-1-Future：经典的异步结果句柄"><a href="#4-3-1-Future：经典的异步结果句柄" class="headerlink" title="4.3.1 Future&lt;T&gt;：经典的异步结果句柄"></a>4.3.1 <code>Future&lt;T&gt;</code>：经典的异步结果句柄</h4><p><code>java.util.concurrent.Future</code> 是 Java 5 引入的标准接口，代表一个异步计算的结果。</p>
<p><strong>工作方式：</strong></p>
<p>当调用返回 <code>Future&lt;T&gt;</code> 的 <code>@Async</code> 方法时，调用会立即返回一个 <code>Future</code> 对象。这个对象是一个“句柄”，你可以通过它来检查任务是否完成、取消任务，或者<strong>阻塞等待</strong>并获取最终的结果。</p>
<p><strong>实现示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;String&gt; <span class="title function_">findUser</span><span class="params">(String username)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始查找用户: &quot;</span> + username + <span class="string">&quot; on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;用户信息: &quot;</span> + username;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 Spring 提供的 AsyncResult 来包装结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsyncResult</span>&lt;&gt;(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用方如何使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callFutureTask</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程发起异步调用...&quot;</span>);</span><br><span class="line">    Future&lt;String&gt; futureResult = futureTaskService.findUser(<span class="string">&quot;JohnDoe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!futureResult.isDone()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程正在做其他事情，同时检查异步任务是否完成...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isDone() 返回 true 后，调用 get() 不会阻塞或只会短暂阻塞</span></span><br><span class="line">    <span class="comment">// 如果在 isDone() 为 false 时调用 get()，主线程会一直阻塞直到任务完成</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureResult.get(); </span><br><span class="line">    System.out.println(<span class="string">&quot;获取到异步结果: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Future</code> 的局限性：</strong></p>
<ul>
<li><strong>阻塞式获取结果</strong>：<code>future.get()</code> 是一个阻塞操作。虽然任务是异步执行的，但为了获取结果，主线程最终还是得停下来等待。</li>
<li><strong>无法链式操作</strong>：你不能方便地指定“当任务A完成后，用它的结果去执行任务B”。这种编排逻辑写起来非常笨拙。</li>
<li><strong>无回调机制</strong>：<code>Future</code> 没有提供一个“任务完成后请通知我”的回调机制，你只能通过 <code>isDone()</code> 去轮询，效率低下。</li>
</ul>
<hr>
<h4 id="4-3-2-CompletableFuture：推荐的现代异步编程方式"><a href="#4-3-2-CompletableFuture：推荐的现代异步编程方式" class="headerlink" title="4.3.2 CompletableFuture&lt;T&gt;：推荐的现代异步编程方式"></a>4.3.2 <code>CompletableFuture&lt;T&gt;</code>：推荐的现代异步编程方式</h4><p><code>java.util.concurrent.CompletableFuture</code> 是 Java 8 引入的，它不仅实现了 <code>Future</code> 接口，还实现了 <code>CompletionStage</code> 接口，提供了极其强大的函数式、非阻塞的异步编程能力。<strong>它是目前处理异步返回值的最佳选择。</strong></p>
<p><strong>工作方式：</strong></p>
<p>它支持<strong>回调</strong>和<strong>链式调用</strong>。你可以定义一系列操作，当异步任务完成时，这些操作会自动被触发，整个过程可以做到非阻塞。</p>
<p><strong>实现示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;taskExecutor&quot;)</span> <span class="comment">// 推荐指定一个线程池</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">processData</span><span class="params">(String data)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始处理数据: &quot;</span> + data + <span class="string">&quot; on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">4000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;error&quot;</span>.equals(data)) &#123;</span><br><span class="line">            <span class="comment">// 模拟异常情况</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid data provided&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;处理结果: &quot;</span> + data.toUpperCase();</span><br><span class="line">        <span class="comment">// 使用工厂方法返回一个已完成的 CompletableFuture</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：如果 <code>@Async</code> 方法内部抛出异常，Spring 会自动捕获它，并返回一个“异常完成”的 <code>CompletableFuture</code>。</p>
</blockquote>
<p><strong>调用方如何使用（展示其强大之处）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callCompletableFutureTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程发起异步调用...&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;String&gt; future = completableFutureTaskService.processData(<span class="string">&quot;my-data&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链式调用：非阻塞地定义后续操作</span></span><br><span class="line">    future.thenApply(result -&gt; &#123;</span><br><span class="line">        <span class="comment">// 当 future 完成时，这个转换操作会被执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一步转换 on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Transformed -&gt; &quot;</span> + result;</span><br><span class="line">    &#125;).thenAccept(finalResult -&gt; &#123;</span><br><span class="line">        <span class="comment">// 当上一步转换完成后，这个消费操作会被执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果消费: &quot;</span> + finalResult + <span class="string">&quot; on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">        <span class="comment">// 如果在任何一步出现异常，这个处理器会被调用</span></span><br><span class="line">        System.err.println(<span class="string">&quot;发生异常: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回一个默认值或 null</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;主线程已设置好回调，继续执行自己的任务，完全不阻塞。&quot;</span>);</span><br><span class="line">    <span class="comment">// 主线程可以继续做其他事情，例如等待其他任务或直接结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>CompletableFuture</code> 的核心优势</strong>：</p>
<ul>
<li><strong>非阻塞回调</strong>：通过 <code>thenApply</code>, <code>thenAccept</code>, <code>thenRun</code> 等方法，可以定义任务完成后自动执行的逻辑。</li>
<li><strong>强大的组合能力</strong>：可以通过 <code>thenCombine</code>（组合两个异步结果）、<code>allOf</code>（等待所有任务完成）、<code>anyOf</code>（等待任一任务完成）等方法编排复杂的异步工作流。</li>
<li><strong>优雅的异常处理</strong>：通过 <code>exceptionally</code> 和 <code>handle</code> 方法，可以集中处理异步链中的异常，代码更清晰。</li>
</ul>
</blockquote>
<hr>
<h4 id="4-3-3-ListenableFuture-已过时"><a href="#4-3-3-ListenableFuture-已过时" class="headerlink" title="4.3.3 ListenableFuture&lt;T&gt; (已过时)"></a>4.3.3 <code>ListenableFuture&lt;T&gt;</code> (已过时)</h4><p>这是 Spring 框架自己提供的一个接口，在 Java 8 的 <code>CompletableFuture</code> 出现之前，它用来弥补 <code>Future</code> 缺少回调机制的不足。</p>
<p>它的工作方式是通过 <code>addCallback</code> 方法注册成功和失败的回调。</p>
<p>由于 <code>CompletableFuture</code> 的功能更全面且已成为 Java 标准，<strong><code>ListenableFuture</code> 现在已经不推荐在新项目中使用。</strong> 了解即可。</p>
<hr>
<h4 id="4-3-4-总结对比"><a href="#4-3-4-总结对比" class="headerlink" title="4.3.4 总结对比"></a>4.3.4 总结对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>Future&lt;T&gt;</code></th>
<th align="left"><code>CompletableFuture&lt;T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>获取结果</strong></td>
<td align="left"><strong>阻塞式</strong> (<code>get()</code> 方法)</td>
<td align="left"><strong>非阻塞</strong> (通过回调) 或 阻塞 (<code>get()</code>)</td>
</tr>
<tr>
<td align="left"><strong>编排能力</strong></td>
<td align="left"><strong>弱</strong>，难以组合多个异步任务</td>
<td align="left"><strong>强</strong>，支持链式调用 (<code>thenApply</code>) 和组合 (<code>thenCombine</code>)</td>
</tr>
<tr>
<td align="left"><strong>异常处理</strong></td>
<td align="left">笨拙 (通过 <code>try-catch ExecutionException</code>)</td>
<td align="left"><strong>优雅</strong> (通过 <code>exceptionally</code>, <code>handle</code> 回调)</td>
</tr>
<tr>
<td align="left"><strong>回调支持</strong></td>
<td align="left">不支持</td>
<td align="left"><strong>核心特性</strong></td>
</tr>
<tr>
<td align="left"><strong>Java 版本</strong></td>
<td align="left">Java 5+</td>
<td align="left">Java 8+</td>
</tr>
<tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left">不推荐用于复杂场景</td>
<td align="left"><strong>强烈推荐</strong></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/" class="post-title-link" itemprop="url">JavaServlet</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-09 21:21:19" itemprop="dateCreated datePublished" datetime="2025-10-09T21:21:19+08:00">2025-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 16:07:22" itemprop="dateModified" datetime="2025-10-17T16:07:22+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">Web协议与服务器</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、Servlet-基础与核心概念"><a href="#一、Servlet-基础与核心概念" class="headerlink" title="一、Servlet 基础与核心概念"></a>一、Servlet 基础与核心概念</h1><h2 id="1-Servlet-是什么？"><a href="#1-Servlet-是什么？" class="headerlink" title="1. Servlet 是什么？"></a>1. Servlet 是什么？</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>Servlet（Server Applet，服务器端小程序）是一种运行在 Web 服务器或应用服务器上的 <strong>Java 程序</strong>。它作为客户端请求（Request）和服务器响应（Response）之间的中间层，用于<strong>生成动态的 Web 内容</strong>。</p>
<p>简单来说，Servlet 就是一个遵循特定规范（Servlet API）的 Java 类，由一个叫做 <strong>“Servlet 容器”</strong>（如 Tomcat）的程序来加载和管理。它的核心职责就是处理客户端发来的请求，并向客户端做出响应。</p>
<p><strong>核心要点:</strong></p>
<ul>
<li><strong>Java 编写：</strong> Servlet 完全使用 Java 语言编写，因此具备 Java 跨平台的特性。</li>
<li><strong>服务器端运行：</strong> 它被部署在 Web 服务器内部，由 Servlet 容器管理其生命周期。</li>
<li><strong>处理请求与响应：</strong> 它的主要工作是接收 HTTP 请求，进行业务逻辑处理（如查询数据库、调用其他服务），然后生成 HTTP 响应（如一个 HTML 页面、JSON 数据）并返回给客户端。</li>
<li><strong>技术规范：</strong> Servlet 是一套标准的 Java API（最初在 <code>javax.servlet</code> 包中，现在是 <code>jakarta.servlet</code> 包），是 Java EE &#x2F; Jakarta EE 规范的核心组成部分，也是构建 Java Web 应用的基石。</li>
</ul>
<hr>
<h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><p>Servlet 的核心作用是<strong>充当 Web 客户端和服务器端业务逻辑之间的桥梁</strong>，动态地处理请求并生成响应。它使得开发者能够使用 Java 语言来扩展 Web 服务器的功能。</p>
<p>具体来说，Servlet 的作用可以细分为以下几个方面：</p>
<ol>
<li><strong>接收和解析客户端请求：</strong><ul>
<li>从 HTTP 请求中读取和解析数据，例如：<ul>
<li>用户在表单中提交的数据 (<code>request.getParameter()</code>)。</li>
<li>URL 中的查询字符串。</li>
<li>HTTP 请求头信息（如浏览器类型、Cookie 等）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理业务逻辑：</strong><ul>
<li>这是 Servlet 的核心职责。它可以根据接收到的请求数据执行任何 Java 代码可以完成的任务。</li>
<li>例如：验证用户登录、与数据库交互（增删改查）、调用其他服务（如微服务、EJB）、执行复杂的计算等。</li>
</ul>
</li>
<li><strong>生成和发送动态响应：</strong><ul>
<li>根据业务逻辑的处理结果，动态地生成响应内容并将其发送回客户端。</li>
<li>响应内容可以是：<ul>
<li>一个完整的 HTML 页面。</li>
<li>JSON 或 XML 格式的数据（常用于 AJAX 和 RESTful API）。</li>
<li>一个重定向指令，让浏览器跳转到另一个页面。</li>
<li>二进制数据流，如图片、PDF 文件等。</li>
</ul>
</li>
</ul>
</li>
<li><strong>管理会话状态：</strong><ul>
<li>HTTP 协议本身是无状态的。Servlet 通过 <code>HttpSession</code> API 能够在多次请求之间跟踪和维持同一个用户的状态。</li>
<li>例如：实现用户登录状态的保持、维护购物车内容等。</li>
</ul>
</li>
<li><strong>在 MVC 模式中充当控制器 (Controller)：</strong><ul>
<li>在经典的 MVC (Model-View-Controller) 设计模式中，Servlet 扮演着<strong>控制器</strong>的角色。它接收所有用户请求，调用业务逻辑（Model），然后选择合适的视图（View，通常是 JSP）来渲染和展示结果。这是 Java Web 开发中最常见的模式。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-3-与-CGI-的对比"><a href="#1-3-与-CGI-的对比" class="headerlink" title="1.3 与 CGI 的对比"></a>1.3 与 CGI 的对比</h3><p>Servlet 的出现主要是为了解决传统 <strong>CGI (Common Gateway Interface, 通用网关接口)</strong> 技术的性能瓶颈问题。CGI 是早期用于在 Web 服务器上执行外部程序以生成动态内容的一种标准。</p>
<table>
<thead>
<tr>
<th>特性 (Feature)</th>
<th>CGI (Common Gateway Interface)</th>
<th>Servlet</th>
</tr>
</thead>
<tbody><tr>
<td><strong>工作模式</strong><br>(Working Model)</td>
<td><strong>多进程模式 (Multi-process)</strong>。<br>每次 HTTP 请求，Web 服务器都会创建一个<strong>全新的独立进程</strong>来执行 CGI 脚本。</td>
<td><strong>多线程模式 (Multi-thread)</strong>。<br>Servlet 实例在容器中<strong>只创建一次</strong>，后续每个请求都由一个<strong>独立的线程</strong>在同一个实例上处理。</td>
</tr>
<tr>
<td><strong>性能与效率</strong><br>(Performance)</td>
<td><strong>低效</strong>。<br>进程的创建和销毁是非常耗时的系统操作，会产生巨大的性能开销。</td>
<td><strong>高效</strong>。<br>线程的创建和切换开销远小于进程。Servlet 实例常驻内存，无需为每个请求重复加载和初始化。</td>
</tr>
<tr>
<td><strong>资源消耗</strong><br>(Resource Usage)</td>
<td><strong>高</strong>。<br>每个请求对应一个进程，会消耗大量的内存和 CPU 资源。</td>
<td><strong>低</strong>。<br>多个线程共享同一个 Servlet 实例的方法区和堆内存，资源利用率极高。</td>
</tr>
<tr>
<td><strong>生命周期</strong><br>(Lifecycle)</td>
<td><strong>请求即生命</strong>。<br>请求处理完毕后，CGI 进程就被销毁，无法维持状态。</td>
<td><strong>长生命周期</strong>。<br>从第一次加载到应用被卸载，Servlet 实例一直存在，可以通过 <code>init()</code> 进行资源初始化，并由容器统一管理。</td>
</tr>
<tr>
<td><strong>可扩展性</strong><br>(Scalability)</td>
<td><strong>差</strong>。<br>当并发请求量增大时，服务器会因创建大量进程而迅速达到资源极限，导致性能急剧下降。</td>
<td><strong>好</strong>。<br>能够轻松地处理成千上万的并发请求，具有优秀的扩展能力。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-4-Servlet-容器（Web-容器）"><a href="#1-4-Servlet-容器（Web-容器）" class="headerlink" title="1.4 Servlet 容器（Web 容器）"></a>1.4 Servlet 容器（Web 容器）</h3><p><strong>Servlet 容器</strong>，也常被称为 <strong>Web 容器</strong>，是一个提供了 Servlet 运行环境的软件组件。它负责管理 Servlet 的整个生命周期，并处理网络通信的底层细节。</p>
<p>简单来说，<strong>Servlet 只是一个遵循特定接口的 Java 类，它本身并不能独立运行</strong>。它必须被部署到 Servlet 容器中，由容器来加载、实例化、调用和销毁。</p>
<h4 id="1-4-1-核心职责"><a href="#1-4-1-核心职责" class="headerlink" title="1.4.1 核心职责"></a>1.4.1 核心职责</h4><h5 id="1-生命周期管理-Lifecycle-Management"><a href="#1-生命周期管理-Lifecycle-Management" class="headerlink" title="1. 生命周期管理 (Lifecycle Management):"></a>1. 生命周期管理 (Lifecycle Management):</h5><ul>
<li><strong>加载和实例化：</strong> 当容器启动或第一次接收到对某个 Servlet 的请求时，它会加载该 Servlet 类并创建一个实例。</li>
<li><strong>初始化：</strong> 调用 Servlet 实例的 <code>init()</code> 方法进行初始化。</li>
<li><strong>请求处理：</strong> 当请求到来时，调用 Servlet 实例的 <code>service()</code> 方法。</li>
<li><strong>销毁：</strong> 当容器关闭或应用被移除时，调用 Servlet 实例的 <code>destroy()</code> 方法释放资源。</li>
<li><strong>开发者不直接调用这些生命周期方法，而是由容器在特定时机自动调用。</strong></li>
</ul>
<hr>
<h5 id="2-通信支持-Communication-Support"><a href="#2-通信支持-Communication-Support" class="headerlink" title="2. 通信支持 (Communication Support):"></a>2. 通信支持 (Communication Support):</h5><ul>
<li>作为 Web 服务器的一部分或与 Web 服务器集成，负责监听特定的网络端口（如 8080）。</li>
<li>接收客户端（如浏览器）发送的 TCP 连接和 HTTP 请求数据流。</li>
<li>将 Servlet 处理后的结果打包成 HTTP 响应格式，通过网络发送回客户端。</li>
</ul>
<hr>
<h5 id="3-请求解析与封装-Request-Parsing-and-Wrapping"><a href="#3-请求解析与封装-Request-Parsing-and-Wrapping" class="headerlink" title="3. 请求解析与封装 (Request Parsing and Wrapping):"></a>3. 请求解析与封装 (Request Parsing and Wrapping):</h5><ul>
<li>容器会将原始的、基于文本的 HTTP 请求数据流解析成开发者易于使用的对象，即 <code>HttpServletRequest</code>。</li>
<li>同时，它会创建一个空的 <code>HttpServletResponse</code> 对象，供 Servlet 写入响应数据。</li>
<li>这两个对象作为参数传递给 Servlet 的 <code>service()</code> 方法。</li>
</ul>
<hr>
<h5 id="4-多线程管理-Multithreading-Management"><a href="#4-多线程管理-Multithreading-Management" class="headerlink" title="4. 多线程管理 (Multithreading Management):"></a>4. 多线程管理 (Multithreading Management):</h5><ul>
<li>Servlet 默认是<strong>单实例多线程</strong>的。容器接收到多个并发请求时，会为每个请求分配一个线程（通常来自线程池），然后这些线程<strong>共享同一个 Servlet 实例</strong>去执行 <code>service()</code> 方法。</li>
<li>这极大地提高了性能，但也要求开发者必须注意<strong>线程安全</strong>问题。</li>
</ul>
<hr>
<h5 id="5-提供其他-Java-EE-Jakarta-EE-技术支持："><a href="#5-提供其他-Java-EE-Jakarta-EE-技术支持：" class="headerlink" title="5. 提供其他 Java EE &#x2F; Jakarta EE 技术支持："></a>5. 提供其他 Java EE &#x2F; Jakarta EE 技术支持：</h5><ul>
<li>除了 Servlet，容器还负责管理和提供 JSP（JavaServer Pages）、Filter（过滤器）、Listener（监听器）等的运行环境。例如，它负责将 JSP 文件编译成 Servlet。</li>
</ul>
<hr>
<h4 id="1-4-2-简要工作流程"><a href="#1-4-2-简要工作流程" class="headerlink" title="1.4.2 简要工作流程"></a>1.4.2 简要工作流程</h4><pre><code class="highlight mermaid">sequenceDiagram
    %% 1. 客户端发送请求
    Client-&gt;&gt;Container: 1. 发送 HTTP 请求

    %% 2-5. 容器处理请求并调用 Servlet
    activate Container
    Note over Container: 2. 接收到请求
    Note over Container: 3. 根据 URL 在 web.xml/注解中查找 Servlet
    Note over Container: 4. 封装 Request 和 Response 对象
    
    Container-&gt;&gt;ThreadPool: 5a. 从线程池获取线程
    activate ThreadPool
    ThreadPool--&gt;&gt;Container: 返回工作线程
    deactivate ThreadPool
    
    Container-&gt;&gt;Servlet: 5b. 调用 service(request, response)
    activate Servlet

    %% 6. Servlet 执行业务逻辑
    Note right of Servlet: 6. 执行业务逻辑，&lt;br/&gt;并将结果写入 Response 对象
    
    %% 7-8. Servlet 返回，容器发送响应
    Servlet--&gt;&gt;Container: service() 方法执行完毕
    deactivate Servlet
    
    Container-&gt;&gt;ThreadPool: 7. 将线程归还到线程池
    activate ThreadPool
    deactivate ThreadPool
    
    Note over Container: 8a. 从 Response 对象生成 HTTP 响应
    Container--&gt;&gt;Client: 8b. 发送最终的 HTTP 响应
    deactivate Container</code></pre>

<ol>
<li>客户端（浏览器）向服务器发送一个 HTTP 请求。</li>
<li><strong>Servlet 容器</strong>（如 Tomcat）接收到这个请求。</li>
<li>容器根据请求的 URL，在 <code>web.xml</code> 或注解中查找并确定应该由哪个 Servlet 来处理。</li>
<li>容器将原始请求数据封装成 <code>HttpServletRequest</code> 对象，并创建一个 <code>HttpServletResponse</code> 对象。</li>
<li>容器从线程池中获取一个线程，调用目标 Servlet 实例的 <code>service()</code> 方法，并将 request 和 response 对象作为参数传入。</li>
<li>Servlet 在 <code>service()</code> 方法中执行业务逻辑，处理数据，并将结果写入 <code>HttpServletResponse</code> 对象。</li>
<li><code>service()</code> 方法执行完毕后，线程被归还到线程池。</li>
<li>容器从 <code>HttpServletResponse</code> 对象中生成最终的 HTTP 响应，并将其发送回客户端。</li>
</ol>
<hr>
<h4 id="1-4-3-常见的-Servlet-容器"><a href="#1-4-3-常见的-Servlet-容器" class="headerlink" title="1.4.3 常见的 Servlet 容器"></a>1.4.3 常见的 Servlet 容器</h4><ul>
<li><strong>Apache Tomcat:</strong> 最流行、最广泛使用的开源 Servlet&#x2F;JSP 容器，是 Servlet 规范的官方参考实现。</li>
<li><strong>Jetty:</strong> 一个轻量级、高度可嵌入的开源 Servlet 容器。</li>
<li><strong>GlassFish:</strong> Oracle 开发的，Jakarta EE 规范的官方参考实现，是一个完整的应用服务器。</li>
<li><strong>WildFly (原 JBoss):</strong> Red Hat 公司开发的开源应用服务器。</li>
</ul>
<hr>
<h2 id="2-Servlet-生命周期"><a href="#2-Servlet-生命周期" class="headerlink" title="2. Servlet 生命周期"></a>2. Servlet 生命周期</h2><h3 id="2-1-加载与实例化"><a href="#2-1-加载与实例化" class="headerlink" title="2.1 加载与实例化"></a>2.1 加载与实例化</h3><p>这是 Servlet 生命周期的<strong>第一个阶段</strong>。在这个阶段，Servlet 容器会找到 Servlet 对应的 <code>.class</code> 文件，将其加载到 JVM 内存中，并创建一个 Servlet 实例。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>执行时机：</strong> 加载和实例化的动作<strong>只会发生一次</strong>。</li>
<li><strong>结果：</strong> 在整个 Web 应用的生命周期中，一个 Servlet 类<strong>只有一个实例</strong>存在。这也就是我们常说的 Servlet 是**“单例多线程”**模式。</li>
</ul>
<h4 id="2-1-1-触发时机"><a href="#2-1-1-触发时机" class="headerlink" title="2.1.1 触发时机"></a>2.1.1 触发时机</h4><p>Servlet 容器在何时进行加载和实例化，主要有两种情况：</p>
<ol>
<li><p><strong>第一次被访问时（默认行为）</strong></p>
<ul>
<li>这是容器的默认策略，也称为<strong>延迟加载 (Lazy Loading)</strong>。</li>
<li>当第一个匹配该 Servlet 的 HTTP 请求到来时，容器才会去创建 Servlet 实例。</li>
<li><strong>优点：</strong> 节约服务器资源，如果某个 Servlet 一直未被访问，它就不会被实例化，不会占用内存。</li>
<li><strong>缺点：</strong> 第一个访问该 Servlet 的用户会经历一个明显的延迟，因为容器需要完成加载、实例化和初始化这几个步骤。</li>
</ul>
</li>
<li><p><strong>Web 应用启动时</strong></p>
<ul>
<li><p>我们可以配置 Servlet 在 Web 应用启动时就立即被加载和实例化，也称为<strong>立即加载 (Eager Loading)</strong>。</p>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li>可以将耗时的初始化工作（如建立数据库连接池、加载配置文件等）在服务器启动时完成，确保第一个用户访问时能获得快速响应。</li>
<li>可以确保某些需要在应用启动时就运行的后台任务或服务能够被正确初始化。</li>
</ul>
</li>
<li><p><strong>配置方式：</strong></p>
<ul>
<li><strong>XML (<code>web.xml</code>)</strong>: 在 <code>&lt;servlet&gt;</code> 标签内配置 <code>&lt;load-on-startup&gt;</code>。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span> <span class="comment">&lt;!-- 数字越小，优先级越高 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注解 (<code>@WebServlet</code>)</strong>: 在注解中设置 <code>loadOnStartup</code> 属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/myServlet&quot;, loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意:</strong> <code>&lt;load-on-startup&gt;</code> 的值是一个非负整数。值越小，该 Servlet 的启动优先级越高。如果值为负数或未设置，则采用默认的延迟加载策略。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p><strong>过程简述：<strong>Servlet 容器通过 Java 的反射机制，调用 Servlet 类的</strong>公共无参构造方法</strong>来创建实例。因此，我们自定义的 Servlet 必须提供一个公共的无参构造函数（通常我们不写，Java 会提供一个默认的）。</p>
<hr>
<h3 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h3><p>这是 Servlet 生命周期的<strong>第二个阶段</strong>，紧跟在加载与实例化之后。在这个阶段，Servlet 容器会调用 Servlet 实例的 <code>init()</code> 方法。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>执行时机：</strong> 在 Servlet 实例被创建后，<strong>立即执行</strong>，且在 Servlet 的整个生命周期中<strong>只会被执行一次</strong>。</li>
<li><strong>主要目的：</strong> 执行一次性的、耗时的准备工作，为后续处理请求做好准备。</li>
</ul>
<h4 id="2-2-1-init-方法的作用"><a href="#2-2-1-init-方法的作用" class="headerlink" title="2.2.1 init() 方法的作用"></a>2.2.1 <code>init()</code> 方法的作用</h4><p><code>init()</code> 方法就像一个类的构造函数，但它专门为 Servlet 的环境而设计。我们通常会重写此方法来完成以下任务：</p>
<ol>
<li><strong>加载配置文件：</strong> 读取 <code>.properties</code> 或 <code>.xml</code> 等配置文件。</li>
<li><strong>建立数据库连接：</strong> 创建数据库连接或初始化一个数据库连接池。</li>
<li><strong>初始化缓存：</strong> 将一些需要频繁访问但不常变动的数据加载到内存中，形成缓存。</li>
<li><strong>读取“初始化参数”：</strong> 获取在 <code>web.xml</code> 或注解中为该特定 Servlet 配置的参数。</li>
</ol>
<h4 id="2-2-2-init-方法签名"><a href="#2-2-2-init-方法签名" class="headerlink" title="2.2.2 init() 方法签名"></a>2.2.2 <code>init()</code> 方法签名</h4><p><code>init()</code> 方法在 <code>javax.servlet.Servlet</code> 接口中定义，其声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数 <code>ServletConfig config</code>：</strong><ul>
<li>这是 <code>init()</code> 方法最重要的部分。容器在调用 <code>init()</code> 方法时，会传入一个 <code>ServletConfig</code> 对象。</li>
<li><code>ServletConfig</code> 对象封装了该 Servlet 的配置信息。</li>
<li>通过 <code>ServletConfig</code> 对象，我们可以：<ul>
<li><code>getServletName()</code>: 获取 Servlet 的名称。</li>
<li><code>getServletContext()</code>: 获取代表整个 Web 应用的 <code>ServletContext</code> 对象。</li>
<li><strong><code>getInitParameter(String name)</code></strong>: 获取在部署描述符（<code>web.xml</code>）或注解中配置的<strong>初始化参数</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-3-代码示例"><a href="#2-2-3-代码示例" class="headerlink" title="2.2.3 代码示例"></a>2.2.3 代码示例</h4><p>假设我们在 <code>web.xml</code> 中为 Servlet 配置了初始化参数：</p>
<p><strong>web.xml 配置:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ConfigDemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.ConfigDemoServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义初始化参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>adminEmail<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>admin@example.com<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Servlet Java 代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigDemoServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String servletEncoding; <span class="comment">// 定义一个成员变量来存储配置信息</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 1. 【非常重要】调用父类的 init 方法，将 ServletConfig 对象保存起来</span></span><br><span class="line">        <span class="built_in">super</span>.init(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 通过 config 对象获取初始化参数</span></span><br><span class="line">        <span class="built_in">this</span>.servletEncoding = config.getInitParameter(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">adminEmail</span> <span class="operator">=</span> config.getInitParameter(<span class="string">&quot;adminEmail&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行初始化逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.servletEncoding == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.servletEncoding = <span class="string">&quot;ISO-8859-1&quot;</span>; <span class="comment">// 如果未配置，则使用默认值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Servlet 初始化完成...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;编码格式: &quot;</span> + <span class="built_in">this</span>.servletEncoding);</span><br><span class="line">        System.out.println(<span class="string">&quot;管理员邮箱: &quot;</span> + adminEmail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 在后续处理请求时，就可以使用在 init 方法中初始化的变量</span></span><br><span class="line">        resp.setCharacterEncoding(<span class="built_in">this</span>.servletEncoding);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello, encoding is set to &quot;</span> + <span class="built_in">this</span>.servletEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>最佳实践：</strong></p>
<p>当我们重写 <code>init(ServletConfig config)</code> 方法时，<strong>强烈建议在方法的第一行调用 <code>super.init(config);</code></strong>。</p>
<p>这是因为父类 <code>GenericServlet</code> 的 <code>init()</code> 方法会将 <code>ServletConfig</code> 对象保存下来，以便我们后续可以通过 <code>getServletConfig()</code> 或 <code>getServletContext()</code> 等方法来获取它。如果不调用 <code>super.init(config)</code>，后续调用这些方法将会抛出 <code>NullPointerException</code>。</p>
</blockquote>
<hr>
<h3 id="2-3-处理请求"><a href="#2-3-处理请求" class="headerlink" title="2.3 处理请求"></a>2.3 处理请求</h3><p>这是 Servlet 生命周期的<strong>第三个阶段</strong>，也是 Servlet 存在的主要目的。一旦 Servlet 完成了实例化和初始化，它就会处于“就绪”状态，等待并处理来自客户端的请求。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>执行时机：</strong> <strong>每当</strong>有一个客户端请求与该 Servlet 的 URL 匹配时，容器就会调用其服务方法。这个阶段会<strong>被重复执行无数次</strong>。</li>
<li><strong>核心方法：</strong> <code>service()</code> 方法是所有请求的入口点。</li>
<li><strong>线程模型：</strong> 容器会为每个请求分配一个线程来执行 <code>service()</code> 方法。多个线程会<strong>并发地访问同一个 Servlet 实例</strong>，因此必须注意<strong>线程安全</strong>问题。</li>
</ul>
<h4 id="2-3-1-service-方法"><a href="#2-3-1-service-方法" class="headerlink" title="2.3.1 service() 方法"></a>2.3.1 <code>service()</code> 方法</h4><p><code>Servlet</code> 接口中定义了 <code>service()</code> 方法，它是处理所有请求的起点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException;</span><br></pre></td></tr></table></figure>

<p>然而，在实际开发中，我们通常继承的是 <code>HttpServlet</code>。<code>HttpServlet</code> 对 <code>service()</code> 方法进行了重写，使其能够根据 HTTP 请求的类型（GET, POST, PUT, DELETE 等）来分发请求。</p>
<hr>
<h4 id="2-3-2-HttpServlet-的请求分发机制"><a href="#2-3-2-HttpServlet-的请求分发机制" class="headerlink" title="2.3.2 HttpServlet 的请求分发机制"></a>2.3.2 <code>HttpServlet</code> 的请求分发机制</h4><p><code>HttpServlet</code> 的 <code>service()</code> 方法内部实现了一个<strong>分发器</strong>。其工作流程如下：</p>
<ol>
<li>容器接收到请求，调用 <code>HttpServlet</code> 的 <code>service(HttpServletRequest req, HttpServletResponse res)</code> 方法。</li>
<li><code>service()</code> 方法内部会通过 <code>req.getMethod()</code> 获取请求的类型（例如 “GET” 或 “POST”）。</li>
<li>它会使用一个大的 <code>if-else</code> 或 <code>switch</code> 结构，根据请求类型，调用与之对应的 <code>doXXX()</code> 方法。<ul>
<li>如果请求是 GET，就调 用 <code>doGet(req, res)</code>。</li>
<li>如果请求是 POST，就调用 <code>doPost(req, res)</code>。</li>
<li>以此类推，还有 <code>doPut()</code>, <code>doDelete()</code> 等。</li>
</ul>
</li>
</ol>
<p><strong>这就是为什么我们通常不需要重写 <code>service()</code> 方法，而是去重写 <code>doGet()</code> 或 <code>doPost()</code> 方法。</strong></p>
<hr>
<h4 id="2-3-3-doGet-与-doPost-方法"><a href="#2-3-3-doGet-与-doPost-方法" class="headerlink" title="2.3.3 doGet() 与 doPost() 方法"></a>2.3.3 <code>doGet()</code> 与 <code>doPost()</code> 方法</h4><p>这两个是我们最常重写的方法，用于实现具体的业务逻辑。</p>
<ul>
<li><code>protected void doGet(HttpServletRequest request, HttpServletResponse response)</code><ul>
<li>处理 HTTP GET 请求。GET 请求通常用于从服务器获取数据，例如点击链接、在浏览器地址栏直接输入 URL。</li>
</ul>
</li>
<li><code>protected void doPost(HttpServletRequest request, HttpServletResponse response)</code><ul>
<li>处理 HTTP POST 请求。POST 请求通常用于向服务器提交数据，例如提交一个表单。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-4-线程安全问题"><a href="#2-3-4-线程安全问题" class="headerlink" title="2.3.4 线程安全问题"></a>2.3.4 线程安全问题</h4><p>这是 Servlet 中一个非常重要且容易出错的概念。</p>
<ul>
<li><strong>原因：</strong> Servlet 容器对每个 Servlet 类只创建一个实例。当多个请求同时到达时，容器会启动多个线程，这些线程<strong>共享这唯一的 Servlet 实例</strong>。</li>
<li><strong>风险：</strong> 如果你在 Servlet 中定义了<strong>成员变量 (Instance Variables)</strong>，并且在 <code>doGet()</code> 或 <code>doPost()</code> 方法中对它进行了修改操作（写操作），那么就会发生线程安全问题。多个线程可能会同时读写这个共享变量，导致数据错乱。</li>
</ul>
<p><strong>最佳实践：</strong></p>
<ol>
<li><strong>避免使用成员变量来存储请求相关的状态。</strong></li>
<li><strong>优先使用局部变量 (Local Variables)。</strong> 在 <code>doGet()</code> 或 <code>doPost()</code> 方法内部定义的变量是局部变量，它们存储在每个线程独有的栈空间中，因此是线程安全的。</li>
<li>如果确实需要使用成员变量来共享数据（例如，一个访问计数器），必须使用同步机制（如 <code>synchronized</code> 关键字或 <code>java.util.concurrent</code> 包中的锁）来保证线程安全。</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个成员变量，如果对其进行写操作，需要考虑线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">accessCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 业务逻辑开始 ---</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取请求参数 (name 是局部变量，线程安全)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            name = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 处理业务 (更新共享的计数器，使用原子类保证线程安全)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentCount</span> <span class="operator">=</span> accessCounter.incrementAndGet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 设置响应内容</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h1&gt;Hello, &quot;</span> + name + <span class="string">&quot;!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;p&gt;You are the &quot;</span> + currentCount + <span class="string">&quot; visitor.&lt;/p&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 业务逻辑结束 ---</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-销毁"><a href="#2-4-销毁" class="headerlink" title="2.4 销毁"></a>2.4 销毁</h3><p>这是 Servlet 生命周期的<strong>最后一个阶段</strong>。当 Servlet 容器决定不再需要该 Servlet 实例时（例如，服务器关闭或 Web 应用被移除），它会调用 Servlet 的 <code>destroy()</code> 方法，为实例的“死亡”做最后的清理工作。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>执行时机：</strong> 在 Servlet 实例从服务中被移除之前执行。</li>
<li><strong>执行次数：</strong> 与 <code>init()</code> 方法一样，<code>destroy()</code> 方法在 Servlet 的整个生命周期中也<strong>只会被执行一次</strong>。</li>
<li><strong>主要目的：</strong> 释放 Servlet 在 <code>init()</code> 方法中创建的资源，或者在处理请求过程中持有的持久化资源。</li>
</ul>
<h4 id="2-4-1-destroy-方法的作用"><a href="#2-4-1-destroy-方法的作用" class="headerlink" title="2.4.1 destroy() 方法的作用"></a>2.4.1 <code>destroy()</code> 方法的作用</h4><p><code>destroy()</code> 方法是 <code>init()</code> 方法的对应操作。如果在 <code>init()</code> 中分配了资源，那么 <code>destroy()</code> 就是释放这些资源的最佳地点。</p>
<p>典型的清理任务包括：</p>
<ol>
<li><strong>关闭数据库连接：</strong> 关闭在 <code>init()</code> 中创建的数据库连接或销毁连接池。</li>
<li><strong>关闭文件流：</strong> 关闭打开的文件句柄或 I&#x2F;O 流。</li>
<li><strong>中断后台线程：</strong> 如果 Servlet 启动了一些后台任务线程，需要在这里优雅地停止它们。</li>
<li><strong>保存状态：</strong> 在应用关闭前，将一些内存中的状态数据（如访问计数器）持久化到文件或数据库中。</li>
</ol>
<hr>
<h4 id="2-4-2-destroy-方法签名"><a href="#2-4-2-destroy-方法签名" class="headerlink" title="2.4.2 destroy() 方法签名"></a>2.4.2 <code>destroy()</code> 方法签名</h4><p><code>destroy()</code> 方法在 <code>javax.servlet.Servlet</code> 接口中定义，其签名非常简单，没有任何参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-3-销毁方法的调用时机"><a href="#2-4-3-销毁方法的调用时机" class="headerlink" title="2.4.3 销毁方法的调用时机"></a>2.4.3 销毁方法的调用时机</h4><p>Servlet 容器会在以下几种情况下调用 <code>destroy()</code> 方法：</p>
<ol>
<li><strong>Web 应用被卸载（Undeployed）：</strong> 当你从容器中移除一个 Web 应用时，容器会销毁该应用中所有的 Servlet 实例。</li>
<li><strong>Servlet 容器正常关闭或停止：</strong> 当你正常关闭 Tomcat 等服务器时，容器会优雅地销毁它管理的所有 Servlet。</li>
<li><strong>重新部署（Redeploy）应用时：</strong> 在不停止服务器的情况下重新部署应用，容器会先销毁旧应用的 Servlet 实例，然后再创建新应用的实例。</li>
</ol>
<hr>
<h4 id="2-4-4-代码示例"><a href="#2-4-4-代码示例" class="headerlink" title="2.4.4 代码示例"></a>2.4.4 代码示例</h4><p>假设一个 Servlet 在初始化时打开了一个日志文件写入器，那么它必须在销毁时关闭这个写入器，以防止资源泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrintWriter logWriter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取文件真实路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">logFilePath</span> <span class="operator">=</span> getServletContext().getRealPath(<span class="string">&quot;/WEB-INF/logs/servlet.log&quot;</span>);</span><br><span class="line">            <span class="comment">// 在初始化时，打开一个文件写入器作为资源</span></span><br><span class="line">            <span class="comment">// true 表示追加模式</span></span><br><span class="line">            <span class="built_in">this</span>.logWriter = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(logFilePath, <span class="literal">true</span>));</span><br><span class="line">            logWriter.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">            logWriter.println(<span class="string">&quot;ResourceServlet initialized.&quot;</span>);</span><br><span class="line">            logWriter.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;Log file writer initialized.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Failed to initialize log writer&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 每次请求都记录一条日志</span></span><br><span class="line">        <span class="keyword">if</span> (logWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            logWriter.println(<span class="string">&quot;Processing a GET request at &quot;</span> + <span class="keyword">new</span> <span class="title class_">java</span>.util.Date());</span><br><span class="line">            logWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Request logged.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在销毁时，关闭并释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            logWriter.println(<span class="string">&quot;ResourceServlet is being destroyed.&quot;</span>);</span><br><span class="line">            logWriter.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">            logWriter.flush();</span><br><span class="line">            logWriter.close(); <span class="comment">// 关键步骤：关闭流</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Log file writer closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h4><ul>
<li><code>destroy()</code> 方法的执行是<strong>不能保证</strong>的。如果 Servlet 容器异常崩溃（例如，JVM 崩溃或服务器被强制 <code>kill -9</code> 终止），<code>destroy()</code> 方法可能根本没有机会被调用。因此，它只适用于<strong>优雅关闭 (graceful shutdown)</strong> 的场景。</li>
<li>一旦 <code>destroy()</code> 方法被调用，容器就会释放对该 Servlet 实例的引用，之后它会被 Java 的垃圾回收器 (Garbage Collector) 回收。如果后续还有对该 Servlet 的请求，容器会<strong>重新创建一个新的实例</strong>，并再次执行 <code>init()</code> 方法，开始一个新的生命周期。</li>
</ul>
<hr>
<h2 id="3-Servlet-继承体系"><a href="#3-Servlet-继承体系" class="headerlink" title="3. Servlet 继承体系"></a>3. Servlet 继承体系</h2><h3 id="3-1-Servlet-接口-javax-servlet-Servlet"><a href="#3-1-Servlet-接口-javax-servlet-Servlet" class="headerlink" title="3.1 Servlet 接口 (javax.servlet.Servlet)"></a>3.1 <code>Servlet</code> 接口 (javax.servlet.Servlet)</h3><p><code>Servlet</code> 接口是整个 Servlet API 的<strong>基石和核心</strong>。它位于 <code>javax.servlet</code> (或 Jakarta EE 9+ 中的 <code>jakarta.servlet</code>) 包中，定义了一个<strong>契约 (Contract)</strong>，任何想要成为 Servlet 的 Java 类都必须直接或间接地实现这个接口。</p>
<p>这个接口是<strong>协议无关 (Protocol-Independent)</strong> 的，意味着它不局限于 HTTP 协议。理论上，它可以被用来处理任何类型的客户端&#x2F;服务器协议。</p>
<h4 id="3-1-1-核心职责"><a href="#3-1-1-核心职责" class="headerlink" title="3.1.1 核心职责"></a>3.1.1 核心职责</h4><p><code>Servlet</code> 接口的核心职责是<strong>定义 Servlet 的生命周期方法</strong>。它规定了 Servlet 容器与 Servlet 实例之间交互的标准方式。</p>
<hr>
<h4 id="3-1-2-核心方法-The-Five-Methods"><a href="#3-1-2-核心方法-The-Five-Methods" class="headerlink" title="3.1.2 核心方法 (The Five Methods)"></a>3.1.2 核心方法 (The Five Methods)</h4><p><code>Servlet</code> 接口中定义了五个方法，它们构成了 Servlet 的基本框架：</p>
<ol>
<li><code>void init(ServletConfig config) throws ServletException;</code><ul>
<li><strong>生命周期方法。</strong></li>
<li>当 Servlet 实例被创建后，容器会调用此方法进行初始化。</li>
<li>它在 Servlet 的整个生命周期中只会被调用一次。</li>
<li>参数 <code>ServletConfig</code> 包含了 Servlet 的配置信息。</li>
</ul>
</li>
<li><code>void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;</code><ul>
<li><strong>生命周期方法，也是最核心的方法。</strong></li>
<li>每当有请求到达时，容器就会调用此方法来处理请求。</li>
<li>参数 <code>ServletRequest</code> 和 <code>ServletResponse</code> 封装了请求和响应信息，但它们是通用的，不包含任何特定于 HTTP 的功能。</li>
</ul>
</li>
<li><code>void destroy();</code><ul>
<li><strong>生命周期方法。</strong></li>
<li>当 Servlet 实例即将被销毁时，容器会调用此方法，用于释放资源。</li>
<li>它在 Servlet 的整个生命周期中也只会被调用一次。</li>
</ul>
</li>
<li><code>ServletConfig getServletConfig();</code><ul>
<li><strong>辅助方法。</strong></li>
<li>返回一个 <code>ServletConfig</code> 对象，该对象是容器在调用 <code>init</code> 方法时传入的。</li>
<li>通过这个方法，Servlet 可以在生命周期的任何时刻获取自己的配置信息。</li>
</ul>
</li>
<li><code>String getServletInfo();</code><ul>
<li><strong>辅助方法。</strong></li>
<li>返回一个描述 Servlet 的字符串，例如作者、版本、版权信息等。</li>
<li>这个方法主要用于管理工具，实际开发中很少使用。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-1-3-为什么我们很少直接实现此接口？"><a href="#3-1-3-为什么我们很少直接实现此接口？" class="headerlink" title="3.1.3 为什么我们很少直接实现此接口？"></a>3.1.3 为什么我们很少直接实现此接口？</h4><p>在实际的 Web 开发中，我们几乎从不直接实现 <code>Servlet</code> 接口，原因如下：</p>
<ul>
<li><strong>过于通用和底层：</strong> <code>Servlet</code> 接口是协议无关的。它的 <code>ServletRequest</code> 和 <code>ServletResponse</code> 对象没有提供处理 HTTP 特有信息（如请求方法 GET&#x2F;POST、请求头、Cookie、Session 等）的便捷方法。如果直接实现它，你需要自己去解析原始的请求数据流，这非常繁琐且容易出错。</li>
<li><strong>需要实现所有方法：</strong> 作为一个接口，你必须为它的所有五个方法都提供实现，即使你只需要用到 <code>service</code> 方法，其他方法也需要写一个空实现，这增加了样板代码。</li>
</ul>
<p>为了解决这些问题，Servlet API 提供了两个方便的实现类：<code>GenericServlet</code> 和 <code>HttpServlet</code>，它们为我们处理了大量底层工作。</p>
<hr>
<h3 id="3-2-GenericServlet-抽象类"><a href="#3-2-GenericServlet-抽象类" class="headerlink" title="3.2 GenericServlet 抽象类"></a>3.2 <code>GenericServlet</code> 抽象类</h3><p><code>GenericServlet</code> 是一个抽象类，它实现了 <code>Servlet</code> 接口和 <code>ServletConfig</code> 接口，提供了一个通用的、<strong>协议无关</strong>的 Servlet 骨架。</p>
<p>它的主要目的是<strong>简化 Servlet 的编写</strong>，让我们不必从零开始实现 <code>Servlet</code> 接口中的所有方法，从而可以更专注于业务逻辑。</p>
<h4 id="3-2-1-主要贡献与特点"><a href="#3-2-1-主要贡献与特点" class="headerlink" title="3.2.1 主要贡献与特点"></a>3.2.1 主要贡献与特点</h4><ol>
<li><strong>实现了 <code>Servlet</code> 接口：</strong><ul>
<li>它为 <code>Servlet</code> 接口中的大多数方法提供了默认的、有意义的实现。例如，<code>destroy()</code> 和 <code>getServletInfo()</code> 方法都有了默认的空实现，子类只有在需要时才需要重写它们。</li>
</ul>
</li>
<li><strong>简化了 <code>init()</code> 方法：</strong><ul>
<li><code>GenericServlet</code> 已经为我们实现了 <code>init(ServletConfig config)</code> 方法。它的主要工作就是将容器传入的 <code>ServletConfig</code> 对象保存起来，以便后续通过 <code>getServletConfig()</code> 等方法调用。</li>
<li>它还提供了一个更方便的、<strong>无参数的 <code>init()</code> 方法</strong>供子类重写。这样，我们在进行自己的初始化工作时，就无需再手动调用 <code>super.init(config)</code> 了。</li>
</ul>
</li>
<li><strong>唯一的抽象方法 <code>service()</code>：</strong><ul>
<li><code>GenericServlet</code> 将 <code>service(ServletRequest req, ServletResponse res)</code> 方法声明为 <code>abstract</code>。</li>
<li>这意味着任何继承 <code>GenericServlet</code> 的子类都<strong>必须</strong>实现这个方法，因为这正是处理请求的核心逻辑所在。</li>
</ul>
</li>
<li><strong>提供了便捷的辅助方法：</strong><ul>
<li>它实现了 <code>ServletConfig</code> 接口的所有方法，如 <code>getServletContext()</code>、<code>getInitParameter(String name)</code>、<code>getServletName()</code> 等。</li>
<li>这使得我们在 Servlet 内部可以直接调用 <code>getServletContext()</code> 来获取应用上下文，而不需要先 <code>getServletConfig().getServletContext()</code>，大大简化了代码。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-2-2-为什么在-Web-开发中仍然很少直接使用它？"><a href="#3-2-2-为什么在-Web-开发中仍然很少直接使用它？" class="headerlink" title="3.2.2 为什么在 Web 开发中仍然很少直接使用它？"></a>3.2.2 为什么在 Web 开发中仍然很少直接使用它？</h4><p>尽管 <code>GenericServlet</code> 提供了很多便利，但在基于 HTTP 协议的 Web 开发中，我们仍然很少直接继承它。主要原因是：</p>
<ul>
<li><strong>协议无关性：</strong> 它的设计目标是通用的，不依赖于任何特定协议。因此，它的核心 <code>service</code> 方法的参数是通用的 <code>ServletRequest</code> 和 <code>ServletResponse</code>。</li>
<li><strong>功能局限：</strong> 这两个通用接口<strong>没有提供处理 HTTP 协议特有信息的方法</strong>。例如，你无法直接从 <code>ServletRequest</code> 中获取请求是 GET 还是 POST，也无法从 <code>ServletResponse</code> 中设置 Cookie 或进行重定向。如果想使用这些功能，你必须先将参数强制类型转换为 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code>，这既不方便也不优雅。</li>
</ul>
<p><strong>示例代码 (不推荐用于 Web 开发):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个继承 GenericServlet 的例子，仅作演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request, ServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须进行强制类型转换才能使用 HTTP 特有的功能</span></span><br><span class="line">        <span class="comment">// HttpServletRequest httpRequest = (HttpServletRequest) request;</span></span><br><span class="line">        <span class="comment">// String method = httpRequest.getMethod();</span></span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;This is a response from GenericServlet.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong><code>GenericServlet</code> 是一个重要的中间层，它为实现 <code>Servlet</code> 接口提供了极大的便利。但由于其协议无关的特性，它并不直接适用于处理 HTTP 请求。为了解决这个问题，Servlet API 在 <code>GenericServlet</code> 的基础上，提供了一个专门用于 HTTP 协议的子类——<code>HttpServlet</code>。</p>
<hr>
<h3 id="3-3-HttpServlet-抽象类"><a href="#3-3-HttpServlet-抽象类" class="headerlink" title="3.3 HttpServlet 抽象类"></a>3.3 <code>HttpServlet</code> 抽象类</h3><p><code>HttpServlet</code> 是一个专门为处理 <strong>HTTP 协议</strong> 而设计的抽象类，它继承自 <code>GenericServlet</code>。在实际的 Java Web 开发中，我们编写的 Servlet <strong>几乎总是</strong>直接或间接地继承自 <code>HttpServlet</code>。</p>
<p>它封装了处理 HTTP 请求的复杂性，为开发者提供了一个清晰、强大且易于使用的编程模型。</p>
<h4 id="3-3-1-核心优势：请求分发器"><a href="#3-3-1-核心优势：请求分发器" class="headerlink" title="3.3.1 核心优势：请求分发器"></a>3.3.1 核心优势：请求分发器</h4><p><code>HttpServlet</code> 最核心、最巧妙的设计在于它对 <code>service()</code> 方法的重写。它并没有将 <code>service()</code> 方法声明为抽象的，而是提供了一个具体的实现。这个 <code>service()</code> 方法不包含任何业务逻辑，而是扮演一个<strong>请求分发器 (Dispatcher)</strong> 的角色。</p>
<p>其工作流程如下：</p>
<ol>
<li><strong>接收请求：</strong> 容器调用 <code>HttpServlet</code> 的 <code>service()</code> 方法，传入 <code>ServletRequest</code> 和 <code>ServletResponse</code> 对象。</li>
<li><strong>类型转换：</strong> <code>service()</code> 方法内部首先将这两个通用的对象向下转型（cast）为 HTTP 专用的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 对象。如果转换失败，会抛出 <code>ServletException</code>。</li>
<li><strong>获取请求方法：</strong> 它调用 <code>httpServletRequest.getMethod()</code> 来获取客户端请求的 HTTP 方法（例如 “GET”, “POST”, “PUT”, “DELETE” 等）。</li>
<li><strong>调用 <code>doXXX()</code> 方法：</strong> 根据获取到的请求方法字符串，<code>service()</code> 方法会调用与之对应的 <code>doXXX()</code> 方法。<ul>
<li>如果请求是 <strong>GET</strong>，则调用 <code>doGet(HttpServletRequest, HttpServletResponse)</code>。</li>
<li>如果请求是 <strong>POST</strong>，则调用 <code>doPost(HttpServletRequest, HttpServletResponse)</code>。</li>
<li>…以此类推。</li>
</ul>
</li>
</ol>
<p>我们作为开发者<strong>不再需要重写 <code>service()</code> 方法</strong>，只需要：</p>
<ul>
<li><strong>继承 <code>HttpServlet</code> 类。</strong></li>
<li><strong>根据需要处理的请求类型，重写相应的 <code>doXXX()</code> 方法</strong>（最常见的是 <code>doGet()</code> 和 <code>doPost()</code>）。</li>
<li>在重写的 <code>doXXX()</code> 方法中，实现具体的业务逻辑。</li>
</ul>
<p><strong>重要提示：</strong> <code>HttpServlet</code> 中这些 <code>doXXX()</code> 方法的<strong>默认实现</strong>通常是向客户端返回一个 <strong>HTTP 405 “Method Not Allowed”</strong> 的错误。这意味着，如果你想让你的 Servlet 处理 POST 请求，你就必须重写 <code>doPost()</code> 方法，否则客户端会收到一个 405 错误。</p>
<hr>
<h4 id="3-3-2-代码示例"><a href="#3-3-2-代码示例" class="headerlink" title="3.3.2 代码示例"></a>3.3.2 代码示例</h4><p>一个典型的 <code>HttpServlet</code> 子类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 GET 请求，通常用于显示登录页面</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;h1&gt;Please Login&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;form action=&#x27;/login&#x27; method=&#x27;post&#x27;&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Username: &lt;input type=&#x27;text&#x27; name=&#x27;username&#x27;&gt;&lt;br&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Password: &lt;input type=&#x27;password&#x27; name=&#x27;password&#x27;&gt;&lt;br&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;input type=&#x27;submit&#x27; value=&#x27;Login&#x27;&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;/form&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 POST 请求，通常用于处理表单提交</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里实现用户名和密码的验证逻辑...</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(password)) &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;Login successful! Welcome, &quot;</span> + username);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;Login failed! Invalid username or password.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二、Servlet-核心-API"><a href="#二、Servlet-核心-API" class="headerlink" title="二、Servlet 核心 API"></a>二、Servlet 核心 API</h1><h2 id="1-HttpServletRequest-请求对象"><a href="#1-HttpServletRequest-请求对象" class="headerlink" title="1. HttpServletRequest (请求对象)"></a>1. HttpServletRequest (请求对象)</h2><h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h3><p><code>HttpServletRequest</code> 对象由 Servlet 容器创建，并作为参数传递给 Servlet 的 <code>service()</code>、<code>doGet()</code> 或 <code>doPost()</code> 等方法。它的核心作用是<strong>客户端发送HTTP请求的完整表示</strong>。</p>
<p>它封装了 HTTP 请求的三个主要部分：</p>
<ol>
<li><strong>请求行 (Request Line):</strong> 包括请求方法（GET, POST 等）、请求的资源路径 (URI) 和 HTTP 协议版本。</li>
<li><strong>请求头 (Request Headers):</strong> 包含一系列键值对，提供了关于客户端、请求本身和内容的元数据（如 <code>User-Agent</code>, <code>Accept</code>, <code>Cookie</code>）。</li>
<li><strong>请求体 (Request Body):</strong> 包含了客户端发送给服务器的实际数据，例如 HTML 表单提交的数据、JSON 数据等。（GET 请求通常没有请求体）。</li>
</ol>
<p><strong>关键点：</strong> 我们作为开发者<strong>从不自己创建</strong> <code>HttpServletRequest</code> 对象，而是由 Servlet 容器（如 Tomcat）为我们解析原始的网络数据流并封装好。</p>
<hr>
<h3 id="1-2-获取请求行信息"><a href="#1-2-获取请求行信息" class="headerlink" title="1.2 获取请求行信息"></a>1.2 获取请求行信息</h3><p>这些方法用于获取 HTTP 请求的第一行内容。</p>
<p>假设客户端请求的 URL 是：<code>http://localhost:8080/myapp/user/info?id=123</code></p>
<ul>
<li><code>String getMethod()</code>: 获取请求方式。<ul>
<li><strong>示例:</strong> <code>request.getMethod();</code> &#x2F;&#x2F; 返回 “GET”</li>
</ul>
</li>
<li><code>String getRequestURI()</code>: 获取请求的资源标识符路径（从项目名开始，不包括协议、主机、端口和查询参数）。<ul>
<li><strong>示例:</strong> <code>request.getRequestURI();</code> &#x2F;&#x2F; 返回 “&#x2F;myapp&#x2F;user&#x2F;info”</li>
</ul>
</li>
<li><code>StringBuffer getRequestURL()</code>: 获取客户端请求的完整 URL（不包括查询参数）。<ul>
<li><strong>示例:</strong> <code>request.getRequestURL();</code> &#x2F;&#x2F; 返回 “<a target="_blank" rel="noopener" href="http://localhost:8080/myapp/user/info">http://localhost:8080/myapp/user/info</a>“</li>
</ul>
</li>
<li><code>String getContextPath()</code>: 获取当前 Web 应用的上下文路径（即项目名）。在构建动态链接时非常有用。<ul>
<li><strong>示例:</strong> <code>request.getContextPath();</code> &#x2F;&#x2F; 返回 “&#x2F;myapp”</li>
</ul>
</li>
<li><code>String getQueryString()</code>: 获取 URL 中 <code>?</code> 后面的查询字符串。<ul>
<li><strong>示例:</strong> <code>request.getQueryString();</code> &#x2F;&#x2F; 返回 “id&#x3D;123”</li>
</ul>
</li>
<li><code>String getProtocol()</code>: 获取请求使用的协议和版本。<ul>
<li><strong>示例:</strong> <code>request.getProtocol();</code> &#x2F;&#x2F; 返回 “HTTP&#x2F;1.1”</li>
</ul>
</li>
<li><code>String getRemoteAddr()</code>: 获取客户端的 IP 地址。</li>
</ul>
<hr>
<h3 id="1-3-获取请求头信息"><a href="#1-3-获取请求头信息" class="headerlink" title="1.3 获取请求头信息"></a>1.3 获取请求头信息</h3><p>这些方法用于获取 HTTP 请求头中的键值对。</p>
<ul>
<li><p><code>String getHeader(String name)</code>: 根据头名称获取对应的头信息值。头名称不区分大小写。</p>
<ul>
<li><strong>示例:</strong> <code>String userAgent = request.getHeader(&quot;User-Agent&quot;);</code> &#x2F;&#x2F; 获取浏览器信息</li>
</ul>
</li>
<li><p><code>java.util.Enumeration&lt;String&gt; getHeaderNames()</code>: 获取所有请求头的名称集合。</p>
<ul>
<li><p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span><br><span class="line"><span class="keyword">while</span>(headerNames.hasMoreElements())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">headerName</span> <span class="operator">=</span> headerNames.nextElement();</span><br><span class="line">    System.out.println(headerName + <span class="string">&quot;: &quot;</span> + request.getHeader(headerName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-获取请求参数"><a href="#1-4-获取请求参数" class="headerlink" title="1.4 获取请求参数"></a>1.4 获取请求参数</h3><p>这是 <code>HttpServletRequest</code> 最常用的功能之一，用于获取客户端通过表单或 URL 查询字符串提交的数据。</p>
<ul>
<li><code>String getParameter(String name)</code>: 根据参数名获取参数值。这是<strong>最常用</strong>的方法。<ul>
<li>如果参数存在，返回其 <code>String</code> 类型的值。</li>
<li>如果参数不存在，返回 <code>null</code>。</li>
</ul>
</li>
<li><code>String[] getParameterValues(String name)</code>: 根据参数名获取一个参数的所有值。常用于处理复选框（checkboxes）这类可以有多个值的表单元素。<ul>
<li>返回一个 <code>String</code> 数组。</li>
<li>如果参数不存在，返回 <code>null</code>。</li>
</ul>
</li>
<li><code>java.util.Map&lt;String, String[]&gt; getParameterMap()</code>: 获取所有请求参数的 Map。<ul>
<li>Map 的键是参数名 (<code>String</code>)。</li>
<li>Map 的值是该参数对应的所有值的 <code>String</code> 数组 (<code>String[]</code>)。</li>
</ul>
</li>
</ul>
<p><strong>示例:</strong></p>
<p>假设有一个表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/register&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Hobbies:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;reading&quot;</span>&gt;</span> Reading</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;coding&quot;</span>&gt;</span> Coding</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 Servlet 中可以这样获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>); <span class="comment">// &quot;admin&quot;</span></span><br><span class="line">String[] hobbies = request.getParameterValues(<span class="string">&quot;hobby&quot;</span>); <span class="comment">// [&quot;reading&quot;, &quot;coding&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>请求参数中文乱码问题</strong></p>
<p>这是一个经典且必须掌握的问题。</p>
<ul>
<li><p><strong>GET 请求乱码：</strong></p>
<ul>
<li>GET 请求的参数在 URL 中，其编码由服务器（如 Tomcat）的配置决定。</li>
<li><strong>解决方案：</strong> 修改 Tomcat 的 <code>server.xml</code> 文件，在 <code>&lt;Connector&gt;</code> 标签中添加 <code>URIEncoding=&quot;UTF-8&quot;</code>。这是推荐的做法。</li>
</ul>
</li>
<li><p><strong>POST 请求乱码：</strong></p>
<ul>
<li><p>POST 请求的参数在请求体中，其编码由请求头中的 <code>Content-Type</code> 决定。</p>
</li>
<li><p><strong>解决方案：</strong> 在<strong>第一次调用任何 <code>getParameter</code> 系列方法之前</strong>，设置请求体的解码字符集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 必须在获取任何参数之前调用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-5-作为域对象"><a href="#1-5-作为域对象" class="headerlink" title="1.5 作为域对象"></a>1.5 作为域对象</h3><p><code>HttpServletRequest</code> 也是一个“域对象”，它提供了一个内部的存储空间（类似一个 Map），可以在<strong>一次请求的生命周期内</strong>传递数据。</p>
<p>这个功能是实现 MVC 模式中 <strong>Controller (Servlet) 向 View (JSP) 传递数据</strong>的核心机制。</p>
<ul>
<li><code>void setAttribute(String name, Object value)</code>: 将一个对象存入 request 域中。</li>
<li><code>Object getAttribute(String name)</code>: 根据名称从 request 域中取出对象（需要手动类型转换）。</li>
<li><code>void removeAttribute(String name)</code>: 从 request 域中移除一个对象。</li>
</ul>
<p><strong>典型场景：</strong></p>
<ol>
<li>一个 Servlet 接收到请求，从数据库查询到一个 <code>User</code> 对象。</li>
<li>Servlet 调用 <code>request.setAttribute(&quot;userInfo&quot;, userObject);</code> 将用户对象存入 request 域。</li>
<li>Servlet 通过<strong>请求转发</strong>将请求交给一个 JSP 页面。</li>
<li>JSP 页面可以通过 <code>${userInfo}</code> (EL 表达式) 或 <code>request.getAttribute(&quot;userInfo&quot;)</code> (Java 脚本) 来获取并展示这个 <code>User</code> 对象的信息。</li>
</ol>
<hr>
<h3 id="1-6-请求转发-RequestDispatcher"><a href="#1-6-请求转发-RequestDispatcher" class="headerlink" title="1.6 请求转发 (RequestDispatcher)"></a>1.6 请求转发 (<code>RequestDispatcher</code>)</h3><p>请求转发是一种<strong>服务器内部</strong>的资源跳转方式。</p>
<ul>
<li><strong>工作原理：</strong> Servlet 处理完部分逻辑后，将请求和响应对象“转发”给服务器上的另一个资源（如另一个 Servlet 或 JSP），由目标资源继续处理并最终生成响应。</li>
<li><strong>获取方式：</strong> <code>RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/path/to/resource&quot;);</code></li>
<li><strong>执行转发：</strong> <code>dispatcher.forward(request, response);</code></li>
</ul>
<p><strong>核心特点：</strong></p>
<ol>
<li><strong>一次请求：</strong> 整个过程对于客户端来说是一次请求和一次响应。</li>
<li><strong>地址栏不变：</strong> 客户端浏览器的地址栏不会发生变化。</li>
<li><strong>数据共享：</strong> 因为使用的是同一个 request 对象，所以可以通过 <code>request.setAttribute()</code> 在转发的 Servlet 和 JSP 之间共享数据。</li>
<li><strong>服务器内部行为：</strong> 只能转发到当前 Web 应用内部的资源。</li>
</ol>
<hr>
<h2 id="2-HttpServletResponse-响应对象"><a href="#2-HttpServletResponse-响应对象" class="headerlink" title="2. HttpServletResponse (响应对象)"></a>2. HttpServletResponse (响应对象)</h2><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h3><p><code>HttpServletResponse</code> 对象由 Servlet 容器创建，并作为参数传递给 Servlet 的服务方法。它的核心作用是<strong>封装服务器对客户端请求的响应</strong>，让开发者能够方便地将处理结果发送回客户端（通常是浏览器）。</p>
<p>它主要用于设置 HTTP 响应的三个部分：</p>
<ol>
<li><strong>响应行 (Status Line):</strong> 包括 HTTP 协议版本、一个状态码（如 200 OK, 404 Not Found）和状态描述。</li>
<li><strong>响应头 (Response Headers):</strong> 包含一系列键值对，告诉浏览器如何处理响应内容（如 <code>Content-Type</code>, <code>Content-Length</code>, <code>Set-Cookie</code>）。</li>
<li><strong>响应体 (Response Body):</strong> 包含了要发送给客户端的实际数据，如 HTML 页面、JSON 字符串、图片数据等。</li>
</ol>
<p><strong>关键点：</strong> 与 <code>HttpServletRequest</code> 一样，我们<strong>从不自己创建</strong> <code>HttpServletResponse</code> 对象，而是由容器提供，我们负责填充它。</p>
<hr>
<h3 id="2-2-设置响应行"><a href="#2-2-设置响应行" class="headerlink" title="2.2 设置响应行"></a>2.2 设置响应行</h3><p>我们通常只关心响应行中的<strong>状态码 (Status Code)</strong>，它告诉客户端请求处理的结果。</p>
<ul>
<li><code>void setStatus(int sc)</code>: 设置响应的状态码。<ul>
<li><strong>示例:</strong> <code>response.setStatus(HttpServletResponse.SC_OK);</code> &#x2F;&#x2F; 设置状态码为 200</li>
<li><strong>示例:</strong> <code>response.setStatus(404);</code> &#x2F;&#x2F; 设置状态码为 404</li>
</ul>
</li>
</ul>
<p><strong>常用状态码：</strong></p>
<ul>
<li><code>200 OK</code>: 请求成功。</li>
<li><code>302 Found</code>: 临时重定向（<code>sendRedirect</code> 方法会自动设置这个状态码）。</li>
<li><code>304 Not Modified</code>: 客户端缓存的资源未过期。</li>
<li><code>400 Bad Request</code>: 请求语法错误。</li>
<li><code>403 Forbidden</code>: 服务器拒绝执行该请求。</li>
<li><code>404 Not Found</code>: 请求的资源不存在。</li>
<li><code>500 Internal Server Error</code>: 服务器内部发生错误。</li>
</ul>
<hr>
<h3 id="2-3-设置响应头"><a href="#2-3-设置响应头" class="headerlink" title="2.3 设置响应头"></a>2.3 设置响应头</h3><p>响应头用于向浏览器提供指令性信息。</p>
<ul>
<li><code>void setHeader(String name, String value)</code>: 设置一个指定名称的响应头。如果该头已存在，新值会覆盖旧值。</li>
<li><code>void addHeader(String name, String value)</code>: 添加一个指定名称的响应头。如果该头已存在，不会覆盖，而是添加一个新的同名头。</li>
</ul>
<p><strong>最常用的响应头设置：</strong></p>
<ol>
<li><strong><code>Content-Type</code> (内容类型):</strong><ul>
<li>这是最重要的响应头，它告诉浏览器响应体是什么类型的数据以及使用什么字符集来解码。</li>
<li>格式: <code>MIME类型;charset=编码</code></li>
<li><strong>便捷方法:</strong> <code>response.setContentType(&quot;text/html;charset=UTF-8&quot;);</code></li>
<li>如果不设置字符集，浏览器可能因解码错误而显示乱码。</li>
</ul>
</li>
<li><strong><code>Location</code> (位置):</strong><ul>
<li>与 <code>302</code> 状态码配合使用，告诉浏览器要重定向到的新地址。<code>sendRedirect</code> 方法会自动设置它。</li>
</ul>
</li>
<li><strong><code>Content-Disposition</code> (内容处置):</strong><ul>
<li>用于指示浏览器如何处理响应体，通常用于<strong>文件下载</strong>。</li>
<li><code>response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=report.xls&quot;);</code></li>
<li><code>attachment</code> 表示作为附件下载，<code>filename</code> 指定了默认的文件名。</li>
</ul>
</li>
<li><strong><code>Refresh</code> (刷新):</strong><ul>
<li>告诉浏览器在指定秒数后刷新页面，或跳转到另一个页面。</li>
<li><code>response.setHeader(&quot;Refresh&quot;, &quot;5;url=http://www.google.com&quot;);</code> &#x2F;&#x2F; 5秒后跳转到谷歌</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-设置响应体"><a href="#2-4-设置响应体" class="headerlink" title="2.4 设置响应体"></a>2.4 设置响应体</h3><p>响应体是发送给客户端的实际数据。Servlet 提供了两种输出流来写入响应体，<strong>但两者是互斥的，一次响应中只能使用其中一个</strong>。</p>
<ol>
<li><p><strong>字符输出流 <code>PrintWriter getWriter()</code></strong></p>
<ul>
<li>用于输出<strong>文本数据</strong>，如 HTML, XML, JSON, Plain Text。</li>
<li>它具有平台无关的 <code>print()</code> 和 <code>println()</code> 方法，非常方便。</li>
<li><strong>注意：</strong> 在调用 <code>getWriter()</code> 之前，最好先通过 <code>response.setContentType(...)</code> 或 <code>response.setCharacterEncoding(...)</code> 设置好字符编码，否则可能产生乱码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;/body&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字节输出流 <code>ServletOutputStream getOutputStream()</code></strong></p>
<ul>
<li>用于输出<strong>非文本的二进制数据</strong>，如图片、视频、PDF 文件、ZIP 压缩包等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"><span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"><span class="comment">// 从文件或其他来源读取图片字节数据，并写入到 out 流中...</span></span><br><span class="line"><span class="comment">// out.write(imageDataBytes);</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>严重警告：</strong> 如果同时尝试调用 <code>getWriter()</code> 和 <code>getOutputStream()</code>，容器会抛出 <code>IllegalStateException</code>。</p>
</blockquote>
<hr>
<h3 id="2-5-页面跳转：重定向"><a href="#2-5-页面跳转：重定向" class="headerlink" title="2.5 页面跳转：重定向"></a>2.5 页面跳转：重定向</h3><p>重定向 (Redirect) 是一种<strong>客户端</strong>行为的跳转方式。</p>
<ul>
<li><p><strong>工作原理：</strong> 服务器向客户端发送一个特殊的响应（状态码 302 和一个 <code>Location</code> 响应头），客户端浏览器接收到这个响应后，会<strong>自动发起一个新的请求</strong>到 <code>Location</code> 头指定的 URL。</p>
</li>
<li><p><strong>实现方法:</strong> <code>void sendRedirect(String location)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理完用户注册逻辑后，重定向到登录页面</span></span><br><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">&quot;/login.jsp&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-6-请求转发-forward-与重定向-redirect-的区别"><a href="#2-6-请求转发-forward-与重定向-redirect-的区别" class="headerlink" title="2.6 请求转发 (forward) 与重定向 (redirect) 的区别"></a>2.6 请求转发 (forward) 与重定向 (redirect) 的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th><strong>请求转发 (Forward)</strong></th>
<th><strong>重定向 (Redirect)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>行为主体</strong></td>
<td><strong>服务器行为</strong>。服务器内部将请求转交给另一个资源处理。</td>
<td><strong>客户端行为</strong>。服务器建议客户端去请求另一个地址。</td>
</tr>
<tr>
<td><strong>请求次数</strong></td>
<td><strong>1 次</strong>。客户端只发起了一次请求。</td>
<td><strong>2 次</strong>。客户端先请求 Servlet，然后被告知再去请求另一个地址。</td>
</tr>
<tr>
<td><strong>地址栏变化</strong></td>
<td><strong>不变</strong>。地址栏仍然是最初请求的地址。</td>
<td><strong>改变</strong>。地址栏会更新为重定向后的新地址。</td>
</tr>
<tr>
<td><strong>数据共享</strong></td>
<td><strong>可以共享</strong>。转发过程共享同一个 <code>request</code> 对象，可以通过 <code>request.setAttribute()</code> 传递数据。</td>
<td><strong>不能共享</strong>。两次请求是完全独立的，<code>request</code> 对象不同。</td>
</tr>
<tr>
<td><strong>可以跳转的资源</strong></td>
<td>只能跳转到<strong>当前 Web 应用内部</strong>的资源。</td>
<td>可以跳转到<strong>任何有效的 URL</strong>，包括外部网站。</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td><strong>高</strong>。因为只是服务器内部的调用。</td>
<td><strong>低</strong>。因为需要经过一次客户端与服务器的网络往返。</td>
</tr>
<tr>
<td><strong>核心方法</strong></td>
<td><code>request.getRequestDispatcher(...).forward(req, res)</code></td>
<td><code>response.sendRedirect(...)</code></td>
</tr>
</tbody></table>
<h4 id="使用场景总结："><a href="#使用场景总结：" class="headerlink" title="使用场景总结："></a><strong>使用场景总结：</strong></h4><ul>
<li><strong>使用转发 (Forward):</strong><ul>
<li><strong>MVC 模式</strong>：Servlet (Controller) 处理完业务逻辑后，将数据存入 <code>request</code> 域，然后<strong>转发</strong>到 JSP (View) 进行展示。这是最典型的应用。</li>
</ul>
</li>
<li><strong>使用重定向 (Redirect):</strong><ul>
<li><strong>避免表单重复提交</strong>：当用户提交一个 POST 请求（如注册、下单）处理成功后，<strong>重定向</strong>到一个成功页面。这样即使用户刷新页面，也只是刷新成功页面（GET 请求），不会重复提交表单数据。这被称为 <strong>Post-Redirect-Get (PRG)</strong> 模式。</li>
<li><strong>跳转到外部网站</strong>。</li>
<li><strong>实现登录功能</strong>：用户访问需要登录的页面时，如果未登录，则重定向到登录页面。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三、会话管理-State-Management"><a href="#三、会话管理-State-Management" class="headerlink" title="三、会话管理 (State Management)"></a>三、会话管理 (State Management)</h1><h2 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h2><h3 id="1-1-定义-1"><a href="#1-1-定义-1" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>Cookie</strong> 是服务器发送到客户端（浏览器）并由客户端保存在本地的一小块<strong>键值对 (key-value) 形式的文本数据</strong>。</p>
<p>当浏览器下次向同一个服务器发送请求时，它会自动将之前保存的 Cookie 数据附加在 HTTP 请求头中一并发送回去。通过这种机制，服务器就能够识别出是哪个用户，从而实现对用户状态的跟踪。</p>
<h3 id="1-2-工作原理"><a href="#1-2-工作原理" class="headerlink" title="1.2 工作原理"></a>1.2 工作原理</h3><p>Cookie 的工作原理完全基于 HTTP 协议的 <strong>请求头 (Request Headers)</strong> 和 <strong>响应头 (Response Headers)</strong>。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    title Cookie 工作原理
    autonumber

    %% 1. 第一次请求 (无 Cookie) %%
    Client-&gt;&gt;Server: 发起请求 (GET /index.html)
    note right of Client: 请求头中没有 Cookie

    %% 2. 第一次响应 (设置 Cookie) %%
    activate Server
    Server--&gt;&gt;Client: 返回响应 (200 OK)
    note left of Server: 响应头包含 Set-Cookie: userID=12345
    deactivate Server
    note right of Client: 浏览器解析并保存 Cookie

    %% 增加分隔，表示后续操作 %%
    rect rgb(240, 240, 240)
        note over Client, Server: 一段时间后，用户再次访问...
    end

    %% 3. 后续请求 (携带 Cookie) %%
    Client-&gt;&gt;Server: 发起后续请求 (GET /profile.html)
    note right of Client: 请求头自动添加 Cookie: userID=12345

    %% 4. 后续响应 (服务器识别用户) %%
    activate Server
    note over Server: 读取 Cookie, 识别用户身份(ID:12345)
    Server--&gt;&gt;Client: 返回个性化响应 (例如：欢迎回来！)
    deactivate Server</code></pre>

<p><strong>流程图解:</strong></p>
<ol>
<li><strong>第一次请求 (客户端 -&gt; 服务器):</strong><ul>
<li>客户端浏览器向服务器发起一个请求。此时，请求头中<strong>没有</strong> <code>Cookie</code> 信息。</li>
</ul>
</li>
<li><strong>第一次响应 (服务器 -&gt; 客户端):</strong><ul>
<li>服务器处理完请求后，决定要为这个客户端设置一个 Cookie。</li>
<li>服务器在 HTTP <strong>响应头</strong>中添加一个 <code>Set-Cookie</code> 字段，内容是 <code>key=value</code> 以及一些可选的属性。</li>
<li>例如：<code>Set-Cookie: userID=12345</code></li>
<li>浏览器接收到这个响应后，会解析 <code>Set-Cookie</code> 头，并将这个 Cookie 保存在本地。</li>
</ul>
</li>
<li><strong>后续请求 (客户端 -&gt; 服务器):</strong><ul>
<li>当浏览器<strong>再次</strong>向同一个服务器（域名和路径匹配）发起请求时，它会自动在 HTTP <strong>请求头</strong>中添加一个 <code>Cookie</code> 字段。</li>
<li><code>Cookie</code> 字段的值就是之前服务器设置的所有相关 Cookie。</li>
<li>例如：<code>Cookie: userID=12345</code></li>
</ul>
</li>
<li><strong>后续响应 (服务器 -&gt; 客户端):</strong><ul>
<li>服务器接收到请求，读取请求头中的 <code>Cookie</code> 信息，就知道“哦，是 ID 为 12345 的用户回来了”，然后就可以根据这个 ID 执行相应的逻辑（如显示个性化内容、保持登录状态等）。</li>
</ul>
</li>
</ol>
<p>这个过程对用户是透明的，完全由浏览器和服务器自动完成。</p>
<hr>
<h3 id="1-3-Cookie-API"><a href="#1-3-Cookie-API" class="headerlink" title="1.3 Cookie API"></a>1.3 Cookie API</h3><p>在 Java Servlet 中，操作 Cookie 主要通过 <code>javax.servlet.http.Cookie</code> 类以及 <code>request</code> 和 <code>response</code> 对象上的方法。</p>
<ol>
<li><strong>创建 Cookie:</strong><ul>
<li><code>Cookie cookie = new Cookie(String name, String value);</code></li>
<li><strong>注意:</strong> Cookie 的 name 和 value <strong>不能包含</strong>中文字符、空格或特殊字符（如 <code>;</code>, <code>,</code>）。如果需要存储，必须先进行 <strong>URL 编码</strong> (<code>URLEncoder.encode()</code>)，读取时再进行解码 (<code>URLDecoder.decode()</code>)。</li>
</ul>
</li>
<li><strong>发送 Cookie 到客户端:</strong><ul>
<li><code>response.addCookie(Cookie cookie);</code></li>
<li>通过 <code>response</code> 对象将创建好的 Cookie 添加到 HTTP 响应头中。</li>
</ul>
</li>
<li><strong>从客户端请求中获取 Cookie:</strong><ul>
<li><code>Cookie[] cookies = request.getCookies();</code></li>
<li>通过 <code>request</code> 对象获取一个 <code>Cookie</code> 数组，包含了客户端本次请求发送过来的所有 Cookie。</li>
<li><strong>注意:</strong> 如果客户端没有发送任何 Cookie，此方法将返回 <code>null</code>，所以在使用前必须进行<strong>空指针判断</strong>。</li>
</ul>
</li>
<li><strong>读取 Cookie 的信息:</strong><ul>
<li><code>String name = cookie.getName();</code></li>
<li><code>String value = cookie.getValue();</code></li>
</ul>
</li>
</ol>
<p><strong>代码示例：记录用户访问次数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/visitCount&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitCountServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 尝试从请求中获/取名为 &quot;visitCount&quot; 的 Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">targetCookie</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;visitCount&quot;</span>.equals(cookie.getName())) &#123;</span><br><span class="line">                    targetCookie = cookie;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetCookie != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 如果 Cookie 存在，获取其值并加 1</span></span><br><span class="line">            count = Integer.parseInt(targetCookie.getValue()) + <span class="number">1</span>;</span><br><span class="line">            out.write(<span class="string">&quot;&lt;h1&gt;您好，这是您的第 &quot;</span> + count + <span class="string">&quot; 次访问！&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            targetCookie.setValue(String.valueOf(count)); <span class="comment">// 更新 Cookie 的值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 如果 Cookie 不存在，说明是第一次访问</span></span><br><span class="line">            out.write(<span class="string">&quot;&lt;h1&gt;欢迎您，这是您的第一次访问！&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            targetCookie = <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;visitCount&quot;</span>, String.valueOf(count));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 设置 Cookie 的有效期（例如 1 天）</span></span><br><span class="line">        targetCookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 将更新后的 Cookie 发送回客户端</span></span><br><span class="line">        response.addCookie(targetCookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-4-Cookie-的属性"><a href="#1-4-Cookie-的属性" class="headerlink" title="1.4 Cookie 的属性"></a>1.4 Cookie 的属性</h3><p>除了基本的 name 和 value，还可以设置 Cookie 的其他属性来控制其行为。</p>
<ul>
<li><code>void setMaxAge(int seconds)</code>: <strong>设置 Cookie 的有效期</strong><ul>
<li><strong>正数:</strong> 表示 Cookie 的存活秒数。Cookie 会被保存在客户端的硬盘上，浏览器关闭后依然有效。</li>
<li><strong>负数 (默认值):</strong> 表示 Cookie 仅在当前浏览器会话期间有效。Cookie 存储在浏览器内存中，一旦浏览器关闭，Cookie 就会被删除。</li>
<li><strong>零 (0):</strong> 表示<strong>立即删除</strong>该 Cookie。这是服务器端删除客户端 Cookie 的标准方法。</li>
</ul>
</li>
<li><code>void setPath(String uri)</code>: <strong>设置 Cookie 的有效路径</strong><ul>
<li>指定一个 URL 路径，只有当请求的路径是该路径或其子路径时，浏览器才会发送这个 Cookie。</li>
<li><strong>常用设置:</strong> <code>cookie.setPath(&quot;/&quot;);</code> 或 <code>cookie.setPath(request.getContextPath());</code>，使其对整个 Web 应用都有效。</li>
</ul>
</li>
<li><code>void setDomain(String pattern)</code>: <strong>设置 Cookie 的有效域名</strong><ul>
<li>用于跨子域共享 Cookie。例如，设置为 <code>.example.com</code>，则 <code>a.example.com</code> 和 <code>b.example.com</code> 都可以访问该 Cookie。</li>
</ul>
</li>
<li><code>void setHttpOnly(boolean isHttpOnly)</code>: <strong>（安全相关）</strong><ul>
<li>如果设置为 <code>true</code>，则该 Cookie <strong>不能被客户端的 JavaScript 脚本访问</strong>（通过 <code>document.cookie</code>）。这能有效防止<strong>跨站脚本攻击 (XSS)</strong> 窃取 Cookie。</li>
</ul>
</li>
<li><code>void setSecure(boolean flag)</code>: <strong>（安全相关）</strong><ul>
<li>如果 设置为 <code>true</code>，则该 Cookie <strong>只会在 HTTPS 连接中被发送</strong>，在普通的 HTTP 连接中不会被发送，可以防止在传输过程中被窃听。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-5-优缺点及应用场景"><a href="#1-5-优缺点及应用场景" class="headerlink" title="1.5 优缺点及应用场景"></a>1.5 优缺点及应用场景</h3><h4 id="1-5-1-优点"><a href="#1-5-1-优点" class="headerlink" title="1.5.1 优点:"></a>1.5.1 优点:</h4><ul>
<li><strong>API 简单：</strong> 使用起来非常方便。</li>
<li><strong>减轻服务器压力：</strong> 数据存储在客户端，不占用服务器内存。</li>
<li><strong>可持久化：</strong> 通过设置 <code>setMaxAge</code> 可以实现长时间保持状态。</li>
</ul>
<hr>
<h4 id="1-5-2-缺点"><a href="#1-5-2-缺点" class="headerlink" title="1.5.2 缺点"></a>1.5.2 缺点</h4><ul>
<li><strong>大小和数量限制：</strong> 大多数浏览器限制单个 Cookie 大小为 4KB 左右，每个域名下的 Cookie 数量也有限制（通常为 20-50 个）。</li>
<li><strong>安全性差：</strong> Cookie 以明文形式存储在客户端本地，并且在网络中明文传输，容易被窃取和篡改。<strong>绝对不能用 Cookie 存储敏感信息</strong>（如密码、银行卡号）。</li>
<li><strong>增加网络流量：</strong> 浏览器每次请求都会携带相关 Cookie，即使是请求图片、CSS 等静态资源，也会带上，造成不必要的流量浪费。</li>
<li><strong>用户可禁用：</strong> 用户可以在浏览器设置中禁用 Cookie，导致依赖 Cookie 的功能失效。</li>
</ul>
<hr>
<h4 id="1-5-3-应用场景"><a href="#1-5-3-应用场景" class="headerlink" title="1.5.3 应用场景"></a>1.5.3 应用场景</h4><ul>
<li><strong>“记住我”功能：</strong> 记录一个非敏感的、加密的用户令牌，用于下次访问时自动登录。</li>
<li><strong>购物车（早期实现）：</strong> 将商品 ID 存储在 Cookie 中，但现在更多使用 Session。</li>
<li><strong>个性化设置：</strong> 记录用户的偏好，如网站主题（白天&#x2F;夜间模式）、语言选择等。</li>
<li><strong>广告追踪：</strong> 跟踪用户在不同网站间的浏览行为，以推送相关广告。</li>
</ul>
<hr>
<h2 id="2-Session-HttpSession"><a href="#2-Session-HttpSession" class="headerlink" title="2. Session (HttpSession)"></a>2. Session (HttpSession)</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>Session (会话)</strong> 是一种<strong>服务器端</strong>的会话跟踪技术。它在服务器的内存中为每个独立的用户（客户端）开辟一块专属的存储空间，用于在多次请求之间保存和共享该用户的状态数据。</p>
<p>HTTP 协议是无状态的，服务器本身无法区分连续的两次请求是否来自同一个用户。Session 机制就是为了解决这个问题而诞生的。</p>
<p><code>HttpSession</code> 是 Servlet API 提供的用于表示 Session 的接口。</p>
<hr>
<h3 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2 工作原理"></a>2.2 工作原理</h3><p>Session 的实现通常<strong>依赖于 Cookie</strong>。具体来说，它依赖一个名为 <code>JSESSIONID</code> 的特殊 Cookie。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    title Java Session (JSESSIONID) 工作原理
    autonumber

    %% == 第一次交互: 创建 Session == %%

    %% 1. 第一次请求 (无 JSESSIONID) %%
    Client-&gt;&gt;Server: 发起请求 (GET /some-resource)
    note right of Client: 请求头中没有 JSESSIONID Cookie

    %% 2 &amp; 3. 服务器创建 Session 并响应 %%
    activate Server
    note over Server: 调用 request.getSession()
    note over Server: 发现无 Session ID, 执行:&lt;br/&gt;1. 创建 HttpSession 对象&lt;br/&gt;2. 生成唯一 Session ID (e.g., A5D7...)&lt;br/&gt;3. 存入内存 Map (ID -&gt; Session)
    Server--&gt;&gt;Client: 返回响应 (200 OK)
    note left of Server: 响应头包含 Set-Cookie: JSESSIONID=A5D7...
    deactivate Server
    note right of Client: 浏览器在内存中保存 JSESSIONID Cookie

    %% == 分隔符: 表示后续操作 == %%
    rect rgb(230, 240, 255)
        note over Client, Server: 后续... 用户在同一会话中继续操作
    end

    %% == 后续交互: 识别 Session == %%

    %% 4. 后续请求 (携带 JSESSIONID) %%
    Client-&gt;&gt;Server: 发起后续请求 (GET /user/profile)
    note right of Client: 请求头自动携带 Cookie: JSESSIONID=A5D7...

    %% 5. 服务器识别 Session %%
    activate Server
    note over Server: 1. 从 Cookie 读取 Session ID&lt;br/&gt;2. 在内存 Map 中查找对应的 HttpSession&lt;br/&gt;3. 成功找到, 关联到当前请求
    Server--&gt;&gt;Client: 返回与会话相关的响应 (如用户数据)
    deactivate Server
    note right of Client: 用户状态得以保持</code></pre>

<p><strong>流程图解:</strong></p>
<ol>
<li><strong>第一次请求 (客户端 -&gt; 服务器):</strong><ul>
<li>客户端浏览器向服务器发起请求。此时，请求中没有 <code>JSESSIONID</code> Cookie。</li>
</ul>
</li>
<li><strong>服务器创建 Session:</strong><ul>
<li>服务器端的 Servlet 调用 <code>request.getSession()</code> 方法。</li>
<li>容器发现当前请求没有携带有效的 Session ID，于是执行以下操作：<ul>
<li>在服务器内存中创建一个全新的 <code>HttpSession</code> 对象。</li>
<li>生成一个<strong>全局唯一的、随机的字符串</strong>作为 <strong>Session ID</strong> (例如: <code>A5D7F9G2H4J1K8L3</code>)。</li>
<li>将这个 <code>HttpSession</code> 对象和它的 Session ID 以键值对的形式存入一个全局的 Map 中。</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务器响应:</strong><ul>
<li>服务器在返回给客户端的 HTTP <strong>响应头</strong>中，添加一个 <code>Set-Cookie</code> 字段，将 Session ID 发送回去。</li>
<li>例如：<code>Set-Cookie: JSESSIONID=A5D7F9G2H4J1K8L3; Path=/myapp</code></li>
<li>这个 Cookie 默认是<strong>会话级别</strong>的（<code>Max-Age</code> 为负数），意味着它存储在浏览器内存中，浏览器关闭后即失效。</li>
</ul>
</li>
<li><strong>后续请求 (客户端 -&gt; 服务器):</strong><ul>
<li>当浏览器再次向该服务器发起请求时，它会自动在 HTTP <strong>请求头</strong>中带上之前收到的 <code>JSESSIONID</code> Cookie。</li>
<li>例如：<code>Cookie: JSESSIONID=A5D7F9G2H4J1K8L3</code></li>
</ul>
</li>
<li><strong>服务器识别 Session:</strong><ul>
<li>服务器接收到请求，从 Cookie 中读取到 Session ID。</li>
<li>容器使用这个 ID 在内存的全局 Map 中查找对应的 <code>HttpSession</code> 对象。</li>
<li>如果找到了，就将这个已存在的 Session 对象与当前请求关联起来，后续的 <code>setAttribute</code> &#x2F; <code>getAttribute</code> 操作都是针对这个找到的对象。</li>
<li>这样，服务器就成功地识别了用户，并恢复了该用户的会话状态。</li>
</ul>
</li>
</ol>
<p><strong>如果客户端禁用了 Cookie 怎么办？</strong></p>
<p>作为备用方案，服务器可以使用 <strong>URL 重写 (URL Rewriting)</strong>。它会动态地将 Session ID 附加在所有页面链接的末尾，例如 <code>.../page.jsp;jsessionid=A5D7F9...</code>。这种方式不推荐，因为它不安全且会破坏 URL 的美观性。</p>
<hr>
<h3 id="2-3-Session-API"><a href="#2-3-Session-API" class="headerlink" title="2.3 Session API"></a>2.3 Session API</h3><p>主要通过 <code>request</code> 对象获取 <code>HttpSession</code> 对象，然后通过 <code>HttpSession</code> 对象进行操作。</p>
<ol>
<li><strong>获取&#x2F;创建 Session 对象:</strong><ul>
<li><code>HttpSession session = request.getSession();</code> (等同于 <code>request.getSession(true);</code>)<ul>
<li>这是<strong>最常用</strong>的方法。它的逻辑是：检查请求中是否有合法的 Session ID，如果有，则返回对应的 Session 对象；如果没有，则<strong>立即创建一个新的</strong> Session 对象并返回。</li>
</ul>
</li>
<li><code>HttpSession session = request.getSession(false);</code><ul>
<li>逻辑是：检查请求中是否有合法的 Session ID，如果有，则返回对应的 Session 对象；如果没有，<strong>不创建新的 Session</strong>，而是返回 <code>null</code>。</li>
<li>此方法常用于<strong>判断用户是否已登录</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>在 Session 中存取数据 (作为域对象):</strong><ul>
<li><code>void session.setAttribute(String name, Object value);</code><ul>
<li>将一个 Java 对象存入 Session。可以存储<strong>任何类型</strong>的对象，而不仅限于字符串。</li>
</ul>
</li>
<li><code>Object session.getAttribute(String name);</code><ul>
<li>根据名称从 Session 中获取对象。返回的是 <code>Object</code> 类型，需要进行强制类型转换。</li>
</ul>
</li>
<li><code>void session.removeAttribute(String name);</code><ul>
<li>从 Session 中移除指定的属性。</li>
</ul>
</li>
</ul>
</li>
<li><strong>管理 Session:</strong><ul>
<li><code>void session.invalidate();</code><ul>
<li><strong>使 Session 立即失效</strong>。这会清空 Session 中所有数据，并解除与客户端的绑定。这是实现**“用户注销”**功能的核心方法。</li>
</ul>
</li>
<li><code>String session.getId();</code><ul>
<li>获取 Session 的唯一 ID 字符串。</li>
</ul>
</li>
<li><code>void session.setMaxInactiveInterval(int seconds);</code><ul>
<li>设置 Session 的最大非活动时间（即超时时间），单位为秒。覆盖 <code>web.xml</code> 中的默认配置。</li>
</ul>
</li>
<li><code>int session.getMaxInactiveInterval();</code><ul>
<li>获取 Session 的超时时间。</li>
</ul>
</li>
<li><code>long session.getCreationTime();</code><ul>
<li>获取 Session 的创建时间（毫秒级时间戳）。</li>
</ul>
</li>
<li><code>boolean session.isNew();</code><ul>
<li>判断当前 Session 是否是新创建的（即客户端还不知道它的存在，ID 还未通过响应发送回去）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-Session-的生命周期"><a href="#2-4-Session-的生命周期" class="headerlink" title="2.4 Session 的生命周期"></a>2.4 Session 的生命周期</h3><ol>
<li><p><strong>创建 (Creation):</strong></p>
<ul>
<li>当客户端第一次访问服务器，并且代码中调用了 <code>request.getSession(true)</code> 或 <code>request.getSession()</code> 时，Session 对象被创建。</li>
</ul>
</li>
<li><p><strong>活动 (Active):</strong></p>
<ul>
<li>在 Session 的超时时间 (<code>maxInactiveInterval</code>) 内，只要客户端持续与服务器进行交互，Session 就一直处于活动状态。</li>
<li><strong>每次有效的客户端请求都会重置 Session 的计时器</strong>。例如，超时时间为 30 分钟，用户在第 29 分钟时访问了新页面，那么 Session 的生命周期会从此刻起重新再计算 30 分钟。</li>
</ul>
</li>
<li><p><strong>销毁 (Destruction):</strong><br>Session 在以下三种情况下会被销毁：</p>
<ul>
<li><p><strong>超时 (Timeout):</strong> 用户在指定的时间内（默认通常是 30 分钟，可在 <code>web.xml</code> 中配置）没有任何操作，服务器会自动销毁该 Session 以释放内存。这是最常见的销毁方式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 web.xml 中配置全局 session 超时时间为 30 分钟 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>手动销毁 (Invalidation):</strong> 在代码中明确调用 <code>session.invalidate()</code> 方法，Session 会立即被销毁。常用于用户退出登录功能。</p>
</li>
<li><p><strong>服务器关闭 (Shutdown):</strong> 当 Web 服务器或应用正常关闭时，所有存在的 Session 都会被销毁。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-5-Cookie-与-Session-的区别与联系"><a href="#2-5-Cookie-与-Session-的区别与联系" class="headerlink" title="2.5 Cookie 与 Session 的区别与联系"></a>2.5 Cookie 与 Session 的区别与联系</h3><table>
<thead>
<tr>
<th>特性</th>
<th><strong>Cookie</strong></th>
<th><strong>Session</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据存储位置</strong></td>
<td><strong>客户端 (浏览器)</strong></td>
<td><strong>服务器端 (内存中)</strong></td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td><strong>低</strong>。数据暴露在客户端，易被窃取和篡改。</td>
<td><strong>高</strong>。数据存储在服务器，客户端只能接触到无意义的 Session ID。</td>
</tr>
<tr>
<td><strong>存储数据类型</strong></td>
<td><strong>String (字符串)</strong>，且不能包含特殊字符。</td>
<td><strong>Object (任何 Java 对象)</strong>。</td>
</tr>
<tr>
<td><strong>存储数据大小</strong></td>
<td><strong>小</strong>，单个 Cookie 约 4KB，数量也有限制。</td>
<td><strong>理论上无限制</strong>，但受限于服务器的内存大小。</td>
</tr>
<tr>
<td><strong>对服务器压力</strong></td>
<td><strong>无</strong>，不占用服务器资源。</td>
<td><strong>有</strong>，每个用户的 Session 都会占用服务器的内存资源。</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>可通过 <code>setMaxAge</code> 设置为长久有效（存硬盘），或会话级别（存内存）。</td>
<td>通常是会话级别，或由服务器超时策略决定。</td>
</tr>
<tr>
<td><strong>联系</strong></td>
<td><strong>Session 依赖 Cookie</strong> 来实现。服务器通过 <code>JSESSIONID</code> Cookie 来识别客户端对应的 Session。</td>
<td>Session 机制的实现通常需要 Cookie 的支持。</td>
</tr>
</tbody></table>
<hr>
<h1 id="四、Servlet-上下文与配置"><a href="#四、Servlet-上下文与配置" class="headerlink" title="四、Servlet 上下文与配置"></a>四、Servlet 上下文与配置</h1><h2 id="1-ServletContext-应用上下文"><a href="#1-ServletContext-应用上下文" class="headerlink" title="1. ServletContext (应用上下文)"></a>1. ServletContext (应用上下文)</h2><h3 id="1-1-定义-2"><a href="#1-1-定义-2" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong><code>ServletContext</code></strong> 是一个<strong>全局性的接口</strong>，它代表了<strong>整个 Web 应用</strong>本身。</p>
<p>当 Servlet 容器（如 Tomcat）启动一个 Web 应用时，它会为这个应用创建一个<strong>唯一</strong>的 <code>ServletContext</code> 实例。这个实例在 Web 应用被加载时创建，在 Web 应用被移除或服务器关闭时销毁。</p>
<p><strong>核心特性：</strong></p>
<ul>
<li><strong>唯一性：</strong> 每个 Web 应用（每个 <code>.war</code> 文件）只有一个 <code>ServletContext</code> 实例。</li>
<li><strong>全局性：</strong> 该实例被应用内的所有 Servlet、Filter 和 Listener 共享。</li>
<li><strong>生命周期：</strong> 与 Web 应用的生命周期相同。</li>
</ul>
<p>它提供了一种让应用中的不同组件（如多个 Servlet）相互通信和共享数据的方式。</p>
<hr>
<h3 id="1-2-获取方式"><a href="#1-2-获取方式" class="headerlink" title="1.2 获取方式"></a>1.2 获取方式</h3><ol>
<li><p><strong>在 Servlet 中获取：</strong></p>
<ul>
<li><p><strong>通过 <code>GenericServlet</code> 继承的方法（最常用）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 <code>ServletConfig</code> 对象获取（通常在 <code>init</code> 方法中）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> config.getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>通过 <code>HttpServletRequest</code> 对象获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> request.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 <code>HttpSession</code> 对象获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> session.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Listener 中获取：</strong></p>
<ul>
<li>在实现了 <code>ServletContextListener</code> 的监听器中，可以直接通过事件对象获取：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-3-作用"><a href="#1-3-作用" class="headerlink" title="1.3 作用"></a>1.3 作用</h3><ol>
<li><p><strong>作为域对象，实现全局数据共享 (Application Scope):</strong></p>
<ul>
<li><code>ServletContext</code> 是三大作用域中范围最大的一个。存储在其中的数据，整个应用中的所有用户、所有请求都可以访问。</li>
<li><strong>API:</strong><ul>
<li><code>void setAttribute(String name, Object value)</code></li>
<li><code>Object getAttribute(String name)</code></li>
<li><code>void removeAttribute(String name)</code></li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>网站访问计数器：</strong> 可以在 <code>ServletContext</code> 中存放一个计数器，每次请求都对其加一。</li>
<li><strong>Web 应用的全局配置信息：</strong> 例如，数据库连接池对象、Spring 框架的 ApplicationContext 容器等重量级对象，通常会存储在 <code>ServletContext</code> 中，避免重复创建。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>获取全局初始化参数 (<code>&lt;context-param&gt;</code>):</strong></p>
<ul>
<li><p>可以在 <code>web.xml</code> 中配置对整个应用都有效的初始化参数，这些参数通过 <code>ServletContext</code> 来读取。</p>
</li>
<li><p><strong>web.xml 配置:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>appVersion<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java 代码读取:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> context.getInitParameter(<span class="string">&quot;appVersion&quot;</span>); <span class="comment">// 返回 &quot;1.2.0&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这与 <code>ServletConfig</code> 的初始化参数不同，<code>ServletConfig</code> 的参数仅对单个 Servlet 有效。</p>
</li>
</ul>
</li>
<li><p><strong>获取 Web 应用中的资源:</strong></p>
<ul>
<li><p>这是 <code>ServletContext</code> 非常重要的一个功能，它允许你在不知道项目部署在服务器哪个物理位置的情况下，安全地访问项目内部的资源文件。</p>
</li>
<li><p><strong><code>InputStream getResourceAsStream(String path)</code> (推荐使用):</strong></p>
<ul>
<li>以输入流的形式返回指定路径的资源。路径必须以 <code>/</code> 开头，代表应用的根目录。</li>
<li>这是读取 <code>/WEB-INF/</code> 目录下资源（如配置文件 <code>config.properties</code>）的<strong>标准且最可靠</strong>的方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 /WEB-INF/classes/db.properties 文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> context.getResourceAsStream(<span class="string">&quot;/WEB-INF/classes/db.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(in);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>String getRealPath(String path)</code> (谨慎使用):</strong></p>
<ul>
<li>将一个 Web 应用的相对路径转换为服务器上的<strong>绝对物理磁盘路径</strong>。</li>
<li><strong>缺点：</strong> 如果应用是以 <code>.war</code> 包形式直接运行而没有解压，或者在某些安全限制较高的环境中，此方法可能返回 <code>null</code> 或无法正常工作。因此，<code>getResourceAsStream</code> 是更佳选择。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能返回 D:\apache-tomcat\webapps\myapp\images\logo.png</span></span><br><span class="line"><span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/images/logo.png&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>记录日志:</strong></p>
<ul>
<li><code>void log(String message)</code></li>
<li>可以将日志信息写入到 Servlet 容器的日志文件中（例如 Tomcat 的 <code>logs</code> 目录下的日志），方便进行调试和问题排查。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-三大作用域对象总结"><a href="#2-三大作用域对象总结" class="headerlink" title="2. 三大作用域对象总结"></a>2. 三大作用域对象总结</h2><h3 id="2-1-HttpServletRequest-request-scope"><a href="#2-1-HttpServletRequest-request-scope" class="headerlink" title="2.1 HttpServletRequest (request scope)"></a>2.1 <code>HttpServletRequest</code> (request scope)</h3><ul>
<li><strong>作用域名称：</strong> 请求域 (Request Scope)</li>
<li><strong>生命周期：</strong><ul>
<li><strong>开始：</strong> 当客户端发起一次 HTTP 请求到达服务器时创建。</li>
<li><strong>结束：</strong> 当服务器对该请求的响应完成并发送回客户端时销毁。</li>
<li>它是<strong>生命周期最短</strong>的作用域。</li>
</ul>
</li>
<li><strong>数据共享范围：</strong><ul>
<li>仅在<strong>同一次请求</strong>的处理过程中有效。</li>
<li>数据可以在通过<strong>请求转发 (<code>forward</code>)</strong> 跳转的多个 Servlet 和 JSP 之间共享。</li>
<li>一旦请求结束（例如，通过重定向 <code>redirect</code> 或用户点击新链接），<code>request</code> 对象及其中的数据就会被销毁。</li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>MVC 模式中的数据传递：</strong> Servlet (Controller) 处理完业务逻辑，将需要展示给用户的数据（如一个 <code>User</code> 对象或一个 <code>List</code> 集合）存入 <code>request</code> 域，然后<strong>转发</strong>到 JSP (View) 页面进行渲染。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-HttpSession-session-scope"><a href="#2-2-HttpSession-session-scope" class="headerlink" title="2.2 HttpSession (session scope)"></a>2.2 <code>HttpSession</code> (session scope)</h3><ul>
<li><strong>作用域名称：</strong> 会话域 (Session Scope)</li>
<li><strong>生命周期：</strong><ul>
<li><strong>开始：</strong> 当一个用户（浏览器）首次访问应用，并且代码调用 <code>request.getSession()</code> 时创建。</li>
<li><strong>结束：</strong> 以下三种情况之一发生时销毁：<ol>
<li>会话超时（用户长时间无操作）。</li>
<li>开发者手动调用 <code>session.invalidate()</code> 方法。</li>
<li>服务器关闭或 Web 应用被卸载。</li>
</ol>
</li>
</ul>
</li>
<li><strong>数据共享范围：</strong><ul>
<li>在<strong>同一个用户（浏览器）的多次请求之间</strong>有效。</li>
<li>数据对于当前用户是私有的，其他用户无法访问。</li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>跟踪用户状态：</strong><ul>
<li><strong>用户登录：</strong> 存储用户的登录信息，判断用户是否已登录。</li>
<li><strong>购物车：</strong> 存储用户添加到购物车中的商品列表。</li>
<li><strong>在线表单：</strong> 在多步骤的表单提交中，临时保存用户已填写的信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-ServletContext-application-scope"><a href="#2-3-ServletContext-application-scope" class="headerlink" title="2.3 ServletContext (application scope)"></a>2.3 <code>ServletContext</code> (application scope)</h3><ul>
<li><strong>作用域名称：</strong> 应用域 &#x2F; 上下文域 (Application Scope)</li>
<li><strong>生命周期：</strong><ul>
<li><strong>开始：</strong> 当 Web 应用在服务器上被加载（启动）时创建。</li>
<li><strong>结束：</strong> 当 Web 应用被卸载或服务器关闭时销毁。</li>
<li>它是<strong>生命周期最长</strong>的作用域，与 Web 应用共存亡。</li>
</ul>
</li>
<li><strong>数据共享范围：</strong><ul>
<li>在<strong>整个 Web 应用的所有用户、所有请求之间</strong>共享。</li>
<li>它是全局的，任何一个用户存入的数据，其他所有用户都能访问到。</li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>存储全局性、共享性的资源：</strong><ul>
<li><strong>网站访问量计数器。</strong></li>
<li><strong>数据库连接池</strong>、<strong>Spring IoC 容器</strong>等重量级对象，只需创建一次，供整个应用使用。</li>
<li><strong>应用范围的配置信息</strong>，如从 <code>web.xml</code> 中读取的 <code>&lt;context-param&gt;</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-Servlet-配置"><a href="#3-Servlet-配置" class="headerlink" title="3. Servlet 配置"></a>3. Servlet 配置</h2><h3 id="3-1-传统方式：web-xml-部署描述符"><a href="#3-1-传统方式：web-xml-部署描述符" class="headerlink" title="3.1 传统方式：web.xml (部署描述符)"></a>3.1 传统方式：<code>web.xml</code> (部署描述符)</h3><p>在 Servlet 3.0 规范之前，<strong><code>web.xml</code> 文件是唯一</strong>的配置方式。这个文件位于 Web 应用的 <code>WEB-INF</code> 目录下，是整个应用的部署描述符 。</p>
<p>配置一个 Servlet 通常需要两个核心标签：<code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code>。</p>
<ol>
<li><strong><code>&lt;servlet&gt;</code> 标签：声明一个 Servlet</strong><ul>
<li><strong>作用：</strong> 向容器注册一个 Servlet，给它起一个内部使用的逻辑名称，并指定它的完整类路径。</li>
<li><strong>子标签：</strong><ul>
<li><code>&lt;servlet-name&gt;</code>: 为 Servlet 指定一个唯一的、自定义的名称。这个名称在 <code>web.xml</code> 内部用作引用。</li>
<li><code>&lt;servlet-class&gt;</code>: 指定该 Servlet 的<strong>完整类名</strong>（包名 + 类名）。</li>
<li><code>&lt;init-param&gt;</code>: (可选) 为该 Servlet 配置初始化参数。</li>
<li><code>&lt;load-on-startup&gt;</code>: (可选) 配置 Servlet 的加载时机。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>&lt;servlet-mapping&gt;</code> 标签：映射 Servlet 的访问路径</strong><ul>
<li><strong>作用：</strong> 将一个已声明的 Servlet 与一个或多个 URL 模式关联起来。</li>
<li><strong>子标签：</strong><ul>
<li><code>&lt;servlet-name&gt;</code>: 必须与 <code>&lt;servlet&gt;</code> 标签中定义的某个 <code>&lt;servlet-name&gt;</code> <strong>完全匹配</strong>，以此建立关联。</li>
<li><code>&lt;url-pattern&gt;</code>: 定义客户端可以通过哪个 URL 路径来访问这个 Servlet。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="web-xml-示例："><a href="#web-xml-示例：" class="headerlink" title="web.xml 示例："></a><code>web.xml</code> 示例：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1. 声明一个名为 &quot;loginServlet&quot; 的 Servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>loginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.web.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 配置启动时加载，数字越小优先级越高 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 将 URL &quot;/login&quot; 映射到 &quot;loginServlet&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>loginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当用户访问 <code>http://.../应用名/login</code> 时，Tomcat 就会调用 <code>com.example.web.LoginServlet</code> 的 <code>service</code> 方法。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>集中管理：</strong> 所有配置集中在一个文件中，方便查看整个应用的路由结构。</li>
<li><strong>修改方便：</strong> 可以在不重新编译 Java 代码的情况下修改 URL 映射。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>繁琐：</strong> 在大型项目中，<code>web.xml</code> 文件会变得异常庞大和复杂，难以维护。</li>
<li><strong>分散：</strong> 配置信息与代码本身分离，降低了代码的内聚性。</li>
</ul>
<hr>
<h3 id="3-2-现代方式：注解-Servlet-3-0"><a href="#3-2-现代方式：注解-Servlet-3-0" class="headerlink" title="3.2 现代方式：注解 (Servlet 3.0+)"></a>3.2 现代方式：注解 (Servlet 3.0+)</h3><p>从 <strong>Servlet 3.0 规范</strong>开始，引入了注解 (Annotation) 的方式来配置 Servlet，大大简化了开发过程。<strong>这是目前主流的配置方式</strong>。</p>
<ol>
<li><strong><code>@WebServlet</code> 注解</strong><ul>
<li><strong>作用：</strong> 直接在 Servlet 的 Java 类上使用此注解，即可完成声明和映射，<strong>完全替代</strong>了 <code>web.xml</code> 中的 <code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code>。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> 或 <code>urlPatterns</code>: 指定一个或多个 URL 模式。这是最常用的属性。<ul>
<li>例如：<code>@WebServlet(&quot;/login&quot;)</code></li>
<li>例如：<code>@WebServlet(urlPatterns = {&quot;/user/login&quot;, &quot;/user/auth&quot;})</code></li>
</ul>
</li>
<li><code>name</code>: (可选) 相当于 <code>&lt;servlet-name&gt;</code>。如果不指定，容器会默认使用类的全名。</li>
<li><code>loadOnStartup</code>: (可选) 相当于 <code>&lt;load-on-startup&gt;</code>，用于设置加载时机。</li>
<li><code>initParams</code>: (可选) 相当于 <code>&lt;init-param&gt;</code>，用于配置初始化参数，需要与 <code>@WebInitParam</code> 注解配合使用。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>@WebInitParam</code> 注解</strong><ul>
<li><strong>作用：</strong> 用于在 <code>@WebServlet</code> 的 <code>initParams</code> 属性中定义初始化参数。</li>
<li><strong>属性：</strong> <code>name</code> 和 <code>value</code>。</li>
</ul>
</li>
</ol>
<h4 id="注解示例："><a href="#注解示例：" class="headerlink" title="注解示例："></a>注解示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 @WebServlet 注解完成所有配置</span></span><br><span class="line"><span class="meta">@WebServlet(</span></span><br><span class="line"><span class="meta">    name = &quot;loginServlet&quot;,</span></span><br><span class="line"><span class="meta">    urlPatterns = &#123;&quot;/login&quot;, &quot;/signin&quot;&#125;, // 映射了两个 URL</span></span><br><span class="line"><span class="meta">    loadOnStartup = 1,</span></span><br><span class="line"><span class="meta">    initParams = &#123;</span></span><br><span class="line"><span class="meta">        @WebInitParam(name = &quot;loginPage&quot;, value = &quot;/login.jsp&quot;),</span></span><br><span class="line"><span class="meta">        @WebInitParam(name = &quot;errorPage&quot;, value = &quot;/error.jsp&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 读取初始化参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">loginPage</span> <span class="operator">=</span> <span class="built_in">this</span>.getInitParameter(<span class="string">&quot;loginPage&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Login Page from init param: &quot;</span> + loginPage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;This is the Login Servlet configured by Annotation.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的效果与上面的 <code>web.xml</code> 示例完全相同，但配置与代码紧密结合，更加清晰直观。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简洁方便：</strong> 代码量大大减少，无需繁琐的 XML 配置。</li>
<li><strong>内聚性高：</strong> 配置信息和它所配置的类放在一起，提高了代码的可读性和可维护性。</li>
<li><strong>IDE 支持良好：</strong> 现代 IDE 对注解有很好的支持，可以方便地进行导航和重构。</li>
</ul>
<hr>
<h1 id="五、过滤器-Filter-与监听器-Listener"><a href="#五、过滤器-Filter-与监听器-Listener" class="headerlink" title="五、过滤器 (Filter) 与监听器 (Listener)"></a>五、过滤器 (Filter) 与监听器 (Listener)</h1><h2 id="1-Filter-过滤器"><a href="#1-Filter-过滤器" class="headerlink" title="1. Filter (过滤器)"></a>1. Filter (过滤器)</h2><h3 id="1-1-定义-3"><a href="#1-1-定义-3" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>Filter (过滤器)</strong> 是一个实现了 <code>javax.servlet.Filter</code> 接口的 Java 对象，它位于客户端请求和目标资源（如 Servlet、JSP 或静态文件）之间，用于<strong>拦截和处理请求与响应</strong>。</p>
<p><strong>核心作用：</strong></p>
<ul>
<li><strong>预处理请求：</strong> 在请求到达 Servlet 之前，可以检查、修改请求头和请求数据。</li>
<li><strong>后处理响应：</strong> 在响应发送给客户端之前，可以修改响应头和响应内容。</li>
<li><strong>拦截请求：</strong> 可以决定是否将请求继续传递给目标资源，或者直接中断请求流程（例如，用户未登录时跳转到登录页面）。</li>
</ul>
<p>Filter 是一种典型的<strong>责任链模式 (Chain of Responsibility Pattern)</strong> 的应用，它提供了一种对 Web 资源进行“横切”关注（如日志、安全、编码）的强大机制，而无需修改 Servlet 本身的代码，实现了<strong>低耦合</strong>。</p>
<hr>
<h3 id="1-2-Filter-生命周期"><a href="#1-2-Filter-生命周期" class="headerlink" title="1.2 Filter 生命周期"></a>1.2 Filter 生命周期</h3><p>Filter 的生命周期由 Servlet 容器管理，与 Servlet 非常相似，也包含三个核心方法：</p>
<ol>
<li><strong><code>void init(FilterConfig filterConfig)</code>: 初始化</strong><ul>
<li><strong>调用时机：</strong> Web 应用启动时，容器会创建 Filter 实例，并<strong>立即调用</strong> <code>init()</code> 方法。</li>
<li><strong>调用次数：</strong> 在 Filter 的整个生命周期中<strong>只调用一次</strong>。</li>
<li><strong>作用：</strong> 用于执行一次性的初始化任务，例如加载配置文件、创建数据库连接等。<code>FilterConfig</code> 对象可以用来获取初始化参数和 <code>ServletContext</code> 对象。</li>
</ul>
</li>
<li><strong><code>void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</code>: 执行过滤</strong><ul>
<li><strong>调用时机：</strong> <strong>每一次</strong>匹配该 Filter 的 URL 模式的请求到达时，容器都会调用此方法。</li>
<li><strong>调用次数：</strong> <strong>多次</strong>。这是 Filter 的核心工作方法。</li>
<li><strong>作用：</strong> 实现具体的过滤逻辑。<ul>
<li><strong><code>chain.doFilter(request, response)</code></strong> 是这个方法中最关键的一行代码。</li>
<li><strong>放行操作：</strong> 调用 <code>chain.doFilter()</code> 会将请求传递给过滤器链中的下一个 Filter，或者如果已经是最后一个 Filter，则传递给目标资源（Servlet）。</li>
<li><strong>代码位置决定处理时机：</strong><ul>
<li>在 <code>chain.doFilter()</code> <strong>之前</strong>写的代码，是对<strong>请求 (Request)</strong> 的预处理。</li>
<li>在 <code>chain.doFilter()</code> <strong>之后</strong>写的代码，是对<strong>响应 (Response)</strong> 的后处理。</li>
</ul>
</li>
<li><strong>拦截操作：</strong> 如果在方法中<strong>不调用</strong> <code>chain.doFilter()</code>，则请求将被拦截，不会继续向下传递。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>void destroy()</code>: 销毁</strong><ul>
<li><strong>调用时机：</strong> Web 应用被卸载或服务器关闭时，容器会调用 <code>destroy()</code> 方法。</li>
<li><strong>调用次数：</strong> <strong>只调用一次</strong>。</li>
<li><strong>作用：</strong> 用于释放 <code>init()</code> 方法中创建的资源，例如关闭数据库连接、文件流等。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-3-FilterChain-过滤器链"><a href="#1-3-FilterChain-过滤器链" class="headerlink" title="1.3 FilterChain (过滤器链)"></a>1.3 <code>FilterChain</code> (过滤器链)</h3><p>当一个请求的 URL 同时匹配多个 Filter 的映射规则时，Servlet 容器会将这些 Filter 按照它们在 <code>web.xml</code> 中配置的顺序（或者注解的特定顺序，但 XML 提供了更明确的控制）组织成一个<strong>过滤器链 (<code>FilterChain</code>)</strong>。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    actor Client
    participant Filter1
    participant Filter2
    participant Servlet

    rect rgb(235, 245, 255)
        note over Client, Servlet: 请求阶段 (Request Flow)
        Client-&gt;&gt;+Filter1: 1. 发起 HTTP Request
        note right of Filter1: 2. 执行 chain.doFilter() 之前的代码
        Filter1-&gt;&gt;+Filter2: 3. 调用 chain.doFilter()
        note right of Filter2: 4. 执行 chain.doFilter() 之前的代码
        Filter2-&gt;&gt;+Servlet: 5. 调用 chain.doFilter()
        note right of Servlet: 6. Servlet.service() 处理请求
    end

    rect rgb(255, 245, 235)
        note over Client, Servlet: 响应阶段 (Response Flow)
        Servlet--&gt;&gt;-Filter2: 7. 生成 HTTP Response 并返回
        note left of Filter2: 8. 执行 chain.doFilter() 之后的代码
        Filter2--&gt;&gt;-Filter1: (继续返回)
        note left of Filter1: 8. 执行 chain.doFilter() 之后的代码
        Filter1--&gt;&gt;-Client: 9. 最终响应返回给客户端
    end</code></pre>

<p><strong>工作流程:</strong></p>
<ol>
<li>请求首先到达链中的第一个 Filter (<code>Filter1</code>)。</li>
<li><code>Filter1</code> 执行其 <code>doFilter()</code> 方法中 <code>chain.doFilter()</code> 之前的代码。</li>
<li><code>Filter1</code> 调用 <code>chain.doFilter()</code>，控制权转移给链中的第二个 Filter (<code>Filter2</code>)。</li>
<li><code>Filter2</code> 执行其 <code>doFilter()</code> 方法…以此类推，直到最后一个 Filter。</li>
<li>最后一个 Filter 调用 <code>chain.doFilter()</code>，请求最终到达目标 Servlet。</li>
<li>Servlet 处理请求，生成响应。</li>
<li>响应沿着<strong>相反的路径</strong>返回，依次经过链中的每个 Filter。</li>
<li>每个 Filter 执行其 <code>doFilter()</code> 方法中 <code>chain.doFilter()</code> <strong>之后</strong>的代码，可以对响应进行处理。</li>
<li>最终，响应从第一个 Filter 发送回客户端。</li>
</ol>
<hr>
<h3 id="1-4-配置"><a href="#1-4-配置" class="headerlink" title="1.4 配置"></a>1.4 配置</h3><p>与 Servlet 类似，Filter 也有两种配置方式：</p>
<ol>
<li><p><strong>传统方式 (<code>web.xml</code>)</strong></p>
<ul>
<li><strong><code>&lt;filter&gt;</code> 标签：</strong> 声明一个 Filter。<ul>
<li><code>&lt;filter-name&gt;</code>: Filter 的逻辑名称。</li>
<li><code>&lt;filter-class&gt;</code>: Filter 的完整类名。</li>
</ul>
</li>
<li><strong><code>&lt;filter-mapping&gt;</code> 标签：</strong> 映射 Filter。<ul>
<li><code>&lt;filter-name&gt;</code>: 与 <code>&lt;filter&gt;</code> 中的名称对应。</li>
<li><code>&lt;url-pattern&gt;</code>: 指定要过滤的 URL 模式（如 <code>/*</code>, <code>/admin/*</code>, <code>*.do</code>）。</li>
<li><code>&lt;dispatcher&gt;</code>: (可选) 指定 Filter 拦截的请求类型，可以是 <code>REQUEST</code> (默认), <code>FORWARD</code>, <code>INCLUDE</code>, <code>ERROR</code>。</li>
</ul>
</li>
</ul>
<p><strong><code>web.xml</code> 示例:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!-- 拦截所有请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>现代方式 (注解 <code>@WebFilter</code>)</strong></p>
<ul>
<li>在 Filter 实现类上使用 <code>@WebFilter</code> 注解即可完成配置。</li>
<li><strong>常用属性:</strong> <code>urlPatterns</code> (或 <code>value</code>), <code>filterName</code>, <code>initParams</code>, <code>dispatcherTypes</code>。</li>
</ul>
<p><strong>注解示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span> <span class="comment">// 拦截所有请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharacterEncodingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 预处理：设置请求编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将请求传递下去</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后处理：可以设置响应编码，但通常在 Servlet 中设置更灵活</span></span><br><span class="line">        <span class="comment">// response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init 和 destroy 方法可以留空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-5-典型应用场景"><a href="#1-5-典型应用场景" class="headerlink" title="1.5 典型应用场景"></a>1.5 典型应用场景</h3><p>Filter 的应用非常广泛，是许多 Web 框架实现核心功能的基础。</p>
<ul>
<li><strong>统一字符编码 (Character Encoding Filter):</strong><ul>
<li>这是最经典的应用。创建一个 Filter 拦截所有请求，在 <code>doFilter</code> 方法中统一设置 <code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code>，一劳永逸地解决全站的 POST 请求中文乱码问题。</li>
</ul>
</li>
<li><strong>用户登录验证 (Authentication Filter):</strong><ul>
<li>拦截需要登录才能访问的资源（如 <code>/admin/*</code>）。</li>
<li>检查 <code>HttpSession</code> 中是否存在用户登录信息。</li>
<li>如果存在，则调用 <code>chain.doFilter()</code> 放行。</li>
<li>如果不存在，则重定向到登录页面，并且<strong>不调用</strong> <code>chain.doFilter()</code> 来中断请求。</li>
</ul>
</li>
<li><strong>权限控制 (Authorization Filter):</strong><ul>
<li>在用户已登录的基础上，检查用户是否拥有访问特定资源的权限（如角色是管理员还是普通用户）。</li>
<li>如果没有权限，则跳转到“无权限”提示页面。</li>
</ul>
</li>
<li><strong>请求日志记录 (Logging Filter):</strong><ul>
<li>记录每个请求的详细信息，如来源 IP、请求 URL、请求参数、处理时长等，用于系统监控和问题排查。</li>
</ul>
</li>
<li><strong>数据压缩 (GZIP Compression Filter):</strong><ul>
<li>拦截响应，将响应体（如 HTML, CSS, JS）进行 GZIP 压缩，并在响应头中设置 <code>Content-Encoding: gzip</code>，可以显著减少传输大小，加快页面加载速度。</li>
</ul>
</li>
<li><strong>XSS&#x2F;CSRF 安全防护:</strong><ul>
<li>创建 Filter 来包装 <code>HttpServletRequest</code> 对象，重写 <code>getParameter()</code> 等方法，对传入的参数进行过滤和转义，防止跨站脚本攻击 (XSS)。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-Listener-监听器"><a href="#2-Listener-监听器" class="headerlink" title="2. Listener (监听器)"></a>2. Listener (监听器)</h2><h3 id="2-1-定义-1"><a href="#2-1-定义-1" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>Listener (监听器)</strong> 是一种特殊的 Java 类，它实现了 Servlet API 中特定的监听器接口。它的作用是<strong>被动地监听</strong> Web 应用中特定<strong>事件</strong>的发生，并在事件发生时执行预定义的代码。</p>
<p>你可以把它想象成一个**“事件报警器”<strong>或</strong>“订阅者”**。它在 Web 应用的生命周期中静静地等待，当它所“订阅”的事件（例如：应用启动、Session 创建、请求到达）发生时，Servlet 容器会自动通知它，并调用其相应的方法。</p>
<p><strong>核心特点：</strong></p>
<ul>
<li><strong>事件驱动 (Event-Driven):</strong> 监听器的工作模式是基于事件的，而不是像 Servlet 或 Filter 那样直接处理请求。</li>
<li><strong>被动触发:</strong> 我们不直接调用监听器的方法，而是由 Servlet 容器在特定事件发生时自动回调。</li>
<li><strong>全局监控:</strong> 监听器提供了一种从宏观层面监控和干预 Web 应用状态变化的方式。</li>
</ul>
<hr>
<h3 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 分类"></a>2.2 分类</h3><p>Servlet API 提供了多种监听器接口，根据它们监听的<strong>事件源</strong>和<strong>事件类型</strong>，主要可以分为三大类：</p>
<h4 id="2-2-1-监听作用域对象生命周期的-Listener"><a href="#2-2-1-监听作用域对象生命周期的-Listener" class="headerlink" title="2.2.1 监听作用域对象生命周期的 Listener"></a>2.2.1 监听作用域对象生命周期的 Listener</h4><p>这类监听器关注三大作用域对象（<code>ServletContext</code>, <code>HttpSession</code>, <code>ServletRequest</code>）的<strong>创建和销毁</strong>。</p>
<ul>
<li><strong><code>ServletContextListener</code> (最常用):</strong><ul>
<li><strong>监听对象:</strong> <code>ServletContext</code> (整个 Web 应用)</li>
<li><strong>事件:</strong> Web 应用的启动和关闭。</li>
<li><strong>方法:</strong><ul>
<li><code>contextInitialized(ServletContextEvent sce)</code>: 在 Web 应用<strong>被加载</strong>时调用。</li>
<li><code>contextDestroyed(ServletContextEvent sce)</code>: 在 Web 应用<strong>被卸载</strong>时调用。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>HttpSessionListener</code>:</strong><ul>
<li><strong>监听对象:</strong> <code>HttpSession</code> (用户会话)</li>
<li><strong>事件:</strong> 一个会话的创建和销毁。</li>
<li><strong>方法:</strong><ul>
<li><code>sessionCreated(HttpSessionEvent se)</code>: 在一个<strong>新会话被创建</strong>时调用。</li>
<li><code>sessionDestroyed(HttpSessionEvent se)</code>: 在一个<strong>会话失效或被销毁</strong>时调用。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>ServletRequestListener</code>:</strong><ul>
<li><strong>监听对象:</strong> <code>ServletRequest</code> (一次请求)</li>
<li><strong>事件:</strong> 一次 HTTP 请求的开始和结束。</li>
<li><strong>方法:</strong><ul>
<li><code>requestInitialized(ServletRequestEvent sre)</code>: 在一个<strong>请求到达</strong> Servlet 容器时调用。</li>
<li><code>requestDestroyed(ServletRequestEvent sre)</code>: 在一个<strong>请求处理完毕</strong>并即将离开容器时调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-2-监听作用域对象属性变化的-Listener"><a href="#2-2-2-监听作用域对象属性变化的-Listener" class="headerlink" title="2.2.2 监听作用域对象属性变化的 Listener"></a>2.2.2 监听作用域对象属性变化的 Listener</h4><p>这类监听器关注三大作用域对象中<strong>属性 (Attribute) 的添加、移除和替换</strong>。</p>
<ul>
<li><strong><code>ServletContextAttributeListener</code>:</strong> 监听 <code>ServletContext</code> 中属性的变化。</li>
<li><strong><code>HttpSessionAttributeListener</code>:</strong> 监听 <code>HttpSession</code> 中属性的变化。</li>
<li><strong><code>ServletRequestAttributeListener</code>:</strong> 监听 <code>ServletRequest</code> 中属性的变化。</li>
<li><strong>它们都包含三个方法:</strong><ul>
<li><code>attributeAdded(...)</code>: 当调用 <code>setAttribute</code> 添加一个新属性时触发。</li>
<li><code>attributeRemoved(...)</code>: 当调用 <code>removeAttribute</code> 时触发。</li>
<li><code>attributeReplaced(...)</code>: 当调用 <code>setAttribute</code> 替换一个同名旧属性时触发。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-3-监听-Session-中对象状态的-Listener"><a href="#2-2-3-监听-Session-中对象状态的-Listener" class="headerlink" title="2.2.3 监听 Session 中对象状态的 Listener"></a>2.2.3 监听 Session 中对象状态的 Listener</h4><p>这类监听器由<strong>被存入 Session 的对象本身</strong>来实现，用于感知自己何时被绑定到 Session 或从 Session 解绑。</p>
<ul>
<li><strong><code>HttpSessionBindingListener</code>:</strong><ul>
<li>当一个<strong>实现了此接口的对象</strong>被 <code>session.setAttribute()</code> 存入 Session 或被 <code>session.removeAttribute()</code> 移除时，该对象自身的方法会被调用。</li>
<li><strong>方法:</strong> <code>valueBound(...)</code>, <code>valueUnbound(...)</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3 配置"></a>2.3 配置</h3><p>与 Servlet 和 Filter 一样，监听器也支持 <code>web.xml</code> 和注解两种配置方式。</p>
<ol>
<li><p><strong>传统方式 (<code>web.xml</code>)</strong></p>
<ul>
<li>使用 <code>&lt;listener&gt;</code> 标签来声明一个监听器。</li>
<li>它只有一个子标签 <code>&lt;listener-class&gt;</code>，用于指定监听器的完整类名。</li>
</ul>
<p><strong><code>web.xml</code> 示例:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.example.listener.MyAppContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>现代方式 (注解 <code>@WebListener</code>)</strong></p>
<ul>
<li>在监听器实现类上添加 <code>@WebListener</code> 注解即可。</li>
<li>这是一个标记注解，没有任何属性。容器在启动时会自动扫描带有此注解的类并注册它们。</li>
</ul>
<p><strong>注解示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppContextListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Web Application is starting up...&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行初始化任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Web Application is shutting down...&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行清理任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="2-4-典型应用场景"><a href="#2-4-典型应用场景" class="headerlink" title="2.4 典型应用场景"></a>2.4 典型应用场景</h3><p>监听器在框架和大型应用中扮演着至关重要的“引导”和“监控”角色。</p>
<ul>
<li><strong>使用 <code>ServletContextListener</code>:</strong><ul>
<li><strong>初始化全局资源 (重量级应用):</strong><ul>
<li>创建和初始化<strong>数据库连接池</strong>（如 HikariCP, C3P0）。</li>
<li>加载和解析全局<strong>配置文件</strong> (<code>.properties</code>, <code>.xml</code>)。</li>
<li>启动<strong>定时任务</strong>调度器（如 Quartz）。</li>
<li><strong>初始化 IoC 容器</strong>，例如 Spring 框架的 <code>ContextLoaderListener</code> 就是一个典型的 <code>ServletContextListener</code>，它负责在应用启动时创建和加载 Spring 的应用上下文。</li>
</ul>
</li>
<li><strong>应用关闭时释放资源：</strong> 在 <code>contextDestroyed</code> 方法中，优雅地关闭数据库连接池、停止定时任务等。</li>
</ul>
</li>
<li><strong>使用 <code>HttpSessionListener</code>:</strong><ul>
<li><strong>统计在线用户数量：</strong><ul>
<li>在 <code>sessionCreated</code> 方法中，将一个全局计数器（通常存放在 <code>ServletContext</code> 中）加一。</li>
<li>在 <code>sessionDestroyed</code> 方法中，将该计数器减一。</li>
</ul>
</li>
<li><strong>监控用户会话：</strong> 记录用户会话的创建和销毁日志，用于行为分析或问题排查。</li>
</ul>
</li>
<li><strong>使用 <code>ServletRequestListener</code>:</strong><ul>
<li><strong>记录请求处理时长：</strong> 在 <code>requestInitialized</code> 中记录开始时间戳，在 <code>requestDestroyed</code> 中记录结束时间戳，计算并记录每个请求的耗时，用于性能监控。</li>
</ul>
</li>
<li><strong>使用 <code>HttpSessionAttributeListener</code>:</strong><ul>
<li><strong>监控敏感信息：</strong> 监听 <code>HttpSession</code> 中特定属性（如用户信息、权限列表）的变化，当这些信息被修改时，记录日志以备审计。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、高级主题与实践"><a href="#六、高级主题与实践" class="headerlink" title="六、高级主题与实践"></a>六、高级主题与实践</h1><h2 id="1-Servlet-与-JSP-的关系-MVC-模式"><a href="#1-Servlet-与-JSP-的关系-MVC-模式" class="headerlink" title="1. Servlet 与 JSP 的关系 (MVC 模式)"></a>1. Servlet 与 JSP 的关系 (MVC 模式)</h2><h3 id="1-1-JSP的本质"><a href="#1-1-JSP的本质" class="headerlink" title="1.1 JSP的本质"></a>1.1 JSP的本质</h3><p><strong>JSP (JavaServer Pages) 的本质就是一个 Servlet。</strong></p>
<p>这可能是理解 JJSP 文件并不是直接由浏览器执行的，它是一个<strong>模板</strong>，最终会被 Servlet 容器（如 Tomcat 内置的 Jasper 引擎）转换为一个 <code>.java</code> 的 Servlet 源文件，然后编译成一个 <code>.class</code> 文件来运行。</p>
<p><strong>转换过程（第一次访问 JSP 时发生）：</strong></p>
<ol>
<li><strong>翻译 (Translate):</strong> JSP 引擎解析 <code>.jsp</code> 文件。<ul>
<li>文件中的静态 HTML 部分被转换为 Java 代码中的 <code>out.println(&quot;&lt;html&gt;...&quot;);</code> 语句。</li>
<li>JSP 脚本元素，如 Scriptlet (<code>&lt;% ... %&gt;</code>) 和表达式 (<code>&lt;%= ... %&gt;</code>)，被原样插入到生成的 Servlet 的 <code>_jspService()</code> 方法中。</li>
</ul>
</li>
<li><strong>编译 (Compile):</strong> 容器调用 Java 编译器将这个生成的 <code>.java</code> 文件编译成 <code>.class</code> 文件。</li>
<li><strong>执行 (Execute):</strong> 容器加载并执行这个编译好的 Servlet 类，其生命周期和普通 Servlet 一样。</li>
</ol>
<p><strong>为什么要有 JSP？</strong></p>
<p>JSP 的诞生是为了解决早期 Servlet 开发的一个巨大痛点：在 Servlet 的 Java 代码中通过 <code>out.println()</code> 来拼接复杂的 HTML 页面是一场噩梦，难以编写和维护。</p>
<ul>
<li><strong>Servlet 的优势：</strong> 擅长处理 Java 逻辑、控制流程、处理业务。<strong>（逻辑强，表现弱）</strong></li>
<li><strong>JSP 的优势：</strong> 擅长展示动态内容，可以在 HTML 中嵌入少量 Java 代码。<strong>（表现强，逻辑弱）</strong></li>
</ul>
<p>因此，最佳实践就是让它们各司其职。</p>
<hr>
<h3 id="1-2-MVC-设计模式"><a href="#1-2-MVC-设计模式" class="headerlink" title="1.2 MVC 设计模式"></a>1.2 MVC 设计模式</h3><p><strong>MVC (Model-View-Controller)</strong> 是一种经典的软件设计模式，旨在将应用程序的关注点分离，使其更易于维护、扩展和测试。在 Java Web 应用中，Servlet 和 JSP 完美地契合了 MVC 模式中的角色。</p>
<ul>
<li><strong>Model (模型):</strong><ul>
<li><strong>职责：</strong> 负责应用程序的<strong>业务逻辑</strong>和<strong>数据</strong>。它封装了应用的核心状态和行为，与表示层和控制层解耦。</li>
<li><strong>在 Java Web 中通常是：</strong><ul>
<li>JavaBean &#x2F; POJO (Plain Old Java Object) 用来封装数据。</li>
<li>Service 层类用来处理业务逻辑。</li>
<li>DAO (Data Access Object) 层类用来与数据库交互。</li>
</ul>
</li>
</ul>
</li>
<li><strong>View (视图):</strong><ul>
<li><strong>职责：</strong> 负责<strong>展示数据</strong>，即用户界面。它从模型中获取数据并将其呈现给用户。视图本身应包含最少的业务逻辑。</li>
<li><strong>在 Java Web 中通常是：</strong><ul>
<li><strong>JSP</strong>、HTML、Thymeleaf 等模板引擎。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Controller (控制器):</strong><ul>
<li><strong>职责：</strong> 充当<strong>调度者</strong>。它接收来自用户的请求，调用相应的模型来处理请求，然后选择合适的视图来渲染模型返回的数据，最终将视图的输出返回给用户。</li>
<li><strong>在 Java Web 中通常是：</strong><ul>
<li><strong>Servlet</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-Servlet-与-JSP-在-MVC-中的协作流程："><a href="#1-3-Servlet-与-JSP-在-MVC-中的协作流程：" class="headerlink" title="1.3 Servlet 与 JSP 在 MVC 中的协作流程："></a>1.3 Servlet 与 JSP 在 MVC 中的协作流程：</h3><pre><code class="highlight mermaid">sequenceDiagram
    title Classic Java Web MVC (Servlet + JSP) Flow

    participant Browser as 用户浏览器
    participant Servlet/Controller as 控制器
    participant Model/Service as 模型/服务
    participant JSP/View as 视图

    Browser-&gt;&gt;Servlet/Controller: 1. 发送 HTTP 请求 (GET /products?id=123)
    activate Servlet/Controller

    note over Servlet/Controller: 2. Servlet 容器将请求映射到此控制器

    Servlet/Controller-&gt;&gt;Model/Service: 3. 调用业务逻辑 (getProductById)
    activate Model/Service
    Model/Service--&gt;&gt;Servlet/Controller: 返回数据 (Product 对象)
    deactivate Model/Service

    note over Servlet/Controller: 4. 将 Product 对象存入 request 作用域

    Servlet/Controller-&gt;&gt;JSP/View: 5. 请求转发 (Forward)
    deactivate Servlet/Controller

    activate JSP/View
    note over JSP/View: 6. 渲染视图&lt;br/&gt;- 从 request 域获取数据&lt;br/&gt;- 使用 EL/JSTL 生成 HTML
    JSP/View--&gt;&gt;Browser: 7. 返回 HTML 响应
    deactivate JSP/View</code></pre>

<ol>
<li><strong>请求到达：</strong> 用户的浏览器发送一个 HTTP 请求（例如 <code>GET /products?id=123</code>）。</li>
<li><strong>控制器接收：</strong> Servlet 容器根据 <code>web.xml</code> 或 <code>@WebServlet</code> 的配置，将请求映射到一个 <strong>Servlet (Controller)</strong>。</li>
<li><strong>控制器处理：</strong><ul>
<li>Servlet 解析请求参数（<code>id=123</code>）。</li>
<li>Servlet <strong>调用 Model</strong>（例如 <code>ProductService.getProductById(123)</code>）来执行业务逻辑，获取数据。</li>
<li>Model 返回一个包含产品信息的 JavaBean (<code>Product</code> 对象)。</li>
</ul>
</li>
<li><strong>存储数据：</strong> Servlet 将从 Model 获取的数据（<code>Product</code> 对象）存入一个<strong>作用域对象</strong>中，最常用的是 <code>request</code> 域：<code>request.setAttribute(&quot;product&quot;, productObject);</code>。</li>
<li><strong>转发到视图：</strong> Servlet <strong>请求转发 (<code>forward</code>)</strong> 给一个 <strong>JSP (View)</strong> 文件，例如 <code>request.getRequestDispatcher(&quot;/WEB-INF/views/productDetail.jsp&quot;).forward(request, response);</code>。</li>
<li><strong>视图渲染：</strong><ul>
<li>JSP 页面被激活。</li>
<li>它从 <code>request</code> 域中取出之前 Servlet 存入的数据。</li>
<li>使用 JSP 标签（如 JSTL）或表达式语言（EL）将数据显示在 HTML 模板中。</li>
</ul>
</li>
<li><strong>响应返回：</strong> JSP 生成的最终 HTML 页面作为响应被发送回用户的浏览器。</li>
</ol>
<hr>
<h2 id="2-文件上传与下载"><a href="#2-文件上传与下载" class="headerlink" title="2. 文件上传与下载"></a>2. 文件上传与下载</h2><h3 id="2-1-文件上传"><a href="#2-1-文件上传" class="headerlink" title="2.1 文件上传"></a>2.1 文件上传</h3><h4 id="2-1-1-前端准备：HTML-表单"><a href="#2-1-1-前端准备：HTML-表单" class="headerlink" title="2.1.1 前端准备：HTML 表单"></a>2.1.1 前端准备：HTML 表单</h4><p>要实现文件上传，HTML <code>&lt;form&gt;</code> 必须满足以下<strong>三个条件</strong>：</p>
<ol>
<li><code>method</code> 必须为 <strong><code>post</code></strong>。</li>
<li><code>enctype</code> (encoding type) 必须设置为 <strong><code>multipart/form-data</code></strong>。这告诉服务器请求体将被分割成多个部分，每个部分代表一个表单字段或一个文件。</li>
<li>必须包含一个 <code>&lt;input type=&quot;file&quot;&gt;</code> 标签。</li>
</ol>
<p><strong>HTML 示例 (<code>upload.html</code>):</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>File Upload<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Upload a File<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        Description: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        Select file: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadFile&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Upload&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-2-后端处理：Servlet"><a href="#2-1-2-后端处理：Servlet" class="headerlink" title="2.1.2 后端处理：Servlet"></a>2.1.2 后端处理：Servlet</h4><p>后端的 Servlet 需要做两件事来启用文件上传处理：</p>
<ol>
<li>在 Servlet 类上添加 <strong><code>@MultipartConfig</code></strong> 注解。这个注解会通知 Servlet 容器，该 Servlet 将会处理 <code>multipart/form-data</code> 类型的请求，容器需要预先解析好请求体，以便我们通过 API 获取文件部分。</li>
<li>使用 <code>request.getPart(String name)</code> 方法来获取上传的文件以及其他表单字段。这个方法返回一个 <code>Part</code> 对象。</li>
</ol>
<p><strong><code>Part</code> 接口的核心方法：</strong></p>
<ul>
<li><code>InputStream getInputStream()</code>: 获取上传文件的输入流，用于读取文件内容。</li>
<li><code>String getSubmittedFileName()</code>: 获取客户端上传的原始文件名。</li>
<li><code>long getSize()</code>: 获取文件的大小（字节）。</li>
<li><code>String getContentType()</code>: 获取文件的 MIME 类型（如 <code>image/jpeg</code>）。</li>
<li><code>void write(String fileName)</code>: 一个便捷方法，直接将上传的文件内容写入到服务器磁盘的指定路径。</li>
</ul>
<p><strong>Servlet 示例 (<code>UploadServlet.java</code>):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/upload&quot;)</span></span><br><span class="line"><span class="meta">@MultipartConfig(</span></span><br><span class="line"><span class="meta">    // 可以配置上传文件的限制</span></span><br><span class="line"><span class="meta">    // fileSizeThreshold = 1024 * 1024, // 1MB, 超过此大小的文件会直接写入磁盘</span></span><br><span class="line"><span class="meta">    // maxFileSize = 1024 * 1024 * 10,  // 10MB, 单个文件最大值</span></span><br><span class="line"><span class="meta">    // maxRequestSize = 1024 * 1024 * 50 // 50MB, 整个请求的最大值</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UPLOAD_DIR</span> <span class="operator">=</span> <span class="string">&quot;uploads&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取普通表单字段</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取文件部分</span></span><br><span class="line">        <span class="type">Part</span> <span class="variable">filePart</span> <span class="operator">=</span> request.getPart(<span class="string">&quot;uploadFile&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> filePart.getSubmittedFileName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 确定文件存储的绝对路径</span></span><br><span class="line">        <span class="comment">// getServletContext().getRealPath(&quot;&quot;) 获取 Web 应用在服务器上的部署路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">applicationPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">uploadFilePath</span> <span class="operator">=</span> applicationPath + File.separator + UPLOAD_DIR;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建上传目录（如果不存在）</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadFilePath);</span><br><span class="line">        <span class="keyword">if</span> (!uploadDir.exists()) &#123;</span><br><span class="line">            uploadDir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将文件写入服务器</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">savePath</span> <span class="operator">=</span> uploadFilePath + File.separator + fileName;</span><br><span class="line">        filePart.write(savePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 返回响应</span></span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;h1&gt;Description: &quot;</span> + description + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;h1&gt;File &quot;</span> + fileName + <span class="string">&quot; has been uploaded successfully!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;Saved at: &quot;</span> + savePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-文件下载"><a href="#2-2-文件下载" class="headerlink" title="2.2 文件下载"></a>2.2 文件下载</h3><p>文件下载指的是服务器将一个文件以<strong>附件 (attachment)</strong> 的形式发送给客户端，触发浏览器的下载对话框，而不是直接在浏览器中打开。</p>
<p>核心技术是设置两个关键的 <strong>HTTP 响应头</strong>：<code>Content-Type</code> 和 <code>Content-Disposition</code>。</p>
<h4 id="2-2-1-实现步骤"><a href="#2-2-1-实现步骤" class="headerlink" title="2.2.1 实现步骤"></a>2.2.1 实现步骤</h4><ol>
<li><strong>确定要下载的文件：</strong> 通常通过请求参数（如 <code>?fileName=report.pdf</code>）来指定。</li>
<li><strong>设置 <code>Content-Type</code>:</strong> 告诉浏览器文件的 MIME 类型。可以使用 <code>getServletContext().getMimeType(fileName)</code> 来动态获取，如果无法确定，可以设置为通用的 <code>application/octet-stream</code>。</li>
<li><strong>设置 <code>Content-Disposition</code> (最关键):</strong><ul>
<li>将其值设置为 <code>attachment; filename=&quot;your_file_name&quot;</code>。</li>
<li><code>attachment</code> 指示浏览器将其作为附件处理。</li>
<li><code>filename</code> 指定了下载时默认显示的文件名。</li>
<li><strong>注意中文文件名乱码问题：</strong> 文件名需要使用 <code>URLEncoder</code> 进行编码，以符合 HTTP Header 规范。</li>
</ul>
</li>
<li><strong>读取文件并写入响应流：</strong><ul>
<li>使用 <code>FileInputStream</code> 读取服务器上的文件。</li>
<li>使用 <code>response.getOutputStream()</code> 获取字节输出流。</li>
<li>将文件内容从输入流循环读取并写入到输出流。</li>
</ul>
</li>
<li><strong>关闭资源：</strong> 确保输入输出流被正确关闭。</li>
</ol>
<p><strong>Servlet 示例 (<code>DownloadServlet.java</code>):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownloadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取要下载的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fileName == <span class="literal">null</span> || fileName.trim().isEmpty()) &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;Please specify a filename.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设文件都存储在 /WEB-INF/files/ 目录下，这是一个安全的目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;/WEB-INF/files/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取文件的真实路径和 ServletContext</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> context.getRealPath(filePath);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置响应头</span></span><br><span class="line">        <span class="comment">// 3.1 获取文件MIME类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> context.getMimeType(fileName);</span><br><span class="line">        <span class="keyword">if</span> (mimeType == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法识别类型时，使用通用二进制流</span></span><br><span class="line">            mimeType = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setContentType(mimeType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 设置 Content-Disposition，解决中文文件名乱码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encodedFileName</span> <span class="operator">=</span> URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=\&quot;&quot;</span> + encodedFileName + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 读取文件并写入响应</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">             <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 如果文件不存在或读取错误</span></span><br><span class="line">            response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;File not found or unable to read.&quot;</span>);</span><br><span class="line">            System.err.println(<span class="string">&quot;Error downloading file: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-异步-Servlet-Servlet-3-0"><a href="#3-异步-Servlet-Servlet-3-0" class="headerlink" title="3. 异步 Servlet (Servlet 3.0+)"></a>3. 异步 Servlet (Servlet 3.0+)</h2><h3 id="3-1-解决的问题"><a href="#3-1-解决的问题" class="headerlink" title="3.1 解决的问题"></a>3.1 解决的问题</h3><p>传统的（同步）Servlet 模型是**“一个请求，一个线程，直到响应完成”**。当一个请求到达时，Servlet 容器会从其线程池中分配一个线程来处理这个请求。这个线程会全程负责执行 Servlet 的 <code>service</code> 方法，直到响应数据完全写入并发送给客户端后，该线程才会被释放并返回到线程池。</p>
<p><strong>核心问题在于：</strong> 如果 Servlet 的业务逻辑中包含<strong>耗时的、阻塞式I&#x2F;O操作</strong>（例如：调用一个缓慢的远程 Web Service、执行一个复杂的数据库查询、等待消息队列的返回），那么这个<strong>请求处理线程就会被长时间阻塞</strong>，空闲地等待，而不能去做其他任何事情。</p>
<p>当大量这样的慢请求并发到达时，容器的线程池会迅速被耗尽。所有线程都被阻塞在等待 I&#x2F;O 上，导致服务器无法再接受和处理新的请求，从而造成<strong>服务吞吐量急剧下降</strong>，甚至<strong>应用崩溃</strong>。这就是所谓的**“线程饥饿 (Thread Starvation)”**。</p>
<p><strong>异步 Servlet 的目的就是为了解决这个问题。</strong></p>
<p>它的核心思想是：<strong>将请求处理线程与耗时的业务逻辑解耦</strong>。当一个耗时操作开始时，Servlet 可以<strong>立即释放</strong>容器的请求处理线程，让它返回线程池去服务其他请求。同时，将耗时任务交给一个<strong>后台的、独立的线程池</strong>去执行。当后台任务完成后，再通过一个回调机制，将结果写回给客户端的响应流。</p>
<p><strong>一句话总结：异步 Servlet 并非让单个慢操作变快，而是通过释放关键的请求处理线程，让服务器在等待慢操作时能处理更多其他请求，从而极大地提高了应用的伸缩性 (Scalability) 和吞吐量 (Throughput)。</strong></p>
<hr>
<h3 id="3-2-核心-API"><a href="#3-2-核心-API" class="headerlink" title="3.2 核心 API"></a>3.2 核心 API</h3><p>实现异步 Servlet 主要涉及以下几个关键 API：</p>
<ol>
<li><strong>开启异步支持:</strong><ul>
<li>必须在 Servlet 配置中明确声明支持异步。</li>
<li><strong>注解方式：</strong> <code>@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)</code></li>
<li><strong><code>web.xml</code> 方式：</strong> 在 <code>&lt;servlet&gt;</code> 标签中添加 <code>&lt;async-supported&gt;true&lt;/async-supported&gt;</code></li>
</ul>
</li>
<li><strong><code>request.startAsync()</code>:</strong><ul>
<li>这是启动异步处理的入口点。在 <code>doGet</code>&#x2F;<code>doPost</code> 等方法中调用它。</li>
<li>调用后，请求将进入异步模式，原始的 <code>request</code> 和 <code>response</code> 对象会被封装起来。</li>
<li>它返回一个 <code>AsyncContext</code> 对象，这是后续所有异步操作的核心。</li>
<li>一旦调用此方法，容器的请求处理线程就可以结束其 <code>service</code> 方法并被释放了。</li>
</ul>
</li>
<li><strong><code>AsyncContext</code> 对象:</strong><ul>
<li>这是异步处理的上下文环境，持有对原始请求和响应的引用。</li>
<li><strong><code>getRequest()</code> &#x2F; <code>getResponse()</code>:</strong> 从后台线程中获取原始的 <code>request</code> 和 <code>response</code> 对象。</li>
<li><strong><code>start(Runnable run)</code>:</strong> 一个便捷方法，可以将一个 <code>Runnable</code> 任务提交给容器管理的线程池去执行。</li>
<li><strong><code>dispatch(String path)</code>:</strong> 在异步任务完成后，可以将请求<strong>派发</strong>给另一个 Servlet 或 JSP 来完成最终的响应渲染。</li>
<li><strong><code>complete()</code>: (最重要)</strong> 当异步任务处理完成，并且响应数据已经写入完毕时，<strong>必须调用此方法</strong>。它会通知容器，该异步过程已结束，可以关闭连接并将响应发送给客户端。</li>
<li><strong><code>setTimeout(long timeout)</code>:</strong> 设置异步操作的超时时间（毫秒）。如果超时，会触发 <code>AsyncListener</code> 的 <code>onTimeout</code> 事件。</li>
<li><strong><code>addListener(AsyncListener listener)</code>:</strong> 添加一个异步监听器来处理超时、错误、完成等事件。</li>
</ul>
</li>
</ol>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用一个独立的线程池来处理耗时任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;主线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 开始处理请求。&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 启动异步上下文</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AsyncContext</span> <span class="variable">asyncContext</span> <span class="operator">=</span> request.startAsync();</span><br><span class="line">        <span class="comment">// 设置超时时间 (例如 10 秒)</span></span><br><span class="line">        asyncContext.setTimeout(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将耗时任务提交到后台线程池</span></span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟一个耗时的I/O操作</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从 AsyncContext 获取响应对象</span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">asyncOut</span> <span class="operator">=</span> asyncContext.getResponse().getWriter();</span><br><span class="line">                asyncOut.println(<span class="string">&quot;后台线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 完成了耗时任务。&quot;</span>);</span><br><span class="line">                asyncOut.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 任务完成，必须调用 complete()</span></span><br><span class="line">                asyncContext.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;主线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 已释放，可以去处理其他请求了。&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-应用场景"><a href="#3-3-应用场景" class="headerlink" title="3.3 应用场景"></a>3.3 应用场景</h3><p>异步 Servlet 主要适用于<strong>I&#x2F;O密集型</strong>而非 CPU 密集型的场景。</p>
<ul>
<li><strong>调用外部 Web Service 或微服务:</strong><br>当你的应用需要调用另一个系统的 REST API 或 SOAP 服务，而对方响应较慢时，这是异步 Servlet 的完美应用场景。</li>
<li><strong>复杂的数据库操作或报表生成:</strong><br>执行需要长时间运行的数据库查询、数据聚合或生成大型报表时，可以使用异步处理，避免阻塞 Web 服务器。</li>
<li><strong>消息队列 (Message Queue) 的发布&#x2F;订阅:</strong><br>向消息中间件（如 RabbitMQ, Kafka）发送消息后，需要等待一个异步的回调或从另一个队列接收响应。</li>
<li><strong>实现长轮询 (Long Polling &#x2F; Comet):</strong><br>这是构建实时 Web 应用（如在线聊天、股票行情推送、实时通知）的一种技术。客户端发起一个请求，服务器端如果没有新数据，就<strong>挂起</strong>这个连接（通过启动异步上下文并释放线程），直到有新数据到达时，才通过 <code>AsyncContext</code> 将数据写回并 <code>complete()</code> 响应。这可以极大地节省服务器资源，是 WebSocket 出现之前的主流实时技术。</li>
<li><strong>作为API网关或代理:</strong><br>一个 Servlet 需要从多个后端服务拉取数据，然后聚合成一个响应返回。它可以异步地并行调用这些后端服务，从而缩短整体响应时间。</li>
</ul>
<hr>
<h2 id="4-Servlet-规范演进"><a href="#4-Servlet-规范演进" class="headerlink" title="4. Servlet 规范演进"></a>4. Servlet 规范演进</h2><h3 id="4-1-从-javax-servlet-Java-EE-到-jakarta-servlet-Jakarta-EE-的变迁"><a href="#4-1-从-javax-servlet-Java-EE-到-jakarta-servlet-Jakarta-EE-的变迁" class="headerlink" title="4.1 从 javax.servlet.* (Java EE) 到 jakarta.servlet.* (Jakarta EE) 的变迁"></a>4.1 从 <code>javax.servlet.*</code> (Java EE) 到 <code>jakarta.servlet.*</code> (Jakarta EE) 的变迁</h3><p>这是一个对 Java 生态系统产生深远影响的重大变化，主要是由于<strong>项目所有权的变更</strong>。</p>
<p><strong>背景：</strong></p>
<ul>
<li><strong>Java EE (Java Platform, Enterprise Edition)</strong> 最初由 Sun Microsystems 开发，后来由 <strong>Oracle</strong> 掌管。所有相关的 API 都位于 <code>javax.*</code> 包名下（<code>x</code> 代表 “extension”）。</li>
<li>2017年，Oracle 决定将 Java EE 移交给一个开源组织——<strong>Eclipse 基金会 (Eclipse Foundation)</strong> 来管理，以促进其更快的发展和社区参与。</li>
<li>项目被重新命名为 <strong>Jakarta EE</strong>。</li>
<li>由于 Oracle 拥有 <code>javax</code> 的商标权，Eclipse 基金会不能在新的 Jakarta EE 规范中继续使用这个包名来发布新版本。</li>
</ul>
<p><strong>核心变化：</strong></p>
<p>为了解决商标问题，Jakarta EE 社区决定进行一次“大爆炸”式的变更：从 <strong>Jakarta EE 9</strong> 版本开始，所有 API 的顶级包名从 <code>javax</code> 更改为 <code>jakarta</code>。</p>
<p>这对 Servlet API 意味着：</p>
<ul>
<li><p><strong>旧版本 (Servlet 4.0 及更早, 属于 Java EE 8 及更早):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>新版本 (Servlet 5.0 及更高, 属于 Jakarta EE 9 及更高):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>对开发者的影响：</strong></p>
<p>这是一个<strong>破坏性变更</strong>。当项目从基于 Java EE 8 的服务器（如 Tomcat 9）迁移到基于 Jakarta EE 9+ 的服务器（如 Tomcat 10+）时，开发者必须：</p>
<ol>
<li><strong>更新代码</strong>中的所有 <code>import</code> 语句。</li>
<li><strong>更新项目构建工具</strong>（如 Maven, Gradle）中的依赖坐标，从 <code>javax.servlet:javax.servlet-api</code> 更改为 <code>jakarta.servlet:jakarta.servlet-api</code>。</li>
</ol>
<hr>
<h2 id="5-与Spring的关系"><a href="#5-与Spring的关系" class="headerlink" title="5. 与Spring的关系"></a>5. 与Spring的关系</h2><p>现代 Spring Boot 与 Servlet 的合作模式可以总结为：<strong>Spring Boot 在 Servlet API 的基础上，构建了一个高度自动化、约定优于配置的开发框架。它为你管理了所有繁琐的底层 Servlet 配置，让你能专注于业务逻辑。</strong></p>
<h3 id="5-1-容器的自动化管理-The-Car-Factory"><a href="#5-1-容器的自动化管理-The-Car-Factory" class="headerlink" title="5.1 容器的自动化管理 (The Car Factory)"></a>5.1 容器的自动化管理 (The Car Factory)</h3><p><strong>传统方式:</strong></p>
<p>在没有 Spring Boot 的时代，你需要：</p>
<ol>
<li>编写一个 <code>Servlet</code> 类。</li>
<li>在 <code>web.xml</code> 文件中手动配置这个 <code>Servlet</code>，包括它的类路径、URL 映射 (<code>&lt;servlet-mapping&gt;</code>)、加载顺序 (<code>&lt;load-on-startup&gt;</code>) 等。</li>
<li>将你的应用打包成一个 <code>.war</code> 文件。</li>
<li>手动将这个 <code>.war</code> 文件部署到一个外部的 Servlet 容器（如 Tomcat, Jetty）中。</li>
</ol>
<p><strong>Spring Boot 方式 :</strong></p>
<p>Spring Boot 彻底改变了这一点：</p>
<ul>
<li><strong>内嵌 Servlet 容器</strong>：你不再需要外部的 Tomcat。当你引入 <code>spring-boot-starter-web</code> 依赖时，Spring Boot 会默认将 Tomcat（或 Jetty&#x2F;Undertow）作为<strong>一个库</strong>直接嵌入到你的应用中。</li>
<li><strong>启动即运行</strong>：运行 <code>main</code> 方法时，Spring Boot 会自动启动这个内嵌的 Tomcat 服务器，并把你的应用部署进去。没有了 <code>.war</code> 包和外部部署的繁琐步骤，开发和部署变得极其简单。</li>
</ul>
<hr>
<h3 id="5-2-请求的核心分发者：DispatcherServlet"><a href="#5-2-请求的核心分发者：DispatcherServlet" class="headerlink" title="5.2 请求的核心分发者：DispatcherServlet"></a>5.2 请求的核心分发者：<code>DispatcherServlet</code></h3><p>这是 Spring 与 Servlet 合作的<strong>最核心</strong>的组件。</p>
<p><strong>传统方式：</strong></p>
<p>你可能会为不同的功能编写多个 <code>Servlet</code>，比如 <code>LoginServlet</code>, <code>OrderServlet</code> 等，并在 <code>web.xml</code> 中为它们分别配置不同的 URL 映射。</p>
<p><strong>Spring Boot &#x2F; Spring MVC 方式：</strong></p>
<p>Spring Boot 遵循了 Spring MVC 的“前端控制器模式”（Front Controller Pattern）。它会自动为你注册一个<strong>唯一且核心</strong>的 Servlet，叫做 <code>DispatcherServlet</code>。</p>
<p>这个 <code>DispatcherServlet</code> 扮演着“交通总指挥”的角色：</p>
<ol>
<li><strong>接管所有请求</strong>：默认情况下，<code>DispatcherServlet</code> 会注册到应用的根路径 (<code>/</code>)，意味着几乎所有的 Web 请求都会先到达它这里。</li>
<li><strong>智能路由</strong>：<code>DispatcherServlet</code> 接收到请求后，不会自己处理业务逻辑。它会查询内部的 <strong><code>HandlerMapping</code></strong>（处理器映射），根据请求的 URL、HTTP 方法等信息，找到应该由哪个 <code>@Controller</code> 里的哪个方法来处理。</li>
<li><strong>分发执行</strong>：找到对应的处理方法（比如一个被 <code>@GetMapping(&quot;/users/{id}&quot;)</code> 注解的方法）后，<code>DispatcherServlet</code> 会调用它，并将处理结果（模型和视图，或 JSON 数据）返回给客户端。</li>
</ol>
<hr>
<h3 id="5-3-一个典型请求的生命周期"><a href="#5-3-一个典型请求的生命周期" class="headerlink" title="5.3 一个典型请求的生命周期"></a>5.3 一个典型请求的生命周期</h3><p>让我们看看一个请求在 Spring Boot 应用中是如何流转的：</p>
<pre><code class="highlight mermaid">sequenceDiagram
    title Spring Boot 请求处理流程

    participant Client as 客户端
    participant Tomcat as 内嵌 Tomcat
    participant FilterChain as Servlet 过滤器链
    participant DS as DispatcherServlet
    participant HM as HandlerMapping
    participant Controller as UserController
    participant HMC as HttpMessageConverter

    %% 1. 客户端发起请求
    Client-&gt;&gt;Tomcat: 1. 发送 HTTP 请求 (GET /api/users/123)

    %% 2 &amp; 3. Tomcat 接收并传递给过滤器链
    Tomcat-&gt;&gt;FilterChain: 2 &amp; 3. 传递请求给过滤器链
    note over FilterChain: 执行如 CharacterEncodingFilter, SecurityFilter 等

    %% 4. 请求到达 DispatcherServlet
    FilterChain-&gt;&gt;DS: 4. 请求穿过过滤器，到达 DispatcherServlet

    %% 5 &amp; 6. DispatcherServlet 查询并找到 Handler
    DS-&gt;&gt;HM: 5. 查询 HandlerMapping
    HM--&gt;&gt;DS: 6. 找到匹配的 Handler (UserController.getUserById)

    %% 7. DispatcherServlet 调用 Controller 方法
    DS-&gt;&gt;Controller: 7. 调用 getUserById(123)

    %% 8. Controller 处理并返回数据对象
    activate Controller
    note over Controller: 执行业务逻辑 (如查询数据库)
    Controller--&gt;&gt;DS: 8. 返回 User 对象
    deactivate Controller

    %% 9. DispatcherServlet 序列化对象
    DS-&gt;&gt;HMC: 9. 请求 HttpMessageConverter (Jackson) 序列化
    HMC--&gt;&gt;DS: 返回 JSON 字符串: &#123;&quot;id&quot;:123, &quot;name&quot;:&quot;...&quot;&#125;

    %% 10 &amp; 11. 响应反向穿过过滤器链
    DS-&gt;&gt;FilterChain: 10 &amp; 11. 将 JSON 响应反向传递给过滤器链
    note over FilterChain: 过滤器可对响应进行处理

    %% 12. Tomcat 将最终响应发送回客户端
    FilterChain-&gt;&gt;Tomcat: 响应穿过过滤器
    Tomcat--&gt;&gt;Client: 12. 返回最终 HTTP 响应 (200 OK + JSON Body)</code></pre>



<ol>
<li><strong>客户端</strong> 发送一个 HTTP 请求，例如 <code>GET /api/users/123</code>。</li>
<li><strong>内嵌的 Servlet 容器 (Tomcat)</strong> 接收到这个网络请求。</li>
<li>Tomcat 将请求传递给 Spring Boot 自动配置的 <strong>Servlet 过滤器链 (Filter Chain)</strong>，例如处理字符编码的 <code>CharacterEncodingFilter</code>、处理安全的 Spring Security 过滤器等。</li>
<li>请求穿过过滤器链，最终到达核心的 <strong><code>DispatcherServlet</code></strong>。</li>
<li><code>DispatcherServlet</code> 根据 <code>/api/users/123</code> 这个路径，查询 <code>HandlerMapping</code>。</li>
<li><code>HandlerMapping</code> 匹配到你编写的 <code>UserController</code> 中的 <code>getUserById(@PathVariable Long id)</code> 方法。</li>
<li><code>DispatcherServlet</code> 调用 <code>UserController</code> 的方法，并将路径中的 <code>123</code> 作为参数传入。</li>
<li>你的方法执行业务逻辑，返回一个 <code>User</code> 对象。</li>
<li>由于你的 <code>UserController</code> 通常被 <code>@RestController</code> 注解，<code>DispatcherServlet</code> 会通过 <strong><code>HttpMessageConverter</code></strong> (如 Jackson) 将 <code>User</code> 对象序列化成 JSON 字符串。</li>
<li><code>DispatcherServlet</code> 将 JSON 数据包装成一个 <code>HttpServletResponse</code>。</li>
<li>这个 Response 再反向穿过过滤器链。</li>
<li><strong>Tomcat</strong> 将最终的 HTTP 响应发送回客户端。</li>
</ol>
<p>在这个过程中，Servlet API（如 <code>HttpServletRequest</code>, <code>HttpServletResponse</code>, <code>Filter</code>）是这一切的<strong>底层基础</strong>，而 Spring Boot 和 Spring MVC 在其上构建了<strong>高层抽象</strong>（<code>@Controller</code>, <code>@GetMapping</code>, <code>@RequestBody</code> 等）。</p>
<hr>
<h3 id="5-4-直接与-Servlet-API-交互"><a href="#5-4-直接与-Servlet-API-交互" class="headerlink" title="5.4 直接与 Servlet API 交互"></a>5.4 直接与 Servlet API 交互</h3><p>虽然 Spring Boot 自动化了绝大部分工作，但它<strong>从未阻止</strong>你使用原生的 Servlet API。当你需要进行一些非常底层的、自定义的操作时，Spring Boot 提供了优雅的方式来实现。</p>
<h4 id="方式一：在-Controller-方法中直接注入"><a href="#方式一：在-Controller-方法中直接注入" class="headerlink" title="方式一：在 Controller 方法中直接注入"></a>方式一：在 Controller 方法中直接注入</h4><p>你可以直接在你的 Controller 方法参数中声明 <code>HttpServletRequest</code> 或 <code>HttpServletResponse</code>，Spring 会自动将它们注入进来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/some/path&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userAgent</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;User-Agent&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动操作 response</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;User-Agent is: &quot;</span> + userAgent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="方式二：注册自定义的-Filter-Servlet-Listener"><a href="#方式二：注册自定义的-Filter-Servlet-Listener" class="headerlink" title="方式二：注册自定义的 Filter, Servlet, Listener"></a>方式二：注册自定义的 <code>Filter</code>, <code>Servlet</code>, <code>Listener</code></h4><p>如果你想添加自定义的过滤器，不需要 <code>web.xml</code>，只需要将它们声明为 Spring 的 <code>@Bean</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个自定义的 Filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;MyCustomFilter&gt; <span class="title function_">customFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        FilterRegistrationBean&lt;MyCustomFilter&gt; registrationBean = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        registrationBean.setFilter(<span class="keyword">new</span> <span class="title class_">MyCustomFilter</span>());</span><br><span class="line">        registrationBean.addUrlPatterns(<span class="string">&quot;/api/*&quot;</span>); <span class="comment">// 只对 /api/* 路径下的请求生效</span></span><br><span class="line">        registrationBean.setOrder(<span class="number">1</span>); <span class="comment">// 设置过滤器的顺序</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的 Filter 实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Request processing started...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        chain.doFilter(request, response); <span class="comment">// 让请求继续向下传递</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(<span class="string">&quot;Request processing finished in &quot;</span> + duration + <span class="string">&quot;ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的方式也适用于注册自定义的 <code>Servlet</code> (<code>ServletRegistrationBean</code>) 和 <code>Listener</code> (<code>ServletListenerRegistrationBean</code>)。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/06/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringSecurity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/06/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringSecurity/" class="post-title-link" itemprop="url">Spring全家桶-SpringSecurity</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-06 15:43:07" itemprop="dateCreated datePublished" datetime="2025-10-06T15:43:07+08:00">2025-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:09:49" itemprop="dateModified" datetime="2025-10-17T11:09:49+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="五、SpringSecurity"><a href="#五、SpringSecurity" class="headerlink" title="五、SpringSecurity"></a>五、SpringSecurity</h1><h2 id="1-入门与核心概念"><a href="#1-入门与核心概念" class="headerlink" title="1. 入门与核心概念"></a>1. 入门与核心概念</h2><h3 id="1-1-为什么需要-Spring-Security？"><a href="#1-1-为什么需要-Spring-Security？" class="headerlink" title="1.1 为什么需要 Spring Security？"></a>1.1 为什么需要 Spring Security？</h3><p>在构建任何一个严肃的Web应用时，<strong>安全（Security）永远是第一道防线，而不是一个可有可无的附加功能</strong>。无论是保护用户数据，还是防止系统被恶意攻击，一个健全的安全机制都是必不可少的。</p>
<p>那么，为什么我们不自己写安全逻辑，而要选择像 Spring Security 这样重量级的框架呢？</p>
<hr>
<h4 id="1-1-1-自己实现安全控制的陷阱"><a href="#1-1-1-自己实现安全控制的陷阱" class="headerlink" title="1.1.1 自己实现安全控制的陷阱"></a>1.1.1 自己实现安全控制的陷阱</h4><p>如果我们尝试自己动手实现安全功能，通常会怎么做？</p>
<ol>
<li><strong>登录验证</strong>：在 Controller 里写一个 <code>login</code> 方法，从请求中获取用户名和密码，查询数据库，比对成功后将用户信息存入 <code>HttpSession</code>。</li>
<li><strong>访问控制</strong>：在需要保护的 Controller 方法或 Service 方法开头，写大量的 <code>if/else</code> 逻辑，从 <code>HttpSession</code> 中取出用户信息，判断其是否有权限访问。</li>
</ol>
<p>这种“手写”方式会带来一系列严重问题：</p>
<ul>
<li><strong>代码高度耦合且重复</strong>：安全逻辑（权限判断）和业务逻辑混杂在一起，遍布在项目的各个角落。一旦权限规则变更，你需要修改大量代码，极难维护。</li>
<li><strong>容易出错且不安全</strong>：安全是一个非常专业的领域。“自己发明”的加密算法、会话管理机制很可能存在未知的漏洞。例如，密码没有加盐（Salt）、容易受到时序攻击（Timing Attacks）、没有防护会话固定（Session Fixation）等。一个微小的疏忽就可能导致整个系统被攻破。</li>
<li><strong>功能不全面</strong>：一个现代Web应用需要的远不止是登录和简单的权限判断。你还需要考虑：<ul>
<li>CSRF（跨站请求伪造）防护</li>
<li>CORS（跨域资源共享）配置</li>
<li>防止暴力破解（如登录失败次数限制）</li>
<li>“记住我”功能  </li>
<li>与其他认证体系（如OAuth2, LDAP）集成</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>结论：</strong> “不要重复造轮子”，尤其不要造“安全的轮子”。自己实现安全控制费时费力、极易出错，且难以维护。</p>
<hr>
<h4 id="1-1-2-Spring-Security-解决的核心问题"><a href="#1-1-2-Spring-Security-解决的核心问题" class="headerlink" title="1.1.2 Spring Security 解决的核心问题"></a>1.1.2 Spring Security 解决的核心问题</h4><p>Spring Security 作为一个专业、强大的安全框架，解决了两个最核心、最基础的安全问题：</p>
<ol>
<li><strong>认证 (Authentication) - “你是谁？”</strong><ul>
<li>这是验证用户身份的过程。用户提供一些凭证（Credentials），如用户名和密码、手机验证码、指纹、或是一个Token，系统通过验证这些凭证来确认用户的真实身份。</li>
</ul>
</li>
<li><strong>授权 (Authorization) - “你能做什么？”</strong><ul>
<li>这发生在认证成功之后。系统根据已认证用户的身份（通常是其拥有的角色或权限），来决定他是否有权访问某个资源（如一个URL、一个按钮、一个方法）。</li>
</ul>
</li>
</ol>
<p>Spring Security 提供了一套标准的、可扩展的机制来优雅地处理认证和授权。</p>
<hr>
<h4 id="1-1-3-Spring-Security核心优势"><a href="#1-1-3-Spring-Security核心优势" class="headerlink" title="1.1.3 Spring Security核心优势"></a>1.1.3 Spring Security核心优势</h4><ol>
<li><strong>与 Spring 生态无缝集成</strong><ul>
<li>作为 Spring 家族的一员，它能与 Spring Boot, Spring MVC, Spring Data 等项目完美整合。通过简单的依赖引入和自动化配置，你就能快速拥有一个基础的安全环境。</li>
</ul>
</li>
<li><strong>声明式安全 (Declarative Security)</strong><ul>
<li>你不再需要在业务代码中手动编写 <code>if-else</code> 来判断权限。Spring Security 允许你通过<strong>配置</strong>和<strong>注解</strong>来声明安全规则。</li>
<li><strong>例如</strong>：<ul>
<li><strong>配置层面</strong>：<code>http.authorizeHttpRequests(auth -&gt; auth.requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;))</code>，一行代码保护所有 <code>/admin/</code> 开头的 URL。</li>
<li><strong>方法层面</strong>：在方法上加一个注解 <code>@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)</code>，就完成了对该方法的权限控制。</li>
</ul>
</li>
<li>这种方式让安全逻辑与业务逻辑彻底解耦，代码更清晰，维护性更高。</li>
</ul>
</li>
<li><strong>全面且强大的功能</strong><ul>
<li><strong>全面的认证支持</strong>：支持基于表单、HTTP Basic、LDAP、OAuth2、OpenID Connect、SAML 等多种认证方式。</li>
<li><strong>精细的授权控制</strong>：支持基于URL的授权、基于方法的授权，并且可以使用强大的SpEL表达式进行复杂的动态授权。</li>
<li><strong>内置常见Web攻击防护</strong>：默认开启并强制执行 CSRF 防护、会话固定攻击防护、点击劫持（Clickjacking）防护等，大大提升了应用的安全性。</li>
</ul>
</li>
<li><strong>高度可扩展</strong><ul>
<li>Spring Security 的设计遵循“面向接口编程”和“责任链模式”。几乎每一个核心组件（如 <code>UserDetailsService</code>, <code>PasswordEncoder</code>, <code>AuthenticationProvider</code>）都是可替换、可扩展的。这意味着你可以轻松地将其定制为你需要的任何认证授权模式（如短信验证码登录、扫码登录等）。</li>
</ul>
</li>
<li><strong>久经考验，社区活跃</strong><ul>
<li>它是一个非常成熟的开源项目，被全球数百万的Java项目所使用，其稳定性和安全性经过了长时间和大规模应用的检验。活跃的社区和及时的版本更新也保证了它可以持续对抗新出现的安全威胁。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-Spring-Security-简介与架构概览"><a href="#1-2-Spring-Security-简介与架构概览" class="headerlink" title="1.2 Spring Security 简介与架构概览"></a>1.2 Spring Security 简介与架构概览</h3><h4 id="1-2-1-核心思想：基于-Servlet-过滤器的责任链模式"><a href="#1-2-1-核心思想：基于-Servlet-过滤器的责任链模式" class="headerlink" title="1.2.1 核心思想：基于 Servlet 过滤器的责任链模式"></a>1.2.1 核心思想：基于 Servlet 过滤器的责任链模式</h4><p>Spring Security 的核心是<strong>一系列的 Servlet 过滤器（Servlet Filter）</strong>。</p>
<p>Spring Security 利用了 Servlet Filter 这一标准机制。它将不同的安全职责（如 CSRF 防护、Session 管理、认证处理、授权检查等）封装到一个个独立的 Filter 中，并将它们组织成一个<strong>有序的链条（Filter Chain）</strong>。</p>
<p>当一个 HTTP 请求进入应用时，它会像通过依次穿过这个过滤器链。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>解耦</strong>：每个 Filter 只关心自己的职责，高度内聚。</li>
<li><strong>可插拔</strong>：我们可以根据需要，轻松地在链条中添加、移除或替换某个 Filter，实现高度定制化。</li>
<li><strong>与框架无关</strong>：由于它工作在 Servlet 层面，因此它能在 <code>DispatcherServlet</code> 之前就保护你的应用，而不仅仅是保护 Spring MVC 的 Controller。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-2-宏观架构：从请求入口到安全处理"><a href="#1-2-2-宏观架构：从请求入口到安全处理" class="headerlink" title="1.2.2 宏观架构：从请求入口到安全处理"></a>1.2.2 宏观架构：从请求入口到安全处理</h4><p>一个典型的请求在 Spring Security 中的旅程如下：</p>
<pre><code class="highlight mermaid">graph LR


    subgraph &quot;Spring容器&quot;
        subgraph C[&quot;FilterChainProxy&quot;]
            E[SecurityFilterChain]
            F[SecurityFilterChain]
            G[SecurityFilterChain]
            ....
        end
    end

    subgraph &quot;Servlet容器&quot;
        subgraph &quot;过滤器链&quot;
            B[DelegatingFilterProxy]
        end
    end

    A[客户端]
    A--&gt;|HTTP请求|B
    B--&gt;C</code></pre>

<ol>
<li><strong>客户端</strong> 发起一个 HTTP 请求（例如，访问 <code>/dashboard</code>）。</li>
<li>请求首先到达 <strong>Servlet 容器</strong>（如 Tomcat）。</li>
<li>容器的过滤器链中，一个名为 <code>DelegatingFilterProxy</code> 的特殊 Filter 会被触发。</li>
<li><strong><code>DelegatingFilterProxy</code></strong>：<ul>
<li>它本身是一个标准的 Servlet Filter，生命周期由 Servlet 容器管理。</li>
<li>它的作用像一个**“桥梁”<strong>，它不做任何安全逻辑，唯一的任务就是在 Spring 的应用上下文（ApplicationContext）中找到一个名为 <code>springSecurityFilterChain</code>（这是一个 Bean 的名字）的代理，并将请求处理</strong>委托（Delegate）**给它。</li>
<li><strong>为什么需要这个桥梁？</strong> 因为 Servlet Filter 是由容器加载的，而 Spring Security 的所有组件都是 Spring 管理的 Bean。<code>DelegatingFilterProxy</code> 解决了 Servlet 世界和 Spring 世界之间的连接问题。</li>
</ul>
</li>
<li><strong><code>FilterChainProxy</code></strong> (即 <code>springSecurityFilterChain</code> Bean)：<ul>
<li>这是一个由 Spring Security 提供的功能极其强大的 Filter。可以称它为**“过滤器链的管理者”**。</li>
<li>它内部维护了<strong>一个或多个安全过滤器链 (<code>SecurityFilterChain</code>)</strong>。</li>
<li>当请求到达时，<code>FilterChainProxy</code> 会根据请求的 URL 路径，决定使用哪一个 <code>SecurityFilterChain</code> 来处理这个请求。这允许我们为不同的路径（如 <code>/api/**</code> 和 <code>/web/**</code>）配置完全不同的安全策略。</li>
</ul>
</li>
<li><strong><code>SecurityFilterChain</code></strong>：<ul>
<li>这就是我们通常通过 Java 配置（<code>@Bean public SecurityFilterChain ...</code>）来定义的东西。它是一个<strong>包含了多个具体安全过滤器的有序列表</strong>。</li>
<li>请求会按照这个列表的顺序，依次通过每一个 Filter。</li>
<li><strong>常见的 Filter 包括（顺序很重要）</strong>：<ul>
<li><code>CsrfFilter</code>: 进行 CSRF 令牌校验。</li>
<li><code>UsernamePasswordAuthenticationFilter</code>: 处理基于表单的用户名密码登录请求。</li>
<li><code>BasicAuthenticationFilter</code>: 处理 HTTP Basic 认证。</li>
<li><code>AuthorizationFilter</code>: 检查用户是否有权限访问请求的资源。</li>
<li>等等…</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理流程</strong>：<ul>
<li>如果请求在链条的某个 Filter 中处理失败（例如，CSRF 令牌无效，或认证失败），该 Filter 会**“短路” (Short-circuit)** 整个流程，直接向客户端返回错误响应（如 401 Unauthorized 或 403 Forbidden），请求将不会到达后续的 Filter 或业务代码。</li>
<li>如果请求成功通过了整个过滤器链，它最终会被放行，到达 <code>DispatcherServlet</code>，并由你的 Controller 进行处理。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-2-3-状态管理：SecurityContextHolder"><a href="#1-2-3-状态管理：SecurityContextHolder" class="headerlink" title="1.2.3 状态管理：SecurityContextHolder"></a>1.2.3 状态管理：<code>SecurityContextHolder</code></h4><p>当一个用户通过认证后，他的身份信息（比如用户名、角色权限）将会存放到 <strong><code>SecurityContextHolder</code></strong>。</p>
<ul>
<li><strong><code>SecurityContextHolder</code></strong> 是一个<strong>全局的、静态的</strong>工具类，用于存储和获取当前线程的安全上下文（<code>SecurityContext</code>）。</li>
<li>默认情况下，它使用 <strong><code>ThreadLocal</code></strong> 策略来存储 <code>SecurityContext</code>。这意味着安全上下文与<strong>当前执行的线程</strong>绑定。当一个请求进入时，Spring Security 会为该请求的线程创建一个<code>SecurityContext</code>；当请求处理完毕时，它会清理这个上下文。</li>
<li><strong><code>SecurityContext</code></strong>：它主要的作用是持有 <code>Authentication</code> 对象。</li>
<li><strong><code>Authentication</code></strong>：这是 Spring Security 中代表认证信息的核心接口。它包含了：<ul>
<li><strong><code>principal</code></strong>: 代表“当事人”，通常是 <code>UserDetails</code> 对象，包含了用户的详细信息（用户名、密码、账户状态等）。</li>
<li><strong><code>authorities</code></strong>: 代表用户拥有的权限集合（如 <code>ROLE_ADMIN</code>, <code>READ_PRIVILEGE</code>）。</li>
<li><strong><code>credentials</code></strong>: 用户的凭证（如密码），在认证成功后通常会被清空。</li>
</ul>
</li>
</ul>
<p><strong>整个流程串联起来</strong>：当 <code>UsernamePasswordAuthenticationFilter</code> 成功认证一个用户后，它会创建一个完整的 <code>Authentication</code> 对象，并将其设置到 <code>SecurityContextHolder.getContext()</code> 中。之后，当请求到达 <code>AuthorizationFilter</code> 时，它就会从 <code>SecurityContextHolder</code> 中取出这个 <code>Authentication</code> 对象，检查其中的权限，来决定是否放行。你的业务代码中也可以随时通过 <code>SecurityContextHolder</code> 获取当前登录用户的信息。</p>
<hr>
<h3 id="1-3-核心组件详解"><a href="#1-3-核心组件详解" class="headerlink" title="1.3 核心组件详解"></a>1.3 核心组件详解</h3><h4 id="1-3-1-SecurityFilterChain"><a href="#1-3-1-SecurityFilterChain" class="headerlink" title="1.3.1 SecurityFilterChain"></a>1.3.1 <code>SecurityFilterChain</code></h4><ul>
<li><p><strong>是什么？</strong></p>
<ul>
<li><code>SecurityFilterChain</code> 是一个接口，其实现类包含一个<strong>有序的 Servlet Filter 列表</strong>。它代表了一套完整的、针对特定 HTTP 请求的安全处理策略。</li>
</ul>
</li>
<li><p><strong>职责</strong>：</p>
<ul>
<li>定义哪些过滤器（Filters）被应用。</li>
<li>定义这些过滤器的应用顺序。</li>
<li>定义这个过滤器链作用于哪些 HTTP 请求（通过 <code>requestMatcher</code>）。</li>
</ul>
</li>
<li><p><strong>现代配置的核心</strong>：</p>
<ul>
<li>在现代的 Spring Security 配置中（Spring Boot 2.7+），我们不再继承 <code>WebSecurityConfigurerAdapter</code>（已废弃），而是直接在 <code>@Configuration</code> 类中定义一个或多个 <code>@Bean</code> 方法，返回 <code>SecurityFilterChain</code> 实例。</li>
<li>每个 <code>SecurityFilterChain</code> Bean 都定义了一套独立的、互不干扰的安全规则。这使得我们可以非常灵活地为不同路径（如 <code>/api/**</code> 和 <code>/</code>）配置不同的安全策略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">apiFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .securityMatcher(<span class="string">&quot;/api/**&quot;</span>) <span class="comment">// 这个链只处理 /api/ 开头的请求</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">            .httpBasic(); <span class="comment">// 对 API 使用 HTTP Basic 认证</span></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">webFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/css/**&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            .formLogin(); <span class="comment">// 对其他所有请求使用表单登录</span></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-3-2-核心过滤器概览"><a href="#1-3-2-核心过滤器概览" class="headerlink" title="1.3.2 核心过滤器概览"></a>1.3.2 核心过滤器概览</h4><h5 id="1-SecurityContextHolderFilter"><a href="#1-SecurityContextHolderFilter" class="headerlink" title="1. SecurityContextHolderFilter"></a>1. <code>SecurityContextHolderFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>建立和清理安全上下文（SecurityContext）。</strong> 它是责任链中非常靠前的一个过滤器。</li>
<li><strong>详细说明：</strong><ul>
<li><strong>请求进入时：</strong> 它的主要任务是从 <code>SecurityContextRepository</code> (通常是基于 <code>HttpSession</code>) 中加载 <code>SecurityContext</code>，然后将其设置到 <code>SecurityContextHolder</code> 中。这样，在整个请求处理期间，后续的过滤器、AOP 切面以及你自己的业务代码都能通过 <code>SecurityContextHolder.getContext()</code> 方便地获取到当前用户的认证信息。</li>
<li><strong>请求结束时：</strong> 在 <code>finally</code> 块中，它会清理 <code>SecurityContextHolder</code> 中的内容，防止因线程复用导致的数据泄露。同时，它会将变更后的 <code>SecurityContext</code> 写回 <code>SecurityContextRepository</code>，实现状态持久化。</li>
</ul>
</li>
</ul>
<h5 id="2-CsrfFilter"><a href="#2-CsrfFilter" class="headerlink" title="2. CsrfFilter"></a>2. <code>CsrfFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>防御跨站请求伪造（CSRF）攻击。</strong></li>
<li><strong>详细说明：</strong> 该过滤器会检查所有“状态变更”的请求（如 <code>POST</code>, <code>PUT</code>, <code>DELETE</code>），验证请求中是否包含一个合法、有效的 CSRF 令牌（Token）。如果令牌不存在或不匹配，请求将被直接拒绝。对于 <code>GET</code> 等安全请求，它通常会生成一个新的令牌并附加到响应中，供前端后续使用。</li>
</ul>
<h5 id="3-UsernamePasswordAuthenticationFilter"><a href="#3-UsernamePasswordAuthenticationFilter" class="headerlink" title="3. UsernamePasswordAuthenticationFilter"></a>3. <code>UsernamePasswordAuthenticationFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>处理基于表单的用户名和密码登录请求。</strong> 它是认证（Authentication）过程中的关键角色。</li>
<li><strong>详细说明：</strong> 这个过滤器<strong>只关心特定的登录 URL</strong>（默认为 <code>/login</code> 且为 <code>POST</code> 请求）。当请求匹配时，它会从请求体中提取用户名和密码，将它们封装成一个 <code>UsernamePasswordAuthenticationToken</code>（一个 <code>Authentication</code> 的实现类），然后委托给 <code>AuthenticationManager</code> 去执行真正的认证逻辑。</li>
</ul>
<h5 id="4-BasicAuthenticationFilter"><a href="#4-BasicAuthenticationFilter" class="headerlink" title="4. BasicAuthenticationFilter"></a>4. <code>BasicAuthenticationFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>处理 HTTP Basic 认证。</strong></li>
<li><strong>详细说明：</strong> 它会检查请求头中是否存在 <code>Authorization: Basic &lt;base64-encoded-credentials&gt;</code>。如果存在，它会解码其中的用户名和密码，并同样委托给 <code>AuthenticationManager</code> 进行认证。这是一种无状态的认证方式，常用于 API 接口。</li>
</ul>
<h5 id="5-AuthorizationFilter"><a href="#5-AuthorizationFilter" class="headerlink" title="5. AuthorizationFilter"></a>5. <code>AuthorizationFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>执行授权（Authorization）决策。</strong> 这是访问控制的核心。</li>
<li><strong>详细说明：</strong> 这个过滤器位于认证过滤器之后。当一个请求到达时，它会从 <code>SecurityContextHolder</code> 中获取已经认证成功的 <code>Authentication</code> 对象（包含了用户的角色和权限），然后根据你在配置中定义的访问规则（例如 <code>authorizeHttpRequests().requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)</code>），判断当前用户是否有权限访问请求的资源。如果无权访问，它会抛出 <code>AccessDeniedException</code>。</li>
</ul>
<h5 id="6-ExceptionTranslationFilter"><a href="#6-ExceptionTranslationFilter" class="headerlink" title="6. ExceptionTranslationFilter"></a>6. <code>ExceptionTranslationFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>捕获安全相关的异常并进行“翻译”和处理。</strong> 它是整个安全体系的“异常调度中心”。</li>
<li><strong>详细说明：</strong> 它本身不处理请求，而是使用 <code>try-catch</code> 块包裹了后续的过滤器链调用。<ul>
<li>如果捕获到 <code>AuthenticationException</code>（认证失败，通常意味着用户根本没登录），它会启动认证流程，例如重定向到登录页面。</li>
<li>如果捕获到 <code>AccessDeniedException</code>（授权失败，用户已登录但权限不足），它会委托给 <code>AccessDeniedHandler</code> 进行处理，通常是返回 403 Forbidden 页面或错误信息。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-3-Authentication"><a href="#1-3-3-Authentication" class="headerlink" title="1.3.3 Authentication"></a>1.3.3 <code>Authentication</code></h4><ul>
<li><strong>是什么？</strong><ul>
<li><code>Authentication</code> 是 Spring Security 中代表**“认证信息”**的核心接口。它封装了一个安全请求的所有信息。</li>
</ul>
</li>
<li><strong>职责</strong>：<ul>
<li>回答 <strong>“你是谁？”</strong></li>
<li>在认证<strong>前</strong>，它通常包含用户提交的凭证（如用户名和密码）。</li>
<li>在认证<strong>后</strong>，它包含经过验证的用户主体（Principal）、权限列表，并标记为“已认证”。</li>
</ul>
</li>
<li><strong>核心方法</strong>：<ul>
<li><code>getPrincipal()</code>: 返回用户主体。认证前可能是用户名（一个 <code>String</code>），认证后通常是一个 <code>UserDetails</code> 对象。</li>
<li><code>getCredentials()</code>: 返回用户凭证（如密码）。<strong>认证成功后，框架会自动清空它以策安全</strong>。</li>
<li><code>getAuthorities()</code>: 返回授予用户的权限集合 (<code>Collection&lt;? extends GrantedAuthority&gt;</code>)。</li>
<li><code>isAuthenticated()</code>: 返回一个布尔值，表示此 <code>Authentication</code> 对象是否已经通过了认证。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-4-GrantedAuthority"><a href="#1-3-4-GrantedAuthority" class="headerlink" title="1.3.4 GrantedAuthority"></a>1.3.4 <code>GrantedAuthority</code></h4><ul>
<li><strong>是什么？</strong><ul>
<li><code>GrantedAuthority</code> 是一个接口，代表授予用户主体的**“权限”**。</li>
</ul>
</li>
<li><strong>职责</strong>：<ul>
<li>回答 <strong>“你能做什么？”</strong></li>
<li>它可以是一个角色（如 <code>ROLE_ADMIN</code>），也可以是一个更细粒度的权限（如 <code>user:delete</code>）。Spring Security 默认情况下，如果你的字符串以 <code>ROLE_</code> 开头，它会将其视为一个角色。</li>
</ul>
</li>
<li><strong>核心方法</strong>：<ul>
<li><code>getAuthority()</code>: 返回权限的字符串表示。这个字符串会被 <code>AccessDecisionManager</code>（授权管理器）用来做决策。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-5-UserDetails-UserDetailsService"><a href="#1-3-5-UserDetails-UserDetailsService" class="headerlink" title="1.3.5 UserDetails &amp; UserDetailsService"></a>1.3.5 <code>UserDetails</code> &amp; <code>UserDetailsService</code></h4><p>这两个组件是连接你的**用户数据存储（如数据库）**和 <strong>Spring Security 框架</strong>之间的桥梁。</p>
<ul>
<li><p><strong><code>UserDetails</code></strong> (接口):</p>
<ul>
<li><strong>是什么？</strong> 它是对你的**用户模型（User Model）**在安全层面的一个抽象。它不关心你的用户有多少个字段（如年龄、邮箱），只关心安全相关的核心数据。</li>
<li><strong>职责</strong>：提供框架所需的核心用户信息。</li>
<li><strong>核心方法</strong>：<ul>
<li><code>getUsername()</code>: 用户名。</li>
<li><code>getPassword()</code>: <strong>已编码的</strong>密码。</li>
<li><code>getAuthorities()</code>: 用户的权限集合 (<code>Collection&lt;? extends GrantedAuthority&gt;</code>)。</li>
<li><code>isAccountNonExpired()</code>, <code>isAccountNonLocked()</code>, <code>isCredentialsNonExpired()</code>, <code>isEnabled()</code>: 一系列表示账户状态的方法，用于控制账户是否可用。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>UserDetailsService</code></strong> (接口):</p>
<ul>
<li><strong>是什么？</strong> 这是一个**数据访问对象（DAO）**模式的接口。</li>
<li><strong>职责</strong>：根据一个用户名（<code>String</code>）加载对应的 <code>UserDetails</code> 对象。</li>
<li><strong>核心方法</strong>：<ul>
<li><code>loadUserByUsername(String username)</code>: 这是该接口唯一的方法。你需要实现这个方法，在其中编写从数据库、LDAP或其他来源查询用户数据的逻辑。如果找不到用户，必须抛出 <code>UsernameNotFoundException</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findByUsername(username)</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;User not found: &quot;</span> + username));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-3-6-PasswordEncoder"><a href="#1-3-6-PasswordEncoder" class="headerlink" title="1.3.6 PasswordEncoder"></a>1.3.6 <code>PasswordEncoder</code></h4><ul>
<li><strong>是什么？</strong><ul>
<li>一个用于<strong>密码编码和验证</strong>的服务接口。</li>
</ul>
</li>
<li><strong>职责</strong>：<ul>
<li><code>encode(CharSequence rawPassword)</code>: 将原始明文密码进行单向加密（哈希），生成一个安全的密码摘要。</li>
<li><code>matches(CharSequence rawPassword, String encodedPassword)</code>: 比较用户提交的原始密码和数据库中存储的已编码密码是否匹配。它会自动处理盐（salt）的提取和比对。</li>
</ul>
</li>
<li><strong>安全存储密码的基石</strong>：<ul>
<li><strong>绝对不能</strong>在数据库中存储明文密码！</li>
<li><code>PasswordEncoder</code> 使用<strong>单向哈希算法</strong>（如 BCrypt, SCrypt, Argon2），这意味着无法从加密后的字符串反推出原始密码。</li>
<li>它还自动包含了**“加盐（Salting）”**机制，即使两个用户设置了相同的密码，他们在数据库中存储的哈希值也是不同的，有效防止了彩虹表攻击。</li>
<li><strong>推荐使用</strong>：<code>BCryptPasswordEncoder</code> 是目前最常用和推荐的选择。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-7-SecurityContext-SecurityContextHolder"><a href="#1-3-7-SecurityContext-SecurityContextHolder" class="headerlink" title="1.3.7 SecurityContext &amp; SecurityContextHolder"></a>1.3.7 <code>SecurityContext</code> &amp; <code>SecurityContextHolder</code></h4><ul>
<li><strong><code>SecurityContext</code></strong> (接口):<ul>
<li><strong>是什么？</strong> 安全上下文。它本身非常简单，主要职责就是<strong>持有 <code>Authentication</code> 对象</strong>。</li>
<li><strong>核心方法</strong>:<ul>
<li><code>getAuthentication()</code>: 获取认证信息。</li>
<li><code>setAuthentication(Authentication authentication)</code>: 设置认证信息。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>SecurityContextHolder</code></strong> (类):<ul>
<li><strong>是什么？</strong> 一个工具类，用于<strong>存储、访问和管理</strong> <code>SecurityContext</code>。它是外界与当前请求的安全信息交互的<strong>唯一入口</strong>。</li>
<li><strong>职责</strong>：将 <code>SecurityContext</code> 与当前执行线程关联起来。</li>
<li><strong>工作模式</strong>:<ul>
<li>默认使用 <code>ThreadLocal</code> 策略。这意味着 <code>SecurityContext</code> 的生命周期与一个请求线程绑定。当请求开始时，过滤器链会准备好 <code>SecurityContext</code>；请求结束时，<code>SecurityContextHolder</code> 会被清空。这保证了不同请求之间的安全信息是隔离的。</li>
</ul>
</li>
<li><strong>如何使用</strong>:<ul>
<li>在应用的任何地方，你都可以通过静态方法 <code>SecurityContextHolder.getContext().getAuthentication()</code> 来获取当前登录用户的 <code>Authentication</code> 对象，进而得到用户名、权限等信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-第一个-Spring-Security-应用（”Hello-Security”）"><a href="#1-4-第一个-Spring-Security-应用（”Hello-Security”）" class="headerlink" title="1.4 第一个 Spring Security 应用（”Hello Security”）"></a>1.4 第一个 Spring Security 应用（”Hello Security”）</h3><ul>
<li>依赖引入 (<code>spring-boot-starter-security</code>)</li>
<li>默认的安全配置与自动生成的登录页</li>
<li>最简 Java 配置 (<code>@Configuration</code> &amp; <code>@Bean SecurityFilterChain</code>)</li>
</ul>
<p>这一节的目标是快速搭建一个最基础的 Spring Boot 项目，并引入 Spring Security，观察它在“零配置”下的默认行为，然后通过最简单的 Java 配置对其进行自定义。</p>
<h4 id="第一步：创建-Spring-Boot-项目"><a href="#第一步：创建-Spring-Boot-项目" class="headerlink" title="第一步：创建 Spring Boot 项目"></a>第一步：创建 Spring Boot 项目</h4><p><strong>项目设置:</strong></p>
<ul>
<li><strong>Project</strong>: Maven Project (或 Gradle)</li>
<li><strong>Language</strong>: Java</li>
<li><strong>Spring Boot</strong>: 推荐选择一个稳定的新版本 (如 3.1.x 或更高)</li>
<li><strong>Project Metadata</strong>:<ul>
<li><strong>Group</strong>: <code>com.example</code></li>
<li><strong>Artifact</strong>: <code>hello-security</code></li>
<li><strong>Packaging</strong>: Jar</li>
<li><strong>Java</strong>: 17 (或更高)</li>
</ul>
</li>
</ul>
<p><strong>添加依赖 (Dependencies):</strong></p>
<ol>
<li><strong>Spring Web</strong>: 用于构建 Web 应用，提供 MVC 功能。</li>
<li><strong>Spring Security</strong>: 这是我们的主角，引入安全功能。</li>
<li><strong>(可选) Thymeleaf</strong>: 一个模板引擎，方便我们创建一个简单的页面来测试。</li>
</ol>
<hr>
<h4 id="第二步：创建一个简单的-Controller"><a href="#第二步：创建一个简单的-Controller" class="headerlink" title="第二步：创建一个简单的 Controller"></a>第二步：创建一个简单的 Controller</h4><p>为了测试安全保护，我们需要创建一个简单的 REST Controller，它有一个公共访问的首页和一个需要保护的页面。</p>
<p>在 <code>src/main/java/com/example/hellosecurity</code> 包下创建一个 <code>HomeController.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;&lt;p&gt;This page is public.&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dashboard&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dashboard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;Welcome to your Dashboard!&lt;/h1&gt;&lt;p&gt;This page is protected.&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="第三步：启动并观察默认行为"><a href="#第三步：启动并观察默认行为" class="headerlink" title="第三步：启动并观察默认行为"></a>第三步：启动并观察默认行为</h4><p>现在，<strong>不要做任何额外的配置</strong>，直接运行 <code>HelloSecurityApplication</code> 类来启动项目。</p>
<p><strong>你会发现：</strong></p>
<ol>
<li><p><strong>控制台输出密码</strong>：<br>在应用启动的日志中，你会看到一行类似这样的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using generated security password: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</span><br></pre></td></tr></table></figure>

<p>这是 Spring Security 见你没有配置任何用户，为了方便开发，自动为你生成了一个用户名为 <code>user</code>，密码为这一长串随机字符串的用户。</p>
</li>
<li><p><strong>访问受保护的页面</strong>：<br>打开浏览器，访问 <code>http://localhost:8080/dashboard</code>。<br>你不会看到 “Welcome to your Dashboard!”，而是会被<strong>重定向</strong>到一个由 Spring Security 自动生成的登录页面（<code>http://localhost:8080/login</code>）。</p>
</li>
<li><p><strong>尝试登录</strong>：</p>
<ul>
<li><strong>用户名</strong>: <code>user</code></li>
<li><strong>密码</strong>: 从控制台日志中复制那一长串随机密码。</li>
<li>点击登录后，你会被成功重定向到 <code>/dashboard</code> 页面，并看到我们预期的内容。</li>
</ul>
</li>
<li><p><strong>访问公共页面</strong>：<br>现在，即使你没有登录，访问 <code>http://localhost:8080/</code>。你会发现这个页面可以正常访问。这是因为 Spring Security 的默认策略通常会放行根路径和一些静态资源。</p>
</li>
</ol>
<p><strong>结论</strong>：仅仅通过引入 <code>spring-boot-starter-security</code> 依赖，Spring Security 就已经自动为我们的应用提供了以下功能：</p>
<ul>
<li><strong>保护所有端点</strong>：默认情况下，除了少数例外，所有请求都需要认证。</li>
<li><strong>生成登录表单</strong>：提供了一个基础的、功能完备的登录页面。</li>
<li><strong>默认用户</strong>：创建了一个内存中的用户以供测试。</li>
<li><strong>基础安全防护</strong>：CSRF 保护、HTTP Header 安全设置等都已经默认开启。</li>
</ul>
<hr>
<h4 id="第四步：进行最简-Java-配置"><a href="#第四步：进行最简-Java-配置" class="headerlink" title="第四步：进行最简 Java 配置"></a>第四步：进行最简 Java 配置</h4><p>自动生成的密码非常不方便。现在，让我们通过最简单的 Java 配置来自定义安全行为。</p>
<ol>
<li><p><strong>创建配置类</strong>:<br>在 <code>com.example.hellosecurity</code> 包下创建一个 <code>SecurityConfig.java</code> 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean 1: 定义一个密码编码器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 BCrypt 强哈希函数进行加密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean 2: 定义用户信息服务 (UserDetailsService)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个基于内存的用户信息管理器</span></span><br><span class="line">        <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个用户，密码必须经过 passwordEncoder 加密</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;password&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        </span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">admin</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;password&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        manager.createUser(user);</span><br><span class="line">        manager.createUser(admin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean 3: 定义安全过滤器链 (SecurityFilterChain)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/dashboard&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// /dashboard 只有 ADMIN 角色可以访问</span></span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>).permitAll() <span class="comment">// 首页与登陆页允许所有用户访问</span></span><br><span class="line">                        .anyRequest().authenticated() <span class="comment">// 其他所有请求都需要认证</span></span><br><span class="line">                )</span><br><span class="line">            	<span class="comment">// 启用基于表单的登录认证功能</span></span><br><span class="line">                .formLogin(</span><br><span class="line">        			<span class="comment">// 下面这行的 permitAll 是让Spring Security知道</span></span><br><span class="line">                    <span class="comment">// formLogin() 这个机制本身是开放的，但它不会影响</span></span><br><span class="line">                    <span class="comment">// authorizeHttpRequests 对 /login URL 的访问控制。</span></span><br><span class="line">                    <span class="comment">// 这就是为什么你必须在 authorizeHttpRequests 中也进行配置。    	</span></span><br><span class="line">		            AbstractAuthenticationFilterConfigurer::permitAll</span><br><span class="line">                )</span><br><span class="line">                .logout(logout -&gt; logout</span><br><span class="line">                        .logoutSuccessUrl(<span class="string">&quot;/&quot;</span>) <span class="comment">// 注销成功后重定向到首页</span></span><br><span class="line">                );</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>配置解读</strong>：</p>
<ol>
<li><strong><code>passwordEncoder()</code></strong>:<ul>
<li>我们声明了一个 <code>PasswordEncoder</code> 的 Bean。这是现代 Spring Security 强制要求的。</li>
<li>我们选择了 <code>BCryptPasswordEncoder</code>，这是一个非常安全和推荐的密码哈希算法。</li>
</ul>
</li>
<li><strong><code>userDetailsService()</code></strong>:<ul>
<li>我们定义了一个 <code>UserDetailsService</code> Bean 来告诉 Spring Security 如何获取用户信息。</li>
<li>这里我们使用了 <code>InMemoryUserDetailsManager</code>，它在内存中创建用户，非常适合演示和测试。</li>
<li><strong>关键点</strong>：<code>User.withUsername(...)</code> 构建用户时，<code>.password()</code> 方法接收的<strong>必须是经过加密后的密码</strong>。所以我们调用了 <code>passwordEncoder().encode(&quot;password&quot;)</code>。</li>
</ul>
</li>
<li><strong><code>filterChain(HttpSecurity http)</code></strong>:<ul>
<li>这是安全配置的核心。我们通过 <code>HttpSecurity</code> 对象来构建一个 <code>SecurityFilterChain</code>。</li>
<li><code>.authorizeHttpRequests(...)</code> 定义了<strong>授权规则</strong>：<ul>
<li><code>/dashboard</code> 路径需要 “ADMIN” 角色。</li>
<li><code>/</code> 根路径与<code>/login</code>登陆路径允许所有人访问 (<code>permitAll</code>)。</li>
<li>其他任何请求 (<code>anyRequest()</code>) 都必须经过认证 (<code>authenticated()</code>)。</li>
</ul>
</li>
<li><code>.formLogin(...)</code> 配置了表单登录。</li>
<li><code>.logout(...)</code> 配置了注销功能。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="第五步：再次测试"><a href="#第五步：再次测试" class="headerlink" title="第五步：再次测试"></a>第五步：再次测试</h4><ol>
<li><strong>重新启动应用</strong>。这次控制台不会再打印随机密码了。</li>
<li><strong>访问 <code>http://localhost:8080/dashboard</code></strong>。你依然会被重定向到登录页。</li>
<li><strong>使用 <code>user</code> &#x2F; <code>password</code> 登录</strong>。你会发现登录后看到一个 <strong>403 Forbidden</strong> 错误页面。这是因为我们配置了 <code>/dashboard</code> 需要 <code>ADMIN</code> 角色，而 <code>user</code> 用户只有 <code>USER</code> 角色。</li>
<li><strong>注销</strong>（可以直接访问 <code>/logout</code>），然后<strong>使用 <code>admin</code> &#x2F; <code>password</code> 登录</strong>。这次你就能成功访问 <code>/dashboard</code> 了。</li>
<li><strong>访问 <code>http://localhost:8080/</code></strong>。无论你是否登录，这个页面始终可以访问。</li>
</ol>
<hr>
<h2 id="2-认证（Authentication）"><a href="#2-认证（Authentication）" class="headerlink" title="2. 认证（Authentication）"></a>2. 认证（Authentication）</h2><h3 id="2-1-认证流程详解（重点）"><a href="#2-1-认证流程详解（重点）" class="headerlink" title="2.1 认证流程详解（重点）"></a>2.1 认证流程详解（重点）</h3><p>当用户在登录页面输入用户名和密码，点击“登录”按钮后，Spring Security 内部发生了一系列精妙的协作。我们将以最常见的<strong>基于表单的认证 (Form Login)</strong> 为例，一步步拆解这个流程。</p>
<h4 id="2-1-1-宏观流程图"><a href="#2-1-1-宏观流程图" class="headerlink" title="2.1.1 宏观流程图"></a>2.1.1 宏观流程图</h4><pre><code class="highlight mermaid">graph LR
    subgraph &quot;SecurityFilterChain&quot;
        A[...一系列其他过滤器...&lt;br&gt;CsrfFilter, CorsFilter等]
        B[认证过滤器&lt;br&gt;UsernamePassword&lt;br&gt;AuthenticationFilter]
        C[创建未认证的&lt;br&gt;Authentication对象]
        D[调用 AuthenticationManager]
        E[AuthenticationProvider&lt;br&gt;处理认证逻辑]
        F[调用 UserDetailsService&lt;br&gt;加载用户信息]
        G[PasswordEncoder&lt;br&gt;比对密码]
        H[返回已认证的&lt;br&gt;Authentication对象]
        I[存入 SecurityContextHolder&lt;br&gt;与当前线程绑定]
    end
    A--&gt;B
    B--&gt;C
    C--&gt;|传递token对象|D
    D--&gt;|遍历管理的Provider&lt;br&gt;查看是否支持此token|E
    E--&gt;F
    F--&gt;G
    G--&gt;H
    H--&gt;I</code></pre>



<hr>
<h4 id="2-1-2-详细步骤分解"><a href="#2-1-2-详细步骤分解" class="headerlink" title="2.1.2 详细步骤分解"></a>2.1.2 详细步骤分解</h4><h5 id="第-1-步-UsernamePasswordAuthenticationFilter-拦截请求"><a href="#第-1-步-UsernamePasswordAuthenticationFilter-拦截请求" class="headerlink" title="第 1 步: UsernamePasswordAuthenticationFilter 拦截请求"></a>第 1 步: <code>UsernamePasswordAuthenticationFilter</code> 拦截请求</h5><ul>
<li><strong>触发条件</strong>: 当一个 <code>POST</code> 请求发送到 <code>/login</code> (这是默认的登录URL，可以配置) 时，这个过滤器会被激活。</li>
<li><strong>核心工作</strong>:<ol>
<li><strong>判断是否为登录请求</strong>: 它会检查请求的 URL 和 HTTP 方法是否匹配它所配置的登录请求。</li>
<li><strong>提取凭证</strong>: 如果匹配，它会从 <code>HttpServletRequest</code> 的参数中提取用户名 (默认参数名 <code>username</code>) 和密码 (默认参数名 <code>password</code>)。</li>
<li><strong>封装 Token</strong>: 它将提取出的用户名和密码封装成一个 <code>UsernamePasswordAuthenticationToken</code> 对象。这是一个 <code>Authentication</code> 接口的实现类。<ul>
<li><strong>关键点</strong>: 此时创建的这个 Token 是 <strong>“未认证” (unauthenticated)</strong> 的。我们可以通过 <code>token.isAuthenticated()</code> 返回 <code>false</code> 来判断。它的 <code>authorities</code> 列表也是空的。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5 id="第-2-步-调用-AuthenticationManager"><a href="#第-2-步-调用-AuthenticationManager" class="headerlink" title="第 2 步: 调用 AuthenticationManager"></a>第 2 步: 调用 <code>AuthenticationManager</code></h5><ul>
<li><code>UsernamePasswordAuthenticationFilter</code> 自身并不执行真正的认证逻辑。它遵循**“委托模式”**，将认证的重任交给了 <code>AuthenticationManager</code>。</li>
<li>它调用 <code>authenticationManager.authenticate(token)</code> 方法，将上一步创建的<strong>未认证 Token</strong> 传进去。</li>
</ul>
<hr>
<h5 id="第-3-步-第-4-步-AuthenticationManager-的实现-ProviderManager"><a href="#第-3-步-第-4-步-AuthenticationManager-的实现-ProviderManager" class="headerlink" title="第 3 步 &amp; 第 4 步: AuthenticationManager 的实现 ProviderManager"></a>第 3 步 &amp; 第 4 步: <code>AuthenticationManager</code> 的实现 <code>ProviderManager</code></h5><ul>
<li><code>AuthenticationManager</code> 是一个接口，它只有一个 <code>authenticate</code> 方法。</li>
<li>在 Spring Security 中，它最常用的实现类是 <code>ProviderManager</code>。</li>
<li><code>ProviderManager</code> 的作用像一个**“认证委托总管”**。它内部维护了一个 <code>AuthenticationProvider</code> 的列表。</li>
<li>当 <code>ProviderManager</code> 收到 <code>authenticate</code> 请求时，它会<strong>遍历</strong>自己管理的所有 <code>AuthenticationProvider</code>，并询问每一个 Provider：“你能处理这种类型的 <code>Authentication</code> Token 吗？” (通过调用 <code>provider.supports(token.getClass())</code>)。</li>
</ul>
<hr>
<h5 id="第-5-步-AuthenticationProvider-执行核心认证"><a href="#第-5-步-AuthenticationProvider-执行核心认证" class="headerlink" title="第 5 步: AuthenticationProvider 执行核心认证"></a>第 5 步: <code>AuthenticationProvider</code> 执行核心认证</h5><ul>
<li>如果某个 <code>AuthenticationProvider</code> (例如，处理用户名密码的 <code>DaoAuthenticationProvider</code>) 返回 <code>true</code>，表示它可以处理，<code>ProviderManager</code> 就会调用它的 <code>authenticate(token)</code> 方法。</li>
<li><strong><code>DaoAuthenticationProvider</code> 是核心中的核心，它的工作流程如下</strong>:<ol>
<li><strong>获取用户名</strong>: 从传入的<strong>未认证 Token</strong> 中获取用户名。</li>
<li><strong>加载用户信息 (第 6、7 步)</strong>: 调用它所配置的 <code>UserDetailsService</code> 的 <code>loadUserByUsername(username)</code> 方法，去数据库 (或其他数据源) 中查找用户。<ul>
<li>如果找不到用户，<code>UserDetailsService</code> 会抛出 <code>UsernameNotFoundException</code>，认证失败。</li>
<li>如果找到了，会返回一个包含了用户所有信息（包括<strong>加密后的密码</strong>和<strong>权限列表</strong>）的 <code>UserDetails</code> 对象。</li>
</ul>
</li>
<li><strong>密码校验 (第 8 步)</strong>: 调用它所配置的 <code>PasswordEncoder</code> 的 <code>matches(rawPassword, encodedPassword)</code> 方法。<ul>
<li><code>rawPassword</code>: 来自用户提交的、<strong>未认证 Token</strong> 中的明文密码。</li>
<li><code>encodedPassword</code>: 来自上一步从数据库加载的 <code>UserDetails</code> 对象中的<strong>加密密码</strong>。</li>
<li>如果 <code>matches</code> 返回 <code>false</code>，则抛出 <code>BadCredentialsException</code>，认证失败。</li>
</ul>
</li>
<li><strong>检查账户状态</strong>: 检查从 <code>UserDetails</code> 中获取的账户状态（如 <code>isAccountNonLocked()</code>, <code>isEnabled()</code> 等）。如果账户状态异常（如被锁定、已过期），则抛出相应的异常，认证失败。</li>
<li><strong>认证成功，构建新 Token (第 9 步)</strong>: 如果所有检查都通过，<code>DaoAuthenticationProvider</code> 会创建一个<strong>新的</strong> <code>UsernamePasswordAuthenticationToken</code>。<ul>
<li><strong>这个新的 Token 是“已认证” (authenticated) 的</strong>。</li>
<li>它的 <code>principal</code> 是从数据库加载的 <code>UserDetails</code> 对象。</li>
<li>它的 <code>credentials</code> (密码) 会被<strong>清空 (设置为 null)</strong>，防止敏感信息泄露。</li>
<li>它的 <code>authorities</code> 列表会用 <code>UserDetails</code> 中的权限信息来填充。</li>
<li>最后，它将这个<strong>已认证的 Token</strong> 返回给 <code>ProviderManager</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5 id="第-10-步-返回认证结果"><a href="#第-10-步-返回认证结果" class="headerlink" title="第 10 步: 返回认证结果"></a>第 10 步: 返回认证结果</h5><ul>
<li><code>ProviderManager</code> 接收到 <code>DaoAuthenticationProvider</code> 返回的<strong>已认证 Token</strong>，然后将其原路返回给最初的调用者——<code>UsernamePasswordAuthenticationFilter</code>。</li>
<li>如果在此过程中任何一个 <code>AuthenticationProvider</code> 抛出了 <code>AuthenticationException</code>（认证异常），<code>ProviderManager</code> 会捕获它，并最终将异常传递回 Filter。</li>
</ul>
<hr>
<h5 id="第-11-步-第-12-步-后续处理"><a href="#第-11-步-第-12-步-后续处理" class="headerlink" title="第 11 步 &amp; 第 12 步: 后续处理"></a>第 11 步 &amp; 第 12 步: 后续处理</h5><p><code>UsernamePasswordAuthenticationFilter</code> 接收到 <code>AuthenticationManager</code> 返回的结果后，会进行如下操作：</p>
<ul>
<li><strong>如果认证成功 (返回了已认证的 <code>Authentication</code> 对象)</strong>:<ol>
<li><strong>更新安全上下文</strong>: 调用 <code>SecurityContextHolder.getContext().setAuthentication(authenticatedToken)</code>，将这个<strong>已认证的 Token</strong> 放入 <code>SecurityContext</code> 中。至此，当前用户就在本次请求的后续处理以及未来的请求中（通过 Session）被认为是已登录状态了。</li>
<li><strong>触发成功处理器</strong>: 调用 <code>AuthenticationSuccessHandler</code>。默认的处理器会将用户重定向到他们访问的原始页面，或者是一个配置好的默认成功页面。</li>
<li><strong>(可选) 触发 Remember-Me</strong>: 如果配置了“记住我”功能，此时也会生成相应的 cookie。</li>
</ol>
</li>
<li><strong>如果认证失败 (抛出了 <code>AuthenticationException</code>)</strong>:<ol>
<li><strong>清空安全上下文</strong>: <code>SecurityContextHolder.clearContext()</code>，确保没有任何残留的认证信息。</li>
<li><strong>触发失败处理器</strong>: 调用 <code>AuthenticationFailureHandler</code>。默认的处理器会将用户重定向回登录页面，并附带一个错误参数（如 <code>/login?error</code>）。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-2-UserDetailsService-自定义实现"><a href="#2-2-UserDetailsService-自定义实现" class="headerlink" title="2.2 UserDetailsService 自定义实现"></a>2.2 <code>UserDetailsService</code> 自定义实现</h3><p>在 <code>1.4 Hello Security</code> 示例中，我们使用了 <code>InMemoryUserDetailsManager</code> 来在内存中创建用户。这对于测试和快速原型开发非常方便，但在真实的应用中，用户信息几乎总是存储在数据库、LDAP或其他持久化存储中。</p>
<p><code>UserDetailsService</code> 接口就是 Spring Security 提供的、用于连接这些<strong>外部用户数据源</strong>的标准化桥梁。我们的任务就是提供一个该接口的实现类，告诉 Spring Security：“嘿，当需要用户信息时，调用我的这个类，我会去数据库里帮你查！”</p>
<h4 id="2-2-1-为什么需要自定义？"><a href="#2-2-1-为什么需要自定义？" class="headerlink" title="2.2.1 为什么需要自定义？"></a>2.2.1 为什么需要自定义？</h4><ul>
<li><strong>对接真实数据</strong>: 将 Spring Security 的认证机制与你的用户表（或其他用户存储）集成。</li>
<li><strong>灵活的用户模型</strong>: 你的用户实体（<code>User</code> Entity）可能包含很多业务字段（如昵称、邮箱、注册时间等），而 <code>UserDetails</code> 接口只关心安全相关的核心字段。自定义实现可以完成从你的实体到 <code>UserDetails</code> 的转换。</li>
<li><strong>复杂的权限模型</strong>: 你的权限可能存储在多个关联表中（用户-角色表，角色-权限表）。自定义实现可以在加载用户时，一并查询并组装这些复杂的权限信息。</li>
</ul>
<hr>
<h4 id="2-2-2-实现步骤-以-MP-为例"><a href="#2-2-2-实现步骤-以-MP-为例" class="headerlink" title="2.2.2 实现步骤 (以 MP 为例)"></a>2.2.2 实现步骤 (以 MP 为例)</h4><p>假设我们有一个基于 MybatisPlus 的项目，包含以下实体：</p>
<p><strong>1. 用户实体 (<code>User</code> Entity)</strong></p>
<p>这代表了我们数据库中的 <code>users</code> 表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 用户DAO (<code>UserMapper</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-创建-UserDetailsService-的实现类"><a href="#3-创建-UserDetailsService-的实现类" class="headerlink" title="3. 创建 UserDetailsService 的实现类"></a>3. 创建 <code>UserDetailsService</code> 的实现类</h5><p>这是最核心的一步。我们创建一个 Service 类，实现 <code>UserDetailsService</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;loadUserByUsername: &#123;&#125;&quot;</span>, username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper</span><br><span class="line">                .selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;()</span><br><span class="line">                        .eq(User::getUsername, username));</span><br><span class="line">        Optional.ofNullable(user).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.core.userdetails.User(</span><br><span class="line">                user.getUsername(),</span><br><span class="line">                user.getPassword(),</span><br><span class="line">                <span class="literal">true</span>,   <span class="comment">// enabled</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// accountNonExpired</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// credentialsNonExpired</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// accountNonLocked</span></span><br><span class="line">                Collections.emptyList() <span class="comment">// 权限列表</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>@Service</code>: 将 <code>MyUserDetailsService</code> 注册为一个 Spring Bean，这样 Spring Security 就能自动发现并使用它。</li>
<li><code>@RequiredArgsConstructor</code>: 注入我们之前创建的 <code>UserMapper</code>。</li>
<li><code>loadUserByUsername(String username)</code>: 这是接口要求我们必须实现的方法。<ol>
<li>我们调用 <code>userMapper.selectOne(new LambdaQueryWrapper&lt;User&gt;().eq(User::getUsername, username))</code>。</li>
<li>如果找不到用户 (<code>Optional</code> 为空)，<strong>必须</strong>抛出 <code>UsernameNotFoundException</code>。这是 Spring Security 的契约，它会捕获这个异常并将其转换为一个认证失败的消息。<strong>切勿返回 <code>null</code></strong>。</li>
<li>如果找到了用户，我们需要返回一个 <code>UserDetails</code> 接口的实例。这里我们使用了 <code>org.springframework.security.core.userdetails.User</code> 这个内置的实现类，它非常方便。我们把从数据库查出的用户名、<strong>已加密的密码</strong>、账户状态等信息填充进去。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-2-3-进阶：加载角色和权限"><a href="#2-2-3-进阶：加载角色和权限" class="headerlink" title="2.2.3 进阶：加载角色和权限"></a>2.2.3 进阶：加载角色和权限</h4><p>通常，我们的权限模型会更复杂，比如用户有关联的角色。</p>
<h5 id="1-扩展实体"><a href="#1-扩展实体" class="headerlink" title="1. 扩展实体"></a>1. 扩展实体</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java (添加角色关系)</span></span><br><span class="line"><span class="keyword">private</span> String role;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-更新-UserDetailsService"><a href="#2-更新-UserDetailsService" class="headerlink" title="2. 更新 UserDetailsService"></a>2. 更新 <code>UserDetailsService</code></h5><p>现在，我们需要在加载用户时，将用户的 <code>Role</code> 集合转换为 <code>GrantedAuthority</code> 集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;loadUserByUsername: &#123;&#125;&quot;</span>, username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper</span><br><span class="line">                .selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;()</span><br><span class="line">                        .eq(User::getUsername, username));</span><br><span class="line">        Optional.ofNullable(user).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = Collections.singleton(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(user.getRole()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.core.userdetails.User(</span><br><span class="line">                user.getUsername(),</span><br><span class="line">                user.getPassword(),</span><br><span class="line">                <span class="literal">true</span>,   <span class="comment">// enabled</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// accountNonExpired</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// credentialsNonExpired</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// accountNonLocked</span></span><br><span class="line">                authorities <span class="comment">// 权限列表</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li>我们从 <code>user</code> 对象中获取 <code>role</code> 。</li>
<li>创建一个只包含单个元素的不可变集合(<code>Collections.singleton</code>),将用户角色转换为 Spring Security 能识别的权限对象,放入不可变集合中。<code>SimpleGrantedAuthority</code> 是 <code>GrantedAuthority</code> 接口最常用的实现类，它接收一个代表权限的字符串（例如，<code>&quot;ROLE_ADMIN&quot;</code>）。</li>
</ul>
<hr>
<h4 id="2-2-4-自定义-UserDetails-实现类-可选，但推荐"><a href="#2-2-4-自定义-UserDetails-实现类-可选，但推荐" class="headerlink" title="2.2.4 自定义 UserDetails 实现类 (可选，但推荐)"></a>2.2.4 自定义 <code>UserDetails</code> 实现类 (可选，但推荐)</h4><p>直接使用 <code>org.springframework.security.core.userdetails.User</code> 很方便，但有时我们希望在 <code>UserDetails</code> 对象中携带更多自定义信息（比如用户ID、昵称），或者让我们的 <code>User</code> 实体本身就具备安全用户的能力。</p>
<p>创建一个独立的类实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetails</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyUserDetails</span><span class="params">(Long id, String username, String password, String role)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.role = role;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(role));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDetails.<span class="built_in">super</span>.isAccountNonExpired();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDetails.<span class="built_in">super</span>.isAccountNonLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDetails.<span class="built_in">super</span>.isCredentialsNonExpired();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDetails.<span class="built_in">super</span>.isEnabled();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这样做的好处</strong>:</p>
<ul>
<li><strong>代码更简洁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;loadUserByUsername: &#123;&#125;&quot;</span>, username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper</span><br><span class="line">                .selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;()</span><br><span class="line">                        .eq(User::getUsername, username));</span><br><span class="line">        Optional.ofNullable(user).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyUserDetails</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>信息更丰富</strong>: <code>Authentication</code> 对象的 <code>getPrincipal()</code> 方法将返回我们完整的 <code>User</code> 实体，你可以在业务代码中方便地获取用户ID、邮箱等任何信息。</li>
</ul>
<hr>
<h3 id="2-3-PasswordEncoder-的选择与使用"><a href="#2-3-PasswordEncoder-的选择与使用" class="headerlink" title="2.3 PasswordEncoder 的选择与使用"></a>2.3 <code>PasswordEncoder</code> 的选择与使用</h3><p><code>PasswordEncoder</code> 是 Spring Security 提供的一个核心服务接口，专门用于处理密码的<strong>单向加密（哈希）和 验证</strong>。在现代 Web 应用中，直接存储用户明文密码是绝对禁止的严重安全漏洞。</p>
<h4 id="2-3-1-为什么不能明文存储密码？"><a href="#2-3-1-为什么不能明文存储密码？" class="headerlink" title="2.3.1 为什么不能明文存储密码？"></a>2.3.1 为什么不能明文存储密码？</h4><ol>
<li><strong>数据库泄露风险</strong>：如果你的数据库被黑客拖库（整个数据库被盗走），所有用户的密码将瞬间暴露无遗。攻击者可以利用这些密码尝试登录用户的其他网站账户（因为很多用户习惯在不同网站使用相同密码），造成巨大损失。</li>
<li><strong>内部人员风险</strong>：能够接触到数据库的内部员工（DBA、运维、开发人员）可以看到所有用户的密码，这带来了极大的隐私和安全风险。</li>
<li><strong>违反合规性要求</strong>：许多数据保护法规（如 GDPR）明确要求对敏感个人数据进行加密保护，明文存储密码是违规行为。</li>
</ol>
<hr>
<h4 id="2-3-2-什么是安全的密码存储？——-自适应单向函数"><a href="#2-3-2-什么是安全的密码存储？——-自适应单向函数" class="headerlink" title="2.3.2 什么是安全的密码存储？—— 自适应单向函数"></a>2.3.2 什么是安全的密码存储？—— 自适应单向函数</h4><p>一个安全的密码存储方案，不仅仅是做一次简单的哈希（如 MD5 或 SHA-1），而是需要使用<strong>自适应单向函数 (Adaptive One-way Function)</strong>。这类函数有几个关键特性：</p>
<ol>
<li><strong>单向性 (One-way)</strong>：从原始密码计算出哈希值非常容易，但从哈希值反推出原始密码在计算上是不可行的。MD5 和 SHA 系列都具备此特性。</li>
<li><strong>加盐 (Salting)</strong>：在对密码进行哈希计算之前，会为每个密码自动生成一个随机的字符串（称为“盐”），并将其与密码结合在一起。<ul>
<li><strong>作用</strong>：即使两个用户设置了完全相同的密码（如 “123456”），由于他们的“盐”是不同的，最终存储在数据库中的哈希值也是完全不同的。这有效抵御了<strong>彩虹表攻击 (Rainbow Table Attack)</strong>。</li>
</ul>
</li>
<li><strong>慢速与可配置的工作因子 (Slow &amp; Configurable Work Factor)</strong>：这类算法被设计成<strong>计算密集型</strong>的，即计算一次哈希需要消耗相对较多的 CPU 或内存资源。<ul>
<li><strong>作用</strong>：这极大地增加了<strong>暴力破解 (Brute-force Attack)</strong> 的成本。攻击者即使拿到了数据库，也无法在短时间内尝试大量的密码组合。</li>
<li><strong>自适应</strong>：随着计算机硬件性能的提升，我们可以通过调整<strong>工作因子（Work Factor）</strong>（也叫成本、迭代次数）来增加计算的耗时，使得破解成本始终保持在一个非常高的水平。</li>
</ul>
</li>
</ol>
<p><strong>已经被淘汰的算法</strong>：</p>
<ul>
<li><strong>MD5, SHA-1, SHA-256</strong>: 这些是快速哈希算法，不包含加盐和慢速特性，非常容易被现代硬件暴力破解，<strong>绝对不能</strong>用于存储密码。</li>
</ul>
<hr>
<h4 id="2-3-3-Spring-Security-提供的-PasswordEncoder-实现"><a href="#2-3-3-Spring-Security-提供的-PasswordEncoder-实现" class="headerlink" title="2.3.3 Spring Security 提供的 PasswordEncoder 实现"></a>2.3.3 Spring Security 提供的 <code>PasswordEncoder</code> 实现</h4><p>Spring Security 提供了一系列实现了上述安全特性的 <code>PasswordEncoder</code>，封装在 <code>spring-security-crypto</code> 模块中。</p>
<table>
<thead>
<tr>
<th>编码器</th>
<th>算法</th>
<th>特点</th>
<th>推荐度</th>
</tr>
</thead>
<tbody><tr>
<td><code>BCryptPasswordEncoder</code></td>
<td>BCrypt</td>
<td><strong>业界标准，最广泛使用</strong>。基于 Blowfish 加密算法，计算密集。工作因子可调（强度，默认为10）。</td>
<td><strong>强烈推荐 (默认首选)</strong></td>
</tr>
<tr>
<td><code>SCryptPasswordEncoder</code></td>
<td>SCrypt</td>
<td><strong>内存消耗型</strong>。除了 CPU 成本，还要求大量的内存，使其更难被 GPU 或 ASIC 硬件并行破解。</td>
<td><strong>推荐</strong> (比 BCrypt 更安全，但需要更多内存)</td>
</tr>
<tr>
<td><code>Argon2PasswordEncoder</code></td>
<td>Argon2</td>
<td><strong>密码哈希竞赛冠军</strong>。现代、安全，同时对抗 CPU、GPU 和内存攻击。是未来的趋势。</td>
<td><strong>推荐</strong> (最安全的选择之一，需要 Bouncy Castle 依赖)</td>
</tr>
<tr>
<td><code>Pbkdf2PasswordEncoder</code></td>
<td>PBKDF2</td>
<td>一个较老的标准，安全性不如前三者，但仍可接受。</td>
<td>不推荐在新项目中使用，除非有兼容性要求。</td>
</tr>
</tbody></table>
<p><strong><code>DelegatingPasswordEncoder</code></strong>:</p>
<p>这是一个特殊的“代理”编码器，也是 Spring Security <strong>默认</strong>使用的。它的设计目标是为了<strong>平滑地升级密码存储策略</strong>。</p>
<ul>
<li><strong>工作原理</strong>：它生成的哈希值会带有一个<strong>前缀</strong>，用于标识该密码是使用哪种算法加密的。例如：<ul>
<li><code>{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1j...</code></li>
<li><code>{argon2}$...</code></li>
</ul>
</li>
<li><strong>优点</strong>：<ol>
<li><strong>验证</strong>：当验证密码时，<code>DelegatingPasswordEncoder</code> 会根据前缀选择正确的编码器进行 <code>matches</code> 操作。</li>
<li><strong>升级</strong>：你可以配置它默认使用新的算法（如 Argon2）。新注册的用户或修改密码的用户会使用新算法存储。而老用户登录时，它仍然能用旧的算法（如 BCrypt）去验证他们的密码。这使得系统可以在不强制所有用户重置密码的情况下，逐步迁移到更安全的算法。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-3-4-如何使用-PasswordEncoder"><a href="#2-3-4-如何使用-PasswordEncoder" class="headerlink" title="2.3.4 如何使用 PasswordEncoder"></a>2.3.4 如何使用 <code>PasswordEncoder</code></h4><h5 id="1-声明-Bean"><a href="#1-声明-Bean" class="headerlink" title="1. 声明 Bean"></a>1. 声明 Bean</h5><p>在你的 <code>@Configuration</code> 类中，必须将一个 <code>PasswordEncoder</code> 实例声明为 Spring Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回一个 BCryptPasswordEncoder 实例</span></span><br><span class="line">        <span class="comment">// 构造函数可以接受一个 &quot;strength&quot; 参数 (4-31)，默认是 10。</span></span><br><span class="line">        <span class="comment">// 数字越大，计算越慢，密码越安全，但认证耗时也越长。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果你想使用 DelegatingPasswordEncoder (Spring Boot 默认行为)</span></span><br><span class="line">    <span class="comment">// import org.springframework.security.crypto.factory.PasswordEncoderFactories;</span></span><br><span class="line">    <span class="comment">// @Bean</span></span><br><span class="line">    <span class="comment">// public PasswordEncoder passwordEncoder() &#123;</span></span><br><span class="line">    <span class="comment">//     return PasswordEncoderFactories.createDelegatingPasswordEncoder();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Spring Boot 会自动配置 <code>DelegatingPasswordEncoder</code>，所以通常你只需要提供一个具体的实现（如 <code>BCryptPasswordEncoder</code>），Spring Security 会自动使用它。</strong></p>
<hr>
<h5 id="2-在注册-修改密码时进行编码"><a href="#2-在注册-修改密码时进行编码" class="headerlink" title="2. 在注册&#x2F;修改密码时进行编码"></a>2. 在注册&#x2F;修改密码时进行编码</h5><p>当用户注册或修改密码时，<strong>永远不要</strong>将明文密码存入数据库。必须先使用 <code>passwordEncoder</code> 进行编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(String username, String rawPassword)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        <span class="comment">// 关键步骤：对明文密码进行编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encodedPassword</span> <span class="operator">=</span> passwordEncoder.encode(rawPassword);</span><br><span class="line">        user.setPassword(encodedPassword);</span><br><span class="line">        </span><br><span class="line">        save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码后的密码（一个长得像乱码的字符串）将被存入数据库的 <code>password</code> 字段。</p>
<hr>
<h5 id="3-Spring-Security-自动进行验证"><a href="#3-Spring-Security-自动进行验证" class="headerlink" title="3. Spring Security 自动进行验证"></a>3. Spring Security 自动进行验证</h5><p>你<strong>不需要</strong>手动调用 <code>passwordEncoder.matches()</code>。</p>
<p>在认证流程（<code>2.1</code> 节已详述）中，<code>DaoAuthenticationProvider</code> 会被自动注入你声明的 <code>PasswordEncoder</code> Bean。当它从 <code>UserDetailsService</code> 加载到 <code>UserDetails</code> 后，会自动调用 <code>passwordEncoder.matches(rawPassword, encodedPassword)</code> 来进行密码比对，其中：</p>
<ul>
<li><code>rawPassword</code>: 是用户在登录表单中输入的明文密码。</li>
<li><code>encodedPassword</code>: 是从 <code>UserDetails</code> (即数据库) 中获取的已编码密码。</li>
</ul>
<hr>
<h3 id="2-4-常见的认证方式配置"><a href="#2-4-常见的认证方式配置" class="headerlink" title="2.4 常见的认证方式配置"></a>2.4 常见的认证方式配置</h3><p>Spring Security 提供了多种开箱即用的认证机制，以适应不同的应用场景。这里我们重点介绍三种最常见的：Form Login、HTTP Basic 和 Remember-Me。</p>
<h4 id="2-4-1-基于表单的认证-Form-Login"><a href="#2-4-1-基于表单的认证-Form-Login" class="headerlink" title="2.4.1 基于表单的认证 (Form Login)"></a>2.4.1 基于表单的认证 (Form Login)</h4><p>这是最常见的一种认证方式，适用于所有面向普通用户的 Web 应用程序。用户通过一个 HTML 表单提交用户名和密码来进行登录。</p>
<h5 id="1-默认的-Form-Login"><a href="#1-默认的-Form-Login" class="headerlink" title="1. 默认的 Form Login"></a>1. 默认的 Form Login</h5><p>只需在 <code>SecurityFilterChain</code> 配置中加入 <code>.formLogin()</code> 即可启用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">        .formLogin(Customizer.withDefaults()); <span class="comment">// 使用默认配置启用表单登录</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会自动提供一个由 Spring Security 生成的登录页面（在 <code>/login</code>），并处理 <code>POST /login</code> 的登录请求。</p>
<hr>
<h5 id="2-自定义登录页面"><a href="#2-自定义登录页面" class="headerlink" title="2. 自定义登录页面"></a>2. 自定义登录页面</h5><p>在真实项目中，我们总是需要一个自定义的、符合网站风格的登录页面。</p>
<p><strong>步骤 1: 创建登录页面的 Controller</strong></p>
<p>你需要一个 Controller 来返回登录页面的视图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loginPage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>; <span class="comment">// 返回视图名，例如 login.html (使用Thymeleaf)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 创建登录页面 (e.g., <code>src/main/resources/templates/login.html</code>)</strong></p>
<p>页面中的表单需要遵循一些约定：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Login Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign in<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 显示登录失败的错误信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;param.error&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span></span><br><span class="line">        Invalid username or password.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 显示注销成功的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;param.logout&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: green;&quot;</span>&gt;</span></span><br><span class="line">        You have been logged out.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 登录表单 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- th:action=&quot;@&#123;/login&#125;&quot; 会自动处理 context path --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- action=&quot;/login&quot; 也可以，处理登录的 URL 默认为 /login --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/login&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- name=&quot;username&quot; 是默认的用户名参数名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">autofocus</span>=<span class="string">&quot;autofocus&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>Password:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- name=&quot;password&quot; 是默认的密码参数名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认开启 CSRF 防护，Thymeleaf 会自动在表单中添加一个隐藏的 _csrf token --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">th:name</span>=<span class="string">&quot;$&#123;_csrf.parameterName&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Sign In<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>action</code> 必须指向 Spring Security 处理登录的 URL (默认为 <code>POST /login</code>)。</li>
<li>用户名输入框的 <code>name</code> 属性默认为 <code>username</code>。</li>
<li>密码输入框的 <code>name</code> 属性默认为 <code>password</code>。</li>
<li>如果启用了 CSRF 防护（默认开启），表单中必须包含 CSRF token。Thymeleaf 会自动处理。</li>
</ul>
<p><strong>步骤 3: 更新 Security 配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/dashboard&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// /dashboard 只有 ADMIN 角色可以访问</span></span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>).permitAll() <span class="comment">// 首页与登陆页允许所有用户访问</span></span><br><span class="line">                        .anyRequest().authenticated() <span class="comment">// 其他所有请求都需要认证</span></span><br><span class="line">                )</span><br><span class="line">                .formLogin(form -&gt; form</span><br><span class="line">                        .loginPage(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 指定自定义登录页的URL</span></span><br><span class="line">                        .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 指定处理登录请求的URL (默认为/login)</span></span><br><span class="line">                        .usernameParameter(<span class="string">&quot;username&quot;</span>) <span class="comment">// 自定义用户名字段名 (默认为username)</span></span><br><span class="line">                        .passwordParameter(<span class="string">&quot;password&quot;</span>) <span class="comment">// 自定义密码字段名 (默认为password)</span></span><br><span class="line">                        .defaultSuccessUrl(<span class="string">&quot;/&quot;</span>, <span class="literal">true</span>) <span class="comment">// 登录成功后的默认重定向地址, true表示总是重定向</span></span><br><span class="line">                        .failureUrl(<span class="string">&quot;/login?error&quot;</span>) <span class="comment">// 登录失败后重定向的地址</span></span><br><span class="line">                        .permitAll() <span class="comment">// 必须允许所有人访问登录相关的URL</span></span><br><span class="line">                )</span><br><span class="line">                .logout(logout -&gt; logout</span><br><span class="line">                        .logoutSuccessUrl(<span class="string">&quot;/&quot;</span>) <span class="comment">// 注销成功后重定向到首页</span></span><br><span class="line">                );</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.loginPage(&quot;/login&quot;)</code>: 告诉 Spring Security 你的登录页在 <code>/login</code>，当未认证用户访问受保护资源时，将他们重定向到这里。</li>
<li><code>.loginProcessingUrl(&quot;/login&quot;)</code>: 指定 <code>UsernamePasswordAuthenticationFilter</code> 监听哪个 URL 来处理登录提交。</li>
<li><code>.defaultSuccessUrl(...)</code>: 登录成功后跳转的页面。如果设置为 <code>true</code>，则总是跳转到此页面；如果为 <code>false</code>（默认），则会跳转到用户在登录前尝试访问的页面。</li>
<li><code>.failureUrl(...)</code>: 登录失败后跳转的页面。我们通常会附带一个参数（如 <code>error</code>）用于在页面上显示提示信息。</li>
<li>最后，非常重要的一点是，<strong>必须将登录页面本身设置为 <code>permitAll()</code></strong>，否则用户将陷入无限重定向的循环。</li>
</ul>
<hr>
<h4 id="2-4-2-HTTP-Basic-认证"><a href="#2-4-2-HTTP-Basic-认证" class="headerlink" title="2.4.2 HTTP Basic 认证"></a>2.4.2 HTTP Basic 认证</h4><p>HTTP Basic 认证是一种更简单的认证方案，它不依赖 HTML 表单，而是直接使用 HTTP Header 来传递凭证。</p>
<h5 id="1-适用场景"><a href="#1-适用场景" class="headerlink" title="1. 适用场景"></a>1. 适用场景</h5><ul>
<li><strong>无状态的 RESTful API</strong>: 特别适合用于程序间的调用，例如脚本、微服务间的通信。</li>
<li><strong>简单的后台管理接口</strong>: 对于内部系统或对用户体验要求不高的场景，可以快速提供安全保护。</li>
<li><strong>开发和测试</strong>: 在开发阶段快速保护端点，无需编写登录页面。</li>
</ul>
<hr>
<h5 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ol>
<li>客户端首次请求受保护资源。</li>
<li>服务器返回 <code>401 Unauthorized</code> 状态码，并在响应头中包含 <code>WWW-Authenticate: Basic realm=&quot;user realm&quot;</code>。</li>
<li>浏览器或客户端收到此响应后，会弹出一个对话框，要求用户输入用户名和密码。</li>
<li>客户端将 <code>username:password</code> 这个字符串进行 Base64 编码，然后放入后续请求的 <code>Authorization</code> Header 中，格式为 <code>Authorization: Basic &lt;base64-encoded-credentials&gt;</code>。</li>
<li>服务器端的 <code>BasicAuthenticationFilter</code> 拦截到这个 Header，解码凭证并进行认证。</li>
</ol>
<hr>
<h5 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h5><p>启用 HTTP Basic 认证非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">// 如果有多个 SecurityFilterChain，用 @Order 指定优先级</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">apiFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .securityMatcher(<span class="string">&quot;/api/**&quot;</span>) <span class="comment">// 此配置仅对 /api/ 开头的请求生效</span></span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">        .httpBasic(Customizer.withDefaults()); <span class="comment">// 启用 HTTP Basic</span></span><br><span class="line">        <span class="comment">// 因为是 API，通常是无状态的，所以禁用 CSRF 和 Session</span></span><br><span class="line">        .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">        .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.httpBasic()</code>: 一行代码即可启用。</li>
<li>对于 API 场景，通常会禁用 CSRF（因为 API 客户端通常不涉及浏览器 Cookie）并设置会话策略为 <code>STATELESS</code>（无状态），这样每次请求都需要携带 <code>Authorization</code> Header。</li>
</ul>
<hr>
<h4 id="2-4-3-“记住我”-Remember-Me-功能"><a href="#2-4-3-“记住我”-Remember-Me-功能" class="headerlink" title="2.4.3 “记住我” (Remember-Me) 功能"></a>2.4.3 “记住我” (Remember-Me) 功能</h4><p>“记住我”功能允许用户在关闭浏览器后，下次访问时仍然保持登录状态，从而提升用户体验。</p>
<h5 id="1-工作原理-基于-Cookie"><a href="#1-工作原理-基于-Cookie" class="headerlink" title="1. 工作原理 (基于 Cookie)"></a>1. 工作原理 (基于 Cookie)</h5><ol>
<li>用户在登录页面勾选“记住我”复选框并成功登录。</li>
<li><code>RememberMeAuthenticationFilter</code> 捕获到这个成功的登录事件。</li>
<li>它会生成一个特殊的 <code>remember-me</code> Cookie，并将其发送给浏览器。这个 Cookie 包含了用户名、过期时间和一个根据私钥（<code>key</code>）、用户名、密码和过期时间计算出的签名。</li>
<li>用户关闭浏览器再重新打开，访问受保护的页面。</li>
<li>此时用户没有 <code>JSESSIONID</code>，未被认证。但 <code>RememberMeAuthenticationFilter</code> 会检查请求中是否存在 <code>remember-me</code> Cookie。</li>
<li>如果存在，它会验证 Cookie 的签名是否有效且未过期。</li>
<li>如果验证通过，它会像正常登录一样，从 <code>UserDetailsService</code> 加载用户信息，创建一个已认证的 <code>Authentication</code> 对象，并将其放入 <code>SecurityContextHolder</code>。</li>
<li>用户被视为已登录，可以访问受保护的资源。</li>
</ol>
<p><strong>安全性注意</strong>：这种方式相对安全，因为 Cookie 中不包含明文密码，且有签名防止篡改。但如果用户的电脑被他人使用，或者 Cookie 被窃取，攻击者仍然可以在过期前冒充用户身份。</p>
<hr>
<h5 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... authorizeHttpRequests 和 formLogin 配置</span></span><br><span class="line">        .rememberMe(rememberMe -&gt; rememberMe</span><br><span class="line">            .key(<span class="string">&quot;a-very-secret-and-long-key-value&quot;</span>) <span class="comment">// 用于生成签名的私钥，必须配置</span></span><br><span class="line">            .tokenValiditySeconds(<span class="number">86400</span> * <span class="number">14</span>) <span class="comment">// Cookie 有效期，单位秒，这里是14天</span></span><br><span class="line">            .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>) <span class="comment">// 登录表单中复选框的 name 属性 (默认)</span></span><br><span class="line">            .userDetailsService(userDetailsService) <span class="comment">// 必须提供 UserDetailsService</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>.key(&quot;...&quot;)</code>: <strong>必须设置一个复杂的、保密的私钥</strong>。如果泄露，所有用户的 <code>remember-me</code> Cookie 都将面临风险。</p>
</li>
<li><p><code>.tokenValiditySeconds(...)</code>: 设置 Cookie 的有效期。</p>
</li>
<li><p><code>.userDetailsService(...)</code>: “记住我”功能需要通过它来在 Cookie 验证成功后重新加载用户信息。</p>
</li>
<li><p><strong>前端修改</strong>: 别忘了在你的登录表单中添加一个复选框：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;remember-me&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;remember-me&quot;</span>&gt;</span>Remember me<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>进阶：基于数据库的持久化 Token</strong></p>
<p>上述基于 Cookie 的签名方式存在一个风险：只要 Cookie 未过期，它就一直有效，无法被主动撤销（除非用户修改密码）。</p>
<p>一种更安全的方式是使用持久化 Token。<code>PersistentTokenRepository</code> 会将生成的 Token 存储在数据库中。每次用户通过 “记住我” 登录时，都会生成一个新的 Token 来替换旧的，这使得一个 Token 只能被使用一次，大大降低了 Cookie 被盗用的风险。配置方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 提供一个 PersistentTokenRepository 的 Bean，例如 JdbcTokenRepositoryImpl</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PersistentTokenRepository <span class="title function_">persistentTokenRepository</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">tokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">    tokenRepository.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">// tokenRepository.setCreateTableOnStartup(true); // 首次运行时可以设为 true 自动建表</span></span><br><span class="line">    <span class="keyword">return</span> tokenRepository;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在 rememberMe 配置中使用它</span></span><br><span class="line">.rememberMe(rememberMe -&gt; rememberMe</span><br><span class="line">    .tokenRepository(persistentTokenRepository(dataSource)) <span class="comment">// 使用基于数据库的 token 仓库</span></span><br><span class="line">    <span class="comment">// .key(...) 仍然需要</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-授权（Authorization）"><a href="#3-授权（Authorization）" class="headerlink" title="3. 授权（Authorization）"></a>3. 授权（Authorization）</h2><h3 id="3-1-授权基础：访问控制"><a href="#3-1-授权基础：访问控制" class="headerlink" title="3.1 授权基础：访问控制"></a>3.1 授权基础：访问控制</h3><p>一旦用户通过了<strong>认证 (Authentication)</strong>，确定了他的身份，接下来的每一步操作都需要经过<strong>授权 (Authorization)</strong> 的检验。授权的核心任务是：<strong>根据当前已认证用户的身份，决定他是否有权访问某个特定的资源</strong>。这个资源可以是一个 URL、一个服务方法，甚至是页面上的一个按钮。</p>
<h4 id="3-1-1-授权流程与决策机制"><a href="#3-1-1-授权流程与决策机制" class="headerlink" title="3.1.1 授权流程与决策机制"></a>3.1.1 授权流程与决策机制</h4><p>Spring Security 的授权流程在宏观上可以看作是一个“守门员”模型，它发生在请求真正到达你的业务代码之前。</p>
<h5 id="1-授权流程概览"><a href="#1-授权流程概览" class="headerlink" title="1. 授权流程概览"></a>1. 授权流程概览</h5><pre><code class="highlight mermaid">flowchart TD
    A[已认证的请求] --&gt; B[AuthorizationFilter &lt;br&gt;- 拦截请求 &lt;br&gt;- 提取目标资源信息 &lt;br&gt;- 提取用户认证信息]
    B --&gt; C&#123;&quot;将信息提交给...&quot;&#125;
    C --&gt; D[AuthorizationManager 新] 
    C --&gt; E[AccessDecisionManager 旧]
    E --&gt; F[AccessDecisionVoter 投票者 &lt;br&gt;- 每个 Voter 根据自身逻辑投票 &lt;br&gt;- 结果：ACCESS_GRANTED / &lt;br&gt;ACCESS_DENIED / ABSTAIN]
    F --&gt; G[AccessDecisionManager 旧 &lt;br&gt;- 汇总投票结果 &lt;br&gt;- 根据策略（如「一票通过」&lt;br&gt;「一致同意」） &lt;br&gt;- 做出最终裁决]
    D --&gt; H[做出最终决策 Check]
    G --&gt; H
    H --&gt; I&#123;决策结果&#125;
    I --&gt; J[允许 Allow: 请求继续执行]
    I --&gt; K[拒绝 Deny: &lt;br&gt;抛出 AccessDeniedException]
    K --&gt; L[ExceptionTranslationFilter &lt;br&gt;- 捕获 AccessDeniedException &lt;br&gt;- 调用 AccessDeniedHandler]
    L --&gt; M[返回 403 Forbidden &lt;br&gt;- 或重定向到错误页面]</code></pre>

<hr>
<h5 id="2-核心决策组件"><a href="#2-核心决策组件" class="headerlink" title="2. 核心决策组件"></a>2. 核心决策组件</h5><ul>
<li><strong>拦截器 (Interceptor)</strong>：<ul>
<li>对于 Web 请求，主要是 <code>AuthorizationFilter</code>。</li>
<li>对于方法级别的安全，是基于 AOP 的方法拦截器。</li>
<li><strong>职责</strong>：在操作发生前“拦住”它，并收集进行授权决策所需的所有信息：<ol>
<li><strong><code>Authentication</code> 对象</strong>: 当前用户的身份信息，从 <code>SecurityContextHolder</code> 获取。</li>
<li><strong>安全对象 (Secure Object)</strong>: 正在被访问的目标资源，例如 <code>Request</code> 对象或被调用的 <code>MethodInvocation</code>。</li>
<li><strong>配置属性 (Configuration Attributes)</strong>: 保护该资源所需的权限配置，例如 <code>hasRole(&#39;ADMIN&#39;)</code> 或 <code>@PreAuthorize(&quot;hasAuthority(&#39;user:read&#39;)&quot;)</code>。</li>
</ol>
</li>
</ul>
</li>
<li><strong><code>AuthorizationManager</code> (现代架构)</strong>：<ul>
<li>这是 Spring Security 6.x 之后推荐的、更简洁的授权决策接口。</li>
<li>它只有一个核心方法 <code>check(Supplier&lt;Authentication&gt; authentication, T object)</code>。</li>
<li><strong>职责</strong>：接收认证信息和目标对象，直接做出“允许”或“拒绝”的最终决策。如果拒绝，它会抛出 <code>AccessDeniedException</code>。我们通过 Lambda 表达式配置的 <code>authorizeHttpRequests</code> 内部就是转换成了不同的 <code>AuthorizationManager</code> 实现。</li>
</ul>
</li>
<li><strong><code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> (传统架构)</strong>：<ul>
<li><strong><code>AccessDecisionManager</code> (决策管理器)</strong>：像一个**“议长”**，它不亲自做判断，而是组织一场投票。</li>
<li><strong><code>AccessDecisionVoter</code> (投票者)</strong>：像**“议员”**。每个 <code>Voter</code> 都有自己专长的领域。例如，<code>RoleVoter</code> 只关心角色（<code>ROLE_</code> 前缀的权限），<code>WebExpressionVoter</code> 负责处理 SpEL 表达式。</li>
<li><strong>投票过程</strong>:<ol>
<li><code>AccessDecisionManager</code> 把收集到的信息分发给它管理的所有 <code>AccessDecisionVoter</code>。</li>
<li>每个 <code>Voter</code> 根据自己的逻辑进行投票，结果有三种：<ul>
<li><code>ACCESS_GRANTED</code> (赞成票)</li>
<li><code>ACCESS_DENIED</code> (反对票)</li>
<li><code>ABSTAIN</code> (弃权票，表示这个决策与我无关)</li>
</ul>
</li>
<li><code>AccessDecisionManager</code> 根据预设的<strong>决策策略</strong>来汇总投票结果：<ul>
<li><strong><code>AffirmativeBased</code> (默认)</strong>: <strong>一票赞成就通过</strong>。只要有一个 Voter 投了赞成票，就允许访问（除非有反对票，具体看配置）。</li>
<li><strong><code>ConsensusBased</code></strong>: <strong>少数服从多数</strong>。赞成票多于反对票就通过。</li>
<li><strong><code>UnanimousBased</code></strong>: <strong>一致同意制</strong>。所有 Voter 都必须投赞成票或弃权票，不能有任何反对票。</li>
</ul>
</li>
</ol>
</li>
<li><strong>最终裁决</strong>：如果最终结果是拒绝，<code>AccessDecisionManager</code> 就会抛出 <code>AccessDeniedException</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3. 异常处理"></a>3. 异常处理</h5><p>如果授权决策的结果是“拒绝”，流程并不会立即终止。抛出的 <code>AccessDeniedException</code> 会被 <code>ExceptionTranslationFilter</code> 捕获，然后委托给 <code>AccessDeniedHandler</code> 进行处理，最终通常是向用户返回一个 <strong>403 Forbidden</strong> 页面或 JSON 响应。</p>
<hr>
<h4 id="3-1-2-角色-Role-与-权限-Authority-的区别与联系"><a href="#3-1-2-角色-Role-与-权限-Authority-的区别与联系" class="headerlink" title="3.1.2 角色 (Role) 与 权限 (Authority) 的区别与联系"></a>3.1.2 角色 (Role) 与 权限 (Authority) 的区别与联系</h4><p>从<strong>技术实现</strong>上讲，<strong>角色和权限在 Spring Security 内部都被抽象为 <code>GrantedAuthority</code> 对象</strong>。<code>RoleVoter</code> 在判断时，只是简单地检查 <code>GrantedAuthority</code> 的字符串是否以 <code>ROLE_</code> 开头。</p>
<p>然而，从<strong>设计理念</strong>上讲，它们代表了不同的抽象层次：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><strong>角色 (Role)</strong></th>
<th align="left"><strong>权限 (Authority&#x2F;Permission)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>概念</strong></td>
<td align="left"><strong>“是什么” (Who you are)</strong>，代表一组职责或身份的集合。</td>
<td align="left"><strong>“能做什么” (What you can do)</strong>，代表一个具体的操作许可。</td>
</tr>
<tr>
<td align="left"><strong>粒度</strong></td>
<td align="left"><strong>粗粒度 (Coarse-grained)</strong></td>
<td align="left"><strong>细粒度 (Fine-grained)</strong></td>
</tr>
<tr>
<td align="left"><strong>例子</strong></td>
<td align="left"><code>ROLE_ADMIN</code> (管理员)<br><code>ROLE_USER</code> (普通用户)<br><code>ROLE_GUEST</code> (访客)</td>
<td align="left"><code>user:create</code> (创建用户)<br><code>user:read</code> (读取用户)<br><code>order:approve</code> (审批订单)</td>
</tr>
<tr>
<td align="left"><strong>关系</strong></td>
<td align="left"><strong>一个角色通常包含多个权限</strong>。</td>
<td align="left"><strong>一个权限是最小的、不可再分的授权单元</strong>。</td>
</tr>
<tr>
<td align="left"><strong>管理</strong></td>
<td align="left">将权限分配给角色，再将角色分配给用户。</td>
<td align="left">直接将权限分配给用户（不推荐，难以维护）。</td>
</tr>
</tbody></table>
<p><strong>联系与最佳实践：基于角色的访问控制 (RBAC - Role-Based Access Control)</strong></p>
<p>这是业界最主流、最推荐的权限设计模型。它的核心思想是：</p>
<ol>
<li><strong>用户 (User) ←→ 角色 (Role)</strong>: 给用户分配一个或多个角色。<ul>
<li>例如：张三是“内容管理员”。</li>
</ul>
</li>
<li><strong>角色 (Role) ←→ 权限 (Permission&#x2F;Authority)</strong>: 给角色分配一组具体的操作权限。<ul>
<li>例如：“内容管理员”这个角色拥有 <code>article:create</code>, <code>article:edit</code>, <code>article:publish</code>, <code>comment:delete</code> 等权限。</li>
</ul>
</li>
</ol>
<p><strong>用户并不直接拥有权限，而是通过拥有角色来间接获得权限。</strong></p>
<p><strong>优点</strong>:</p>
<ul>
<li><strong>简化管理</strong>: 当需要调整权限时，只需修改角色的权限配置，所有拥有该角色的用户的权限就会自动更新。无需逐个修改每个用户的权限。</li>
<li><strong>逻辑清晰</strong>: “管理员能做什么”比“张三、李四、王五…能做什么”要清晰得多，符合业务语义。</li>
<li><strong>最小权限原则</strong>: 可以精确地为每个角色授予其完成工作所必需的最小权限集合。</li>
</ul>
<p><strong>在 Spring Security 中的体现</strong>:</p>
<ul>
<li>使用 <code>.hasRole(&quot;ADMIN&quot;)</code>: 检查用户是否拥有 <code>ROLE_ADMIN</code> 这个 <code>GrantedAuthority</code>。</li>
<li>使用 <code>.hasAuthority(&quot;user:create&quot;)</code>: 检查用户是否拥有 <code>user:create</code> 这个 <code>GrantedAuthority</code>。</li>
</ul>
<p>当你从数据库加载用户的 <code>GrantedAuthority</code> 时，你应该把用户的<strong>角色</strong>（如 <code>ROLE_ADMIN</code>）和该角色所对应的所有<strong>权限</strong>（如 <code>user:create</code>, <code>user:delete</code>）<strong>全部加载进来</strong>，并作为 <code>GrantedAuthority</code> 列表返回。这样，无论是基于角色的粗粒度控制，还是基于权限的细粒度控制，都可以无缝支持。</p>
<hr>
<h3 id="3-2-基于-URL-的请求授权"><a href="#3-2-基于-URL-的请求授权" class="headerlink" title="3.2 基于 URL 的请求授权"></a>3.2 基于 URL 的请求授权</h3><p>基于 URL 的授权是 Web 应用中最基础、最核心的安全控制方式。它通过配置，为不同的 URL 路径（endpoints）设置不同的访问规则。Spring Security 提供了强大而灵活的链式 API 来实现这一点。</p>
<h4 id="3-2-1-使用-http-authorizeHttpRequests-进行配置"><a href="#3-2-1-使用-http-authorizeHttpRequests-进行配置" class="headerlink" title="3.2.1 使用 http.authorizeHttpRequests() 进行配置"></a>3.2.1 使用 <code>http.authorizeHttpRequests()</code> 进行配置</h4><p>在现代的 <code>SecurityFilterChain</code> 配置中, 所有的 URL 授权规则都定义在 <code>.authorizeHttpRequests()</code> 这个 Lambda 表达式内部。</p>
<p>这个方法提供了一个 <code>AuthorizeHttpRequestsConfigurer</code> 对象（通常我们命名为 <code>auth</code> 或 <code>authorize</code>），我们可以用它来链式地定义一条条匹配规则。</p>
<p><strong>基本结构</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">            <span class="comment">// 在这里定义一条条的 URL 匹配规则</span></span><br><span class="line">            .requestMatchers(<span class="string">&quot;/public/**&quot;</span>, <span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ... 其他配置, 如 .formLogin()</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重要原则：规则的顺序至关重要 (Order Matters!)</strong></p>
<p>Spring Security 会<strong>从上到下</strong>依次匹配这些规则。一旦一个 URL 被<strong>第一条</strong>适用的规则匹配上，后续的规则就不会再生效。</p>
<p>因此，<strong>必须将更具体的规则放在更通用的规则之前</strong>。</p>
<p><strong>正确顺序示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">    .requestMatchers(<span class="string">&quot;/admin/specific-task&quot;</span>).hasRole(<span class="string">&quot;SUPER_ADMIN&quot;</span>) <span class="comment">// 1. 最具体的</span></span><br><span class="line">    .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)            <span class="comment">// 2. 较通用的</span></span><br><span class="line">    .anyRequest().authenticated()                             <span class="comment">// 3. 最通用的（必须放最后）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果把 <code>/admin/**</code> 放在前面，那么 <code>/admin/specific-task</code> 这个请求会先被 <code>.hasRole(&quot;ADMIN&quot;)</code> 匹配到，从而导致 <code>.hasRole(&quot;SUPER_ADMIN&quot;)</code> 这条更严格的规则永远不会被触发。</p>
<hr>
<h4 id="3-2-2-requestMatchers-的使用"><a href="#3-2-2-requestMatchers-的使用" class="headerlink" title="3.2.2 requestMatchers() 的使用"></a><strong>3.2.2 <code>requestMatchers()</code> 的使用</strong></h4><p><code>requestMatchers()</code> 是定义 URL 模式的入口，它支持多种匹配策略。</p>
<h5 id="1-Ant-风格路径匹配-Ant-style-Path-Matching"><a href="#1-Ant-风格路径匹配-Ant-style-Path-Matching" class="headerlink" title="1. Ant 风格路径匹配 (Ant-style Path Matching)"></a>1. Ant 风格路径匹配 (Ant-style Path Matching)</h5><p>这是最常用、最直观的匹配方式。</p>
<ul>
<li><code>?</code>: 匹配任意单个字符。<ul>
<li><code>&quot;/api/v?&quot;</code> 匹配 <code>/api/v1</code>, <code>/api/v2</code>，但不匹配 <code>/api/v</code> 或 <code>/api/v12</code>。</li>
</ul>
</li>
<li><code>*</code>: 匹配路径中任意数量的字符（不含 <code>/</code>）。<ul>
<li><code>&quot;/users/*&quot;</code> 匹配 <code>/users/123</code>, <code>/users/profile</code>，但不匹配 <code>/users/123/orders</code>。</li>
</ul>
</li>
<li><code>**</code>: 匹配路径中任意数量的目录（包含 <code>/</code>）。<ul>
<li><code>&quot;/admin/**&quot;</code> 匹配 <code>/admin/</code>, <code>/admin/users</code>, <code>/admin/users/1/edit</code> 等所有以 <code>/admin/</code> 开头的路径。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配多个具体的路径</span></span><br><span class="line">.requestMatchers(<span class="string">&quot;/home&quot;</span>, <span class="string">&quot;/about&quot;</span>, <span class="string">&quot;/contact&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配某个目录下的所有直接子路径</span></span><br><span class="line">.requestMatchers(<span class="string">&quot;/products/*&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配某个目录及其所有子目录下的所有路径</span></span><br><span class="line">.requestMatchers(<span class="string">&quot;/static/css/**&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-匹配-HTTP-方法"><a href="#2-匹配-HTTP-方法" class="headerlink" title="2. 匹配 HTTP 方法"></a>2. 匹配 HTTP 方法</h5><p>你可以在 <code>requestMatchers</code> 中指定 HTTP 方法，从而对同一个 URL 的不同操作（GET, POST, DELETE 等）设置不同的权限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.http.HttpMethod.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">.authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">    <span class="comment">// 任何人都可以 GET 用户列表</span></span><br><span class="line">    .requestMatchers(GET, <span class="string">&quot;/api/users&quot;</span>).permitAll()</span><br><span class="line">    <span class="comment">// 只有 ADMIN 可以 POST 创建新用户</span></span><br><span class="line">    .requestMatchers(POST, <span class="string">&quot;/api/users&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">    <span class="comment">// 只有 ADMIN 可以删除特定用户</span></span><br><span class="line">    .requestMatchers(DELETE, <span class="string">&quot;/api/users/&#123;id&#125;&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-Servlet-路径匹配-MVC-匹配"><a href="#3-Servlet-路径匹配-MVC-匹配" class="headerlink" title="3. Servlet 路径匹配 (MVC 匹配)"></a>3. Servlet 路径匹配 (MVC 匹配)</h5><p>Spring Security 6.1+ 默认使用 <code>Spring MVC</code> 的路径匹配规则 (<code>PathPatternParser</code>)，它性能更好，且语法与 Ant 风格基本兼容，但在 <code>**</code> 的使用上略有不同（例如 <code>**</code> 只能在路径末尾）。通常你不需要关心这个区别，除非遇到非常复杂的路径匹配场景。</p>
<hr>
<h4 id="3-2-3-核心访问控制方法"><a href="#3-2-3-核心访问控制方法" class="headerlink" title="3.2.3 核心访问控制方法"></a>3.2.3 核心访问控制方法</h4><p>这些方法跟在 <code>requestMatchers(...)</code> 后面，用于定义匹配到的 URL 需要满足什么条件才能访问。</p>
<ul>
<li><strong><code>permitAll()</code></strong>: <strong>允许所有访问</strong><ul>
<li>允许任何人（包括匿名用户）访问。</li>
<li>常用于公共资源，如登录页、注册页、静态文件 (CSS, JS)、首页等。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/login&quot;, &quot;/css/**&quot;).permitAll()</code></li>
</ul>
</li>
<li><strong><code>denyAll()</code></strong>: <strong>拒绝所有访问</strong><ul>
<li>无论用户是谁，都无法访问。</li>
<li>不常用，但可用于明确禁用某些不应被外部访问的路径。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/internal/secret-api&quot;).denyAll()</code></li>
</ul>
</li>
<li><strong><code>authenticated()</code></strong>: <strong>要求已认证</strong><ul>
<li>要求用户必须已经登录（通过了认证）。</li>
<li>这是最基础的保护，不关心用户具体有什么角色或权限，只要登录了就行。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/my-account/**&quot;).authenticated()</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-4-基于角色-权限的访问控制方法"><a href="#3-2-4-基于角色-权限的访问控制方法" class="headerlink" title="3.2.4 基于角色&#x2F;权限的访问控制方法"></a>3.2.4 基于角色&#x2F;权限的访问控制方法</h4><p>这些方法提供了更细粒度的控制，要求用户不仅要登录，还必须拥有特定的角色或权限。</p>
<ul>
<li><strong><code>hasRole(String role)</code></strong>: <strong>要求拥有单个角色</strong><ul>
<li>检查当前用户的 <code>GrantedAuthority</code> 列表中，是否存在一个以 <code>ROLE_</code> 开头的、与指定角色名匹配的权限。</li>
<li><strong>注意</strong>: 你提供的角色名<strong>不需要</strong>加 <code>ROLE_</code> 前缀，框架会自动添加。例如，<code>.hasRole(&quot;ADMIN&quot;)</code> 会去匹配 <code>ROLE_ADMIN</code>。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/admin/panel&quot;).hasRole(&quot;ADMIN&quot;)</code></li>
</ul>
</li>
<li><strong><code>hasAnyRole(String... roles)</code></strong>: <strong>要求拥有多个角色中的任意一个</strong><ul>
<li>只要用户拥有参数列表中任何一个角色，即可访问。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/management/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;MANAGER&quot;)</code><ul>
<li>用户有 <code>ROLE_ADMIN</code> 或 <code>ROLE_MANAGER</code> (或两者都有) 就可以访问。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>hasAuthority(String authority)</code></strong>: <strong>要求拥有单个权限</strong><ul>
<li>直接匹配 <code>GrantedAuthority</code> 列表中的字符串，<strong>不会</strong>自动添加 <code>ROLE_</code> 前缀。</li>
<li>适用于细粒度的权限控制（RBAC 模型中的 Permission）。</li>
<li><strong>示例</strong>: <code>.requestMatchers(POST, &quot;/articles&quot;).hasAuthority(&quot;article:create&quot;)</code></li>
</ul>
</li>
<li><strong><code>hasAnyAuthority(String... authorities)</code></strong>: <strong>要求拥有多个权限中的任意一个</strong><ul>
<li>只要用户拥有参数列表中任何一个权限，即可访问。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/articles/editor&quot;).hasAnyAuthority(&quot;article:edit&quot;, &quot;article:publish&quot;)</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-5-综合示例"><a href="#3-2-5-综合示例" class="headerlink" title="3.2.5 综合示例"></a>3.2.5 综合示例</h4><p>一个典型的、遵循最佳实践的授权配置可能如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">            <span class="comment">// 1. 优先放行公共资源</span></span><br><span class="line">            .requestMatchers(<span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;/images/**&quot;</span>, <span class="string">&quot;/webjars/**&quot;</span>).permitAll()</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/home&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 配置基于权限的细粒度规则</span></span><br><span class="line">            .requestMatchers(POST, <span class="string">&quot;/api/products&quot;</span>).hasAuthority(<span class="string">&quot;product:write&quot;</span>)</span><br><span class="line">            .requestMatchers(DELETE, <span class="string">&quot;/api/products/**&quot;</span>).hasAuthority(<span class="string">&quot;product:delete&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 配置基于角色的粗粒度规则</span></span><br><span class="line">            .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/moderator/**&quot;</span>).hasAnyRole(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;MODERATOR&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. (兜底规则) 其他任何未匹配的请求，都必须登录后才能访问</span></span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">        )</span><br><span class="line">        .formLogin(form -&gt; form.loginPage(<span class="string">&quot;/login&quot;</span>).permitAll());</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-方法级别的安全控制（-EnableMethodSecurity）"><a href="#3-3-方法级别的安全控制（-EnableMethodSecurity）" class="headerlink" title="3.3 方法级别的安全控制（@EnableMethodSecurity）"></a>3.3 方法级别的安全控制（@EnableMethodSecurity）</h3><p>URL 级别的授权能够保护 Web 端点，但它无法深入到业务逻辑层（Service Layer）。有时，我们需要对 Service 方法进行保护，确保即便是 Controller 层的代码逻辑出现疏忽，非法的调用也无法触及核心业务。方法安全正是为此而生。</p>
<h4 id="3-3-1-如何启用方法安全"><a href="#3-3-1-如何启用方法安全" class="headerlink" title="3.3.1 如何启用方法安全"></a>3.3.1 如何启用方法安全</h4><p>要使用方法安全注解，首先需要在你的主配置类或安全配置类上添加 <code>@EnableMethodSecurity</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMethodSecurity</span> <span class="comment">// 启用方法级别的安全控制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上这个注解后，Spring Security 会创建一个 AOP (面向切面编程) 的代理，来拦截标注了安全注解的方法调用，并在方法执行前后进行安全检查。</p>
<p>默认情况下，<code>@EnableMethodSecurity</code> 会启用对 <code>@PreAuthorize</code>, <code>@PostAuthorize</code>, <code>@Secured</code> 和 <code>@RolesAllowed</code> (JSR-250) 注解的支持。</p>
<hr>
<h4 id="3-3-2-PreAuthorize-PostAuthorize-最强大、最灵活的注解"><a href="#3-3-2-PreAuthorize-PostAuthorize-最强大、最灵活的注解" class="headerlink" title="3.3.2 @PreAuthorize &#x2F; @PostAuthorize: 最强大、最灵活的注解"></a>3.3.2 <code>@PreAuthorize</code> &#x2F; <code>@PostAuthorize</code>: 最强大、最灵活的注解</h4><p>这两个注解是 Spring Security 自己的注解，它们内部支持 <strong>SpEL (Spring Expression Language)</strong> 表达式，这使得我们可以编写出极其灵活和强大的动态授权规则。</p>
<h5 id="1-PreAuthorize-expression"><a href="#1-PreAuthorize-expression" class="headerlink" title="1. @PreAuthorize(&quot;expression&quot;)"></a>1. <code>@PreAuthorize(&quot;expression&quot;)</code></h5><ul>
<li><strong>执行时机</strong>: 在<strong>方法执行之前</strong>进行权限检查。</li>
<li><strong>决策</strong>: 如果 SpEL 表达式返回 <code>false</code>，方法将<strong>不会被执行</strong>，并直接抛出 <code>AccessDeniedException</code>。</li>
<li><strong>适用场景</strong>: 这是<strong>最常用</strong>的方法安全注解。绝大多数授权决策都应该在方法执行前完成，以避免不必要的资源消耗和潜在的数据操作。</li>
</ul>
<p><strong>常用 SpEL 表达式:</strong></p>
<ul>
<li><p><strong>检查角色&#x2F;权限</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span> <span class="comment">// 需要 ROLE_ADMIN 角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(Long userId)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyRole(&#x27;ADMIN&#x27;, &#x27;MANAGER&#x27;)&quot;)</span> <span class="comment">// 需要 ADMIN 或 MANAGER 角色</span></span><br><span class="line"><span class="keyword">public</span> Report <span class="title function_">generateReport</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;user:delete&#x27;)&quot;)</span> <span class="comment">// 需要 &#x27;user:delete&#x27; 权限</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(Long userId)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问 <code>authentication</code> 对象</strong>:<br>SpEL 表达式可以直接访问 <code>SecurityContext</code> 中的 <code>authentication</code> 对象，从而获取当前登录用户的详细信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有用户名是 &quot;admin&quot; 的用户才能调用</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;authentication.name == &#x27;admin&#x27;&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runAdminTask</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问方法参数</strong>:<br>SpEL 表达式可以通过 <code>#参数名</code> 的形式来引用方法的参数，这对于实现“对象级别的访问控制”至关重要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有用户自己才能修改自己的信息</span></span><br><span class="line"><span class="comment">// #username 引用了方法的 username 参数</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#username == authentication.principal.username&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserProfile</span><span class="params">(String username, UserProfile newProfile)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 User 对象有 owner 属性</span></span><br><span class="line"><span class="comment">// 只有文章的拥有者或管理员才能编辑</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#article.owner == authentication.name or hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">editArticle</span><span class="params">(<span class="meta">@P(&quot;article&quot;)</span> Article article)</span> &#123; ... &#125; </span><br><span class="line"><span class="comment">// 使用 @P 注解为参数命名，使其在 SpEL 中可被引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调用其他 Bean 的方法</strong>:<br>可以在 SpEL 表达式中通过 <code>@beanName.methodName()</code> 的形式调用 Spring 容器中任何 Bean 的方法，实现非常复杂的业务授权逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用名为 &#x27;permissionService&#x27; 的 Bean 的 checkPermission 方法</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@permissionService.checkPermission(authentication, #userId)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserProfile <span class="title function_">getUserProfile</span><span class="params">(Long userId)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>这是一种将授权逻辑从业务代码中完全抽离出来的强大模式。</p>
</li>
</ul>
<hr>
<h5 id="2-PostAuthorize-expression"><a href="#2-PostAuthorize-expression" class="headerlink" title="2. @PostAuthorize(&quot;expression&quot;)"></a>2. <code>@PostAuthorize(&quot;expression&quot;)</code></h5><ul>
<li><strong>执行时机</strong>: 在<strong>方法执行之后，返回结果之前</strong>进行权限检查。</li>
<li><strong>决策</strong>: 如果 SpEL 表达式返回 <code>false</code>，方法已经执行完毕，但其<strong>返回结果不会传递给调用者</strong>，而是抛出 <code>AccessDeniedException</code>。</li>
<li><strong>适用场景</strong>: 比较少见，通常用于需要<strong>根据方法的返回值</strong>来进行授权决策的场景。例如，一个方法返回了某个敏感对象，你需要检查当前用户是否有权查看这个特定的对象。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法返回一个 Order 对象</span></span><br><span class="line"><span class="comment">// 只有订单的创建者或者管理员才能获取到这个订单的详细信息</span></span><br><span class="line"><span class="meta">@PostAuthorize(&quot;returnObject.customerUsername == authentication.name or hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">getOrderDetails</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderRepository.findById(orderId);</span><br><span class="line">    <span class="comment">// ... 此时方法逻辑已经执行</span></span><br><span class="line">    <span class="keyword">return</span> order; <span class="comment">// 在返回前，会对 returnObject (即 order) 进行权限检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>returnObject</code>: 是 SpEL 中一个特殊的关键字，代表了方法的返回值。</li>
</ul>
<p><strong>注意</strong>: 使用 <code>@PostAuthorize</code> 要小心，因为它是在业务逻辑执行后才进行检查。如果方法内部有修改数据的操作（如更新数据库），即使最后授权失败，这些操作也已经完成了，可能需要事务回滚来保证数据一致性。</p>
<hr>
<h4 id="3-3-3-Secured-和-RolesAllowed-简单的基于角色的控制"><a href="#3-3-3-Secured-和-RolesAllowed-简单的基于角色的控制" class="headerlink" title="3.3.3 @Secured 和 @RolesAllowed: 简单的基于角色的控制"></a>3.3.3 <code>@Secured</code> 和 <code>@RolesAllowed</code>: 简单的基于角色的控制</h4><p>这两个注解功能类似，都是用于简单的、基于角色的访问控制，它们不支持复杂的 SpEL 表达式。</p>
<h5 id="1-Secured-ROLE-NAME-1-ROLE-NAME-2"><a href="#1-Secured-ROLE-NAME-1-ROLE-NAME-2" class="headerlink" title="1. @Secured({&quot;ROLE_NAME_1&quot;, &quot;ROLE_NAME_2&quot;})"></a>1. <code>@Secured({&quot;ROLE_NAME_1&quot;, &quot;ROLE_NAME_2&quot;})</code></h5><ul>
<li><strong>来源</strong>: Spring Security 早期就有的注解。</li>
<li><strong>用法</strong>: 注解的参数是一个字符串数组，代表允许访问的角色列表。</li>
<li><strong>约定</strong>: 角色名<strong>必须</strong>以 <code>ROLE_</code> 作为前缀。</li>
<li><strong>逻辑</strong>: 拥有参数列表中<strong>任意一个</strong>角色的用户即可访问。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有拥有 ROLE_ADMIN 角色的用户才能访问</span></span><br><span class="line"><span class="meta">@Secured(&quot;ROLE_ADMIN&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resetSystem</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拥有 ROLE_ADMIN 或 ROLE_MANAGER 角色的用户可以访问</span></span><br><span class="line"><span class="meta">@Secured(&#123;&quot;ROLE_ADMIN&quot;, &quot;ROLE_MANAGER&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> DashboardData <span class="title function_">getDashboard</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-RolesAllowed-ROLE-1-ROLE-2"><a href="#2-RolesAllowed-ROLE-1-ROLE-2" class="headerlink" title="2. @RolesAllowed({&quot;ROLE_1&quot;, &quot;ROLE_2&quot;})"></a>2. <code>@RolesAllowed({&quot;ROLE_1&quot;, &quot;ROLE_2&quot;})</code></h5><ul>
<li><strong>来源</strong>: <strong>JSR-250</strong> 标准定义的一套 Java 安全注解之一。Spring Security 提供了对其的支持。</li>
<li><strong>用法</strong>: 与 <code>@Secured</code> 类似，参数也是一个字符串数组。</li>
<li><strong>约定</strong>: 角色名<strong>不需要</strong> <code>ROLE_</code> 前缀。Spring Security 在处理时会自动为你添加 <code>ROLE_</code> 前缀进行匹配。</li>
<li><strong>逻辑</strong>: 同样，拥有参数列表中<strong>任意一个</strong>角色的用户即可访问。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.annotation.security.RolesAllowed;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拥有 ROLE_ADMIN 角色的用户可以访问</span></span><br><span class="line"><span class="meta">@RolesAllowed(&quot;ADMIN&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resetSystem</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拥有 ROLE_ADMIN 或 ROLE_MANAGER 角色的用户可以访问</span></span><br><span class="line"><span class="meta">@RolesAllowed(&#123;&quot;ADMIN&quot;, &quot;MANAGER&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> DashboardData <span class="title function_">getDashboard</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-4-如何选择？"><a href="#3-3-4-如何选择？" class="headerlink" title="3.3.4 如何选择？"></a>3.3.4 如何选择？</h4><ul>
<li><strong>首选 <code>@PreAuthorize</code></strong>: 在绝大多数情况下，<code>@PreAuthorize</code> 都是最佳选择。它的 SpEL 功能提供了无与伦比的灵活性，能够满足几乎所有的授权需求，尤其是需要动态判断和对象级别访问控制的场景。</li>
<li><strong>使用 <code>@PostAuthorize</code></strong>: 仅在需要基于方法<strong>返回值</strong>进行判断时才考虑使用，并注意其副作用。</li>
<li><strong>使用 <code>@Secured</code> 或 <code>@RolesAllowed</code></strong>: 如果你的授权需求非常简单，仅仅是基于静态的角色列表，并且你和你的团队喜欢这种更简洁的声明方式，那么可以使用它们。<code>@RolesAllowed</code> 因为是 Java EE 标准的一部分，可能在某些追求标准化的项目中更受欢迎。但总的来说，它们的功能是 <code>@PreAuthorize(&quot;hasAnyRole(...)&quot;)</code> 的一个子集。</li>
</ul>
<hr>
<h3 id="3-4-在授权中使用-SpEL-表达式"><a href="#3-4-在授权中使用-SpEL-表达式" class="headerlink" title="3.4 在授权中使用 SpEL 表达式"></a>3.4 在授权中使用 SpEL 表达式</h3><p>SpEL 是一种功能强大的表达式语言，它允许在运行时查询和操作对象图。在 Spring Security 中，SpEL 被集成到了 <code>@PreAuthorize</code> 和 <code>@PostAuthorize</code> 等注解中，将静态的授权规则提升到了一个全新的、动态的维度。这使得我们能够编写出与当前请求上下文、方法参数甚至其他业务逻辑紧密相关的复杂授权规则。</p>
<h4 id="3-4-1-SpEL-表达式的核心能力"><a href="#3-4-1-SpEL-表达式的核心能力" class="headerlink" title="3.4.1 SpEL 表达式的核心能力"></a>3.4.1 SpEL 表达式的核心能力</h4><p>在 Spring Security 的方法安全表达式中，SpEL 提供了一个强大的“根对象”（Root Object）作为评估上下文，我们可以通过它访问各种有用的内置对象和函数。</p>
<h5 id="1-内置的安全表达式"><a href="#1-内置的安全表达式" class="headerlink" title="1. 内置的安全表达式"></a>1. 内置的安全表达式</h5><p>Spring Security 提供了一系列内置的、可以直接使用的安全相关函数，这些函数极大地方便了我们编写授权规则。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>等价的 URL 配置方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>hasRole(&#39;ROLE_NAME&#39;)</code></td>
<td><code>.hasRole(&quot;NAME&quot;)</code></td>
<td>判断当前用户是否拥有指定角色。 <strong>注意</strong>: 角色名通常需要 <code>ROLE_</code> 前缀。</td>
</tr>
<tr>
<td><code>hasAnyRole(&#39;R1&#39;, &#39;R2&#39;)</code></td>
<td><code>.hasAnyRole(&quot;R1&quot;,&quot;R2&quot;)</code></td>
<td>判断用户是否拥有列表中的任意一个角色。</td>
</tr>
<tr>
<td><code>hasAuthority(&#39;AUTH&#39;)</code></td>
<td><code>.hasAuthority(&quot;AUTH&quot;)</code></td>
<td>判断用户是否拥有指定权限。</td>
</tr>
<tr>
<td><code>hasAnyAuthority(&#39;A1&#39;,&#39;A2&#39;)</code></td>
<td><code>.hasAnyAuthority(&quot;A1&quot;,&quot;A2&quot;)</code></td>
<td>判断用户是否拥有列表中的任意一个权限。</td>
</tr>
<tr>
<td><code>permitAll</code></td>
<td><code>.permitAll()</code></td>
<td>总是返回 <code>true</code>，允许所有访问。</td>
</tr>
<tr>
<td><code>denyAll</code></td>
<td><code>.denyAll()</code></td>
<td>总是返回 <code>false</code>，拒绝所有访问。</td>
</tr>
<tr>
<td><code>isAuthenticated()</code></td>
<td><code>.authenticated()</code></td>
<td>判断用户是否已经认证（非匿名）。</td>
</tr>
<tr>
<td><code>isAnonymous()</code></td>
<td></td>
<td>判断用户是否是匿名用户。</td>
</tr>
<tr>
<td><code>isRememberMe()</code></td>
<td></td>
<td>判断用户是否是通过“记住我”功能认证的。</td>
</tr>
<tr>
<td><code>isFullyAuthenticated()</code></td>
<td></td>
<td>判断用户是否经过了完整的认证流程（而不是通过“记住我”）。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等同于 @Secured(&quot;ROLE_ADMIN&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ROLE_ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAdminAction</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求用户必须是完整登录，而不是“记住我”状态</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;isFullyAuthenticated()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String newPassword)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-访问-authentication-对象"><a href="#2-访问-authentication-对象" class="headerlink" title="2. 访问 authentication 对象"></a>2. 访问 <code>authentication</code> 对象</h5><p>SpEL 表达式可以直接访问当前 <code>SecurityContext</code> 中的 <code>authentication</code> 对象。这是实现动态判断的基础。</p>
<ul>
<li><code>authentication.name</code>: 获取当前用户名。</li>
<li><code>authentication.principal</code>: 获取当前用户主体（Principal）。如果使用的是 <code>UserDetails</code>，那么这个对象就是你的 <code>UserDetails</code> 实例。</li>
<li><code>authentication.authorities</code>: 获取当前用户的权限集合。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有用户名为 &#x27;superadmin&#x27; 的用户才能执行</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;authentication.name == &#x27;superadmin&#x27;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSuperAdminTask</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设你的 UserDetails 实现类有一个 getEmail() 方法</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;authentication.principal.email.endsWith(&#x27;@mycompany.com&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessInternalResource</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-4-2-动态判断：结合方法参数"><a href="#3-4-2-动态判断：结合方法参数" class="headerlink" title="3.4.2 动态判断：结合方法参数"></a>3.4.2 动态判断：结合方法参数</h4><p>SpEL 最强大的功能之一是能够引用被拦截方法的参数。这使得授权规则可以根据每次方法调用的具体上下文来动态决策。</p>
<p><strong>语法</strong>：通过 <code>#参数名</code> 的形式来引用。</p>
<h5 id="1-“所有权”-检查"><a href="#1-“所有权”-检查" class="headerlink" title="1. “所有权” 检查"></a>1. “所有权” 检查</h5><p>这是最经典的用例：判断当前用户是否是某个数据对象的“所有者”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：用户只能查看自己的账户信息</span></span><br><span class="line"><span class="comment">// #accountId 引用了方法的 accountId 参数</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#accountId == authentication.principal.accountId&quot;)</span> </span><br><span class="line"><span class="comment">// 假设你的 UserDetails 实现中有 getAccountId() 方法</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">getAccountDetails</span><span class="params">(Long accountId)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景：用户只能更新自己的博客文章</span></span><br><span class="line"><span class="comment">// #post.authorUsername 访问了 post 对象的 authorUsername 属性</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#post.authorUsername == authentication.name or hasRole(&#x27;ROLE_MODERATOR&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePost</span><span class="params">(Post post)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-使用-P-或-Param-注解为参数命名"><a href="#2-使用-P-或-Param-注解为参数命名" class="headerlink" title="2. 使用 @P 或 @Param 注解为参数命名"></a>2. 使用 <code>@P</code> 或 <code>@Param</code> 注解为参数命名</h5><p>如果你的项目编译时没有保留参数名（例如，使用旧版本的 Java 或特定的编译设置），SpEL 可能无法通过 <code>#参数名</code> 找到参数。这时，可以使用 <code>@P</code> (Spring Security 提供) 或 <code>@Param</code> (Spring Data 提供) 注解来显式地为参数命名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.access.prepost.PreAuthorize;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.parameters.P;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#user.username == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeUserPassword</span><span class="params">(<span class="meta">@P(&quot;user&quot;)</span> User user, String newPassword)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很好的编程习惯，因为它使得代码意图更明确，且不受编译选项的影响。</p>
<hr>
<h4 id="3-4-3-访问-Bean-方法进行复杂判断"><a href="#3-4-3-访问-Bean-方法进行复杂判断" class="headerlink" title="3.4.3 访问 Bean 方法进行复杂判断"></a>3.4.3 访问 Bean 方法进行复杂判断</h4><p>当授权逻辑变得非常复杂，不适合写在一个长长的 SpEL 表达式里时，最佳实践是<strong>将授权逻辑封装到一个单独的 Spring Bean 中</strong>，然后在 SpEL 中调用这个 Bean 的方法。</p>
<h5 id="1-创建一个授权服务-Bean"><a href="#1-创建一个授权服务-Bean" class="headerlink" title="1. 创建一个授权服务 Bean"></a>1. 创建一个授权服务 Bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;securityService&quot;)</span> <span class="comment">// 给 Bean 一个明确的名字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PostRepository postRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前用户是否是某篇文章的作者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPostOwner</span><span class="params">(Authentication authentication, Long postId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">currentUsername</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">        <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> postRepository.findById(postId).orElse(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (post == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 或者抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> post.getAuthorUsername().equals(currentUsername);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更复杂的逻辑，例如检查用户是否在某个项目团队中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInProjectTeam</span><span class="params">(Authentication authentication, Long projectId)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 查询数据库，判断用户是否是项目成员 ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-在-SpEL-中调用-Bean-的方法"><a href="#2-在-SpEL-中调用-Bean-的方法" class="headerlink" title="2. 在 SpEL 中调用 Bean 的方法"></a>2. 在 SpEL 中调用 Bean 的方法</h5><p><strong>语法</strong>：通过 <code>@beanName.methodName(arguments)</code> 的形式调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 securityService Bean 的 isPostOwner 方法</span></span><br><span class="line"><span class="comment">// 将当前的 authentication 对象和方法的 postId 参数传递过去</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@securityService.isPostOwner(authentication, #postId)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">editPost</span><span class="params">(Long postId, String content)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@securityService.isInProjectTeam(authentication, #projectId)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ProjectDashboard <span class="title function_">getProjectDashboard</span><span class="params">(Long projectId)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种方法的巨大优势</strong>:</p>
<ul>
<li><strong>关注点分离</strong>: 将复杂的授权逻辑从业务方法的注解中抽离出来，放到了专门的 <code>SecurityService</code> 中，使得业务代码更干净。</li>
<li><strong>可重用性</strong>: <code>isPostOwner</code> 这样的方法可以在多个需要此项检查的地方被重复调用。</li>
<li><strong>可测试性</strong>: <code>SecurityService</code> 是一个普通的 Spring Bean，可以像其他 Service 一样被轻松地进行单元测试。</li>
<li><strong>无限扩展</strong>: 你可以在这个 Bean 中注入任何其他服务（如 <code>UserRepository</code>, <code>ProjectRepository</code>），编写任意复杂的 Java 代码来实现你的授权判断，而不仅仅局限于 SpEL 的语法。</li>
</ul>
<hr>
<h3 id="3-5-访问控制决策者（高级）"><a href="#3-5-访问控制决策者（高级）" class="headerlink" title="3.5 访问控制决策者（高级）"></a>3.5 访问控制决策者（高级）</h3><p>在我们通过 <code>.authorizeHttpRequests()</code> 或 <code>@PreAuthorize</code> 声明授权规则时，这些高级的配置最终会被 Spring Security 翻译成底层的决策逻辑。在传统的 Spring Security 架构中，这个决策过程的核心就是 <code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code>。</p>
<h4 id="3-5-1-核心概念：投票决策模型"><a href="#3-5-1-核心概念：投票决策模型" class="headerlink" title="3.5.1 核心概念：投票决策模型"></a>3.5.1 核心概念：投票决策模型</h4><p>想象一下一个议会正在对一项法案进行投票。</p>
<ul>
<li><strong>法案</strong>: 相当于一个访问请求，例如“用户 Bob 想要访问 <code>/admin/dashboard</code>”。</li>
<li><strong>议员 (Voter)</strong>: 每个议员都有自己的专长和立场。有的只关心角色，有的只关心IP地址，有的只关心时间。</li>
<li><strong>议长 (Manager)</strong>: 议长不亲自投票，他负责组织投票，并根据议会规则（如“简单多数通过”或“一票否决”）来宣布最终结果。</li>
</ul>
<p>Spring Security 的授权决策机制就是这个模型的完美体现。</p>
<ul>
<li><strong><code>AccessDecisionVoter</code> (投票者)</strong>: 对应“议员”。</li>
<li><strong><code>AccessDecisionManager</code> (决策管理器)</strong>: 对应“议长”。</li>
</ul>
<hr>
<h4 id="3-5-2-AccessDecisionVoter-接口"><a href="#3-5-2-AccessDecisionVoter-接口" class="headerlink" title="3.5.2 AccessDecisionVoter&lt;T&gt; 接口"></a>3.5.2 <code>AccessDecisionVoter&lt;T&gt;</code> 接口</h4><p><code>AccessDecisionVoter</code> 是执行具体投票逻辑的组件。</p>
<p><strong>核心方法</strong>:</p>
<ol>
<li><strong><code>boolean supports(ConfigAttribute attribute)</code></strong>:<ul>
<li>在投票前，<code>AccessDecisionManager</code> 会用这个方法来询问 Voter：“你关心这个类型的权限配置吗？”</li>
<li><code>ConfigAttribute</code> 是对权限规则（如 <code>ROLE_ADMIN</code>）的抽象。</li>
<li>例如，<code>RoleVoter</code> 只会对代表角色的 <code>ConfigAttribute</code> 返回 <code>true</code>。</li>
</ul>
</li>
<li><strong><code>boolean supports(Class&lt;?&gt; clazz)</code></strong>:<ul>
<li>询问 Voter：“你能对这种类型的受保护对象（Secure Object）进行投票吗？”</li>
<li>例如，<code>WebExpressionVoter</code> 会对 <code>Request</code> 对象返回 <code>true</code>，而方法安全的 Voter 会对 <code>MethodInvocation</code> 返回 <code>true</code>。</li>
</ul>
</li>
<li><strong><code>int vote(Authentication authentication, T object, Collection&lt;ConfigAttribute&gt; attributes)</code></strong>:<ul>
<li>这是<strong>核心的投票方法</strong>。如果前面的 <code>supports</code> 方法都返回 <code>true</code>，<code>AccessDecisionManager</code> 就会调用它。</li>
<li><strong>参数</strong>:<ul>
<li><code>authentication</code>: 当前用户的认证信息。</li>
<li><code>object</code>: 正在被访问的受保护对象（如 <code>FilterInvocation</code>，包含了 <code>request</code> 和 <code>response</code>）。</li>
<li><code>attributes</code>: 保护该对象所需的所有权限配置的集合。</li>
</ul>
</li>
<li><strong>返回值 (int)</strong>:<ul>
<li><code>AccessDecisionVoter.ACCESS_GRANTED</code> (1): <strong>赞成</strong>。表示根据我的逻辑，应该允许访问。</li>
<li><code>AccessDecisionVoter.ACCESS_DENIED</code> (-1): <strong>反对</strong>。表示根据我的逻辑，应该拒绝访问。</li>
<li><code>AccessDecisionVoter.ACCESS_ABSTAIN</code> (0): <strong>弃权</strong>。表示这个规则我不关心，让其他 Voter 决定吧。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>常见的 Voter 实现</strong>:</p>
<ul>
<li><code>RoleVoter</code>: 可能是最简单的 Voter。它检查用户的 <code>GrantedAuthority</code> 是否匹配任何以 <code>ROLE_</code> 前缀开头的 <code>ConfigAttribute</code>。如果匹配，投赞成票；否则弃权。</li>
<li><code>AuthenticatedVoter</code>: 检查用户是否是匿名、通过“记住我”认证，或完全认证，并根据配置（如 <code>IS_AUTHENTICATED_FULLY</code>）进行投票。</li>
<li><code>WebExpressionVoter</code>: <strong>功能最强大的 Voter</strong>。它负责解析和执行 SpEL 表达式（如 <code>hasRole(&#39;ADMIN&#39;) and hasIpAddress(&#39;192.168.1.0/24&#39;)</code>）。</li>
</ul>
<hr>
<h4 id="3-5-3-AccessDecisionManager-接口"><a href="#3-5-3-AccessDecisionManager-接口" class="headerlink" title="3.5.3 AccessDecisionManager 接口"></a>3.5.3 <code>AccessDecisionManager</code> 接口</h4><p><code>AccessDecisionManager</code> 是授权决策的最终裁决者。它管理一个 <code>AccessDecisionVoter</code> 列表，并根据投票结果做出最终决定。</p>
<p><strong>核心方法</strong>:</p>
<ul>
<li><strong><code>void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</code></strong>:<ul>
<li>这是唯一的决策方法。</li>
<li><strong>职责</strong>:<ol>
<li>遍历其管理的 <code>AccessDecisionVoter</code> 列表。</li>
<li>调用每个 Voter 的 <code>vote</code> 方法来收集投票。</li>
<li>根据自己的内部策略，对投票结果进行汇总和裁决。</li>
<li>如果最终决定是<strong>拒绝</strong>，它必须抛出 <code>AccessDeniedException</code>。</li>
<li>如果最终决定是<strong>允许</strong>，它会正常返回，不做任何事情，请求将继续执行。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>常见的 Manager 实现 (决策策略)</strong>:</p>
<ol>
<li><strong><code>AffirmativeBased</code> (默认策略)</strong><ul>
<li><strong>“一票赞成就通过”</strong>。</li>
<li><strong>逻辑</strong>:<ul>
<li>只要有一个 Voter 投了 <code>ACCESS_GRANTED</code> (赞成票)，就立即做出“允许”的决定，不再询问其他 Voter。</li>
<li>如果没有赞成票，并且 <code>isAllowIfAllAbstainDecisions()</code> 为 <code>false</code>（默认），则抛出 <code>AccessDeniedException</code>。</li>
<li><strong>注意</strong>: <code>AffirmativeBased</code> 不会因为有 <code>ACCESS_DENIED</code> (反对票) 而立即拒绝。它只关心有没有赞成票。</li>
</ul>
</li>
<li><strong>优点</strong>: 灵活。你可以组合多个独立的、可选的授权条件（例如，角色、IP、时间），满足任何一个即可。</li>
</ul>
</li>
<li><strong><code>ConsensusBased</code></strong><ul>
<li><strong>“少数服从多数”</strong>。</li>
<li><strong>逻辑</strong>:<ul>
<li>统计所有非弃权票。</li>
<li>如果赞成票严格多于反对票，则“允许”。</li>
<li>如果反对票多于或等于赞成票，则“拒绝”。</li>
<li>如果全是弃权票，根据 <code>isAllowIfAllAbstainDecisions()</code> 决定。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>UnanimousBased</code></strong><ul>
<li><strong>“一票否决制”</strong>。</li>
<li><strong>逻辑</strong>:<ul>
<li>只要有一个 Voter 投了 <code>ACCESS_DENIED</code> (反对票)，就立即做出“拒绝”的决定。</li>
<li>如果没有反对票，但至少有一个赞成票，则“允许”。</li>
<li>如果全是弃权票，根据 <code>isAllowIfAllAbstainDecisions()</code> 决定。</li>
</ul>
</li>
<li><strong>优点</strong>: 严格。适用于需要满足所有安全条件的场景。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-5-4-现代架构的演进-AuthorizationManager"><a href="#3-5-4-现代架构的演进-AuthorizationManager" class="headerlink" title="3.5.4 现代架构的演进 (AuthorizationManager)"></a>3.5.4 现代架构的演进 (<code>AuthorizationManager</code>)</h4><p>随着 Spring Security 的发展，特别是函数式配置风格的引入，<code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> 这套复杂的投票机制被一个更简洁的接口所取代：<strong><code>AuthorizationManager</code></strong>。</p>
<ul>
<li><strong><code>AuthorizationManager&lt;T&gt;</code></strong> 接口只有一个方法: <code>AuthorizationDecision check(Supplier&lt;Authentication&gt; authentication, T object)</code>。</li>
<li>它不再有“投票”和“弃权”的概念，而是直接返回一个 <code>AuthorizationDecision</code> 对象，该对象包含一个布尔值（<code>isGranted()</code>）。如果决策是拒绝，<code>AuthorizationManager</code> 的实现通常会直接抛出 <code>AccessDeniedException</code>。</li>
</ul>
<p><strong>关系</strong>:</p>
<p>你可以将 <code>AuthorizationManager</code> 看作是 <code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> 的<strong>结合体和简化版</strong>。我们通过 <code>.authorizeHttpRequests()</code> 提供的 Lambda 表达式，实际上是在动态地构建和组合各种 <code>AuthorizationManager</code> 的实现。</p>
<p>例如，<code>.hasRole(&quot;ADMIN&quot;)</code> 内部会创建一个 <code>AuthorityAuthorizationManager</code> 的实例。</p>
<p><strong>为什么还要了解旧模型？</strong></p>
<ol>
<li><strong>理解历史和设计哲学</strong>: 投票模型是 Spring Security 设计哲学的核心，理解它有助于你更深入地理解框架的行为。</li>
<li><strong>维护老项目</strong>: 大量现存的 Spring Security 项目仍然在使用基于 XML 或 <code>WebSecurityConfigurerAdapter</code> 的配置，这些配置底层就是 <code>AccessDecisionManager</code>。</li>
<li><strong>深度定制</strong>: 如果你需要实现非常独特的、标准 <code>AuthorizationManager</code> 无法满足的授权逻辑，你可能需要自定义 <code>AccessDecisionVoter</code> 和 <code>AccessDecisionManager</code>，并将它们集成到安全配置中。</li>
</ol>
<hr>
<h2 id="4-Web-安全与高级配置"><a href="#4-Web-安全与高级配置" class="headerlink" title="4. Web 安全与高级配置"></a>4. Web 安全与高级配置</h2><h3 id="4-1-CSRF-跨站请求伪造-防护"><a href="#4-1-CSRF-跨站请求伪造-防护" class="headerlink" title="4.1 CSRF (跨站请求伪造) 防护"></a>4.1 CSRF (跨站请求伪造) 防护</h3><p>CSRF (Cross-Site Request Forgery) 是一种常见的、极具欺骗性的网络攻击方式。攻击者通过诱导受害者在一个已登录的网站上执行非本意的操作，从而达到恶意目的。Spring Security 默认开启了强大的 CSRF 防护机制来应对这种威胁。</p>
<h4 id="4-1-1-CSRF-攻击原理"><a href="#4-1-1-CSRF-攻击原理" class="headerlink" title="4.1.1 CSRF 攻击原理"></a>4.1.1 CSRF 攻击原理</h4><p>要理解 CSRF 防护，首先必须明白攻击是如何发生的。</p>
<p><strong>攻击场景</strong>:</p>
<ol>
<li><p><strong>用户登录可信网站</strong>: 用户 Bob 登录了他的网上银行网站 <code>bank.com</code>，并且没有退出。<code>bank.com</code> 将 Bob 的会话信息（Session ID）存储在了浏览器的 Cookie 中。</p>
</li>
<li><p><strong>用户访问恶意网站</strong>: 之后，Bob 浏览了一个恶意网站 <code>evil.com</code>。这个网站的页面上可能包含一个隐藏的表单或一个诱导性的图片链接，其目标指向 <code>bank.com</code> 的一个敏感操作，比如转账。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 恶意网站 evil.com 的页面内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>超值优惠，点击领取！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方式一：一个自动提交的隐藏表单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;csrf-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;https://bank.com/transfer&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;toAccount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mallory-Account-ID&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;csrf-form&#x27;</span>).<span class="title function_">submit</span>();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方式二：一个看似无害的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://bank.com/transfer?toAccount=Mallory-Account-ID&amp;amount=1000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>(注: GET 请求虽然不规范，但也能触发某些不安全的敏感操作)</em></p>
</li>
<li><p><strong>浏览器自动携带 Cookie</strong>: 当 Bob 的浏览器加载 <code>evil.com</code> 的页面时，它会解析到这个表单或图片，并向 <code>bank.com/transfer</code> 发起一个请求。根据浏览器的同源策略，<strong>在跨域请求时，浏览器会自动携带目标域 (<code>bank.com</code>) 的 Cookie</strong>。</p>
</li>
<li><p><strong>攻击成功</strong>: <code>bank.com</code> 的服务器收到了这个转账请求。它检查请求中的 Cookie，发现是 Bob 的有效会话，于是认为这是 Bob 本人发起的合法操作，便执行了转账。Bob 在毫不知情的情况下，钱就被转走了。</p>
</li>
</ol>
<p><strong>攻击的核心</strong>: <strong>攻击者利用了浏览器会自动携带 Cookie 的特性，并借助用户的登录状态，伪造了用户的请求。</strong> 服务器无法分辨这个请求是用户在 <code>bank.com</code> 官网上点击按钮触发的，还是在 <code>evil.com</code> 上被动触发的。</p>
<hr>
<h4 id="4-1-2-Spring-Security-的-CSRF-防护机制：同步器令牌模式-Synchronizer-Token-Pattern"><a href="#4-1-2-Spring-Security-的-CSRF-防护机制：同步器令牌模式-Synchronizer-Token-Pattern" class="headerlink" title="4.1.2 Spring Security 的 CSRF 防护机制：同步器令牌模式 (Synchronizer Token Pattern)"></a>4.1.2 Spring Security 的 CSRF 防护机制：同步器令牌模式 (Synchronizer Token Pattern)</h4><p>Spring Security 采用业界标准的<strong>同步器令牌模式</strong>来防御 CSRF 攻击。</p>
<p><strong>工作原理</strong>:</p>
<ol>
<li><strong>服务器生成 Token</strong>: 当用户访问网站时（特别是访问包含表单的页面），服务器会生成一个随机的、不可预测的字符串，称为 <strong>CSRF Token</strong>。</li>
<li><strong>Token 双重分发</strong>:<ul>
<li><strong>一份存储在服务器端</strong>: 这个 Token 会被存储在用户的 <code>HttpSession</code> 中。</li>
<li><strong>一份发送给客户端</strong>: 这个 Token 会被放入页面的某个地方，通常是一个隐藏的表单字段。</li>
</ul>
</li>
<li><strong>客户端提交 Token</strong>: 当用户提交表单时，这个隐藏字段中的 CSRF Token 会作为请求参数，随同其他数据一起发送回服务器。</li>
<li><strong>服务器端验证</strong>: 服务器收到请求后，会执行以下比较：<ul>
<li>从请求参数中获取客户端提交的 Token。</li>
<li>从当前用户的 <code>HttpSession</code> 中获取服务器端存储的 Token。</li>
<li><strong>比较两者是否完全一致</strong>。</li>
</ul>
</li>
<li><strong>决策</strong>:<ul>
<li><strong>如果一致</strong>: 说明请求确实是由网站自己的页面发起的，是合法请求，予以处理。</li>
<li><strong>如果不一致或请求中没有 Token</strong>: 说明这很可能是一个伪造的请求（因为恶意网站 <code>evil.com</code> 无法获取到这个随机 Token），服务器会拒绝该请求，通常返回 <strong>403 Forbidden</strong>。</li>
</ul>
</li>
</ol>
<p>这个机制之所以有效，是因为攻击者所在的恶意网站 <code>evil.com</code> 受到浏览器同源策略的限制，无法通过脚本读取到 <code>bank.com</code> 页面内容或 Cookie 中精确的 Token 值，因此无法在伪造的请求中包含正确的 Token。</p>
<hr>
<h4 id="4-1-3-Spring-Security-的-CsrfFilter-与-CsrfToken"><a href="#4-1-3-Spring-Security-的-CsrfFilter-与-CsrfToken" class="headerlink" title="4.1.3 Spring Security 的 CsrfFilter 与 CsrfToken"></a>4.1.3 Spring Security 的 <code>CsrfFilter</code> 与 <code>CsrfToken</code></h4><ul>
<li><strong><code>CsrfFilter</code></strong>:<ul>
<li>这是 Spring Security 过滤器链中负责 CSRF 防护的核心组件。</li>
<li>它在 <code>UsernamePasswordAuthenticationFilter</code> 等执行实际操作的过滤器之前运行。</li>
<li><strong>职责</strong>:<ul>
<li>对所有“不安全”的 HTTP 方法（如 <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code>）进行拦截。它默认会放行 <code>GET</code>, <code>HEAD</code>, <code>TRACE</code>, <code>OPTIONS</code> 请求，因为这些方法被认为是幂等的，不应改变服务器状态。</li>
<li>执行上述的 Token 比较逻辑。如果验证失败，它会立即中断请求链，并抛出 <code>InvalidCsrfTokenException</code> 或 <code>MissingCsrfTokenException</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>CsrfToken</code></strong>:<ul>
<li>这是一个接口，代表了 CSRF Token 本身。它包含了三个关键信息：<ul>
<li><code>getToken()</code>: 获取 Token 的字符串值。</li>
<li><code>getHeaderName()</code>: 获取期望在 HTTP Header 中传递 Token 时使用的 Header 名称（默认为 <code>X-CSRF-TOKEN</code>）。</li>
<li><code>getParameterName()</code>: 获取期望在请求参数中传递 Token 时使用的参数名称（默认为 <code>_csrf</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-4-与前端的集成"><a href="#4-1-4-与前端的集成" class="headerlink" title="4.1.4 与前端的集成"></a>4.1.4 与前端的集成</h4><p>为了让 CSRF 防护正常工作，前端必须正确地获取并提交 CSRF Token。</p>
<h5 id="1-Thymeleaf-服务器端渲染"><a href="#1-Thymeleaf-服务器端渲染" class="headerlink" title="1. Thymeleaf (服务器端渲染)"></a>1. Thymeleaf (服务器端渲染)</h5><p>Thymeleaf 对 Spring Security 的 CSRF 提供了无缝的、自动化的集成。</p>
<ul>
<li><p><strong>表单集成</strong>:<br>只要你在 <code>form</code> 标签上使用了 <code>th:action</code>，并且你的应用启用了 CSRF 防护，Thymeleaf 会<strong>自动</strong>在生成的 HTML 表单中添加一个隐藏字段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/process&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... other inputs ... --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 下面这行是由 Thymeleaf 自动生成的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_csrf&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你几乎不需要做任何额外的工作，这是最简单、最推荐的方式。</p>
</li>
<li><p><strong>Meta 标签集成 (用于 AJAX)</strong>:<br>为了方便在 JavaScript 中使用 Token，可以在页面的 <code>&lt;head&gt;</code> 部分添加 meta 标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;_csrf&quot;</span> <span class="attr">th:content</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;_csrf_header&quot;</span> <span class="attr">th:content</span>=<span class="string">&quot;$&#123;_csrf.headerName&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，JavaScript 就可以轻松地读取这些 meta 标签来获取 Token 和 Header 名称。</p>
</li>
</ul>
<hr>
<h5 id="2-AJAX-前后端分离"><a href="#2-AJAX-前后端分离" class="headerlink" title="2. AJAX (前后端分离)"></a>2. AJAX (前后端分离)</h5><p>对于使用 JavaScript（如 Fetch API, Axios）发起的 AJAX 请求，你需要手动将 CSRF Token 添加到请求中。有两种标准方式：</p>
<p><strong>a. 作为请求参数 (Request Parameter)</strong></p>
<p>适用于 <code>application/x-www-form-urlencoded</code> 类型的请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设已通过 meta 标签获取</span></span><br><span class="line"><span class="keyword">const</span> token = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>();</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;field1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;_csrf&#x27;</span>, token); <span class="comment">// 将 token 作为参数添加</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/data&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: formData</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>b. 作为请求头 (Request Header) - 推荐方式</strong></p>
<p>这是更现代、更通用的方式，尤其适用于发送 JSON 数据的请求 (<code>application/json</code>)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设已通过 meta 标签获取</span></span><br><span class="line"><span class="keyword">const</span> token = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> headerName = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf_header&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Axios 的示例</span></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/api/data&#x27;</span>, </span><br><span class="line">    &#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">            [headerName]: token <span class="comment">// 将 token 放入指定的 header</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Fetch API 的示例</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/data&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        [headerName]: token</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>全局配置 (如 Axios Interceptors)</strong></p>
<p>在实际项目中，最好的做法是配置一个全局的请求拦截器，自动为所有不安全的请求添加 CSRF Token Header，而无需在每个请求中手动添加。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Axios 拦截器示例</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> headerName = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf_header&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (token &amp;&amp; headerName) &#123;</span><br><span class="line">        config.<span class="property">headers</span>[headerName] = token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>禁用 CSRF</strong></p>
<p>在某些特定场景下（例如，你正在构建一个无状态的、基于 Token 认证的 REST API，并且不使用 Cookie 进行会话管理），你可能需要禁用 CSRF 防护。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .csrf(csrf -&gt; csrf.disable()); <span class="comment">// 禁用 CSRF 防护</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>警告</strong>: 除非你完全确定你的认证机制（如 JWT in Header）不受 CSRF 攻击影响，否则不要轻易禁用它。如果你的应用同时支持 Cookie 认证和 API Token 认证，你需要更精细的配置来只对 API 部分禁用 CSRF。</p>
<hr>
<h3 id="4-2-CORS-跨域资源共享-配置"><a href="#4-2-CORS-跨域资源共享-配置" class="headerlink" title="4.2 CORS (跨域资源共享) 配置"></a>4.2 CORS (跨域资源共享) 配置</h3><p>在<code>Spring全家桶-SpringWeb</code>中的1.5.4节介绍过了跨域问题，那么SpringSecurity是如何解决的呢。</p>
<h4 id="4-2-1-启用-CORS-支持-cors"><a href="#4-2-1-启用-CORS-支持-cors" class="headerlink" title="4.2.1 启用 CORS 支持: .cors()"></a>4.2.1 启用 CORS 支持: <code>.cors()</code></h4><p>首先，你需要在你的 <code>SecurityFilterChain</code> 配置中调用 <code>.cors()</code> 方法来启用 CORS 支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .cors(Customizer.withDefaults()) <span class="comment">// 启用 CORS，并使用默认配置</span></span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.cors()</code> 的作用是在 Spring Security 的过滤器链中添加一个 <code>CorsFilter</code>。这个过滤器会尝试从 Spring 的应用上下文中查找一个名为 <code>corsConfigurationSource</code> 的 Bean。如果找到了，它就会使用这个 Bean 提供的配置来处理 CORS 请求。</p>
<h4 id="4-2-2-提供-CORS-配置-CorsConfigurationSource-Bean"><a href="#4-2-2-提供-CORS-配置-CorsConfigurationSource-Bean" class="headerlink" title="4.2.2 提供 CORS 配置: CorsConfigurationSource Bean"></a>4.2.2 提供 CORS 配置: <code>CorsConfigurationSource</code> Bean</h4><p>所以，下一步就是定义这个 <code>corsConfigurationSource</code> Bean。这是配置 CORS 规则的核心。</p>
<p><strong>推荐方式：创建一个 <code>CorsConfigurationSource</code> Bean</strong></p>
<p>这种方式最灵活，允许你根据不同的请求路径应用不同的 CORS 策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsConfigurationSource <span class="title function_">corsConfigurationSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 CorsConfiguration 对象</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 设置允许的源</span></span><br><span class="line">        <span class="comment">// configuration.setAllowedOrigins(Arrays.asList(&quot;http://localhost:3000&quot;, &quot;https://app.my-domain.com&quot;));</span></span><br><span class="line">        <span class="comment">// 对于需要携带凭证（如Cookie）的请求，不能使用 &quot;*&quot;，必须指定具体的源</span></span><br><span class="line">        configuration.setAllowedOrigins(List.of(<span class="string">&quot;http://localhost:3000&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置允许的 HTTP 方法</span></span><br><span class="line">        configuration.setAllowedMethods(Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 设置允许的请求头</span></span><br><span class="line">        <span class="comment">// &quot;*&quot; 表示允许所有头，但在生产环境中建议明确指定</span></span><br><span class="line">        configuration.setAllowedHeaders(Arrays.asList(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;X-Requested-With&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 设置是否允许发送 Cookie 等凭证</span></span><br><span class="line">        <span class="comment">// 当设置为 true 时，allowedOrigins 不能为 &quot;*&quot;</span></span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 暴露哪些响应头给前端JS，让其可以访问</span></span><br><span class="line">        <span class="comment">// configuration.setExposedHeaders(Arrays.asList(&quot;header1&quot;, &quot;header2&quot;));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 7. 设置预检请求的有效期，单位为秒。在此期间，浏览器无需为相同的跨域请求再次发送预检请求</span></span><br><span class="line">        configuration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 创建 UrlBasedCorsConfigurationSource 对象，注册 CORS 配置</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        <span class="comment">// 对所有 URL 路径应用上述配置</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, configuration);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>setAllowedOrigins()</code>: 设置允许跨域请求的来源。在开发环境中，这通常是你的前端开发服务器地址（如 <code>http://localhost:3000</code>）。</li>
<li><code>setAllowedMethods()</code>: 设置允许的 HTTP 方法。</li>
<li><code>setAllowedHeaders()</code>: 设置允许的请求头。如果你的前端需要发送自定义头（如 <code>Authorization</code> for JWT），必须在这里声明。</li>
<li><code>setAllowCredentials(true)</code>: <strong>非常重要</strong>。如果你的前后端交互需要使用 Cookie 或 <code>Authorization</code> 头来进行会话管理和认证，必须将此项设为 <code>true</code>。同时，前端的 <code>axios</code> 或 <code>fetch</code> 请求也需要设置 <code>withCredentials: true</code>。</li>
<li><code>registerCorsConfiguration(&quot;/**&quot;, configuration)</code>: 将我们创建的 <code>CorsConfiguration</code> 应用到所有的 URL 路径 (<code>/**</code>) 上。你也可以为不同的路径（如 <code>/api/**</code> 和 <code>/public/**</code>）注册不同的 CORS 配置。</li>
</ul>
<p><strong>另一种配置方式：<code>WebMvcConfigurer</code></strong></p>
<p>在SpringWeb中介绍了此方法，当同时存在 <code>WebMvcConfigurer</code> 的 CORS 配置和 Spring Security 的 CORS 配置时，<strong>Spring Security 的配置会优先生效</strong>，因为它通过 <code>CorsFilter</code> 在过滤器链的更早阶段处理了请求。因此，<strong>推荐使用 <code>CorsConfigurationSource</code> Bean 的方式，将所有安全相关的配置集中在 Spring Security 中</strong>。</p>
<hr>
<h3 id="4-3-Session-管理"><a href="#4-3-Session-管理" class="headerlink" title="4.3 Session 管理"></a>4.3 Session 管理</h3><p>在传统的有状态（Stateful）Web 应用中，Session 是服务器用来跟踪和维持单个用户会话状态的核心机制。当用户首次登录成功后，服务器会创建一个 Session 对象，并生成一个唯一的 Session ID。这个 Session ID 通常通过 Cookie（名为 <code>JSESSIONID</code>）发送给浏览器。在后续的请求中，浏览器会自动携带这个 Cookie，服务器通过 Session ID 就能找到对应的 Session 对象，从而识别用户身份。</p>
<p>Spring Security 对 Session 的创建、使用和销毁提供了全面的控制和保护。</p>
<h4 id="4-3-1-Session-创建策略-SessionCreationPolicy"><a href="#4-3-1-Session-创建策略-SessionCreationPolicy" class="headerlink" title="4.3.1 Session 创建策略 (SessionCreationPolicy)"></a>4.3.1 Session 创建策略 (SessionCreationPolicy)</h4><p>Spring Security 允许我们精细地控制何时创建 <code>HttpSession</code>。这对于构建不同类型的应用（如有状态 Web 应用和无状态 REST API）至关重要。</p>
<p>通过 <code>.sessionManagement().sessionCreationPolicy()</code> 进行配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .sessionManagement(session -&gt; session</span><br><span class="line">            .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED) <span class="comment">// 设置策略</span></span><br><span class="line">        );</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四种策略</strong>:</p>
<ol>
<li><strong><code>SessionCreationPolicy.IF_REQUIRED</code> (默认值)</strong><ul>
<li><strong>含义</strong>: 只有在需要时，Spring Security 才会创建 <code>HttpSession</code>。</li>
<li><strong>“需要时”</strong> 指的是：当需要存储与认证相关的信息时，比如 <code>SecurityContext</code>。典型的场景是用户通过表单登录成功后，需要将 <code>Authentication</code> 对象保存起来以维持登录状态。</li>
<li><strong>适用场景</strong>: 绝大多数传统的、有状态的 Web 应用。</li>
</ul>
</li>
<li><strong><code>SessionCreationPolicy.STATELESS</code></strong><ul>
<li><strong>含义</strong>: Spring Security <strong>永远不会</strong>创建 <code>HttpSession</code>，也<strong>不会</strong>使用它来获取 <code>SecurityContext</code>。</li>
<li><strong>适用场景</strong>: <strong>无状态的 REST API</strong>。这类 API 的每次请求都应该是自包含的，认证信息通常通过其他方式携带，比如放在 <code>Authorization</code> Header 中的 JWT (JSON Web Token)。这使得 API 服务可以轻松地水平扩展，因为服务器不需要在内存中维护任何用户的 Session 信息。</li>
</ul>
</li>
<li><strong><code>SessionCreationPolicy.NEVER</code></strong><ul>
<li><strong>含义</strong>: Spring Security <strong>永远不会</strong>自己创建 <code>HttpSession</code>，但是如果应用的其他部分（例如，非安全相关的代码）已经创建了一个 Session，Spring Security <strong>会使用它</strong>。</li>
<li><strong>适用场景</strong>: 当你确定应用本身需要 Session，但希望 Spring Security 自身不主动触发 Session 创建时使用。比较少见。</li>
</ul>
</li>
<li><strong><code>SessionCreationPolicy.ALWAYS</code></strong><ul>
<li><strong>含义</strong>: Spring Security <strong>总是</strong>会创建一个 <code>HttpSession</code>，即使用是匿名用户。</li>
<li><strong>适用场景</strong>: 极少使用。可能用于需要为匿名用户也跟踪某些会话状态的特殊场景。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-3-2-Session-并发控制-Concurrent-Session-Control"><a href="#4-3-2-Session-并发控制-Concurrent-Session-Control" class="headerlink" title="4.3.2 Session 并发控制 (Concurrent Session Control)"></a>4.3.2 Session 并发控制 (Concurrent Session Control)</h4><p>这是一个常见的业务需求：<strong>限制同一个用户账户在同一时间只能在一个地方（或指定数量的地方）登录</strong>。例如，防止账户共享，或者在用户登录新设备时自动踢掉旧设备的登录。</p>
<p><strong>配置步骤</strong>:</p>
<h5 id="1-添加-Listener"><a href="#1-添加-Listener" class="headerlink" title="1. 添加 Listener"></a>1. 添加 Listener</h5><p>Spring Security 需要监听 Session 的销毁事件，以便在 Session 过期或被无效化时，能够清理其在并发控制注册表中的记录。为此，需要在主应用类或配置类中注册一个 <code>HttpSessionEventPublisher</code> 的 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.session.HttpSessionEventPublisher;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在你的 @Configuration 类中</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> HttpSessionEventPublisher <span class="title function_">httpSessionEventPublisher</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpSessionEventPublisher</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>在 Spring Boot 2.x 中，这个 Bean 似乎是自动配置的，但在 Spring Boot 3.x 及 Spring Framework 6.x 中，官方文档建议显式声明它以确保功能正常。</em></p>
<hr>
<h5 id="2-配置并发控制"><a href="#2-配置并发控制" class="headerlink" title="2. 配置并发控制"></a>2. 配置并发控制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .sessionManagement(session -&gt; session</span><br><span class="line">            .maximumSessions(<span class="number">1</span>) <span class="comment">// 1. 设置最大并发会话数量为 1</span></span><br><span class="line">            .maxSessionsPreventsLogin(<span class="literal">true</span>) <span class="comment">// 2. (策略二选一) 当达到最大会话数时，阻止新登录</span></span><br><span class="line">            <span class="comment">// .expiredUrl(&quot;/login?expired&quot;) // (可选) 当会话因并发登录被踢掉时重定向的 URL</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.maximumSessions(int maxSessions)</code>: 设置允许的并发会话最大数量。设置为 <code>1</code> 表示只允许单点登录。</li>
<li>之后，你需要选择一个<strong>并发处理策略</strong>（二选一）：<ul>
<li><strong><code>.maxSessionsPreventsLogin(true)</code></strong>: <strong>阻止新登录</strong>。如果用户 “user” 已经在一个地方登录，当他尝试在另一个地方用相同的账户登录时，新的登录请求将被拒绝。旧的登录会话保持有效。</li>
<li><strong><code>.maxSessionsPreventsLogin(false)</code> (默认行为)</strong>: <strong>踢掉旧登录</strong>。如果用户 “user” 已经登录，当他从新设备登录时，新登录会成功，而<strong>旧的登录会话将被标记为无效</strong>。当旧设备上的用户下次发起请求时，他会被强制下线，并可以被重定向到 <code>.expiredUrl()</code> 指定的页面。这是更常见的“互踢”策略。</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>: 要使并发控制生效，<code>UserDetails</code> 的 <code>equals()</code> 和 <code>hashCode()</code> 方法必须被正确实现（通常基于 <code>username</code>），以确保 Spring Security 能够正确识别是“同一个用户”。</p>
<hr>
<h4 id="4-3-3-Session-Fixation-会话固定-攻击防护"><a href="#4-3-3-Session-Fixation-会话固定-攻击防护" class="headerlink" title="4.3.3 Session Fixation (会话固定) 攻击防护"></a>4.3.3 Session Fixation (会话固定) 攻击防护</h4><h5 id="1-什么是会话固定攻击？"><a href="#1-什么是会话固定攻击？" class="headerlink" title="1. 什么是会话固定攻击？"></a>1. 什么是会话固定攻击？</h5><p>这是一种攻击者试图将自己的 Session ID 强加给受害者的攻击方式。</p>
<ul>
<li><strong>攻击流程</strong>:<ol>
<li>攻击者 Mallory 访问了目标网站 <code>example.com</code>，服务器为她创建了一个 Session 并返回了 Session ID (例如，<code>JSESSIONID=111</code>)。</li>
<li>Mallory 通过某种方式（如钓鱼链接、网络劫持）诱导受害者 Bob 使用这个 Session ID (<code>111</code>) 去访问 <code>example.com</code>。例如，<code>http://example.com?JSESSIONID=111</code>。</li>
<li>Bob 没有察觉，点击链接后，输入了自己的用户名和密码成功登录。</li>
<li><strong>问题来了</strong>：服务器在 Bob 登录后，<strong>没有改变 Session ID</strong>，而是直接将 Bob 的认证信息关联到了这个已知的 Session ID (<code>111</code>) 上。</li>
<li>现在，攻击者 Mallory 就可以使用她预先知道的 Session ID (<code>111</code>) 来访问网站，服务器会认为她就是已经登录的 Bob，从而劫持了 Bob 的会话。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="2-Spring-Security-的防护机制"><a href="#2-Spring-Security-的防护机制" class="headerlink" title="2. Spring Security 的防护机制"></a>2. Spring Security 的防护机制</h5><p>Spring Security <strong>默认开启了强大的会话固定攻击防护</strong>，你几乎不需要做任何额外配置。</p>
<ul>
<li><strong>核心策略</strong>: <strong>在用户认证成功后，迁移 Session</strong>。<ul>
<li>当用户成功登录时，Spring Security 会使当前的（可能是攻击者注入的）Session 无效化。</li>
<li>然后，它会创建一个<strong>全新的 Session</strong>，并生成一个<strong>全新的、不可预测的 Session ID</strong>。</li>
<li>最后，它会将旧 Session 中的所有属性复制到新 Session 中，并将新的 Session ID 返回给用户的浏览器。</li>
</ul>
</li>
</ul>
<p>这样一来，即使攻击者成功地将自己的 Session ID 固定给了受害者，一旦受害者登录，这个旧的 Session ID 就会失效，攻击者无法再利用它来劫持会话。</p>
<p><strong>配置</strong>:</p>
<p>这个行为由 <code>.sessionManagement().sessionFixation()</code> 控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.sessionManagement(session -&gt; session</span><br><span class="line">    .sessionFixation(fixation -&gt; fixation</span><br><span class="line">        .migrateSession() <span class="comment">// 默认策略，最推荐</span></span><br><span class="line">        <span class="comment">// .newSession()      // 创建新 Session，但不复制属性</span></span><br><span class="line">        <span class="comment">// .none()           // 关闭防护 (极不推荐!)</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>migrateSession()</code>: <strong>默认值，也是最安全的选项</strong>。使旧 Session 失效，创建新 Session，并复制旧 Session 的属性。</li>
<li><code>newSession()</code>: 使旧 Session 失效，创建新 Session，但<strong>不复制</strong>属性。</li>
<li><code>none()</code>: <strong>禁用</strong>会话固定攻击防护。<strong>除非你有非常特殊且明确的理由，否则永远不要使用这个选项。</strong></li>
</ul>
<hr>
<h3 id="4-4-注销-Logout-功能"><a href="#4-4-注销-Logout-功能" class="headerlink" title="4.4 注销 (Logout) 功能"></a>4.4 注销 (Logout) 功能</h3><p>注销 (Logout) 是一个允许用户主动终止其认证会话的过程。一个设计良好的注销功能不仅能提升用户体验，更是保障账户安全的关键步骤。Spring Security 提供了非常灵活且强大的注Gitg能来配置和自定义注销行为。</p>
<h4 id="4-4-1-默认的注销功能"><a href="#4-4-1-默认的注销功能" class="headerlink" title="4.4.1 默认的注销功能"></a>4.4.1 默认的注销功能</h4><p>只需在 <code>SecurityFilterChain</code> 配置中加入 <code>.logout()</code>，即可启用一套功能完备的默认注销机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">        .logout(Customizer.withDefaults()); <span class="comment">// 使用默认配置启用注销功能</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，这会提供以下功能：</p>
<ol>
<li><strong>监听注销 URL</strong>: 默认会拦截对 <code>/logout</code> 的 <strong>GET 请求</strong>。当用户访问这个 URL 时，注销流程就会被触发。（注意：出于安全考虑，推荐使用 POST 请求进行注销，下面会讲如何配置）。</li>
<li><strong>执行注销操作</strong>: 当注销流程被触发时，<code>LogoutFilter</code> 会执行一系列清理操作：<ul>
<li><strong>使 <code>HttpSession</code> 无效化 (Invalidate)</strong>：这是最关键的一步，清除了服务器端的所有会-话信息。</li>
<li><strong>清空 <code>SecurityContextHolder</code></strong>: 清除当前线程的安全上下文。</li>
<li><strong>清除 “记住我” (Remember-Me) Cookie</strong>: 如果用户之前使用了 “记住我” 功能，相关的持久化认证信息也会被删除。</li>
</ul>
</li>
<li><strong>重定向</strong>: 注销成功后，默认会将用户重定向到 <code>/login?logout</code> 页面。</li>
</ol>
<p><strong>前端实现</strong>:</p>
<p>你只需要在页面上提供一个指向 <code>/logout</code> 的链接或按钮即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如果使用 GET (不推荐，但默认支持) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/logout&#125;&quot;</span>&gt;</span>Logout<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果使用 POST (推荐) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/logout&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Logout<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么推荐使用 POST？</strong></p>
<p>使用 GET 请求进行注销存在 CSRF 风险。攻击者可以在恶意网站上放置一个 <code>&lt;img src=&quot;http://your-site.com/logout&quot;&gt;</code>，诱导已登录的用户访问，从而在用户不知情的情况下将其注销。虽然注销操作的危害性通常小于转账等操作，但这仍是一种不良实践。要求使用 POST 并配合 CSRF Token 可以完全杜绝这种风险。</p>
<hr>
<h4 id="4-4-2-自定义注销配置"><a href="#4-4-2-自定义注销配置" class="headerlink" title="4.4.2 自定义注销配置"></a>4.4.2 自定义注销配置</h4><p>Spring Security 允许我们通过 Lambda 表达式对注销的各个方面进行详细配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .logout(logout -&gt; logout</span><br><span class="line">            <span class="comment">// 1. 配置触发注销的 URL</span></span><br><span class="line">            .logoutUrl(<span class="string">&quot;/perform_logout&quot;</span>) <span class="comment">// 默认为 /logout</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 指定注销请求必须是 POST (推荐)</span></span><br><span class="line">            .logoutRequestMatcher(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/perform_logout&quot;</span>, <span class="string">&quot;POST&quot;</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 注销成功后的重定向地址</span></span><br><span class="line">            .logoutSuccessUrl(<span class="string">&quot;/login?logout_success&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 注销时清除的 Cookie</span></span><br><span class="line">            .deleteCookies(<span class="string">&quot;JSESSIONID&quot;</span>, <span class="string">&quot;remember-me&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 是否在注销时使 HttpSession 无效</span></span><br><span class="line">            .invalidateHttpSession(<span class="literal">true</span>) <span class="comment">// 默认为 true</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 6. 是否在注销时清除 SecurityContextHolder</span></span><br><span class="line">            .clearAuthentication(<span class="literal">true</span>) <span class="comment">// 默认为 true</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置项详解</strong>:</p>
<ul>
<li><code>.logoutUrl(&quot;/perform_logout&quot;)</code>: 更改 <code>LogoutFilter</code> 监听的 URL。</li>
<li><code>.logoutRequestMatcher(...)</code>: 提供一个 <code>RequestMatcher</code> 来更精细地定义触发注销的请求。这里我们明确要求必须是 <code>POST</code> 方法访问 <code>/perform_logout</code>。这是替代 <code>.logoutUrl()</code> 的更现代、更灵活的方式。</li>
<li><code>.logoutSuccessUrl(&quot;/login?logout_success&quot;)</code>: 指定注销成功后重定向到哪个页面。</li>
<li><code>.deleteCookies(&quot;cookie1&quot;, &quot;cookie2&quot;, ...)</code>: 告诉 Spring Security 在注销时除了默认的 “记住我” Cookie 外，还应清除哪些指定的 Cookie。这对于清理应用自定义的 Cookie 非常有用。</li>
<li><code>.invalidateHttpSession(true)</code>: 确保 <code>HttpSession</code> 被销毁。通常应保持为 <code>true</code>。</li>
<li><code>.clearAuthentication(true)</code>: 确保 <code>SecurityContextHolder</code> 被清空。通常也应保持为 <code>true</code>。</li>
</ul>
<h4 id="4-4-3-自定义注销成功后的处理器"><a href="#4-4-3-自定义注销成功后的处理器" class="headerlink" title="4.4.3 自定义注销成功后的处理器"></a>4.4.3 自定义注销成功后的处理器</h4><p><code>.logoutSuccessUrl()</code> 只能实现简单的重定向。对于更复杂的场景，例如在前后端分离的应用中，注销后需要返回一段 JSON 数据，而不是重定向页面，这时我们就需要自定义 <code>LogoutSuccessHandler</code>。</p>
<p><strong>步骤 1: 创建 <code>LogoutSuccessHandler</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 注册为 Spring Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogoutSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                                HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                Authentication authentication)</span> </span><br><span class="line">                                <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        response.setStatus(HttpStatus.OK.value());</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonResponse</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;code\&quot;: 200, \&quot;message\&quot;: \&quot;Logout successful\&quot;&#125;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        response.getWriter().write(jsonResponse);</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>onLogoutSuccess</code> 方法会在注销流程成功执行后被调用。</li>
<li><code>authentication</code> 参数包含了注销前用户的认证信息，你可以在这里获取用户名等信息进行日志记录。</li>
<li>我们设置了响应的状态码为 200 OK，<code>Content-Type</code> 为 <code>application/json</code>。</li>
<li>然后向响应体中写入自定义的 JSON 字符串。</li>
<li><strong>注意</strong>: 在自定义 Handler 中，我们完全控制了响应。Spring Security 不会再执行任何默认的重定向操作。</li>
</ul>
<p><strong>步骤 2: 在安全配置中使用自定义的 Handler</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .logout(logout -&gt; logout</span><br><span class="line">            .logoutUrl(<span class="string">&quot;/api/logout&quot;</span>)</span><br><span class="line">            <span class="comment">// 使用 .logoutSuccessHandler() 替代 .logoutSuccessUrl()</span></span><br><span class="line">            .logoutSuccessHandler(myLogoutSuccessHandler) </span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>.logoutSuccessHandler()</code> 方法，我们将自定义的处理器注入到了注销配置中。现在，当用户访问 <code>/api/logout</code> 时，成功注销后将收到我们定义的 JSON 响应，而不是页面跳转。</p>
<h4 id="4-4-4-添加自定义的注销处理器-LogoutHandler"><a href="#4-4-4-添加自定义的注销处理器-LogoutHandler" class="headerlink" title="4.4.4 添加自定义的注销处理器 (LogoutHandler)"></a>4.4.4 添加自定义的注销处理器 (<code>LogoutHandler</code>)</h4><p><code>LogoutSuccessHandler</code> 是在<strong>注销成功后</strong>执行的。如果你需要在<strong>注销过程中</strong>执行一些自定义的清理逻辑（例如，记录用户登出日志、调用第三方服务使 Token 失效等），你应该实现 <code>LogoutHandler</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogoutHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (authentication != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">            <span class="comment">// 在这里执行自定义逻辑，比如记录日志</span></span><br><span class="line">            System.out.println(<span class="string">&quot;User &quot;</span> + username + <span class="string">&quot; is logging out.&quot;</span>);</span><br><span class="line">            <span class="comment">// 或者调用服务使 JWT Token 黑名单</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在配置中使用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyLogoutHandler myLogoutHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">.logout(logout -&gt; logout</span><br><span class="line">    .addLogoutHandler(myLogoutHandler) <span class="comment">// 添加自定义 LogoutHandler</span></span><br><span class="line">    .logoutSuccessUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>你可以通过 <code>.addLogoutHandler()</code> 添加多个 <code>LogoutHandler</code>。它们会与 Spring Security 内置的处理器（如 <code>CookieClearingLogoutHandler</code>, <code>SecurityContextLogoutHandler</code>）一起被依次调用。</p>
<hr>
<h3 id="4-5-异常处理"><a href="#4-5-异常处理" class="headerlink" title="4.5 异常处理"></a>4.5 异常处理</h3><p>在 Spring Security 的过滤器链中，当一个安全相关的异常被抛出时，<code>ExceptionTranslationFilter</code> 会捕获它，并根据异常的类型，将处理工作委托给两个核心的策略接口：<code>AuthenticationEntryPoint</code> 和 <code>AccessDeniedHandler</code>。</p>
<p>理解这两者的区别是掌握 Spring Security 异常处理的关键。</p>
<h4 id="4-5-1-AuthenticationEntryPoint-未认证用户的“入口点”"><a href="#4-5-1-AuthenticationEntryPoint-未认证用户的“入口点”" class="headerlink" title="4.5.1 AuthenticationEntryPoint: 未认证用户的“入口点”"></a>4.5.1 <code>AuthenticationEntryPoint</code>: 未认证用户的“入口点”</h4><ul>
<li><p><strong>是什么？</strong><br><code>AuthenticationEntryPoint</code> 是一个接口，它定义了当一个**未认证（匿名）<strong>的用户尝试访问一个需要认证的受保护资源时，应该如何</strong>“开始”**认证流程。它的名字“入口点”非常形象，它就是引导匿名用户进入认证流程的起点。</p>
</li>
<li><p><strong>何时触发？</strong><br>当 <code>ExceptionTranslationFilter</code> 捕获到一个 <code>AuthenticationException</code> 时，就会调用 <code>AuthenticationEntryPoint</code>。这通常发生在：</p>
<ol>
<li>一个匿名用户直接访问了一个受保护的 URL（例如 <code>http://.../dashboard</code>）。</li>
<li>用户提交了无效的凭证（如错误的密码），导致认证失败，抛出了 <code>BadCredentialsException</code>（它是 <code>AuthenticationException</code> 的子类）。</li>
</ol>
</li>
<li><p><strong>默认行为</strong><br>Spring Security 根据你的配置，提供了不同的默认实现：</p>
<ul>
<li>如果配置了 <strong>Form Login</strong> (<code>.formLogin()</code>)，默认的 <code>LoginUrlAuthenticationEntryPoint</code> 会将用户<strong>重定向到登录页面</strong>。</li>
<li>如果配置了 <strong>HTTP Basic</strong> (<code>.httpBasic()</code>)，默认的 <code>BasicAuthenticationEntryPoint</code> 会向浏览器返回一个 <strong><code>401 Unauthorized</code></strong> 状态码，并带上 <code>WWW-Authenticate</code> 头，触发浏览器的原生登录对话框。</li>
</ul>
</li>
<li><p><strong>自定义实现（REST API 场景）</strong><br>在前后端分离的 REST API 中，我们不希望重定向到 HTML 页面，而是希望返回一个结构化的 JSON 响应，并附带 <code>401</code> 状态码。</p>
<p><strong>步骤 1: 创建 <code>AuthenticationEntryPoint</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                         HttpServletResponse response, </span></span><br><span class="line"><span class="params">                         AuthenticationException authException)</span> </span><br><span class="line">                         <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        response.setStatus(HttpStatus.UNAUTHORIZED.value()); <span class="comment">// 设置状态码 401</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回一个提示需要登录的 JSON</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonResponse</span> <span class="operator">=</span> String.format(</span><br><span class="line">            <span class="string">&quot;&#123;\&quot;code\&quot;: %d, \&quot;message\&quot;: \&quot;Sorry, you must be authenticated to access this resource.\&quot;, \&quot;error\&quot;: \&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">            HttpStatus.UNAUTHORIZED.value(),</span><br><span class="line">            authException.getMessage()</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        response.getWriter().write(jsonResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在安全配置中应用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationEntryPoint myAuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">        .exceptionHandling(exceptions -&gt; exceptions</span><br><span class="line">            .authenticationEntryPoint(myAuthenticationEntryPoint)</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-5-2-AccessDeniedHandler-已认证但无权限用户的“处理器”"><a href="#4-5-2-AccessDeniedHandler-已认证但无权限用户的“处理器”" class="headerlink" title="4.5.2 AccessDeniedHandler: 已认证但无权限用户的“处理器”"></a>4.5.2 <code>AccessDeniedHandler</code>: 已认证但无权限用户的“处理器”</h4><ul>
<li><p><strong>是什么？</strong><br><code>AccessDeniedHandler</code> 是一个接口，它定义了当一个<strong>已经认证</strong>的用户尝试访问一个他<strong>没有足够权限</strong>的资源时，应该如何处理。</p>
</li>
<li><p><strong>何时触发？</strong><br>当 <code>ExceptionTranslationFilter</code> 捕获到一个 <code>AccessDeniedException</code> 时，就会调用 <code>AccessDeniedHandler</code>。这个异常通常由授权决策者（如 <code>AuthorizationManager</code> 或 <code>AccessDecisionManager</code>）在检查权限（例如 <code>hasRole(&#39;ADMIN&#39;)</code>）失败后抛出。</p>
</li>
<li><p><strong>默认行为</strong><br>默认的 <code>AccessDeniedHandlerImpl</code> 会向浏览器返回一个 <strong><code>403 Forbidden</code></strong> 的错误页面。这通常是一个非常简陋的、由 Web 服务器提供的页面。</p>
</li>
<li><p><strong>自定义实现（REST API 场景）</strong><br>同样，在 REST API 中，我们希望返回一个 <code>403</code> 状态码和 JSON 错误信息，而不是一个 HTML 页面。</p>
<p><strong>步骤 1: 创建 <code>AccessDeniedHandler</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                       HttpServletResponse response, </span></span><br><span class="line"><span class="params">                       AccessDeniedException accessDeniedException)</span> </span><br><span class="line">                       <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">                       </span><br><span class="line">        response.setStatus(HttpStatus.FORBIDDEN.value()); <span class="comment">// 设置状态码 403</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonResponse</span> <span class="operator">=</span> String.format(</span><br><span class="line">            <span class="string">&quot;&#123;\&quot;code\&quot;: %d, \&quot;message\&quot;: \&quot;Access Denied. You do not have the required permissions.\&quot;, \&quot;error\&quot;: \&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">            HttpStatus.FORBIDDEN.value(),</span><br><span class="line">            accessDeniedException.getMessage()</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        response.getWriter().write(jsonResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在安全配置中应用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">        .exceptionHandling(exceptions -&gt; exceptions</span><br><span class="line">            <span class="comment">// .authenticationEntryPoint(...) // 可以同时配置</span></span><br><span class="line">            .accessDeniedHandler(myAccessDeniedHandler)</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-5-3-总结与对比"><a href="#4-5-3-总结与对比" class="headerlink" title="4.5.3 总结与对比"></a>4.5.3 总结与对比</h4><p>将这两个组件放在一起配置，就可以完全控制你的 API 的安全异常响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationEntryPoint myAuthenticationEntryPoint;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... authorizeHttpRequests, csrf, cors 等配置</span></span><br><span class="line">        .exceptionHandling(exceptions -&gt; exceptions</span><br><span class="line">            .authenticationEntryPoint(myAuthenticationEntryPoint) <span class="comment">// 处理未认证</span></span><br><span class="line">            .accessDeniedHandler(myAccessDeniedHandler)           <span class="comment">// 处理未授权</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>决策流程图</strong>:</p>
<pre><code class="highlight mermaid">flowchart TD
    A[请求进入&lt;br&gt;ExceptionTranslationFilter] --&gt; B&#123;安全异常被抛出?&#125;
    B --&gt;|是| C&#123;是 AuthenticationException?&lt;br&gt;用户未登录&#125;
    B --&gt;|否| G[继续处理请求]
    C --&gt;|是| D[调用 AuthenticationEntryPoint]
    C --&gt;|否| E&#123;是 AccessDeniedException?&lt;br&gt;用户已登录但无权限&#125;
    D --&gt; F[通常返回 401 + JSON&lt;br&gt;或重定向到 /login]
    E --&gt;|是| H[调用 AccessDeniedHandler]
    H --&gt; I[通常返回 403 + JSON]</code></pre>

<table>
<thead>
<tr>
<th>特性</th>
<th><code>AuthenticationEntryPoint</code></th>
<th><code>AccessDeniedHandler</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>处理的用户状态</strong></td>
<td><strong>未认证 (Anonymous)</strong></td>
<td><strong>已认证 (Authenticated)</strong></td>
</tr>
<tr>
<td><strong>触发的异常</strong></td>
<td><code>AuthenticationException</code> 及其子类</td>
<td><code>AccessDeniedException</code></td>
</tr>
<tr>
<td><strong>核心问题</strong></td>
<td><strong>“你是谁？”</strong> - 用户身份未知或无效。</td>
<td><strong>“你能做什么？”</strong> - 用户身份已知，但权限不足。</td>
</tr>
<tr>
<td><strong>典型 HTTP 状态码</strong></td>
<td><strong>401 Unauthorized</strong> (需要认证)</td>
<td><strong>403 Forbidden</strong> (禁止访问)</td>
</tr>
<tr>
<td><strong>典型行为 (Web)</strong></td>
<td>重定向到登录页</td>
<td>显示“禁止访问”错误页</td>
</tr>
<tr>
<td><strong>典型行为 (API)</strong></td>
<td>返回 JSON，提示客户端需要登录并提供凭证。</td>
<td>返回 JSON，提示客户端当前用户没有权限执行该操作。</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-现代化应用集成：JWT-与-OAuth2"><a href="#5-现代化应用集成：JWT-与-OAuth2" class="headerlink" title="5. 现代化应用集成：JWT 与 OAuth2"></a>5. 现代化应用集成：JWT 与 OAuth2</h2><h3 id="5-1-无状态认证与-JWT-JSON-Web-Token"><a href="#5-1-无状态认证与-JWT-JSON-Web-Token" class="headerlink" title="5.1 无状态认证与 JWT (JSON Web Token)"></a>5.1 无状态认证与 JWT (JSON Web Token)</h3><p>传统的基于 Session 的认证机制在服务器端存储用户的会札信息，这被称为<strong>有状态 (Stateful)</strong> 认证。然而，随着分布式系统、微服务和前后端分离架构的兴起，有状态认证的弊端日益凸显，<strong>无状态 (Stateless)</strong> 认证应运而生，而 JWT 则是实现无状态认证最主流的技术方案。</p>
<h4 id="5-1-1-为什么需要无状态认证？"><a href="#5-1-1-为什么需要无状态认证？" class="headerlink" title="5.1.1 为什么需要无状态认证？"></a>5.1.1 为什么需要无状态认证？</h4><ol>
<li><strong>可伸缩性 (Scalability) 问题</strong>:<ul>
<li><strong>有状态</strong>: 用户的 Session 信息存储在某一台服务器的内存中。如果系统需要水平扩展（增加更多服务器实例），请求可能会被负载均衡器分发到没有该用户 Session 的服务器上，导致认证失败。解决方案（如 Session 复制或集中式 Session 存储）会增加系统的复杂性和开销。</li>
<li><strong>无状态</strong>: 服务器不存储任何会话信息。每个请求都包含了所有必要的认证信息（如 JWT）。任何一台服务器收到请求后，都可以独立地对其进行验证，从而实现无缝的水平扩展。</li>
</ul>
</li>
<li><strong>微服务架构的挑战</strong>:<ul>
<li>在一个复杂的微服务系统中，一个来自客户端的请求可能需要经过多个微服务（如 API 网关 -&gt; 订单服务 -&gt; 库存服务）。如果使用 Session，就需要建立一套复杂的机制来在所有服务间共享 Session 状态，这几乎是不可行的。</li>
<li>使用无状态的 Token，API 网关在验证 Token 后，可以将解析出的用户信息传递给下游服务，或者下游服务自己也可以独立验证 Token，服务之间解耦，架构更清晰。</li>
</ul>
</li>
<li><strong>多客户端支持 (SPA, 移动应用)</strong>:<ul>
<li>传统的 Session 机制严重依赖于浏览器的 Cookie (<code>JSESSIONID</code>)。</li>
<li>对于单页面应用 (SPA)、移动 App (iOS&#x2F;Android)、桌面应用等非浏览器客户端，处理 Cookie 并非它们的标准或最佳实践。</li>
<li>使用 Token（通常放在 <code>Authorization</code> 请求头中）是一种跨平台的、标准化的 API 认证方式，所有类型的客户端都能轻松支持。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-1-2-JWT-结构详解：Header-Payload-Signature"><a href="#5-1-2-JWT-结构详解：Header-Payload-Signature" class="headerlink" title="5.1.2 JWT 结构详解：Header, Payload, Signature"></a>5.1.2 JWT 结构详解：Header, Payload, Signature</h4><p>JWT 本质上是一个紧凑的、自包含的、URL 安全的字符串，它由三部分组成，每部分都经过 Base64Url 编码，并用点 (<code>.</code>) 连接。</p>
<p><code>xxxxx.yyyyy.zzzzz</code><br>(Header).(Payload).(Signature)</p>
<p><strong>把 JWT 想象成一张带防伪标识的身份证：</strong></p>
<ul>
<li><strong>Header (头部)</strong>: 身份证的“元信息”，说明了这张卡的类型和防伪技术。</li>
<li><strong>Payload (载荷)</strong>: 身份证的“个人信息”，包含了姓名、性别、出生日期等。</li>
<li><strong>Signature (签名)</strong>: 身份证的“防伪镭射标”，用来验证这张卡是不是伪造的。</li>
</ul>
<h5 id="1-Header-头部"><a href="#1-Header-头部" class="headerlink" title="1. Header (头部)"></a>1. Header (头部)</h5><p>描述 JWT 的元数据，通常包含两部分：</p>
<ul>
<li><code>typ</code> (Type): 令牌的类型，固定为 “JWT”。</li>
<li><code>alg</code> (Algorithm): 用于生成签名的算法，如 <code>HS256</code> (HMAC using SHA-256) 或 <code>RS256</code> (RSA using SHA-256)。</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这部分 JSON 会被 Base64Url 编码，形成 JWT 的第一部分。</p>
<hr>
<h5 id="2-Payload-载荷"><a href="#2-Payload-载荷" class="headerlink" title="2. Payload (载荷)"></a>2. Payload (载荷)</h5><p>存放实际需要传递的数据，这些数据被称为“声明 (Claims)”。声明分为三类：</p>
<ul>
<li><strong>Registered Claims (注册声明)</strong>: 官方预定义的一组声明，建议使用但非强制。<ul>
<li><code>iss</code> (Issuer): 签发者</li>
<li><code>sub</code> (Subject): 主题，通常是用户的唯一标识（如用户ID或用户名）</li>
<li><code>aud</code> (Audience): 接收方</li>
<li><code>exp</code> (Expiration Time): <strong>过期时间</strong> (时间戳)，是保证 Token 安全的关键。</li>
<li><code>nbf</code> (Not Before): 生效时间 (时间戳)</li>
<li><code>iat</code> (Issued At): 签发时间 (时间戳)</li>
</ul>
</li>
<li><strong>Public Claims (公共声明)</strong>: 由使用者自行定义，但为了避免冲突，应在 <a target="_blank" rel="noopener" href="https://www.iana.org/assignments/json-web-token/json-web-token.xhtml">IANA JSON Web Token Claims</a> 注册表中注册。</li>
<li><strong>Private Claims (私有声明)</strong>: 服务端和客户端共同约定的声明，用于传递自定义信息。这是我们最常使用的部分。<ul>
<li>例如，我们可以放入用户角色、权限列表、用户ID等。</li>
</ul>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;roles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ROLE_USER&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ROLE_VIEWER&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1678886400</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1678890000</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>安全警告</strong>: Payload 部分只是被 Base64Url 编码，<strong>它不是加密的</strong>！任何人都可以解码并读取其中的内容。<strong>绝对不要在 Payload 中存放任何敏感信息，如密码！</strong></p>
<hr>
<h5 id="3-Signature-签名"><a href="#3-Signature-签名" class="headerlink" title="3. Signature (签名)"></a>3. Signature (签名)</h5><p>签名的作用是<strong>验证 Token 的完整性</strong>，确保它在传输过程中没有被篡改。</p>
<p>生成过程如下：</p>
<p><code>HMACSHA256(Base64UrlEncode(header) + &quot;.&quot; + Base64UrlEncode(payload), secret)</code></p>
<ul>
<li>将编码后的 Header 和 Payload 用点 (<code>.</code>) 连接起来。</li>
<li>使用 Header 中指定的签名算法 (<code>alg</code>) 和一个保存在<strong>服务器端的、绝不外泄的密钥 (secret)</strong> 对其进行加密。</li>
</ul>
<p><strong>验证过程</strong>:</p>
<p>当服务器收到一个 JWT 时，它会用相同的算法和密钥，对接收到的 Header 和 Payload 重新计算一次签名。然后，将计算出的新签名与 JWT 中附带的原始签名进行比对。</p>
<ul>
<li>如果一致，说明 Token 未被篡改且是由该服务器签发的。</li>
<li>如果不一致，说明 Token 是伪造的或已被篡改，验证失败。</li>
</ul>
<hr>
<h4 id="5-1-3-在-Spring-Security-中集成-JWT"><a href="#5-1-3-在-Spring-Security-中集成-JWT" class="headerlink" title="5.1.3 在 Spring Security 中集成 JWT"></a>5.1.3 在 Spring Security 中集成 JWT</h4><p>集成 JWT 的核心思想是：</p>
<ol>
<li><strong>禁用</strong> Spring Security 默认的 Session 管理和 CSRF 防护。</li>
<li>创建一个<strong>自定义的过滤器</strong>，在 Spring Security 的标准认证过滤器之前运行。</li>
<li>这个过滤器负责从请求中提取 JWT，验证它，如果验证通过，就构建一个 <code>Authentication</code> 对象并放入 <code>SecurityContextHolder</code>。</li>
</ol>
<p><strong>依赖引入 (以 <code>jjwt</code> 为例)</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 1: 创建 JWT 工具类</strong></p>
<p>封装 JWT 的生成和解析逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.expiration&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> expiration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 Authentication 对象生成 JWT</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">(Authentication authentication)</span> &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> (UserDetails) authentication.getPrincipal();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expiryDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(now.getTime() + expiration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setSubject(userDetails.getUsername())</span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                .setExpiration(expiryDate)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 JWT 中解析用户名</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsernameFromToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(secret)</span><br><span class="line">                .parseClaimsJws(token)</span><br><span class="line">                .getBody();</span><br><span class="line">        <span class="keyword">return</span> claims.getSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证 JWT 是否有效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateToken</span><span class="params">(String token, UserDetails userDetails)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> getUsernameFromToken(token);</span><br><span class="line">            <span class="keyword">return</span> (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// MalformedJwtException, ExpiredJwtException, etc.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isTokenExpired</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expirationDate</span> <span class="operator">=</span> Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody().getExpiration();</span><br><span class="line">        <span class="keyword">return</span> expirationDate.before(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 创建自定义过滤器</strong></p>
<p>这个过滤器继承 <code>OncePerRequestFilter</code>，确保每个请求只执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                                    HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                    FilterChain filterChain)</span> </span><br><span class="line">                                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 从请求头获取 JWT</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (header != <span class="literal">null</span> &amp;&amp; header.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            jwt = header.substring(<span class="number">7</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                username = jwtUtil.getUsernameFromToken(jwt);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// ... handle exceptions</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 如果获取到用户名，且当前 SecurityContext 中没有认证信息</span></span><br><span class="line">        <span class="keyword">if</span> (username != <span class="literal">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> <span class="built_in">this</span>.userDetailsService.loadUserByUsername(username);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 验证 JWT 是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (jwtUtil.validateToken(jwt, userDetails)) &#123;</span><br><span class="line">                <span class="comment">// 4. 构建 Authentication 对象</span></span><br><span class="line">                <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(</span><br><span class="line">                        userDetails, <span class="literal">null</span>, userDetails.getAuthorities());</span><br><span class="line">                authentication.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 将 Authentication 对象放入 SecurityContext</span></span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 放行请求</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 更新 Security 配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationFilter jwtAuthenticationFilter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 1. 禁用 CSRF</span></span><br><span class="line">            .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 配置会话管理为无状态</span></span><br><span class="line">            .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 配置授权规则</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/api/auth/**&quot;</span>).permitAll() <span class="comment">// 允许访问登录/注册</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 将自定义的 JWT 过滤器添加到过滤器链中</span></span><br><span class="line">            <span class="comment">// 在 UsernamePasswordAuthenticationFilter 之前执行</span></span><br><span class="line">            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要 AuthenticationManager Bean 用于登录认证</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(AuthenticationConfiguration config)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> config.getAuthenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当一个请求到达时：</p>
<ul>
<li><code>/api/auth/login</code> 请求被放行，用户登录成功后，Controller 调用 <code>JwtUtil.generateToken()</code> 生成 JWT 并返回给前端。</li>
<li>前端在后续请求的 <code>Authorization</code> Header 中携带 <code>Bearer &lt;jwt&gt;</code>。</li>
<li><code>JwtAuthenticationFilter</code> 拦截请求，验证 JWT，并将用户信息放入 <code>SecurityContext</code>。</li>
<li>后续的授权逻辑（如 <code>@PreAuthorize</code>）就能正常工作了。</li>
</ul>
<hr>
<h4 id="5-1-4-实现-Token-刷新机制"><a href="#5-1-4-实现-Token-刷新机制" class="headerlink" title="5.1.4 实现 Token 刷新机制"></a>5.1.4 实现 Token 刷新机制</h4><p>短期的 Access Token 提高了安全性，但也带来了用户体验问题。<strong>Access Token + Refresh Token</strong> 模式是解决这个问题的最佳实践。</p>
<ul>
<li><strong>Access Token</strong>: 短生命周期（如 15-60 分钟），用于访问受保护资源，Payload 中可包含权限信息。</li>
<li><strong>Refresh Token</strong>: 长生命周期（如 7-30 天），<strong>只能</strong>用于获取新的 Access Token。它不包含任何权限信息，通常是一个随机生成的、无意义的字符串，并存储在数据库中，以便可以随时撤销。</li>
</ul>
<p><strong>刷新流程</strong>:</p>
<ol>
<li><strong>登录</strong>: 用户登录成功，服务器返回 <strong>Access Token</strong> 和 <strong>Refresh Token</strong>。</li>
<li><strong>访问</strong>: 客户端使用 Access Token 访问 API。</li>
<li><strong>过期</strong>: Access Token 过期，API 返回 401 Unauthorized。</li>
<li><strong>刷新</strong>: 客户端的请求拦截器捕获到 401 错误，然后向一个专门的刷新端点（如 <code>/api/auth/refresh</code>）发送 <strong>Refresh Token</strong>。</li>
<li><strong>验证与签发</strong>: 服务器验证 Refresh Token 是否有效（存在于数据库且未过期）。如果有效，则签发一个新的 Access Token（有时也会签发一个新的 Refresh Token，这称为“刷新令牌旋转”），并返回给客户端。</li>
<li><strong>重试</strong>: 客户端收到新的 Access Token 后，用它来自动重试之前失败的请求。整个过程对用户是透明的。</li>
</ol>
<p>这个机制需要在 <code>AuthController</code> 中增加一个处理 <code>/refresh</code> 的端点，并设计 Refresh Token 在数据库中的存储和校验逻辑。</p>
<hr>
<h3 id="5-2-OAuth2-与-OIDC-OpenID-Connect-核心概念"><a href="#5-2-OAuth2-与-OIDC-OpenID-Connect-核心概念" class="headerlink" title="5.2 OAuth2 与 OIDC (OpenID Connect) 核心概念"></a>5.2 OAuth2 与 OIDC (OpenID Connect) 核心概念</h3><h4 id="5-2-1-OAuth-2-0-委托授权的框架"><a href="#5-2-1-OAuth-2-0-委托授权的框架" class="headerlink" title="5.2.1 OAuth 2.0: 委托授权的框架"></a>5.2.1 OAuth 2.0: 委托授权的框架</h4><p>首先，要明确 OAuth 2.0 的核心目标：它<strong>不是一个认证 (Authentication) 协议</strong>，而是一个<strong>授权 (Authorization) 框架</strong>。</p>
<p>它的设计初衷是为了解决一个非常具体的问题：<strong>“如何在不暴露用户核心凭证（如用户名和密码）的前提下，允许第三方应用（客户端）访问用户在某个服务上受保护的资源？”</strong></p>
<p><strong>经典场景</strong>:</p>
<p>想象一下，你发现了一个很棒的第三方照片打印网站 <code>PrintPhotos.com</code>，你希望它能访问你在 <code>Google Photos</code> 上的照片来进行打印。</p>
<ul>
<li><strong>没有 OAuth 2.0 的糟糕做法</strong>: <code>PrintPhotos.com</code> 要求你输入你的 Google 用户名和密码。这是一个巨大的安全风险，因为它拿到了你的最高权限，不仅可以看你的照片，还能看你的邮件、日历等所有信息。</li>
<li><strong>有了 OAuth 2.0 的优雅做法</strong>:<ol>
<li><code>PrintPhotos.com</code> 会将你重定向到 Google 的登录和授权页面。</li>
<li>你直接向 Google 登录（你的密码绝不会给 <code>PrintPhotos.com</code>）。</li>
<li>Google 会询问你：“<code>PrintPhotos.com</code> 正在请求访问你的照片库，你是否同意？”</li>
<li>你点击“同意”后，Google 会给 <code>PrintPhotos.com</code> 一个临时的、有特定权限（只能访问照片）的“令牌 (Token)”。</li>
<li><code>PrintPhotos.com</code> 使用这个令牌去访问 <code>Google Photos</code> API，成功获取你的照片。</li>
</ol>
</li>
</ul>
<p>在这个过程中，<code>PrintPhotos.com</code> 从未接触到你的密码，并且它获得的授权是<strong>有限的、可撤销的</strong>。这就是 OAuth 2.0 的核心思想——<strong>委托授权</strong>。</p>
<hr>
<h4 id="5-2-2-OAuth-2-0-的四大核心角色"><a href="#5-2-2-OAuth-2-0-的四大核心角色" class="headerlink" title="5.2.2 OAuth 2.0 的四大核心角色"></a>5.2.2 OAuth 2.0 的四大核心角色</h4><p>OAuth 2.0 协议中定义了四个关键角色：</p>
<ol>
<li><strong>资源所有者 (Resource Owner)</strong><ul>
<li><strong>定义</strong>: 能够授予对受保护资源访问权限的实体。通常就是<strong>最终用户</strong>。</li>
<li><strong>例子</strong>: 在上面的场景中，<strong>你</strong>就是资源所有者，因为照片是你的。</li>
</ul>
</li>
<li><strong>客户端 (Client)</strong><ul>
<li><strong>定义</strong>: 代表资源所有者，并经其授权，去请求访问受保护资源的应用程序。</li>
<li><strong>例子</strong>: <code>PrintPhotos.com</code> 网站。</li>
<li><strong>关键属性</strong>: 每个客户端在授权服务器上注册时，都会获得一个 <code>client_id</code> 和一个 <code>client_secret</code>（对于保密客户端），用于表明自己的身份。</li>
</ul>
</li>
<li><strong>授权服务器 (Authorization Server)</strong><ul>
<li><strong>定义</strong>: <strong>整个流程的核心</strong>。负责验证资源所有者的身份，并根据其授权，向客户端颁发访问令牌 (Access Token)。</li>
<li><strong>例子</strong>: Google 的认证和授权服务 (<code>accounts.google.com</code>)。</li>
<li>它就像一个**“令牌颁发机构”**。</li>
</ul>
</li>
<li><strong>资源服务器 (Resource Server)</strong><ul>
<li><strong>定义</strong>: 托管受保护资源的服务器。它只认令牌，不认人。它能接受并验证访问令牌，如果令牌有效，就允许客户端访问资源。</li>
<li><strong>例子</strong>: 存储你照片的 <code>Google Photos</code> API 服务器 (<code>photos.googleapis.com</code>)。</li>
</ul>
</li>
</ol>
<p><strong>流程概览</strong>:</p>
<p><code>资源所有者</code> 告诉 <code>授权服务器</code>：“我同意让这个 <code>客户端</code> 访问我在 <code>资源服务器</code> 上的某些数据”。然后 <code>授权服务器</code> 给了 <code>客户端</code> 一个令牌，<code>客户端</code> 拿着这个令牌去找 <code>资源服务器</code> 要数据。</p>
<hr>
<h4 id="5-2-3-四种核心授权模式-Grant-Types"><a href="#5-2-3-四种核心授权模式-Grant-Types" class="headerlink" title="5.2.3 四种核心授权模式 (Grant Types)"></a>5.2.3 四种核心授权模式 (Grant Types)</h4><p>OAuth 2.0 定义了多种获取访问令牌的流程（称为“授权模式”），以适应不同的客户端类型和应用场景。</p>
<h5 id="1-授权码模式-Authorization-Code-Grant"><a href="#1-授权码模式-Authorization-Code-Grant" class="headerlink" title="1. 授权码模式 (Authorization Code Grant)"></a>1. 授权码模式 (Authorization Code Grant)</h5><ul>
<li><strong>流程概述</strong>: 这是<strong>功能最完整、最安全、最推荐</strong>的模式。<ol>
<li>客户端将资源所有者重定向到授权服务器。</li>
<li>资源所有者登录并授权。</li>
<li>授权服务器将资源所有者重定向回客户端，并附带一个<strong>一次性的授权码 (Authorization Code)</strong>。</li>
<li>客户端在<strong>后端</strong>，使用自己的 <code>client_id</code>, <code>client_secret</code> 和上一步获得的授权码，向授权服务器请求令牌。</li>
<li>授权服务器验证所有信息后，返回<strong>访问令牌 (Access Token)</strong> 和可选的<strong>刷新令牌 (Refresh Token)</strong>。</li>
</ol>
</li>
<li><strong>适用场景</strong>:<ul>
<li>传统的<strong>服务端 Web 应用</strong>（如 Java, Python, Ruby on Rails 应用），因为它们有安全的后端来存储 <code>client_secret</code> 和处理与授权服务器的通信。</li>
<li><strong>第三方登录</strong>（“Login with Google&#x2F;GitHub”）的核心就是这个模式。</li>
</ul>
</li>
<li><strong>安全性</strong>: 非常高。因为敏感的令牌交换是在后端服务器之间进行的，不会暴露给前端浏览器。</li>
</ul>
<hr>
<h5 id="2-简化模式-Implicit-Grant-已不推荐"><a href="#2-简化模式-Implicit-Grant-已不推荐" class="headerlink" title="2. 简化模式 (Implicit Grant) - (已不推荐)"></a>2. 简化模式 (Implicit Grant) - (已不推荐)</h5><ul>
<li><strong>流程概述</strong>:<ol>
<li>流程与授权码模式类似，但授权服务器在用户授权后，<strong>直接</strong>通过重定向将<strong>访问令牌</strong>返回给客户端的前端。</li>
<li>没有授权码交换的步骤。</li>
</ol>
</li>
<li><strong>适用场景</strong>:<ul>
<li>最初是为<strong>纯前端应用 (SPA)</strong> 设计的，因为它们没有后端来安全地存储 <code>client_secret</code>。</li>
</ul>
</li>
<li><strong>安全性</strong>: <strong>较低，已不推荐使用</strong>。因为访问令牌直接暴露在浏览器中，容易被截获。现代 SPA 应用应使用<strong>带有 PKCE 的授权码模式</strong>来替代。</li>
</ul>
<hr>
<h5 id="3-密码模式-Resource-Owner-Password-Credentials-Grant-已不推荐"><a href="#3-密码模式-Resource-Owner-Password-Credentials-Grant-已不推荐" class="headerlink" title="3. 密码模式 (Resource Owner Password Credentials Grant) - (已不推荐)"></a>3. 密码模式 (Resource Owner Password Credentials Grant) - (已不推荐)</h5><ul>
<li><strong>流程概述</strong>:<ol>
<li>客户端直接向用户索要用户名和密码。</li>
<li>客户端将用户名、密码、<code>client_id</code> 和 <code>client_secret</code> 一起发送给授权服务器。</li>
<li>授权服务器验证后，直接返回访问令牌。</li>
</ol>
</li>
<li><strong>适用场景</strong>:<ul>
<li>仅限于<strong>高度可信的“第一方”客户端</strong>（例如，官方自己开发的移动 App）。</li>
</ul>
</li>
<li><strong>安全性</strong>: <strong>较低，强烈不推荐使用</strong>。因为它违背了 OAuth 2.0 的核心原则——不向客户端暴露用户密码。这使得客户端可以存储用户密码，增加了风险。</li>
</ul>
<hr>
<h5 id="4-客户端凭证模式-Client-Credentials-Grant"><a href="#4-客户端凭证模式-Client-Credentials-Grant" class="headerlink" title="4. 客户端凭证模式 (Client Credentials Grant)"></a>4. 客户端凭证模式 (Client Credentials Grant)</h5><ul>
<li><strong>流程概述</strong>:<ol>
<li><strong>没有资源所有者参与</strong>。</li>
<li>客户端直接使用自己的 <code>client_id</code> 和 <code>client_secret</code> 向授权服务器请求访问令牌。</li>
<li>授权服务器验证客户端身份后，返回一个访问令牌。这个令牌代表的是<strong>客户端自身</strong>，而不是某个最终用户。</li>
</ol>
</li>
<li><strong>适用场景</strong>:<ul>
<li><strong>机器对机器 (M2M) 的通信</strong>。例如，一个后台的数据同步服务需要调用另一个服务的 API。这个数据同步服务本身就是一个客户端，它需要访问资源，但这个过程与任何终端用户都无关。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-2-4-OIDC-OpenID-Connect-在-OAuth-2-0-之上构建的认证层"><a href="#5-2-4-OIDC-OpenID-Connect-在-OAuth-2-0-之上构建的认证层" class="headerlink" title="5.2.4 OIDC (OpenID Connect): 在 OAuth 2.0 之上构建的认证层"></a>5.2.4 OIDC (OpenID Connect): 在 OAuth 2.0 之上构建的认证层</h4><p>前面提到，OAuth 2.0 是一个授权框架。但实际应用中，我们经常需要“第三方登录”，这不仅需要授权，还需要<strong>认证</strong>——即“确认当前用户的身份是谁”。</p>
<p><strong>OIDC (OpenID Connect)</strong> 就是为了解决这个问题而生的。</p>
<ul>
<li><strong>定义</strong>: OIDC 是建立在 OAuth 2.0 协议之上的一个<strong>身份认证层 (Identity Layer)</strong>。</li>
<li><strong>核心扩展</strong>: OIDC 在 OAuth 2.0 的流程中，增加了一个关键产物：<strong>ID Token</strong>。<ul>
<li><strong>ID Token</strong> 是一个 <strong>JWT (JSON Web Token)</strong>。</li>
<li>它包含了关于<strong>资源所有者（用户）的身份信息</strong>，如用户的唯一标识符 (<code>sub</code>)、签发者 (<code>iss</code>)、签发时间 (<code>iat</code>) 等。</li>
<li>ID Token 经过了<strong>数字签名</strong>，客户端可以验证其真实性和完整性，从而确认用户的身份。</li>
</ul>
</li>
</ul>
<p><strong>OIDC 与 OAuth 2.0 的关系</strong>:</p>
<ul>
<li>所有 OIDC 流程都是合法的 OAuth 2.0 流程。</li>
<li>OIDC 在 OAuth 2.0 的基础上增加了 <code>openid</code> 这个特殊的 <code>scope</code> (权限范围)。当客户端请求中包含 <code>scope=openid</code> 时，授权服务器就知道这是一个 OIDC 请求。</li>
<li>在返回 <code>Access Token</code> 的同时，授权服务器还会返回一个 <code>ID Token</code>。</li>
</ul>
<p><strong>总结</strong>:</p>
<ul>
<li>如果你只需要<strong>授权</strong>（让应用 A 访问应用 B 的数据），使用 <strong>OAuth 2.0</strong>。</li>
<li>如果你需要<strong>认证</strong>（实现“使用 Google&#x2F;GitHub 登录”的功能），你需要的是 <strong>OIDC</strong>。</li>
</ul>
<p><strong>Spring Security OAuth2 Client 模块实际上就是一个 OIDC 的客户端实现</strong>，它能帮助我们轻松地集成支持 OIDC 的第三方认证服务。</p>
<hr>
<h3 id="5-3-Spring-Security-OAuth2-Client"><a href="#5-3-Spring-Security-OAuth2-Client" class="headerlink" title="5.3 Spring Security OAuth2 Client"></a>5.3 Spring Security OAuth2 Client</h3><p>Spring Security 的 <code>spring-security-oauth2-client</code> 模块极大地简化了作为 OAuth2&#x2F;OIDC 客户端与第三方身份提供商（IdP, Identity Provider）集成的过程。它封装了所有复杂的 OAuth2 授权码流程，让我们只需少量配置就能实现强大的第三方登录功能。</p>
<h4 id="5-3-1-核心流程回顾"><a href="#5-3-1-核心流程回顾" class="headerlink" title="5.3.1 核心流程回顾"></a>5.3.1 核心流程回顾</h4><p>当我们集成第三方登录时，我们的应用扮演的是 <strong>OAuth2 客户端 (Client)</strong> 的角色。整个流程遵循 <strong>授权码模式 (Authorization Code Grant)</strong>：</p>
<ol>
<li><strong>用户点击“使用 GitHub 登录”</strong>: 我们的应用将用户重定向到 GitHub 的授权页面。</li>
<li><strong>用户在 GitHub 上授权</strong>: 用户登录自己的 GitHub 账户，并同意授权我们的应用访问其基本信息。</li>
<li><strong>GitHub 重定向回应用</strong>: GitHub 将用户重定向回我们应用预先配置的回调 URL (<code>redirect-uri</code>)，并附带一个一次性的<strong>授权码 (code)</strong>。</li>
<li><strong>后台交换令牌</strong>: Spring Security OAuth2 Client 模块自动拦截这个回调请求，在后台用授权码、<code>client-id</code> 和 <code>client-secret</code> 向 GitHub 的 Token 端点交换<strong>访问令牌 (Access Token)</strong>。</li>
<li><strong>获取用户信息</strong>: 获得 Access Token 后，模块会用它去请求 GitHub 的 UserInfo 端点，获取用户的详细信息（如用户名、头像、邮箱等）。</li>
<li><strong>创建本地会话</strong>: 模块将获取到的第三方用户信息适配成一个 <code>Authentication</code> 对象，并存入 <code>SecurityContextHolder</code>，创建本地登录会话。</li>
<li><strong>用户登录成功</strong>: 用户被重定向到应用的首页或登录前的目标页面。</li>
</ol>
<p><strong>好消息是：以上所有步骤，Spring Security 都已经为我们自动处理好了！</strong> 我们需要做的主要是提供配置信息。</p>
<hr>
<h4 id="5-3-2-集成第三方登录（以-GitHub-为例）"><a href="#5-3-2-集成第三方登录（以-GitHub-为例）" class="headerlink" title="5.3.2 集成第三方登录（以 GitHub 为例）"></a>5.3.2 集成第三方登录（以 GitHub 为例）</h4><p><strong>步骤 1: 引入依赖</strong></p>
<p>确保你的 <code>pom.xml</code> 中包含了 <code>oauth2-client</code> 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-oauth2-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在第三方平台注册应用</strong></p>
<p>你必须先到你要集成的第三方平台（如 GitHub, Google, Facebook）的开发者中心注册你的应用，以获取凭证。</p>
<p><strong>以 GitHub 为例</strong>:</p>
<ol>
<li>登录 GitHub，进入 <code>Settings</code> -&gt; <code>Developer settings</code> -&gt; <code>OAuth Apps</code> -&gt; <code>New OAuth App</code>。</li>
<li>填写应用信息：<ul>
<li><strong>Application name</strong>: 你的应用名称。</li>
<li><strong>Homepage URL</strong>: 你的应用主页地址，例如 <code>http://localhost:8080</code>。</li>
<li><strong>Authorization callback URL</strong>: <strong>极其重要！</strong> 这是 GitHub 在用户授权后将用户重定向回来的地址。Spring Security 默认的格式是 <code>{baseUrl}/login/oauth2/code/{registrationId}</code>。<ul>
<li><code>baseUrl</code>: 你的应用的基础 URL，例如 <code>http://localhost:8080</code>。</li>
<li><code>registrationId</code>: 你在 <code>application.yml</code> 中为这个提供商起的名字，对于 GitHub，通常就是 <code>github</code>。</li>
<li>所以，这里应该填写 <code>http://localhost:8080/login/oauth2/code/github</code>。</li>
</ul>
</li>
</ul>
</li>
<li>注册成功后，你将获得一个 <strong>Client ID</strong> 和一个 <strong>Client Secret</strong>。<strong>请妥善保管 Client Secret，绝不要泄露到前端或公共代码库中。</strong></li>
</ol>
<p><strong>步骤 3: 配置 <code>application.yml</code></strong></p>
<p>这是最核心的配置步骤。Spring Boot 对常见的 OAuth2 提供商（Google, GitHub, Facebook, Okta）提供了极简的自动化配置。</p>
<p>在 <code>src/main/resources/application.yml</code> 中添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">registration:</span></span><br><span class="line">          <span class="comment"># &quot;github&quot; 是这个配置的 registrationId，必须与回调 URL 中的一致</span></span><br><span class="line">          <span class="attr">github:</span> </span><br><span class="line">            <span class="attr">client-id:</span> <span class="string">YOUR_GITHUB_CLIENT_ID</span> <span class="comment"># 替换成你的 Client ID</span></span><br><span class="line">            <span class="attr">client-secret:</span> <span class="string">YOUR_GITHUB_CLIENT_SECRET</span> <span class="comment"># 替换成你的 Client Secret</span></span><br><span class="line">            <span class="comment"># scope: # (可选) 指定请求的权限范围，如 read:user, user:email</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment"># 如果要同时集成 Google</span></span><br><span class="line">          <span class="attr">google:</span></span><br><span class="line">            <span class="attr">client-id:</span> <span class="string">YOUR_GOOGLE_CLIENT_ID</span></span><br><span class="line">            <span class="attr">client-secret:</span> <span class="string">YOUR_GOOGLE_CLIENT_SECRET</span></span><br><span class="line">            <span class="attr">scope:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">openid</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">profile</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">email</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">provider:</span></span><br><span class="line">          <span class="comment"># 对于非 Spring Boot 预置的提供商，需要在这里手动配置端点信息。</span></span><br><span class="line">          <span class="comment"># 对于 GitHub, Google 等，这些信息都是自动配置的，所以 provider 部分可以省略。</span></span><br></pre></td></tr></table></figure>

<p><strong>配置解读</strong>:</p>
<ul>
<li><code>spring.security.oauth2.client.registration</code>: 这个路径下定义了所有客户端的注册信息。</li>
<li><code>github</code>: 这是我们为 GitHub 这个提供商定义的 <code>registrationId</code>。</li>
<li><code>client-id</code> &#x2F; <code>client-secret</code>: 填入从 GitHub 获取的凭证。</li>
<li><code>scope</code>: (可选) 定义你希望向用户申请的权限范围。对于 OIDC (如 Google)，<code>openid</code> 是必须的。</li>
</ul>
<p><strong>步骤 4: 启用 OAuth2 登录</strong></p>
<p>在你的 <code>SecurityFilterChain</code> 配置中，启用 <code>.oauth2Login()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/login**&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            .oauth2Login(Customizer.withDefaults()); <span class="comment">// 启用 OAuth2 登录，使用默认配置</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>oauth2Login()</code> 会自动配置 <code>OAuth2LoginAuthenticationFilter</code>，它负责处理整个 OAuth2 登录流程。</p>
<p><strong>步骤 5: 创建登录链接</strong></p>
<p>Spring Security 默认的登录发起 URL 格式是 <code>/oauth2/authorization/{registrationId}</code>。</p>
<p>你可以在你的登录页面（或任何页面）上添加入口链接：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 Thymeleaf 模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Login with:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oauth2/authorization/github&quot;</span>&gt;</span>GitHub<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oauth2/authorization/google&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当用户点击这个链接时，Spring Security 会自动将他们重定向到对应的第三方授权页面。</p>
<p><strong>就是这么简单！</strong> 完成以上步骤后，启动你的应用，访问首页，点击“GitHub”链接，你应该就能体验完整的第三方登录流程了。</p>
<hr>
<h4 id="5-3-3-获取第三方用户信息"><a href="#5-3-3-获取第三方用户信息" class="headerlink" title="5.3.3 获取第三方用户信息"></a>5.3.3 获取第三方用户信息</h4><p>当用户通过 OAuth2 登录成功后，Spring Security 会将获取到的用户信息封装成一个 <code>Authentication</code> 对象，其 <code>Principal</code> 通常是一个 <code>OAuth2User</code> (对于标准 OAuth2) 或 <code>OidcUser</code> (对于 OIDC) 的实例。</p>
<p>你可以在 Controller 中方便地获取这些信息。</p>
<p><strong>方法 1: 从 <code>Authentication</code> 对象获取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getUserInfo</span><span class="params">(Authentication authentication)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是从 OAuth2 登录</span></span><br><span class="line">        <span class="keyword">if</span> (authentication.getPrincipal() <span class="keyword">instanceof</span> OAuth2User) &#123;</span><br><span class="line">            <span class="type">OAuth2User</span> <span class="variable">oauth2User</span> <span class="operator">=</span> (OAuth2User) authentication.getPrincipal();</span><br><span class="line">            <span class="comment">// attributes 包含了从 UserInfo 端点获取的所有用户信息</span></span><br><span class="line">            <span class="keyword">return</span> oauth2User.getAttributes();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是 OIDC 登录 (如 Google)</span></span><br><span class="line">        <span class="keyword">if</span> (authentication.getPrincipal() <span class="keyword">instanceof</span> OidcUser) &#123;</span><br><span class="line">            <span class="type">OidcUser</span> <span class="variable">oidcUser</span> <span class="operator">=</span> (OidcUser) authentication.getPrincipal();</span><br><span class="line">            <span class="comment">// OidcUser 包含更丰富的身份信息</span></span><br><span class="line">            Map&lt;String, Object&gt; claims = oidcUser.getClaims();</span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> oidcUser.getEmail();</span><br><span class="line">            <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> oidcUser.getFullName();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> claims;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理其他登录方式...</span></span><br><span class="line">        <span class="keyword">return</span> Map.of(<span class="string">&quot;username&quot;</span>, authentication.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法 2: 使用 <code>@AuthenticationPrincipal</code> 注解</strong></p>
<p>这是一种更简洁的方式，可以直接将 <code>Principal</code> 对象注入到方法参数中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.core.annotation.AuthenticationPrincipal;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.core.user.OAuth2User;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/info/principal&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getUserInfoFromPrincipal</span><span class="params">(<span class="meta">@AuthenticationPrincipal</span> OAuth2User principal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (principal == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户可能不是通过 OAuth2 登录的</span></span><br><span class="line">        <span class="keyword">return</span> Map.of(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;Not an OAuth2 user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// principal.getAttributes() 返回一个包含用户信息的 Map</span></span><br><span class="line">    <span class="comment">// 例如: &quot;login&quot; -&gt; &quot;username&quot;, &quot;avatar_url&quot; -&gt; &quot;...&quot;, &quot;name&quot; -&gt; &quot;...&quot;</span></span><br><span class="line">    <span class="keyword">return</span> principal.getAttributes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@AuthenticationPrincipal</code> 注解会自动进行类型转换。如果用户是通过 OIDC 登录的，你可以直接注入 <code>OidcUser</code> 类型。</p>
<p><strong>自定义处理</strong>:</p>
<p>在实际应用中，当用户首次通过第三方登录时，你可能需要在你的数据库中创建一个对应的用户记录。你可以通过自定义 <code>OAuth2UserService</code> 来实现这个逻辑，将获取到的 <code>OAuth2User</code> 信息保存到你的 <code>User</code> 实体中。</p>
<hr>
<h3 id="5-4-Spring-Security-OAuth2-Resource-Server"><a href="#5-4-Spring-Security-OAuth2-Resource-Server" class="headerlink" title="5.4 Spring Security OAuth2 Resource Server"></a>5.4 Spring Security OAuth2 Resource Server</h3><p>在 OAuth2 的世界里，<strong>资源服务器 (Resource Server)</strong> 是托管受保护资源（如用户数据、业务 API）的一方。它的核心职责是：<strong>接收并验证客户端出示的访问令牌 (Access Token)，只有在令牌有效且具备足够权限时，才允许访问资源</strong>。</p>
<p>Spring Security 的 <code>spring-security-oauth2-resource-server</code> 模块为我们构建这样的服务提供了强大的支持。</p>
<h4 id="5-4-1-核心概念与场景"><a href="#5-4-1-核心概念与场景" class="headerlink" title="5.4.1 核心概念与场景"></a>5.4.1 核心概念与场景</h4><ul>
<li><strong>场景</strong>: 你正在构建一个微服务或一个后端 RESTful API。这个 API 是无状态的，它不会处理用户登录流程。它只信任由一个独立的<strong>授权服务器 (Authorization Server)</strong>（如 Okta, Keycloak, Auth0，或者你自己用 Spring Authorization Server 构建的服务）签发的令牌。</li>
<li><strong>交互流程</strong>:<ol>
<li>前端应用（客户端）通过 OAuth2 流程（如授权码模式）从授权服务器获取到一个 Access Token。</li>
<li>前端应用在每次请求你的 API 时，都在 <code>Authorization</code> 请求头中携带这个令牌：<code>Authorization: Bearer &lt;access_token&gt;</code>。</li>
<li>你的 API 服务（资源服务器）拦截到请求，提取出 Access Token。</li>
<li>资源服务器<strong>独立地</strong>对这个 Token 进行验证。</li>
<li>如果验证通过，资源服务器处理请求并返回数据；否则，返回 <code>401 Unauthorized</code> 或 <code>403 Forbidden</code>。</li>
</ol>
</li>
<li><strong>关键点</strong>: 资源服务器<strong>不关心</strong>令牌是如何获取的，它只关心<strong>如何验证</strong>令牌的有效性。</li>
</ul>
<hr>
<h4 id="5-4-2-令牌验证的两种主要方式"><a href="#5-4-2-令牌验证的两种主要方式" class="headerlink" title="5.4.2 令牌验证的两种主要方式"></a>5.4.2 令牌验证的两种主要方式</h4><p>资源服务器验证 Access Token 的方式主要有两种：</p>
<ol>
<li><strong>JWT (JSON Web Token)</strong><ul>
<li><strong>原理</strong>: JWT 是<strong>自包含</strong>的。它本身就包含了所有验证所需的信息（签名、过期时间、签发者、权限等）。资源服务器只需要知道授权服务器的<strong>公钥</strong>或<strong>对称密钥</strong>，就可以在<strong>本地</strong>对 JWT 进行完整的验证，<strong>无需与授权服务器进行网络通信</strong>。</li>
<li><strong>优点</strong>: 性能高，可扩展性强。因为验证是离线的，不会给授权服务器带来压力。</li>
<li><strong>缺点</strong>: 令牌一旦签发，在过期前通常无法轻易撤销。</li>
</ul>
</li>
<li><strong>Opaque Token (不透明令牌)</strong><ul>
<li><strong>原理</strong>: Opaque Token 本身是一个无意义的、随机的字符串。它不包含任何用户信息。</li>
<li><strong>验证方式</strong>: 资源服务器必须通过网络调用授权服务器提供的一个特殊端点——<strong>内省端点 (Introspection Endpoint)</strong>，将令牌发送过去，由授权服务器来判断该令牌是否有效。</li>
<li><strong>优点</strong>: 安全性更高。授权服务器可以随时撤销任何一个令牌，资源服务器每次查询都能得到最新的状态。</li>
<li><strong>缺点</strong>: 性能较低，增加了网络延迟，并对授权服务器产生了强依赖和负载压力。</li>
</ul>
</li>
</ol>
<p><strong>在现代微服务架构中，JWT 是更常用、更主流的选择。</strong></p>
<hr>
<h4 id="5-4-3-构建受-JWT-保护的资源服务器"><a href="#5-4-3-构建受-JWT-保护的资源服务器" class="headerlink" title="5.4.3 构建受 JWT 保护的资源服务器"></a>5.4.3 构建受 JWT 保护的资源服务器</h4><p><strong>步骤 1: 引入依赖</strong></p>
<p>确保你的 <code>pom.xml</code> 中包含了 <code>oauth2-resource-server</code> 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-oauth2-resource-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 配置 <code>application.yml</code></strong></p>
<p>你需要告诉资源服务器如何找到用于验证 JWT 签名的公钥。授权服务器通常会通过一个标准的 <strong>JWK Set URI</strong> (<code>.well-known/jwks.json</code>) 来发布其公钥集。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">resourceserver:</span></span><br><span class="line">        <span class="attr">jwt:</span></span><br><span class="line">          <span class="comment"># JWK Set URI: 这是授权服务器发布其公钥的地方。</span></span><br><span class="line">          <span class="comment"># 你的资源服务器会启动时或首次需要时从这个地址下载公钥。</span></span><br><span class="line">          <span class="attr">jwk-set-uri:</span> <span class="string">https://your-auth-server.com/.well-known/jwks.json</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment"># (可选) Issuer URI: 指定期望的签发者。</span></span><br><span class="line">          <span class="comment"># 资源服务器会验证 JWT 中的 &#x27;iss&#x27; 声明是否与此值匹配，增强安全性。</span></span><br><span class="line">          <span class="comment"># Spring Boot 也能从此地址自动发现 JWK Set URI (通过 .well-known/openid-configuration)。</span></span><br><span class="line">          <span class="comment"># issuer-uri: https://your-auth-server.com</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>jwk-set-uri</code>: <strong>核心配置</strong>。指向授权服务器的公钥集地址。</li>
<li><code>issuer-uri</code>: 推荐配置。这不仅可以验证 <code>iss</code> 声明，还能让 Spring Boot 自动发现 <code>jwk-set-uri</code>，使得配置更简洁。如果配置了 <code>issuer-uri</code>，<code>jwk-set-uri</code> 就可以省略。</li>
</ul>
<p><strong>步骤 3: 启用资源服务器支持</strong></p>
<p>在你的 <code>SecurityFilterChain</code> 配置中，启用 <code>.oauth2ResourceServer()</code> 并指定使用 JWT。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableMethodSecurity</span> <span class="comment">// 强烈建议开启，以便进行基于 scope/claims 的方法级授权</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 1. 配置所有请求都需要认证</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 2. 启用 OAuth2 资源服务器支持，并指定使用 JWT</span></span><br><span class="line">            .oauth2ResourceServer(oauth2 -&gt; oauth2</span><br><span class="line">                .jwt(Customizer.withDefaults())</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(...))</code>: 这行代码会配置 <code>BearerTokenAuthenticationFilter</code>。这个过滤器负责从 <code>Authorization</code> Header 中提取 Bearer Token (JWT)，然后委托给 <code>JwtDecoder</code> 进行解码和验证。如果验证成功，它会创建一个 <code>JwtAuthenticationToken</code> 并放入 <code>SecurityContextHolder</code>。</li>
</ul>
<p><strong>步骤 4: 基于 Scope&#x2F;Claims 进行授权</strong></p>
<p>一旦 JWT 被成功验证，我们就可以利用其 Payload 中的声明（特别是 <code>scope</code> 或自定义的 <code>authorities</code> 声明）来进行细粒度的授权。</p>
<p><strong>URL 级别授权</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">    <span class="comment">// 要求 Token 必须包含 &quot;read&quot; 这个 scope</span></span><br><span class="line">    .requestMatchers(HttpMethod.GET, <span class="string">&quot;/api/data&quot;</span>).hasAuthority(<span class="string">&quot;SCOPE_read&quot;</span>)</span><br><span class="line">    <span class="comment">// 要求 Token 必须包含 &quot;write&quot; 这个 scope</span></span><br><span class="line">    .requestMatchers(HttpMethod.POST, <span class="string">&quot;/api/data&quot;</span>).hasAuthority(<span class="string">&quot;SCOPE_write&quot;</span>)</span><br><span class="line">    .anyRequest().authenticated()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: Spring Security 会自动为 <code>scope</code> 声明的值添加 <code>SCOPE_</code> 前缀，使其可以被 <code>hasAuthority()</code> 匹配。</p>
<p><strong>方法级别授权 (更推荐)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;SCOPE_read&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;You have read the data!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;SCOPE_write&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">writeData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;You have written the data!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 甚至可以基于自定义的 claim 进行判断</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;SCOPE_delete&#x27;) and #jwt.getClaimAsString(&#x27;department&#x27;) == &#x27;FINANCE&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteData</span><span class="params">(<span class="meta">@PathVariable</span> String id, <span class="meta">@AuthenticationPrincipal</span> Jwt jwt)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Data &quot;</span> + id + <span class="string">&quot; deleted by someone from FINANCE department.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@AuthenticationPrincipal Jwt jwt</code>: 可以直接注入解码后的 <code>Jwt</code> 对象，方便地访问其中的任何 claim。</li>
</ul>
<hr>
<h4 id="5-4-4-可选-配置-Opaque-Token-校验"><a href="#5-4-4-可选-配置-Opaque-Token-校验" class="headerlink" title="5.4.4 [可选] 配置 Opaque Token 校验"></a>5.4.4 [可选] 配置 Opaque Token 校验</h4><p>如果你的授权服务器使用不透明令牌，配置方式略有不同。</p>
<p><strong><code>application.yml</code> 配置</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">resourceserver:</span></span><br><span class="line">        <span class="attr">opaque-token:</span></span><br><span class="line">          <span class="comment"># 内省端点的 URI</span></span><br><span class="line">          <span class="attr">introspection-uri:</span> <span class="string">https://your-auth-server.com/oauth2/introspect</span></span><br><span class="line">          <span class="comment"># 资源服务器自己的凭证，用于向内省端点表明身份</span></span><br><span class="line">          <span class="attr">client-id:</span> <span class="string">your-resource-server-client-id</span></span><br><span class="line">          <span class="attr">client-secret:</span> <span class="string">your-resource-server-client-secret</span></span><br></pre></td></tr></table></figure>

<p><strong>Security 配置</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.oauth2ResourceServer(oauth2 -&gt; oauth2</span><br><span class="line">    .opaqueToken(Customizer.withDefaults())</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样配置后，<code>BearerTokenAuthenticationFilter</code> 会将提取到的令牌通过网络请求发送到 <code>introspection-uri</code> 进行验证。</p>
<hr>
<h3 id="5-5-选学-Spring-Authorization-Server"><a href="#5-5-选学-Spring-Authorization-Server" class="headerlink" title="5.5 [选学] Spring Authorization Server"></a>5.5 [选学] Spring Authorization Server</h3><p>在前面的章节中，我们学习了如何作为 <strong>客户端 (Client)</strong> 去集成第三方登录，以及如何作为 <strong>资源服务器 (Resource Server)</strong> 去保护 API。但提供这些服务的<strong>授权服务器 (Authorization Server)</strong> 是由第三方（如 Google, GitHub, Okta）提供的。</p>
<p><strong>Spring Authorization Server (SAS)</strong> 项目则让我们有能力<strong>自己从零构建一个功能齐全、符合 OAuth 2.1 和 OIDC 1.0 规范的授权服务器</strong>。这意味着你可以成为自己生态系统中的“Google”或“Okta”。</p>
<h4 id="5-5-1-为什么需要自建授权服务器？"><a href="#5-5-1-为什么需要自建授权服务器？" class="headerlink" title="5.5.1 为什么需要自建授权服务器？"></a>5.5.1 为什么需要自建授权服务器？</h4><ul>
<li><strong>统一身份认证 (Single Sign-On, SSO)</strong>: 当你的公司有多个内部应用（如 CRM, HR 系统, Wiki）时，你希望员工只需登录一次，就可以访问所有授权的应用。SAS 是实现 SSO 的核心。</li>
<li><strong>中心化授权管理</strong>: 为你自己的所有 API 和微服务提供一个统一的令牌签发和管理中心。你可以集中控制哪个应用（客户端）可以访问哪个 API（资源），以及拥有哪些权限（scope）。</li>
<li><strong>开放平台能力</strong>: 如果你想构建一个开放平台，允许第三方开发者创建应用来访问你的用户数据（就像微信开放平台、GitHub Apps），那么一个标准的授权服务器是必不可少的。</li>
<li><strong>数据主权与合规性</strong>: 在某些行业（如金融、医疗），出于数据隐私和法规要求，必须将用户身份数据存储在自己的基础设施内，不能依赖外部 IdP。</li>
</ul>
<hr>
<h4 id="5-5-2-核心概念与组件"><a href="#5-5-2-核心概念与组件" class="headerlink" title="5.5.2 核心概念与组件"></a>5.5.2 核心概念与组件</h4><p>Spring Authorization Server 的设计遵循了 OAuth 2.1 规范，其核心是管理和协调以下几个关键实体：</p>
<ol>
<li><strong><code>RegisteredClient</code> (注册客户端)</strong><ul>
<li>代表一个在你的授权服务器上注册的<strong>客户端应用</strong>（如一个 Web 应用、一个移动 App、一个后台服务）。</li>
<li><strong>核心配置</strong>:<ul>
<li><code>clientId</code> &#x2F; <code>clientSecret</code>: 客户端的唯一凭证。</li>
<li><code>clientAuthenticationMethods</code>: 客户端如何向授权服务器验证自己（如 <code>client_secret_basic</code>）。</li>
<li><code>authorizationGrantTypes</code>: 该客户端被允许使用的授权模式（如 <code>AUTHORIZATION_CODE</code>, <code>CLIENT_CREDENTIALS</code>, <code>REFRESH_TOKEN</code>）。</li>
<li><code>redirectUris</code>: 对于授权码模式，授权成功后允许重定向回的白名单 URL。</li>
<li><code>scopes</code>: 该客户端被允许请求的权限范围。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>OAuth2AuthorizationService</code> (授权管理服务)</strong><ul>
<li>这是一个状态存储服务，用于<strong>持久化</strong>在授权过程中产生的状态，主要是<strong>授权码 (Authorization Code)</strong> 和<strong>访问&#x2F;刷新令牌 (Access&#x2F;Refresh Token)</strong>。</li>
<li>它将令牌与用户、客户端关联起来，并记录其状态（如是否已吊销）。</li>
<li>默认实现是基于内存的 (<code>InMemoryOAuth2AuthorizationService</code>)，生产环境必须替换为持久化实现（如 <code>JdbcOAuth2AuthorizationService</code>）。</li>
</ul>
</li>
<li><strong><code>OAuth2AuthorizationConsentService</code> (用户同意管理服务)</strong><ul>
<li>用于存储用户对特定客户端的授权同意记录。</li>
<li>当你看到“应用 XXX 希望访问你的以下信息：头像、昵称。你是否同意？”这个页面时，如果你点击“同意”，这个同意记录就会被此服务存储。下次同一个客户端请求相同权限时，可能就不需要你再次确认了。</li>
<li>同样有内存和 JDBC 实现。</li>
</ul>
</li>
<li><strong>JWK (JSON Web Key) 源</strong><ul>
<li>授权服务器需要一个**密钥对（公钥和私钥）**来对 JWT 进行签名。</li>
<li><code>JWKSource</code> 负责提供这些密钥。你可以从文件中加载，或者在启动时动态生成。</li>
<li>公钥会通过 <code>/oauth2/jwks</code> (JWK Set) 端点暴露出去，供资源服务器下载和验证令牌签名。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-5-3-从零构建一个最小化的授权服务器"><a href="#5-5-3-从零构建一个最小化的授权服务器" class="headerlink" title="5.5.3 从零构建一个最小化的授权服务器"></a>5.5.3 从零构建一个最小化的授权服务器</h4><p><strong>步骤 1: 引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2-authorization-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用与你的 Spring Boot 版本匹配的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 基础安全配置 (用户认证)</strong></p>
<p>授权服务器首先需要一个普通的用户认证机制，来确认<strong>资源所有者</strong>的身份。这里我们使用一个简单的内存用户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order(2)</span> <span class="comment">// 默认的安全过滤器链</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">defaultSecurityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">            .formLogin(Customizer.withDefaults());</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withDefaultPasswordEncoder()</span><br><span class="line">                .username(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 授权服务器核心配置</strong></p>
<p>这是最关键的一步。我们需要配置 SAS 提供的所有 OAuth2 端点（如 <code>/oauth2/authorize</code>, <code>/oauth2/token</code>）以及核心服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationServerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order(1)</span> <span class="comment">// 授权服务器的过滤器链，优先级更高</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">authorizationServerSecurityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 应用 SAS 的默认安全配置</span></span><br><span class="line">        OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 启用 OpenID Connect 1.0 功能</span></span><br><span class="line">        http.getConfigurer(OAuth2AuthorizationServerConfigurer.class)</span><br><span class="line">            .oidc(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 配置异常处理，将 OAuth2 相关的认证错误重定向到登录页面</span></span><br><span class="line">        http</span><br><span class="line">            .exceptionHandling(exceptions -&gt; exceptions</span><br><span class="line">                .defaultAuthenticationEntryPointFor(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">LoginUrlAuthenticationEntryPoint</span>(<span class="string">&quot;/login&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">MediaTypeRequestMatcher</span>(MediaType.TEXT_HTML)</span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 配置注册的客户端信息</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RegisteredClientRepository <span class="title function_">registeredClientRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RegisteredClient</span> <span class="variable">oidcClient</span> <span class="operator">=</span> RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">                .clientId(<span class="string">&quot;oidc-client&quot;</span>)</span><br><span class="line">                .clientSecret(<span class="string">&quot;&#123;noop&#125;secret&quot;</span>) <span class="comment">// 生产环境必须加密</span></span><br><span class="line">                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">                .redirectUri(<span class="string">&quot;http://127.0.0.1:8080/login/oauth2/code/oidc-client&quot;</span>)</span><br><span class="line">                .scope(OidcScopes.OPENID)</span><br><span class="line">                .scope(OidcScopes.PROFILE)</span><br><span class="line">                .scope(<span class="string">&quot;message.read&quot;</span>)</span><br><span class="line">                .scope(<span class="string">&quot;message.write&quot;</span>)</span><br><span class="line">                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(<span class="literal">true</span>).build())</span><br><span class="line">                .build();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用内存存储，生产环境应替换为 JdbcRegisteredClientRepository</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryRegisteredClientRepository</span>(oidcClient);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 配置用于 JWT 签名的密钥对</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JWKSource&lt;SecurityContext&gt; <span class="title function_">jwkSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> generateRsaKey();</span><br><span class="line">        <span class="type">RSAPublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">        <span class="type">RSAPrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">        <span class="type">RSAKey</span> <span class="variable">rsaKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RSAKey</span>.Builder(publicKey)</span><br><span class="line">                .privateKey(privateKey)</span><br><span class="line">                .keyID(UUID.randomUUID().toString())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">JWKSet</span> <span class="variable">jwkSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JWKSet</span>(rsaKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImmutableJWKSet</span>&lt;&gt;(jwkSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> KeyPair <span class="title function_">generateRsaKey</span><span class="params">()</span> &#123; <span class="comment">/* ... a helper method to generate RSA key pair ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 配置 ProviderSettings，定义授权服务器的 Issuer URI</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationServerSettings <span class="title function_">authorizationServerSettings</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AuthorizationServerSettings.builder().issuer(<span class="string">&quot;http://localhost:9000&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7. [可选] 配置 OAuth2AuthorizationConsentService 和 OAuth2AuthorizationService</span></span><br><span class="line">    <span class="comment">// 默认是 InMemory，生产应使用 JDBC 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ol>
<li><strong><code>authorizationServerSecurityFilterChain</code></strong>: 这是一个专门为 SAS 端点设计的安全过滤器链，通过 <code>@Order(1)</code> 确保它在默认的用户认证链之前被匹配。<code>OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http)</code> 是一个便捷方法，它会自动配置好所有必需的端点和过滤器。</li>
<li><strong><code>oidc(Customizer.withDefaults())</code></strong>: 启用 OIDC 支持，这会开启 <code>/userinfo</code> 端点，并在令牌响应中包含 ID Token。</li>
<li><strong><code>registeredClientRepository()</code></strong>: 定义了“谁可以（客户端）”来使用我们的授权服务。这里我们硬编码了一个客户端，在生产环境中，这些信息应该存储在数据库中 (<code>JdbcRegisteredClientRepository</code>)。</li>
<li><strong><code>jwkSource()</code></strong>: 提供了用于 JWT 签名的 RSA 密钥对。每次服务器重启都会生成新的密钥（仅用于演示）。生产中应从固定的密钥库文件加载。</li>
<li><strong><code>authorizationServerSettings()</code></strong>: 配置授权服务器的元数据，最重要的就是 <code>issuer</code> URI。</li>
</ol>
<p><strong>步骤 4: 运行与测试</strong><br>启动应用后，你的授权服务器就运行在 <code>http://localhost:9000</code> 了。你可以通过以下端点来观察它的能力：</p>
<ul>
<li><strong>Issuer Discovery</strong>: <code>http://localhost:9000/.well-known/openid-configuration</code><ul>
<li>这是一个标准的元数据端点，它会告诉客户端你的授权服务器的所有端点地址（授权、令牌、用户信息、JWKS 等）以及支持的功能。</li>
</ul>
</li>
<li><strong>JWK Set URI</strong>: <code>http://localhost:9000/oauth2/jwks</code><ul>
<li>资源服务器可以从这里获取用于验证 JWT 签名的公钥。</li>
</ul>
</li>
</ul>
<p>现在，你可以配置一个 OAuth2 Client 应用（就像 <code>5.3</code> 节那样），将其 <code>issuer-uri</code> 指向 <code>http://localhost:9000</code>，<code>client-id</code> 和 <code>client-secret</code> 配置为 <code>oidc-client</code> 和 <code>secret</code>，然后尝试通过你自己的授权服务器进行登录。</p>
<hr>
<h2 id="6-自定义与扩展"><a href="#6-自定义与扩展" class="headerlink" title="6. 自定义与扩展"></a>6. 自定义与扩展</h2><h3 id="6-1-自定义-SecurityFilterChain"><a href="#6-1-自定义-SecurityFilterChain" class="headerlink" title="6.1 自定义 SecurityFilterChain"></a>6.1 自定义 <code>SecurityFilterChain</code></h3><p>虽然 Spring Security 提供的默认配置和高级 DSL (<code>.formLogin()</code>, <code>.oauth2Login()</code>) 能够满足绝大多数需求，但在某些高级场景下，我们可能需要更精细地控制过滤器链的行为——比如插入一个自定义的认证过滤器（如 JWT），或者添加一个用于审计的日志过滤器。</p>
<h4 id="6-1-1-关键-Filter-的顺序"><a href="#6-1-1-关键-Filter-的顺序" class="headerlink" title="6.1.1 关键 Filter 的顺序"></a>6.1.1 关键 Filter 的顺序</h4><table>
<thead>
<tr>
<th align="left">顺序</th>
<th align="left">过滤器 (部分)</th>
<th align="left">职责</th>
<th align="left">为什么在这个位置？</th>
</tr>
</thead>
<tbody><tr>
<td align="left">早</td>
<td align="left"><code>CorsFilter</code></td>
<td align="left">处理跨域预检请求 (OPTIONS) 和添加 CORS 响应头。</td>
<td align="left">必须在任何认证&#x2F;授权之前处理，以允许前端脚本的跨域请求。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>CsrfFilter</code></td>
<td align="left">验证 CSRF Token。</td>
<td align="left">必须在任何会改变状态的操作（如登录）之前，防止 CSRF 攻击。</td>
</tr>
<tr>
<td align="left">中</td>
<td align="left"><code>LogoutFilter</code></td>
<td align="left">处理 <code>/logout</code> 请求，使会话失效。</td>
<td align="left">在认证过滤器之前，以便可以立即处理注销请求。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>UsernamePasswordAuthenticationFilter</code></td>
<td align="left">处理表单登录提交的用户名和密码。</td>
<td align="left">这是核心的认证入口之一。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>BasicAuthenticationFilter</code></td>
<td align="left">处理 HTTP Basic 认证头。</td>
<td align="left">提供了另一种认证方式。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>BearerTokenAuthenticationFilter</code></td>
<td align="left">(当使用 <code>.oauth2ResourceServer()</code> 时) 处理 Bearer Token。</td>
<td align="left">用于 API 的 Token 认证。</td>
</tr>
<tr>
<td align="left">晚</td>
<td align="left"><code>ExceptionTranslationFilter</code></td>
<td align="left">捕获 <code>AuthenticationException</code> 和 <code>AccessDeniedException</code> 并进行处理。</td>
<td align="left">它包裹了后续的过滤器，以便捕获它们抛出的安全异常。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>AuthorizationFilter</code></td>
<td align="left"><strong>执行最终的授权决策</strong>，检查用户是否有权限访问请求的 URL。</td>
<td align="left">必须在认证之后，因为只有知道了“你是谁”，才能判断“你能做什么”。</td>
</tr>
</tbody></table>
<p><strong>核心思想</strong>：通用策略和防御性检查在前，身份认证在中，权限决策在后。</p>
<hr>
<h4 id="6-1-2-添加、替换或移除默认的-Filter"><a href="#6-1-2-添加、替换或移除默认的-Filter" class="headerlink" title="6.1.2 添加、替换或移除默认的 Filter"></a>6.1.2 添加、替换或移除默认的 Filter</h4><p><code>HttpSecurity</code> 对象提供了多个方法来让我们在默认的过滤器链中“做手术”。</p>
<h5 id="1-创建自定义-Filter"><a href="#1-创建自定义-Filter" class="headerlink" title="1. 创建自定义 Filter"></a>1. 创建自定义 Filter</h5><p>首先自定义的过滤器。最佳实践是继承 <code>OncePerRequestFilter</code>，它能确保在一次请求分派中，你的过滤器逻辑只会被执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的日志过滤器示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestLoggingFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RequestLoggingFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                                    HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                    FilterChain filterChain)</span> </span><br><span class="line">                                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 在请求到达 Controller 之前执行</span></span><br><span class="line">        logger.info(<span class="string">&quot;Incoming request: &#123;&#125; &#123;&#125;&quot;</span>, request.getMethod(), request.getRequestURI());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将请求传递给链中的下一个过滤器</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 在响应返回给客户端之前执行</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        logger.info(<span class="string">&quot;Request finished in &#123;&#125; ms with status &#123;&#125;&quot;</span>, duration, response.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-添加-Filter"><a href="#2-添加-Filter" class="headerlink" title="2. 添加 Filter"></a>2. 添加 Filter</h5><p><code>HttpSecurity</code> 提供了三种主要的添加方式：</p>
<ul>
<li><p><strong><code>addFilterBefore(Filter filter, Class&lt;? extends Filter&gt; beforeFilter)</code></strong>:</p>
<ul>
<li><strong>含义</strong>: 将你的 <code>filter</code> 添加到 <code>beforeFilter</code> <strong>之前</strong>。</li>
<li><strong>最常用</strong>的场景：实现自定义认证。例如，在 <code>UsernamePasswordAuthenticationFilter</code> 尝试处理表单登录<strong>之前</strong>，先用你的 <code>JwtAuthenticationFilter</code> 检查一下请求头里有没有 JWT。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterBefore(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>addFilterAfter(Filter filter, Class&lt;? extends Filter&gt; afterFilter)</code></strong>:</p>
<ul>
<li><strong>含义</strong>: 将你的 <code>filter</code> 添加到 <code>afterFilter</code> <strong>之后</strong>。</li>
<li><strong>场景</strong>: 如果你的过滤器依赖于某个前置过滤器的执行结果。例如，你可能想在 <code>ExceptionTranslationFilter</code> <strong>之后</strong>添加一个过滤器来对特定的安全异常进行特殊格式化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterAfter(<span class="keyword">new</span> <span class="title class_">CustomExceptionFormattingFilter</span>(), ExceptionTranslationFilter.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>addFilterAt(Filter filter, Class&lt;? extends Filter&gt; atFilter)</code></strong>:</p>
<ul>
<li><strong>含义</strong>: 将你的 <code>filter</code> 添加到与 <code>atFilter</code> <strong>相同的位置</strong>，并可能替换它。</li>
<li><strong>场景</strong>: 如果你想完全替换掉一个 Spring Security 的默认过滤器。例如，你有一个高度定制的 <code>MyUsernamePasswordAuthenticationFilter</code>，你想用它来替换掉 Spring 默认的实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterAt(<span class="keyword">new</span> <span class="title class_">MyUsernamePasswordAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-替换或移除-Filter"><a href="#3-替换或移除-Filter" class="headerlink" title="3. 替换或移除 Filter"></a>3. 替换或移除 Filter</h5><p>通常，我们不直接“移除”一个 Filter 对象，而是通过<strong>禁用</strong>添加该 Filter 的功能特性来实现。</p>
<ul>
<li><p><strong>禁用 Form Login</strong>: 这会从过滤器链中移除 <code>UsernamePasswordAuthenticationFilter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin(formLogin -&gt; formLogin.disable());</span><br><span class="line"><span class="comment">// 或者更简洁的 http.formLogin(AbstractHttpConfigurer::disable);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>禁用 CSRF 防护</strong>: 这会移除 <code>CsrfFilter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.csrf(csrf -&gt; csrf.disable());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>禁用 HTTP Basic</strong>: 这会移除 <code>BasicAuthenticationFilter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.httpBasic(httpBasic -&gt; httpBasic.disable());</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>替换的典型流程</strong>:</p>
<p>实现 JWT 认证就是一个经典的“替换”流程：</p>
<ol>
<li><strong>禁用</strong>会话管理、Form Login、HTTP Basic 和 CSRF，因为这些都是有状态或不适用于 Token 认证的。</li>
<li><strong>添加</strong>你自定义的 <code>JwtAuthenticationFilter</code> 到合适的位置（通常是 <code>before</code> <code>UsernamePasswordAuthenticationFilter.class</code>）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 1. 禁用不需要的默认功能</span></span><br><span class="line">            .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">            .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">            .formLogin(form -&gt; form.disable())</span><br><span class="line">            .httpBasic(httpBasic -&gt; httpBasic.disable())</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 配置授权规则</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/api/auth/**&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 添加自定义的 JWT 过滤器</span></span><br><span class="line">            .addFilterBefore(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，即使 <code>UsernamePasswordAuthenticationFilter.class</code> 对应的过滤器因为 <code>formLogin().disable()</code> 而被移除了，这个类引用仍然可以作为一个有效的<strong>锚点</strong>，告诉 Spring Security 你的过滤器应该放在哪个逻辑位置上。</p>
<hr>
<h3 id="6-2-自定义认证逻辑"><a href="#6-2-自定义认证逻辑" class="headerlink" title="6.2 自定义认证逻辑"></a>6.2 自定义认证逻辑</h3><p>Spring Security 的认证架构是高度可插拔的。其核心在于 <code>AuthenticationManager</code> 将认证任务委托给一系列的 <code>AuthenticationProvider</code>。默认情况下，<code>DaoAuthenticationProvider</code> 负责处理用户名和密码。</p>
<p>当我们想实现全新的认证方式时，例如<strong>短信验证码登录</strong>、<strong>邮箱验证码登录</strong>、<strong>扫码登录</strong>或<strong>社交媒体一键登录</strong>（非标准 OAuth2），最佳实践就是<strong>创建我们自己的 <code>AuthenticationProvider</code></strong>。</p>
<h4 id="6-2-1-认证流程回顾与扩展点"><a href="#6-2-1-认证流程回顾与扩展点" class="headerlink" title="6.2.1 认证流程回顾与扩展点"></a>6.2.1 认证流程回顾与扩展点</h4><p>回想一下 <code>2.1</code> 节的认证流程：</p>
<ol>
<li><strong>Filter</strong> 拦截请求，从 <code>HttpServletRequest</code> 中提取凭证。</li>
<li>Filter 将凭证封装成一个**<code>Authentication</code> Token** (例如，<code>UsernamePasswordAuthenticationToken</code>)。</li>
<li>Token 被传递给 <strong><code>AuthenticationManager</code></strong> (<code>ProviderManager</code>)。</li>
<li><code>ProviderManager</code> 遍历其下的所有 <strong><code>AuthenticationProvider</code></strong>，询问谁能处理这种类型的 Token。</li>
<li>匹配的 <code>AuthenticationProvider</code> 执行核心认证逻辑，并返回一个<strong>已认证</strong>的 <code>Authentication</code> Token。</li>
</ol>
<p>要实现自定义认证，我们需要扩展以下三个关键组件：</p>
<ol>
<li><strong>自定义 <code>Authentication</code> Token</strong>: 用于封装新的凭证类型（如手机号和验证码）。</li>
<li><strong>自定义 <code>AuthenticationProvider</code></strong>: 用于实现新的认证逻辑（如校验验证码是否正确）。</li>
<li><strong>自定义 <code>Filter</code></strong>: 用于从请求中提取新的凭证，并发起认证流程。</li>
</ol>
<hr>
<h4 id="6-2-2-案例：实现短信验证码登录"><a href="#6-2-2-案例：实现短信验证码登录" class="headerlink" title="6.2.2 案例：实现短信验证码登录"></a>6.2.2 案例：实现短信验证码登录</h4><p>我们将以一个完整的“手机号 + 短信验证码”登录为例，一步步实现自定义认证。</p>
<p><strong>步骤 1: 创建自定义 <code>Authentication</code> Token</strong></p>
<p>我们需要一个类来携带手机号和验证码。这个类必须继承 <code>AbstractAuthenticationToken</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AbstractAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationToken</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationToken</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object principal; <span class="comment">// 通常是手机号</span></span><br><span class="line">    <span class="keyword">private</span> Object credentials; <span class="comment">// 通常是验证码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数1: 用于封装认证前的凭证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">null</span>); <span class="comment">// 认证前权限为 null</span></span><br><span class="line">        <span class="built_in">this</span>.principal = principal;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">        setAuthenticated(<span class="literal">false</span>); <span class="comment">// 明确标记为未认证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数2: 用于封装认证后的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationToken</span><span class="params">(Object principal, Object credentials,</span></span><br><span class="line"><span class="params">                                        Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(authorities); <span class="comment">// 认证后传入权限</span></span><br><span class="line">        <span class="built_in">this</span>.principal = principal;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">        <span class="built_in">super</span>.setAuthenticated(<span class="literal">true</span>); <span class="comment">// 明确标记为已认证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.credentials;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.principal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAuthenticated) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.setAuthenticated(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eraseCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.eraseCredentials();</span><br><span class="line">        credentials = <span class="literal">null</span>; <span class="comment">// 认证成功后清除凭证</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 创建自定义 <code>AuthenticationProvider</code></strong></p>
<p>这是核心认证逻辑的实现。它需要实现 <code>AuthenticationProvider</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.BadCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们有一个 SmsCodeService 用于校验验证码</span></span><br><span class="line"><span class="comment">// @Component</span></span><br><span class="line"><span class="comment">// public class SmsCodeService &#123;</span></span><br><span class="line"><span class="comment">//     public boolean verifyCode(String mobile, String code) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    <span class="keyword">private</span> SmsCodeService smsCodeService; <span class="comment">// 注入我们自己的验证码服务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数注入依赖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationProvider</span><span class="params">(UserDetailsService userDetailsService, SmsCodeService smsCodeService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">        <span class="built_in">this</span>.smsCodeService = smsCodeService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mobile</span> <span class="operator">=</span> (String) authentication.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> (String) authentication.getCredentials();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 核心校验逻辑：调用服务验证验证码是否正确</span></span><br><span class="line">        <span class="keyword">if</span> (!smsCodeService.verifyCode(mobile, code)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;SMS code is invalid.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 验证码正确，加载用户信息</span></span><br><span class="line">        <span class="comment">// 注意：这里的 UserDetailsService 是通过手机号加载用户的。</span></span><br><span class="line">        <span class="comment">// 你可能需要自定义 UserDetailsService 的实现。</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> userDetailsService.loadUserByUsername(mobile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 认证成功，创建一个已认证的 Token</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationToken</span> <span class="variable">authenticatedToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationToken</span>(</span><br><span class="line">                userDetails, <span class="comment">// principal 现在是 UserDetails 对象</span></span><br><span class="line">                <span class="literal">null</span>,        <span class="comment">// credentials 设为 null</span></span><br><span class="line">                userDetails.getAuthorities() <span class="comment">// 权限</span></span><br><span class="line">        );</span><br><span class="line">        authenticatedToken.setDetails(authentication.getDetails());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> authenticatedToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> &#123;</span><br><span class="line">        <span class="comment">// 告诉 AuthenticationManager，我能处理 SmsCodeAuthenticationToken 类型的 Token</span></span><br><span class="line">        <span class="keyword">return</span> (SmsCodeAuthenticationToken.class.isAssignableFrom(authentication));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>supports()</code> 方法至关重要</strong>，它就像 <code>Provider</code> 在向 <code>Manager</code> “举手”说：“这种类型的认证请求，我能处理！”</p>
<p><strong>步骤 3: 创建自定义 <code>Filter</code></strong></p>
<p>我们需要一个过滤器来拦截短信登录请求（例如 <code>POST /sms/login</code>），提取手机号和验证码，然后启动认证流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.AntPathRequestMatcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationProcessingFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_LOGIN_REQUEST_URL</span> <span class="operator">=</span> <span class="string">&quot;/sms/login&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HTTP_METHOD</span> <span class="operator">=</span> <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_SECURITY_FORM_MOBILE_KEY</span> <span class="operator">=</span> <span class="string">&quot;mobile&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_SECURITY_FORM_CODE_KEY</span> <span class="operator">=</span> <span class="string">&quot;code&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(DEFAULT_LOGIN_REQUEST_URL, HTTP_METHOD));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationFilter</span><span class="params">(AuthenticationManager authenticationManager)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(DEFAULT_LOGIN_REQUEST_URL, HTTP_METHOD), authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="comment">// 从请求中提取手机号和验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mobile</span> <span class="operator">=</span> request.getParameter(SPRING_SECURITY_FORM_MOBILE_KEY);</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> request.getParameter(SPRING_SECURITY_FORM_CODE_KEY);</span><br><span class="line">        </span><br><span class="line">        mobile = (mobile != <span class="literal">null</span>) ? mobile.trim() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        code = (code != <span class="literal">null</span>) ? code : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建未认证的 Token</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationToken</span>(mobile, code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将请求详情（如 IP 地址）设置到 Token 中</span></span><br><span class="line">        authRequest.setDetails(<span class="built_in">this</span>.authenticationDetailsSource.buildDetails(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 AuthenticationManager，发起认证</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 4: 将它们组装到 <code>SecurityFilterChain</code></strong></p>
<p>最后一步是将我们创建的这三个组件整合到安全配置中。这通常需要创建一个自定义的 <code>SecurityConfigurer</code>，或者直接在 <code>SecurityFilterChain</code> 中配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (注入 UserDetailsService, SmsCodeService 等)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http, AuthenticationManager authenticationManager)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建并配置我们的 Filter</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationFilter</span> <span class="variable">smsCodeFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationFilter</span>(authenticationManager);</span><br><span class="line">        <span class="comment">// (可选) 设置成功和失败的处理器</span></span><br><span class="line">        smsCodeFilter.setAuthenticationSuccessHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationSuccessHandler</span>());</span><br><span class="line">        smsCodeFilter.setAuthenticationFailureHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationFailureHandler</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建我们的 Provider</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationProvider</span> <span class="variable">smsCodeProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationProvider</span>(userDetailsService, smsCodeService);</span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">            .formLogin(Customizer.withDefaults())</span><br><span class="line">            <span class="comment">// 3. 将我们的 Provider 添加到 AuthenticationManager 的管理中</span></span><br><span class="line">            .authenticationProvider(smsCodeProvider)</span><br><span class="line">            <span class="comment">// 4. 将我们的 Filter 添加到过滤器链的合适位置</span></span><br><span class="line">            .addFilterAfter(smsCodeFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http.getSharedObject(AuthenticationManagerBuilder.class).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置解读</strong>:</p>
<ol>
<li>我们创建了 <code>SmsCodeAuthenticationFilter</code> 的实例。</li>
<li>我们创建了 <code>SmsCodeAuthenticationProvider</code> 的实例。</li>
<li>通过 <code>http.authenticationProvider(smsCodeProvider)</code>，我们将自定义的 Provider 注册到了 <code>ProviderManager</code> 中。现在 <code>ProviderManager</code> 在遍历时就能找到它了。</li>
<li>通过 <code>http.addFilterAfter(smsCodeFilter, ...)</code>，我们将自定义的 Filter 插入到了过滤器链中。放在 <code>UsernamePasswordAuthenticationFilter</code> 之后意味着，如果请求不是 <code>/sms/login</code>，它会继续被后面的过滤器处理（如表单登录过滤器）。</li>
</ol>
<p>现在，当用户向 <code>POST /sms/login</code> 发送包含 <code>mobile</code> 和 <code>code</code> 参数的请求时，你的自定义认证流程就会被完整地触发！</p>
<hr>
<p><strong>其他场景的思路</strong>:</p>
<ul>
<li><strong>扫码登录</strong>:<ol>
<li><strong>Filter</strong>: 拦截一个轮询接口（如 <code>/check-scan-status?ticket=xxx</code>）。</li>
<li><strong>Token</strong>: 包含一个一次性的 <code>ticket</code>。</li>
<li><strong>Provider</strong>: 认证逻辑是检查这个 <code>ticket</code> 对应的扫码状态（在 Redis 或数据库中）是否已被 App 端确认为“已扫码并同意登录”。如果确认，则加载用户信息，认证成功。</li>
</ol>
</li>
<li><strong>内部系统免密认证</strong>:<ol>
<li><strong>Filter</strong>: 从请求头或参数中提取一个预共享密钥或内部服务 Token。</li>
<li><strong>Token</strong>: 包含这个密钥。</li>
<li><strong>Provider</strong>: 认证逻辑是验证这个密钥是否有效，如果有效，则直接认证通过，并为其赋予一个预设的系统角色。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="6-3-自定义认证成功-失败处理器"><a href="#6-3-自定义认证成功-失败处理器" class="headerlink" title="6.3 自定义认证成功&#x2F;失败处理器"></a>6.3 自定义认证成功&#x2F;失败处理器</h3><p>在 Spring Security 的认证流程中，当 <code>AbstractAuthenticationProcessingFilter</code>（如 <code>UsernamePasswordAuthenticationFilter</code>）收到 <code>AuthenticationManager</code> 的认证结果后，它不会自己决定接下来该做什么，而是将后续处理委托给两个专门的策略接口：</p>
<ul>
<li><strong><code>AuthenticationSuccessHandler</code></strong>: 当认证<strong>成功</strong>时被调用。</li>
<li><strong><code>AuthenticationFailureHandler</code></strong>: 当认证<strong>失败</strong>时被调用。</li>
</ul>
<p>通过实现这两个接口，我们可以完全掌控认证成功或失败后的行为，例如返回自定义的 JSON、记录日志、更新用户统计数据等。</p>
<h4 id="6-3-1-AuthenticationSuccessHandler-处理认证成功"><a href="#6-3-1-AuthenticationSuccessHandler-处理认证成功" class="headerlink" title="6.3.1 AuthenticationSuccessHandler: 处理认证成功"></a>6.3.1 <code>AuthenticationSuccessHandler</code>: 处理认证成功</h4><h5 id="1-默认行为"><a href="#1-默认行为" class="headerlink" title="1. 默认行为"></a>1. 默认行为</h5><p>默认的 <code>SavedRequestAwareAuthenticationSuccessHandler</code> 非常智能，它会：</p>
<ol>
<li>检查 Session 中是否存在一个“被保存的请求”（<code>SavedRequest</code>）。这通常是用户在登录前尝试访问的那个受保护页面。</li>
<li>如果存在，它会将用户<strong>重定向到那个原始请求的 URL</strong>。</li>
<li>如果不存在（例如，用户是直接访问的登录页面），它会将用户重定向到一个配置好的<strong>默认成功 URL</strong>（通常是根路径 <code>/</code>）。</li>
</ol>
<p>这种行为非常适合传统的、基于页面的 Web 应用。</p>
<hr>
<h5 id="2-为什么需要自定义？"><a href="#2-为什么需要自定义？" class="headerlink" title="2. 为什么需要自定义？"></a>2. 为什么需要自定义？</h5><p>在前后端分离的架构中（例如 Vue&#x2F;React + Spring Boot API），前端发起登录请求后，期望的不是页面重定向，而是一个包含成功信息和 <strong>JWT (JSON Web Token)</strong> 的 <strong>JSON 响应</strong>。前端拿到这个 Token 后会将其存储起来，并在后续的 API 请求中携带。</p>
<hr>
<h5 id="3-实现登录成功后返回-JSON-Token"><a href="#3-实现登录成功后返回-JSON-Token" class="headerlink" title="3. 实现登录成功后返回 JSON Token"></a>3. 实现登录成功后返回 JSON Token</h5><p><strong>步骤 1: 创建 <code>AuthenticationSuccessHandler</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationSuccessHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil; <span class="comment">// 注入我们之前创建的 JWT 工具类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper; <span class="comment">// Spring Boot 自动配置的 Jackson ObjectMapper</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                        HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        Authentication authentication)</span></span><br><span class="line">                                        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从 Authentication 对象生成 JWT</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtUtil.generateToken(authentication);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 准备要返回的 JSON 数据</span></span><br><span class="line">        Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        responseData.put(<span class="string">&quot;code&quot;</span>, HttpStatus.OK.value());</span><br><span class="line">        responseData.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Login successful&quot;</span>);</span><br><span class="line">        responseData.put(<span class="string">&quot;token&quot;</span>, token);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置响应头</span></span><br><span class="line">        response.setStatus(HttpStatus.OK.value());</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将 JSON 数据写入响应体</span></span><br><span class="line">        response.getWriter().write(objectMapper.writeValueAsString(responseData));</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：这里我们已经处理了响应，所以不需要再调用 filterChain.doFilter()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>onAuthenticationSuccess</code> 方法的 <code>authentication</code> 参数是<strong>已认证</strong>的 <code>Authentication</code> 对象，包含了用户的 <code>UserDetails</code> 和权限信息。</li>
<li>我们利用 <code>JwtUtil</code> 为这个已认证的用户生成一个 JWT。</li>
<li>然后构建一个包含 Token 和成功信息的 Map。</li>
<li>最后，使用 <code>ObjectMapper</code> 将 Map 序列化为 JSON 字符串，并写入 <code>HttpServletResponse</code>。</li>
</ul>
<p><strong>步骤 2: 在安全配置中应用</strong></p>
<p>将我们自定义的 Handler 应用到 <code>.formLogin()</code> 配置中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">        )</span><br><span class="line">        .formLogin(form -&gt; form</span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 指定登录处理 URL</span></span><br><span class="line">            .successHandler(myAuthenticationSuccessHandler) <span class="comment">// ✨ 使用自定义的成功处理器</span></span><br><span class="line">            <span class="comment">// .failureHandler(...) // 稍后会添加失败处理器</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ... (通常会禁用 csrf 和 session)</span></span><br><span class="line">        .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">        .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当用户通过 <code>POST /login</code> 成功登录后，他们将收到一个 JSON 响应，而不是被重定向。</p>
<hr>
<h4 id="6-3-2-AuthenticationFailureHandler-处理认证失败"><a href="#6-3-2-AuthenticationFailureHandler-处理认证失败" class="headerlink" title="6.3.2 AuthenticationFailureHandler: 处理认证失败"></a>6.3.2 <code>AuthenticationFailureHandler</code>: 处理认证失败</h4><h5 id="1-默认行为-1"><a href="#1-默认行为-1" class="headerlink" title="1. 默认行为"></a>1. 默认行为</h5><p>默认的 <code>SimpleUrlAuthenticationFailureHandler</code> 会将用户<strong>重定向</strong>到一个指定的失败 URL，通常是 <code>/login?error</code>。它还会在 Session 中存储导致失败的 <code>AuthenticationException</code>，以便在登录页面上可以显示具体的错误信息（如“密码错误”或“用户不存在”）。</p>
<hr>
<h5 id="2-为什么需要自定义？-1"><a href="#2-为什么需要自定义？-1" class="headerlink" title="2. 为什么需要自定义？"></a>2. 为什么需要自定义？</h5><p>同样，在 REST API 场景中，我们不希望重定向，而是希望返回一个包含详细错误信息的 <strong>JSON 响应</strong>，并附带一个合适的 HTTP 状态码（通常是 <code>401 Unauthorized</code>）。</p>
<hr>
<h5 id="3-实现登录失败后返回-JSON"><a href="#3-实现登录失败后返回-JSON" class="headerlink" title="3. 实现登录失败后返回 JSON"></a>3. 实现登录失败后返回 JSON</h5><p><strong>步骤 1: 创建 <code>AuthenticationFailureHandler</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationFailureHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                        HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        AuthenticationException exception)</span></span><br><span class="line">                                        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 准备要返回的 JSON 数据</span></span><br><span class="line">        Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        responseData.put(<span class="string">&quot;code&quot;</span>, HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        responseData.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Login failed: &quot;</span> + exception.getMessage());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 也可以根据不同的异常类型返回更具体的信息</span></span><br><span class="line">        <span class="comment">// if (exception instanceof BadCredentialsException) &#123; ... &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 JSON 数据写入响应体</span></span><br><span class="line">        response.getWriter().write(objectMapper.writeValueAsString(responseData));</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>onAuthenticationFailure</code> 方法的 <code>exception</code> 参数是导致认证失败的具体异常，例如 <code>BadCredentialsException</code>, <code>UsernameNotFoundException</code> 等。</li>
<li>我们可以利用 <code>exception.getMessage()</code> 来获取友好的错误提示。</li>
<li>我们构建了一个包含错误信息的 JSON，并以 <code>401</code> 状态码返回给前端。</li>
</ul>
<p><strong>步骤 2: 在安全配置中应用</strong></p>
<p>将失败处理器也添加到 <code>.formLogin()</code> 配置中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .formLogin(form -&gt; form</span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">            .successHandler(myAuthenticationSuccessHandler)</span><br><span class="line">            .failureHandler(myAuthenticationFailureHandler) <span class="comment">// ✨ 使用自定义的失败处理器</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-自定义-AccessDecisionManager-AuthorizationManager-高级"><a href="#6-4-自定义-AccessDecisionManager-AuthorizationManager-高级" class="headerlink" title="6.4 自定义 AccessDecisionManager &#x2F; AuthorizationManager (高级)"></a>6.4 自定义 <code>AccessDecisionManager</code> &#x2F; <code>AuthorizationManager</code> (高级)</h3><p>标准的安全配置（如 <code>.requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)</code>）是<strong>静态</strong>的。这些规则在应用启动时就被硬编码在配置中。然而，在许多复杂的企业级应用中，权限需求是<strong>动态</strong>的：</p>
<ul>
<li>权限本身是在数据库中配置的，可以由管理员在运行时添加、修改或删除。</li>
<li>一个 URL 的访问权限可能不仅仅依赖于用户的角色，还可能依赖于请求的参数、当前时间、用户所属的部门等多种动态因素。</li>
</ul>
<p>为了实现这种级别的动态授权，我们需要深入到 Spring Security 的决策核心，自定义 <code>AccessDecisionManager</code> (传统架构) 或 <code>AuthorizationManager</code> (现代架构)。</p>
<h4 id="6-4-1-现代架构-自定义-AuthorizationManager"><a href="#6-4-1-现代架构-自定义-AuthorizationManager" class="headerlink" title="6.4.1 现代架构: 自定义 AuthorizationManager"></a>6.4.1 现代架构: 自定义 <code>AuthorizationManager</code></h4><p>在 Spring Security 6+ 中，<code>AuthorizationManager</code> 是推荐的、更简洁的授权决策接口。自定义它通常是实现动态授权的首选方式。</p>
<p><strong>场景</strong>: 假设我们有一个权限管理系统，数据库中有一张 <code>permission</code> 表，存储了 URL 路径与所需权限的对应关系。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> permission (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  url <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,      <span class="comment">-- 受保护的 URL 模式 (e.g., /api/users/**)</span></span><br><span class="line">  permission <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> <span class="comment">-- 访问该 URL 所需的权限 (e.g., user:list)</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一个用户-角色表，一个角色-权限表 (此处简化，权限直接关联用户)</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> user_permissions (</span><br><span class="line">  username <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  permission <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们的目标是：当一个请求进来时，根据请求的 URL 从数据库中查出所需的权限，然后检查当前用户是否拥有该权限。</p>
<p><strong>步骤 1: 创建自定义 <code>AuthorizationManager</code></strong></p>
<p>我们需要创建一个类，实现 <code>AuthorizationManager&lt;RequestAuthorizationContext&gt;</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authorization.AuthorizationDecision;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authorization.AuthorizationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.access.intercept.RequestAuthorizationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.AntPathMatcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicAuthorizationManager</span> <span class="keyword">implements</span> <span class="title class_">AuthorizationManager</span>&lt;RequestAuthorizationContext&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入用于查询数据库的服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PermissionService permissionService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">antPathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicAuthorizationManager</span><span class="params">(PermissionService permissionService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permissionService = permissionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationDecision <span class="title function_">check</span><span class="params">(Supplier&lt;Authentication&gt; authenticationSupplier, RequestAuthorizationContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前请求的 HttpServletRequest 对象</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> context.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestUrl</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从数据库中查询所有已配置的 URL 权限规则</span></span><br><span class="line">        Collection&lt;Permission&gt; allPermissions = permissionService.getAllPermissions();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历所有规则，找到与当前请求 URL 匹配的规则</span></span><br><span class="line">        <span class="keyword">for</span> (Permission permission : allPermissions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (antPathMatcher.match(permission.getUrl(), requestUrl)) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 4. 如果找到匹配规则，获取当前用户的认证信息</span></span><br><span class="line">                <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> authenticationSupplier.get();</span><br><span class="line">                <span class="keyword">if</span> (authentication == <span class="literal">null</span> || !authentication.isAuthenticated()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthorizationDecision</span>(<span class="literal">false</span>); <span class="comment">// 未认证用户直接拒绝</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 检查用户是否拥有该规则所要求的权限</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">requiredPermission</span> <span class="operator">=</span> permission.getPermission();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">hasPermission</span> <span class="operator">=</span> authentication.getAuthorities().stream()</span><br><span class="line">                        .anyMatch(grantedAuthority -&gt; grantedAuthority.getAuthority().equals(requiredPermission));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 6. 返回决策结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthorizationDecision</span>(hasPermission);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 如果没有匹配到任何已配置的规则，可以采取默认策略</span></span><br><span class="line">        <span class="comment">// 例如，默认拒绝 (更安全)，或者允许 (如果你的系统有大量公共接口)</span></span><br><span class="line">        <span class="comment">// 这里我们选择默认拒绝未明确配置的 URL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthorizationDecision</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>PermissionService</code> (示意)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermissionService</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个示例，实际应从数据库查询</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Permission&gt; <span class="title function_">getAllPermissions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在实际应用中，这里应该有缓存以提高性能</span></span><br><span class="line">        <span class="keyword">return</span> List.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Permission</span>(<span class="string">&quot;/api/users/**&quot;</span>, <span class="string">&quot;user:list&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Permission</span>(<span class="string">&quot;/api/orders/**&quot;</span>, <span class="string">&quot;order:manage&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在安全配置中使用自定义 <code>AuthorizationManager</code></strong></p>
<p>现在，我们可以在 <code>SecurityFilterChain</code> 中使用这个自定义的 <code>AuthorizationManager</code> 来保护所有请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DynamicAuthorizationManager dynamicAuthorizationManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">            <span class="comment">// 将所有请求的授权决策委托给我们自定义的 Manager</span></span><br><span class="line">            .anyRequest().access(dynamicAuthorizationManager)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>.anyRequest().access(dynamicAuthorizationManager)</code>，我们告诉 Spring Security：“对于任何请求，都不要使用 <code>hasRole</code>, <code>permitAll</code> 等静态规则了，直接调用我的 <code>dynamicAuthorizationManager</code> 来做决定吧！”</p>
<p><strong>优势</strong>:</p>
<ul>
<li><strong>完全动态</strong>: 现在你可以通过修改数据库中的 <code>permission</code> 表来实时地更新应用的授权规则，无需重启应用。</li>
<li><strong>逻辑集中</strong>: 所有 URL 相关的授权逻辑都集中在 <code>DynamicAuthorizationManager</code> 中，便于管理和审计。</li>
<li><strong>无限扩展</strong>: 你可以在 <code>check</code> 方法中实现任意复杂的逻辑，比如结合请求参数、请求头、当前时间等因素来做决策。</li>
</ul>
<hr>
<h4 id="6-4-2-传统架构-自定义-AccessDecisionManager-与-Voter"><a href="#6-4-2-传统架构-自定义-AccessDecisionManager-与-Voter" class="headerlink" title="6.4.2 传统架构: 自定义 AccessDecisionManager 与 Voter"></a><strong>6.4.2 传统架构: 自定义 <code>AccessDecisionManager</code> 与 <code>Voter</code></strong></h4><p>如果你正在维护一个老项目，或者需要实现更复杂的“投票”逻辑，你可能需要自定义 <code>AccessDecisionManager</code> 和 <code>Voter</code>。</p>
<p><strong>思路</strong>:</p>
<ol>
<li><strong>自定义 <code>FilterInvocationSecurityMetadataSource</code></strong>: 这个组件的职责是在 <code>AccessDecisionManager</code> 做决策之前，为它提供“决策所需的依据”（即 <code>ConfigAttribute</code>）。我们需要自定义它，让它根据请求的 URL 从数据库中查询出所需的权限，并封装成 <code>ConfigAttribute</code>。</li>
<li><strong>自定义 <code>AccessDecisionVoter</code></strong>: 创建一个 Voter，它能够理解我们自定义的 <code>ConfigAttribute</code>。它的 <code>vote</code> 方法会比较用户拥有的权限和 <code>ConfigAttribute</code> 中要求的权限。</li>
<li><strong>配置 <code>AccessDecisionManager</code></strong>: 将我们的自定义 Voter 配置到一个 <code>AccessDecisionManager</code> 中（例如 <code>AffirmativeBased</code>）。</li>
<li><strong>将它们整合到 <code>FilterSecurityInterceptor</code></strong>: 这是最终执行授权的过滤器。</li>
</ol>
<p>这个过程比自定义 <code>AuthorizationManager</code> 复杂得多，涉及的组件也更多。</p>
<p><strong>简化版自定义 <code>AccessDecisionManager</code> 示例</strong>:</p>
<p>我们也可以不使用 Voter，而是直接实现一个 <code>AccessDecisionManager</code>，将所有逻辑都放在里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicAccessDecisionManager</span> <span class="keyword">implements</span> <span class="title class_">AccessDecisionManager</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (注入 PermissionService, AntPathMatcher 等)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span> </span><br><span class="line">            <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((FilterInvocation) object).getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestUrl</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... (与 DynamicAuthorizationManager 类似的逻辑) ...</span></span><br><span class="line">        <span class="comment">// 1. 查数据库，找到匹配的 requiredPermission</span></span><br><span class="line">        <span class="comment">// 2. 检查 authentication.getAuthorities() 是否包含 requiredPermission</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasPermission</span> <span class="operator">=</span> ...; <span class="comment">// 检查逻辑</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!hasPermission) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(<span class="string">&quot;Access is denied.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有权限，则方法正常返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(ConfigAttribute attribute)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 支持所有类型的 ConfigAttribute</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FilterInvocation.class.isAssignableFrom(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置 (使用 <code>WebSecurityConfigurerAdapter</code> 的老式方法)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .withObjectPostProcessor(<span class="keyword">new</span> <span class="title class_">ObjectPostProcessor</span>&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;O <span class="keyword">extends</span> <span class="title class_">FilterSecurityInterceptor</span>&gt; O <span class="title function_">postProcess</span><span class="params">(O fsi)</span> &#123;</span><br><span class="line">                fsi.setAccessDecisionManager(<span class="keyword">new</span> <span class="title class_">DynamicAccessDecisionManager</span>());</span><br><span class="line">                <span class="comment">// fsi.setSecurityMetadataSource(...) 如果需要的话</span></span><br><span class="line">                <span class="keyword">return</span> fsi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .anyRequest().authenticated();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个配置方式比较晦涩，这也是 Spring Security 推荐迁移到 <code>AuthorizationManager</code> 的原因之一。</p>
<hr>
<h2 id="7-测试与最佳实践"><a href="#7-测试与最佳实践" class="headerlink" title="7. 测试与最佳实践"></a>7. 测试与最佳实践</h2><h3 id="7-1-Spring-Security-测试"><a href="#7-1-Spring-Security-测试" class="headerlink" title="7.1 Spring Security 测试"></a>7.1 Spring Security 测试</h3><p>在开发过程中，手动登录并测试每个受保护的端点既繁琐又容易出错。Spring Security 提供了强大的测试支持，允许我们编写自动化的集成测试，来验证我们的安全配置是否按预期工作。</p>
<h4 id="7-1-1-核心测试依赖"><a href="#7-1-1-核心测试依赖" class="headerlink" title="7.1.1 核心测试依赖"></a>7.1.1 核心测试依赖</h4><p>要进行 Spring Security 的测试，你需要确保项目中包含了以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot 的测试启动器，包含了 JUnit, Mockito, Spring Test 等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Spring Security 的测试支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-1-2-模拟已认证用户"><a href="#7-1-2-模拟已认证用户" class="headerlink" title="7.1.2 模拟已认证用户"></a>7.1.2 模拟已认证用户</h4><p><code>spring-security-test</code> 模块最核心的功能就是提供了一系列注解，让我们可以在测试方法运行时，轻松地**“伪造”**一个已认证的用户身份，而无需经过实际的登录流程。</p>
<h5 id="1-WithMockUser-最简单、最常用的模拟"><a href="#1-WithMockUser-最简单、最常用的模拟" class="headerlink" title="1. @WithMockUser: 最简单、最常用的模拟"></a>1. <code>@WithMockUser</code>: 最简单、最常用的模拟</h5><p>这个注解会在执行测试方法前，自动在 <code>SecurityContextHolder</code> 中放入一个模拟的 <code>Authentication</code> 对象。</p>
<p><strong>常用属性</strong>:</p>
<ul>
<li><code>username</code> &#x2F; <code>value</code>: 模拟的用户名（默认为 “user”）。</li>
<li><code>password</code>: 模拟的密码（默认为 “password”）。</li>
<li><code>roles</code>: 一个字符串数组，用于指定用户拥有的<strong>角色</strong>。<strong>注意</strong>: 你提供的角色名<strong>不需要</strong> <code>ROLE_</code> 前缀，注解会自动添加。</li>
<li><code>authorities</code>: 一个字符串数组，用于指定用户拥有的<strong>权限</strong>。这里的字符串会原样作为 <code>GrantedAuthority</code>。</li>
</ul>
<p><strong>示例</strong>:</p>
<p>假设我们有一个 <code>AdminController</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dashboard&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAdminDashboard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Welcome, Admin!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user-profile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserProfile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + authentication.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在来编写测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.test.context.support.WithMockUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span> <span class="comment">// 自动配置 MockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminControllerTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@WithMockUser(username = &quot;test_admin&quot;, roles = &#123;&quot;ADMIN&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whenAdminAccessesDashboard_thenSucceeds</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/admin/dashboard&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(content().string(<span class="string">&quot;Welcome, Admin!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@WithMockUser(username = &quot;test_user&quot;, roles = &#123;&quot;USER&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whenUserAccessesDashboard_thenIsForbidden</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// test_user 只有 USER 角色，没有 ADMIN 角色</span></span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/admin/dashboard&quot;</span>))</span><br><span class="line">               .andExpect(status().isForbidden()); <span class="comment">// 期望得到 403 Forbidden</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@WithMockUser(username = &quot;john.doe&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whenAnyAuthenticatedUserAccessesProfile_thenSucceeds</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/admin/user-profile&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(content().string(<span class="string">&quot;Hello, john.doe&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@SpringBootTest</code>: 加载完整的 Spring 应用上下文。</li>
<li><code>@AutoConfigureMockMvc</code>: 自动注入 <code>MockMvc</code> Bean，这是我们模拟 HTTP 请求的入口。</li>
<li><code>@WithMockUser</code> 应用在测试方法上，为该次测试提供了一个临时的安全上下文。方法执行完毕后，上下文会自动清理。</li>
</ul>
<hr>
<h5 id="2-WithUserDetails-使用真实的-UserDetailsService"><a href="#2-WithUserDetails-使用真实的-UserDetailsService" class="headerlink" title="2. @WithUserDetails: 使用真实的 UserDetailsService"></a>2. <code>@WithUserDetails</code>: 使用真实的 <code>UserDetailsService</code></h5><p><code>@WithMockUser</code> 非常方便，但它创建的是一个<strong>完全模拟</strong>的用户，这个用户可能并不存在于你的数据库中。如果你希望测试的 <code>Authentication</code> 对象是由你自己的 <code>UserDetailsService</code> 加载而来的真实用户数据，你应该使用 <code>@WithUserDetails</code>。</p>
<p><strong>前提</strong>: 你必须已经实现了一个 <code>UserDetailsService</code> Bean。</p>
<p><strong>常用属性</strong>:</p>
<ul>
<li><code>value</code> &#x2F; <code>username</code>: 指定要加载的用户名。</li>
<li><code>userDetailsServiceBeanName</code>: (可选) 如果你有多个 <code>UserDetailsService</code> 的实现，可以用这个属性指定要使用哪一个 Bean。</li>
</ul>
<p><strong>示例</strong>:<br>假设你的 <code>JpaUserDetailsService</code> 会从数据库加载用户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithUserDetails(&quot;real_admin_from_db&quot;)</span> <span class="comment">// 假设数据库中存在名为 &quot;real_admin_from_db&quot; 的用户</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenAuthenticatingWithRealUser_thenSucceeds</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 在这个测试方法中，SecurityContextHolder 中的 Principal</span></span><br><span class="line">    <span class="comment">// 将是一个由你的 JpaUserDetailsService.loadUserByUsername() 方法返回的真实 UserDetails 对象</span></span><br><span class="line">    </span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/admin/dashboard&quot;</span>))</span><br><span class="line">           .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>: 这种方式的测试保真度更高，因为它使用了你的真实用户数据加载逻辑，可以一并测试 <code>UserDetailsService</code> 的正确性。</p>
<hr>
<h4 id="7-1-3-结合-MockMvc-测试-Controller-层的安全端点"><a href="#7-1-3-结合-MockMvc-测试-Controller-层的安全端点" class="headerlink" title="7.1.3 结合 MockMvc 测试 Controller 层的安全端点"></a>7.1.3 结合 <code>MockMvc</code> 测试 Controller 层的安全端点</h4><p><code>MockMvc</code> 是 Spring Test 框架提供的服务器端测试工具，它允许我们在不启动完整 Web 服务器的情况下，对 Controller 进行“真实”的 HTTP 请求调用。</p>
<h5 id="1-测试未认证的访问"><a href="#1-测试未认证的访问" class="headerlink" title="1. 测试未认证的访问"></a>1. 测试未认证的访问</h5><p>要测试匿名用户访问受保护的端点，非常简单：<strong>不使用任何 <code>@With...</code> 注解即可</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenAnonymousAccessesProtectedEndpoint_thenIsRedirectedToLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 假设我们配置了 Form Login</span></span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/admin/dashboard&quot;</span>))</span><br><span class="line">           .andExpect(status().is3xxRedirection()) <span class="comment">// 期望 3xx 重定向</span></span><br><span class="line">           .andExpect(redirectedUrl(<span class="string">&quot;http://localhost/login&quot;</span>)); <span class="comment">// 期望重定向到登录页</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenAnonymousAccessesApiEndpoint_thenIsUnauthorized</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 假设 /api/data 是受保护的，且异常处理器会返回 401</span></span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/api/data&quot;</span>))</span><br><span class="line">           .andExpect(status().isUnauthorized()); <span class="comment">// 期望 401 Unauthorized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-测试-CSRF-防护"><a href="#2-测试-CSRF-防护" class="headerlink" title="2. 测试 CSRF 防护"></a>2. 测试 CSRF 防护</h5><p>当你的应用开启了 CSRF 防护时，所有“不安全”的请求（POST, PUT, DELETE）都必须携带有效的 CSRF Token。<code>spring-security-test</code> 提供了 <code>csrf()</code> 请求后处理器来自动处理这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithMockUser</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenPostingWithCsrfToken_thenSucceeds</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(post(<span class="string">&quot;/transfer&quot;</span>)</span><br><span class="line">                .param(<span class="string">&quot;amount&quot;</span>, <span class="string">&quot;100&quot;</span>)</span><br><span class="line">                .with(csrf())) <span class="comment">// ✨ 添加一个有效的 CSRF Token</span></span><br><span class="line">           .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithMockUser</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenPostingWithoutCsrfToken_thenIsForbidden</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(post(<span class="string">&quot;/transfer&quot;</span>)</span><br><span class="line">                .param(<span class="string">&quot;amount&quot;</span>, <span class="string">&quot;100&quot;</span>))</span><br><span class="line">                <span class="comment">// 没有 .with(csrf())</span></span><br><span class="line">           .andExpect(status().isForbidden()); <span class="comment">// 期望 403 Forbidden</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>with(csrf())</code> 会自动模拟一个合法的 CSRF Token 并将其放入请求中，让你的测试能够顺利通过 CSRF 过滤器的检查。</p>
<hr>
<h5 id="3-测试表单登录"><a href="#3-测试表单登录" class="headerlink" title="3. 测试表单登录"></a>3. 测试表单登录</h5><p><code>spring-security-test</code> 还提供了一个便捷的 <code>formLogin()</code> 请求处理器来模拟完整的表单登录流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.formLogin;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.authenticated;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.unauthenticated;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenLoginWithValidCredentials_thenIsAuthenticated</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(formLogin(<span class="string">&quot;/login&quot;</span>).user(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;password&quot;</span>)) <span class="comment">// 模拟表单登录</span></span><br><span class="line">           .andExpect(status().is3xxRedirection())</span><br><span class="line">           .andExpect(redirectedUrl(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">           .andExpect(authenticated().withUsername(<span class="string">&quot;user&quot;</span>)); <span class="comment">// 验证认证成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenLoginWithInvalidCredentials_thenIsUnauthenticated</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(formLogin(<span class="string">&quot;/login&quot;</span>).user(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;wrongpassword&quot;</span>))</span><br><span class="line">           .andExpect(status().is3xxRedirection())</span><br><span class="line">           .andExpect(redirectedUrl(<span class="string">&quot;/login?error&quot;</span>))</span><br><span class="line">           .andExpect(unauthenticated()); <span class="comment">// 验证认证失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>formLogin()</code> 极大地简化了登录接口的测试，同时 <code>authenticated()</code> 和 <code>unauthenticated()</code> 断言也让结果验证更清晰。</p>
<hr>
<h3 id="7-2-安全最佳实践"><a href="#7-2-安全最佳实践" class="headerlink" title="7.2 安全最佳实践"></a>7.2 安全最佳实践</h3><p>仅仅正确配置 Spring Security 是不够的，一个安全的应用是一个系统工程，需要遵循一系列业界公认的最佳实践。</p>
<h4 id="7-2-1-始终使用-HTTPS"><a href="#7-2-1-始终使用-HTTPS" class="headerlink" title="7.2.1 始终使用 HTTPS"></a>7.2.1 始终使用 HTTPS</h4><p><strong>为什么？</strong></p>
<p>未使用 HTTPS 的 HTTP 协议是<strong>明文传输</strong>的。这意味着在客户端和服务器之间传输的所有数据，包括用户名、密码、Session Cookie、JWT Token 以及任何敏感的业务数据，都可能被网络中间人（如同一 WiFi 下的攻击者、ISP、网络节点）轻易地窃听和截获。这就是所谓的<strong>中间人攻击 (Man-in-the-Middle, MITM)</strong>。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><p><strong>生产环境强制 HTTPS</strong>: 必须为你的生产环境配置 SSL&#x2F;TLS 证书。现在有许多免费的证书颁发机构（如 Let’s Encrypt），获取证书非常方便。</p>
</li>
<li><p><strong>配置 Spring Boot 开启 SSL</strong>: 在 <code>application.properties</code> 或 <code>yml</code> 中配置服务器 SSL 属性。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.ssl.key-store</span>=<span class="string">classpath:keystore.p12</span></span><br><span class="line"><span class="attr">server.ssl.key-store-password</span>=<span class="string">your-password</span></span><br><span class="line"><span class="attr">server.ssl.key-alias</span>=<span class="string">your-alias</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>HTTP 到 HTTPS 的自动重定向</strong>: 配置你的 Web 服务器（如 Nginx）或应用网关，将所有传入的 HTTP 请求（端口 80）自动重定向到 HTTPS（端口 443）。在 Spring Security 中，你也可以配置来实现这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.requiresChannel(channel -&gt; channel.anyRequest().requiresSecure());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 HSTS (HTTP Strict Transport Security)</strong>: 在响应头中添加 <code>Strict-Transport-Security</code>。这会告诉浏览器，在未来的一段时间内，所有对该域名的访问都<strong>必须</strong>使用 HTTPS，从而防止 SSL 剥离攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.headers(headers -&gt; headers</span><br><span class="line">    .httpStrictTransportSecurity(hsts -&gt; hsts</span><br><span class="line">        .includeSubDomains(<span class="literal">true</span>)</span><br><span class="line">        .maxAgeInSeconds(<span class="number">31536000</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="7-2-2-使用强大的密码编码策略"><a href="#7-2-2-使用强大的密码编码策略" class="headerlink" title="7.2.2 使用强大的密码编码策略"></a>7.2.2 使用强大的密码编码策略</h4><p><strong>为什么？</strong></p>
<p>正如 <code>2.3</code> 节所述，明文存储密码是灾难性的。即使是使用过时的哈希算法（如 MD5, SHA-1）也无法有效抵御现代的破解技术。一个强大的密码策略能够确保即使数据库被泄露，用户的原始密码也不会暴露。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><p><strong>选择合适的算法</strong>:</p>
<ul>
<li><strong>首选 <code>BCryptPasswordEncoder</code></strong>: 它是目前功能、安全性和易用性之间最好的平衡点，是绝大多数新项目的默认选择。</li>
<li>如果对安全有更高要求，可以考虑 <code>SCryptPasswordEncoder</code> 或 <code>Argon2PasswordEncoder</code>。</li>
</ul>
</li>
<li><p><strong>使用 <code>DelegatingPasswordEncoder</code></strong>: 这是 Spring Security 的默认行为，也是最佳实践。它允许你平滑地升级密码存储算法，而无需强制所有用户重置密码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring Boot 会自动配置这个，你只需要提供一个具体的 Encoder Bean 即可</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调整工作因子</strong>: 对于 <code>BCryptPasswordEncoder</code>，可以根据你的服务器性能调整其构造函数中的 <code>strength</code> 参数（默认为 10）。这个值越高，哈希计算越慢，暴力破解的难度就越大。你应该选择一个既能提供足够安全性，又不会导致登录响应时间过长的值。</p>
</li>
</ul>
<hr>
<h4 id="7-2-3-最小权限原则-Principle-of-Least-Privilege"><a href="#7-2-3-最小权限原则-Principle-of-Least-Privilege" class="headerlink" title="7.2.3 最小权限原则 (Principle of Least Privilege)"></a>7.2.3 最小权限原则 (Principle of Least Privilege)</h4><p><strong>为什么？</strong></p>
<p>这个原则要求任何用户、程序或进程只应拥有其完成任务所必需的最小权限集合。如果一个账户（无论是用户还是系统服务）被盗用，最小权限原则可以极大地限制攻击者能够造成的损害范围。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><strong>避免使用“超级管理员”</strong>: 不要创建一个可以为所欲为的 <code>SUPER_ADMIN</code> 角色，然后把它分配给所有需要管理权限的用户。</li>
<li><strong>基于角色的访问控制 (RBAC)</strong>: 将权限（细粒度的操作许可，如 <code>user:create</code>, <code>order:approve</code>）分配给角色（职责集合，如 <code>USER_MANAGER</code>, <code>ORDER_APPROVER</code>），再将角色分配给用户。</li>
<li><strong>默认拒绝</strong>: 你的授权策略应该是“默认拒绝，明确允许”。对于任何未明确配置权限的资源，都应该默认拒绝访问。在 Spring Security 中，这通常通过在授权规则链的末尾加上 <code>.anyRequest().authenticated()</code> 或 <code>.anyRequest().denyAll()</code> 来实现。</li>
<li><strong>为 API 客户端授权</strong>: 当使用客户端凭证模式为后台服务授权时，也应遵循最小权限原则。例如，一个“报表生成服务”只应被授予读取相关数据的权限，而绝不应该有写入或删除的权限。</li>
</ul>
<hr>
<h4 id="7-2-4-依赖项安全扫描"><a href="#7-2-4-依赖项安全扫描" class="headerlink" title="7.2.4 依赖项安全扫描"></a>7.2.4 依赖项安全扫描</h4><p><strong>为什么？</strong></p>
<p>你的应用不仅仅是你自己写的代码。它构建在大量的开源第三方库（依赖项）之上。这些依赖项可能存在已知的安全漏洞（CVEs - Common Vulnerabilities and Exposures）。攻击者常常利用这些公开的漏洞来攻击系统。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><strong>使用自动化扫描工具</strong>:<ul>
<li><strong>Maven</strong>: 使用 <code>dependency-check-maven</code> 插件。</li>
<li><strong>Gradle</strong>: 使用 <code>dependency-check-gradle</code> 插件。</li>
<li><strong>GitHub</strong>: 启用 <strong>Dependabot</strong>，它可以自动扫描你的依赖项，并在发现漏洞时创建 Pull Request 来更新到安全版本。</li>
<li><strong>商业工具</strong>: Snyk, Sonatype Nexus Lifecycle 等提供了更强大的扫描和管理功能。</li>
</ul>
</li>
<li><strong>保持依赖项更新</strong>: 定期（例如，在每个 sprint 开始时）检查并更新你的项目依赖到一个新的稳定版本。这不仅能修复已知的安全漏洞，还能获得性能改进和新功能。</li>
<li><strong>订阅安全通告</strong>: 关注你所使用的核心框架（如 Spring, Log4j）的安全邮件列表或公告，以便在出现严重漏洞（如 Log4Shell）时能第一时间响应。</li>
</ul>
<hr>
<h4 id="7-2-5-避免在日志中记录敏感信息"><a href="#7-2-5-避免在日志中记录敏感信息" class="headerlink" title="7.2.5 避免在日志中记录敏感信息"></a>7.2.5 避免在日志中记录敏感信息</h4><p><strong>为什么？</strong></p>
<p>日志是排查问题的重要工具，但也可能成为敏感信息泄露的源头。如果在日志中不慎打印了用户密码、Session ID、API Key、信用卡号、个人身份信息等，这些信息可能会被存储在日志文件、日志管理系统（如 ELK Stack）中，从而扩大了攻击面。任何能够访问日志系统的人都可能获取到这些敏感数据。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><p><strong>重写 <code>toString()</code> 方法</strong>: 对于包含敏感数据的 DTO 或实体类（如 <code>User</code>），务必重写其 <code>toString()</code> 方法，对敏感字段进行屏蔽。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegistrationDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserRegistrationDto&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">               <span class="string">&quot;, password=&#x27;[PROTECTED]&#x27;&quot;</span> +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Lombok 的 <code>@ToString(exclude = {&quot;password&quot;})</code> 是一个更简洁的方式。</p>
</li>
<li><p><strong>审查日志输出</strong>: 在代码审查（Code Review）时，特别注意 <code>logger.info()</code>, <code>System.out.println()</code> 等输出语句，确保它们没有直接打印包含敏感信息的完整对象或请求体。</p>
</li>
<li><p><strong>配置日志框架</strong>: 一些日志框架允许配置过滤器，自动屏蔽匹配特定模式（如信用卡号格式）的字符串。</p>
</li>
<li><p><strong>Spring Boot Actuator</strong>: 如果你使用了 Actuator 的 <code>/trace</code> 或 <code>/httptrace</code> 端点，要注意它默认可能会记录请求头和响应头。检查其配置，确保像 <code>Authorization</code> 或 <code>Cookie</code> 这样的敏感头信息被屏蔽了。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringData/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringData/" class="post-title-link" itemprop="url">Spring全家桶-SpringData</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-05 19:55:10" itemprop="dateCreated datePublished" datetime="2025-10-05T19:55:10+08:00">2025-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:09:43" itemprop="dateModified" datetime="2025-10-17T11:09:43+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="四、SpringData"><a href="#四、SpringData" class="headerlink" title="四、SpringData"></a>四、SpringData</h1><h2 id="1-Spring-JDBC"><a href="#1-Spring-JDBC" class="headerlink" title="1. Spring JDBC"></a>1. Spring JDBC</h2><h3 id="1-1-JdbcTemplate-的使用-CRUD操作"><a href="#1-1-JdbcTemplate-的使用-CRUD操作" class="headerlink" title="1.1 JdbcTemplate 的使用 (CRUD操作)"></a>1.1 <code>JdbcTemplate</code> 的使用 (CRUD操作)</h3><h4 id="1-1-1-什么是-JdbcTemplate？"><a href="#1-1-1-什么是-JdbcTemplate？" class="headerlink" title="1.1.1 什么是 JdbcTemplate？"></a>1.1.1 什么是 <code>JdbcTemplate</code>？</h4><p><code>JdbcTemplate</code> 是 Spring Framework 核心包 (<code>spring-jdbc</code>)中提供的一个核心类。它<strong>极大地简化了传统JDBC的使用</strong>，旨在解决原生JDBC开发的几大痛”点：</p>
<ol>
<li><strong>资源管理的繁琐</strong>: 原生JDBC需要手动管理<code>Connection</code>, <code>Statement</code>, <code>ResultSet</code>的创建和关闭，并且必须在<code>finally</code>块中进行以确保资源释放，代码冗长且容易出错。</li>
<li><strong>异常处理的复杂</strong>: 原生JDBC抛出的是受检异常 <code>SQLException</code>，开发者必须在代码中显式地<code>try-catch</code>。</li>
<li><strong>重复的样板代码</strong>: 每次查询都需要重复编写获取连接、创建<code>Statement</code>、执行SQL、遍历<code>ResultSet</code>、关闭资源等一系列步骤。</li>
</ol>
<p><strong><code>JdbcTemplate</code> 所做的就是将这些重复的、底层的、资源管理相关的“脏活累活”全部封装起来</strong>，让开发者可以只专注于两件核心的事情：</p>
<ol>
<li><strong>提供SQL语句</strong>。</li>
<li><strong>处理查询结果</strong>。</li>
</ol>
<hr>
<h4 id="1-1-2-配置与准备"><a href="#1-1-2-配置与准备" class="headerlink" title="1.1.2 配置与准备"></a>1.1.2 配置与准备</h4><p><strong>Step 1: 添加依赖</strong></p>
<p>只需要引入<code>spring-boot-starter-jdbc</code>依赖。通常，如果你使用了任何数据库相关的Starter（如<code>spring-boot-starter-data-jpa</code>或<code>spring-boot-starter-mybatis</code>），这个依赖已经被传递性地包含了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!-- 或者其他数据库驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 配置数据源 (<code>application.yml</code>)</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/testdb?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p><strong>Step 3: 注入 <code>JdbcTemplate</code></strong></p>
<p>Spring Boot的自动配置机制会检测到<code>DataSource</code>的存在，并<strong>自动为你创建一个 <code>JdbcTemplate</code> 的Bean</strong>。你只需要在需要使用它的地方（如Service或DAO层）通过 <code>@Autowired</code> 注入即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... CRUD方法将在这里实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-3-核心CRUD操作"><a href="#1-1-3-核心CRUD操作" class="headerlink" title="1.1.3 核心CRUD操作"></a>1.1.3 核心CRUD操作</h4><p>假设我们有一个<code>user</code>表，包含<code>id</code>, <code>username</code>, <code>password</code>, <code>email</code>字段。</p>
<h5 id="1-更新操作-INSERT-UPDATE-DELETE"><a href="#1-更新操作-INSERT-UPDATE-DELETE" class="headerlink" title="1. 更新操作 (INSERT, UPDATE, DELETE)"></a>1. 更新操作 (INSERT, UPDATE, DELETE)</h5><p>对于所有不返回结果集（只返回受影响行数）的写操作，都使用 <code>update()</code> 方法。</p>
<ul>
<li><strong><code>int update(String sql, Object... args)</code></strong>:<ul>
<li><code>sql</code>: 带有 <code>?</code> 占位符的SQL语句。</li>
<li><code>args</code>: 与 <code>?</code> 占位符按顺序对应的参数列表。</li>
<li><strong>返回值</strong>: <code>int</code> 类型，表示受影响的行数。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CREATE (INSERT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO user (username, password, email) VALUES (?, ?, ?)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(sql, user.getUsername(), user.getPassword(), user.getEmail());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UPDATE</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateUserEmail</span><span class="params">(Long id, String newEmail)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE user SET email = ? WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(sql, newEmail, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DELETE</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DELETE FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(sql, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>: <code>JdbcTemplate</code> 内部处理了 <code>PreparedStatement</code> 的创建和参数绑定，有效防止了<strong>SQL注入</strong>。</p>
<hr>
<h5 id="2-查询单个值-Query-for-a-Single-Value"><a href="#2-查询单个值-Query-for-a-Single-Value" class="headerlink" title="2. 查询单个值 (Query for a Single Value)"></a>2. 查询单个值 (Query for a Single Value)</h5><p>当你确定查询结果<strong>只有一行一列</strong>时（例如查询总数、获取某个用户的姓名），使用 <code>queryForObject()</code>。</p>
<ul>
<li><strong><code>T queryForObject(String sql, Class&lt;T&gt; requiredType, Object... args)</code></strong>:<ul>
<li><code>requiredType</code>: 期望返回值的类型（如 <code>Integer.class</code>, <code>String.class</code>）。</li>
<li><strong>注意</strong>: 如果查询没有返回任何行，或者返回了多行，此方法会抛出异常。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户总数</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">countUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT COUNT(*) FROM user&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ID查询用户名</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUsernameById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT username FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, String.class, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-查询单个对象-Query-for-a-Single-Object"><a href="#3-查询单个对象-Query-for-a-Single-Object" class="headerlink" title="3. 查询单个对象 (Query for a Single Object)"></a>3. 查询单个对象 (Query for a Single Object)</h5><p>当你需要将<strong>一行</strong>查询结果映射为一个完整的Java对象时，也使用 <code>queryForObject()</code>，但需要提供一个 <code>RowMapper</code>。</p>
<ul>
<li><strong><code>T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</code></strong>:<ul>
<li><code>RowMapper&lt;T&gt;</code>: 这是一个<strong>函数式接口</strong>，其核心方法是 <code>T mapRow(ResultSet rs, int rowNum)</code>。你需要在这个方法中实现如何将 <code>ResultSet</code> 的当前行数据，手动映射到你的Java对象的字段上。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ID查询一个完整的User对象</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RowMapper可以定义为匿名内部类，或Lambda表达式，或一个独立的类</span></span><br><span class="line">    RowMapper&lt;User&gt; rowMapper = (rs, rowNum) -&gt; &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(rs.getLong(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        user.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        user.setPassword(rs.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        user.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, rowMapper, id);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EmptyResultDataAccessException e) &#123;</span><br><span class="line">        <span class="comment">// queryForObject在找不到记录时会抛出此异常，可以捕获并返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Spring内置的 <code>BeanPropertyRowMapper</code></strong>:</p>
<p>如果你的Java Bean的<strong>字段名</strong>与数据库表的<strong>列名</strong>完全一致（或符合驼峰与下划线的转换规则），你可以使用 <code>BeanPropertyRowMapper</code> 来简化映射，无需手动编写<code>RowMapper</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserByIdSimple</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class), id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-查询对象列表-Query-for-a-List-of-Objects"><a href="#4-查询对象列表-Query-for-a-List-of-Objects" class="headerlink" title="4. 查询对象列表 (Query for a List of Objects)"></a>4. 查询对象列表 (Query for a List of Objects)</h5><p>当你需要查询<strong>多行</strong>数据，并将每一行都映射为一个Java对象时，使用 <code>query()</code> 方法。</p>
<ul>
<li><strong><code>List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</code></strong>:<ul>
<li>这个方法会遍历 <code>ResultSet</code> 的所有行，对每一行都调用你提供的 <code>RowMapper</code>，并将所有映射出的对象收集到一个 <code>List</code> 中返回。</li>
<li>如果查询结果为空，它会返回一个<strong>空的List</strong>，而不是<code>null</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有用户</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user&quot;</span>;</span><br><span class="line">    <span class="comment">// 可以复用上面定义的rowMapper，或者使用BeanPropertyRowMapper</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据email后缀查询用户</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUsersByEmailDomain</span><span class="params">(String domain)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE email LIKE ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class), <span class="string">&quot;%&quot;</span> + domain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-批量操作-Batch-Operations"><a href="#5-批量操作-Batch-Operations" class="headerlink" title="5. 批量操作 (Batch Operations)"></a>5. 批量操作 (Batch Operations)</h5><p>当需要执行大量相同的写操作时（如一次性插入1000条记录），使用 <code>batchUpdate()</code> 可以获得极高的性能，因为它会减少网络往返次数。</p>
<ul>
<li><strong><code>int[] batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</code></strong>:</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量添加用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] batchAddUsers(List&lt;User&gt; users) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO user (username, password, email) VALUES (?, ?, ?)&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        Object[] args = &#123;user.getUsername(), user.getPassword(), user.getEmail()&#125;;</span><br><span class="line">        batchArgs.add(args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-Spring-Data-Commons"><a href="#2-Spring-Data-Commons" class="headerlink" title="2. Spring Data Commons"></a>2. Spring Data Commons</h2><h3 id="2-1-核心理念"><a href="#2-1-核心理念" class="headerlink" title="2.1 核心理念"></a>2.1 核心理念</h3><h4 id="2-1-1-问题背景：传统数据访问层的痛点"><a href="#2-1-1-问题背景：传统数据访问层的痛点" class="headerlink" title="2.1.1 问题背景：传统数据访问层的痛点"></a>2.1.1 问题背景：传统数据访问层的痛点</h4><p>在 Spring Data 出现之前，即使使用了像 JPA&#x2F;Hibernate 这样的ORM框架，数据访问层（DAO&#x2F;Repository层）的开发依然存在大量重复的、机械化的<strong>样板代码 (Boilerplate Code)</strong>。</p>
<p>对于每一个实体（Entity），比如 <code>User</code>, <code>Order</code>, <code>Product</code>，我们通常都需要手动编写一个实现类，并在其中一遍又一遍地实现最基础的CRUD（创建、读取、更新、删除）操作：</p>
<p><strong>传统的JPA Repository实现示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span> <span class="comment">// 声明为数据访问Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span> <span class="comment">// 注入JPA的EntityManager</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager em;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> em.find(User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> em.createQuery(<span class="string">&quot;SELECT u FROM User u&quot;</span>, User.class).getResultList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (user.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">            em.persist(user); <span class="comment">// 新增</span></span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> em.merge(user); <span class="comment">// 更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        em.remove(em.contains(user) ? user : em.merge(user));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果需要按名字查找，还需要再写一个方法...</span></span><br><span class="line">    <span class="comment">// public User findByUsername(String username) &#123; ... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>痛点分析</strong>：</p>
<ol>
<li><strong>高度重复</strong>: <code>findById</code>, <code>findAll</code>, <code>save</code>, <code>delete</code> 的实现逻辑在99%的情况下都是完全一样的，但我们却要为每个实体都写一遍。</li>
<li><strong>容易出错</strong>: 手动编写JPQL或SQL语句容易出现拼写错误。</li>
<li><strong>工作量大</strong>: 应用中有几十个实体，就意味着要写几十个这样的实现类。</li>
</ol>
<hr>
<h4 id="2-1-2-核心理念：统一的数据访问抽象-Unified-Data-Access-Abstraction"><a href="#2-1-2-核心理念：统一的数据访问抽象-Unified-Data-Access-Abstraction" class="headerlink" title="2.1.2 核心理念：统一的数据访问抽象 (Unified Data Access Abstraction)"></a>2.1.2 核心理念：统一的数据访问抽象 (Unified Data Access Abstraction)</h4><p><strong>Spring Data Commons 的核心理念</strong>就是为了解决上述痛点，它旨在提供一个<strong>统一的、基于Repository模式的数据访问层抽象</strong>，使得开发者无论使用何种持久化技术（关系型数据库、NoSQL数据库等），都能享有一致的、极简的编程模型。</p>
<p><strong>Spring Data Commons 本身不提供任何具体的数据访问实现</strong>。它就像一个**“规范”<strong>或</strong>“蓝图”<strong>，定义了一系列通用的接口和注解。而 Spring Data JPA, Spring Data MongoDB 等具体的模块，则是对这个“规范”的</strong>具体实现**。</p>
<p>这个理念主要通过以下两大支柱来实现：</p>
<h5 id="1-Repository-模式的终极抽象"><a href="#1-Repository-模式的终极抽象" class="headerlink" title="1. Repository 模式的终极抽象"></a>1. Repository 模式的终极抽象</h5><p>Spring Data Commons 将<strong>仓储模式 (Repository Pattern)</strong> 提升到了一个新的高度。它提供了一系列核心接口，开发者只需要继承这些接口，<strong>无需编写任何实现代码</strong>，就能在运行时自动获得强大的数据访问能力。</p>
<ul>
<li><strong><code>Repository&lt;T, ID&gt;</code></strong>:<ul>
<li>最顶层的<strong>标记接口 (Marker Interface)</strong>。它本身不包含任何方法。</li>
<li>它的作用是告诉Spring Data：“这个接口是一个用于数据访问的Repository”。</li>
<li><code>T</code> 代表实体类型（如 <code>User</code>），<code>ID</code> 代表主键类型（如 <code>Long</code>）。</li>
</ul>
</li>
<li><strong><code>CrudRepository&lt;T, ID&gt;</code></strong>:<ul>
<li>继承自 <code>Repository</code>，提供了最基础、最通用的<strong>CRUD</strong>方法。</li>
<li>例如：<code>save()</code>, <code>findById()</code>, <code>findAll()</code>, <code>count()</code>, <code>deleteById()</code>, <code>existsById()</code> 等。</li>
<li><strong>在 90% 的场景下，继承这个接口就足够了</strong>。</li>
</ul>
</li>
<li><strong><code>PagingAndSortingRepository&lt;T, ID&gt;</code></strong>:<ul>
<li>继承自 <code>CrudRepository</code>，额外增加了对<strong>分页 (Pagination)</strong> 和<strong>排序 (Sorting)</strong> 的支持。</li>
<li>例如：<code>findAll(Sort sort)</code>, <code>findAll(Pageable pageable)</code>。</li>
</ul>
</li>
</ul>
<p><strong>核心魔法</strong>：</p>
<p>当你定义一个接口 <code>interface UserRepository extends CrudRepository&lt;User, Long&gt; {}</code> 时，Spring Data在应用启动时，会通过<strong>动态代理 (Dynamic Proxy)</strong> 技术，在内存中<strong>自动为你生成这个接口的实现类</strong>。这个实现类包含了所有<code>CrudRepository</code>中定义方法的高效实现。你只需要定义接口，实现由框架搞定！</p>
<hr>
<h5 id="2-约定优于配置-Convention-over-Configuration-的查询方法"><a href="#2-约定优于配置-Convention-over-Configuration-的查询方法" class="headerlink" title="2. 约定优于配置 (Convention over Configuration) 的查询方法"></a>2. 约定优于配置 (Convention over Configuration) 的查询方法</h5><p>这是 Spring Data 另一个“杀手锏”功能，被称为 <strong>Query Methods</strong> 或 <strong>方法命名查询</strong>。</p>
<ul>
<li><strong>理念</strong>: 你不再需要手写JPQL或SQL查询语句。你只需要按照<strong>预定义的命名约定</strong>来<strong>声明一个方法</strong>，Spring Data 就会在运行时<strong>解析这个方法名</strong>，并<strong>自动为你生成并执行对应的查询</strong>。</li>
<li><strong>命名约定</strong>: <code>find...By...</code>, <code>read...By...</code>, <code>query...By...</code>, <code>count...By...</code>, <code>get...By...</code><ul>
<li><code>findByUsername(String username)</code> -&gt; <code>WHERE username = ?</code></li>
<li><code>findByUsernameAndPassword(String username, String password)</code> -&gt; <code>WHERE username = ? AND password = ?</code></li>
<li><code>findByAgeGreaterThan(int age)</code> -&gt; <code>WHERE age &gt; ?</code></li>
<li><code>findFirst10ByOrderByUsernameDesc()</code> -&gt; <code>WHERE ... ORDER BY username DESC LIMIT 10</code></li>
</ul>
</li>
</ul>
<p><strong>一个形象的比喻</strong>:</p>
<p>可以把 Spring Data Commons 与 Java 的 <code>Collection</code> 框架类比：</p>
<table>
<thead>
<tr>
<th align="left">Java Collection 框架</th>
<th align="left">Spring Data Commons 体系</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>Collection&lt;T&gt;</code></strong> (顶层接口)</td>
<td align="left"><strong><code>Repository&lt;T, ID&gt;</code></strong> (顶层标记接口)</td>
</tr>
<tr>
<td align="left"><strong><code>List&lt;T&gt;</code></strong> (具体接口)</td>
<td align="left"><strong><code>CrudRepository&lt;T, ID&gt;</code></strong> (具体接口)</td>
</tr>
<tr>
<td align="left"><code>new ArrayList&lt;T&gt;()</code> (具体实现)</td>
<td align="left"><code>spring-boot-starter-data-jpa</code> (具体实现模块)</td>
</tr>
</tbody></table>
<p>你编程时面向的是 <code>List</code> 接口，而不需要关心底层是 <code>ArrayList</code>还是 <code>LinkedList</code>。同样，你编程时面向的是 <code>CrudRepository</code>，Spring Data Commons 确保了无论你将来把底层的数据源从JPA换成MongoDB，你的Repository接口和业务代码几乎<strong>无需改动</strong>。</p>
<hr>
<h3 id="2-2-通用功能"><a href="#2-2-通用功能" class="headerlink" title="2.2 通用功能"></a>2.2 通用功能</h3><p>除了提供基础的Repository抽象，Spring Data Commons 还内置了对分页和排序的通用支持。这意味着，无论你使用 Spring Data JPA、Spring Data MongoDB 还是其他模块，进行分页和排序的<strong>编程方式是完全一致的</strong>。</p>
<h4 id="2-2-1-排序-Sorting"><a href="#2-2-1-排序-Sorting" class="headerlink" title="2.2.1 排序 (Sorting)"></a>2.2.1 排序 (Sorting)</h4><h5 id="1-Sort-对象"><a href="#1-Sort-对象" class="headerlink" title="1. Sort 对象"></a>1. <code>Sort</code> 对象</h5><p><code>org.springframework.data.domain.Sort</code> 是一个用于封装排序信息的类。</p>
<ul>
<li><p><strong>创建 <code>Sort</code> 对象</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 按单个字段升序 (默认)</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sortByUsernameAsc</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 按单个字段降序</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sortByCreateTimeDesc</span> <span class="operator">=</span> Sort.by(Sort.Direction.DESC, <span class="string">&quot;createTime&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 组合多个排序条件 (按年龄降序，如果年龄相同，再按用户名升序)</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sortByAgeDescAndUsernameAsc</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;age&quot;</span>).descending()</span><br><span class="line">                                       .and(Sort.by(<span class="string">&quot;username&quot;</span>).ascending());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种链式写法</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">complexSort</span> <span class="operator">=</span> Sort.by(</span><br><span class="line">    Sort.Order.desc(<span class="string">&quot;priority&quot;</span>),</span><br><span class="line">    Sort.Order.asc(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-在Repository中使用-Sort"><a href="#2-在Repository中使用-Sort" class="headerlink" title="2. 在Repository中使用 Sort"></a>2. 在Repository中使用 <code>Sort</code></h5><ol>
<li><p><strong>对于 <code>CrudRepository</code></strong>: 它自身没有直接支持排序的方法，但你可以在<strong>方法命名查询</strong>中嵌入排序规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 方法名中直接包含排序规则</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByStatusOrderByCreateTimeDesc</span><span class="params">(String status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对于 <code>PagingAndSortingRepository</code></strong>: 这个接口继承自 <code>CrudRepository</code>，并额外提供了一个接收 <code>Sort</code> 参数的 <code>findAll</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PagingAndSortingRepository 继承了 CrudRepository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;Product, Long&gt; &#123;</span><br><span class="line"><span class="comment">// 该接口自带 findAll(Sort sort) 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service层中使用</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductRepository productRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getProductsSortedByPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Sort</span> <span class="variable">sortByPriceAsc</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;price&quot;</span>).ascending();</span><br><span class="line">        <span class="keyword">return</span> (List&lt;Product&gt;) productRepository.findAll(sortByPriceAsc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在自定义查询方法中使用 <code>Sort</code></strong>: 你也可以在自定义的查询方法中添加一个 <code>Sort</code> 类型的参数，Spring Data会自动应用这个排序规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// Spring Data会解析方法名生成查询条件 (WHERE status = ?)，</span></span><br><span class="line">    <span class="comment">// 然后将传入的Sort对象动态地应用到查询的 ORDER BY 子句上。</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByStatus</span><span class="params">(String status, Sort sort)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service层中使用</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getActiveUsersSorted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;lastName&quot;</span>).ascending();</span><br><span class="line">    <span class="keyword">return</span> userRepository.findByStatus(<span class="string">&quot;ACTIVE&quot;</span>, sort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="2-2-2-分页-Pagination"><a href="#2-2-2-分页-Pagination" class="headerlink" title="2.2.2 分页 (Pagination)"></a>2.2.2 分页 (Pagination)</h4><p>当查询结果集非常大时，一次性加载所有数据是不现实的，这会导致内存溢出和性能问题。分页查询是必须的。Spring Data Commons 提供了 <code>Pageable</code> 和 <code>Page</code> 两个核心接口来优雅地处理分页。</p>
<h5 id="1-Pageable-接口-请求分页"><a href="#1-Pageable-接口-请求分页" class="headerlink" title="1. Pageable 接口 (请求分页)"></a>1. <code>Pageable</code> 接口 (请求分页)</h5><p><code>org.springframework.data.domain.Pageable</code> 是一个接口，用于<strong>封装分页请求信息</strong>，通常由客户端（或Service层）传入。</p>
<ul>
<li><p><strong>核心信息</strong>:</p>
<ul>
<li><strong>页码 (Page Number)</strong>: 请求的是第几页（<strong>从0开始</strong>）。</li>
<li><strong>每页大小 (Page Size)</strong>: 每页希望返回多少条记录。</li>
<li><strong>排序信息 (Sort)</strong>: 一个可选的 <code>Sort</code> 对象，用于对当前页的数据进行排序。</li>
</ul>
</li>
<li><p><strong>创建 <code>Pageable</code> 对象</strong>:<br>通常使用其实现类 <code>PageRequest</code> 来创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个简单的分页请求：请求第 0 页，每页 10 条数据</span></span><br><span class="line"><span class="type">Pageable</span> <span class="variable">firstPageWithTenElements</span> <span class="operator">=</span> PageRequest.of(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个带排序的分页请求：请求第 2 页，每页 5 条，按用户名降序</span></span><br><span class="line"><span class="type">Pageable</span> <span class="variable">thirdPageWithFiveElementsSorted</span> <span class="operator">=</span> PageRequest.of(<span class="number">2</span>, <span class="number">5</span>, Sort.by(<span class="string">&quot;username&quot;</span>).descending());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以先创建Sort对象</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;createTime&quot;</span>).descending();</span><br><span class="line"><span class="type">Pageable</span> <span class="variable">pageableWithSort</span> <span class="operator">=</span> PageRequest.of(<span class="number">0</span>, <span class="number">20</span>, sort);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-Page-接口-响应分页"><a href="#2-Page-接口-响应分页" class="headerlink" title="2. Page&lt;T&gt; 接口 (响应分页)"></a>2. <code>Page&lt;T&gt;</code> 接口 (响应分页)</h5><p><code>org.springframework.data.domain.Page&lt;T&gt;</code> 是一个接口，用于<strong>封装分页查询的结果</strong>。它不仅仅包含了当前页的数据列表，还包含了丰富的<strong>分页元数据 (metadata)</strong>，非常便于前端展示分页控件。</p>
<ul>
<li><strong>核心信息</strong>:<ul>
<li><code>List&lt;T&gt; getContent()</code>: 获取当前页的数据列表。</li>
<li><code>int getTotalPages()</code>: 获取总页数。</li>
<li><code>long getTotalElements()</code>: 获取总记录数。</li>
<li><code>int getNumber()</code>: 获取当前页码（从0开始）。</li>
<li><code>int getSize()</code>: 获取当前页的实际大小。</li>
<li><code>int getNumberOfElements()</code>: 获取当前页的记录数。</li>
<li><code>boolean hasContent()</code>: 判断当前页是否有数据。</li>
<li><code>boolean isFirst()</code>: 是否是第一页。</li>
<li><code>boolean isLast()</code>: 是否是最后一页。</li>
<li><code>boolean hasNext()</code>: 是否有下一页。</li>
<li><code>boolean hasPrevious()</code>: 是否有上一页。</li>
<li><code>Pageable nextPageable()</code>: 获取请求下一页的 <code>Pageable</code> 对象。</li>
<li><code>Pageable previousPageable()</code>: 获取请求上一页的 <code>Pageable</code> 对象。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-在Repository中使用分页"><a href="#3-在Repository中使用分页" class="headerlink" title="3. 在Repository中使用分页"></a>3. 在Repository中使用分页</h5><ol>
<li><p><strong>继承 <code>PagingAndSortingRepository</code></strong>: 这个接口直接提供了 <code>findAll(Pageable pageable)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;Product, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 自带 Page&lt;Product&gt; findAll(Pageable pageable);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在自定义查询方法中使用 <code>Pageable</code></strong>:</p>
<ul>
<li>在任何自定义的查询方法中，只要将<strong>最后一个参数</strong>设置为 <code>Pageable</code> 类型，并且<strong>返回类型</strong>是 <code>Page&lt;T&gt;</code>，Spring Data就会自动执行分页查询。</li>
<li>它会执行<strong>两次</strong>查询：一次是获取总记录数的 <code>COUNT</code> 查询，一次是获取当前页数据的分页查询。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据状态查询用户，并进行分页</span></span><br><span class="line">    Page&lt;User&gt; <span class="title function_">findByStatus</span><span class="params">(String status, Pageable pageable)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service层中使用</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Page&lt;User&gt; <span class="title function_">findActiveUsers</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建分页请求对象，按创建时间降序</span></span><br><span class="line">        <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(page, size, Sort.by(<span class="string">&quot;createTime&quot;</span>).descending());</span><br><span class="line">        <span class="keyword">return</span> userRepository.findByStatus(<span class="string">&quot;ACTIVE&quot;</span>, pageable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在Controller中与Spring MVC集成</strong>:<br>Spring MVC可以自动将HTTP请求中的 <code>page</code>, <code>size</code>, <code>sort</code> 参数解析并组装成一个 <code>Pageable</code> 对象，直接注入到Controller方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端可以这样请求: /users?page=0&amp;size=10&amp;sort=username,desc</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Page&lt;User&gt; <span class="title function_">getActiveUsers</span><span class="params">(Pageable pageable)</span> &#123;</span><br><span class="line">        <span class="comment">// Spring MVC 已经自动根据请求参数创建好了 pageable 对象</span></span><br><span class="line">        <span class="keyword">return</span> userService.findActiveUsers(pageable); <span class="comment">// Service层也需要一个接收Pageable的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个自动化集成极大地简化了分页API的开发。</p>
</li>
</ol>
<hr>
<h2 id="3-Spring-Data-JPA"><a href="#3-Spring-Data-JPA" class="headerlink" title="3. Spring Data JPA"></a>3. Spring Data JPA</h2><p><strong>核心接口</strong></p>
<p>Spring Data JPA 的核心是围绕一系列<strong>层层递进、功能不断增强</strong>的Repository接口构建的。开发者通过继承这些接口，可以“免费”获得大量预先实现好的数据访问方法。这个接口的继承体系主要源自 Spring Data Commons，在第上一章已经介绍过了。</p>
<h3 id="3-1-实体映射"><a href="#3-1-实体映射" class="headerlink" title="3.1 实体映射"></a>3.1 实体映射</h3><p>实体映射是通过一系列的 <strong>JPA (Java Persistence API)</strong> 注解来完成的。这些注解告诉JPA提供者（如Hibernate）如何将一个普通的Java类（POJO）转换为可以被数据库持久化的<strong>实体 (Entity)</strong>。</p>
<hr>
<h4 id="3-1-1-Entity-声明实体"><a href="#3-1-1-Entity-声明实体" class="headerlink" title="3.1.1 @Entity - 声明实体"></a>3.1.1 <code>@Entity</code> - 声明实体</h4><ul>
<li><strong>作用</strong>: <strong>这是最重要的注解</strong>。它标记在一个类上，向JPA声明这个类是一个实体类，它将<strong>映射到数据库中的一张表</strong>。</li>
<li><strong>要求</strong>:<ol>
<li>该类必须有一个<strong>无参的构造函数</strong>（可以是<code>public</code>或<code>protected</code>），JPA需要用它来创建实体实例。</li>
<li>该类不能是 <code>final</code> 的，因为JPA提供者可能需要创建代理子类来实现懒加载等特性。</li>
<li>必须包含一个<strong>主键</strong>，通过<code>@Id</code>注解标记。</li>
</ol>
</li>
<li><strong><code>@Table</code> - 指定表名</strong><ul>
<li><strong>作用</strong>: 与 <code>@Entity</code> 配合使用，用于<strong>显式指定</strong>该实体映射到的数据库表的<strong>名称</strong>。</li>
<li><strong>常用属性</strong>:<ul>
<li><code>name</code>: 指定表名。</li>
<li><code>schema</code>: 指定数据库的模式（Schema）。</li>
<li><code>uniqueConstraints</code>: 定义唯一约束。</li>
</ul>
</li>
<li><strong>约定</strong>: 如果<strong>不使用</strong><code>@Table</code>注解，JPA默认会使用<strong>类名</strong>作为表名（命名策略可能因配置而异，如驼峰转下划线<code>UserInfo</code> -&gt; <code>user_info</code>）。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span> <span class="comment">// 声明这是一个实体类</span></span><br><span class="line"><span class="meta">@Table(name = &quot;tbl_user&quot;)</span> <span class="comment">// 映射到数据库中的 &#x27;tbl_user&#x27; 表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ... 字段和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-2-Id-GeneratedValue-定义主键"><a href="#3-1-2-Id-GeneratedValue-定义主键" class="headerlink" title="3.1.2 @Id &amp; @GeneratedValue - 定义主键"></a>3.1.2 <code>@Id</code> &amp; <code>@GeneratedValue</code> - 定义主键</h4><ul>
<li><strong><code>@Id</code></strong>:<ul>
<li><strong>作用</strong>: 标记在实体的某个字段上，声明该字段是实体类的<strong>主键 (Primary Key)</strong>，对应数据库表的主键列。<strong>每个实体必须有且只有一个<code>@Id</code></strong>。</li>
</ul>
</li>
<li><strong><code>@GeneratedValue</code></strong>:<ul>
<li><strong>作用</strong>: 与 <code>@Id</code> 配合使用，用于指定<strong>主键的生成策略</strong>。如果主键是由数据库自动生成的（如自增ID），则必须使用此注解。</li>
<li><strong>核心属性 <code>strategy</code></strong>:<ul>
<li><strong><code>GenerationType.AUTO</code> (默认值)</strong>:<ul>
<li>JPA提供者（Hibernate）会自动选择一个最适合当前数据库的策略。对于MySQL，它会选择<code>IDENTITY</code>；对于Oracle，会选择<code>SEQUENCE</code>。<strong>通常使用默认值即可</strong>。</li>
</ul>
</li>
<li><strong><code>GenerationType.IDENTITY</code></strong>:<ul>
<li>表示主键由数据库的<strong>自增列</strong>生成。适用于支持自增的数据库，如MySQL, SQL Server。</li>
<li>这是最常用的一种策略。</li>
</ul>
</li>
<li><strong><code>GenerationType.SEQUENCE</code></strong>:<ul>
<li>使用数据库的<strong>序列 (Sequence)</strong> 来生成主键。适用于Oracle, PostgreSQL等支持序列的数据库。</li>
<li>需要配合 <code>@SequenceGenerator</code> 注解来指定序列的名称。</li>
</ul>
</li>
<li><strong><code>GenerationType.TABLE</code></strong>:<ul>
<li>使用一张特定的数据库表来模拟序列的功能。这种方式性能较差，已很少使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">// 使用数据库自增策略</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-3-Column-Basic-映射普通列"><a href="#3-1-3-Column-Basic-映射普通列" class="headerlink" title="3.1.3 @Column &amp; @Basic - 映射普通列"></a>3.1.3 <code>@Column</code> &amp; <code>@Basic</code> - 映射普通列</h4><ul>
<li><strong><code>@Column</code></strong>:<ul>
<li><strong>作用</strong>: 标记在实体的字段上，用于<strong>精细化控制</strong>该字段如何映射到数据库表的<strong>列 (Column)</strong>。</li>
<li><strong>常用属性</strong>:<ul>
<li><code>name</code>: 指定数据库列的名称。如果不指定，默认使用字段名。</li>
<li><code>length</code>: 指定列的长度（主要用于<code>VARCHAR</code>类型），默认255。</li>
<li><code>nullable</code>: 是否允许为<code>null</code>，默认<code>true</code>。设置为<code>false</code>会生成<code>NOT NULL</code>约束。</li>
<li><code>unique</code>: 是否是唯一约束，默认<code>false</code>。</li>
<li><code>columnDefinition</code>: 允许你直接定义该列的DDL片段，如<code>columnDefinition = &quot;TEXT&quot;</code>或<code>columnDefinition = &quot;DECIMAL(10, 2) DEFAULT 0.00&quot;</code>。</li>
<li><code>updatable</code>: 该列是否会包含在<code>UPDATE</code>语句中，默认<code>true</code>。</li>
<li><code>insertable</code>: 该列是否会包含在<code>INSERT</code>语句中，默认<code>true</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>@Basic</code></strong>:<ul>
<li>JPA默认会将所有未被注解的、非<code>static</code>、非<code>transient</code>的字段都当作持久化字段处理，这背后其实是隐式地使用了 <code>@Basic</code> 注解。</li>
<li>你<strong>几乎不需要显式使用</strong><code>@Basic</code>。它的主要作用是控制字段的<strong>加载策略</strong> (<code>fetch</code>属性，<code>FetchType.EAGER</code>或<code>FetchType.LAZY</code>），但这对于基本类型字段的懒加载通常意义不大。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ... id ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_name&quot;, nullable = false, length = 50, unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(length = 100)</span> <span class="comment">// 只指定长度</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果字段名和列名一致，且没有其他特殊约束，可以不加@Column注解</span></span><br><span class="line">    <span class="keyword">private</span> String email; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-4-其他常用注解"><a href="#3-1-4-其他常用注解" class="headerlink" title="3.1.4 其他常用注解"></a>3.1.4 其他常用注解</h4><ul>
<li><p><strong><code>@Transient</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 标记在字段上，告诉JPA<strong>忽略这个字段</strong>，不要将它持久化到数据库中。</li>
<li><strong>场景</strong>: 用于存放一些临时的、计算得出的，或者不属于数据模型的字段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 假设age是根据生日计算得出的，不需要存入数据库</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@Temporal</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 用于修饰 <code>java.util.Date</code> 或 <code>java.util.Calendar</code> 类型的字段，指定它们在数据库中映射的类型。</li>
<li><strong>属性</strong>:<ul>
<li><code>TemporalType.DATE</code>: 只保留日期部分（映射到<code>DATE</code>类型）。</li>
<li><code>TemporalType.TIME</code>: 只保留时间部分（映射到<code>TIME</code>类型）。</li>
<li><code>TemporalType.TIMESTAMP</code>: 保留日期和时间（映射到<code>TIMESTAMP</code>类型）。</li>
</ul>
</li>
<li><strong>现代实践</strong>: <strong>强烈推荐使用 Java 8 的 <code>java.time</code> 包下的日期时间类型（<code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code>）</strong>。这些类型在JPA 2.2及以上版本中是原生支持的，<strong>不再需要</strong> <code>@Temporal</code> 注解，并且能更精确地映射到数据库类型。</li>
</ul>
</li>
<li><p><strong><code>@Enumerated</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 用于映射<strong>枚举 (Enum)</strong> 类型字段。</li>
<li><strong>属性</strong>:<ul>
<li><strong><code>EnumType.ORDINAL</code> (默认值)</strong>: 将枚举的<strong>序数</strong>（从0开始的整数）存入数据库。<strong>这是一个危险的默认值！</strong> 因为如果你在枚举中间插入一个新的值，所有后续枚举的序数都会改变，导致数据错乱。</li>
<li><strong><code>EnumType.STRING</code> (推荐)</strong>: 将枚举的<strong>名称</strong>（字符串）存入数据库。这更具可读性，也更健壮。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123; ACTIVE, INACTIVE, BANNED; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Enumerated(EnumType.STRING)</span> <span class="comment">// 强烈推荐使用STRING</span></span><br><span class="line"><span class="meta">@Column(length = 20)</span></span><br><span class="line"><span class="keyword">private</span> UserStatus status;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-2-关系映射"><a href="#3-2-关系映射" class="headerlink" title="3.2 关系映射"></a>3.2 关系映射</h3><p>在关系型数据库中，表与表之间的关系通常通过<strong>外键 (Foreign Key)</strong> 来维护。JPA通过一系列的关系映射注解，将这种数据库层面的关系，优雅地转换为了Java对象之间的<strong>引用 (Reference)</strong> 关系。</p>
<p>关系映射主要分为四种类型，根据实体间数量上的对应关系（“基数”）来定义：</p>
<ol>
<li><strong>一对一 (<code>@OneToOne</code>)</strong></li>
<li><strong>一对多 (<code>@OneToMany</code>)</strong></li>
<li><strong>多对一 (<code>@ManyToOne</code>)</strong></li>
<li><strong>多对多 (<code>@ManyToMany</code>)</strong></li>
</ol>
<hr>
<h4 id="3-2-1-通用概念：关系维护方与被维护方"><a href="#3-2-1-通用概念：关系维护方与被维护方" class="headerlink" title="3.2.1 通用概念：关系维护方与被维护方"></a>3.2.1 通用概念：关系维护方与被维护方</h4><p>在双向关系中（即两个实体都持有对方的引用），必须指定一个<strong>关系维护方 (Owning Side)</strong>。</p>
<ul>
<li><strong>关系维护方</strong>:<ul>
<li>通常是“多”的一方（在<code>@ManyToOne</code>中）或逻辑上的从属方。</li>
<li>这个实体对应的表中，会包含<strong>外键列</strong>。</li>
<li>在代码中，它使用 <code>@JoinColumn</code> 注解来定义外键。</li>
</ul>
</li>
<li><strong>关系被维护方 (Inverse Side)</strong>:<ul>
<li>它不拥有外键。</li>
<li>在代码中，它使用关系注解的 <code>mappedBy</code> 属性来声明：“这段关系由对方的那个字段来维护”。</li>
</ul>
</li>
</ul>
<p><strong>规则</strong>: <code>mappedBy</code> 属性总是出现在<strong>不包含外键</strong>的那一方。</p>
<hr>
<h4 id="3-2-2-多对一-ManyToOne-一对多-OneToMany"><a href="#3-2-2-多对一-ManyToOne-一对多-OneToMany" class="headerlink" title="3.2.2 多对一 (@ManyToOne) &amp; 一对多 (@OneToMany)"></a>3.2.2 多对一 (<code>@ManyToOne</code>) &amp; 一对多 (<code>@OneToMany</code>)</h4><p>这是最常见的一种关系，例如 <strong>用户(User)</strong> 和 <strong>订单(Order)</strong>。一个用户可以有多个订单，但一个订单只属于一个用户。</p>
<h5 id="1-定义关系"><a href="#1-定义关系" class="headerlink" title="1. 定义关系"></a>1. 定义关系</h5><ul>
<li><strong><code>Order</code> (多方 - Owning Side)</strong>:<ul>
<li>持有 <code>User</code> 的单个引用。</li>
<li>使用 <code>@ManyToOne</code> 注解。</li>
<li>使用 <code>@JoinColumn</code> 来定义外键列。</li>
</ul>
</li>
<li><strong><code>User</code> (一方 - Inverse Side)</strong>:<ul>
<li>持有 <code>Order</code> 的一个集合 (<code>Set</code> 或 <code>List</code>)。</li>
<li>使用 <code>@OneToMany</code> 注解。</li>
<li>使用 <code>mappedBy</code> 属性指向 <code>Order</code> 类中维护关系的字段名。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2. 示例代码"></a>2. 示例代码</h5><p><strong><code>Order.java</code> (多方，关系维护方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;orders&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderNumber;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span> <span class="comment">// 多对一关系，默认是EAGER加载</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;user_id&quot;)</span> <span class="comment">// 定义外键列，名为 user_id</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>User.java</code> (一方，关系被维护方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一对多关系，默认是LAZY加载</span></span><br><span class="line">    <span class="comment">// mappedBy 的值是 Order 类中 &quot;user&quot; 字段的名称</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL, orphanRemoval = true)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-关键注解与属性"><a href="#3-关键注解与属性" class="headerlink" title="3. 关键注解与属性"></a>3. 关键注解与属性</h5><ul>
<li><strong><code>@JoinColumn(name = &quot;...&quot;)</code></strong>:<ul>
<li>定义了在当前实体对应的表中，外键列的名称。</li>
</ul>
</li>
<li><strong><code>fetch</code> (加载策略)</strong>:<ul>
<li><code>FetchType.EAGER</code> (急切加载): 当查询主实体时，<strong>立即</strong>加载其关联的实体。</li>
<li><code>FetchType.LAZY</code> (懒加载): 当查询主实体时，<strong>不加载</strong>其关联的实体。只有当你<strong>第一次访问</strong>这个关联实体时，JPA才会发送额外的SQL去查询它。</li>
<li><strong>默认值</strong>:<ul>
<li><code>@ManyToOne</code> 和 <code>@OneToOne</code> 默认是 <strong><code>EAGER</code></strong>。</li>
<li><code>@OneToMany</code> 和 <code>@ManyToMany</code> 默认是 <strong><code>LAZY</code></strong>。</li>
</ul>
</li>
<li><strong>最佳实践</strong>: <strong>强烈建议将所有 <code>to-one</code> 关系（<code>@ManyToOne</code>, <code>@OneToOne</code>）手动设置为 <code>LAZY</code></strong>，以避免不必要的查询和N+1问题。只在确定每次都需要关联数据时才使用 <code>EAGER</code>。</li>
</ul>
</li>
<li><strong><code>cascade</code> (级联操作)</strong>:<ul>
<li>定义了对主实体的操作如何<strong>传播</strong>到关联实体。</li>
<li><code>CascadeType.ALL</code>: 所有操作（<code>PERSIST</code>, <code>MERGE</code>, <code>REMOVE</code>, <code>REFRESH</code>, <code>DETACH</code>）都级联。</li>
<li><code>CascadeType.PERSIST</code>: 级联保存（当你保存<code>User</code>时，会自动保存其<code>orders</code>集合中的新订单）。</li>
<li><code>CascadeType.REMOVE</code>: 级联删除（当你删除<code>User</code>时，会自动删除其所有订单）。</li>
<li><strong>使用场景</strong>: 通常在父子关系（如<code>User</code>与<code>Order</code>）中，在“一”的一方使用 <code>cascade = CascadeType.ALL</code>，可以简化代码。</li>
</ul>
</li>
<li><strong><code>orphanRemoval = true</code> (孤儿移除)</strong>:<ul>
<li>与 <code>cascade</code> 配合使用，通常在 <code>@OneToMany</code> 中。</li>
<li>当一个子实体（<code>Order</code>）从父实体（<code>User</code>）的集合中被<strong>移除</strong>时（例如 <code>user.getOrders().remove(someOrder)</code>），这个子实体会被自动从数据库中<strong>删除</strong>。它就像一个“孤儿”，失去了与父级的关联，所以被清理掉。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-3-一对一-OneToOne"><a href="#3-2-3-一对一-OneToOne" class="headerlink" title="3.2.3 一对一 (@OneToOne)"></a>3.2.3 一对一 (<code>@OneToOne</code>)</h4><p>例如，<strong>用户(User)</strong> 和 <strong>用户资料(UserProfile)</strong>。一个用户只有一个资料，一个资料也只属于一个用户。</p>
<p>实现方式有两种：共享主键（不推荐）和<strong>唯一外键</strong>。</p>
<p><strong>示例：使用唯一外键</strong></p>
<p><strong><code>UserProfile.java</code> (关系维护方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id; <span class="comment">// 主键</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bio;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@MapsId</span> <span class="comment">// 关键：将外键 user_id 同时作为本实体的主键</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;user_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>User.java</code> (关系被维护方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// orphanRemoval=true 确保删除User时，UserProfile也被删除</span></span><br><span class="line">    <span class="meta">@OneToOne(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)</span></span><br><span class="line">    <span class="keyword">private</span> UserProfile userProfile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@MapsId</code>: 这是一个非常巧妙的注解。它告诉JPA，<code>UserProfile</code> 的主键(<code>id</code>)的值，直接来源于关联的<code>User</code>对象的主键。这保证了<code>user_id</code>既是外键，又是主键，从而在数据库层面实现了严格的一对一关系。</li>
</ul>
<hr>
<h4 id="3-2-4-多对多-ManyToMany"><a href="#3-2-4-多对多-ManyToMany" class="headerlink" title="3.2.4 多对多 (@ManyToMany)"></a>3.2.4 多对多 (<code>@ManyToMany</code>)</h4><p>例如，<strong>文章(Post)</strong> 和 <strong>标签(Tag)</strong>。一篇文章可以有多个标签，一个标签也可以用于多篇文章。</p>
<p>在数据库中，多对多关系必须通过一个<strong>中间表 (Join Table &#x2F; Link Table)</strong> 来实现。</p>
<h5 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1. 示例代码"></a>1. 示例代码</h5><p><strong><code>Post.java</code> (关系的一方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany(cascade = &#123; CascadeType.PERSIST, CascadeType.MERGE &#125;)</span></span><br><span class="line">    <span class="meta">@JoinTable(</span></span><br><span class="line"><span class="meta">        name = &quot;post_tag&quot;, // 中间表的名字</span></span><br><span class="line"><span class="meta">        joinColumns = @JoinColumn(name = &quot;post_id&quot;), // 中间表中，指向本实体(Post)的外键列</span></span><br><span class="line"><span class="meta">        inverseJoinColumns = @JoinColumn(name = &quot;tag_id&quot;) // 中间表中，指向另一方实体(Tag)的外键列</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Tag&gt; tags = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Tag.java</code> (关系的另一方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany(mappedBy = &quot;tags&quot;)</span> <span class="comment">// 由Post方的&quot;tags&quot;字段维护关系</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Post&gt; posts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-关键注解"><a href="#2-关键注解" class="headerlink" title="2. 关键注解"></a>2. 关键注解</h5><ul>
<li><strong><code>@JoinTable</code></strong>:<ul>
<li>用于在<strong>关系维护方</strong>定义中间表的细节。</li>
<li><code>name</code>: 中间表的名称。</li>
<li><code>joinColumns</code>: 定义了中间表中与<strong>当前实体</strong>相关联的外键。</li>
<li><code>inverseJoinColumns</code>: 定义了中间表中与<strong>另一方实体</strong>相关联的外键。</li>
</ul>
</li>
</ul>
<p><strong>多对多关系的警告</strong>:<br>虽然JPA的<code>@ManyToMany</code>用起来很方便，但在实际项目中，中间表往往不只是包含两个外键，可能还需要包含额外的属性（如<code>创建时间</code>、<code>排序字段</code>等）。在这种情况下，<strong>最佳实践</strong>是<strong>将多对多关系拆分为两个一对多关系</strong>，即创建一个代表中间表的<strong>新实体</strong>（如<code>PostTag</code>），然后建立 <code>Post -&gt; PostTag</code> 和 <code>Tag -&gt; PostTag</code> 的两个一对多关系。</p>
<hr>
<h3 id="3-3-查询方式"><a href="#3-3-查询方式" class="headerlink" title="3.3 查询方式"></a>3.3 查询方式</h3><h4 id="3-3-1-方法命名查询-Query-Methods"><a href="#3-3-1-方法命名查询-Query-Methods" class="headerlink" title="3.3.1 方法命名查询 (Query Methods)"></a>3.3.1 方法命名查询 (Query Methods)</h4><h5 id="1-核心理念"><a href="#1-核心理念" class="headerlink" title="1. 核心理念"></a>1. 核心理念</h5><p>方法命名查询的核心理念是：<strong>你不再需要编写JPQL或SQL语句，只需要在你的Repository接口中，按照Spring Data预先定义好的一套命名约定来声明一个方法，Spring Data框架就会在运行时自动为你解析这个方法名，并生成对应的查询语句来执行。</strong></p>
<p>这就像你和Spring Data之间有了一个“暗号”。你说出暗号（方法名），它就能理解你的查询意图。</p>
<hr>
<h5 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ol>
<li><strong>接口定义</strong>: 你在继承了<code>JpaRepository</code>的接口中定义一个新方法，例如 <code>findByUsername(String username)</code>。</li>
<li><strong>应用启动</strong>: Spring Boot在启动并扫描到你的Repository接口时，Spring Data框架会介入。</li>
<li><strong>方法名解析</strong>: 它会获取到你定义的所有方法，并尝试解析那些没有具体实现的方法名。</li>
<li><strong>查询生成</strong>: 它会根据一套严格的语法规则来“拆解”方法名，例如：<ul>
<li><code>find</code>…<code>By</code>…: 识别出查询的前缀和分隔符。</li>
<li><code>Username</code>: 将其解析为实体类<code>User</code>的一个属性<code>username</code>。</li>
<li><code>String username</code>: 识别出方法的参数，并将其与属性<code>username</code>对应。</li>
</ul>
</li>
<li><strong>代理实现</strong>: 最后，它会为这个方法动态地生成一个实现，该实现内部包含了执行 <code>SELECT u FROM User u WHERE u.username = ?1</code> 这样的JPQL查询的逻辑。</li>
</ol>
<p>当你的Service层调用<code>userRepository.findByUsername(&quot;alice&quot;)</code>时，实际上是调用了这个动态生成的代理实现。</p>
<hr>
<h5 id="3-命名约定语法"><a href="#3-命名约定语法" class="headerlink" title="3. 命名约定语法"></a>3. 命名约定语法</h5><p>方法名的结构通常如下：<code>[前缀][关键词][(属性名 + 条件)]...[排序子句]</code></p>
<h6 id="a-查询前缀-Prefix"><a href="#a-查询前缀-Prefix" class="headerlink" title="a. 查询前缀 (Prefix)"></a>a. 查询前缀 (Prefix)</h6><table>
<thead>
<tr>
<th align="left">前缀</th>
<th align="left">描述</th>
<th align="left">返回类型示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>find...By...</code></td>
<td align="left">最常用的查询前缀。</td>
<td align="left"><code>User</code>, <code>List&lt;User&gt;</code></td>
</tr>
<tr>
<td align="left"><code>read...By...</code></td>
<td align="left">功能与<code>find</code>完全相同，语义上表示读取。</td>
<td align="left"><code>User</code>, <code>List&lt;User&gt;</code></td>
</tr>
<tr>
<td align="left"><code>query...By...</code></td>
<td align="left">功能与<code>find</code>完全相同。</td>
<td align="left"><code>User</code>, <code>List&lt;User&gt;</code></td>
</tr>
<tr>
<td align="left"><code>get...By...</code></td>
<td align="left">功能与<code>find</code>完全相同。</td>
<td align="left"><code>User</code>, <code>List&lt;User&gt;</code></td>
</tr>
<tr>
<td align="left"><code>count...By...</code></td>
<td align="left">查询符合条件的记录<strong>总数</strong>。</td>
<td align="left"><code>long</code>, <code>int</code></td>
</tr>
<tr>
<td align="left"><code>exists...By...</code></td>
<td align="left">判断是否存在符合条件的记录。</td>
<td align="left"><code>boolean</code></td>
</tr>
<tr>
<td align="left"><code>delete...By...</code> *</td>
<td align="left">删除符合条件的记录。需要事务支持 (<code>@Transactional</code>)。</td>
<td align="left"><code>long</code> (删除的行数)</td>
</tr>
<tr>
<td align="left"><code>remove...By...</code> *</td>
<td align="left">功能与<code>delete</code>相同。</td>
<td align="left"><code>long</code> (删除的行数)</td>
</tr>
</tbody></table>
<p><em>注意: <code>delete</code>和<code>remove</code>前缀返回的是被删除的记录数或记录列表，具体取决于返回类型定义。</em></p>
<hr>
<h6 id="b-属性表达式与条件关键词"><a href="#b-属性表达式与条件关键词" class="headerlink" title="b. 属性表达式与条件关键词"></a>b. 属性表达式与条件关键词</h6><p><code>By</code>之后的部分是查询的<strong>条件</strong>，由<strong>实体属性名</strong>和<strong>条件关键词</strong>组成。</p>
<ul>
<li><strong>属性名</strong>: 必须与你的实体类中的<strong>字段名完全匹配</strong>（首字母大写）。支持<strong>嵌套属性</strong>，通过 <code>_</code> 或直接驼峰连接，例如 <code>findByAddressCity(String city)</code> 对应 <code>address.city</code>。</li>
<li><strong>条件关键词 (Keywords)</strong>:</li>
</ul>
<table>
<thead>
<tr>
<th align="left">关键词</th>
<th align="left">JPQL&#x2F;SQL 等价物</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>And</code></td>
<td align="left"><code>AND</code></td>
<td align="left"><code>findByUsernameAndEmail(String name, String email)</code></td>
</tr>
<tr>
<td align="left"><code>Or</code></td>
<td align="left"><code>OR</code></td>
<td align="left"><code>findByUsernameOrEmail(String name, String email)</code></td>
</tr>
<tr>
<td align="left"><code>Is</code>, <code>Equals</code></td>
<td align="left"><code>=</code></td>
<td align="left"><code>findByUsername(&quot;alice&quot;)</code>, <code>findByUsernameIs(&quot;alice&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>IsNot</code>, <code>Not</code></td>
<td align="left"><code>!=</code> or <code>&lt;&gt;</code></td>
<td align="left"><code>findByUsernameIsNot(&quot;admin&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>IsNull</code>, <code>IsNotNull</code></td>
<td align="left"><code>IS NULL</code>, <code>IS NOT NULL</code></td>
<td align="left"><code>findByAddressIsNull()</code></td>
</tr>
<tr>
<td align="left"><code>IsTrue</code>, <code>IsFalse</code></td>
<td align="left"><code>= true</code>, <code>= false</code></td>
<td align="left"><code>findByActiveIsTrue()</code></td>
</tr>
<tr>
<td align="left"><code>Like</code>, <code>NotLike</code></td>
<td align="left"><code>LIKE</code>, <code>NOT LIKE</code></td>
<td align="left"><code>findByNameLike(&quot;%a%&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>StartingWith</code></td>
<td align="left"><code>LIKE &#39;prefix%&#39;</code></td>
<td align="left"><code>findByNameStartingWith(&quot;A&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>EndingWith</code></td>
<td align="left"><code>LIKE &#39;%suffix&#39;</code></td>
<td align="left"><code>findByNameEndingWith(&quot;ce&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>Containing</code></td>
<td align="left"><code>LIKE &#39;%infix%&#39;</code></td>
<td align="left"><code>findByNameContaining(&quot;li&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>GreaterThan</code></td>
<td align="left"><code>&gt;</code></td>
<td align="left"><code>findByAgeGreaterThan(18)</code></td>
</tr>
<tr>
<td align="left"><code>GreaterThanEqual</code></td>
<td align="left"><code>&gt;=</code></td>
<td align="left"><code>findByAgeGreaterThanEqual(18)</code></td>
</tr>
<tr>
<td align="left"><code>LessThan</code></td>
<td align="left"><code>&lt;</code></td>
<td align="left"><code>findByAgeLessThan(60)</code></td>
</tr>
<tr>
<td align="left"><code>LessThanEqual</code></td>
<td align="left"><code>&lt;=</code></td>
<td align="left"><code>findByAgeLessThanEqual(60)</code></td>
</tr>
<tr>
<td align="left"><code>Between</code></td>
<td align="left"><code>BETWEEN</code></td>
<td align="left"><code>findByAgeBetween(18, 30)</code> (接收两个参数)</td>
</tr>
<tr>
<td align="left"><code>In</code>, <code>NotIn</code></td>
<td align="left"><code>IN</code>, <code>NOT IN</code></td>
<td align="left"><code>findByStatusIn(List&lt;Status&gt; statuses)</code> (接收集合参数)</td>
</tr>
<tr>
<td align="left"><code>IgnoreCase</code></td>
<td align="left">(会转换值为小写&#x2F;大写进行比较)</td>
<td align="left"><code>findByUsernameIgnoreCase(&quot;ALICE&quot;)</code></td>
</tr>
</tbody></table>
<hr>
<h6 id="c-排序与限制结果"><a href="#c-排序与限制结果" class="headerlink" title="c. 排序与限制结果"></a>c. 排序与限制结果</h6><ul>
<li><strong>排序 (<code>OrderBy</code>)</strong>:<ul>
<li>在方法名末尾使用 <code>OrderBy</code> 子句，后跟属性名和排序方向 (<code>Asc</code> 或 <code>Desc</code>)。</li>
<li><code>findByStatusOrderByUsernameAsc(String status)</code></li>
<li><code>findByStatusOrderByCreateTimeDesc(String status)</code></li>
</ul>
</li>
<li><strong>限制结果数量 (<code>Top</code>, <code>First</code>)</strong>:<ul>
<li>在查询前缀后，<code>By</code>之前，可以加上 <code>Top&lt;N&gt;</code> 或 <code>First&lt;N&gt;</code> 来限制返回结果的数量。</li>
<li><code>findTop10ByOrderByCreateTimeDesc()</code>: 查询最新的10条记录。</li>
<li><code>findFirstByStatus(String status)</code>: 只返回符合条件的第一条记录。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-综合示例"><a href="#4-综合示例" class="headerlink" title="4. 综合示例"></a>4. 综合示例</h5><p>假设有一个 <code>User</code> 实体，包含 <code>username</code>, <code>email</code>, <code>status</code> (Enum), <code>age</code>, <code>createTime</code> 字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 根据用户名精确查找用户 (返回单个对象)</span></span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 根据用户名和状态查找用户列表</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByUsernameAndStatus</span><span class="params">(String username, UserStatus status)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 根据年龄大于某个值，并按创建时间降序排序</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByAgeGreaterThanOrderByCreateTimeDesc</span><span class="params">(<span class="type">int</span> age)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 根据用户名模糊查询（忽略大小写）</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByUsernameContainingIgnoreCase</span><span class="params">(String keyword)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 查询某个日期之后创建的用户数量</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">countByCreateTimeAfter</span><span class="params">(LocalDateTime dateTime)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 查找状态为ACTIVE的前5个用户</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findTop5ByStatus</span><span class="params">(UserStatus status)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 判断是否存在某个邮箱的用户</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">existsByEmail</span><span class="params">(String email)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 根据ID列表批量删除用户</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">deleteByIdIn</span><span class="params">(List&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>:</p>
<ul>
<li><strong>零SQL</strong>: 无需编写任何JPQL或SQL，完全避免了拼写错误。</li>
<li><strong>类型安全</strong>: 方法参数是强类型的，IDE和编译器可以进行检查。</li>
<li><strong>代码即文档</strong>: 方法名本身就清晰地描述了查询的目的，可读性极高。</li>
<li><strong>易于重构</strong>: 如果实体字段名发生变化，IDE的重构工具可以自动更新方法名。</li>
</ul>
<p><strong>局限性</strong>:</p>
<ul>
<li>对于<strong>非常复杂</strong>的查询（如多表连接、子查询、复杂的聚合函数），方法名会变得<strong>异常冗长且难以理解</strong>。</li>
<li>无法实现动态查询（即查询条件根据输入动态增减）。</li>
</ul>
<hr>
<h4 id="3-3-2-Query-注解"><a href="#3-3-2-Query-注解" class="headerlink" title="3.3.2 @Query 注解"></a>3.3.2 <code>@Query</code> 注解</h4><h5 id="1-为什么需要-Query？"><a href="#1-为什么需要-Query？" class="headerlink" title="1. 为什么需要 @Query？"></a>1. 为什么需要 <code>@Query</code>？</h5><p>虽然方法命名查询非常便捷，但它有其局限性：</p>
<ol>
<li><strong>复杂查询的表达能力不足</strong>: 对于涉及多表<code>JOIN</code>、子查询、<code>GROUP BY</code>、<code>HAVING</code>或复杂聚合函数的查询，如果硬要用方法名来表示，方法名会变得极其冗长、难以阅读和维护。</li>
<li><strong>查询逻辑固定</strong>: 方法名一旦定义，其查询逻辑就是固定的。它无法处理动态的、根据输入参数有选择性地添加查询条件的需求。</li>
<li><strong>非实体字段查询</strong>: 方法命名查询默认只能查询实体的所有字段。如果你只想查询部分字段（投影查询），或者进行一些计算，方法命名查询就无能为力了。</li>
</ol>
<p><code>@Query</code> 注解就是为了解决这些问题而生的。它允许你<strong>直接在Repository接口的方法上，编写自定义的JPQL（Java Persistence Query Language）或原生SQL语句</strong>，从而获得对查询逻辑的完全控制权。</p>
<hr>
<h5 id="2-使用JPQL-Java-Persistence-Query-Language"><a href="#2-使用JPQL-Java-Persistence-Query-Language" class="headerlink" title="2. 使用JPQL (Java Persistence Query Language)"></a>2. 使用JPQL (Java Persistence Query Language)</h5><p>JPQL是一种<strong>面向对象</strong>的查询语言，语法与SQL非常相似，但它是<strong>针对实体（Entity）和实体的属性</strong>进行查询的，而不是直接操作数据库的表和列。这是使用<code>@Query</code>的首选和最常用的方式。</p>
<h6 id="a-基本用法"><a href="#a-基本用法" class="headerlink" title="a. 基本用法"></a>a. 基本用法</h6><ul>
<li>在Repository接口的方法上添加 <code>@Query</code> 注解。</li>
<li>将JPQL语句作为注解的 <code>value</code> 属性值。</li>
<li>使用<strong>位置参数</strong> (<code>?</code> + 索引，从1开始) 或 <strong>命名参数</strong> (<code>:</code> + 参数名) 来引用方法参数。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用位置参数 (?1, ?2, ...)</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.username = ?1 AND u.status = ?2&quot;)</span></span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findUserByUsernameAndStatus</span><span class="params">(String username, UserStatus status)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用命名参数 (:paramName) - 更推荐，可读性更好</span></span><br><span class="line">    <span class="comment">//    需要配合 @Param 注解来绑定方法参数</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.email LIKE :emailPattern&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUsersWithEmailLike</span><span class="params">(<span class="meta">@Param(&quot;emailPattern&quot;)</span> String emailPattern)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：</span></span><br><span class="line">    <span class="comment">// - &quot;User&quot; 是实体类的名字，不是表名 &quot;users&quot;。</span></span><br><span class="line">    <span class="comment">// - &quot;u.username&quot; 是实体类的字段名，不是列名 &quot;user_name&quot;。</span></span><br><span class="line">    <span class="comment">// - JPQL是大小写敏感的 (对于实体名和属性名)。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>@Param(&quot;...&quot;)</code></strong>: 用于将方法的参数与JPQL中的命名参数进行绑定。如果方法参数名与命名参数名一致，在较新版本的Spring Data JPA中可以省略<code>@Param</code>，但显式指定是最佳实践。</li>
</ul>
<hr>
<h6 id="b-投影查询-只查询部分字段"><a href="#b-投影查询-只查询部分字段" class="headerlink" title="b. 投影查询 (只查询部分字段)"></a>b. 投影查询 (只查询部分字段)</h6><p>你可以直接在 <code>SELECT</code> 子句中指定要查询的字段。如果返回的是多个字段，通常需要将它们封装到一个DTO（Data Transfer Object）或接口中。</p>
<p><strong>返回DTO (构造函数表达式)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserSummaryDTO.java (必须有一个与JPQL中NEW后面的构造函数参数匹配的构造器)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSummaryDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// Constructor, Getters...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserRepository.java</span></span><br><span class="line"><span class="meta">@Query(&quot;SELECT new com.example.dto.UserSummaryDTO(u.username, u.email) FROM User u WHERE u.id = :id&quot;)</span></span><br><span class="line">UserSummaryDTO <span class="title function_">findUserSummaryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回接口 (Interface-based Projections)</strong>:</p>
<p>这是一种更简洁的方式，你只需要定义一个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个只包含需要字段的getter方法的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserProjection</span> &#123;</span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getEmail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserRepository.java</span></span><br><span class="line"><span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.id = :id&quot;)</span></span><br><span class="line">UserProjection <span class="title function_">findUserProjectionById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>

<p>Spring Data JPA会自动创建一个代理实现来填充这个接口。</p>
<hr>
<h6 id="c-更新和删除操作-Modifying"><a href="#c-更新和删除操作-Modifying" class="headerlink" title="c. 更新和删除操作 (@Modifying)"></a>c. 更新和删除操作 (<code>@Modifying</code>)</h6><p>如果你想通过 <code>@Query</code> 执行 <code>UPDATE</code> 或 <code>DELETE</code> 操作，必须满足两个条件：</p>
<ol>
<li>在 <code>@Query</code> 注解旁边，额外添加 <strong><code>@Modifying</code></strong> 注解。</li>
<li>该方法必须在一个<strong>事务</strong>中执行（通常在Service层的方法上添加 <code>@Transactional</code>）。</li>
</ol>
<p><code>@Modifying</code> 注解告诉Spring Data，这个查询将要<strong>修改数据库状态</strong>。</p>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Modifying;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query(&quot;UPDATE User u SET u.status = :newStatus WHERE u.lastLoginTime &lt; :cutoffDate&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateStatusForInactiveUsers</span><span class="params">(<span class="meta">@Param(&quot;newStatus&quot;)</span> UserStatus newStatus, </span></span><br><span class="line"><span class="params">                                     <span class="meta">@Param(&quot;cutoffDate&quot;)</span> LocalDateTime cutoffDate)</span>;</span><br><span class="line">                                     </span><br><span class="line">    <span class="comment">// 返回值 int 表示受影响的行数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 执行 <code>@Modifying</code> 查询后，<strong>持久化上下文（Persistence Context）中的实体可能与数据库中的状态不一致</strong>。如果你需要在同一个事务中继续使用这些被修改的实体，可以设置 <code>@Modifying(clearAutomatically = true)</code> 来自动清空持久化上下文。</p>
<hr>
<h5 id="3-使用原生SQL-Native-SQL"><a href="#3-使用原生SQL-Native-SQL" class="headerlink" title="3. 使用原生SQL (Native SQL)"></a>3. 使用原生SQL (Native SQL)</h5><p>在某些特殊情况下，JPQL可能无法满足需求（例如，使用数据库特有的函数、复杂的查询提示或操作非实体映射的表）。此时，你可以通过<code>@Query</code>执行<strong>原生SQL</strong>。</p>
<ul>
<li><strong>开启原生查询</strong>: 在 <code>@Query</code> 注解中，将 <code>nativeQuery</code> 属性设置为 <code>true</code>。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数据库特有的函数 (例如 MySQL的 DATE_FORMAT)</span></span><br><span class="line">    <span class="comment">// 注意：表名和列名都是数据库中的实际名称</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT * FROM users u WHERE u.user_name = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">    User <span class="title function_">findByUsernameNative</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投影查询也可以用原生SQL</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT user_name, email FROM users WHERE id = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">    Map&lt;String, Object&gt; <span class="title function_">findUsernameAndEmailNative</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原生SQL的缺点</strong>:</p>
<ul>
<li><strong>失去了数据库无关性</strong>: 你的代码将与特定的数据库方言（如MySQL, Oracle）绑定。</li>
<li><strong>类型不安全</strong>: 查询中的表名、列名都是字符串，IDE和编译器无法校验其正确性。</li>
<li><strong>分页和排序的复杂性</strong>: 对于复杂的原生SQL，Spring Data可能无法正确地自动生成<code>COUNT</code>查询，你需要手动提供<code>countQuery</code>或<code>countProjection</code>。</li>
</ul>
<hr>
<h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">方法命名查询</th>
<th align="left"><code>@Query</code> 注解</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>易用性</strong></td>
<td align="left"><strong>极高</strong>，无需编写任何查询语句。</td>
<td align="left"><strong>较高</strong>，需要编写JPQL或SQL，但比原生JDBC简单得多。</td>
</tr>
<tr>
<td align="left"><strong>表达能力</strong></td>
<td align="left"><strong>有限</strong>，适用于中等复杂度的CRUD和条件查询。</td>
<td align="left"><strong>极强</strong>，可以实现任何复杂的查询、更新、删除操作。</td>
</tr>
<tr>
<td align="left"><strong>代码可读性</strong></td>
<td align="left">方法名即文档，<strong>非常清晰</strong>（只要不过于复杂）。</td>
<td align="left">JPQL语句也很清晰，但查询逻辑与方法名分离。</td>
</tr>
<tr>
<td align="left"><strong>维护性</strong></td>
<td align="left"><strong>高</strong>，易于重构。</td>
<td align="left"><strong>中等</strong>，修改查询需要直接编辑字符串，容易出错。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>80%的日常查询</strong>，特别是简单的条件过滤和排序。</td>
<td align="left"><strong>20%的复杂场景</strong>，如<code>JOIN</code>、投影、批量更新、使用原生SQL等。</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong>:</p>
<ol>
<li><strong>首选方法命名查询</strong>：对于简单和中等复杂度的查询，优先使用方法命名查询，因为它最简洁、最安全。</li>
<li><strong>次选 <code>@Query</code> + JPQL</strong>：当方法命名查询无法满足需求时，使用 <code>@Query</code> 结合JPQL。这在保持面向对象和一定数据库无关性的同时，提供了强大的查询能力。</li>
<li><strong>最后才考虑 <code>@Query</code> + 原生SQL</strong>：仅在JPQL无法实现特定功能时，才退回到使用原生SQL。</li>
</ol>
<hr>
<h4 id="3-3-3-Specification-动态查询"><a href="#3-3-3-Specification-动态查询" class="headerlink" title="3.3.3 Specification (动态查询)"></a>3.3.3 Specification (动态查询)</h4><h5 id="1-为什么需要-Specification？"><a href="#1-为什么需要-Specification？" class="headerlink" title="1. 为什么需要 Specification？"></a>1. 为什么需要 <code>Specification</code>？</h5><p>在很多业务场景中，我们的查询条件并不是固定的，而是根据用户的输入<strong>动态组合</strong>的。</p>
<p><strong>典型场景：一个复杂的用户搜索功能</strong><br>用户可以在搜索页面上提供以下任意组合的筛选条件：</p>
<ul>
<li>用户名 (模糊匹配)</li>
<li>邮箱 (精确匹配)</li>
<li>状态 (下拉选择)</li>
<li>年龄范围 (大于等于 <code>minAge</code>，小于等于 <code>maxAge</code>)</li>
<li>创建时间的范围</li>
</ul>
<p>如果使用<strong>方法命名查询</strong>，你需要为所有可能的条件组合都创建一个方法，这会导致方法数量爆炸式增长，完全不可行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findByUsername(String username);</span></span><br><span class="line"><span class="comment">// findByUsernameAndStatus(String username, Status status);</span></span><br><span class="line"><span class="comment">// findByUsernameAndAgeBetween(String username, int minAge, int maxAge);</span></span><br><span class="line"><span class="comment">// ... 组合会非常多</span></span><br></pre></td></tr></table></figure>

<p>如果使用 <strong><code>@Query</code></strong> 注解，你可以在JPQL中用<code>if</code>语句拼接字符串，但这非常繁琐、容易出错，且有SQL注入的风险（尽管JPA参数绑定能缓解部分问题）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Service层拼接JPQL字符串，非常不推荐</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jpql</span> <span class="operator">=</span> <span class="string">&quot;SELECT u FROM User u WHERE 1=1 &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (username != <span class="literal">null</span>) &#123;</span><br><span class="line">    jpql += <span class="string">&quot; AND u.username LIKE :username&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (status != <span class="literal">null</span>) &#123;</span><br><span class="line">    jpql += <span class="string">&quot; AND u.status = :status&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><strong><code>Specification</code> 就是Spring Data JPA提供的、用于以一种类型安全、面向对象的方式来构建动态查询条件的解决方案。</strong></p>
<hr>
<h5 id="2-核心理念：谓词-Predicate-的组合"><a href="#2-核心理念：谓词-Predicate-的组合" class="headerlink" title="2. 核心理念：谓词 (Predicate) 的组合"></a>2. 核心理念：谓词 (Predicate) 的组合</h5><p><code>Specification</code> 的设计基于 <strong>JPA Criteria API</strong>，它的核心思想是：<strong>将每一个查询条件都看作是一个独立的“谓词 (Predicate)”，然后通过逻辑运算（AND, OR）将这些谓词动态地组合起来，形成一个完整的查询。</strong></p>
<p>一个 <code>Specification&lt;T&gt;</code> 本质上是一个<strong>函数式接口</strong>，它只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Specification</span>&lt;T&gt; &#123;</span><br><span class="line">    Predicate <span class="title function_">toPredicate</span><span class="params">(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>: 实体类型。</li>
<li><code>toPredicate(...)</code>: 这个方法就是你需要实现的核心。它的职责是根据输入的 <code>root</code>, <code>query</code>, <code>cb</code>，返回一个JPA的 <code>Predicate</code> 对象，这个对象就代表了一个查询条件（如 <code>username = &#39;alice&#39;</code>）。<ul>
<li><strong><code>Root&lt;T&gt; root</code></strong>: 代表了查询的<strong>根对象</strong>（通常是你要查询的实体）。你可以通过 <code>root.get(&quot;fieldName&quot;)</code> 来获取实体的属性。</li>
<li><strong><code>CriteriaQuery&lt;?&gt; query</code></strong>: 代表了整个查询语句。你可以用它来定义<code>ORDER BY</code>, <code>GROUP BY</code>等。</li>
<li><strong><code>CriteriaBuilder cb</code></strong>: 一个<strong>条件构造器工厂</strong>。它是最重要的部分，提供了大量的方法来创建各种类型的谓词，例如：<ul>
<li><code>cb.equal(expression, value)</code>: 等于 (<code>=</code>)</li>
<li><code>cb.like(expression, pattern)</code>: 模糊匹配 (<code>LIKE</code>)</li>
<li><code>cb.greaterThan(expression, value)</code>: 大于 (<code>&gt;</code>)</li>
<li><code>cb.and(predicate1, predicate2)</code>: 逻辑与 (<code>AND</code>)</li>
<li><code>cb.or(predicate1, predicate2)</code>: 逻辑或 (<code>OR</code>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-如何使用-Specification"><a href="#3-如何使用-Specification" class="headerlink" title="3. 如何使用 Specification"></a>3. 如何使用 <code>Specification</code></h5><p><strong>Step 1: 让你的Repository接口继承 <code>JpaSpecificationExecutor</code></strong></p>
<p>这个接口提供了执行 <code>Specification</code> 查询所需要的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaSpecificationExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JpaSpecificationExecutor&lt;User&gt; 提供了额外的、接收Specification参数的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt;, JpaSpecificationExecutor&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JpaSpecificationExecutor</code> 提供了如下关键方法：</p>
<ul>
<li><code>Optional&lt;T&gt; findOne(@Nullable Specification&lt;T&gt; spec)</code></li>
<li><code>List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec)</code></li>
<li><code>Page&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Pageable pageable)</code></li>
<li><code>List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Sort sort)</code></li>
<li><code>long count(@Nullable Specification&lt;T&gt; spec)</code></li>
</ul>
<p><strong>Step 2: 在Service层构建 <code>Specification</code></strong></p>
<p>这是最核心的部分。我们通常会在Service层根据传入的参数，动态地构建一个<code>Specification</code>对象。</p>
<p><strong>示例：实现前面提到的用户动态搜索</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">searchUsers</span><span class="params">(UserSearchCriteria criteria)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Specification&lt;User&gt; spec = (root, query, cb) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建一个 Predicate 列表，用于存放所有动态生成的查询条件</span></span><br><span class="line">            List&lt;Predicate&gt; predicates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 如果用户名不为空，添加 username LIKE &#x27;%...%&#x27; 条件</span></span><br><span class="line">            <span class="keyword">if</span> (criteria.getUsername() != <span class="literal">null</span> &amp;&amp; !criteria.getUsername().isEmpty()) &#123;</span><br><span class="line">                predicates.add(cb.like(root.get(<span class="string">&quot;username&quot;</span>), <span class="string">&quot;%&quot;</span> + criteria.getUsername() + <span class="string">&quot;%&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 如果状态不为空，添加 status = &#x27;...&#x27; 条件</span></span><br><span class="line">            <span class="keyword">if</span> (criteria.getStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">                predicates.add(cb.equal(root.get(<span class="string">&quot;status&quot;</span>), criteria.getStatus()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 如果最小年龄不为空，添加 age &gt;= ... 条件</span></span><br><span class="line">            <span class="keyword">if</span> (criteria.getMinAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                predicates.add(cb.greaterThanOrEqualTo(root.get(<span class="string">&quot;age&quot;</span>), criteria.getMinAge()));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 如果最大年龄不为空，添加 age &lt;= ... 条件</span></span><br><span class="line">            <span class="keyword">if</span> (criteria.getMaxAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                predicates.add(cb.lessThanOrEqualTo(root.get(<span class="string">&quot;age&quot;</span>), criteria.getMaxAge()));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ... 可以添加更多条件</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将所有条件用 AND 连接起来</span></span><br><span class="line">            <span class="comment">// cb.and() 接收一个 Predicate 数组</span></span><br><span class="line">            <span class="keyword">return</span> cb.and(predicates.toArray(<span class="keyword">new</span> <span class="title class_">Predicate</span>[<span class="number">0</span>]));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构建好的 Specification 和排序/分页信息进行查询</span></span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll(spec, Sort.by(<span class="string">&quot;createTime&quot;</span>).descending());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserSearchCriteria</code> 是一个简单的DTO，用于封装搜索参数。</p>
<p><strong>Step 3 (可选): 将<code>Specification</code>逻辑封装成可复用的单元</strong></p>
<p>为了提高代码的可读性和复用性，我们可以为每个查询条件创建一个独立的<code>Specification</code>，然后在需要时将它们组合起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 UserSpecifications 工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSpecifications</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Specification&lt;User&gt; <span class="title function_">usernameContains</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (root, query, cb) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (username == <span class="literal">null</span> || username.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> cb.conjunction(); <span class="comment">// 返回一个恒为 true 的 Predicate</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cb.like(root.get(<span class="string">&quot;username&quot;</span>), <span class="string">&quot;%&quot;</span> + username + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Specification&lt;User&gt; <span class="title function_">hasStatus</span><span class="params">(UserStatus status)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (root, query, cb) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (status == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cb.conjunction();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cb.equal(root.get(<span class="string">&quot;status&quot;</span>), status);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service层中可以这样使用，代码更清晰</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">searchUsersV2</span><span class="params">(UserSearchCriteria criteria)</span> &#123;</span><br><span class="line">    Specification&lt;User&gt; spec = Specification</span><br><span class="line">            .where(UserSpecifications.usernameContains(criteria.getUsername()))</span><br><span class="line">            .and(UserSpecifications.hasStatus(criteria.getStatus()));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> userRepository.findAll(spec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Specification.where(spec1).and(spec2).or(spec3)</code>: 提供了流式API来组合<code>Specification</code>。</li>
<li><code>cb.conjunction()</code>: 返回一个 <code>true</code> 条件 (<code>1=1</code>)，在动态构建<code>AND</code>条件时非常有用，可以作为初始条件。</li>
<li><code>cb.disjunction()</code>: 返回一个 <code>false</code> 条件 (<code>1=0</code>)，用于构建<code>OR</code>条件。</li>
</ul>
<hr>
<h5 id="4-优势与劣势"><a href="#4-优势与劣势" class="headerlink" title="4. 优势与劣势"></a>4. 优势与劣势</h5><p><strong>优势</strong>:</p>
<ol>
<li><strong>极高的灵活性</strong>: 可以构建出任意复杂的动态查询逻辑。</li>
<li><strong>类型安全</strong>: 所有属性名都是通过 <code>root.get(&quot;fieldName&quot;)</code> 获取的，如果字段名写错，在<strong>编译时</strong>可能会被一些静态分析工具发现（运行时肯定会报错），比拼接字符串更安全。</li>
<li><strong>代码可读性与复用性</strong>: 将查询逻辑封装成独立的<code>Specification</code>方法，使得代码更清晰、易于测试和复用。</li>
</ol>
<p><strong>劣势</strong>:</p>
<ol>
<li><strong>学习曲线陡峭</strong>: <code>Criteria API</code> 的语法相对繁琐和抽象，初学者需要一定时间来适应。</li>
<li><strong>代码量较大</strong>: 相比方法命名查询，实现一个简单的动态查询也需要编写更多的代码。</li>
<li><strong>关联查询（JOIN）相对复杂</strong>: 虽然<code>Criteria API</code>支持JOIN，但语法会变得更加复杂，例如 <code>root.join(&quot;address&quot;).get(&quot;city&quot;)</code>。</li>
</ol>
<hr>
<h2 id="4-Spring-Data-for-Redis"><a href="#4-Spring-Data-for-Redis" class="headerlink" title="4. Spring Data for Redis"></a>4. Spring Data for Redis</h2><h3 id="4-1-客户端集成"><a href="#4-1-客户端集成" class="headerlink" title="4.1 客户端集成"></a>4.1 客户端集成</h3><p>要在Java应用中与Redis服务器进行通信，我们需要一个<strong>Redis客户端库</strong>。这个库负责处理网络连接、执行Redis命令、以及对返回结果进行编码和解码。</p>
<p>在Spring Boot 2.x及以后的版本中，Spring Data Redis 支持两个主流的、高性能的Java Redis客户端：<strong>Lettuce</strong> 和 <strong>Jedis</strong>。</p>
<p><strong>Spring Boot的默认选择</strong>：从 Spring Boot 2.0 开始，<strong>Lettuce</strong> 成为了<strong>默认</strong>的Redis客户端。</p>
<hr>
<h4 id="4-1-1-如何配置"><a href="#4-1-1-如何配置" class="headerlink" title="4.1.1 如何配置"></a>4.1.1 如何配置</h4><p>Spring Boot的自动配置机制使得客户端的集成变得异常简单。</p>
<p><strong>Step 1: 添加 <code>spring-boot-starter-data-redis</code> 依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当你只添加这个Starter时，它会<strong>传递性地依赖 <code>lettuce-core</code></strong>，所以你默认使用的就是Lettuce。</li>
</ul>
<p><strong>Step 2: 配置Redis连接 (<code>application.yml</code>)</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your-password</span> <span class="comment"># 如果有密码的话</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># 使用的数据库索引，默认为0</span></span><br><span class="line">    <span class="attr">lettuce:</span> <span class="comment"># Lettuce特有的连接池配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 最大连接数</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>   <span class="comment"># 最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>   <span class="comment"># 最小空闲连接</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">-1ms</span> <span class="comment"># 连接等待时间，-1表示不限制</span></span><br></pre></td></tr></table></figure>

<p>完成这两步，Spring Boot就会自动为你配置好一个<code>LettuceConnectionFactory</code>以及后续会讲到的<code>RedisTemplate</code>等Bean，你就可以直接开始使用了。</p>
<hr>
<h4 id="4-1-2-Lettuce-现代化的、默认的选择"><a href="#4-1-2-Lettuce-现代化的、默认的选择" class="headerlink" title="4.1.2 Lettuce - 现代化的、默认的选择"></a>4.1.2 Lettuce - 现代化的、默认的选择</h4><ul>
<li><strong>官方网站</strong>: <a target="_blank" rel="noopener" href="https://lettuce.io/">https://lettuce.io/</a></li>
<li><strong>底层技术</strong>: 基于 <strong>Netty</strong>，一个高性能的、异步的、事件驱动的网络应用框架。</li>
<li><strong>核心特点</strong>:<ol>
<li><strong>异步非阻塞 (Asynchronous &amp; Non-blocking)</strong>: 这是Lettuce<strong>最核心的优势</strong>。它允许你在一个线程上发送多个Redis命令而无需等待响应，当响应返回时，会通过回调来处理。这与响应式编程（Project Reactor）的思想完美契合。</li>
<li><strong>响应式支持 (Reactive)</strong>: Lettuce提供了原生的响应式API，可以返回<code>Mono</code>和<code>Flux</code>。这使得它成为<strong>Spring WebFlux</strong>项目中与Redis交互的<strong>唯一选择</strong>。</li>
<li><strong>可伸缩性和高性能</strong>: 由于其非阻塞的特性，Lettuce可以用更少的线程处理更高的并发量，从而获得更好的性能和资源利用率。</li>
<li><strong>线程安全</strong>: 一个Lettuce连接（<code>StatefulRedisConnection</code>）<strong>是线程安全的</strong>，这意味着多个线程可以<strong>共享同一个连接</strong>来执行命令，而不会产生线程安全问题。这简化了连接管理，并且通过连接池可以进一步提高性能。</li>
</ol>
</li>
<li><strong>缺点</strong>:<ul>
<li>API相对Jedis来说稍显复杂，特别是直接使用其原生异步API时。但在Spring Data Redis的封装下，这个缺点被很大程度上隐藏了。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-3-Jedis-传统而稳定的选择"><a href="#4-1-3-Jedis-传统而稳定的选择" class="headerlink" title="4.1.3 Jedis - 传统而稳定的选择"></a>4.1.3 Jedis - 传统而稳定的选择</h4><ul>
<li><strong>官方网站</strong>: <a target="_blank" rel="noopener" href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></li>
<li><strong>底层技术</strong>: 基于传统的<strong>阻塞式I&#x2F;O (BIO)</strong>，使用Java的<code>Socket</code>进行通信。</li>
<li><strong>核心特点</strong>:<ol>
<li><strong>同步阻塞 (Synchronous &amp; Blocking)</strong>: 这是Jedis最显著的特点。当你发送一个命令时，当前线程会<strong>阻塞</strong>，直到Redis服务器返回响应。这使得它的编程模型非常简单直观，易于理解。</li>
<li><strong>简单易用</strong>: API非常直接，几乎与Redis的原生命令一一对应。</li>
<li><strong>线程不安全</strong>: 一个Jedis连接实例<strong>不是线程安全的</strong>。因此，在多线程环境中，你<strong>必须</strong>使用连接池（如<code>JedisPool</code>），每个线程从池中获取自己的连接，使用完毕后归还。如果多个线程共享一个Jedis实例，会导致不可预知的数据错乱。</li>
</ol>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>性能瓶颈</strong>: 在高并发场景下，同步阻塞模型会导致大量线程被创建和阻塞，成为系统的性能瓶颈。</li>
<li><strong>不支持响应式</strong>: 由于其阻塞的特性，Jedis<strong>无法</strong>与Spring WebFlux等响应式框架协同工作。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-4-如何从Lettuce切换到Jedis？"><a href="#4-1-4-如何从Lettuce切换到Jedis？" class="headerlink" title="4.1.4 如何从Lettuce切换到Jedis？"></a>4.1.4 如何从Lettuce切换到Jedis？</h4><p>如果你因为特定原因（例如，需要兼容一些只支持Jedis的老代码或库）需要使用Jedis，切换过程也非常简单：</p>
<p><strong>Step 1: 修改<code>pom.xml</code></strong></p>
<ol>
<li>在 <code>spring-boot-starter-data-redis</code> 中<strong>排除</strong>默认的 <code>lettuce-core</code> 依赖。</li>
<li><strong>添加</strong> <code>jedis</code> 依赖。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 修改<code>application.yml</code> (可选)</strong></p>
<p>将连接池的配置从<code>lettuce.pool</code>改为<code>jedis.pool</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># ... host, port等通用配置 ...</span></span><br><span class="line">    <span class="attr">jedis:</span> <span class="comment"># Jedis特有的连接池配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot的自动配置会检测到类路径下存在<code>Jedis</code>而没有<code>Lettuce</code>，于是会自动为你配置<code>JedisConnectionFactory</code>。你的上层业务代码（如使用<code>RedisTemplate</code>）<strong>无需做任何改动</strong>，这是Spring抽象的强大之处。</p>
<hr>
<h4 id="4-1-5-总结"><a href="#4-1-5-总结" class="headerlink" title="4.1.5 总结"></a>4.1.5 总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Lettuce (默认推荐)</th>
<th align="left">Jedis (传统选择)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>I&#x2F;O模型</strong></td>
<td align="left"><strong>异步非阻塞</strong> (基于Netty)</td>
<td align="left"><strong>同步阻塞</strong> (基于BIO Socket)</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left">连接是<strong>线程安全</strong>的，可多线程共享</td>
<td align="left">连接是<strong>非线程安全</strong>的，多线程必须使用连接池</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>高</strong>。在高并发和响应式场景下表现优异。</td>
<td align="left"><strong>中等</strong>。在低并发下简单直接，高并发下会成为瓶颈。</td>
</tr>
<tr>
<td align="left"><strong>响应式支持</strong></td>
<td align="left"><strong>原生支持</strong>。是WebFlux的标配。</td>
<td align="left"><strong>不支持</strong>。无法用于响应式编程。</td>
</tr>
<tr>
<td align="left"><strong>资源消耗</strong></td>
<td align="left"><strong>低</strong>。可以用更少的线程处理更多请求。</td>
<td align="left"><strong>高</strong>。每个阻塞的请求都需要一个线程。</td>
</tr>
<tr>
<td align="left"><strong>编程模型</strong></td>
<td align="left">略复杂，但被Spring封装后变得简单。</td>
<td align="left">非常简单直观。</td>
</tr>
</tbody></table>
<p><strong>最终建议</strong>:</p>
<ul>
<li>对于<strong>所有新的Spring Boot项目</strong>，都应该<strong>坚持使用默认的Lettuce</strong>。它的性能优势、线程安全以及对未来响应式编程的支持，使其成为一个毫无疑问的更优选择。</li>
<li>只有在维护<strong>老的、已经在使用Jedis的项目</strong>，或者有<strong>强烈的理由</strong>（如需要与某些仅支持Jedis的第三方工具集成）时，才考虑切换到Jedis。</li>
</ul>
<hr>
<h3 id="4-2-RedisTemplate-vs-StringRedisTemplate"><a href="#4-2-RedisTemplate-vs-StringRedisTemplate" class="headerlink" title="4.2 RedisTemplate vs StringRedisTemplate"></a>4.2 <code>RedisTemplate</code> vs <code>StringRedisTemplate</code></h3><p>当你在Spring Boot项目中配置好Redis后，自动配置会为你创建并注册两个核心的模板类Bean：<code>RedisTemplate&lt;Object, Object&gt;</code> 和 <code>StringRedisTemplate</code>。它们都是对Redis命令的高度封装，提供了便捷的API来操作Redis中的各种数据结构。</p>
<p>它们最核心、最根本的区别在于<strong>序列化方式 (Serialization)</strong> 的不同。</p>
<hr>
<h4 id="4-2-1-RedisTemplate-通用的、面向对象的模板"><a href="#4-2-1-RedisTemplate-通用的、面向对象的模板" class="headerlink" title="4.2.1 RedisTemplate&lt;K, V&gt; - 通用的、面向对象的模板"></a>4.2.1 <code>RedisTemplate&lt;K, V&gt;</code> - 通用的、面向对象的模板</h4><ul>
<li><strong>泛型定义</strong>: <code>RedisTemplate&lt;K, V&gt;</code> 是一个泛型类，允许你指定键（Key）和值（Value）的类型。在Spring Boot自动配置中，默认创建的是 <code>RedisTemplate&lt;Object, Object&gt;</code>。</li>
<li><strong>核心特点：可定制的序列化</strong><ul>
<li><code>RedisTemplate</code> 为了能够处理<strong>任何类型的Java对象</strong>（如 <code>User</code>, <code>Product</code>, <code>List&lt;String&gt;</code> 等），必须对存入Redis的键和值进行<strong>序列化</strong>，将Java对象转换成二进制数据。</li>
<li><strong>默认序列化器</strong>: <code>JdkSerializationRedisSerializer</code>。<ul>
<li><strong>工作方式</strong>: 使用Java<strong>自带的序列化机制</strong> (<code>ObjectOutputStream</code>)。</li>
<li><strong>缺点</strong>:<ol>
<li><strong>可读性极差</strong>: 序列化后的结果是一串二进制数据，包含了类的信息、版本号等，在Redis客户端（如<code>redis-cli</code>）中查看时，会显示为乱码（如 <code>\xac\xed\x00\x05t\x00\x04user</code>）。</li>
<li><strong>跨语言不友好</strong>: 只有Java程序能够反序列化这些数据，其他语言（Python, Go, Node.js）的程序无法识别。</li>
<li><strong>占用空间较大</strong>: 存储了额外的元数据，比JSON等格式更占空间。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>当你需要存储<strong>复杂的Java对象</strong>，并且<strong>只有Java应用</strong>会访问这些数据时。</li>
<li>在现代微服务架构中，由于其可读性和跨语言的弊端，<strong>默认的<code>JdkSerializationRedisSerializer</code>已不被推荐使用</strong>。</li>
</ul>
</li>
<li><strong>如何改进（最佳实践）</strong>:<br>为了解决上述缺点，我们通常会<strong>手动配置<code>RedisTemplate</code></strong>，将其默认的序列化器替换为<strong>更通用的格式</strong>，如 <strong>JSON</strong>。</li>
</ul>
<p><strong>自定义 <code>RedisTemplate</code> Bean配置示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建JSON序列化器</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建String序列化器</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 设置Key的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 设置Value的序列化方式</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置后的效果</strong>:</p>
<ul>
<li>当你使用这个自定义的 <code>redisTemplate</code> 存入一个 <code>User</code> 对象时，Redis中存储的将是<strong>可读的JSON字符串</strong>，如 <code>{&quot;id&quot;:1, &quot;name&quot;:&quot;Alice&quot;}</code>。</li>
<li>这样既保证了可读性，也实现了跨语言的兼容性。</li>
</ul>
<hr>
<h4 id="4-2-2-StringRedisTemplate-专用于字符串的模板"><a href="#4-2-2-StringRedisTemplate-专用于字符串的模板" class="headerlink" title="4.2.2 StringRedisTemplate - 专用于字符串的模板"></a>4.2.2 <code>StringRedisTemplate</code> - 专用于字符串的模板</h4><ul>
<li><p><strong>继承关系</strong>: <code>StringRedisTemplate extends RedisTemplate&lt;String, String&gt;</code>。</p>
</li>
<li><p><strong>核心特点：固定的字符串序列化</strong></p>
<ul>
<li>从它的继承关系就可以看出，<code>StringRedisTemplate</code> 是一个<strong>特化</strong>的<code>RedisTemplate</code>，它<strong>强制要求键（Key）和值（Value）都是 <code>String</code> 类型</strong>。</li>
<li>它内部<strong>固定使用 <code>StringRedisSerializer</code></strong> 来进行序列化。</li>
<li><code>StringRedisSerializer</code> 会将字符串按照指定的字符集（默认为UTF-8）转换为字节数组。</li>
</ul>
</li>
<li><p><strong>优点</strong>:</p>
<ol>
<li><strong>可读性最好</strong>: 存入Redis的数据就是你传入的原始字符串，在任何客户端中查看都非常直观。</li>
<li><strong>通用性最强</strong>: 字符串是所有编程语言都支持的最基本数据类型，跨语言交互毫无障碍。</li>
<li><strong>性能高</strong>: 字符串序列化比复杂的对象序列化更快。</li>
<li><strong>完美匹配Redis原生操作</strong>: 非常适合用来操作Redis中的字符串类型数据，以及对数字进行<code>incr</code>（自增）、<code>decr</code>（自减）等操作。</li>
</ol>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li><p>当你的应用中，Redis主要用于存储<strong>简单的字符串键值对</strong>时，例如：</p>
<ul>
<li>缓存简单的文本信息、配置项。</li>
<li>存储Session ID。</li>
<li>实现分布式锁（锁的value通常是字符串）。</li>
<li>用作计数器（存储数字字符串）。</li>
</ul>
</li>
<li><p>当需要缓存<strong>JSON字符串</strong>时。你可以手动将Java对象序列化为JSON字符串，然后使用<code>StringRedisTemplate</code>存入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:1&quot;</span>, userJson);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动反序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">storedJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> objectMapper.readValue(storedJson, User.class);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-2-3-总结"><a href="#4-2-3-总结" class="headerlink" title="4.2.3 总结"></a>4.2.3 总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>RedisTemplate&lt;Object, Object&gt;</code> (默认)</th>
<th align="left"><code>RedisTemplate&lt;String, Object&gt;</code> (自定义JSON序列化)</th>
<th align="left"><code>StringRedisTemplate</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>键(Key)类型</strong></td>
<td align="left"><code>Object</code></td>
<td align="left"><code>String</code></td>
<td align="left"><code>String</code></td>
</tr>
<tr>
<td align="left"><strong>值(Value)类型</strong></td>
<td align="left"><code>Object</code></td>
<td align="left"><code>Object</code></td>
<td align="left"><code>String</code></td>
</tr>
<tr>
<td align="left"><strong>序列化器</strong></td>
<td align="left"><code>JdkSerializationRedisSerializer</code></td>
<td align="left">Key: <code>StringRedisSerializer</code><br>Value: <code>Jackson2JsonRedisSerializer</code></td>
<td align="left">Key&#x2F;Value: <code>StringRedisSerializer</code></td>
</tr>
<tr>
<td align="left"><strong>Redis中存储格式</strong></td>
<td align="left"><strong>二进制乱码</strong></td>
<td align="left"><strong>可读的JSON字符串</strong></td>
<td align="left"><strong>原始字符串</strong></td>
</tr>
<tr>
<td align="left"><strong>跨语言兼容性</strong></td>
<td align="left"><strong>差</strong> (仅Java)</td>
<td align="left"><strong>好</strong></td>
<td align="left"><strong>极好</strong></td>
</tr>
<tr>
<td align="left"><strong>可读性</strong></td>
<td align="left"><strong>差</strong></td>
<td align="left"><strong>好</strong></td>
<td align="left"><strong>极好</strong></td>
</tr>
<tr>
<td align="left"><strong>使用便利性</strong></td>
<td align="left">直接存取Java对象，无需手动转换。</td>
<td align="left">直接存取Java对象，无需手动转换。</td>
<td align="left">只能存取字符串，存取对象需<strong>手动进行JSON转换</strong>。</td>
</tr>
<tr>
<td align="left"><strong>核心用途</strong></td>
<td align="left">存储任意Java对象（不推荐默认配置）</td>
<td align="left"><strong>推荐用于存储复杂Java对象作为缓存</strong></td>
<td align="left"><strong>推荐用于存储简单字符串、计数器、JSON字符串</strong></td>
</tr>
</tbody></table>
<p><strong>最终选择建议</strong>:</p>
<ol>
<li><strong>首选自定义的<code>RedisTemplate&lt;String, Object&gt;</code></strong>: 在大多数需要将<strong>Java对象</strong>作为整体进行缓存的场景中，配置一个使用JSON序列化器的<code>RedisTemplate</code>是<strong>最佳实践</strong>。它兼顾了使用的便利性（直接操作对象）和数据在Redis中的可读性&#x2F;通用性。</li>
<li><strong>使用<code>StringRedisTemplate</code>处理简单数据</strong>: 当你明确知道要处理的就是<strong>字符串</strong>、<strong>数字</strong>（作为字符串存储）或者需要<strong>手动控制JSON转换</strong>时，<code>StringRedisTemplate</code> 是最直接、最高效的选择。</li>
<li><strong>避免使用默认的<code>RedisTemplate&lt;Object, Object&gt;</code></strong>: 除非你的应用是一个与外界完全隔离的、纯Java的单体应用，并且你不在乎Redis中数据的可读性，否则应<strong>尽量避免</strong>使用其默认的JDK序列化方式。</li>
</ol>
<hr>
<h3 id="4-3-常用数据结构操作"><a href="#4-3-常用数据结构操作" class="headerlink" title="4.3 常用数据结构操作"></a>4.3 常用数据结构操作</h3><p>Redis之所以强大，不仅仅因为它是一个键值存储，更在于它为值（Value）提供了丰富的数据结构。Spring Data Redis 通过 <code>RedisTemplate</code> 提供了一系列的操作接口（Operations），使得我们可以用面向对象的方式来与这些数据结构交互，而无需记忆繁杂的Redis命令。</p>
<p><strong>获取操作接口</strong>:</p>
<p><code>RedisTemplate</code> 提供了一系列的 <code>opsFor...()</code> 方法来获取针对特定数据结构的操作接口：</p>
<ul>
<li><code>opsForValue()</code>: 操作 <strong>String (字符串)</strong></li>
<li><code>opsForHash()</code>: 操作 <strong>Hash (哈希&#x2F;散列)</strong></li>
<li><code>opsForList()</code>: 操作 <strong>List (列表)</strong></li>
<li><code>opsForSet()</code>: 操作 <strong>Set (集合)</strong></li>
<li><code>opsForZSet()</code>: 操作 <strong>ZSet (有序集合)</strong></li>
</ul>
<p>在下面的示例中，我们假设已经注入了<code>StringRedisTemplate</code>，因为它操作的结果在<code>redis-cli</code>中查看最直观。使用自定义JSON序列化的<code>RedisTemplate</code>在API调用上是完全一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisOperationService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 操作方法将在这里实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-1-String-字符串"><a href="#4-3-1-String-字符串" class="headerlink" title="4.3.1 String (字符串)"></a>4.3.1 String (字符串)</h4><p>这是最简单的数据结构，一个key对应一个string value。</p>
<ul>
<li><strong>用途</strong>: 缓存用户信息JSON、存储配置、计数器、分布式锁等。</li>
<li><strong>操作接口</strong>: <code>ValueOperations&lt;String, String&gt;</code> (通过 <code>stringRedisTemplate.opsForValue()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 设置键值 (SET key value)</span></span><br><span class="line">    ops.set(<span class="string">&quot;user:1:name&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置键值并带过期时间 (SETEX key seconds value)</span></span><br><span class="line">    ops.set(<span class="string">&quot;sms:code:138xxxx&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取键值 (GET key)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ops.get(<span class="string">&quot;user:1:name&quot;</span>); <span class="comment">// &quot;Alice&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取多个键值 (MGET key1 key2 ...)</span></span><br><span class="line">    List&lt;String&gt; values = ops.multiGet(Arrays.asList(<span class="string">&quot;user:1:name&quot;</span>, <span class="string">&quot;another_key&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 原子性自增 (INCR key) - 值必须是数字字符串</span></span><br><span class="line">    ops.set(<span class="string">&quot;page:view:1001&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    ops.increment(<span class="string">&quot;page:view:1001&quot;</span>); <span class="comment">// 返回 1</span></span><br><span class="line">    ops.increment(<span class="string">&quot;page:view:1001&quot;</span>, <span class="number">10</span>); <span class="comment">// 增加10，返回 11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 原子性自减 (DECR key)</span></span><br><span class="line">    ops.decrement(<span class="string">&quot;page:view:1001&quot;</span>); <span class="comment">// 返回 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-2-Hash-哈希"><a href="#4-3-2-Hash-哈希" class="headerlink" title="4.3.2 Hash (哈希)"></a>4.3.2 Hash (哈希)</h4><p>一个key对应一个<code>Map&lt;String, String&gt;</code>，非常适合用来存储一个<strong>对象</strong>的多个字段。</p>
<ul>
<li><strong>用途</strong>: 存储一个用户的多个属性（姓名、年龄、邮箱），避免为每个属性都创建一个顶层key。</li>
<li><strong>操作接口</strong>: <code>HashOperations&lt;String, HK, HV&gt;</code> (通过 <code>stringRedisTemplate.opsForHash()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    HashOperations&lt;String, String, String&gt; ops = stringRedisTemplate.opsForHash();</span><br><span class="line">    <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;user:profile:1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 设置单个字段值 (HSET key field value)</span></span><br><span class="line">    ops.put(userKey, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    ops.put(userKey, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 一次性设置多个字段值 (HMSET key field1 value1 ...)</span></span><br><span class="line">    Map&lt;String, String&gt; userFields = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    userFields.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;bob@example.com&quot;</span>);</span><br><span class="line">    userFields.put(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;New York&quot;</span>);</span><br><span class="line">    ops.putAll(userKey, userFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取单个字段值 (HGET key field)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ops.get(userKey, <span class="string">&quot;name&quot;</span>); <span class="comment">// &quot;Bob&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取多个字段值 (HMGET key field1 field2 ...)</span></span><br><span class="line">    List&lt;String&gt; fields = ops.multiGet(userKey, Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;city&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 获取所有字段和值 (HGETALL key)</span></span><br><span class="line">    Map&lt;String, String&gt; allFields = ops.entries(userKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 删除一个或多个字段 (HDEL key field1 ...)</span></span><br><span class="line">    ops.delete(userKey, <span class="string">&quot;city&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 判断字段是否存在 (HEXISTS key field)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> ops.hasKey(userKey, <span class="string">&quot;email&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-3-List-列表"><a href="#4-3-3-List-列表" class="headerlink" title="4.3.3 List (列表)"></a>4.3.3 List (列表)</h4><p>一个key对应一个<strong>有序的、可重复的</strong>字符串列表。它是一个双向链表，所以在两端添加和删除元素非常快。</p>
<ul>
<li><strong>用途</strong>: 实现消息队列（生产者LPUSH，消费者BRPOP）、存储文章的评论列表、最新动态列表。</li>
<li><strong>操作接口</strong>: <code>ListOperations&lt;String, String&gt;</code> (通过 <code>stringRedisTemplate.opsForList()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line">    ListOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForList();</span><br><span class="line">    <span class="type">String</span> <span class="variable">tasksKey</span> <span class="operator">=</span> <span class="string">&quot;tasks:queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从左侧推入元素 (LPUSH key value1 [value2 ...])</span></span><br><span class="line">    ops.leftPush(tasksKey, <span class="string">&quot;Task A&quot;</span>);</span><br><span class="line">    ops.leftPushAll(tasksKey, <span class="string">&quot;Task B&quot;</span>, <span class="string">&quot;Task C&quot;</span>); <span class="comment">// 现在的顺序: C, B, A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从右侧推入元素 (RPUSH key value1 [value2 ...])</span></span><br><span class="line">    ops.rightPush(tasksKey, <span class="string">&quot;Task D&quot;</span>); <span class="comment">// 现在的顺序: C, B, A, D</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从左侧弹出元素 (LPOP key)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> ops.leftPop(tasksKey); <span class="comment">// &quot;C&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从右侧弹出元素 (RPOP key)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lastTask</span> <span class="operator">=</span> ops.rightPop(tasksKey); <span class="comment">// &quot;D&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 阻塞式地从左侧弹出元素 (BLPOP key timeout) - 消息队列核心</span></span><br><span class="line">    <span class="comment">// 如果列表为空，会阻塞等待最多10秒，直到有新元素或超时</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">blockingTask</span> <span class="operator">=</span> ops.leftPop(tasksKey, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 获取列表长度 (LLEN key)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> ops.size(tasksKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 获取指定范围的元素 (LRANGE key start stop) - 0是第一个，-1是最后一个</span></span><br><span class="line">    List&lt;String&gt; allTasks = ops.range(tasksKey, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-4-Set-集合"><a href="#4-3-4-Set-集合" class="headerlink" title="4.3.4 Set (集合)"></a>4.3.4 Set (集合)</h4><p>一个key对应一个<strong>无序的、唯一的</strong>字符串集合。</p>
<ul>
<li><strong>用途</strong>: 存储一篇文章的点赞用户ID、一个用户的标签、共同好友计算。</li>
<li><strong>操作接口</strong>: <code>SetOperations&lt;String, String&gt;</code> (通过 <code>stringRedisTemplate.opsForSet()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">    SetOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForSet();</span><br><span class="line">    <span class="type">String</span> <span class="variable">post1Likes</span> <span class="operator">=</span> <span class="string">&quot;post:1:likes&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">post2Likes</span> <span class="operator">=</span> <span class="string">&quot;post:2:likes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 添加一个或多个成员 (SADD key member1 [member2 ...])</span></span><br><span class="line">    ops.add(post1Likes, <span class="string">&quot;user:101&quot;</span>, <span class="string">&quot;user:102&quot;</span>, <span class="string">&quot;user:103&quot;</span>);</span><br><span class="line">    ops.add(post2Likes, <span class="string">&quot;user:102&quot;</span>, <span class="string">&quot;user:104&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取所有成员 (SMEMBERS key)</span></span><br><span class="line">    Set&lt;String&gt; members = ops.members(post1Likes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 判断成员是否存在 (SISMEMBER key member)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> ops.isMember(post1Likes, <span class="string">&quot;user:101&quot;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取集合大小 (SCARD key)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> ops.size(post1Likes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 移除一个或多个成员 (SREM key member1 ...)</span></span><br><span class="line">    ops.remove(post1Likes, <span class="string">&quot;user:103&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 集合运算</span></span><br><span class="line">    <span class="comment">// 交集 (SINTER key1 key2): 同时点赞了文章1和文章2的用户</span></span><br><span class="line">    Set&lt;String&gt; intersection = ops.intersect(post1Likes, post2Likes); <span class="comment">// &#123;&quot;user:102&quot;&#125;</span></span><br><span class="line">    <span class="comment">// 并集 (SUNION key1 key2): 至少点赞了一篇文章的用户</span></span><br><span class="line">    Set&lt;String&gt; union = ops.union(post1Likes, post2Likes);</span><br><span class="line">    <span class="comment">// 差集 (SDIFF key1 key2): 点赞了文章1但没点赞文章2的用户</span></span><br><span class="line">    Set&lt;String&gt; difference = ops.difference(post1Likes, post2Likes); <span class="comment">// &#123;&quot;user:101&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-5-ZSet-有序集合"><a href="#4-3-5-ZSet-有序集合" class="headerlink" title="4.3.5 ZSet (有序集合)"></a>4.3.5 ZSet (有序集合)</h4><p>ZSet (Sorted Set) 是Set的升级版，它在每个成员上关联了一个<strong>分数 (score)</strong>，并根据这个分数对成员进行<strong>排序</strong>。成员是唯一的，但分数可以重复。</p>
<ul>
<li><strong>用途</strong>: 排行榜（按分数排序）、带有权重的任务队列、范围查找（如查找分数在某个区间的成员）。</li>
<li><strong>操作接口</strong>: <code>ZSetOperations&lt;String, String&gt;</code> (通过 <code>stringRedisTemplate.opsForZSet()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZSet</span><span class="params">()</span> &#123;</span><br><span class="line">    ZSetOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForZSet();</span><br><span class="line">    <span class="type">String</span> <span class="variable">leaderboardKey</span> <span class="operator">=</span> <span class="string">&quot;game:leaderboard&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 添加成员并指定分数 (ZADD key score1 member1 [score2 member2 ...])</span></span><br><span class="line">    ops.add(leaderboardKey, <span class="string">&quot;player:alice&quot;</span>, <span class="number">1500.0</span>);</span><br><span class="line">    ops.add(leaderboardKey, <span class="string">&quot;player:bob&quot;</span>, <span class="number">1800.0</span>);</span><br><span class="line">    ops.add(leaderboardKey, <span class="string">&quot;player:charlie&quot;</span>, <span class="number">1200.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 为成员增加分数 (ZINCRBY key increment member)</span></span><br><span class="line">    ops.incrementScore(leaderboardKey, <span class="string">&quot;player:alice&quot;</span>, <span class="number">50.0</span>); <span class="comment">// Alice的分数变为1550</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取指定成员的分数 (ZSCORE key member)</span></span><br><span class="line">    <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> ops.score(leaderboardKey, <span class="string">&quot;player:bob&quot;</span>); <span class="comment">// 1800.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 按分数范围获取成员 (ZRANGEBYSCORE key min max)</span></span><br><span class="line">    Set&lt;String&gt; players = ops.rangeByScore(leaderboardKey, <span class="number">1500</span>, <span class="number">2000</span>); <span class="comment">// &#123;&quot;player:alice&quot;, &quot;player:bob&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 按排名范围获取成员 (ZRANGE key start stop) - 分数从低到高</span></span><br><span class="line">    Set&lt;String&gt; top3Asc = ops.range(leaderboardKey, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// Charlie, Alice, Bob</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 按排名范围获取成员 (ZREVRANGE key start stop) - 分数从高到低</span></span><br><span class="line">    Set&lt;String&gt; top3Desc = ops.reverseRange(leaderboardKey, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// Bob, Alice, Charlie</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 获取成员的排名 (ZRANK / ZREVRANK)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">rank</span> <span class="operator">=</span> ops.rank(leaderboardKey, <span class="string">&quot;player:alice&quot;</span>); <span class="comment">// 1 (从0开始，升序排名)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">reverseRank</span> <span class="operator">=</span> ops.reverseRank(leaderboardKey, <span class="string">&quot;player:alice&quot;</span>); <span class="comment">// 1 (从0开始，降序排名)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. 获取集合大小 (ZCARD key)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> ops.size(leaderboardKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-SpringCache抽象与Redis实现"><a href="#4-4-SpringCache抽象与Redis实现" class="headerlink" title="4.4 SpringCache抽象与Redis实现"></a>4.4 SpringCache抽象与Redis实现</h3><h4 id="4-4-1-什么是-Spring-Cache-抽象？"><a href="#4-4-1-什么是-Spring-Cache-抽象？" class="headerlink" title="4.4.1 什么是 Spring Cache 抽象？"></a>4.4.1 什么是 Spring Cache 抽象？</h4><p><strong>问题背景</strong>：<br>在应用中，对于那些<strong>读多写少</strong>、<strong>计算成本高</strong>且<strong>数据不经常变化</strong>的操作（例如，从数据库查询商品详情、计算复杂的报表），我们通常会引入<strong>缓存</strong>来提升性能和降低后端负载。</p>
<p><strong>传统的缓存实现方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Service层手动编写缓存逻辑</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">getProductById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 先从缓存中查找</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> cacheManager.get(<span class="string">&quot;productCache&quot;</span>, id);</span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> product; <span class="comment">// 缓存命中，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 缓存未命中，从数据库查询</span></span><br><span class="line">    product = productRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将查询结果放入缓存</span></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheManager.put(<span class="string">&quot;productCache&quot;</span>, id, product);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种方式的痛点</strong>:</p>
<ol>
<li><strong>代码侵入性强</strong>: 缓存逻辑（<code>get</code>, <code>put</code>, <code>evict</code>）与业务逻辑<strong>高度耦合</strong>，混杂在一起，使得业务代码变得复杂和不纯粹。</li>
<li><strong>重复劳动</strong>: 每个需要缓存的方法都得写一遍类似的逻辑。</li>
<li><strong>缓存技术更换困难</strong>: 如果想从 Guava Cache 换成 Redis Cache，你需要修改所有相关的业务代码。</li>
</ol>
<p><strong>Spring Cache 抽象的解决方案</strong>:<br>Spring Cache 提供了一套<strong>基于注解</strong>的、<strong>与具体缓存技术无关</strong>的抽象层。它的核心思想是：</p>
<ul>
<li><strong>将缓存操作声明化</strong>: 开发者不再需要手动编写缓存的读写逻辑，而是通过在方法上添加简单的注解（如 <code>@Cacheable</code>），来**“声明”**这个方法的缓存行为。</li>
<li><strong>AOP实现</strong>: Spring 在底层通过**AOP（面向切面编程）**来拦截这些被注解标记的方法调用。<ul>
<li>在方法<strong>执行前</strong>，AOP切面会先检查缓存。如果命中，则直接返回缓存结果，<strong>不再执行</strong>方法体。</li>
<li>如果缓存未命中，AOP切面会<strong>执行</strong>方法体，获取返回值，然后在方法<strong>返回后</strong>，自动将结果放入缓存。</li>
</ul>
</li>
<li><strong>技术无关性</strong>: 你的业务代码只依赖于Spring Cache的注解，而<strong>不关心底层到底是用Redis、Caffeine、EhCache还是ConcurrentHashMap</strong>。底层的缓存实现是可插拔的，通过配置文件即可轻松切换。</li>
</ul>
<p><strong>最终效果</strong>: 业务代码回归纯粹，缓存逻辑被优雅地分离出去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务代码变得极其简洁</span></span><br><span class="line"><span class="meta">@Cacheable(cacheNames = &quot;productCache&quot;, key = &quot;#id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">getProductById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 只需要保留核心的业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> productRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-4-2-核心注解"><a href="#4-4-2-核心注解" class="headerlink" title="4.4.2 核心注解"></a>4.4.2 核心注解</h4><p>Spring Cache 主要通过以下三个注解来工作：</p>
<ul>
<li><p><strong><code>@Cacheable</code></strong>: <strong>触发缓存入口</strong></p>
<ul>
<li><strong>作用</strong>: 主要用于<strong>查询</strong>操作。标记在一个方法上，表示该方法的执行结果是可以被缓存的。</li>
<li><strong>执行流程</strong>:<ol>
<li>方法调用前，根据 <code>cacheNames</code> 和 <code>key</code> 生成一个缓存键。</li>
<li>用这个键去缓存中查找。</li>
<li><strong>如果找到</strong>，直接返回缓存的值，<strong>方法体不会被执行</strong>。</li>
<li><strong>如果没找到</strong>，执行方法体，将方法的返回值存入缓存，然后再返回结果。</li>
</ol>
</li>
<li><strong>常用属性</strong>:<ul>
<li><code>cacheNames</code> &#x2F; <code>value</code>: 指定要使用的缓存区域的名称（可以有多个）。</li>
<li><code>key</code>: <strong>缓存的键</strong>。支持 <strong>SpEL (Spring Expression Language)</strong> 来动态生成。<ul>
<li><code>#id</code>: 引用方法参数 <code>id</code>。</li>
<li><code>#p0</code>, <code>#a0</code>: 引用第一个方法参数。</li>
<li><code>#result</code>: 引用方法的返回值（通常用于<code>@CachePut</code>）。</li>
<li><code>#root.methodName</code>: 引用当前方法名。</li>
<li>如果<strong>不指定</strong>，Spring会使用所有方法参数的 <code>hashCode</code> 生成一个默认的key。</li>
</ul>
</li>
<li><code>condition</code>: SpEL表达式，满足条件时才进行缓存。例如 <code>condition = &quot;#result != null&quot;</code>。</li>
<li><code>unless</code>: SpEL表达式，满足条件时<strong>不</strong>进行缓存。例如 <code>unless = &quot;#result.price &lt; 100&quot;</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>@CachePut</code></strong>: <strong>强制更新缓存</strong></p>
<ul>
<li><strong>作用</strong>: 主要用于<strong>更新</strong>操作。</li>
<li><strong>执行流程</strong>: 与 <code>@Cacheable</code> 不同，<code>@CachePut</code> <strong>总是会执行方法体</strong>。在方法执行成功后，它会<strong>强制</strong>将方法的返回值更新到缓存中。</li>
<li><strong>场景</strong>: 当你更新了数据库中的某个对象，并希望<strong>同步更新</strong>缓存中的数据时使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CachePut(cacheNames = &quot;productCache&quot;, key = &quot;#product.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> productRepository.save(product); <span class="comment">// save方法会返回更新后的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@CacheEvict</code></strong>: <strong>清空缓存</strong></p>
<ul>
<li><strong>作用</strong>: 主要用于<strong>删除</strong>操作。</li>
<li><strong>执行流程</strong>: 方法执行后，会从缓存中<strong>移除</strong>指定的数据。</li>
<li><strong>常用属性</strong>:<ul>
<li><code>cacheNames</code>, <code>key</code>: 指定要移除的缓存项。</li>
<li><code>allEntries = true</code>: 如果设置为 <code>true</code>，则会清空整个 <code>cacheNames</code> 区域的所有缓存，而不是只移除单个key。</li>
<li><code>beforeInvocation = true</code>: 默认是 <code>false</code> (方法执行后清除)。如果设为 <code>true</code>，则在方法执行前就清除缓存，这在方法可能抛出异常的情况下可以保证缓存一定被清除。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(cacheNames = &quot;productCache&quot;, key = &quot;#id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteProduct</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    productRepository.deleteById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空所有productCache</span></span><br><span class="line"><span class="meta">@CacheEvict(cacheNames = &quot;productCache&quot;, allEntries = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reloadAllProducts</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 重新加载数据的逻辑 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-4-3-使用Redis作为缓存实现"><a href="#4-4-3-使用Redis作为缓存实现" class="headerlink" title="4.4.3 使用Redis作为缓存实现"></a>4.4.3 使用Redis作为缓存实现</h4><p>将Spring Cache的后端从默认的 <code>ConcurrentHashMap</code> 切换为 Redis 非常简单。</p>
<p><strong>Step 1: 添加 <code>spring-boot-starter-data-redis</code> 依赖</strong></p>
<p>(这在之前的章节已经做过)</p>
<p><strong>Step 2: 在启动类上开启缓存功能</strong></p>
<p>在你的Spring Boot主启动类上添加 <code>@EnableCaching</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span> <span class="comment">// 开启Spring Cache的注解功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step 3: 配置 <code>application.yml</code></strong></p>
<p>告诉Spring Boot我们希望使用Redis作为缓存类型。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># ... redis 连接配置 ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span> <span class="comment"># 指定缓存类型为Redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="string">600s</span> <span class="comment"># 全局设置缓存的默认过期时间为10分钟</span></span><br><span class="line">      <span class="comment"># key-prefix: myapp:cache: # （可选）为所有缓存键添加一个公共前缀</span></span><br><span class="line">      <span class="comment"># use-key-prefix: true</span></span><br><span class="line">      <span class="comment"># cache-null-values: false # （可选）是否缓存null值，默认为true</span></span><br></pre></td></tr></table></figure>

<p><strong>完成！</strong> Spring Boot的自动配置会检测到 <code>spring.cache.type=redis</code>，然后自动为你配置好一个 <code>RedisCacheManager</code> Bean。现在，你所有的 <code>@Cacheable</code> 等注解就会自动地将数据存入Redis，而不是内存。</p>
<hr>
<h4 id="4-4-4-序列化问题与解决方案"><a href="#4-4-4-序列化问题与解决方案" class="headerlink" title="4.4.4 序列化问题与解决方案"></a>4.4.4 序列化问题与解决方案</h4><p>默认情况下，Spring Cache使用Redis时，会使用 <code>RedisTemplate&lt;Object, Object&gt;</code> 的默认JDK序列化方式。这会导致你在Redis中看到的是<strong>乱码</strong>。</p>
<p>为了解决这个问题，我们需要像之前一样，自定义一个 <code>RedisCacheManager</code> Bean，并为其配置<strong>JSON序列化</strong>。</p>
<p><strong>自定义 <code>RedisCacheManager</code> 配置示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个默认的缓存配置</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">defaultCacheConfig</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                <span class="comment">// 2. 设置key的序列化方式为String</span></span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()))</span><br><span class="line">                <span class="comment">// 3. 设置value的序列化方式为JSON</span></span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>()))</span><br><span class="line">                <span class="comment">// 4. 设置默认的过期时间</span></span><br><span class="line">                .entryTtl(Duration.ofMinutes(<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. （可选）为特定的cacheName设置不同的过期时间</span></span><br><span class="line">        <span class="comment">// Map&lt;String, RedisCacheConfiguration&gt; cacheConfigurations = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// cacheConfigurations.put(&quot;userCache&quot;, defaultCacheConfig.entryTtl(Duration.ofHours(1)));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 创建RedisCacheManager</span></span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(defaultCacheConfig)</span><br><span class="line">                <span class="comment">// .withInitialCacheConfigurations(cacheConfigurations)</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个配置后，所有通过Spring Cache存入Redis的数据，其值都会是<strong>可读的JSON格式</strong>，大大提升了可维护性和调试便利性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringWeb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringWeb/" class="post-title-link" itemprop="url">Spring全家桶-SpringWeb</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-05 14:27:02" itemprop="dateCreated datePublished" datetime="2025-10-05T14:27:02+08:00">2025-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:09:51" itemprop="dateModified" datetime="2025-10-17T11:09:51+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="三、SpringWeb"><a href="#三、SpringWeb" class="headerlink" title="三、SpringWeb"></a>三、SpringWeb</h1><h2 id="1-Spring-MVC-同步阻塞模型"><a href="#1-Spring-MVC-同步阻塞模型" class="headerlink" title="1. Spring MVC (同步阻塞模型)"></a>1. Spring MVC (同步阻塞模型)</h2><h3 id="1-1-核心工作流程"><a href="#1-1-核心工作流程" class="headerlink" title="1.1 核心工作流程"></a>1.1 核心工作流程</h3><p>Spring MVC（Model-View-Controller）是一个基于<strong>前端控制器模式 (Front Controller Pattern)</strong> 设计的Web框架。在这个模式中，所有的Web请求都会首先被一个<strong>单一的、核心的Servlet</strong>所拦截，然后由它来负责将请求<strong>分发</strong>给后续的组件进行处理。这个核心的Servlet就是 <strong><code>DispatcherServlet</code></strong>。</p>
<p><code>DispatcherServlet</code> 就像一个机场的**“总调度塔”**，它本身不处理具体的业务逻辑（比如查询用户信息、创建订单），但它负责指挥和协调，确保每一个到来的请求（航班）都能被正确地引导到对应的处理器（登机口），并最终返回正确的响应（乘客到达目的地）。</p>
<h4 id="1-1-1-核心组件"><a href="#1-1-1-核心组件" class="headerlink" title="1.1.1 核心组件"></a>1.1.1 核心组件</h4><p>在深入流程之前，我们先认识一下参与这个流程的几位“关键角色”：</p>
<ol>
<li><strong><code>DispatcherServlet</code> (前端控制器)</strong>:<ul>
<li><strong>职责</strong>: 整个流程的<strong>核心</strong>和<strong>入口</strong>。接收所有HTTP请求，并负责协调各个组件的工作。</li>
</ul>
</li>
<li><strong><code>HandlerMapping</code> (处理器映射器)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>查找处理器</strong>。<code>DispatcherServlet</code> 会询问它：“对于这个URL的请求，我应该交给哪个处理器（Controller的方法）来处理？”</li>
<li>它会根据请求的URL、HTTP方法等信息，从容器中找到最匹配的 <code>HandlerMethod</code>（包含了Controller实例和对应的方法信息）。</li>
</ul>
</li>
<li><strong><code>HandlerAdapter</code> (处理器适配器)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>执行处理器</strong>。由于处理器（Handler）的形式多种多样（可能是实现了某个接口的类，也可能是一个被注解标记的方法），<code>DispatcherServlet</code> 自身并不知道如何去调用它们。</li>
<li><code>HandlerAdapter</code> 就像一个**“万能插座转换器”**，它能够适配并以一种标准化的方式去调用任何类型的处理器，并返回一个 <code>ModelAndView</code> 对象。</li>
</ul>
</li>
<li><strong><code>Handler</code> (处理器)</strong>:<ul>
<li><strong>职责</strong>: <strong>处理具体的业务逻辑</strong>。这通常就是我们编写的 <strong><code>Controller</code> 类中的方法</strong>。</li>
<li>它会接收请求参数，调用Service层处理业务，并准备好模型数据（Model）和视图信息（View）。</li>
</ul>
</li>
<li><strong><code>ModelAndView</code> (模型与视图)</strong>:<ul>
<li><strong>职责</strong>: 一个<strong>封装了模型数据和视图信息的容器</strong>。</li>
<li><strong>Model</strong>: 一个Map，包含了需要传递给视图进行渲染的数据（例如，从数据库查出的用户信息）。</li>
<li><strong>View</strong>: 一个逻辑视图名（如 <code>&quot;user/detail&quot;</code>）或一个具体的视图对象。</li>
</ul>
</li>
<li><strong><code>ViewResolver</code> (视图解析器)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>解析视图</strong>。<code>DispatcherServlet</code> 会拿着 <code>ModelAndView</code> 中的逻辑视图名（如 <code>&quot;user/detail&quot;</code>）去询问 <code>ViewResolver</code>：“这个逻辑名对应的真实视图文件在哪里？”</li>
<li><code>ViewResolver</code> 会根据预先配置好的规则（如添加前缀<code>/WEB-INF/views/</code>和后缀<code>.jsp</code>），将逻辑视图名解析成一个具体的 <code>View</code> 对象（如一个JSP文件或Thymeleaf模板）。</li>
</ul>
</li>
<li><strong><code>View</code> (视图)</strong>:<ul>
<li><strong>职责</strong>: <strong>渲染模型数据</strong>。<code>View</code> 对象接收到模型数据后，负责将数据填充到视图模板中，最终生成HTML等响应内容，返回给客户端。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-1-2-工作流程详解-九大步骤"><a href="#1-1-2-工作流程详解-九大步骤" class="headerlink" title="1.1.2 工作流程详解 (九大步骤)"></a>1.1.2 工作流程详解 (九大步骤)</h4><p>下面是当一个HTTP请求（例如 <code>GET /users/123</code>）到达时，Spring MVC内部发生的详细步骤：</p>
<pre><code class="highlight mermaid">sequenceDiagram
    actor Client

    title Spring MVC DispatcherServlet 工作流程
    Client-&gt;&gt;+DS: 1. HTTP Request
    
    DS-&gt;&gt;HM: 2. 查询能处理请求的Handler
    HM--&gt;&gt;DS: 3. 返回HandlerExecutionChain (含Controller方法和Interceptors)

    DS-&gt;&gt;+HA: 4. 请求HandlerAdapter执行Handler
    
    note right of HA: 执行拦截器的 preHandle 方法
    HA-&gt;&gt;I: 5a. Interceptor.preHandle()
    I--&gt;&gt;HA: (若返回false, 则中断流程)

    note right of HA: 参数解析、数据转换、数据校验等
    HA-&gt;&gt;+C: 5b. 通过反射调用Controller方法
    
    C--&gt;&gt;-HA: 6. Controller处理后返回ModelAndView
    
    note right of HA: 执行拦截器的 postHandle 方法
    HA-&gt;&gt;I: 7a. Interceptor.postHandle()
    I--&gt;&gt;HA: 
    
    HA--&gt;&gt;-DS: 7b. 返回ModelAndView给DispatcherServlet

    DS-&gt;&gt;+VR: 8. 请求ViewResolver解析视图
    VR--&gt;&gt;-DS: 返回具体的View对象

    DS-&gt;&gt;+V: 9a. 使用Model数据渲染View
    V--&gt;&gt;-DS: 返回渲染后的响应 (如HTML)

    note left of Client: 视图渲染完毕后
    DS-&gt;&gt;I: 9b. 执行Interceptor.afterCompletion()
    I--&gt;&gt;DS: 
    
    DS--&gt;&gt;-Client: 9c. 响应客户端</code></pre>

<ol>
<li><strong>请求到达 <code>DispatcherServlet</code></strong>:<ul>
<li>用户的HTTP请求被Web服务器（如Tomcat）接收，并根据 <code>web.xml</code> (或Spring Boot的自动配置) 的映射规则，将请求转发给 <code>DispatcherServlet</code>。</li>
</ul>
</li>
<li><strong><code>DispatcherServlet</code> 查询 <code>HandlerMapping</code></strong>:<ul>
<li><code>DispatcherServlet</code> 将请求（<code>HttpServletRequest</code>）交给已注册的 <code>HandlerMapping</code> 实例（通常是 <code>RequestMappingHandlerMapping</code>），询问谁能处理这个请求。</li>
</ul>
</li>
<li><strong><code>HandlerMapping</code> 返回处理器执行链 (<code>HandlerExecutionChain</code>)</strong>:<ul>
<li><code>HandlerMapping</code> 遍历其内部维护的URL与Controller方法的映射关系，找到最匹配的 <code>HandlerMethod</code>。</li>
<li>它不仅返回这个处理器方法，还会返回一个包含所有适用于该请求的<strong>拦截器 (Interceptors)</strong> 的执行链。</li>
</ul>
</li>
<li><strong><code>DispatcherServlet</code> 请求 <code>HandlerAdapter</code> 执行 <code>Handler</code></strong>:<ul>
<li><code>DispatcherServlet</code> 根据找到的 <code>HandlerMethod</code>，选择一个能够处理这种类型Handler的 <code>HandlerAdapter</code>（通常是 <code>RequestMappingHandlerAdapter</code>）。</li>
<li>然后，<code>DispatcherServlet</code> 将请求、响应以及处理器执行链交给这个 <code>HandlerAdapter</code>。</li>
</ul>
</li>
<li><strong><code>HandlerAdapter</code> 调用 <code>Handler</code></strong>:<ul>
<li><code>HandlerAdapter</code> 在调用真正的 <code>Handler</code> (Controller方法) <strong>之前</strong>，会先按顺序执行拦截器的 <code>preHandle</code> 方法。</li>
<li>接着，<code>HandlerAdapter</code> 会进行一系列准备工作，如<strong>参数解析</strong>（将HTTP请求中的参数绑定到Controller方法的参数上）、<strong>数据转换</strong>、<strong>数据校验</strong>等。</li>
<li>一切准备就绪后，它会通过<strong>反射</strong>调用我们编写的Controller方法。</li>
</ul>
</li>
<li><strong><code>Handler</code> (Controller方法) 处理并返回 <code>ModelAndView</code></strong>:<ul>
<li>Controller方法执行业务逻辑，与Service、Repository层交互。</li>
<li>处理完成后，它会将结果数据放入一个 <code>Model</code> 对象，并指定一个逻辑视图名，最终将它们封装成一个 <code>ModelAndView</code> 对象返回给 <code>HandlerAdapter</code>。</li>
<li>(在RESTful场景下，如果方法被 <code>@ResponseBody</code> 注解，会直接返回数据对象，流程会发生变化，跳过视图解析阶段)。</li>
</ul>
</li>
<li><strong><code>HandlerAdapter</code> 返回 <code>ModelAndView</code> 给 <code>DispatcherServlet</code></strong>:<ul>
<li><code>HandlerAdapter</code> 在接收到 <code>ModelAndView</code> 后，会按逆序执行拦截器的 <code>postHandle</code> 方法。</li>
<li>最后，<code>HandlerAdapter</code> 将 <code>ModelAndView</code> 返回给 <code>DispatcherServlet</code>。</li>
</ul>
</li>
<li><strong><code>DispatcherServlet</code> 请求 <code>ViewResolver</code> 解析视图</strong>:<ul>
<li><code>DispatcherServlet</code> 从 <code>ModelAndView</code> 中取出逻辑视图名。</li>
<li>它会遍历所有已注册的 <code>ViewResolver</code>，请求它们将这个逻辑视图名解析为一个具体的 <code>View</code> 对象。</li>
</ul>
</li>
<li><strong><code>View</code> 渲染并响应</strong>:<ul>
<li><code>DispatcherServlet</code> 拿到 <code>View</code> 对象后，将 <code>ModelAndView</code> 中的模型数据传递给它。</li>
<li><code>View</code> 对象（如一个JSP页面）使用模型数据进行渲染，生成最终的HTML响应体。</li>
<li>在视图渲染完成后，<code>DispatcherServlet</code> 会执行拦截器的 <code>afterCompletion</code> 方法（通常用于资源清理）。</li>
<li>最后，<code>DispatcherServlet</code> 将完整的HTTP响应返回给客户端浏览器。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-常用注解"><a href="#1-2-常用注解" class="headerlink" title="1.2 常用注解"></a>1.2 常用注解</h3><h4 id="1-2-1-类级别注解-Class-level-Annotations"><a href="#1-2-1-类级别注解-Class-level-Annotations" class="headerlink" title="1.2.1 类级别注解 (Class-level Annotations)"></a>1.2.1 类级别注解 (Class-level Annotations)</h4><p>这类注解通常用在Controller类上，用于声明该类的职责。</p>
<ul>
<li><p><strong><code>@Controller</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 这是最基础的Web控制器注解。它继承自 <code>@Component</code>，因此被 <code>@Controller</code> 标记的类会自动被组件扫描发现并注册为Spring Bean。</li>
<li><strong>职责</strong>: 表明这个类是一个<strong>传统的MVC控制器</strong>。它内部的方法通常会返回一个<strong>逻辑视图名</strong>（如<code>&quot;user/list&quot;</code>），然后由 <code>ViewResolver</code> 解析为具体的视图（如JSP或Thymeleaf模板）进行页面渲染。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/profile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserProfile</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userProfile&quot;</span>; <span class="comment">// 返回逻辑视图名，将被解析为 userProfile.html 或 .jsp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@RestController</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 一个<strong>复合注解</strong>，它由 <code>@Controller</code> 和 <code>@ResponseBody</code> 组合而成。</li>
<li><strong>职责</strong>: 专门用于构建 <strong>RESTful API</strong>。被 <code>@RestController</code> 标记的类，其内部所有被 <code>@RequestMapping</code> 系列注解标记的方法，都会<strong>自动应用 <code>@ResponseBody</code> 的效果</strong>。这意味着方法的返回值将直接被序列化（通常为JSON格式）并写入HTTP响应体中，而不是去解析视图。</li>
<li>这是现代前后端分离架构中的<strong>首选</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRestController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回User对象，Spring会通过Jackson自动将其序列化为JSON</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-2-请求映射注解-Request-Mapping-Annotations"><a href="#1-2-2-请求映射注解-Request-Mapping-Annotations" class="headerlink" title="1.2.2 请求映射注解 (Request Mapping Annotations)"></a>1.2.2 请求映射注解 (Request Mapping Annotations)</h4><p>这类注解用于将HTTP请求映射到具体的Controller处理方法上。</p>
<ul>
<li><p><strong><code>@RequestMapping</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 最通用、最基础的映射注解。它可以用于<strong>类级别</strong>和<strong>方法级别</strong>。<ul>
<li><strong>类级别</strong>: 为该控制器下的所有方法提供一个<strong>公共的URL前缀</strong>。</li>
<li><strong>方法级别</strong>: 定义处理具体请求的路径。</li>
</ul>
</li>
<li><strong>属性</strong>:<ul>
<li><code>value</code> 或 <code>path</code>: 指定请求的URL路径（支持Ant风格的通配符，如 <code>*</code>, <code>**</code>, <code>?</code>）。</li>
<li><code>method</code>: 指定HTTP请求方法，如 <code>RequestMethod.GET</code>, <code>RequestMethod.POST</code>。</li>
<li><code>params</code>: 要求请求中必须包含指定的参数，如 <code>params=&quot;myParam=myValue&quot;</code>。</li>
<li><code>headers</code>: 要求请求头必须包含指定的信息。</li>
<li><code>consumes</code>: 指定请求体的内容类型（Content-Type），如 <code>consumes=&quot;application/json&quot;</code>。</li>
<li><code>produces</code>: 指定响应体的内容类型，如 <code>produces=&quot;application/json&quot;</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v1/products&quot;)</span> <span class="comment">// 类级别映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;&quot;, method = RequestMethod.GET)</span> <span class="comment">// 方法级别映射</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getAllProducts</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.POST, consumes = &quot;application/json&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@RequestBody</span> Product product)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@RequestMapping</code> 的快捷注解 (Shortcut Annotations)</strong>:<br>为了简化开发，Spring提供了针对不同HTTP方法的专用快捷注解。它们在功能上与 <code>@RequestMapping(method = ...)</code> 等价，但代码更简洁、语义更清晰。</p>
<ul>
<li><strong><code>@GetMapping</code></strong>: 映射HTTP GET请求。</li>
<li><strong><code>@PostMapping</code></strong>: 映射HTTP POST请求。</li>
<li><strong><code>@PutMapping</code></strong>: 映射HTTP PUT请求。</li>
<li><strong><code>@DeleteMapping</code></strong>: 映射HTTP DELETE请求。</li>
<li><strong><code>@PatchMapping</code></strong>: 映射HTTP PATCH请求。</li>
</ul>
<p><strong>使用快捷注解重构上面的例子</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v1/products&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span> <span class="comment">// 更简洁</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getAllProducts</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span> <span class="comment">// consumes属性依然可以添加</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@RequestBody</span> Product product)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-3-RequestMapping-与-RestController-的关系总结"><a href="#1-2-3-RequestMapping-与-RestController-的关系总结" class="headerlink" title="1.2.3 @RequestMapping 与 @RestController 的关系总结"></a>1.2.3 <code>@RequestMapping</code> 与 <code>@RestController</code> 的关系总结</h4><table>
<thead>
<tr>
<th align="left">类注解</th>
<th align="left">方法注解</th>
<th align="left">返回值处理方式</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@Controller</code></td>
<td align="left"><code>@RequestMapping</code></td>
<td align="left"><strong>默认解析为视图</strong>。如果方法想返回数据，需要<strong>额外</strong>加<code>@ResponseBody</code>。</td>
<td align="left">传统的MVC，服务端渲染</td>
</tr>
<tr>
<td align="left"><code>@RestController</code></td>
<td align="left"><code>@GetMapping</code>等</td>
<td align="left"><strong>默认直接返回数据 (JSON&#x2F;XML)</strong>。所有方法隐式地应用了<code>@ResponseBody</code>。</td>
<td align="left"><strong>RESTful API</strong>，前后端分离</td>
</tr>
</tbody></table>
<p>在现代Web开发中，<code>@RestController</code> 及其配套的 <code>@GetMapping</code>, <code>@PostMapping</code> 等快捷注解，是构建后端API服务时最常用的组合。</p>
<hr>
<h3 id="1-3-请求参数处理"><a href="#1-3-请求参数处理" class="headerlink" title="1.3 请求参数处理"></a>1.3 请求参数处理</h3><h4 id="1-3-1-参数绑定"><a href="#1-3-1-参数绑定" class="headerlink" title="1.3.1 参数绑定"></a>1.3.1 参数绑定</h4><p>参数绑定（或称请求参数处理）是Spring MVC框架的一项强大功能。它的核心任务是将<strong>HTTP请求中的数据（如URL路径变量、查询参数、请求体等）自动地提取出来，进行必要的类型转换，并赋值给Controller处理方法的参数</strong>。这使得开发者可以像调用普通Java方法一样来编写Controller，而无需手动去解析底层的 <code>HttpServletRequest</code> 对象。</p>
<p>以下是用于参数绑定的最常用注解：</p>
<hr>
<h5 id="1-RequestParam-提取请求参数"><a href="#1-RequestParam-提取请求参数" class="headerlink" title="1. @RequestParam - 提取请求参数"></a>1. <code>@RequestParam</code> - 提取请求参数</h5><ul>
<li><p><strong>作用</strong>: 用于从<strong>查询字符串 (Query String)</strong> 或 <strong>POST表单数据 (<code>x-www-form-urlencoded</code>)</strong> 中提取参数。</p>
</li>
<li><p><strong>常见场景</strong>: <code>GET /users?name=alice&amp;age=30</code> 或 <code>POST /login</code> (表单提交)。</p>
</li>
<li><p><strong>核心属性</strong>:</p>
<ul>
<li><code>value</code> 或 <code>name</code>: 指定要绑定的请求参数的名称。如果方法参数名与请求参数名一致，此属性可以省略。</li>
<li><code>required</code>: 布尔值，表示该参数是否<strong>必需</strong>。默认为 <code>true</code>，如果请求中不包含该参数，会抛出异常。设为 <code>false</code> 则为可选参数。</li>
<li><code>defaultValue</code>: 字符串，提供一个<strong>默认值</strong>。当参数为可选 (<code>required=false</code>) 且请求中未提供该参数时，会使用此默认值。<strong>注意：<code>defaultValue</code> 隐含了 <code>required=false</code> 的效果</strong>。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUser</span><span class="params">(</span></span><br><span class="line"><span class="params">    // <span class="number">1.</span> 基本用法 (参数名与方法变量名一致)</span></span><br><span class="line">    String name,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指定请求参数名，并设为可选</span></span><br><span class="line">    <span class="meta">@RequestParam(name = &quot;user_age&quot;, required = false)</span> Integer age,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供默认值</span></span><br><span class="line">    <span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class="type">int</span> page,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 接收多个同名参数到一个List中</span></span><br><span class="line">    <span class="meta">@RequestParam(&quot;roles&quot;)</span> List&lt;String&gt; roles <span class="comment">// e.g., ?roles=admin&amp;roles=user</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不带注解的情况</strong>: 如果一个简单类型的参数（如 <code>String</code>, <code>int</code>）没有加任何注解，Spring MVC会<strong>默认</strong>把它当作 <code>@RequestParam</code> 来处理（且 <code>required=false</code>）。</p>
</li>
</ul>
<hr>
<h5 id="2-PathVariable-提取路径变量"><a href="#2-PathVariable-提取路径变量" class="headerlink" title="2. @PathVariable - 提取路径变量"></a>2. <code>@PathVariable</code> - 提取路径变量</h5><ul>
<li><p><strong>作用</strong>: 用于从<strong>URL路径</strong>中提取值。这在RESTful API设计中非常常见，用于表示对特定资源的访问。</p>
</li>
<li><p><strong>常见场景</strong>: <code>GET /users/123</code> 或 <code>DELETE /orders/order-abc</code>。</p>
</li>
<li><p><strong>URL模板</strong>: 路径中需要使用 <code>{}</code> 占位符来定义变量。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;userId&#125;/orders/&#123;orderId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">getOrderDetails</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 将URL中的 &#123;userId&#125; 绑定到 Long类型的 userId 参数</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable</span> Long userId,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    // 如果占位符名称与参数名不一致，需要显式指定</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;orderId&quot;)</span> String orderIdentifier</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// ... find order by userId and orderIdentifier</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-RequestBody-提取请求体"><a href="#3-RequestBody-提取请求体" class="headerlink" title="3. @RequestBody - 提取请求体"></a>3. <code>@RequestBody</code> - 提取请求体</h5><ul>
<li><p><strong>作用</strong>: 将<strong>整个HTTP请求体 (Request Body)</strong> 的内容读取出来，并通过 <code>HttpMessageConverter</code> (通常是 <code>Jackson2HttpMessageConverter</code>) 将其<strong>反序列化</strong>为一个Java对象（POJO）。</p>
</li>
<li><p><strong>核心要求</strong>: 一个Controller方法中，<strong>最多只能有一个</strong> <code>@RequestBody</code> 注解。</p>
</li>
<li><p><strong>常见场景</strong>: 接收 <code>POST</code>, <code>PUT</code>, <code>PATCH</code> 请求中发送的 <code>application/json</code> 或 <code>application/xml</code> 数据。</p>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li><p><strong>客户端发送的JSON</strong>:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pwd&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bob@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Controller方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users/register&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">registerUser</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 将请求体JSON反序列化为 UserDTO 对象</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestBody</span> UserDTO userDto</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// ... process userDto object</span></span><br><span class="line">    System.out.println(userDto.getUsername());</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;User registered successfully&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-RequestHeader-提取请求头"><a href="#4-RequestHeader-提取请求头" class="headerlink" title="4. @RequestHeader - 提取请求头"></a>4. <code>@RequestHeader</code> - 提取请求头</h5><ul>
<li><p><strong>作用</strong>: 用于读取HTTP请求头 (Header) 中的特定值。</p>
</li>
<li><p><strong>属性</strong>: 与 <code>@RequestParam</code> 类似，也支持 <code>name</code>, <code>required</code>, <code>defaultValue</code>。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 读取 <span class="string">&quot;User-Agent&quot;</span> 请求头</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    // 读取一个可选的 <span class="string">&quot;X-Custom-Header&quot;</span>，提供默认值</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(name = &quot;X-Custom-Header&quot;, defaultValue = &quot;default&quot;)</span> String customHeader,</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">    // 将所有请求头注入到一个Map中</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader</span> Map&lt;String, String&gt; allHeaders</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User-Agent: &quot;</span> + userAgent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-CookieValue-提取Cookie值"><a href="#5-CookieValue-提取Cookie值" class="headerlink" title="5. @CookieValue - 提取Cookie值"></a>5. <code>@CookieValue</code> - 提取Cookie值</h5><ul>
<li><p><strong>作用</strong>: 用于从HTTP请求的Cookie中读取特定<code>name</code>的值。</p>
</li>
<li><p><strong>属性</strong>: 与 <code>@RequestParam</code> 类似，也支持 <code>name</code>, <code>required</code>, <code>defaultValue</code>。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserProfile</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 读取名为 <span class="string">&quot;sessionId&quot;</span> 的cookie</span></span><br><span class="line"><span class="params">    <span class="meta">@CookieValue(&quot;sessionId&quot;)</span> String sessionId,</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">    // 读取一个可选的cookie</span></span><br><span class="line"><span class="params">    <span class="meta">@CookieValue(name = &quot;theme&quot;, required = false)</span> String theme</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// ... use sessionId to find user session</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Profile for session: &quot;</span> + sessionId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-无注解的POJO绑定-表单数据到对象"><a href="#6-无注解的POJO绑定-表单数据到对象" class="headerlink" title="6. 无注解的POJO绑定 - 表单数据到对象"></a>6. 无注解的POJO绑定 - 表单数据到对象</h5><ul>
<li><p><strong>作用</strong>: 当请求是 <code>GET</code> 的查询参数或 <code>POST</code> 的 <code>x-www-form-urlencoded</code> 表单数据时，Spring MVC可以<strong>自动</strong>将这些参数<strong>按名称匹配</strong>并绑定到一个POJO对象的字段上。</p>
</li>
<li><p><strong>要求</strong>: POJO类必须有<strong>无参构造函数</strong>和对应字段的<strong>setter方法</strong>。</p>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li><p><strong>请求</strong>: <code>POST /users/create</code>，请求体为 <code>username=carol&amp;email=carol@example.com</code></p>
</li>
<li><p><strong>POJO类 (<code>UserCreateForm.java</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCreateForm</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// Getters and Setters ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Controller方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users/create&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">(UserCreateForm form)</span> &#123; <span class="comment">// 无需任何注解</span></span><br><span class="line">    <span class="comment">// Spring会自动 new UserCreateForm(), 然后调用 setUsername(&quot;carol&quot;) 和 setEmail(&quot;carol@example.com&quot;)</span></span><br><span class="line">    System.out.println(form.getUsername());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User created&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-2-数据校验"><a href="#1-3-2-数据校验" class="headerlink" title="1.3.2 数据校验"></a>1.3.2 数据校验</h4><p>数据校验的目的是确保客户端发送到后端的数据符合预定义的规则。例如，用户名不能为空、邮箱必须符合格式、年龄必须是正整数等。如果在业务逻辑代码中手动进行大量的<code>if-else</code>判断来做校验，会使代码变得臃肿、重复且难以维护。</p>
<p>Spring MVC 深度集成了 <strong>Bean Validation (JSR-303 &#x2F; JSR-380)</strong> 规范，允许我们通过<strong>声明式注解</strong>的方式来定义校验规则，并通过框架自动执行校验。</p>
<p><strong>Hibernate Validator</strong> 是 Bean Validation 规范最流行、也是Spring Boot默认集成的实现库。</p>
<h5 id="1-核心依赖"><a href="#1-核心依赖" class="headerlink" title="1. 核心依赖"></a>1. 核心依赖</h5><p>要使用数据校验功能，首先需要确保项目中包含了 <code>spring-boot-starter-validation</code> 依赖。通常情况下，如果你引入了 <code>spring-boot-starter-web</code>，这个校验依赖已经<strong>被传递性地包含</strong>进来了，无需额外添加。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-如何使用"><a href="#2-如何使用" class="headerlink" title="2. 如何使用"></a>2. 如何使用</h5><p>数据校验的使用通常分为两步：</p>
<ol>
<li><strong>在DTO&#x2F;VO上添加校验注解</strong>：在需要被校验的Java Bean（通常是用于接收请求体的DTO - Data Transfer Object）的字段上，添加JSR-303&#x2F;380规范定义的校验注解。</li>
<li><strong>在Controller方法上开启校验</strong>：在Controller方法的对应参数上，添加 <code>@Valid</code> 或 <code>@Validated</code> 注解，来触发对该对象的校验。</li>
</ol>
<h6 id="a-在DTO上添加校验注解"><a href="#a-在DTO上添加校验注解" class="headerlink" title="a. 在DTO上添加校验注解"></a>a. 在DTO上添加校验注解</h6><p>我们创建一个 <code>UserRegisterDTO</code> 来接收用户注册的请求数据，并为其添加校验规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterDTO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 4, max = 20, message = &quot;用户名长度必须在4到20个字符之间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[\\s\\S]&#123;8,16&#125;$&quot;, </span></span><br><span class="line"><span class="meta">             message = &quot;密码必须8-16位，且包含大小写字母和数字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;年龄不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 18, message = &quot;年龄必须大于等于18岁&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 100, message = &quot;年龄不能超过100岁&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;邮箱不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 嵌套对象校验</span></span><br><span class="line">    <span class="meta">@Valid</span> <span class="comment">// 必须加上@Valid，才会对嵌套对象进行校验</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">        <span class="meta">@NotBlank</span></span><br><span class="line">        <span class="keyword">private</span> String street;</span><br><span class="line">        <span class="meta">@NotBlank</span></span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用的校验注解 (位于 <code>javax.validation.constraints</code> 包下)</strong>:</p>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@NotNull</code></strong></td>
<td align="left">验证对象不能为 <code>null</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>@NotBlank</code></strong></td>
<td align="left">验证字符串<strong>不能为 <code>null</code> 且去除首尾空格后长度必须大于0</strong>。 (专用于字符串)</td>
</tr>
<tr>
<td align="left"><strong><code>@NotEmpty</code></strong></td>
<td align="left">验证对象<strong>不能为 <code>null</code> 且大小&#x2F;长度必须大于0</strong>。 (可用于String, Collection, Map, Array)</td>
</tr>
<tr>
<td align="left"><strong><code>@Size(min, max)</code></strong></td>
<td align="left">验证对象（String, Collection, Map, Array）的大小&#x2F;长度是否在指定范围内。</td>
</tr>
<tr>
<td align="left"><strong><code>@Min(value)</code></strong></td>
<td align="left">验证数字是否大于等于指定值。</td>
</tr>
<tr>
<td align="left"><strong><code>@Max(value)</code></strong></td>
<td align="left">验证数字是否小于等于指定值。</td>
</tr>
<tr>
<td align="left"><strong><code>@Email</code></strong></td>
<td align="left">验证字符串是否为合法的Email格式。</td>
</tr>
<tr>
<td align="left"><strong><code>@Pattern(regexp)</code></strong></td>
<td align="left">验证字符串是否匹配指定的正则表达式。</td>
</tr>
<tr>
<td align="left"><strong><code>@Past</code> &#x2F; <code>@Future</code></strong></td>
<td align="left">验证日期是否为过去或将来的日期。</td>
</tr>
<tr>
<td align="left"><strong><code>@Valid</code></strong></td>
<td align="left"><strong>用于嵌套对象</strong>。标记在一个字段上，表示需要<strong>级联校验</strong>这个字段所引用的对象的内部规则。</td>
</tr>
</tbody></table>
<hr>
<h6 id="b-在Controller方法上开启校验"><a href="#b-在Controller方法上开启校验" class="headerlink" title="b. 在Controller方法上开启校验"></a>b. 在Controller方法上开启校验</h6><p>在Controller方法中，我们在需要校验的参数（通常是被 <code>@RequestBody</code> 标记的对象）前面加上 <code>@Valid</code> 或 <code>@Validated</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">registerUser</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserRegisterDTO userDto,</span></span><br><span class="line"><span class="params">        BindingResult bindingResult // 紧跟在校验对象后面，用于接收校验结果</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="comment">// 方式一：手动处理校验结果 (灵活)</span></span><br><span class="line">        <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">            <span class="comment">// 获取第一个错误信息并返回</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">firstError</span> <span class="operator">=</span> bindingResult.getAllErrors().get(<span class="number">0</span>).getDefaultMessage();</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.badRequest().body(firstError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果校验通过，则执行业务逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;User registered successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>BindingResult</code> 对象</strong>:</p>
<ul>
<li>这是一个<strong>可选的</strong>参数，它必须<strong>紧跟在</strong>被校验的参数后面。</li>
<li>它的作用是<strong>捕获</strong>校验过程中产生的所有错误信息。</li>
<li>如果Controller方法中包含了 <code>BindingResult</code> 参数，当校验失败时，<strong>Spring MVC不会立即抛出异常</strong>，而是将错误信息填充到 <code>BindingResult</code> 中，然后继续执行方法体。这给了我们<strong>手动处理和定制错误响应</strong>的机会。</li>
<li>如果<strong>没有</strong> <code>BindingResult</code> 参数，一旦校验失败，Spring MVC会立即抛出 <code>MethodArgumentNotValidException</code> 异常，请求流程中断。</li>
</ul>
<hr>
<h5 id="3-全局异常处理校验失败"><a href="#3-全局异常处理校验失败" class="headerlink" title="3. 全局异常处理校验失败"></a>3. 全局异常处理校验失败</h5><p>手动在每个Controller方法中检查 <code>BindingResult</code> 是一种重复劳动。更好的实践是使用全局异常处理器（<code>@RestControllerAdvice</code>）来统一捕获 <code>MethodArgumentNotValidException</code> 并返回一个结构化的错误响应，在1.5.1 全局异常处理中会有详细说明。</p>
<hr>
<h5 id="4-Valid-vs-Validated"><a href="#4-Valid-vs-Validated" class="headerlink" title="4. @Valid vs @Validated"></a>4. <code>@Valid</code> vs <code>@Validated</code></h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Valid</code> (JSR-303标准)</th>
<th align="left"><code>@Validated</code> (Spring特有)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>来源</strong></td>
<td align="left"><code>javax.validation</code></td>
<td align="left"><code>org.springframework.validation.annotation</code></td>
</tr>
<tr>
<td align="left"><strong>功能</strong></td>
<td align="left">标准的校验功能</td>
<td align="left">继承了<code>@Valid</code>的所有功能，并提供了<strong>分组校验</strong>的能力。</td>
</tr>
<tr>
<td align="left"><strong>使用位置</strong></td>
<td align="left">方法参数、字段、构造函数参数</td>
<td align="left">方法参数、字段、构造函数参数、<strong>类、方法</strong></td>
</tr>
<tr>
<td align="left"><strong>分组校验</strong></td>
<td align="left">不支持</td>
<td align="left"><strong>支持</strong>。允许定义不同的校验组，在不同场景下应用不同的校验规则。</td>
</tr>
</tbody></table>
<p><strong>分组校验示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义分组接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnCreate</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnUpdate</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在DTO中使用groups属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(groups = OnUpdate.class)</span> <span class="comment">// id在更新时不能为空</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(groups = &#123;OnCreate.class, OnUpdate.class&#125;)</span> <span class="comment">// username在创建和更新时都不能为空</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在Controller中指定要校验的分组</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(<span class="meta">@Validated(OnCreate.class)</span> <span class="meta">@RequestBody</span> UserDTO user)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(<span class="meta">@Validated(OnUpdate.class)</span> <span class="meta">@RequestBody</span> UserDTO user)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：在简单的校验场景中，<code>@Valid</code> 和 <code>@Validated</code> 可以互换。当你需要更高级的分组校验功能时，必须使用 <code>@Validated</code>。在Spring环境中，使用 <code>@Validated</code> 通常是更好的选择。</p>
<hr>
<h3 id="1-4-响应处理"><a href="#1-4-响应处理" class="headerlink" title="1.4 响应处理"></a>1.4 响应处理</h3><h4 id="1-4-1-ResponseEntity"><a href="#1-4-1-ResponseEntity" class="headerlink" title="1.4.1 ResponseEntity"></a>1.4.1 <code>ResponseEntity</code></h4><h5 id="1-什么是-ResponseEntity？"><a href="#1-什么是-ResponseEntity？" class="headerlink" title="1. 什么是 ResponseEntity？"></a>1. 什么是 <code>ResponseEntity</code>？</h5><p><code>ResponseEntity</code> 是 Spring 提供的一个泛型类，它代表了<strong>整个 HTTP 响应</strong>。通过使用它，你可以完全控制响应的<strong>状态码 (Status Code)</strong>、<strong>响应头 (Headers)</strong> 和<strong>响应体 (Body)</strong>。</p>
<p>在简单的场景中，<code>@RestController</code> 的方法可以直接返回一个POJO（如 <code>User</code> 对象），Spring 会默认：</p>
<ul>
<li><strong>状态码</strong>: <code>200 OK</code></li>
<li><strong>响应头</strong>: <code>Content-Type: application/json</code> (通常)</li>
<li><strong>响应体</strong>: POJO 序列化后的 JSON 字符串</li>
</ul>
<p>但是，现实世界的 API 需要更丰富的表达能力。例如：</p>
<ul>
<li>成功创建资源后，应该返回 <code>201 Created</code> 状态码，并在 <code>Location</code> 头中提供新资源的URL。</li>
<li>请求的资源不存在时，应该返回 <code>404 Not Found</code> 状态码，并且响应体可能为空。</li>
<li>请求处理成功但无需返回内容时（如删除操作），应该返回 <code>204 No Content</code> 状态码。</li>
<li>需要添加自定义的响应头，如缓存控制（<code>Cache-Control</code>）或认证令牌。</li>
</ul>
<p><strong><code>ResponseEntity</code> 就是为了满足这些精细化控制需求而生的。</strong></p>
<hr>
<h5 id="2-ResponseEntity-的组成"><a href="#2-ResponseEntity-的组成" class="headerlink" title="2. ResponseEntity 的组成"></a>2. <code>ResponseEntity</code> 的组成</h5><p><code>ResponseEntity&lt;T&gt;</code> 包含了三个核心部分：</p>
<ol>
<li><strong><code>T body</code></strong>: 响应体。泛型 <code>T</code> 代表了响应体的数据类型，可以是任何Java对象（POJO、List、Map等），也可以是 <code>Void</code>（表示没有响应体）。</li>
<li><strong><code>HttpStatus status</code></strong>: HTTP 状态码。这是一个枚举类，包含了所有标准的HTTP状态码，如 <code>HttpStatus.OK</code>, <code>HttpStatus.CREATED</code>, <code>HttpStatus.NOT_FOUND</code> 等。</li>
<li><strong><code>HttpHeaders headers</code></strong>: HTTP 响应头。一个可以方便地添加和设置各种响应头的对象。</li>
</ol>
<hr>
<h5 id="3-如何创建和使用-ResponseEntity"><a href="#3-如何创建和使用-ResponseEntity" class="headerlink" title="3. 如何创建和使用 ResponseEntity"></a>3. 如何创建和使用 <code>ResponseEntity</code></h5><p>Spring 提供了非常便利的<strong>静态工厂方法</strong>和<strong>链式构建器 (Builder)</strong> 来创建 <code>ResponseEntity</code> 实例。</p>
<h6 id="a-使用静态工厂方法-最常用"><a href="#a-使用静态工厂方法-最常用" class="headerlink" title="a. 使用静态工厂方法 (最常用)"></a>a. 使用静态工厂方法 (最常用)</h6><p>这些方法通常以状态码命名，非常直观。</p>
<ul>
<li><p><strong>返回 200 OK</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findById(id);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ResponseEntity.ok() 创建一个状态码为 200 的响应</span></span><br><span class="line">        <span class="comment">// .body(user) 可以省略，直接 ResponseEntity.ok(user)</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(user); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回 404 Not Found</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...接上例</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ResponseEntity.notFound() 创建一个状态码为 404 的响应</span></span><br><span class="line">    <span class="comment">// .build() 用于构建一个没有响应体的 ResponseEntity</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.notFound().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回 201 Created (创建资源)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User newUser)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">savedUser</span> <span class="operator">=</span> userService.save(newUser);</span><br><span class="line">    <span class="comment">// 构建新资源的URI，用于放入Location头</span></span><br><span class="line">    <span class="type">URI</span> <span class="variable">location</span> <span class="operator">=</span> ServletUriComponentsBuilder.fromCurrentRequest()</span><br><span class="line">            .path(<span class="string">&quot;/&#123;id&#125;&quot;</span>)</span><br><span class="line">            .buildAndExpand(savedUser.getId())</span><br><span class="line">            .toUri();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ResponseEntity.created(uri) 创建一个 201 状态码的响应，并自动设置 Location 头</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.created(location).body(savedUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回 204 No Content (无内容)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    userService.deleteById(id);</span><br><span class="line">    <span class="comment">// ResponseEntity.noContent() 创建一个 204 状态码的响应</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回 400 Bad Request (错误请求)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserDTO userDto)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 假设某些业务逻辑校验失败</span></span><br><span class="line">    <span class="keyword">if</span> (userService.isUsernameTaken(userDto.getUsername())) &#123;</span><br><span class="line">         <span class="comment">// ResponseEntity.badRequest() 创建一个 400 状态码的响应</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest().body(<span class="string">&quot;Username is already taken.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="b-使用链式构建器-更灵活"><a href="#b-使用链式构建器-更灵活" class="headerlink" title="b. 使用链式构建器 (更灵活)"></a>b. 使用链式构建器 (更灵活)</h6><p>如果你需要设置更复杂的状态码或自定义响应头，可以使用构建器模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/custom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">customResponse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.ACCEPTED) <span class="comment">// 设置状态码为 202 Accepted</span></span><br><span class="line">            .header(<span class="string">&quot;X-Custom-Header&quot;</span>, <span class="string">&quot;MyCustomValue&quot;</span>) <span class="comment">// 添加自定义响应头</span></span><br><span class="line">            .header(HttpHeaders.CACHE_CONTROL, <span class="string">&quot;max-age=3600&quot;</span>) <span class="comment">// 添加标准的响应头</span></span><br><span class="line">            .body(<span class="string">&quot;This is a custom response body.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-ResponseEntity-的核心优势"><a href="#4-ResponseEntity-的核心优势" class="headerlink" title="4. ResponseEntity 的核心优势"></a>4. <code>ResponseEntity</code> 的核心优势</h5><ol>
<li><strong>完全的HTTP响应控制</strong>: 让你能够精确控制状态码、响应头和响应体，是实现真正RESTful API的基石。</li>
<li><strong>代码可读性强</strong>: <code>ResponseEntity.ok()</code>, <code>ResponseEntity.notFound()</code> 等方法让代码的意图一目了然，明确表达了API的返回契约。</li>
<li><strong>灵活性</strong>: 无论是简单的成功响应，还是复杂的带自定义头的错误响应，<code>ResponseEntity</code> 都能优雅地处理。</li>
<li><strong>遵循RESTful最佳实践</strong>: 正确使用HTTP状态码是RESTful设计的重要原则。<code>ResponseEntity</code> 鼓励并简化了这一实践。</li>
</ol>
<p><strong>总结</strong></p>
<p>在现代基于Spring的REST API开发中，<strong>将Controller方法的返回类型声明为 <code>ResponseEntity&lt;T&gt;</code> 是一种最佳实践</strong>。它将HTTP协议的细节以一种优雅、类型安全的方式暴露给开发者，使得我们能够构建出更专业、更健壮、更符合Web标准的应用程序接口。</p>
<hr>
<h4 id="1-4-2-JSON序列化"><a href="#1-4-2-JSON序列化" class="headerlink" title="1.4.2 JSON序列化"></a>1.4.2 <code>JSON序列化</code></h4><h5 id="1-什么是序列化与反序列化？"><a href="#1-什么是序列化与反序列化？" class="headerlink" title="1. 什么是序列化与反序列化？"></a>1. 什么是序列化与反序列化？</h5><p>在Web API的上下文中：</p>
<ul>
<li><strong>序列化 (Serialization)</strong>:<ul>
<li><strong>过程</strong>: 将服务端的 <strong>Java 对象</strong>（如 <code>User</code>、<code>List&lt;Product&gt;</code>）转换为一种可以在网络上传输的、标准化的<strong>文本格式</strong>（通常是 <strong>JSON</strong> 字符串）的过程。</li>
<li><strong>方向</strong>: <code>Java Object -&gt; JSON String</code></li>
<li><strong>何时发生</strong>: 当 <code>@RestController</code> 的方法返回一个Java对象时，Spring MVC会在将响应写入HTTP响应体之前，自动对其进行序列化。</li>
</ul>
</li>
<li><strong>反序列化 (Deserialization)</strong>:<ul>
<li><strong>过程</strong>: 将从客户端HTTP请求体中接收到的 <strong>JSON 字符串</strong>，转换为服务端能够理解和处理的 <strong>Java 对象</strong>的过程。</li>
<li><strong>方向</strong>: <code>JSON String -&gt; Java Object</code></li>
<li><strong>何时发生</strong>: 当Controller方法的参数被 <code>@RequestBody</code> 注解标记时，Spring MVC会自动读取请求体中的JSON数据，并将其反序列化为指定的Java对象。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-Spring-Boot-与-Jackson-的无缝集成"><a href="#2-Spring-Boot-与-Jackson-的无缝集成" class="headerlink" title="2. Spring Boot 与 Jackson 的无缝集成"></a>2. Spring Boot 与 Jackson 的无缝集成</h5><p>Spring Boot 默认选择 <strong>Jackson</strong> (<code>jackson-databind</code> 库)作为其首选的JSON处理库。当你引入 <code>spring-boot-starter-web</code> 或 <code>spring-boot-starter-webflux</code> 时，Jackson 相关的依赖已经被自动包含进来了。</p>
<p>Spring Boot 的自动配置机制会为你完成所有繁琐的整合工作：</p>
<ol>
<li><strong>自动配置 <code>ObjectMapper</code></strong>:<ul>
<li><code>ObjectMapper</code> 是 Jackson 库中进行序列化和反序列化的核心类。</li>
<li>Spring Boot 会自动创建一个预配置好的 <code>ObjectMapper</code> Bean，并将其注册到IoC容器中。这个默认的 <code>ObjectMapper</code> 已经配置了许多最佳实践，比如：<ul>
<li>忽略JSON中未知属性（避免因客户端多传了字段而导致反序列化失败）。</li>
<li>正确处理Java 8的日期时间类型（<code>LocalDate</code>, <code>LocalDateTime</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>自动注册 <code>MappingJackson2HttpMessageConverter</code></strong>:<ul>
<li>这是一个 <code>HttpMessageConverter</code> 的实现，它专门使用 <code>ObjectMapper</code> 来处理 <code>application/json</code> 类型的HTTP请求和响应。</li>
<li>正是这个转换器，在背后默默地为你完成了所有的序列化和反序列化工作。</li>
</ul>
</li>
</ol>
<p><strong>整个过程对开发者是完全透明的</strong>。你只需要在Controller中返回或接收Java对象，Spring Boot和Jackson会处理好剩下的一切。</p>
<hr>
<h5 id="3-Jackson-常用注解"><a href="#3-Jackson-常用注解" class="headerlink" title="3. Jackson 常用注解"></a>3. Jackson 常用注解</h5><p>尽管默认配置已经很好用，但在很多场景下，我们需要对JSON的转换过程进行更精细的控制。Jackson提供了一系列强大的注解来实现这一点。这些注解通常加在<strong>POJO类的字段或getter&#x2F;setter方法</strong>上。</p>
<h6 id="a-控制字段的包含与排除"><a href="#a-控制字段的包含与排除" class="headerlink" title="a. 控制字段的包含与排除"></a>a. 控制字段的包含与排除</h6><ul>
<li><p><strong><code>@JsonIgnore</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 在序列化和反序列化时，<strong>完全忽略</strong>被此注解标记的字段。</li>
<li><strong>场景</strong>: 常用于忽略敏感信息（如密码）或内部状态字段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 这个字段永远不会出现在JSON中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@JsonInclude(JsonInclude.Include.NON_NULL)</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 在序列化时，<strong>只包含那些值不为 <code>null</code> 的字段</strong>。</li>
<li><strong>场景</strong>: 节省网络带宽，使JSON响应更紧凑。可以标记在类上，对所有字段生效；也可以标记在单个字段上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description; <span class="comment">// 如果description为null，则JSON中不会有这个key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(其他选项如 <code>NON_EMPTY</code>, <code>NON_DEFAULT</code> 也很有用)</p>
</li>
<li><p><strong><code>@JsonIgnoreProperties({&quot;prop1&quot;, &quot;prop2&quot;})</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 在类级别使用，指定一个<strong>要忽略的字段列表</strong>。</li>
<li><strong>场景</strong>: 当你无法修改源码（如第三方库的类）但又想忽略其某些字段时，可以通过Mixin技术配合使用。也常用于解决双向引用导致的无限递归问题。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="b-控制字段的名称"><a href="#b-控制字段的名称" class="headerlink" title="b. 控制字段的名称"></a>b. 控制字段的名称</h6><ul>
<li><p><strong><code>@JsonProperty(&quot;custom_name&quot;)</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 为Java字段指定一个<strong>自定义的JSON属性名</strong>。</li>
<li><strong>场景</strong>: 当Java的命名规范（camelCase，如 <code>firstName</code>）与前端或API契约要求的命名规范（snake_case，如 <code>first_name</code>）不一致时。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@JsonProperty(&quot;first_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化结果: &#123;&quot;first_name&quot;: &quot;...&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="c-控制日期和时间的格式"><a href="#c-控制日期和时间的格式" class="headerlink" title="c. 控制日期和时间的格式"></a>c. 控制日期和时间的格式</h6><ul>
<li><p><strong><code>@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 精确控制 <code>Date</code>, <code>Calendar</code>, <code>LocalDateTime</code> 等日期时间类型在JSON中的格式。</li>
<li><strong>场景</strong>: 统一API的日期时间格式，避免因默认格式（如时间戳或ISO-8601）不满足需求而产生的问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化结果: &#123;&quot;createTime&quot;: &quot;2023-10-27 15:30:00&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="d-控制枚举-Enum-的序列化"><a href="#d-控制枚举-Enum-的序列化" class="headerlink" title="d. 控制枚举 (Enum) 的序列化"></a>d. 控制枚举 (Enum) 的序列化</h6><ul>
<li><p><strong><code>@JsonValue</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 指定使用枚举中的<strong>哪个方法或字段的返回值</strong>作为其JSON表示。</li>
<li><strong>场景</strong>: 默认枚举序列化为它的名字（<code>&quot;PENDING&quot;</code>），如果你想序列化为它的某个属性（如一个整数代码 <code>1</code>）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    PENDING(<span class="number">1</span>, <span class="string">&quot;待处理&quot;</span>),</span><br><span class="line">    PROCESSING(<span class="number">2</span>, <span class="string">&quot;处理中&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 构造函数 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonValue</span> <span class="comment">// 指定使用getCode()的返回值进行序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化结果: 1 (而不是 &quot;PENDING&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-全局定制-ObjectMapper"><a href="#4-全局定制-ObjectMapper" class="headerlink" title="4. 全局定制 ObjectMapper"></a>4. 全局定制 <code>ObjectMapper</code></h5><p>如果你想对所有JSON序列化&#x2F;反序列化行为进行统一的、全局的配置（例如，所有日期都按特定格式，所有<code>null</code>值都不序列化），而不是在每个POJO上都加注解，你可以通过自定义 <code>ObjectMapper</code> Bean 来实现。</p>
<p>在Spring Boot中，最推荐的方式是定义一个 <code>Jackson2ObjectMapperBuilderCustomizer</code> Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializationFeature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="title function_">jsonCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder -&gt; &#123;</span><br><span class="line">            <span class="comment">// 全局设置：序列化时，所有为null的字段都不参与</span></span><br><span class="line">            builder.serializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 全局设置：美化输出（开发时有用，生产环境建议关闭以节省带宽）</span></span><br><span class="line">            builder.featuresToEnable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 全局设置：禁用将日期序列化为时间戳的行为</span></span><br><span class="line">            builder.featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 全局设置：所有Date类型的日期格式</span></span><br><span class="line">            builder.dateFormat(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，你可以在不侵入业务POJO的情况下，实现对JSON行为的全局统一控制。</p>
<p><strong>总结</strong></p>
<p>JSON序列化是现代Web API的“通用语言”。Spring Boot通过与Jackson的深度集成，提供了“零配置”的开箱即用体验。同时，通过丰富的注解和灵活的全局配置，Jackson也赋予了开发者完全掌控JSON数据格式的能力，以满足各种复杂的业务需求。</p>
<hr>
<h3 id="1-5-Web层通用功能"><a href="#1-5-Web层通用功能" class="headerlink" title="1.5 Web层通用功能"></a>1.5 Web层通用功能</h3><h4 id="1-5-1-全局异常处理"><a href="#1-5-1-全局异常处理" class="headerlink" title="1.5.1 全局异常处理"></a>1.5.1 全局异常处理</h4><h5 id="1-为什么需要全局异常处理？"><a href="#1-为什么需要全局异常处理？" class="headerlink" title="1. 为什么需要全局异常处理？"></a>1. 为什么需要全局异常处理？</h5><p>在Web应用开发中，异常是不可避免的。例如：</p>
<ul>
<li><strong>业务异常</strong>: 用户名已存在、余额不足、订单不存在等。</li>
<li><strong>参数校验异常</strong>: 客户端传入的参数不符合格式 (<code>MethodArgumentNotValidException</code>)。</li>
<li><strong>认证&#x2F;授权异常</strong>: 用户未登录、权限不足 (<code>AccessDeniedException</code>)。</li>
<li><strong>系统异常</strong>: 空指针 (<code>NullPointerException</code>)、数据库连接失败等。</li>
</ul>
<p>如果不对这些异常进行处理，Spring Boot的默认行为通常是向客户端返回一个包含大量堆栈信息的、不友好的HTML错误页面（或JSON错误对象）。</p>
<p><strong>默认的错误响应示例</strong>:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-10-27T08:30:00.123+00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;trace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.NullPointerException: ... (长长的堆栈信息) ...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/api/users/123&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>这种默认响应的问题</strong>:</p>
<ol>
<li><strong>用户体验差</strong>: 暴露了技术细节，用户看不懂也无法处理。</li>
<li><strong>安全风险</strong>: 堆栈信息可能会泄露服务器的内部实现、库版本等敏感信息。</li>
<li><strong>格式不统一</strong>: 不同的异常可能导致不同格式的响应，不利于前端统一处理。</li>
</ol>
<p><strong>全局异常处理的目标</strong>：创建一个<strong>统一的、集中的机制</strong>来捕获应用程序中抛出的各种异常，并根据异常的类型，返回<strong>结构化的、对客户端友好的、统一格式的错误响应</strong>。</p>
<hr>
<h5 id="2-核心注解"><a href="#2-核心注解" class="headerlink" title="2. 核心注解"></a>2. 核心注解</h5><p>Spring MVC提供了两个核心注解来实现全局异常处理：</p>
<ul>
<li><strong><code>@ControllerAdvice</code></strong> (或其变体 <code>@RestControllerAdvice</code>)<ul>
<li><strong>作用</strong>: 这是一个<strong>组件注解</strong>，用于标记一个类。被标记的类会成为一个<strong>全局的增强控制器</strong>。</li>
<li><strong>职责</strong>: 它可以**“横切”**到所有的（或指定的）<code>@Controller</code> 或 <code>@RestController</code> 上，用于集中处理那些原本需要在多个Controller中重复编写的逻辑，最典型的就是异常处理和全局数据绑定。</li>
<li><strong><code>@RestControllerAdvice</code></strong>: 是 <code>@ControllerAdvice</code> 和 <code>@ResponseBody</code> 的组合。它表示这个类中的所有 <code>@ExceptionHandler</code> 方法的返回值都将直接序列化为JSON并写入响应体，这在构建RESTful API时是首选。</li>
</ul>
</li>
<li><strong><code>@ExceptionHandler</code></strong><ul>
<li><strong>作用</strong>: 用于标记一个<strong>方法</strong>，这个方法必须定义在 <code>@ControllerAdvice</code> 类中（或单个 <code>@Controller</code> 类中）。</li>
<li><strong>职责</strong>: 声明这个方法是用来<strong>处理特定类型的异常</strong>的。你可以在注解的 <code>value</code> 属性中指定它能处理的一个或多个异常类。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-实现一个全局异常处理器"><a href="#3-实现一个全局异常处理器" class="headerlink" title="3. 实现一个全局异常处理器"></a>3. 实现一个全局异常处理器</h5><p>下面是一个典型的全局异常处理器的实现步骤和示例：</p>
<p><strong>Step 1: 创建一个全局异常处理类</strong></p>
<p>创建一个类，并使用 <code>@RestControllerAdvice</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @RestControllerAdvice 会自动扫描所有被@RestController或@Controller标记的类</span></span><br><span class="line"><span class="comment">// 也可以指定扫描范围，如 @RestControllerAdvice(basePackages = &quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">// ... 在这里定义异常处理方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 编写针对不同异常的处理方法</strong></p>
<p>在类中，为不同类型的异常编写相应的处理方法，并使用 <code>@ExceptionHandler</code> 标记。</p>
<p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理自定义的业务异常 (例如，资源未找到)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span> <span class="comment">// 直接指定HTTP状态码</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="number">404</span>, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理参数校验异常 (<span class="doctag">@Valid</span>)</span></span><br><span class="line"><span class="comment">     * 这是最常用的异常处理之一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, String&gt;&gt; <span class="title function_">handleValidationExceptions</span><span class="params">(MethodArgumentNotValidException ex)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; errors = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        ex.getBindingResult().getFieldErrors().forEach(error -&gt; </span><br><span class="line">            errors.put(error.getField(), error.getDefaultMessage())</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(errors, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理其他所有未被捕获的系统级异常 (兜底方案)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleGlobalException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        <span class="comment">// 在实际项目中，这里应该记录详细的错误日志</span></span><br><span class="line">        <span class="comment">// log.error(&quot;Unhandled exception occurred&quot;, ex); </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向客户端返回一个通用的、模糊的错误信息，隐藏内部细节</span></span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="number">500</span>, <span class="string">&quot;Internal Server Error. Please contact support.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的错误响应体结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ErrorResponse</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">        <span class="keyword">private</span> String message;</span><br><span class="line">        <span class="comment">// constructor, getters, setters</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义的业务异常类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ResourceNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ResourceNotFoundException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-工作流程"><a href="#4-工作流程" class="headerlink" title="4. 工作流程"></a>4. 工作流程</h5><ol>
<li>当任何一个 <code>@Controller</code> 的方法在执行过程中抛出一个<strong>未被<code>try-catch</code>捕获</strong>的异常时，该异常会被Spring MVC的 <code>DispatcherServlet</code> 捕获。</li>
<li><code>DispatcherServlet</code> 会查找所有已注册的 <code>@ControllerAdvice</code> Bean。</li>
<li>它会遍历这些Advice类中的所有 <code>@ExceptionHandler</code> 方法，寻找一个<strong>最匹配</strong>当前抛出异常类型的处理方法。<ul>
<li><strong>匹配规则</strong>: 优先选择最精确匹配的异常类型。例如，如果抛出的是 <code>ResourceNotFoundException</code>，它会优先匹配 <code>handleResourceNotFoundException</code>，而不是更通用的 <code>handleGlobalException</code>。</li>
</ul>
</li>
<li>一旦找到匹配的处理方法，Spring MVC就会调用该方法。</li>
<li>该方法的返回值（通常是一个 <code>ResponseEntity</code> 或被 <code>@ResponseStatus</code> 标记的对象）会被用来构建最终的HTTP响应，返回给客户端。</li>
</ol>
<hr>
<h5 id="5-优势总结"><a href="#5-优势总结" class="headerlink" title="5. 优势总结"></a>5. 优势总结</h5><ol>
<li><strong>代码解耦和集中化</strong>: 将异常处理逻辑从业务代码（Controller）中完全分离出来，避免了在每个Controller方法中都写<code>try-catch</code>块，使得业务代码更纯粹、更专注于其核心职责。</li>
<li><strong>统一的错误响应格式</strong>: 确保了无论发生何种错误，API返回给客户端的错误信息都遵循统一的、预先定义好的结构，极大地简化了前端的处理逻辑。</li>
<li><strong>提升安全性</strong>: 避免了直接暴露系统内部的堆栈信息，只向外部提供有意义的、安全的错误提示。</li>
<li><strong>可维护性高</strong>: 当需要修改错误处理逻辑或错误响应格式时，只需修改全局异常处理器这一个地方即可。</li>
</ol>
<p><strong>最佳实践</strong>: 在任何生产级的Spring Boot项目中，都应该实现一个健壮的 <code>GlobalExceptionHandler</code>，它至少应该能处理：</p>
<ul>
<li><strong>参数校验异常</strong> (<code>MethodArgumentNotValidException</code>)</li>
<li><strong>自定义的业务异常</strong> (继承自 <code>RuntimeException</code>)</li>
<li><strong>一个通用的 <code>Exception</code> 兜底处理器</strong></li>
</ul>
<hr>
<h4 id="1-5-2-过滤器-Filter-vs-拦截器-Interceptor"><a href="#1-5-2-过滤器-Filter-vs-拦截器-Interceptor" class="headerlink" title="1.5.2 过滤器 (Filter) vs 拦截器 (Interceptor)"></a>1.5.2 过滤器 (Filter) vs 拦截器 (Interceptor)</h4><h5 id="1-过滤器-Filter"><a href="#1-过滤器-Filter" class="headerlink" title="1. 过滤器 (Filter)"></a><strong>1. 过滤器 (Filter)</strong></h5><h6 id="a-核心定义与归属"><a href="#a-核心定义与归属" class="headerlink" title="a. 核心定义与归属"></a><strong>a. 核心定义与归属</strong></h6><ul>
<li><strong>归属</strong>: <strong>Servlet规范</strong> 的一部分，定义在 <code>javax.servlet.Filter</code> 接口中。</li>
<li><strong>定位</strong>: 它是Java Web技术栈中的一个<strong>底层</strong>组件，不依赖于任何特定的Web框架（如Spring MVC）。理论上，任何实现了Servlet规范的Web容器（如Tomcat, Jetty）都支持Filter。</li>
<li><strong>工作层面</strong>: 工作在 <strong>Servlet容器层面</strong>，在请求进入 <code>DispatcherServlet</code> <strong>之前</strong>，以及响应从 <code>DispatcherServlet</code> 返回 <strong>之后</strong>被调用。</li>
</ul>
<h6 id="b-工作流程"><a href="#b-工作流程" class="headerlink" title="b. 工作流程"></a><strong>b. 工作流程</strong></h6><p>Filter构成了一个<strong>责任链 (Chain of Responsibility)</strong>。一个请求在到达目标Servlet（在Spring MVC中就是<code>DispatcherServlet</code>）之前，会依次穿过这个链上的所有Filter。</p>
<p><strong>请求流程</strong>:</p>
<p><code>Request</code> -&gt; <code>Filter1.doFilter()</code> -&gt; <code>Filter2.doFilter()</code> -&gt; … -&gt; <code>DispatcherServlet</code></p>
<p><strong>响应流程</strong>:</p>
<p><code>Request</code> &lt;- <code>Filter1.doFilter()</code> &lt;- <code>Filter2.doFilter()</code> &lt;- … &lt;- <code>DispatcherServlet</code></p>
<p><code>doFilter(ServletRequest, ServletResponse, FilterChain)</code> 方法是其核心：</p>
<ul>
<li>在 <code>chain.doFilter(request, response)</code> <strong>之前</strong>的代码，是在<strong>请求处理前</strong>执行的。</li>
<li><code>chain.doFilter(request, response)</code> 这行代码的作用是将请求<strong>传递给链中的下一个Filter</strong>，如果已经是最后一个Filter，则传递给目标Servlet。</li>
<li>在 <code>chain.doFilter(request, response)</code> <strong>之后</strong>的代码，是在<strong>响应返回时</strong>执行的。</li>
</ul>
<h6 id="c-实现方式-在Spring-Boot中"><a href="#c-实现方式-在Spring-Boot中" class="headerlink" title="c. 实现方式 (在Spring Boot中)"></a><strong>c. 实现方式 (在Spring Boot中)</strong></h6><ol>
<li>创建一个类实现 <code>javax.servlet.Filter</code> 接口。</li>
<li>使用 <code>@Component</code> 将其注册为Bean，Spring Boot会自动发现并配置它。</li>
<li>可以使用 <code>@Order</code> 注解来指定多个Filter之间的执行顺序（值越小，优先级越高）。</li>
</ol>
<p><strong>示例：一个简单的日志Filter</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">// 设置执行顺序为1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Filter: Request received for URL: &quot;</span> + req.getRequestURI());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将请求传递下去</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter: Request processed in &quot;</span> + duration + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init() 和 destroy() 方法可以留空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="d-功能与适用场景"><a href="#d-功能与适用场景" class="headerlink" title="d. 功能与适用场景"></a><strong>d. 功能与适用场景</strong></h6><p>由于Filter工作在非常靠前的位置，它能够：</p>
<ul>
<li><strong>修改请求和响应对象</strong>: 在请求到达Servlet之前，可以替换或包装 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 对象。</li>
<li><strong>访问原始的HTTP信息</strong>: 可以获取到最原始的请求数据，不受任何框架处理。</li>
<li><strong>进行请求拦截与重定向</strong>: 在 <code>chain.doFilter()</code> 调用之前，可以直接中断请求流程，例如进行重定向或返回错误响应。</li>
</ul>
<p><strong>适用场景</strong>:</p>
<ul>
<li><strong>全局编码转换</strong>: 如设置所有请求和响应的字符编码为UTF-8。</li>
<li><strong>XSS&#x2F;CSRF防护</strong>: 对所有请求的参数进行安全过滤。</li>
<li><strong>GZIP压缩</strong>: 对响应内容进行压缩。</li>
<li><strong>实现CORS跨域</strong>: 在响应中添加CORS相关的头信息。</li>
<li><strong>记录所有请求的访问日志 (Access Log)</strong>。</li>
</ul>
<hr>
<h5 id="2-拦截器-Interceptor"><a href="#2-拦截器-Interceptor" class="headerlink" title="2. 拦截器 (Interceptor)"></a><strong>2. 拦截器 (Interceptor)</strong></h5><h6 id="a-核心定义与归属-1"><a href="#a-核心定义与归属-1" class="headerlink" title="a. 核心定义与归属"></a><strong>a. 核心定义与归属</strong></h6><ul>
<li><strong>归属</strong>: <strong>Spring MVC框架</strong> 的一部分，定义在 <code>org.springframework.web.servlet.HandlerInterceptor</code> 接口中。</li>
<li><strong>定位</strong>: 它是Spring MVC<strong>专属</strong>的组件，依赖于Spring的IoC容器。</li>
<li><strong>工作层面</strong>: 工作在 <strong>Spring MVC框架层面</strong>，在请求进入 <code>DispatcherServlet</code> <strong>之后</strong>，但在 <code>Controller</code> 的方法被调用 <strong>之前&#x2F;之后</strong>被调用。</li>
</ul>
<h6 id="b-工作流程-1"><a href="#b-工作流程-1" class="headerlink" title="b. 工作流程"></a><strong>b. 工作流程</strong></h6><p>拦截器提供了更精细的控制点，它有三个核心方法：</p>
<ol>
<li><strong><code>preHandle(request, response, handler)</code></strong>:<ul>
<li><strong>调用时机</strong>: 在 <code>HandlerAdapter</code> 调用 <code>Controller</code> 方法<strong>之前</strong>执行。</li>
<li><strong>返回值</strong>: 返回 <code>true</code> 表示继续执行后续的拦截器和Controller；返回 <code>false</code> 表示<strong>中断请求</strong>，后续的拦截器和Controller都不会被执行。</li>
<li><strong>用途</strong>: 主要用于<strong>权限认证、登录校验</strong>等。</li>
</ul>
</li>
<li><strong><code>postHandle(request, response, handler, modelAndView)</code></strong>:<ul>
<li><strong>调用时机</strong>: 在 <code>Controller</code> 方法<strong>执行之后</strong>，但在<strong>视图渲染之前</strong>执行。</li>
<li><strong>用途</strong>: 可以在视图渲染前，对<strong>模型数据 (<code>ModelAndView</code>) 进行修改</strong>或添加公共的属性。</li>
</ul>
</li>
<li><strong><code>afterCompletion(request, response, handler, ex)</code></strong>:<ul>
<li><strong>调用时机</strong>: 在整个请求处理完成（包括<strong>视图渲染之后</strong>）执行。</li>
<li><strong>用途</strong>: 主要用于<strong>资源清理</strong>、<strong>记录异常日志</strong>、<strong>性能监控</strong>等。无论请求处理过程中是否发生异常，这个方法<strong>都会被调用</strong>（前提是<code>preHandle</code>返回<code>true</code>）。</li>
</ul>
</li>
</ol>
<h6 id="c-实现方式-在Spring-Boot中-1"><a href="#c-实现方式-在Spring-Boot中-1" class="headerlink" title="c. 实现方式 (在Spring Boot中)"></a><strong>c. 实现方式 (在Spring Boot中)</strong></h6><ol>
<li>创建一个类实现 <code>HandlerInterceptor</code> 接口。</li>
<li>创建一个配置类实现 <code>WebMvcConfigurer</code> 接口。</li>
<li>重写 <code>addInterceptors(InterceptorRegistry registry)</code> 方法，将自定义的拦截器注册到Spring MVC中，并可以指定要拦截的URL路径模式。</li>
</ol>
<p><strong>示例：一个简单的认证拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 实现 HandlerInterceptor</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; token.equals(<span class="string">&quot;valid-token&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interceptor: Authentication passed.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 放行</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interceptor: Authentication failed.&quot;</span>);</span><br><span class="line">            response.setStatus(<span class="number">401</span>); <span class="comment">// 设置未授权状态码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 中断请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 注册 Interceptor</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthInterceptor authInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(authInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/api/**&quot;</span>) <span class="comment">// 指定拦截以/api/开头的路径</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/api/login&quot;</span>); <span class="comment">// 排除登录接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="d-功能与适用场景-1"><a href="#d-功能与适用场景-1" class="headerlink" title="d. 功能与适用场景"></a><strong>d. 功能与适用场景</strong></h6><p>由于拦截器工作在Spring MVC内部，它能够：</p>
<ul>
<li><strong>访问到处理器信息</strong>: <code>preHandle</code> 方法的 <code>handler</code> 参数是 <code>HandlerMethod</code> 对象，可以获取到即将要调用的Controller、方法、方法上的注解等详细信息。</li>
<li><strong>访问和修改<code>ModelAndView</code></strong>: 在 <code>postHandle</code> 中可以修改即将渲染到视图的数据。</li>
<li><strong>利用Spring的IoC容器</strong>: 拦截器本身就是一个Bean，可以方便地注入其他Service等Bean来执行复杂的业务逻辑。</li>
</ul>
<p><strong>适用场景</strong>:</p>
<ul>
<li><strong>用户登录状态校验</strong>。</li>
<li><strong>接口权限验证</strong>。</li>
<li><strong>向<code>Model</code>中添加公共数据</strong>（如网站的全局导航信息）。</li>
<li><strong>记录接口的调用日志</strong>（包含哪个Controller的哪个方法被调用）。</li>
<li><strong>性能监控</strong>（计算Controller方法的执行时间）。</li>
</ul>
<hr>
<h5 id="3-总结与对比"><a href="#3-总结与对比" class="headerlink" title="3. 总结与对比"></a>3. 总结与对比</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">过滤器 (Filter)</th>
<th align="left">拦截器 (Interceptor)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>归属</strong></td>
<td align="left"><strong>Servlet规范</strong>，不依赖Spring</td>
<td align="left"><strong>Spring MVC框架</strong>的一部分，依赖Spring</td>
</tr>
<tr>
<td align="left"><strong>执行时机</strong></td>
<td align="left">在<code>DispatcherServlet</code><strong>之前&#x2F;之后</strong>，更靠前</td>
<td align="left">在<code>Controller</code>方法<strong>之前&#x2F;之中&#x2F;之后</strong>，更靠后</td>
</tr>
<tr>
<td align="left"><strong>控制粒度</strong></td>
<td align="left"><strong>粗粒度</strong>。只能访问原始的<code>Request</code>和<code>Response</code>。</td>
<td align="left"><strong>细粒度</strong>。可以访问<code>HandlerMethod</code>、<code>ModelAndView</code>等框架内部对象。</td>
</tr>
<tr>
<td align="left"><strong>功能范围</strong></td>
<td align="left">能处理所有进入Servlet容器的请求，包括<strong>静态资源</strong>。</td>
<td align="left"><strong>只能处理</strong>经过<code>DispatcherServlet</code>的请求，默认不处理静态资源。</td>
</tr>
<tr>
<td align="left"><strong>依赖注入</strong></td>
<td align="left">本身是Bean，可以注入其他Bean，但无法直接获取Spring MVC上下文信息。</td>
<td align="left">本身是Bean，可以方便地注入Service等，并能获取Spring MVC上下文。</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">编码、CORS、安全过滤、GZIP压缩</td>
<td align="left">登录校验、权限控制、日志记录、性能监控</td>
</tr>
</tbody></table>
<p><strong>一句话总结</strong>:</p>
<ul>
<li>如果你想做一些<strong>与框架无关</strong>的、<strong>针对所有HTTP请求</strong>的底层操作，请使用<strong>过滤器 (Filter)</strong>。</li>
<li>如果你想做一些<strong>与Spring MVC应用相关</strong>的、<strong>需要访问Controller或模型数据</strong>的精细化控制，请使用<strong>拦截器 (Interceptor)</strong>。</li>
</ul>
<hr>
<h4 id="1-5-3-文件上传与下载"><a href="#1-5-3-文件上传与下载" class="headerlink" title="1.5.3 文件上传与下载"></a>1.5.3 文件上传与下载</h4><p>Spring Boot 对文件上传进行了自动配置，使得处理上传文件变得非常简单。核心是使用 <code>MultipartFile</code> 接口来接收上传的文件数据。</p>
<h5 id="1-文件上传"><a href="#1-文件上传" class="headerlink" title="1. 文件上传"></a>1. 文件上传</h5><h6 id="a-前端准备-HTML-Form"><a href="#a-前端准备-HTML-Form" class="headerlink" title="a. 前端准备 (HTML Form)"></a>a. 前端准备 (HTML Form)</h6><p>要实现文件上传，前端的HTML表单必须满足三个条件：</p>
<ol>
<li><code>method</code> 必须是 <strong><code>POST</code></strong>。</li>
<li><code>enctype</code> (encoding type) 必须设置为 <strong><code>multipart/form-data</code></strong>。这告诉浏览器要以二进制的形式分段上传数据，而不是普通的文本。</li>
<li><code>input</code> 标签的 <code>type</code> 必须是 <strong><code>file</code></strong>。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>File Upload Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Upload a Single File<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload/single&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Upload<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Upload Multiple Files<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload/multiple&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &#x27;multiple&#x27; attribute allows selecting multiple files --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span> <span class="attr">multiple</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Upload<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h6 id="b-Spring-Boot-配置-application-yml"><a href="#b-Spring-Boot-配置-application-yml" class="headerlink" title="b. Spring Boot 配置 (application.yml)"></a>b. Spring Boot 配置 (application.yml)</h6><p>Spring Boot 允许你配置一些文件上传的限制，这对于防止恶意的大文件上传非常重要。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 默认开启</span></span><br><span class="line">      <span class="comment"># 单个文件的最大大小，默认1MB</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">10MB</span></span><br><span class="line">      <span class="comment"># 单次请求的总文件大小，默认10MB</span></span><br><span class="line">      <span class="attr">max-request-size:</span> <span class="string">100MB</span></span><br><span class="line">      <span class="comment"># 文件写入磁盘的阈值，超过这个大小会先写入临时文件，默认0</span></span><br><span class="line">      <span class="comment"># file-size-threshold: 2KB</span></span><br><span class="line">      <span class="comment"># 上传文件的临时存储目录</span></span><br><span class="line">      <span class="comment"># location: /path/to/temp</span></span><br></pre></td></tr></table></figure>

<hr>
<h6 id="c-后端Controller实现"><a href="#c-后端Controller实现" class="headerlink" title="c. 后端Controller实现"></a>c. 后端Controller实现</h6><p>在Controller中，我们使用 <code>@RequestParam</code> 注解，并将参数类型声明为 <code>MultipartFile</code> 或 <code>MultipartFile[]</code> 来接收文件。</p>
<p><strong>i. 处理单个文件上传</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="string">&quot;D:/uploads/&quot;</span>; <span class="comment">// 文件存储目录，请替换为实际路径</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/single&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">uploadSingleFile</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.badRequest().body(<span class="string">&quot;Please select a file to upload.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 获取文件扩展名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">            <span class="comment">// 生成新的唯一文件名，防止重名覆盖</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extension;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建目标文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadDir + newFileName);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 确保目录存在</span></span><br><span class="line">            <span class="keyword">if</span> (!dest.getParentFile().exists()) &#123;</span><br><span class="line">                dest.getParentFile().mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将上传的文件内容写入到目标文件</span></span><br><span class="line">            file.transferTo(dest);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;File uploaded successfully: &quot;</span> + newFileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 记录异常日志</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.internalServerError().body(<span class="string">&quot;File upload failed: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>MultipartFile</code> 接口常用方法</strong>:</p>
<ul>
<li><code>String getOriginalFilename()</code>: 获取上传文件的原始名称。</li>
<li><code>String getContentType()</code>: 获取文件的MIME类型，如 <code>image/jpeg</code>。</li>
<li><code>long getSize()</code>: 获取文件的大小（字节）。</li>
<li><code>byte[] getBytes()</code>: 获取文件的字节数组。</li>
<li><code>InputStream getInputStream()</code>: 获取文件的输入流。</li>
<li><code>void transferTo(File dest)</code>: <strong>最常用</strong>的方法，将文件内容快速保存到目标文件。</li>
<li><code>boolean isEmpty()</code>: 判断是否上传了空文件。</li>
</ul>
<p><strong>ii. 处理多个文件上传</strong></p>
<p>处理多个文件时，只需将参数类型改为 <code>MultipartFile[]</code> 或 <code>List&lt;MultipartFile&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload/multiple&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">uploadMultipleFiles</span><span class="params">(<span class="meta">@RequestParam(&quot;files&quot;)</span> MultipartFile[] files)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (files.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest().body(<span class="string">&quot;Please select at least one file.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; uploadedFileNames = Arrays.stream(files)</span><br><span class="line">            .map(file -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// ... (与单文件上传类似的保存逻辑) ...</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> saveFile(file); <span class="comment">// 假设saveFile是封装好的保存方法</span></span><br><span class="line">                    <span class="keyword">return</span> newFileName;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;failed-to-upload-&quot;</span> + file.getOriginalFilename();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Files uploaded: &quot;</span> + uploadedFileNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-文件下载-File-Download"><a href="#2-文件下载-File-Download" class="headerlink" title="2. 文件下载 (File Download)"></a><strong>2. 文件下载 (File Download)</strong></h5><p>文件下载的本质是：后端Controller从服务器的某个位置（文件系统、数据库、对象存储等）读取文件内容，然后将其作为HTTP响应体返回给客户端，并设置特定的<strong>响应头</strong>，告诉浏览器这是一个需要下载的文件，而不是直接在页面上显示。</p>
<p>关键的响应头是 <code>Content-Disposition</code>。</p>
<p>我们可以使用 <code>ResponseEntity&lt;Resource&gt;</code> 来实现文件下载，这是最灵活、最推荐的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDownloadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Path</span> <span class="variable">fileStorageLocation</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/uploads/&quot;</span>).toAbsolutePath().normalize();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/download/&#123;fileName:.+&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Resource&gt; <span class="title function_">downloadFile</span><span class="params">(<span class="meta">@PathVariable</span> String fileName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 构建文件路径</span></span><br><span class="line">            <span class="type">Path</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="built_in">this</span>.fileStorageLocation.resolve(fileName).normalize();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 创建一个Resource对象来代表文件</span></span><br><span class="line">            <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(filePath.toUri());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 检查文件是否存在且可读</span></span><br><span class="line">            <span class="keyword">if</span> (!resource.exists() || !resource.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;File not found or is not readable: &quot;</span> + fileName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 设置Content-Disposition响应头</span></span><br><span class="line">            <span class="comment">//    &quot;attachment&quot; 表示作为附件下载</span></span><br><span class="line">            <span class="comment">//    &quot;filename&quot; 是下载时显示的文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> <span class="string">&quot;application/octet-stream&quot;</span>; <span class="comment">// 通用的二进制流类型</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">headerValue</span> <span class="operator">=</span> <span class="string">&quot;attachment; filename=\&quot;&quot;</span> + resource.getFilename() + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">                    .contentType(MediaType.parseMediaType(contentType))</span><br><span class="line">                    .header(HttpHeaders.CONTENT_DISPOSITION, headerValue)</span><br><span class="line">                    .body(resource);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;File path error&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong>:</p>
<ol>
<li><strong><code>{fileName:.+}</code></strong>: 路径变量中的 <code>:.+</code> 是一个正则表达式，确保文件名中如果包含 <code>.</code> (点号) 也能被正确匹配。</li>
<li><strong><code>Resource</code> 接口</strong>: Spring提供的资源抽象接口，<code>UrlResource</code> 是其一个实现，用于从文件系统、URL等位置加载资源。</li>
<li><strong><code>HttpHeaders.CONTENT_DISPOSITION</code></strong>:<ul>
<li>这是文件下载的<strong>核心</strong>。</li>
<li><code>attachment</code>: 告诉浏览器这是一个需要下载的附件，浏览器会弹出“另存为”对话框。</li>
<li>如果设置为 <code>inline</code>，浏览器会尝试在页面内直接显示文件（例如PDF、图片）。</li>
<li><code>filename=&quot;...&quot;</code>: 指定下载时默认的文件名。为了处理文件名中的特殊字符，最好用双引号包裹。</li>
</ul>
</li>
<li><strong><code>MediaType.APPLICATION_OCTET_STREAM</code></strong>:<ul>
<li>这是一个通用的MIME类型，表示未知的二进制数据。它通常会强制浏览器触发下载。</li>
<li>如果你知道文件的确切类型（如<code>image/jpeg</code>），设置具体的MediaType会更好。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><p>Spring MVC 极大地简化了文件上传和下载的处理。</p>
<ul>
<li><strong>上传</strong>: 通过 <code>MultipartFile</code> 和 <code>multipart/form-data</code>，结合简单的配置，即可轻松接收文件。</li>
<li><strong>下载</strong>: 通过 <code>ResponseEntity&lt;Resource&gt;</code>，并正确设置 <code>Content-Disposition</code> 响应头，可以实现健壮、灵活的文件下载功能。</li>
</ul>
<hr>
<h4 id="1-5-4-CORS-跨域资源共享"><a href="#1-5-4-CORS-跨域资源共享" class="headerlink" title="1.5.4 CORS(跨域资源共享)"></a>1.5.4 CORS(跨域资源共享)</h4><h5 id="1-什么是跨域？"><a href="#1-什么是跨域？" class="headerlink" title="1. 什么是跨域？"></a>1. 什么是跨域？</h5><p><strong>跨域 (Cross-Origin)</strong> 是由浏览器的<strong>同源策略 (Same-Origin Policy)</strong> 引起的一种安全限制。</p>
<p><strong>同源策略</strong>规定：一个源（Origin）的网页脚本，在未经允许的情况下，不能访问另一个源的资源。</p>
<p><strong>什么是“源 (Origin)”？</strong></p>
<p>一个源由三个部分组成：<strong>协议 (Protocol) + 域名 (Host) + 端口 (Port)</strong>。</p>
<p>只要这三者中<strong>有任何一个不同</strong>，就被认为是<strong>跨域</strong>。</p>
<p><strong>示例</strong>:</p>
<p>假设当前页面的源是 <code>http://app.example.com:8080</code></p>
<table>
<thead>
<tr>
<th align="left">要请求的URL</th>
<th align="left">是否跨域</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>http://app.example.com:8080/data</code></td>
<td align="left"><strong>否</strong></td>
<td align="left">同源</td>
</tr>
<tr>
<td align="left"><code>https://app.example.com:8080/data</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>协议</strong>不同 (http vs https)</td>
</tr>
<tr>
<td align="left"><code>http://api.example.com:8080/data</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>域名</strong>不同 (app vs api)</td>
</tr>
<tr>
<td align="left"><code>http://app.example.com:9090/data</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>端口</strong>不同 (8080 vs 9090)</td>
</tr>
</tbody></table>
<p><strong>常见的前后端分离开发场景</strong>:</p>
<ul>
<li>前端应用（如Vue, React）运行在 <code>http://localhost:3000</code>。</li>
<li>后端Spring Boot API运行在 <code>http://localhost:8080</code>。</li>
<li>前端代码通过AJAX（如<code>fetch</code>, <code>axios</code>）请求后端API时，由于<strong>端口不同</strong>，就构成了<strong>跨域请求</strong>。</li>
</ul>
<p><strong>跨域限制的是什么？</strong></p>
<p>浏览器<strong>实际上已经发送了请求</strong>，并且<strong>后端服务器也已经处理并返回了响应</strong>。但是，浏览器在接收到响应后，会检查响应头，如果发现不符合CORS规范，就会<strong>拦截这个响应</strong>，不允许前端JavaScript代码读取它，并在控制台抛出CORS相关的错误。</p>
<hr>
<h5 id="2-CORS-跨域资源共享-机制"><a href="#2-CORS-跨域资源共享-机制" class="headerlink" title="2. CORS (跨域资源共享) 机制"></a>2. CORS (跨域资源共享) 机制</h5><p>CORS 是一种W3C标准，它允许服务器在HTTP响应头中添加一些额外的字段，来**“告诉”浏览器，我允许来自指定源的跨域请求**。</p>
<p>CORS请求分为两类：</p>
<ul>
<li><strong>简单请求 (Simple Request)</strong>:<ul>
<li>满足特定条件（如GET&#x2F;HEAD&#x2F;POST方法，Content-Type为特定值等）的请求。</li>
<li>浏览器直接发送实际请求，并在请求头中携带 <code>Origin</code> 字段，表明请求来源。</li>
<li>服务器在响应头中返回 <code>Access-Control-Allow-Origin</code> 字段。如果该字段的值包含了请求的<code>Origin</code>（或者是<code>*</code>），浏览器就认为跨域访问被允许。</li>
</ul>
</li>
<li><strong>非简单请求 (Preflighted Request)</strong>:<ul>
<li>不满足简单请求条件的请求，例如 <code>PUT</code>, <code>DELETE</code> 方法，或者 <code>Content-Type</code> 为 <code>application/json</code> 的 <code>POST</code> 请求。</li>
<li>浏览器会先发送一个<strong>预检请求 (Preflight Request)</strong>，这是一个 <strong><code>OPTIONS</code></strong> 方法的请求。</li>
<li>这个<code>OPTIONS</code>请求会询问服务器：“我接下来要用<code>PUT</code>方法，带着<code>Content-Type: application/json</code>头来请求<code>/api/users/1</code>，你允许吗？”</li>
<li>服务器如果允许，需要在<code>OPTIONS</code>请求的响应头中返回 <code>Access-Control-Allow-Origin</code>, <code>Access-Control-Allow-Methods</code>, <code>Access-Control-Allow-Headers</code> 等字段来表明许可。</li>
<li>浏览器收到<code>OPTIONS</code>的成功响应后，<strong>才会发送真正的<code>PUT</code>请求</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-在Spring-Boot中解决CORS问题"><a href="#3-在Spring-Boot中解决CORS问题" class="headerlink" title="3. 在Spring Boot中解决CORS问题"></a>3. 在Spring Boot中解决CORS问题</h5><p>Spring MVC 提供了非常优雅的方式来配置CORS，主要有两种：<strong>局部配置</strong>和<strong>全局配置</strong>。</p>
<h6 id="a-局部配置-CrossOrigin-注解"><a href="#a-局部配置-CrossOrigin-注解" class="headerlink" title="a. 局部配置: @CrossOrigin 注解"></a><strong>a. 局部配置: <code>@CrossOrigin</code> 注解</strong></h6><p>这是最简单、最快捷的方式，用于对<strong>单个Controller</strong>或<strong>单个方法</strong>开放跨域。</p>
<ul>
<li><p><strong>作用</strong>: 在 <code>@RestController</code> 类或 <code>@RequestMapping</code> 方法上添加 <code>@CrossOrigin</code> 注解。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">// 对整个Controller下的所有方法都生效</span></span><br><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://localhost:3000&quot;, maxAge = 3600)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Some data from backend&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/public-data&quot;)</span></span><br><span class="line">    <span class="comment">// 如果类上已经有注解，方法上的注解会覆盖类的配置</span></span><br><span class="line">    <span class="meta">@CrossOrigin</span> <span class="comment">// 不指定origins，默认允许所有源</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPublicData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Public data&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常用属性</strong>:</p>
<ul>
<li><code>origins</code> (或 <code>value</code>): 字符串数组，允许的源列表。<code>&quot;*&quot;</code> 表示允许所有源（生产环境慎用）。</li>
<li><code>methods</code>: 允许的HTTP方法，如 <code>RequestMethod.GET</code>, <code>RequestMethod.POST</code>。</li>
<li><code>allowedHeaders</code>: 允许的请求头。</li>
<li><code>exposedHeaders</code>: 允许前端JS访问的响应头。默认情况下，前端只能访问一些简单响应头。</li>
<li><code>allowCredentials</code>: 是否允许发送Cookie。默认为<code>&quot;false&quot;</code>。设为<code>&quot;true&quot;</code>时，<code>origins</code>不能为<code>&quot;*&quot;</code>，必须指定具体的源。</li>
<li><code>maxAge</code>: 预检请求的缓存时间（秒）。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="b-全局配置-WebMvcConfigurer-推荐"><a href="#b-全局配置-WebMvcConfigurer-推荐" class="headerlink" title="b. 全局配置: WebMvcConfigurer (推荐)"></a><strong>b. 全局配置: <code>WebMvcConfigurer</code> (推荐)</strong></h6><p>当整个应用都需要统一的CORS策略时，全局配置是最佳实践。这避免了在每个Controller上都重复添加 <code>@CrossOrigin</code> 注解。</p>
<ul>
<li><p><strong>作用</strong>: 创建一个配置类，实现 <code>WebMvcConfigurer</code> 接口，并重写 <code>addCorsMappings</code> 方法。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 1. 对所有路径应用CORS配置</span></span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:3000&quot;</span>, <span class="string">&quot;http://prod.example.com&quot;</span>) <span class="comment">// 2. 允许的源</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>) <span class="comment">// 3. 允许的方法</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>) <span class="comment">// 4. 允许的请求头</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>) <span class="comment">// 5. 是否允许发送Cookie</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>); <span class="comment">// 6. 预检请求的有效期</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码解析</strong>:</p>
<ol>
<li><code>addMapping(&quot;/**&quot;)</code>: 指定CORS配置应用的路径模式。<code>/**</code> 表示应用到所有接口。你也可以指定更具体的路径，如 <code>/api/**</code>。</li>
<li><code>allowedOrigins(...)</code>: 指定允许跨域请求的来源。</li>
<li><code>allowedMethods(...)</code>: 指定允许的HTTP方法。</li>
<li><code>allowedHeaders(&quot;*&quot;)</code>: <code>*</code> 表示允许所有请求头。</li>
<li><code>allowCredentials(true)</code>: 允许客户端携带认证信息（如Cookie）。</li>
<li><code>maxAge(3600)</code>: 设置预检请求的缓存时间为1小时，在此期间内，浏览器对相同的跨域请求无需再发送<code>OPTIONS</code>预检。</li>
</ol>
</li>
</ul>
<p><strong>全局配置 vs. 局部配置</strong>:</p>
<ul>
<li><strong>全局配置</strong>是管理整个应用CORS策略的首选，因为它<strong>集中、统一、易于维护</strong>。</li>
<li><strong>局部 <code>@CrossOrigin</code> 注解</strong>适用于对<strong>特定接口</strong>进行<strong>临时或特殊</strong>的CORS设置，可以作为全局配置的补充或覆盖。</li>
</ul>
<hr>
<h3 id="1-6-RESTful-API-设计原则"><a href="#1-6-RESTful-API-设计原则" class="headerlink" title="1.6 RESTful API 设计原则"></a>1.6 RESTful API 设计原则</h3><p>RESTful是一种架构风格，其核心是遵循一系列<strong>架构约束 (Architectural Constraints)</strong>。当一个系统完全遵循这些约束时，它就是RESTful的。这些约束旨在创建一个可伸缩、高性能、可靠且易于演进的分布式系统。</p>
<h4 id="1-6-1-REST的六大核心约束"><a href="#1-6-1-REST的六大核心约束" class="headerlink" title="1.6.1 REST的六大核心约束"></a>1.6.1 REST的六大核心约束</h4><h5 id="1-客户端-服务器-Client-Server"><a href="#1-客户端-服务器-Client-Server" class="headerlink" title="1. 客户端-服务器 (Client-Server)"></a>1. 客户端-服务器 (Client-Server)</h5><ul>
<li><strong>约束</strong>: 客户端和服务器的关注点必须完全分离。</li>
<li><strong>解读</strong>:<ul>
<li><strong>客户端</strong>负责用户界面和用户体验（UI&#x2F;UX）。</li>
<li><strong>服务器</strong>负责数据存储、业务逻辑和安全。</li>
<li>它们之间仅通过一个标准化的接口（HTTP）进行通信。</li>
</ul>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>独立演进</strong>: 前端团队和后端团队可以独立开发、测试和部署，只要双方遵守API契约。</li>
<li><strong>多平台支持</strong>: 同一个后端API可以为Web应用、移动App（iOS&#x2F;Android）、桌面应用等多种客户端提供服务。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-无状态-Stateless"><a href="#2-无状态-Stateless" class="headerlink" title="2. 无状态 (Stateless)"></a>2. 无状态 (Stateless)</h5><ul>
<li><strong>约束</strong>: 从客户端到服务器的每个请求都必须包含处理该请求所需的所有信息。服务器不能在多次请求之间存储任何关于客户端的上下文（会话状态）。</li>
<li><strong>解读</strong>:<ul>
<li>如果需要认证，客户端必须在<strong>每个请求</strong>中都携带身份凭证（例如，放在<code>Authorization</code>头中的JWT）。</li>
<li>服务器处理完请求后，“忘记”关于这个客户端的一切。</li>
</ul>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>高可靠性</strong>: 如果一个服务器实例失败，请求可以无缝地路由到另一个实例，因为服务器不依赖本地会话数据。</li>
<li><strong>高可伸缩性</strong>: 易于进行负载均衡和水平扩展。</li>
<li><strong>简化服务器设计</strong>: 服务器不需要管理复杂的会话状态。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-可缓存-Cacheable"><a href="#3-可缓存-Cacheable" class="headerlink" title="3. 可缓存 (Cacheable)"></a>3. 可缓存 (Cacheable)</h5><ul>
<li><strong>约束</strong>: 服务器的响应必须能够被标记为<strong>可缓存</strong>或<strong>不可缓存</strong>。</li>
<li><strong>解读</strong>:<ul>
<li>对于那些不经常变化的数据（如产品目录、配置信息），服务器应该在响应头中通过<code>Cache-Control</code>, <code>Expires</code>, <code>ETag</code>, <code>Last-Modified</code>等字段，明确告知客户端或中间代理（如CDN、反向代理）这个响应可以被缓存多久。</li>
</ul>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>提升性能</strong>: 客户端可以直接从本地缓存获取数据，减少网络延迟。</li>
<li><strong>降低服务器负载</strong>: 大量请求被缓存层拦截，减少了对后端服务器的直接访问。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-统一接口-Uniform-Interface"><a href="#4-统一接口-Uniform-Interface" class="headerlink" title="4. 统一接口 (Uniform Interface)"></a>4. 统一接口 (Uniform Interface)</h5><p>这是REST最核心的约束，它本身又包含四个子约束，旨在简化和解耦架构。</p>
<ul>
<li><p><strong>4.1 资源的标识 (Identification of Resources)</strong>:</p>
<ul>
<li>使用URI来唯一标识资源。URI的设计应稳定、语义清晰，并使用名词。</li>
</ul>
</li>
<li><p><strong>4.2 通过表现层来操作资源 (Manipulation of Resources Through Representations)</strong>:</p>
<ul>
<li>客户端通过获取和操作资源的表现层（如JSON）来与资源交互。一个资源的表现层应该包含足够的信息来修改或删除该资源。</li>
</ul>
</li>
<li><p><strong>4.3 自描述消息 (Self-descriptive Messages)</strong>:</p>
<ul>
<li>每个消息（请求&#x2F;响应）都应包含足够的信息来描述如何处理它。</li>
<li>例如，使用<code>Content-Type</code>头来指明消息体的媒体类型（如<code>application/json</code>），使用HTTP方法（<code>GET</code>, <code>POST</code>）来指明操作意图。</li>
</ul>
</li>
<li><p><strong>4.4 超媒体作为应用状态的引擎 (Hypermedia as the Engine of Application State - HATEOAS)</strong>:</p>
<ul>
<li><p>这是REST成熟度模型的最高级别。</p>
</li>
<li><p>客户端无需硬编码API的URI结构。相反，服务器的响应中应该提供相关操作的<strong>链接 (Links)</strong>，引导客户端进行下一步操作。</p>
</li>
<li><p><strong>示例</strong>: 获取一个订单信息的响应：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;orderId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xyz-123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shipped&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">59.99</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_links&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;self&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/orders/xyz-123&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;customer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/customers/567&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tracking&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/tracking/xyz-123&quot;</span> <span class="punctuation">&#125;</span> <span class="comment">// 提供了查询物流的链接</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>好处</strong>: 极大地降低了客户端和服务器的耦合度。如果服务器的URL结构发生变化，只要<code>_links</code>中的链接是正确的，客户端就可以自适应，无需修改代码。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="5-分层系统-Layered-System"><a href="#5-分层系统-Layered-System" class="headerlink" title="5. 分层系统 (Layered System)"></a>5. 分层系统 (Layered System)</h5><ul>
<li><strong>约束</strong>: 客户端通常不知道它连接的是最终的服务器，还是中间的某个代理。</li>
<li><strong>解读</strong>: 可以在客户端和服务器之间插入多个中间层，如负载均衡器、API网关、安全代理、缓存服务器等。这些中间层可以提供安全、负载均衡、缓存等功能，而不会影响客户端和服务器之间的通信。</li>
<li><strong>好处</strong>: 增强了系统的可伸缩性和安全性。</li>
</ul>
<hr>
<h5 id="6-按需编码-Code-On-Demand-可选约束"><a href="#6-按需编码-Code-On-Demand-可选约束" class="headerlink" title="6. 按需编码 (Code-On-Demand) - 可选约束"></a>6. 按需编码 (Code-On-Demand) - 可选约束</h5><ul>
<li><strong>约束</strong>: 服务器可以通过向客户端发送可执行代码（如JavaScript）来临时扩展或自定义客户端的功能。</li>
<li><strong>解读</strong>: 这是RESTful约束中唯一一个<strong>可选</strong>的。现代Web应用的单页应用（SPA）就是这个约束的典型例子。</li>
</ul>
<hr>
<h4 id="1-6-2-生产环境中的最佳实践"><a href="#1-6-2-生产环境中的最佳实践" class="headerlink" title="1.6.2 生产环境中的最佳实践"></a>1.6.2 生产环境中的最佳实践</h4><h5 id="1-精心设计URI"><a href="#1-精心设计URI" class="headerlink" title="1. 精心设计URI"></a><strong>1. 精心设计URI</strong></h5><ul>
<li><strong>使用kebab-case（短横线分隔命名法）</strong>: <code>GET /product-catalogs/electronic-devices</code>，而不是<code>productCatalogs</code>。它更易读且符合URL的传统。</li>
<li><strong>避免在URI中暴露数据库主键</strong>: 使用业务上唯一的、不透明的标识符（如UUID）代替自增ID，如 <code>/users/f47ac10b-58cc-4372-a567-0e02b2c3d479</code>。</li>
</ul>
<hr>
<h5 id="2-提供结构化的错误响应"><a href="#2-提供结构化的错误响应" class="headerlink" title="2. 提供结构化的错误响应"></a><strong>2. 提供结构化的错误响应</strong></h5><p>当API出错时，不要只返回一个简单的字符串。提供一个结构化的JSON错误对象。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="string">&quot;User not found&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;USER_NOT_FOUND&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The user with ID &#x27;123&#x27; does not exist.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;documentationUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://api.example.com/docs/errors#USER_NOT_FOUND&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-强制使用HTTPS"><a href="#3-强制使用HTTPS" class="headerlink" title="3. 强制使用HTTPS"></a><strong>3. 强制使用HTTPS</strong></h5><p>所有API通信都应该使用HTTPS来加密，以防止中间人攻击和数据窃听。</p>
<hr>
<h5 id="4-明确API契约-API-Contract"><a href="#4-明确API契约-API-Contract" class="headerlink" title="4. 明确API契约 (API Contract)"></a><strong>4. 明确API契约 (API Contract)</strong></h5><p>使用 <strong>OpenAPI (Swagger)</strong> 或 <strong>API Blueprint</strong> 等工具来定义和文档化你的API。这会生成一份清晰的API契约，便于前端、后端和测试团队之间的协作，并可以自动生成客户端代码和API文档。</p>
<hr>
<h2 id="2-Spring-WebFlux-异步非阻塞模型"><a href="#2-Spring-WebFlux-异步非阻塞模型" class="headerlink" title="2. Spring WebFlux (异步非阻塞模型)"></a>2. Spring WebFlux (异步非阻塞模型)</h2><h3 id="2-1-什么是响应式编程？-Reactive-Streams规范"><a href="#2-1-什么是响应式编程？-Reactive-Streams规范" class="headerlink" title="2.1 什么是响应式编程？(Reactive Streams规范)"></a>2.1 什么是响应式编程？(Reactive Streams规范)</h3><h4 id="2-1-1-从一个“拉”与“推”的比喻开始"><a href="#2-1-1-从一个“拉”与“推”的比喻开始" class="headerlink" title="2.1.1 从一个“拉”与“推”的比喻开始"></a>2.1.1 从一个“拉”与“推”的比喻开始</h4><p>想象一下你去一家餐厅吃饭的两种不同模式：</p>
<ul>
<li><p><strong>模式一：传统同步阻塞 (拉模式 - Pull Model)</strong></p>
<ol>
<li>你（<strong>消费者线程</strong>）向服务员（<strong>数据源&#x2F;生产者</strong>）点了一份菜（<strong>请求数据</strong>）。</li>
<li>你<strong>坐在原地死等</strong>，什么也不干，直到服务员把菜端上来。这个等待的过程就是<strong>阻塞 (Blocking)</strong>。</li>
<li>如果服务员很忙，或者厨房出菜很慢，你就得一直等下去。你的时间（线程资源）被白白浪费了。</li>
<li>菜来了，你吃了，然后再点下一份，继续死等…</li>
</ol>
<ul>
<li><strong>特点</strong>:<ul>
<li><strong>主动拉取</strong>: 你主动向服务员要菜。</li>
<li><strong>同步</strong>: 你必须等一份菜来了才能点下一份。</li>
<li><strong>阻塞</strong>: 在等待时，你被“卡住”了，无法做其他事。</li>
<li><strong>资源浪费</strong>: 你的时间（线程）在等待中被占用。</li>
</ul>
</li>
<li><strong>这就是传统的同步阻塞编程模型，比如 <code>InputStream.read()</code> 或 <code>RestTemplate</code>。</strong></li>
</ul>
</li>
<li><p><strong>模式二：响应式异步非阻塞 (推模式 - Push Model)</strong></p>
<ol>
<li>你（<strong>消费者&#x2F;订阅者</strong>）告诉服务员（<strong>数据源&#x2F;发布者</strong>）：“这是我的菜单，请按照顺序，做好了就<strong>一道一道给我送过来</strong>。在我等菜的时候，<strong>我会去看书</strong>（做其他事）。”</li>
<li>你和服务员之间建立了一个**“订阅”**关系。</li>
<li>厨房（<strong>数据生产者</strong>）每做好一道菜，服务员就<strong>主动把菜推给你</strong>（<strong>数据推送</strong>）。</li>
<li>当菜送到你面前时，你会<strong>收到一个通知</strong>（<strong>事件回调</strong>），你放下书，吃了这道菜，然后继续看书。你<strong>没有被“卡住”</strong>。</li>
<li>你甚至可以告诉服务员：“我有点饱了，<strong>先别上那么快</strong>”（<strong>背压&#x2F;回压 - Backpressure</strong>）。</li>
</ol>
<ul>
<li><strong>特点</strong>:<ul>
<li><strong>被动接收</strong>: 你不主动要，而是等待服务员主动送。</li>
<li><strong>异步</strong>: 你点完菜就可以做别的事，菜来了再处理。</li>
<li><strong>非阻塞</strong>: 你的时间（线程）没有被等待卡住。</li>
<li><strong>事件驱动</strong>: “菜来了”就是一个事件，触发你“吃”这个动作。</li>
<li><strong>流量控制</strong>: 你可以控制上菜的速度。</li>
</ul>
</li>
<li><strong>这就是响应式编程的核心思想。</strong></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-2-响应式编程的正式定义"><a href="#2-1-2-响应式编程的正式定义" class="headerlink" title="2.1.2 响应式编程的正式定义"></a>2.1.2 响应式编程的正式定义</h4><p><strong>响应式编程 (Reactive Programming)</strong> 是一种<strong>面向数据流 (Data Streams) 和变化传播 (Propagation of Change)</strong> 的<strong>异步编程范式</strong>。</p>
<p>让我们拆解这个定义：</p>
<ul>
<li><strong>异步编程范式</strong>: 意味着操作不会立即返回结果，而是在未来某个时间点通过回调、事件等方式通知你结果。</li>
<li><strong>面向数据流 (Data Streams)</strong>:<ul>
<li>在响应式编程中，<strong>任何东西都可以被看作是一个数据流</strong>。</li>
<li>一个数据流是一个<strong>按时间排序的事件序列</strong>。这些事件可以是：<ol>
<li><strong>值 (Value)</strong>: 数据项，比如一次数据库查询的结果行、一次HTTP请求的字节块、一次鼠标点击。</li>
<li><strong>错误 (Error)</strong>: 一个表示流中发生错误的信号。</li>
<li><strong>完成 (Completion)</strong>: 一个表示流已经结束的信号。</li>
</ol>
</li>
<li>这个流可以是<strong>有限的</strong>（比如读取文件内容），也可以是<strong>无限的</strong>（比如鼠标点击事件流）。</li>
</ul>
</li>
<li><strong>变化传播 (Propagation of Change)</strong>:<ul>
<li>这是响应式编程的“响应”二字的由来。</li>
<li>你不对数据流本身进行操作，而是定义一套**“处理规则”<strong>（一系列操作符，如<code>map</code>, <code>filter</code>等），然后将这些规则</strong>“附加”**到数据流上。</li>
<li>当数据流中出现新的数据时，这个变化会自动地、<strong>像涟漪一样</strong>穿过你定义的整个处理链，最终产生结果。你只需要**“响应”**这些变化即可。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<p>假设有一个代表用户输入的数据流 <code>inputStream</code>：</p>
<ul>
<li><p><strong>传统命令式编程</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我要主动地、一步一步地去操作</span></span><br><span class="line"><span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!line.isEmpty()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">transformed</span> <span class="operator">=</span> line.toUpperCase();</span><br><span class="line">        System.out.println(transformed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>响应式声明式编程</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我只声明处理规则，数据来了会自动按规则流动</span></span><br><span class="line">inputStream</span><br><span class="line">    .filter(line -&gt; !line.isEmpty()) <span class="comment">// 规则1：过滤掉空行</span></span><br><span class="line">    .map(String::toUpperCase)        <span class="comment">// 规则2：转换为大写</span></span><br><span class="line">    .subscribe(System.out::println); <span class="comment">// 规则3：最终处理方式是打印出来</span></span><br></pre></td></tr></table></figure>

<p>在这个响应式例子中，我们定义了一个处理管道。只有当<code>subscribe</code>被调用时，数据才开始流动。每当<code>inputStream</code>产生一个新数据，它就会自动流经<code>filter</code>和<code>map</code>，最后到达<code>subscribe</code>。</p>
</li>
</ul>
<hr>
<h4 id="2-1-3-Reactive-Streams-规范"><a href="#2-1-3-Reactive-Streams-规范" class="headerlink" title="2.1.3 Reactive Streams 规范"></a>2.1.3 Reactive Streams 规范</h4><p>由于不同的公司和开源社区（如Netflix, Pivotal, Lightbend）都开发了自己的响应式库（RxJava, Project Reactor, Akka Streams），为了确保这些库之间可以<strong>互操作</strong>，他们共同制定了一套标准——<strong>Reactive Streams 规范</strong>。</p>
<p><strong>这套规范非常小，只定义了四个核心接口</strong>:</p>
<ol>
<li><strong><code>Publisher&lt;T&gt;</code> (发布者)</strong><ul>
<li>角色: <strong>数据生产者</strong>。</li>
<li>它只有一个方法: <code>subscribe(Subscriber&lt;? super T&gt; s)</code>。</li>
<li>作用: 允许一个 <code>Subscriber</code> 来“订阅”它。</li>
</ul>
</li>
<li><strong><code>Subscriber&lt;T&gt;</code> (订阅者)</strong><ul>
<li>角色: <strong>数据消费者</strong>。</li>
<li>它有四个方法，定义了它如何**“响应”**来自 <code>Publisher</code> 的事件：<ul>
<li><code>onSubscribe(Subscription s)</code>: 订阅成功时被调用，<code>Publisher</code> 会传递一个 <code>Subscription</code> 对象。</li>
<li><code>onNext(T t)</code>: 接收到一个新的数据项时被调用。</li>
<li><code>onError(Throwable t)</code>: 发生错误时被调用。</li>
<li><code>onComplete()</code>: 数据流正常结束时被调用。</li>
</ul>
</li>
<li><code>onNext</code>, <code>onError</code>, <code>onComplete</code> 都是<strong>终止信号</strong>，一个流最多只会触发其中一个。</li>
</ul>
</li>
<li><strong><code>Subscription</code> (订阅关系)</strong><ul>
<li>角色: <strong>连接 <code>Publisher</code> 和 <code>Subscriber</code> 的桥梁</strong>。</li>
<li>它代表了一个<strong>唯一的</strong>订阅关系。</li>
<li>它有两个方法:<ul>
<li><code>request(long n)</code>: <strong>这是实现背压 (Backpressure) 的核心</strong>。<code>Subscriber</code> 通过调用这个方法来告诉 <code>Publisher</code>：“我准备好了，请再给我 <code>n</code> 个数据”。</li>
<li><code>cancel()</code>: <code>Subscriber</code> 用来取消订阅。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>Processor&lt;T, R&gt;</code> (处理器)</strong><ul>
<li>角色: <strong>处理阶段</strong>，它既是 <code>Subscriber</code> 又是 <code>Publisher</code>。</li>
<li>它订阅上游的 <code>Publisher</code>，对数据进行处理，然后再将处理后的结果发布给下游的 <code>Subscriber</code>。<code>map</code>, <code>filter</code> 等操作符在内部就是通过 <code>Processor</code> 实现的。</li>
</ul>
</li>
</ol>
<p><strong>规范的核心原则</strong>:</p>
<ul>
<li><strong>异步非阻塞</strong>: 所有操作都是异步的。</li>
<li><strong>背压 (Backpressure)</strong>: <strong>数据流的速度由 <code>Subscriber</code> (消费者) 来控制，而不是 <code>Publisher</code> (生产者)</strong>。<code>Publisher</code> 只有在 <code>Subscriber</code> 通过 <code>subscription.request(n)</code> 请求数据时，才能推送最多 <code>n</code> 个数据。这可以有效防止因消费者处理速度慢于生产者而导致的内存溢出（<code>OutOfMemoryError</code>）。</li>
</ul>
<hr>
<h3 id="2-2-核心API-Project-Reactor"><a href="#2-2-核心API-Project-Reactor" class="headerlink" title="2.2 核心API(Project Reactor)"></a>2.2 核心API(Project Reactor)</h3><p>Project Reactor 是 Pivotal（Spring 的母公司）开发的一个实现了 Reactive Streams 规范的、功能强大的响应式编程库。它提供了两种核心的、专门用于处理异步数据流的 <code>Publisher</code> 实现：<strong><code>Mono</code></strong> 和 <strong><code>Flux</code></strong>。</p>
<p>你可以把 <code>Mono</code> 和 <code>Flux</code> 理解为 Java 8 <code>Stream</code> API 的<strong>异步、响应式</strong>版本。它们都提供了一套极其丰富的<strong>操作符 (Operators)</strong>，用于以<strong>声明式</strong>的方式来处理数据流。</p>
<hr>
<h4 id="2-2-1-Flux-处理-0-到-N-个元素"><a href="#2-2-1-Flux-处理-0-到-N-个元素" class="headerlink" title="2.2.1 Flux&lt;T&gt; - 处理 0 到 N 个元素"></a>2.2.1 <code>Flux&lt;T&gt;</code> - 处理 0 到 N 个元素</h4><ul>
<li><p><strong>定义</strong>: <code>Flux</code> 是一个可以发出 <strong>0 到 N 个</strong>元素的异步序列（数据流）的 <code>Publisher</code>。</p>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>处理一个<strong>集合</strong>或<strong>数组</strong>中的所有元素。</li>
<li>从数据库查询返回的<strong>多行结果</strong>。</li>
<li>一个持续不断的<strong>事件流</strong>（如消息队列的消息、服务器推送事件SSE）。</li>
<li>HTTP响应中分块（chunked）传输的数据体。</li>
</ul>
</li>
<li><p><strong>生命周期事件</strong>: 一个 <code>Flux</code> 流会按顺序发出：</p>
<ol>
<li><code>onSubscribe</code> (一次)</li>
<li><code>onNext</code> (<strong>0次或多次</strong>)</li>
<li><code>onComplete</code> (最多一次) <strong>或</strong> <code>onError</code> (最多一次)</li>
</ol>
</li>
<li><p><strong>创建 <code>Flux</code> (静态工厂方法)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从固定元素创建</span></span><br><span class="line">Flux&lt;String&gt; flux1 = Flux.just(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从集合或数组创建</span></span><br><span class="line">List&lt;String&gt; fruits = Arrays.asList(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">Flux&lt;String&gt; flux2 = Flux.fromIterable(fruits);</span><br><span class="line">Flux&lt;String&gt; flux3 = Flux.fromArray(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 从一个范围创建</span></span><br><span class="line">Flux&lt;Integer&gt; flux4 = Flux.range(<span class="number">1</span>, <span class="number">5</span>); <span class="comment">// 发出 1, 2, 3, 4, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建一个空的Flux</span></span><br><span class="line">Flux&lt;Object&gt; emptyFlux = Flux.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建一个只发出错误的Flux</span></span><br><span class="line">Flux&lt;Object&gt; errorFlux = Flux.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Something went wrong&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 创建一个定时发出的Flux (每100ms发出一个从0开始递增的long值)</span></span><br><span class="line">Flux&lt;Long&gt; intervalFlux = Flux.interval(Duration.ofMillis(<span class="number">100</span>)); </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-2-Mono-处理-0-或-1-个元素"><a href="#2-2-2-Mono-处理-0-或-1-个元素" class="headerlink" title="2.2.2 Mono&lt;T&gt; - 处理 0 或 1 个元素"></a>2.2.2 <code>Mono&lt;T&gt;</code> - 处理 0 或 1 个元素</h4><ul>
<li><p><strong>定义</strong>: <code>Mono</code> 是一个最多只能发出 <strong>0 个或 1 个</strong>元素的异步序列的 <code>Publisher</code>。</p>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>当你确定一个异步操作<strong>最多只会返回一个结果</strong>时。</li>
<li>一个只返回单个实体的API调用（如 <code>findById</code>）。</li>
<li>一个异步计算的最终结果（如 <code>CompletableFuture</code>）。</li>
<li>一个表示**“完成”但没有具体值**的操作（<code>Mono&lt;Void&gt;</code>），例如保存或删除操作。</li>
</ul>
</li>
<li><p><strong>生命周期事件</strong>: 一个 <code>Mono</code> 流会按顺序发出：</p>
<ol>
<li><code>onSubscribe</code> (一次)</li>
<li><code>onNext</code> (<strong>0次或1次</strong>)</li>
<li><code>onComplete</code> (最多一次) <strong>或</strong> <code>onError</code> (最多一次)</li>
</ol>
</li>
<li><p><strong>创建 <code>Mono</code> (静态工厂方法)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从一个可能为null的元素创建</span></span><br><span class="line">Mono&lt;String&gt; mono1 = Mono.just(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">Mono&lt;String&gt; emptyMonoFromNull = Mono.justOrEmpty(<span class="literal">null</span>); <span class="comment">// 返回一个空的Mono</span></span><br><span class="line">Mono&lt;String&gt; monoFromOptional = Mono.justOrEmpty(Optional.of(<span class="string">&quot;Apple&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个空的Mono (只发出 onComplete 信号)</span></span><br><span class="line">Mono&lt;Void&gt; emptyMono = Mono.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个只发出错误的Mono</span></span><br><span class="line">Mono&lt;Object&gt; errorMono = Mono.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Something went wrong&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 从 Supplier 创建 (延迟执行)</span></span><br><span class="line">Mono&lt;String&gt; supplierMono = Mono.fromSupplier(() -&gt; <span class="string">&quot;Hello from Supplier&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 从 Callable 或 CompletableFuture 创建</span></span><br><span class="line">Mono&lt;String&gt; futureMono = Mono.fromFuture(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello from Future&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-3-核心概念：订阅-Subscription-与惰性求值"><a href="#2-2-3-核心概念：订阅-Subscription-与惰性求值" class="headerlink" title="2.2.3 核心概念：订阅 (Subscription) 与惰性求值"></a>2.2.3 核心概念：订阅 (Subscription) 与惰性求值</h4><p><strong>“冷”发布者 (Cold Publisher)</strong>:</p>
<ul>
<li><code>Flux</code> 和 <code>Mono</code> 默认都是**“冷”的**。这意味着，在你<strong>没有调用 <code>subscribe()</code></strong> 方法之前，<strong>什么都不会发生</strong>。</li>
<li>你通过各种操作符（<code>map</code>, <code>filter</code>等）构建起来的，只是一个<strong>执行计划</strong>或**“数据处理流水线”**的蓝图。</li>
<li>只有当最终的 <code>subscribe()</code> 被调用时，数据才真正开始从源头（<code>Publisher</code>）流动，并穿过整个处理链。</li>
<li>每次有新的订阅者 <code>subscribe()</code>，都会从头开始一个新的数据流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; pipeline = Flux.just(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">        .map(String::toUpperCase)</span><br><span class="line">        .log(); <span class="comment">// log()是一个有副作用的操作符，用于观察事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pipeline.subscribe(); // 如果没有这一行，控制台什么都不会打印！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当调用subscribe时，数据才开始流动</span></span><br><span class="line">pipeline.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | request(unbounded)</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onNext(A)</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onNext(B)</span></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onNext(C)</span></span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onComplete()</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-4-常用操作符-Operators"><a href="#2-2-4-常用操作符-Operators" class="headerlink" title="2.2.4 常用操作符 (Operators)"></a>2.2.4 常用操作符 (Operators)</h4><p>Reactor 提供了极其丰富的操作符，用于以声明式的方式组合和处理数据流。下面是一些最常用的操作符类别：</p>
<h5 id="1-转换-Transforming"><a href="#1-转换-Transforming" class="headerlink" title="1. 转换 (Transforming)"></a>1. 转换 (Transforming)</h5><ul>
<li><p><strong><code>map(Function&lt;T, R&gt;)</code></strong>: <strong>1对1同步转换</strong>。将流中的每个元素 T 转换为另一个元素 R。类似于 <code>Stream.map</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).map(i -&gt; i * <span class="number">10</span>).subscribe(System.out::println); <span class="comment">// 输出 10, 20, 30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>flatMap(Function&lt;T, Publisher&lt;R&gt;&gt;)</code></strong>: <strong>1对多异步转换</strong>。将每个元素 T 转换为一个新的流 <code>Publisher&lt;R&gt;</code>，然后将所有这些新流<strong>合并 (flatten)</strong> 成一个单一的流。这是<strong>处理异步调用的核心</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 findOrdersByUser(user) 是一个返回 Flux&lt;Order&gt; 的异步方法</span></span><br><span class="line">Flux&lt;User&gt; users = Flux.just(user1, user2);</span><br><span class="line">Flux&lt;Order&gt; allOrders = users.flatMap(user -&gt; findOrdersByUser(user));</span><br></pre></td></tr></table></figure>

<p><code>flatMap</code> 不保证顺序，它会交错地发出元素。如果需要保持顺序，使用 <code>concatMap</code>。</p>
</li>
</ul>
<hr>
<h5 id="2-过滤-Filtering"><a href="#2-过滤-Filtering" class="headerlink" title="2. 过滤 (Filtering)"></a>2. 过滤 (Filtering)</h5><ul>
<li><p><strong><code>filter(Predicate&lt;T&gt;)</code></strong>: 根据条件过滤流中的元素。类似于 <code>Stream.filter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println); <span class="comment">// 输出 2, 4, 6, 8, 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>take(long n)</code></strong>: 只取流中的前 n 个元素。</p>
</li>
<li><p><strong><code>distinct()</code></strong>: 去除重复的元素。</p>
</li>
</ul>
<hr>
<h5 id="3-组合-Combining"><a href="#3-组合-Combining" class="headerlink" title="3. 组合 (Combining)"></a>3. 组合 (Combining)</h5><ul>
<li><p><strong><code>mergeWith(Publisher&lt;T&gt;)</code></strong>: 将两个流合并成一个，元素按它们到达的时间交错发出。</p>
</li>
<li><p><strong><code>zipWith(Publisher&lt;U&gt;, BiFunction&lt;T, U, V&gt;)</code></strong>: 将两个流的元素<strong>按顺序两两配对</strong>，并应用一个函数来组合它们。输出流的长度取决于最短的输入流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; names = Flux.just(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">Flux&lt;Integer&gt; ages = Flux.just(<span class="number">30</span>, <span class="number">25</span>);</span><br><span class="line">Flux&lt;String&gt; zipped = names.zipWith(ages, (name, age) -&gt; name + <span class="string">&quot; is &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line"><span class="comment">// 输出: &quot;Alice is 30 years old.&quot;, &quot;Bob is 25 years old.&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-错误处理-Error-Handling"><a href="#4-错误处理-Error-Handling" class="headerlink" title="4. 错误处理 (Error Handling)"></a>4. 错误处理 (Error Handling)</h5><ul>
<li><strong><code>onErrorReturn(T fallbackValue)</code></strong>: 当发生错误时，返回一个默认值并正常完成流。</li>
<li><strong><code>onErrorResume(Function&lt;Throwable, Publisher&lt;T&gt;&gt;)</code></strong>: 当发生错误时，订阅一个新的备用流 <code>Publisher&lt;T&gt;</code>。</li>
<li><strong><code>retry(long n)</code></strong>: 当发生错误时，重新订阅上游流，最多重试 n 次。</li>
</ul>
<hr>
<h5 id="5-阻塞操作-Blocking-谨慎使用！"><a href="#5-阻塞操作-Blocking-谨慎使用！" class="headerlink" title="5. 阻塞操作 (Blocking) - 谨慎使用！"></a>5. 阻塞操作 (Blocking) - 谨慎使用！</h5><p>在响应式编程中应<strong>尽量避免阻塞</strong>。但有时在测试或与遗留代码集成时，可能需要阻塞等待结果。</p>
<ul>
<li><strong><code>block()</code></strong>: <strong>阻塞</strong>当前线程，直到 <code>Mono</code> 发出元素（或完成&#x2F;出错），并返回该元素。</li>
<li><strong><code>blockFirst()</code> &#x2F; <code>blockLast()</code></strong>: 阻塞直到 <code>Flux</code> 发出第一个&#x2F;最后一个元素。</li>
</ul>
<p><strong>警告</strong>: <strong>绝对不要在由Netty等管理的非阻塞线程（如WebFlux的请求处理线程）中调用阻塞操作！</strong> 这会严重破坏响应式模型的性能优势，甚至导致线程饥饿和应用假死。</p>
<hr>
<h3 id="2-3-两种编程模型"><a href="#2-3-两种编程模型" class="headerlink" title="2.3 两种编程模型"></a>2.3 两种编程模型</h3><h4 id="2-3-1-注解驱动模式"><a href="#2-3-1-注解驱动模式" class="headerlink" title="2.3.1 注解驱动模式"></a>2.3.1 注解驱动模式</h4><h5 id="1-核心思想：熟悉的配方，响应式的味道"><a href="#1-核心思想：熟悉的配方，响应式的味道" class="headerlink" title="1. 核心思想：熟悉的配方，响应式的味道"></a>1. 核心思想：熟悉的配方，响应式的味道</h5><p>Spring WebFlux 的注解驱动模式在设计上<strong>刻意与 Spring MVC 保持了高度的一致性</strong>。其核心思想是让已经熟悉 Spring MVC 的开发者能够以最小的学习成本，快速上手响应式Web开发。</p>
<p>这意味着，你用来构建 Spring MVC 控制器的绝大部分注解，在 WebFlux 中<strong>完全适用</strong>。</p>
<p><strong>可以重用的核心注解包括</strong>:</p>
<ul>
<li><strong>类级别</strong>: <code>@RestController</code>, <code>@Controller</code></li>
<li><strong>请求映射</strong>: <code>@RequestMapping</code>, <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, <code>@PatchMapping</code></li>
<li><strong>参数绑定</strong>: <code>@PathVariable</code>, <code>@RequestParam</code>, <code>@RequestHeader</code>, <code>@RequestBody</code>, <code>@CookieValue</code></li>
</ul>
<p>你可以像写MVC Controller一样组织你的代码结构。</p>
<hr>
<h5 id="2-根本性的区别：返回类型"><a href="#2-根本性的区别：返回类型" class="headerlink" title="2. 根本性的区别：返回类型"></a>2. 根本性的区别：返回类型</h5><p>尽管注解相同，但两者在<strong>编程模型</strong>上有着根本性的区别，这主要体现在<strong>Controller方法的返回类型</strong>上。</p>
<ul>
<li><strong>Spring MVC (同步阻塞)</strong>:<ul>
<li>方法返回的是<strong>具体的数据</strong>，如 <code>User</code>, <code>List&lt;User&gt;</code>, <code>ResponseEntity&lt;User&gt;</code>。</li>
<li>当方法被调用时，它会<strong>阻塞</strong>当前线程，直到数据准备就绪（例如，数据库查询完成），然后将完整的数据返回。</li>
</ul>
</li>
<li><strong>Spring WebFlux (异步非阻塞)</strong>:<ul>
<li>方法返回的是一个<strong>发布者 (Publisher)</strong>，即 <strong><code>Mono&lt;T&gt;</code></strong> 或 <strong><code>Flux&lt;T&gt;</code></strong>。</li>
<li>你返回的不是数据本身，而是一个**“数据的承诺”<strong>或</strong>“未来数据的持有者”**。</li>
<li>方法在定义完这个“数据承诺”（即构建好响应式管道）后会<strong>立即返回</strong>，<strong>不会阻塞</strong>请求处理线程。</li>
<li>Spring WebFlux 框架会**“订阅 (subscribe)”** 你返回的 <code>Mono</code> 或 <code>Flux</code>。当数据源（如数据库、外部API）在未来某个时间点准备好数据后，数据会被<strong>推送 (push)</strong> 到这个管道中，最终由框架写入HTTP响应。</li>
</ul>
</li>
</ul>
<p><strong>返回类型总结</strong>:</p>
<ul>
<li>返回 <strong><code>Mono&lt;T&gt;</code></strong>: 当你预期API会返回 <strong>0个或1个</strong> 结果时。例如，<code>findById</code>, <code>createUser</code>。</li>
<li>返回 <strong><code>Flux&lt;T&gt;</code></strong>: 当你预期API会返回 <strong>0个或多个</strong> 结果时。例如，<code>findAll</code>, <code>searchByName</code>。</li>
<li>返回 <strong><code>Mono&lt;Void&gt;</code></strong>: 当操作成功但<strong>无需返回任何内容</strong>时。例如，<code>deleteById</code>。</li>
<li>返回 <strong><code>Mono&lt;ResponseEntity&lt;T&gt;&gt;</code></strong>: 当你需要精细化控制响应状态码或响应头时，可以将 <code>ResponseEntity</code> 包装在 <code>Mono</code> 中。</li>
</ul>
<hr>
<h5 id="3-示例：一个响应式的-UserController"><a href="#3-示例：一个响应式的-UserController" class="headerlink" title="3. 示例：一个响应式的 UserController"></a>3. 示例：一个响应式的 <code>UserController</code></h5><p>让我们通过一个具体的例子来对比和理解。</p>
<p><strong><code>User.java</code> (POJO)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的User领域对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// constructor, getters, setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>UserController.java</code> (WebFlux Controller)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/reactive/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一个DAO/Repository</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, User&gt; userDb = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">()</span> &#123;</span><br><span class="line">        userDb.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        userDb.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2L</span>, <span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有用户 (返回多个元素 -&gt; Flux)</span></span><br><span class="line"><span class="comment">     * 使用 text/event-stream，可以观察到数据是逐条流式返回的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Flux.fromIterable 将集合转换为Flux</span></span><br><span class="line">        <span class="comment">// delayElements 模拟每个元素之间有1秒的延迟，以体现&quot;流&quot;的特性</span></span><br><span class="line">        <span class="keyword">return</span> Flux.fromIterable(userDb.values())</span><br><span class="line">                   .delayElements(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID获取单个用户 (返回0或1个元素 -&gt; Mono)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDb.get(id);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Mono.just 将一个对象包装成Mono</span></span><br><span class="line">            <span class="comment">// 返回 Mono&lt;ResponseEntity&gt; 来控制状态码</span></span><br><span class="line">            <span class="keyword">return</span> Mono.just(ResponseEntity.ok(user));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Mono.just 包装一个404的ResponseEntity</span></span><br><span class="line">            <span class="keyword">return</span> Mono.just(ResponseEntity.notFound().build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个新用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userMono 请求体也是一个Publisher (Mono&lt;User&gt;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回创建后的用户 (Mono&lt;User&gt;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CREATED)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> Mono&lt;User&gt; userMono)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用flatMap来处理异步数据</span></span><br><span class="line">        <span class="keyword">return</span> userMono.flatMap(user -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟生成ID并保存</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">newId</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            user.setId(newId);</span><br><span class="line">            userDb.put(newId, user);</span><br><span class="line">            <span class="comment">// 返回包含新用户的Mono</span></span><br><span class="line">            <span class="keyword">return</span> Mono.just(user);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-底层执行模型"><a href="#4-底层执行模型" class="headerlink" title="4. 底层执行模型"></a>4. 底层执行模型</h5><p>这个模式的背后是完全不同的线程模型。</p>
<ul>
<li><strong>Spring MVC</strong>: 默认情况下，基于Servlet API，通常采用**“一个线程处理一个请求”**的模型。如果请求中的I&#x2F;O操作（如数据库查询）阻塞了，那么这个线程也会被阻塞，直到I&#x2F;O完成。在高并发下，这会导致大量线程被创建和占用，成为系统瓶颈。</li>
<li><strong>Spring WebFlux</strong>: 通常运行在<strong>非阻塞I&#x2F;O服务器</strong>（如Netty）之上。它使用<strong>少量固定的线程（Event Loop）</strong> 来处理大量的并发请求。<ol>
<li>一个请求到达，Event Loop线程接收它。</li>
<li>该线程调用你的Controller方法。</li>
<li>Controller方法<strong>快速返回</strong>一个<code>Mono</code>或<code>Flux</code>（定义了处理流程），<strong>线程立即被释放</strong>，去处理下一个请求。</li>
<li>当响应式管道中的I&#x2F;O操作（如响应式数据库驱动）完成时，会通过<strong>回调</strong>通知Netty。</li>
<li>Event Loop线程再次被唤醒，将结果数据写入响应。</li>
</ol>
</li>
</ul>
<p><strong>核心优势</strong>：线程永远不会因为等待I&#x2F;O而阻塞，从而可以用更少的线程资源支撑更高的并发量。</p>
<hr>
<h4 id="2-3-2-函数式路由模式"><a href="#2-3-2-函数式路由模式" class="headerlink" title="2.3.2 函数式路由模式"></a>2.3.2 函数式路由模式</h4><h5 id="1-核心思想：路由即函数，处理即函数"><a href="#1-核心思想：路由即函数，处理即函数" class="headerlink" title="1. 核心思想：路由即函数，处理即函数"></a>1. 核心思想：路由即函数，处理即函数</h5><p>函数式路由模式完全摒弃了注解，将Web层的两个核心职责——**路由（Routing）**和**处理（Handling）**——显式地定义为两个独立的函数接口：</p>
<ol>
<li><strong><code>RouterFunction&lt;T extends ServerResponse&gt;</code> (路由函数)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>定义路由规则</strong>。它的作用等同于 <code>@RequestMapping</code> 注解。</li>
<li><strong>本质</strong>: 它是一个接收 <code>ServerRequest</code> 对象作为输入，返回一个 <code>Mono&lt;HandlerFunction&gt;</code> 作为输出的函数。</li>
<li><strong>工作流程</strong>: 当一个请求进来时，<code>RouterFunction</code> 会被调用。它会检查这个请求是否与自己定义的规则（如路径、HTTP方法、请求头等）匹配。<ul>
<li>如果<strong>匹配</strong>，它就返回一个包裹在 <code>Mono</code> 中的 <code>HandlerFunction</code>，告诉框架“这个请求应该由这个Handler来处理”。</li>
<li>如果<strong>不匹配</strong>，它就返回一个空的 <code>Mono</code> (<code>Mono.empty()</code>)，框架会继续尝试下一个路由规则。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>HandlerFunction&lt;T extends ServerResponse&gt;</code> (处理函数)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>处理具体的业务逻辑</strong>。它的作用等同于 <code>@Controller</code> 中的方法体。</li>
<li><strong>本质</strong>: 它是一个接收 <code>ServerRequest</code> 对象作为输入，返回一个 <code>Mono&lt;ServerResponse&gt;</code> 作为输出的函数。</li>
<li><strong>工作流程</strong>: 当路由匹配成功后，这个函数被调用。它从 <code>ServerRequest</code> 中提取数据（路径变量、参数、请求体），执行业务逻辑，并构建一个 <code>ServerResponse</code>（包含了状态码、响应头、响应体）包装在 <code>Mono</code> 中返回。</li>
</ul>
</li>
</ol>
<p><strong>对比注解模式</strong>:</p>
<table>
<thead>
<tr>
<th align="left">职责</th>
<th align="left">注解驱动模式</th>
<th align="left">函数式路由模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>路由</strong></td>
<td align="left"><code>@RequestMapping</code> 及其变体</td>
<td align="left"><code>RouterFunction</code></td>
</tr>
<tr>
<td align="left"><strong>处理</strong></td>
<td align="left"><code>@Controller</code> 中的方法</td>
<td align="left"><code>HandlerFunction</code></td>
</tr>
<tr>
<td align="left"><strong>耦合方式</strong></td>
<td align="left">注解将路由和处理耦合在方法上</td>
<td align="left">路由和处理是两个独立的函数，通过配置将它们组合在一起</td>
</tr>
</tbody></table>
<hr>
<h5 id="2-核心组件与API"><a href="#2-核心组件与API" class="headerlink" title="2. 核心组件与API"></a>2. 核心组件与API</h5><p>为了方便地构建这两个函数，Spring WebFlux 提供了一些实用的工具类：</p>
<ul>
<li><strong><code>RouterFunctions</code></strong>:<ul>
<li>一个<strong>工具类</strong>，提供了大量的静态方法来创建 <code>RouterFunction</code>。</li>
<li><code>route()</code>: 创建路由的入口。</li>
<li><code>nest()</code>: 用于创建嵌套路由，相当于类级别的 <code>@RequestMapping</code>。</li>
<li><code>and()</code> &#x2F; <code>andRoute()</code>: 用于将多个路由规则组合在一起。</li>
</ul>
</li>
<li><strong><code>RequestPredicates</code></strong>:<ul>
<li>一个<strong>工具类</strong>，提供了各种用于匹配请求的<strong>谓词 (Predicate)</strong>。</li>
<li><code>GET(pattern)</code>: 匹配GET方法和指定路径。</li>
<li><code>POST(pattern)</code>, <code>PUT(pattern)</code>, <code>DELETE(pattern)</code> 等。</li>
<li><code>accept(MediaType)</code>: 匹配 <code>Accept</code> 请求头。</li>
<li><code>contentType(MediaType)</code>: 匹配 <code>Content-Type</code> 请求头。</li>
<li><code>path(pattern)</code>: 只匹配路径。</li>
</ul>
</li>
<li><strong><code>ServerRequest</code></strong>:<ul>
<li>对 <code>HttpServletRequest</code> 的响应式、不可变封装。</li>
<li>提供了获取路径变量、查询参数、请求头、请求体 (<code>bodyToMono</code>, <code>bodyToFlux</code>) 的响应式方法。</li>
</ul>
</li>
<li><strong><code>ServerResponse</code></strong>:<ul>
<li>对 <code>HttpServletResponse</code> 的响应式、不可变封装。</li>
<li>提供了一个<strong>流式的构建器 (Builder)</strong> 来创建响应，可以方便地设置状态码、响应头、响应体等。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-示例：使用函数式模式重写-UserController"><a href="#3-示例：使用函数式模式重写-UserController" class="headerlink" title="3. 示例：使用函数式模式重写 UserController"></a>3. 示例：使用函数式模式重写 <code>UserController</code></h5><p>我们将之前注解模式的 <code>UserController</code> 用函数式的方式重写，通常会把路由定义和处理逻辑分开。</p>
<p><strong>Step 1: 创建 <code>UserHandler</code> (处理逻辑)</strong></p>
<p>这个类不依赖任何Spring MVC的注解，是一个纯粹的业务处理类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 仍然是一个Spring Bean，以便注入其他服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设有一个响应式的 UserService</span></span><br><span class="line">    <span class="comment">// @Autowired</span></span><br><span class="line">    <span class="comment">// private UserService userService;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟的DAO/Repository</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, User&gt; userDb = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        userDb.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        userDb.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2L</span>, <span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理获取所有用户的请求 (HandlerFunction)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">getAllUsers</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        Flux&lt;User&gt; users = Flux.fromIterable(userDb.values());</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.ok()</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(users, User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理根据ID获取用户的请求 (HandlerFunction)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">getUserById</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> Long.valueOf(request.pathVariable(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDb.get(id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.ok()</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .body(Mono.just(user), User.class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.notFound().build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理创建用户的请求 (HandlerFunction)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">createUser</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        Mono&lt;User&gt; userMono = request.bodyToMono(User.class);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> userMono.flatMap(user -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟保存</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">newId</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            user.setId(newId);</span><br><span class="line">            userDb.put(newId, user);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> ServerResponse.status(HttpStatus.CREATED)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .body(Mono.just(user), User.class);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 创建 <code>UserRouter</code> (路由定义)</strong></p>
<p>这个类使用 <code>@Configuration</code> 和 <code>@Bean</code> 来定义路由规则，并将它们与 <code>UserHandler</code> 中的方法关联起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunctions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RouterFunctions.route;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">userRoutes</span><span class="params">(UserHandler userHandler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> route(GET(<span class="string">&quot;/functional/users&quot;</span>), userHandler::getAllUsers)</span><br><span class="line">                .andRoute(GET(<span class="string">&quot;/functional/users/&#123;id&#125;&quot;</span>), userHandler::getUserById)</span><br><span class="line">                .andRoute(POST(<span class="string">&quot;/functional/users&quot;</span>), userHandler::createUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用嵌套路由，更清晰</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">nestedUserRoutes</span><span class="params">(UserHandler userHandler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.nest(path(<span class="string">&quot;/functional/v2/users&quot;</span>),</span><br><span class="line">                route(GET(<span class="string">&quot;&quot;</span>), userHandler::getAllUsers)</span><br><span class="line">                .andRoute(GET(<span class="string">&quot;/&#123;id&#125;&quot;</span>), userHandler::getUserById)</span><br><span class="line">                .andRoute(POST(<span class="string">&quot;&quot;</span>), userHandler::createUser)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong>:</p>
<ul>
<li>我们定义了一个类型为 <code>RouterFunction&lt;ServerResponse&gt;</code> 的Bean。Spring WebFlux会自动检测到这个Bean并用它来处理请求。</li>
<li><code>route(RequestPredicate, HandlerFunction)</code> 是核心方法，它将一个请求谓词和一个处理函数绑定在一起。</li>
<li><code>userHandler::getAllUsers</code> 是Java 8的方法引用，它指向了 <code>UserHandler</code> 中的 <code>getAllUsers</code> 方法，非常简洁。</li>
<li><code>nest()</code> 方法可以将一组路由规则嵌套在一个公共的路径前缀下，使得代码结构更清晰。</li>
</ul>
<hr>
<h5 id="4-优势与适用场景"><a href="#4-优势与适用场景" class="headerlink" title="4. 优势与适用场景"></a><strong>4. 优势与适用场景</strong></h5><p><strong>优势</strong>:</p>
<ol>
<li><strong>更高的灵活性和控制力</strong>: 路由规则是普通的Java代码，你可以使用任何编程逻辑（<code>if-else</code>, 循环, Stream API）来动态地构建路由，这是注解无法做到的。</li>
<li><strong>更好的性能（理论上）</strong>: 由于绕过了注解的反射扫描和解析过程，函数式路由在启动时和运行时的开销理论上更小。对于需要处理极高吞吐量的微服务网关等场景，这可能是一个优势。</li>
<li><strong>函数式编程风格</strong>: 代码更加声明式和不可变，易于测试和推理。<code>HandlerFunction</code> 只是一个接收 <code>ServerRequest</code> 返回 <code>Mono&lt;ServerResponse&gt;</code> 的函数，单元测试非常简单。</li>
<li><strong>关注点分离</strong>: 路由逻辑和业务处理逻辑被清晰地分离在不同的类中，职责更单一。</li>
</ol>
<p><strong>适用场景</strong>:</p>
<ul>
<li>需要构建高度动态或复杂的路由规则。</li>
<li>对性能有极致要求的场景。</li>
<li>偏爱函数式编程风格，追求更强类型安全和代码控制力的团队。</li>
<li>构建轻量级的、专注于代理或路由的微服务。</li>
</ul>
<hr>
<h3 id="2-4-WebClient-响应式HTTP客户端"><a href="#2-4-WebClient-响应式HTTP客户端" class="headerlink" title="2.4 WebClient (响应式HTTP客户端)"></a>2.4 WebClient (响应式HTTP客户端)</h3><h4 id="2-4-1-什么是-WebClient？"><a href="#2-4-1-什么是-WebClient？" class="headerlink" title="2.4.1 什么是 WebClient？"></a>2.4.1 什么是 <code>WebClient</code>？</h4><p><code>WebClient</code> 是 Spring 5 中引入的一个<strong>现代化的、响应式的、非阻塞的HTTP客户端</strong>。它是作为传统的、同步阻塞的 <code>RestTemplate</code> 的替代品而设计的。</p>
<ul>
<li><strong>定位</strong>: Spring WebFlux 官方推荐的HTTP请求工具。</li>
<li><strong>核心特性</strong>:<ul>
<li><strong>非阻塞I&#x2F;O</strong>: 底层基于Netty等非阻塞I&#x2F;O库，发送请求时不会阻塞当前线程。</li>
<li><strong>响应式API</strong>: 它的API设计完全基于Project Reactor的 <code>Mono</code> 和 <code>Flux</code>，可以无缝地集成到响应式处理链中。</li>
<li><strong>流式处理</strong>: 能够高效地处理大量的或持续的数据流（如文件上传下载、Server-Sent Events）。</li>
<li><strong>函数式风格</strong>: 提供了一个流畅的、链式调用的函数式API来构建和发送请求。</li>
</ul>
</li>
</ul>
<p><strong><code>RestTemplate</code> vs <code>WebClient</code></strong>:</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>RestTemplate</code> (维护模式)</th>
<th align="left"><code>WebClient</code> (推荐)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>编程模型</strong></td>
<td align="left"><strong>同步阻塞</strong></td>
<td align="left"><strong>异步非阻塞</strong></td>
</tr>
<tr>
<td align="left"><strong>返回类型</strong></td>
<td align="left">直接返回具体对象 (<code>User</code>, <code>String</code>)</td>
<td align="left">返回 <code>Mono&lt;T&gt;</code> 或 <code>Flux&lt;T&gt;</code> (数据的“承诺”)</td>
</tr>
<tr>
<td align="left"><strong>线程模型</strong></td>
<td align="left">每个请求占用一个线程直到响应返回</td>
<td align="left">使用少量Event Loop线程处理大量并发请求</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">传统的Spring MVC应用、简单的同步调用</td>
<td align="left"><strong>Spring WebFlux应用</strong>、高并发微服务间通信、流式API</td>
</tr>
<tr>
<td align="left"><strong>状态</strong></td>
<td align="left">Spring官方已将其置于<strong>维护模式</strong>，不再添加新功能。</td>
<td align="left">Spring官方<strong>主推</strong>的现代HTTP客户端。</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-4-2-如何使用-WebClient？"><a href="#2-4-2-如何使用-WebClient？" class="headerlink" title="2.4.2 如何使用 WebClient？"></a>2.4.2 如何使用 <code>WebClient</code>？</h4><p>使用 <code>WebClient</code> 通常分为三步：</p>
<ol>
<li><strong>创建 <code>WebClient</code> 实例</strong></li>
<li><strong>构建 HTTP 请求</strong></li>
<li><strong>处理响应</strong></li>
</ol>
<h5 id="1-创建-WebClient-实例"><a href="#1-创建-WebClient-实例" class="headerlink" title="1. 创建 WebClient 实例"></a>1. 创建 <code>WebClient</code> 实例</h5><p><code>WebClient</code> 实例是<strong>线程安全的</strong>和<strong>不可变的</strong>，因此通常建议在应用中创建一个<strong>单例</strong>的 <code>WebClient</code> Bean，并根据需要进行复用。</p>
<p><strong>方式一：使用默认设置创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebClient</span> <span class="variable">client</span> <span class="operator">=</span> WebClient.create();</span><br></pre></td></tr></table></figure>

<p><strong>方式二：指定基础URL创建</strong></p>
<p>这是最常见的方式，可以为所有从此客户端发出的请求设置一个公共的基础URL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebClient</span> <span class="variable">client</span> <span class="operator">=</span> WebClient.create(<span class="string">&quot;http://api.example.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>方式三：使用构建器进行高级定制 (推荐)</strong></p>
<p>通过 <code>WebClient.builder()</code> 可以进行更详细的配置，如设置默认请求头、超时、过滤器等。</p>
<p><strong>在 <code>@Configuration</code> 类中创建 <code>WebClient</code> Bean</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.client.WebClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebClient <span class="title function_">webClient</span><span class="params">(WebClient.Builder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .baseUrl(<span class="string">&quot;http://api.example.com&quot;</span>) <span class="comment">// 设置基础URL</span></span><br><span class="line">                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) <span class="comment">// 设置默认请求头</span></span><br><span class="line">                .defaultHeader(<span class="string">&quot;X-App-Name&quot;</span>, <span class="string">&quot;MyCoolApp&quot;</span>)</span><br><span class="line">                <span class="comment">// ... 还可以设置超时、过滤器、负载均衡等</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Boot会自动配置一个 <code>WebClient.Builder</code> Bean，我们可以在配置类中直接注入并使用它。这样做的好处是可以保留Spring Boot对<code>WebClient</code>的自动配置（如编解码器等）。</p>
</blockquote>
<hr>
<h5 id="2-构建并发送请求-Fluent-API"><a href="#2-构建并发送请求-Fluent-API" class="headerlink" title="2. 构建并发送请求 (Fluent API)"></a>2. 构建并发送请求 (Fluent API)</h5><p><code>WebClient</code> 的API是链式调用的，非常流畅。</p>
<p><strong>请求构建流程</strong>:</p>
<ol>
<li><strong>指定HTTP方法</strong>: <code>.get()</code>, <code>.post()</code>, <code>.put()</code>, <code>.delete()</code> …</li>
<li><strong>指定URI</strong>: <code>.uri(&quot;/users/{id}&quot;, 123)</code>。URI是相对于基础URL的。</li>
<li><strong>设置请求头 (可选)</strong>: <code>.header(&quot;Authorization&quot;, &quot;Bearer ...&quot;)</code>。</li>
<li><strong>设置请求体 (对于POST&#x2F;PUT)</strong>: <code>.bodyValue(object)</code> 或 <code>.body(publisher, class)</code>。</li>
<li><strong>发送请求</strong>: <code>.retrieve()</code>。</li>
<li><strong>处理响应</strong>: <code>.bodyToMono(class)</code> 或 <code>.bodyToFlux(class)</code>。</li>
</ol>
<hr>
<h5 id="3-处理响应"><a href="#3-处理响应" class="headerlink" title="3. 处理响应"></a>3. 处理响应</h5><p><code>WebClient</code> 提供了两种主要的方式来处理响应：<code>retrieve()</code> 和 <code>exchangeToMono</code>&#x2F;<code>exchangeToFlux</code>。</p>
<p><strong>i. 使用 <code>retrieve()</code> (最常用、最简单)</strong></p>
<p><code>retrieve()</code> 方法是处理响应最直接的方式。它会自动检查 <code>4xx</code> 和 <code>5xx</code> 系列的状态码，如果遇到，会直接将 <code>Mono</code> 或 <code>Flux</code> 转换为<strong>错误信号</strong> (<code>onError</code>)，并抛出 <code>WebClientResponseException</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApiService</span><span class="params">(WebClient webClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.webClient = webClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单个用户 (返回 Mono)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.webClient.get()</span><br><span class="line">                .uri(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, id)</span><br><span class="line">                .retrieve()</span><br><span class="line">                <span class="comment">// 将响应体转换为 Mono&lt;User&gt;</span></span><br><span class="line">                .bodyToMono(User.class)</span><br><span class="line">                .doOnError(e -&gt; System.err.println(<span class="string">&quot;Failed to fetch user: &quot;</span> + e.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有用户 (返回 Flux)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.webClient.get()</span><br><span class="line">                .uri(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">                .retrieve()</span><br><span class="line">                <span class="comment">// 将响应体转换为 Flux&lt;User&gt;</span></span><br><span class="line">                .bodyToFlux(User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新用户 (使用 POST 并发送请求体)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">createUser</span><span class="params">(User newUser)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.webClient.post()</span><br><span class="line">                .uri(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">                .bodyValue(newUser) <span class="comment">// bodyValue() 用于发送一个普通对象</span></span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToMono(User.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ii. 使用 <code>exchangeToMono</code> &#x2F; <code>exchangeToFlux</code> (高级用法)</strong></p>
<p><code>exchangeTo...</code> 方法提供了对响应的<strong>完全控制权</strong>，包括状态码和响应头。它<strong>不会</strong>自动处理错误状态码，你需要自己检查。</p>
<p>这在你需要根据不同的状态码执行不同逻辑时非常有用。</p>
<p><strong>示例：根据状态码进行不同处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">getUserWithCustomErrorHandling</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.webClient.get()</span><br><span class="line">            .uri(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, id)</span><br><span class="line">            .exchangeToMono(response -&gt; &#123;</span><br><span class="line">                <span class="comment">// response 是 ClientResponse 对象</span></span><br><span class="line">                <span class="keyword">if</span> (response.statusCode().is2xxSuccessful()) &#123;</span><br><span class="line">                    <span class="comment">// 如果是2xx成功，正常转换响应体</span></span><br><span class="line">                    <span class="keyword">return</span> response.bodyToMono(User.class);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.statusCode().equals(HttpStatus.NOT_FOUND)) &#123;</span><br><span class="line">                    <span class="comment">// 如果是404，返回一个空的Mono</span></span><br><span class="line">                    <span class="keyword">return</span> Mono.empty();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他错误情况，创建一个自定义的异常并放入错误信号</span></span><br><span class="line">                    <span class="keyword">return</span> response.createException()</span><br><span class="line">                            .flatMap(ex -&gt; Mono.error(<span class="keyword">new</span> <span class="title class_">MyCustomException</span>(<span class="string">&quot;API call failed&quot;</span>, ex)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-3-同步调用-WebClient"><a href="#2-4-3-同步调用-WebClient" class="headerlink" title="2.4.3 同步调用 WebClient"></a>2.4.3 同步调用 <code>WebClient</code></h4><p>虽然 <code>WebClient</code> 是为异步而生，但在某些特殊情况（如与遗留的同步代码集成、或在简单的命令行应用中），你可能需要阻塞等待结果。可以通过 <code>.block()</code> 方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// !!! 警告：仅在非响应式上下文中使用，如main方法或测试中 !!!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncCall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> webClient.get()</span><br><span class="line">                .uri(<span class="string">&quot;/users/1&quot;</span>)</span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToMono(User.class)</span><br><span class="line">                .block(Duration.ofSeconds(<span class="number">5</span>)); <span class="comment">// 阻塞最多5秒等待结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Synchronously fetched user: &quot;</span> + user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WebClientResponseException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Error: &quot;</span> + e.getRawStatusCode() + <span class="string">&quot; - &quot;</span> + e.getResponseBodyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>再次强调</strong>：<strong>永远不要在WebFlux的Controller或任何响应式管道中调用 <code>.block()</code></strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringBoot/" class="post-title-link" itemprop="url">Spring全家桶-SpringBoot</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-05 14:24:40" itemprop="dateCreated datePublished" datetime="2025-10-05T14:24:40+08:00">2025-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:09:37" itemprop="dateModified" datetime="2025-10-17T11:09:37+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="二、SpringBoot"><a href="#二、SpringBoot" class="headerlink" title="二、SpringBoot"></a>二、SpringBoot</h1><p><strong>Spring Boot 是一个用来简化 Spring 应用创建和开发的框架，让你能快速地搭建和运行独立的、生产级别的 Java 应用程序。</strong></p>
<h2 id="1-SpringBoot核心"><a href="#1-SpringBoot核心" class="headerlink" title="1. SpringBoot核心"></a>1. SpringBoot核心</h2><h3 id="1-1-四大核心特性"><a href="#1-1-四大核心特性" class="headerlink" title="1.1 四大核心特性"></a>1.1 四大核心特性</h3><h4 id="1-1-1-起步依赖"><a href="#1-1-1-起步依赖" class="headerlink" title="1.1.1 起步依赖"></a>1.1.1 起步依赖</h4><h5 id="1-问题背景：没有Starter的“黑暗时代”"><a href="#1-问题背景：没有Starter的“黑暗时代”" class="headerlink" title="1. 问题背景：没有Starter的“黑暗时代”"></a>1. 问题背景：没有Starter的“黑暗时代”</h5><p>在 Spring Boot 出现之前，如果我们想用 Spring Framework 构建一个 Web 应用，需要经历一个繁琐且易错的过程：</p>
<ol>
<li><strong>手动添加大量依赖</strong>：我们需要在 <code>pom.xml</code> (Maven) 或 <code>build.gradle</code> (Gradle) 中手动添加一长串的依赖项，例如：<ul>
<li>核心Spring框架：<code>spring-core</code>, <code>spring-beans</code>, <code>spring-context</code></li>
<li>Web功能：<code>spring-web</code>, <code>spring-webmvc</code></li>
<li>Servlet容器：<code>tomcat-embed-core</code>, <code>tomcat-embed-el</code></li>
<li>…可能还有日志、校验等其他库。</li>
</ul>
</li>
<li><strong>管理复杂的版本兼容性</strong>：你需要确保你添加的所有库版本之间都是相互兼容的。如果版本不匹配，轻则出现警告，重则应用在运行时直接崩溃。这个过程被称为**“依赖地狱 (Dependency Hell)”**。</li>
<li><strong>编写大量的模板配置</strong>：添加完依赖后，还需要编写大量的XML或Java配置来把这些组件整合起来，比如配置 <code>DispatcherServlet</code>、视图解析器、Jackson的 <code>ObjectMapper</code> 等。</li>
</ol>
<p>这个过程不仅耗时，而且对于新手来说门槛极高，任何一个环节出错都可能导致项目无法启动。</p>
<hr>
<h5 id="2-解决方案：Spring-Boot-Starter"><a href="#2-解决方案：Spring-Boot-Starter" class="headerlink" title="2. 解决方案：Spring Boot Starter"></a>2. 解决方案：Spring Boot Starter</h5><p>Spring Boot Starter 的出现，就是为了彻底解决上述问题。</p>
<p><strong>核心定义</strong>：一个<strong>起步依赖 (Starter)</strong> 本质上是一个<strong>精心策划的、一站式的依赖描述符（通常是一个Maven项目&#x2F;POM）</strong>。它将构建特定类型应用（如Web、数据访问、消息队列）所需的一整套通用依赖项<strong>打包</strong>在一起。</p>
<hr>
<h5 id="3-工作原理：传递性依赖-Transitive-Dependencies"><a href="#3-工作原理：传递性依赖-Transitive-Dependencies" class="headerlink" title="3. 工作原理：传递性依赖 (Transitive Dependencies)"></a>3. 工作原理：传递性依赖 (Transitive Dependencies)</h5><p>Starter 本身通常是一个**“空壳”**。它里面几乎没有Java代码，其真正的价值在于它的 <code>pom.xml</code> 文件。</p>
<p>当你引入一个 Starter 时，例如 <code>spring-boot-starter-web</code>，Maven或Gradle会利用<strong>传递性依赖</strong>机制，自动将这个Starter的<code>pom.xml</code>中声明的所有相关依赖项全部下载并添加到你的项目中。</p>
<p><strong>以 <code>spring-boot-starter-web</code> 为例：</strong></p>
<p>当你只在 <code>pom.xml</code> 中添加了这一行：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你实际上获得了以下所有核心依赖（版本由Spring Boot统一管理）：</p>
<ul>
<li><code>spring-boot-starter</code>：核心Starter，提供了自动配置、日志和YAML支持。</li>
<li><code>spring-boot-starter-json</code>：提供了对JSON的读写支持，内部依赖了 <code>jackson-databind</code>。</li>
<li><code>spring-boot-starter-tomcat</code>：提供了内嵌的Tomcat服务器。</li>
<li><code>spring-web</code> 和 <code>spring-webmvc</code>：Spring MVC框架的核心。</li>
<li><code>hibernate-validator</code>：提供了数据校验的支持。</li>
</ul>
<p><strong>版本管理</strong>：所有这些依赖的版本号，都由 <code>spring-boot-dependencies</code> 这个特殊的 “parent POM” 统一管理。Spring Boot 团队对这些版本组合进行了大量的测试，确保它们之间完美兼容。你无需再为版本号操心。</p>
<hr>
<h5 id="4-带来的核心优势"><a href="#4-带来的核心优势" class="headerlink" title="4. 带来的核心优势"></a>4. 带来的核心优势</h5><ol>
<li><strong>极简的依赖管理</strong>：<ul>
<li><strong>之前</strong>：需要添加 5-10 个或更多的 <code>&lt;dependency&gt;</code> 标签。</li>
<li><strong>现在</strong>：只需要添加 1 个 <code>&lt;dependency&gt;</code> 标签。</li>
</ul>
</li>
<li><strong>杜绝版本冲突</strong>：<ul>
<li><strong>之前</strong>：开发者需要像“排雷”一样手动协调版本。</li>
<li><strong>现在</strong>：版本由Spring Boot官方统一管理和测试，开箱即用，稳定可靠。</li>
</ul>
</li>
<li><strong>功能开箱即用</strong>：<ul>
<li>引入Starter不仅是添加了JAR包，它还常常与Spring Boot的<strong>自动配置</strong>特性联动。例如，一旦 <code>spring-boot-starter-web</code> 被引入，Spring Boot就会自动为你配置好 <code>DispatcherServlet</code>、<code>Tomcat</code> 服务器等Web环境所需的一切，让应用可以直接启动并处理HTTP请求。</li>
</ul>
</li>
<li><strong>加速项目启动和原型开发</strong>：<ul>
<li>开发者可以快速地搭建起一个具备特定功能（Web、JPA、Redis等）的应用原型，而无需陷入繁琐的配置细节中。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="5-命名约定"><a href="#5-命名约定" class="headerlink" title="5. 命名约定"></a>5. 命名约定</h5><ul>
<li><strong>官方Starter</strong>：由Spring Boot团队维护，命名格式为 <code>spring-boot-starter-*</code>，例如 <code>spring-boot-starter-data-jpa</code>。</li>
<li><strong>社区&#x2F;第三方Starter</strong>：由社区或第三方公司提供，为了避免混淆，官方推荐的命名格式为 <code>*-spring-boot-starter</code>，例如 <code>mybatis-spring-boot-starter</code>。</li>
</ul>
<hr>
<h5 id="6-自定义起步依赖"><a href="#6-自定义起步依赖" class="headerlink" title="6. 自定义起步依赖"></a>6. 自定义起步依赖</h5><h6 id="a-核心概念与组成"><a href="#a-核心概念与组成" class="headerlink" title="a). 核心概念与组成"></a>a). 核心概念与组成</h6><p>一个标准的自定义Starter通常由<strong>两个模块</strong>组成，这是最佳实践：</p>
<ol>
<li><strong><code>xxx-spring-boot-autoconfigure</code> 模块</strong>:<ul>
<li><strong>核心功能模块</strong>。它包含了所有自动配置的代码、<code>@ConfigurationProperties</code>类以及需要被注册为Bean的业务类。</li>
<li><strong>这是Starter的“大脑”</strong>。它负责判断在何种条件下（<code>@ConditionalOn...</code>），应该创建哪些Bean，以及如何配置它们。</li>
</ul>
</li>
<li><strong><code>xxx-spring-boot-starter</code> 模块</strong>:<ul>
<li><strong>依赖聚合模块</strong>。这个模块本身<strong>几乎没有任何代码</strong>。</li>
<li>它的唯一作用就是在 <code>pom.xml</code> 中<strong>聚合依赖</strong>。它会依赖于上面的 <code>autoconfigure</code> 模块，以及其他任何这个功能所需要的第三方库。</li>
<li><strong>这是用户唯一需要关心的模块</strong>。用户在他的项目中，只需要引入这一个Starter依赖，就能获得所有功能。</li>
</ul>
</li>
</ol>
<p><strong>为什么要分成两个模块？</strong></p>
<p>这是为了<strong>关注点分离</strong>。<code>autoconfigure</code>模块负责实现所有逻辑，而<code>starter</code>模块只负责提供一个简单的依赖入口。用户只需要依赖<code>starter</code>，而不需要关心具体的自动配置实现，使得依赖关系更清晰。</p>
<hr>
<h6 id="b-创建一个my-greeting-spring-boot-starter"><a href="#b-创建一个my-greeting-spring-boot-starter" class="headerlink" title="b). 创建一个my-greeting-spring-boot-starter"></a>b). 创建一个<code>my-greeting-spring-boot-starter</code></h6><p>我们的目标是创建一个Starter，它能提供一个<code>GreetingService</code> Bean。这个Bean的行为可以通过 <code>application.properties</code> 进行配置。</p>
<p><strong>最终效果</strong>：</p>
<ol>
<li><p>用户只需在项目中引入我们的<code>my-greeting-spring-boot-starter</code>依赖。</p>
</li>
<li><p>用户可以在<code>application.properties</code>中配置问候语的前缀和后缀，如：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my.greeting.prefix</span>=<span class="string">Hi, </span></span><br><span class="line"><span class="attr">my.greeting.suffix</span>=<span class="string">. Welcome!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用户可以在自己的代码中直接 <code>@Autowired</code> 注入 <code>GreetingService</code> 并使用它。</p>
</li>
</ol>
<hr>
<p><strong>步骤 1: 创建项目结构 (Maven)</strong></p>
<p>首先，创建一个父Maven项目，并在其中创建两个子模块 。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my-greeting-starter-parent</span><br><span class="line">├── pom.xml</span><br><span class="line">├── my-greeting-spring-boot-autoconfigure</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src/main/java/...</span><br><span class="line">│   └── src/main/resources/...</span><br><span class="line">└── my-greeting-spring-boot-starter</span><br><span class="line">    └── pom.xml</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>父 <code>pom.xml</code></strong>: 管理公共的版本信息。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span> <span class="comment">&lt;!-- 请使用合适的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-greeting-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-greeting-spring-boot-starter<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>步骤 2: 实现 <code>autoconfigure</code> 模块</strong></p>
<p>这是我们的核心工作区。</p>
<p><strong>1. <code>pom.xml</code> for <code>autoconfigure</code></strong></p>
<p>这个模块需要依赖Spring Boot的自动配置处理器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入Spring Boot自动配置核心包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入配置属性处理器，用于生成配置元数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 创建属性配置类 (<code>GreetingProperties.java</code>)</strong></p>
<p>这个类用于映射 <code>application.properties</code>中的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.greeting.autoconfigure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my.greeting&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The prefix of the greeting message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span>; <span class="comment">// 提供默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The suffix of the greeting message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> <span class="string">&quot;!&quot;</span>; <span class="comment">// 提供默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrefix</span><span class="params">()</span> &#123; <span class="keyword">return</span> prefix; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrefix</span><span class="params">(String prefix)</span> &#123; <span class="built_in">this</span>.prefix = prefix; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSuffix</span><span class="params">()</span> &#123; <span class="keyword">return</span> suffix; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuffix</span><span class="params">(String suffix)</span> &#123; <span class="built_in">this</span>.suffix = suffix; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tip</strong>: 添加JavaDoc注释，<code>spring-boot-configuration-processor</code>会自动生成<code>spring-configuration-metadata.json</code>文件，为IDE提供配置提示。</p>
</blockquote>
<p><strong>3. 创建业务服务类 (<code>GreetingService.java</code>)</strong></p>
<p>这是我们想提供给用户的核心服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.greeting.autoconfigure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GreetingService</span><span class="params">(String prefix, String suffix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prefix = prefix;</span><br><span class="line">        <span class="built_in">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix + name + suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 创建自动配置类 (<code>GreetingAutoConfiguration.java</code>)</strong></p>
<p>这是Starter的灵魂！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.greeting.autoconfigure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 启用我们定义的属性类，使其生效</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(GreetingProperties.class)</span></span><br><span class="line"><span class="comment">// 条件注解：只有当配置文件中 my.greeting.enabled=true (或未设置) 时，此配置才生效</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;my.greeting&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入属性类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GreetingProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GreetingAutoConfiguration</span><span class="params">(GreetingProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GreetingService <span class="title function_">greetingService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用配置的属性来创建GreetingService的Bean</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GreetingService</span>(properties.getPrefix(), properties.getSuffix());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>@ConditionalOnProperty</code></strong> 非常关键！<code>matchIfMissing = true</code> 表示如果用户没有配置<code>my.greeting.enabled</code>，则默认此条件满足（即默认启用），这是一种很好的设计。</p>
</blockquote>
<p><strong>5. 创建 <code>spring.factories</code> 文件</strong></p>
<p>这是Spring Boot发现我们自动配置类的入口。</p>
<p>在 <code>src/main/resources/META-INF/</code> 目录下创建 <code>spring.factories</code> 文件。</p>
<p><strong>路径</strong>: <code>my-greeting-spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories</code></p>
<p><strong>内容</strong>:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auto Configuration</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.example.greeting.autoconfigure.GreetingAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果类名很长，可以使用 <code>\</code> 来换行。确保类的完整路径名是正确的。</p>
</blockquote>
<p>至此，<code>autoconfigure</code>模块就完成了。</p>
<hr>
<p><strong>步骤 3: 实现 <code>starter</code> 模块</strong></p>
<p>这个模块非常简单。</p>
<p><strong>1. <code>pom.xml</code> for <code>starter</code></strong></p>
<p>它只需要依赖于<code>autoconfigure</code>模块。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这个模块的唯一职责就是传递依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个模块甚至不需要<code>src</code>目录。</p>
<hr>
<p><strong>步骤 4: 构建和安装</strong></p>
<p>在父项目的根目录下，执行Maven命令，将我们的Starter安装到本地仓库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>步骤 5: 使用我们的自定义Starter</strong></p>
<p>现在，我们可以像使用官方Starter一样使用它了。</p>
<p><strong>1. 创建一个新的Spring Boot应用</strong></p>
<p><strong>2. 在 <code>pom.xml</code> 中引入我们的Starter</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 在 <code>application.properties</code> 中进行配置</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义问候语</span></span><br><span class="line"><span class="attr">my.greeting.prefix</span>=<span class="string">Welcome, Mr/Ms. </span></span><br><span class="line"><span class="attr">my.greeting.suffix</span>=<span class="string">. Have a nice day!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 如果想禁用这个功能，可以设置</span></span><br><span class="line"><span class="comment"># my.greeting.enabled=false</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 在代码中使用 <code>GreetingService</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demouser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.greeting.autoconfigure.GreetingService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoUserApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GreetingService greetingService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoUserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (greetingService != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> greetingService.greet(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;GreetingService not available.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Welcome, Mr/Ms. Alice. Have a nice day!</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h5><p><strong>起步依赖 (Starters) 是 Spring Boot “约定优于配置” 理念的基石</strong>。它通过将复杂的依赖关系和版本管理封装起来，将开发者从繁琐的配置工作中解放出来，使其能够更专注于业务逻辑的实现。这是Spring Boot能够如此流行和高效的关键原因之一。</p>
<hr>
<h4 id="1-1-2-自动配置"><a href="#1-1-2-自动配置" class="headerlink" title="1.1.2 自动配置"></a>1.1.2 自动配置</h4><h5 id="1-问题背景：Starter之后还缺什么？"><a href="#1-问题背景：Starter之后还缺什么？" class="headerlink" title="1. 问题背景：Starter之后还缺什么？"></a>1. 问题背景：Starter之后还缺什么？</h5><p>在上一节的**起步依赖 (Starter)<strong>解决了</strong>“需要哪些依赖”**的问题，帮我们自动引入了一整套JAR包。但仅仅有JAR包是不够的。</p>
<p>在传统的Spring应用中，即使引入了所有依赖，我们仍然需要手动编写大量的Java配置（或XML）来“激活”和“组装”这些依赖中的组件。例如，引入了<code>spring-boot-starter-jdbc</code>后，我们还需要手动配置：</p>
<ul>
<li><code>DataSource</code> Bean (数据源)</li>
<li><code>JdbcTemplate</code> Bean</li>
<li><code>PlatformTransactionManager</code> Bean (事务管理器)</li>
</ul>
<p>我们需要告诉Spring：“我引入了数据库驱动和连接池，请帮我创建一个<code>DataSource</code>；我还想用<code>JdbcTemplate</code>来操作数据库，也请帮我创建一个实例并把<code>DataSource</code>注入进去。”</p>
<p>这个“告诉”的过程，就是<strong>配置</strong>。如果每个项目都需要重复编写这些几乎一模一样的“样板代码”，那效率依然很低。</p>
<hr>
<h5 id="2-解决方案：Spring-Boot-自动配置"><a href="#2-解决方案：Spring-Boot-自动配置" class="headerlink" title="2. 解决方案：Spring Boot 自动配置"></a>2. 解决方案：Spring Boot 自动配置</h5><p>自动配置的核心思想是：<strong>Spring Boot 尝试根据你项目中引入的依赖（即类路径下的JAR包），自动猜测你可能需要哪些Bean，并智能地为你创建和配置好它们。</strong></p>
<hr>
<h5 id="3-工作原理：三大核心组件"><a href="#3-工作原理：三大核心组件" class="headerlink" title="3. 工作原理：三大核心组件"></a>3. 工作原理：三大核心组件</h5><p>Spring Boot的自动配置魔法主要依赖于以下三个组件的协同工作：</p>
<p><strong>A. <code>@SpringBootApplication</code> 注解</strong></p>
<p>这是我们启动类的入口注解，它是一个复合注解，其中最重要的一个元注解是：</p>
<ul>
<li><strong><code>@EnableAutoConfiguration</code></strong>：这个注解是<strong>开启自动配置功能的总开关</strong>。它告诉Spring Boot：“请启动你的智能探测模式，开始自动配置吧！”</li>
</ul>
<p><strong>B. <code>spring.factories</code> 文件</strong></p>
<p><code>@EnableAutoConfiguration</code> 是如何知道有哪些自动配置可以应用的呢？答案就在<code>spring-boot-autoconfigure.jar</code>这个JAR包里的 <code>META-INF/spring.factories</code> 文件中。</p>
<ul>
<li><p><strong>这是一个“自动配置清单”</strong>。打开这个文件，你会看到一个巨大的列表，以键值对的形式存在：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string"># ... 还有几百行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring Boot启动时，会加载所有JAR包中<code>META-INF/spring.factories</code>文件里<code>EnableAutoConfiguration</code>键下的<strong>所有配置类</strong>。</p>
</li>
</ul>
<p><strong>C. 条件化配置 (<code>@ConditionalOn...</code>)</strong></p>
<p>Spring Boot加载了上百个自动配置类，但显然我们不需要所有的功能。那么Spring Boot是如何决定哪个配置类应该生效呢？<strong>答案是：条件判断</strong>。</p>
<ul>
<li><strong>每一个自动配置类（如 <code>DataSourceAutoConfiguration</code>）都被 <code>@ConditionalOn...</code> 系列注解所标记。</strong></li>
<li>这些注解定义了该配置类生效的<strong>条件</strong>。只有当<strong>所有条件都满足</strong>时，这个自动配置类才会生效，它内部定义的<code>@Bean</code>才会被创建。</li>
</ul>
<p><strong>常见的条件注解：</strong></p>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@ConditionalOnClass</code></strong></td>
<td align="left"><strong>类路径下存在指定的类</strong>时，条件满足。 (这是最常用的)</td>
<td align="left"><code>@ConditionalOnClass(DataSource.class)</code>: 只有当有数据源实现时才生效</td>
</tr>
<tr>
<td align="left"><strong><code>@ConditionalOnMissingBean</code></strong></td>
<td align="left"><strong>容器中不存在指定类型的Bean</strong>时，条件满足。 (防止用户自定义的Bean被覆盖)</td>
<td align="left"><code>@ConditionalOnMissingBean(DataSource.class)</code>: 如果用户自己配了数据源，我就不配了</td>
</tr>
<tr>
<td align="left"><strong><code>@ConditionalOnBean</code></strong></td>
<td align="left"><strong>容器中已存在指定类型的Bean</strong>时，条件满足。</td>
<td align="left"><code>@ConditionalOnBean(DataSource.class)</code>: 只有数据源存在时，才配JdbcTemplate</td>
</tr>
<tr>
<td align="left"><strong><code>@ConditionalOnProperty</code></strong></td>
<td align="left"><strong>配置文件中有指定的属性且值匹配</strong>时，条件满足。</td>
<td align="left"><code>@ConditionalOnProperty(name=&quot;spring.jpa.open-in-view&quot;, havingValue=&quot;true&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong><code>@ConditionalOnResource</code></strong></td>
<td align="left"><strong>类路径下存在指定的资源文件</strong>时，条件满足。</td>
<td align="left"><code>@ConditionalOnResource(resources=&quot;classpath:db/migration&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong><code>@ConditionalOnWebApplication</code></strong></td>
<td align="left"><strong>当前是一个Web应用</strong>时，条件满足。</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong><code>@ConditionalOnExpression</code></strong></td>
<td align="left">**SpEL表达式返回<code>true</code>**时，条件满足。 (最灵活)</td>
<td align="left"><code>@ConditionalOnExpression(&quot;${spring.jmx.enabled:true}&quot;)</code></td>
</tr>
</tbody></table>
<hr>
<h5 id="4-一个完整的例子：DataSource的自动配置流程"><a href="#4-一个完整的例子：DataSource的自动配置流程" class="headerlink" title="4. 一个完整的例子：DataSource的自动配置流程"></a>4. 一个完整的例子：<code>DataSource</code>的自动配置流程</h5><ol>
<li><strong>启动</strong>：你的应用启动，<code>@SpringBootApplication</code> 中的 <code>@EnableAutoConfiguration</code> 生效。</li>
<li><strong>加载清单</strong>：Spring Boot读取所有<code>spring.factories</code>文件，加载了包括 <code>DataSourceAutoConfiguration</code> 在内的上百个配置类。</li>
<li><strong>条件判断</strong>：轮到 <code>DataSourceAutoConfiguration</code> 进行判断了：<ul>
<li><strong>检查 <code>@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })</code></strong>: 你在<code>pom.xml</code>中加入了<code>spring-boot-starter-jdbc</code>，它传递依赖了<code>HikariCP.jar</code> (一个DataSource实现)，所以类路径下存在<code>DataSource.class</code>。<strong>条件满足</strong>。</li>
<li><strong>检查 <code>@ConditionalOnMissingBean(DataSource.class)</code></strong>: Spring Boot会检查容器里是不是已经有一个<code>DataSource</code>类型的Bean了。因为你没有自己手动配置，所以<strong>条件满足</strong>。</li>
</ul>
</li>
<li><strong>生效</strong>：所有条件都满足，<code>DataSourceAutoConfiguration</code> 这个配置类<strong>正式生效</strong>。</li>
<li><strong>创建Bean</strong>：Spring Boot开始执行 <code>DataSourceAutoConfiguration</code> 内部被<code>@Bean</code>注解的方法，该方法会读取你的<code>application.properties</code>中的<code>spring.datasource.url</code>等属性，为你创建一个配置好的<code>DataSource</code> Bean，并放入IoC容器。</li>
</ol>
<p><strong>用户覆盖</strong>：如果你在自己的<code>@Configuration</code>类里手动配置了一个<code>DataSource</code> Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">myCustomDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 你的自定义配置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyDataSource</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在第3步中，<code>@ConditionalOnMissingBean(DataSource.class)</code> 的条件就会<strong>不满足</strong>，<code>DataSourceAutoConfiguration</code> 就会<strong>自动失效</strong>，完全尊重你的自定义配置。</p>
<hr>
<h5 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h5><p><strong>自动配置是Spring Boot“约定优于配置”理念的终极体现</strong>。它通过**<code>@EnableAutoConfiguration</code><strong>、</strong><code>spring.factories</code><strong>和</strong><code>@ConditionalOn...</code>**三驾马车的协同工作，实现了对项目依赖的智能分析和对Bean的按需、动态配置。这使得开发者可以从大量的样板配置中解脱出来，真正做到“引入即用，按需覆盖”。</p>
<hr>
<h4 id="1-1-3-嵌入式Web服务器"><a href="#1-1-3-嵌入式Web服务器" class="headerlink" title="1.1.3 嵌入式Web服务器"></a>1.1.3 嵌入式Web服务器</h4><h5 id="1-问题背景：传统的Web应用部署方式"><a href="#1-问题背景：传统的Web应用部署方式" class="headerlink" title="1. 问题背景：传统的Web应用部署方式"></a>1. 问题背景：传统的Web应用部署方式</h5><p>在 Spring Boot 出现之前，开发和部署一个Java Web应用通常遵循以下步骤：</p>
<ol>
<li><strong>项目打包</strong>：将整个Web应用（包括所有Java类、资源文件、库文件和<code>WEB-INF/web.xml</code>）打包成一个 <strong>WAR (Web Application Archive)</strong> 文件。</li>
<li><strong>准备外部服务器</strong>：需要在服务器上预先安装并配置一个独立的 <strong>Servlet 容器</strong>，最常见的就是 <strong>Apache Tomcat</strong>。此外还有 Jetty、Undertow 等。</li>
<li><strong>手动部署</strong>：运维人员需要将打好的 WAR 包<strong>复制</strong>到 Tomcat 的 <code>webapps</code> 目录下。</li>
<li><strong>启动服务器</strong>：启动外部的 Tomcat 服务器。Tomcat 会自动解压并加载 WAR 包，启动Web应用。</li>
</ol>
<p><strong>这种传统方式的痛点：</strong></p>
<ul>
<li><strong>环境依赖重</strong>：应用无法独立运行，它强依赖于外部的服务器环境。开发、测试和生产环境的Tomcat版本和配置可能不一致，导致“在我机器上是好的”问题。</li>
<li><strong>部署流程繁琐</strong>：需要下载、安装、配置服务器，然后是“打包-&gt;拷贝-&gt;启动”的部署流程，自动化程度低，效率不高。</li>
<li><strong>应用臃肿</strong>：WAR 包的结构相对复杂。</li>
<li><strong>不符合微服务理念</strong>：在微服务架构中，我们希望每个服务都是一个独立的、自包含的、可以快速启动和销毁的进程。传统部署方式显然过于“笨重”。</li>
</ul>
<hr>
<h5 id="2-解决方案：Spring-Boot的嵌入式服务器"><a href="#2-解决方案：Spring-Boot的嵌入式服务器" class="headerlink" title="2. 解决方案：Spring Boot的嵌入式服务器"></a>2. 解决方案：Spring Boot的嵌入式服务器</h5><p>Spring Boot 彻底颠覆了这种模式。它的核心思想是：<strong>“应用自带服务器，而不是将应用部署到服务器”</strong>。</p>
<ul>
<li><strong>核心定义</strong>：嵌入式Web服务器意味着 <strong>Servlet容器（如Tomcat）不再是一个需要外部安装的独立软件，而是作为一个普通的库（JAR包）被直接包含在你的应用程序中</strong>。</li>
<li><strong>工作原理</strong>：<ol>
<li>当你引入 <code>spring-boot-starter-web</code> 这个起步依赖时，它会通过传递性依赖，自动将 <code>spring-boot-starter-tomcat</code> 添加到你的项目中。</li>
<li><code>spring-boot-starter-tomcat</code> 依赖了 <code>tomcat-embed-core.jar</code>, <code>tomcat-embed-el.jar</code> 等Tomcat的核心库文件。</li>
<li>当你的Spring Boot应用通过 <code>main</code> 方法启动时，Spring Boot的自动配置机制会检测到类路径下存在Tomcat的JAR包。</li>
<li><code>ServletWebServerFactoryAutoConfiguration</code> 这个自动配置类就会生效，它会在<strong>应用程序内部</strong>，通过<strong>Java代码</strong>来<strong>启动一个Tomcat实例</strong>，并完成所有必要的配置（如设置端口、上下文路径等）。</li>
<li>最后，Spring Boot会将自己的核心组件 <code>DispatcherServlet</code> 注册到这个内嵌的Tomcat实例中。</li>
</ol>
</li>
</ul>
<p>整个过程对开发者是完全透明的。你所做的，仅仅是运行了一个普通的Java <code>main</code> 方法。</p>
<hr>
<h5 id="3-打包与运行方式的变革"><a href="#3-打包与运行方式的变革" class="headerlink" title="3. 打包与运行方式的变革"></a>3. 打包与运行方式的变革</h5><p>由于服务器被内嵌了，Spring Boot应用的打包和运行方式也发生了根本性的变化：</p>
<ul>
<li><p><strong>打包成可执行JAR (Executable JAR)</strong>：Spring Boot应用通常被打包成一个<strong>单一的、可执行的JAR文件</strong>。这个JAR文件包含了你所有的业务代码、依赖库，以及<strong>嵌入式服务器本身</strong>。</p>
</li>
<li><p><strong>简化运行</strong>：部署和运行这个应用变得异常简单，只需要一个Java环境即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只需要一行命令，应用就带着自己的Tomcat服务器启动了</span></span><br><span class="line">java -jar my-application.jar </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-带来的核心优势-1"><a href="#4-带来的核心优势-1" class="headerlink" title="4. 带来的核心优势"></a>4. 带来的核心优势</h5><ol>
<li><strong>环境无关，独立运行</strong>：<ul>
<li>应用是<strong>自包含的 (self-contained)</strong>，不再依赖任何外部的Web服务器。只要有JRE，就可以处处运行，彻底解决了环境不一致的问题。</li>
</ul>
</li>
<li><strong>部署极简，运维友好</strong>：<ul>
<li>部署过程从“打包-&gt;拷贝-&gt;启动外部服务器”简化为“上传单个JAR文件-&gt;执行<code>java -jar</code>命令”。</li>
<li>这对于自动化部署（CI&#x2F;CD）、容器化（Docker）和云原生环境极为友好。</li>
</ul>
</li>
<li><strong>开发体验佳</strong>：<ul>
<li>开发者可以直接在IDE中像运行普通Java程序一样启动和调试Web应用，无需配置和管理外部Tomcat，开发效率大大提升。</li>
</ul>
</li>
<li><strong>微服务架构的完美匹配</strong>：<ul>
<li>每个微服务都可以打包成一个独立的、轻量级的可执行JAR，易于管理、水平扩展和快速迭代。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="5-服务器的切换"><a href="#5-服务器的切换" class="headerlink" title="5. 服务器的切换"></a>5. 服务器的切换</h5><p>Spring Boot不仅默认集成了Tomcat，还支持Jetty和Undertow。切换服务器非常简单，只需在 <code>pom.xml</code> 中进行简单的修改。</p>
<p>例如，想从Tomcat切换到Undertow：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 排除默认的Tomcat依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 添加Undertow的Starter依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>只需这样修改，你的应用下次启动时，内部运行的就会是Undertow服务器，而你的业务代码无需任何改动。</p>
<hr>
<h5 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h5><p><strong>嵌入式Web服务器是Spring Boot实现快速开发和简化部署的“杀手锏”</strong>。它将复杂的服务器管理工作完全内化，让开发者可以像开发普通Java应用一样开发Web应用。这种“应用自带服务器”的模式，不仅极大地提升了开发和运维效率，也完美契-合了现代微服务和云原生架构的理念。</p>
<hr>
<h4 id="1-1-4-外部化配置"><a href="#1-1-4-外部化配置" class="headerlink" title="1.1.4 外部化配置"></a>1.1.4 外部化配置</h4><h5 id="1-问题背景：硬编码配置的弊端"><a href="#1-问题背景：硬编码配置的弊端" class="headerlink" title="1. 问题背景：硬编码配置的弊端"></a>1. 问题背景：硬编码配置的弊端</h5><p>在软件开发中，我们经常需要处理一些可变的配置信息，例如：</p>
<ul>
<li>数据库连接URL、用户名、密码</li>
<li>服务器端口号</li>
<li>第三方API的密钥</li>
<li>日志级别</li>
<li>功能开关（Feature Toggles）</li>
</ul>
<p>最糟糕的做法是将这些值<strong>硬编码 (Hard-coded)</strong> 在代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是非常糟糕的实践！</span></span><br><span class="line"><span class="type">int</span> <span class="variable">serverPort</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dbUrl</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/prod_db&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>硬编码的弊端显而易见：</strong></p>
<ol>
<li><strong>缺乏灵活性</strong>：如果需要将应用从开发环境部署到生产环境，数据库地址变了，端口号也变了。这时你必须<strong>修改源代码，重新编译、打包和部署</strong>整个应用。这个过程既耗时又风险高。</li>
<li><strong>安全性差</strong>：将敏感信息（如密码、密钥）直接写入代码，意味着任何能看到源码的人都能看到这些机密。</li>
<li><strong>难以管理</strong>：配置散落在代码的各个角落，难以集中查看和修改。</li>
</ol>
<hr>
<h5 id="2-解决方案：Spring-Boot的外部化配置"><a href="#2-解决方案：Spring-Boot的外部化配置" class="headerlink" title="2. 解决方案：Spring Boot的外部化配置"></a>2. 解决方案：Spring Boot的外部化配置</h5><p>Spring Boot的外部化配置机制，就是为了解决这个问题。</p>
<ul>
<li><strong>核心定义</strong>：外部化配置允许你<strong>将配置信息从应用程序代码中分离出来，存储在外部文件中或环境中</strong>。这样，你可以在<strong>不修改任何代码</strong>的情况下，通过改变外部配置来影响和控制应用程序的行为。</li>
<li><strong>形象的比喻</strong>：<ul>
<li>你的应用程序就像一台<strong>精密的机器</strong>（比如一台数控机床）。</li>
<li><strong>硬编码</strong>就像是把机器的运行参数（切割速度、钻头尺寸）<strong>焊死</strong>在机器内部。每次想加工不同零件，都得把机器拆开重新焊接。</li>
<li><strong>外部化配置</strong>则像为这台机器提供了一个<strong>控制面板</strong>（<code>application.properties</code>文件）和<strong>外部接口</strong>（环境变量）。操作员（运维人员）只需在控制面板上调整参数，或者通过接口发送指令，就能让机器执行不同的任务，而无需触碰机器内部的任何线路。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-Spring-Boot支持的配置源"><a href="#3-Spring-Boot支持的配置源" class="headerlink" title="3. Spring Boot支持的配置源"></a>3. Spring Boot支持的配置源</h5><p>Spring Boot非常强大，它支持从多种不同的外部位置加载配置。这些配置源按<strong>优先级</strong>从高到低排列（高优先级的配置会覆盖低优先级的同名配置）：</p>
<ol>
<li><p><strong>命令行参数 (Command-Line Arguments)</strong></p>
<ul>
<li>在启动应用时通过命令行直接传入。</li>
<li>示例：<code>java -jar my-app.jar --server.port=9090</code></li>
<li><strong>优先级最高</strong>，常用于临时覆盖特定配置。</li>
</ul>
</li>
<li><p><strong>Java系统属性 ( <code>System.getProperties()</code> )</strong></p>
<ul>
<li>通过 <code>-D</code> 参数设置。</li>
<li>示例：<code>java -Dserver.port=9090 -jar my-app.jar</code></li>
</ul>
</li>
<li><p><strong>操作系统环境变量 (OS Environment Variables)</strong></p>
<ul>
<li>配置在操作系统级别的变量。</li>
<li>格式需要转换：<code>SERVER_PORT=9090</code> 会被自动映射为 <code>server.port</code>。</li>
</ul>
</li>
<li><p><strong>JAR包外部的 <code>application-{profile}.properties</code> 或 <code>application-{profile}.yml</code> 文件</strong></p>
<ul>
<li><p>与JAR包放在<strong>同一目录</strong>下的配置文件。</p>
</li>
<li><p>这是<strong>生产环境中最常用的覆盖方式</strong>。运维人员可以直接在服务器上创建或修改这个文件，而无需解压JAR包。</p>
</li>
<li><p>示例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/opt/app/</span><br><span class="line">├── my-app.jar</span><br><span class="line">└── application.properties  &lt;-- 这个文件的优先级高于JAR包内部的</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>JAR包内部的 <code>application-{profile}.properties</code> 或 <code>application-{profile}.yml</code> 文件</strong></p>
<ul>
<li>打包在 <code>src/main/resources</code> 目录下的，针对不同环境（profile）的配置文件，如 <code>application-dev.properties</code>，<code>application-prod.properties</code>。</li>
</ul>
</li>
<li><p><strong>JAR包内部的 <code>application.properties</code> 或 <code>application.yml</code> 文件</strong></p>
<ul>
<li>打包在 <code>src/main/resources</code> 目录下的默认配置文件。通常存放一些通用的、默认的配置。</li>
<li><strong>优先级最低</strong>。</li>
</ul>
</li>
<li><p><strong><code>@PropertySource</code> 注解</strong></p>
<ul>
<li>可以在<code>@Configuration</code>类上通过此注解加载额外的自定义配置文件。</li>
</ul>
</li>
</ol>
<p><strong>优先级规则总结</strong>：<strong>离代码越“远”的配置，优先级越高</strong>。命令行（最远） &gt; 包外文件 &gt; 包内文件（最近）。这个设计哲学使得运维人员可以轻松地在外部覆盖掉开发者在代码包里设置的默认值。</p>
<hr>
<h5 id="4-如何在代码中使用配置"><a href="#4-如何在代码中使用配置" class="headerlink" title="4. 如何在代码中使用配置"></a>4. 如何在代码中使用配置</h5><p>Spring Boot提供了两种主要的方式来将这些外部配置注入到你的Bean中：</p>
<p><strong>A. <code>@Value</code> 注解</strong></p>
<ul>
<li><p>用于注入<strong>单个</strong>配置属性。</p>
</li>
<li><p>语法：<code>@Value(&quot;${property.name:defaultValue}&quot;)</code></p>
<ul>
<li><code>${...}</code> 是占位符语法。</li>
<li><code>:defaultValue</code> 是可选的，当配置项不存在时，会使用这个默认值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfigReader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myapp.custom.greeting:Hello World&#125;&quot;)</span> <span class="comment">// 提供默认值</span></span><br><span class="line">    <span class="keyword">private</span> String greetingMessage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server Port: &quot;</span> + serverPort);</span><br><span class="line">        System.out.println(<span class="string">&quot;Greeting: &quot;</span> + greetingMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>B. <code>@ConfigurationProperties</code> 注解（更推荐）</strong></p>
<ul>
<li><p>用于将<strong>一组</strong>相关的配置属性<strong>批量</strong>、<strong>类型安全</strong>地绑定到一个Java对象（POJO）上。</p>
</li>
<li><p><strong>优势</strong>：</p>
<ol>
<li><strong>类型安全</strong>：如果配置文件中的值无法转换为目标类型（如把”abc”配给<code>int</code>类型），应用启动时会报错。</li>
<li><strong>结构化</strong>：将相关的配置组织在一个类中，代码更清晰。</li>
<li><strong>强大的IDE支持</strong>：IDE可以为<code>@ConfigurationProperties</code>类提供自动补全和元数据提示。</li>
</ol>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li><p><strong><code>application.properties</code></strong>:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myapp.auth.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">myapp.auth.password</span>=<span class="string">secret123</span></span><br><span class="line"><span class="attr">myapp.auth.timeout</span>=<span class="string">30s</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>属性绑定类 <code>AuthConfig.java</code></strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;myapp.auth&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Duration timeout; <span class="comment">// Spring Boot能自动转换 &quot;30s&quot; 为 Duration 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在其他地方使用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthConfig authConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 直接使用 authConfig 对象的属性</span></span><br><span class="line">    System.out.println(authConfig.getUsername());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5. 总结"></a>5. 总结</h5><p><strong>外部化配置是构建健壮、可维护、适应多环境部署的应用程序的基石</strong>。Spring Boot通过其<strong>分层的配置加载机制</strong>和便捷的<strong>属性注入方式（<code>@Value</code> 和 <code>@ConfigurationProperties</code>）</strong>，提供了一套极其强大和灵活的配置解决方案。这使得同一份应用程序代码，无需任何修改，就能通过外部配置的调整，无缝地在开发、测试、生产等不同环境中运行。</p>
<hr>
<h3 id="1-2-SpringBootApplication注解刨析"><a href="#1-2-SpringBootApplication注解刨析" class="headerlink" title="1.2 @SpringBootApplication注解刨析"></a>1.2 <code>@SpringBootApplication</code>注解刨析</h3><p><code>@SpringBootApplication</code> 是一个典型的 Spring <strong>复合注解 (Composite Annotation)</strong>。它由其他三个核心注解组合而成。目的是为了简化配置，让开发者只需一个注解就能开启 Spring Boot 的所有核心功能。</p>
<p>我们可以通过查看其源码来一探究竟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">// 核心在这里！下面三个注解才是它的真身</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">// ... 注解的属性定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以清晰地看到，<code>@SpringBootApplication</code> 主要由以下三个注解构成：</p>
<ol>
<li><code>@SpringBootConfiguration</code></li>
<li><code>@EnableAutoConfiguration</code></li>
<li><code>@ComponentScan</code></li>
</ol>
<p>下面我们来逐一剖析这“三位一体”的真正含义。</p>
<hr>
<h4 id="1-2-1-SpringBootConfiguration"><a href="#1-2-1-SpringBootConfiguration" class="headerlink" title="1.2.1 @SpringBootConfiguration"></a>1.2.1 <code>@SpringBootConfiguration</code></h4><ul>
<li><p><strong>作用</strong>：声明当前类是一个 <strong>Spring Boot 的配置类</strong>。</p>
</li>
<li><p><strong>深层剖析</strong>：我们再次点进 <code>@SpringBootConfiguration</code> 的源码会发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">// &lt;-- 核心在这里！</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它本质上就是 Spring 框架的 <strong><code>@Configuration</code></strong> 注解。</p>
</li>
<li><p><strong>意义</strong>：</p>
<ol>
<li><strong>语义化</strong>：它在语义上表明这是一个Spring Boot应用的主配置类，而不仅仅是一个普通的Spring配置类。</li>
<li><strong>Bean定义</strong>：被 <code>@Configuration</code> 标记的类，意味着我们可以在这个类中使用 <code>@Bean</code> 注解来手动定义和注册Bean到IoC容器中。</li>
<li><strong>单例保证</strong>：Spring 会为 <code>@Configuration</code> 类创建一个CGLIB代理，以确保通过方法调用获取Bean时能遵循其作用域（如单例）。</li>
</ol>
</li>
</ul>
<p><strong>一句话总结 <code>@SpringBootConfiguration</code></strong>：它就是 <code>@Configuration</code>，表明启动类本身也是一个IoC容器的配置源。</p>
<hr>
<h4 id="1-2-2-EnableAutoConfiguration"><a href="#1-2-2-EnableAutoConfiguration" class="headerlink" title="1.2.2 @EnableAutoConfiguration"></a>1.2.2 <code>@EnableAutoConfiguration</code></h4><ul>
<li><strong>作用</strong>：这是 <strong>开启自动配置功能的主开关</strong>。</li>
<li><strong>深层剖析</strong>：它通过 <code>@Import(AutoConfigurationImportSelector.class)</code> 来实现其核心功能。<ul>
<li><code>AutoConfigurationImportSelector</code> 这个类会去扫描所有引入的JAR包中 <code>META-INF/spring.factories</code> 文件。</li>
<li>它会找到 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 这个键所对应的所有自动配置类（如 <code>DataSourceAutoConfiguration</code>, <code>WebMvcAutoConfiguration</code> 等）。</li>
<li>然后，它会将这个庞大的配置类列表加载到Spring IoC容器中。</li>
<li>最后，每个自动配置类会根据自身的 <code>@ConditionalOn...</code> 条件来判断自己是否应该生效。</li>
</ul>
</li>
</ul>
<p><strong>一句话总结 <code>@EnableAutoConfiguration</code></strong>：它负责启动Spring Boot的自动配置引擎，让Spring Boot根据类路径的依赖来智能地配置应用。</p>
<hr>
<h4 id="3-ComponentScan"><a href="#3-ComponentScan" class="headerlink" title="3. @ComponentScan"></a><strong>3. <code>@ComponentScan</code></strong></h4><ul>
<li><strong>作用</strong>：开启 <strong>组件扫描</strong>，自动发现并注册被特定注解（如<code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>）标记的类为Bean。</li>
<li><strong>深层剖析</strong>：<ul>
<li><strong>默认扫描范围</strong>：<code>@SpringBootApplication</code> 中的 <code>@ComponentScan</code> <strong>没有指定 <code>basePackages</code> 属性</strong>。在这种情况下，它的默认扫描范围是<strong>当前启动类所在的包及其所有子包</strong>。</li>
<li><strong>最佳实践</strong>：正是因为这个默认行为，官方强烈建议将启动类放在一个<strong>根包 (root package)</strong> 下，例如 <code>com.example.myapp</code>。这样，你所有的业务代码（如 <code>com.example.myapp.controller</code>, <code>com.example.myapp.service</code>）都会自然而然地被扫描到。</li>
</ul>
</li>
</ul>
<p><strong>目录结构示例 (推荐):</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">└── example</span><br><span class="line">    └── myapp</span><br><span class="line">        ├── Application.java          &lt;-- 启动类在这里</span><br><span class="line">        ├── controller</span><br><span class="line">        │   └── UserController.java</span><br><span class="line">        ├── service</span><br><span class="line">        │   └── UserServiceImpl.java</span><br><span class="line">        └── repository</span><br><span class="line">            └── UserRepository.java</span><br></pre></td></tr></table></figure>

<p>在这个结构中，<code>Application.java</code> 上的 <code>@ComponentScan</code> 会自动扫描到 <code>controller</code>, <code>service</code>, <code>repository</code> 包下的所有组件。</p>
<p><strong>一句话总结 <code>@ComponentScan</code></strong>：它负责扫描并注册我们自己编写的业务类Bean。</p>
<hr>
<h4 id="1-2-3-总结"><a href="#1-2-3-总结" class="headerlink" title="1.2.3 总结"></a>1.2.3 总结</h4><p><code>@SpringBootApplication</code> 这个看似简单的注解，实际上协同完成了Spring Boot应用初始化的三大核心任务：</p>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">扮演的角色</th>
<th align="left">职责</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@SpringBootConfiguration</code></strong></td>
<td align="left"><strong>配置源 (Configuration Source)</strong></td>
<td align="left">将启动类自身标识为一个配置类，允许在其中定义 <code>@Bean</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>@EnableAutoConfiguration</code></strong></td>
<td align="left"><strong>配置引擎 (Engine)</strong></td>
<td align="left">开启自动配置，让Spring Boot根据依赖智能地“猜测”并配置所需的Bean。</td>
</tr>
<tr>
<td align="left"><strong><code>@ComponentScan</code></strong></td>
<td align="left"><strong>扫描器 (Scanner)</strong></td>
<td align="left">扫描并注册我们自己编写的 <code>@Component</code> 等业务Bean。</td>
</tr>
</tbody></table>
<p>这三个注解共同作用，使得Spring Boot应用能够：</p>
<ol>
<li><strong>自我配置</strong>（通过 <code>@EnableAutoConfiguration</code>）。</li>
<li><strong>发现我们自己的组件</strong>（通过 <code>@ComponentScan</code>）。</li>
<li><strong>允许我们进行额外的自定义配置</strong>（通过 <code>@SpringBootConfiguration</code> 和 <code>@Bean</code>）。</li>
</ol>
<p>最终，它们将所有自动配置的Bean和我们自己定义的Bean汇集到同一个Spring IoC容器中，构建出一个功能完备的应用程序。</p>
<hr>
<h4 id="1-2-4-自定义属性"><a href="#1-2-4-自定义属性" class="headerlink" title="1.2.4 自定义属性"></a>1.2.4 自定义属性</h4><p><code>@SpringBootApplication</code> 注解还提供了一些属性，允许我们进行微调，最常用的是 <code>exclude</code>：</p>
<ul>
<li><p><strong><code>exclude</code></strong>：如果我们想禁用某个特定的自动配置，可以使用这个属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用数据源的自动配置</span></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这在某些特定场景下（比如你想完全手动控制数据源配置）非常有用。</p>
<hr>
<h3 id="1-3-SpringApplication-启动流程"><a href="#1-3-SpringApplication-启动流程" class="headerlink" title="1.3 SpringApplication 启动流程"></a>1.3 SpringApplication 启动流程</h3><p>我们所有Spring Boot应用的入口都是一个简单的 <code>main</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(MyApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这行看似简单的 <code>SpringApplication.run()</code> 代码，背后隐藏了一个精心设计的、高度可扩展的启动流程。整个流程可以分为两大阶段：</p>
<ol>
<li><strong><code>SpringApplication</code> 实例的初始化阶段</strong></li>
<li><strong><code>run()</code> 方法的执行阶段</strong></li>
</ol>
<hr>
<h4 id="第一阶段：SpringApplication-实例初始化"><a href="#第一阶段：SpringApplication-实例初始化" class="headerlink" title="第一阶段：SpringApplication 实例初始化"></a><strong>第一阶段：<code>SpringApplication</code> 实例初始化</strong></h4><p>在 <code>run()</code> 方法被调用时，首先会创建一个 <code>SpringApplication</code> 的实例。这个构造函数的过程主要是为后续的启动做准备工作。</p>
<p><code>public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</code></p>
<p>这个构造函数主要做了以下几件重要的事情：</p>
<ol>
<li><strong>确定应用类型 (Deduce Web Application Type)</strong>:<ul>
<li>Spring Boot 会检查类路径中是否存在特定的类来判断当前应用的类型。</li>
<li>如果 classpath 中存在 <code>DispatcherHandler</code> 并且不存在 <code>DispatcherServlet</code>，则应用类型为 <strong><code>REACTIVE</code></strong> (响应式Web应用)。</li>
<li>如果两者都不存在，则应用类型为 <strong><code>NONE</code></strong> (非Web应用)。</li>
<li>否则，默认类型为 <strong><code>SERVLET</code></strong> (基于Servlet的传统Web应用)。</li>
<li>这个判断结果会决定后续是启动内嵌的Tomcat&#x2F;Jetty还是Netty，或者不启动任何Web服务器。</li>
</ul>
</li>
<li><strong>加载 <code>ApplicationContextInitializer</code>(应用上下文初始化器)</strong><ul>
<li>从 <code>META-INF/spring.factories</code> 文件中加载所有 <code>ApplicationContextInitializer</code> 的实现类。</li>
<li><code>ApplicationContextInitializer</code> 允许我们在 <code>ApplicationContext</code> <strong>刷新（refresh）之前</strong>，对其进行一些编程方式的初始化操作，是一个非常早期的扩展点。例如，注册额外的属性源。</li>
</ul>
</li>
<li><strong>加载 <code>ApplicationListener</code>(应用监听器)</strong><ul>
<li>同样从 <code>META-INF/spring.factories</code> 文件中加载所有 <code>ApplicationListener</code> 的实现类。</li>
<li><code>ApplicationListener</code> 用于监听 <code>SpringApplication</code> 在启动过程中发布的各种事件（如 <code>ApplicationStartingEvent</code>, <code>ApplicationReadyEvent</code> 等），从而在特定阶段执行自定义逻辑。</li>
<li>这些加载到的 Initializer 和 Listener 会被缓存到 <code>SpringApplication</code> 实例的成员变量中，等待后续在 <code>run</code> 阶段被调用。</li>
</ul>
</li>
<li><strong>确定主启动类 (Deduce Main Application Class)</strong>:<ul>
<li>通过分析当前的线程调用栈（<code>new RuntimeException().getStackTrace()</code>），推断出哪个类包含了 <code>main</code> 方法，并将其记录下来。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="第二阶段：run-方法执行流程-核心"><a href="#第二阶段：run-方法执行流程-核心" class="headerlink" title="第二阶段：run() 方法执行流程 (核心)"></a><strong>第二阶段：<code>run()</code> 方法执行流程 (核心)</strong></h4><p><code>run()</code> 方法是整个启动过程的核心，它编排了所有步骤，最终返回一个完全配置好的 <code>ApplicationContext</code>。</p>
<p>我们可以将其核心步骤概括为以下几点：</p>
<p><strong>Step 1: 创建并启动 <code>StopWatch</code></strong></p>
<ul>
<li>Spring Boot 使用 <code>StopWatch</code> 来记录整个启动过程各个阶段的耗时，方便开发者进行性能分析。</li>
</ul>
<p><strong>Step 2: 准备 <code>SpringApplicationRunListeners</code></strong></p>
<ul>
<li>这是一个关键的事件发布机制，它允许我们在启动过程的各个生命周期节点发布事件。</li>
<li>首先从<code>spring.factories</code>，加载所有 <code>SpringApplicationRunListener</code> 的实现类（默认是 <code>EventPublishingRunListener</code>）。</li>
<li><code>EventPublishingRunListener</code> 的作用就是将 Spring Boot 内部事件转化为标准的 Spring <code>ApplicationEvent</code>，并广播给所有在第一阶段注册的 <code>ApplicationListener</code>。</li>
<li>调用所有 <code>RunListener</code> 的 <code>starting()</code> 方法，标志着启动流程正式开始，<strong>发布 <code>ApplicationStartingEvent</code> 事件</strong>（但环境还未准备好）。</li>
</ul>
<p><strong>Step 3: 准备环境 (<code>Environment</code>)</strong></p>
<ul>
<li>根据之前推断的应用类型，创建一个合适的 <code>Environment</code> 对象（例如，<code>StandardServletEnvironment</code>）。</li>
<li><strong>配置加载</strong>：<code>Environment</code> 负责管理应用的配置信息。它会加载和合并来自各种属性源（PropertySource）的配置，包括：<ol>
<li>命令行参数 (<code>--server.port=9090</code>)。</li>
<li>JVM 系统属性 (<code>-D...</code>)。</li>
<li>操作系统环境变量。</li>
<li><code>application-{profile}.properties</code> 或 <code>.yml</code> 文件。</li>
<li><code>application.properties</code> 或 <code>.yml</code> 文件。</li>
<li><code>@PropertySource</code> 注解指定的配置文件。</li>
<li>默认属性。<br>（注意：优先级从上到下依次降低）</li>
</ol>
</li>
<li><strong>后处理</strong>：调用从 <code>spring.factories</code> 中加载的 <code>EnvironmentPostProcessor</code>，允许对 <code>Environment</code> 进行进一步的编程化修改。</li>
<li>将准备好的 <code>Environment</code> 绑定到 <code>SpringApplication</code> 实例。</li>
<li>调用 <code>RunListener</code> 的 <code>environmentPrepared()</code> 方法，并发布 <strong><code>ApplicationEnvironmentPreparedEvent</code></strong> 事件，通知监听者环境已经准备就绪，可以进行一些基于环境的调整了。</li>
</ul>
<p><strong>Step 4: 打印 Banner</strong></p>
<ul>
<li>读取 classpath 下的 <code>banner.txt</code> 文件（如果存在），并将 Spring Boot 的横幅打印到控制台。可以通过 <code>spring.main.banner-mode</code> 配置来控制其行为（<code>console</code>, <code>log</code>, <code>off</code>）。</li>
</ul>
<p><strong>Step 5: 创建 <code>ApplicationContext</code> (应用上下文)</strong></p>
<ul>
<li>根据第一阶段推断出的<strong>应用类型</strong>（<code>SERVLET</code>, <code>REACTIVE</code>, <code>NONE</code>），创建对应的 <code>ApplicationContext</code> 实例。<ul>
<li>Web应用 (<code>SERVLET</code>): 创建 <code>AnnotationConfigServletWebServerApplicationContext</code>。</li>
<li>响应式Web应用 (<code>REACTIVE</code>): 创建 <code>AnnotationConfigReactiveWebServerApplicationContext</code>。</li>
<li>非Web应用 (<code>NONE</code>): 创建 <code>AnnotationConfigApplicationContext</code>。</li>
</ul>
</li>
</ul>
<p><strong>Step 6: <code>prepareContext</code> - 上下文预处理</strong></p>
<p>在刷新上下文之前，进行一系列准备工作：</p>
<ul>
<li>将前面创建好的 <code>Environment</code> 设置到 <code>ApplicationContext</code> 中。</li>
<li>调用所有在第一阶段加载的 <strong><code>ApplicationContextInitializer</code></strong> 的 <code>initialize</code> 方法，对上下文进行定制化处理。</li>
<li>调用 <code>RunListener</code> 的 <code>contextPrepared()</code> 方法，并发布 <strong><code>ApplicationContextInitializedEvent</code></strong> 事件。</li>
<li>将主启动类（如 <code>MyApplication.class</code>）加载到 <code>ApplicationContext</code> 中，这是配置的入口点。</li>
<li>调用 <code>RunListener</code> 的 <code>contextLoaded()</code> 方法，并发布 <strong><code>ApplicationPreparedEvent</code></strong> 事件。</li>
</ul>
<p><strong>Step 7: <code>refreshContext</code> - 刷新上下文</strong></p>
<ul>
<li>这是整个启动流程<strong>最核心、最耗时</strong>的一步。它会调用 <code>ApplicationContext.refresh()</code> 方法。</li>
<li><strong><code>prepareRefresh()</code></strong>: 准备刷新，设置上下文状态。</li>
<li><strong><code>obtainFreshBeanFactory()</code></strong>: 创建 <code>DefaultListableBeanFactory</code>，也就是 Bean 工厂，用于管理所有的 Bean 定义和实例。</li>
<li><strong><code>prepareBeanFactory()</code></strong>: 对 Bean 工厂进行配置，比如设置类加载器、添加默认的 <code>BeanPostProcessor</code> 等。</li>
<li><strong><code>postProcessBeanFactory()</code></strong>: 子类扩展点。对于 Web 应用，这里会添加与 Web 相关的 <code>BeanPostProcessor</code>。</li>
<li><strong><code>invokeBeanFactoryPostProcessors()</code></strong>: <strong>【关键】</strong> 调用所有注册的 <code>BeanFactoryPostProcessor</code>。这是自动配置的核心，<code>@Configuration</code> 注解的解析、<code>@ComponentScan</code> 的扫描、<code>@Bean</code> 方法的定义、<code>@EnableAutoConfiguration</code> 的触发都在这一步完成。Spring Boot 的自动配置类就是通过这个机制生效的。</li>
<li><strong><code>registerBeanPostProcessors()</code></strong>: <strong>【关键】</strong> 注册所有 <code>BeanPostProcessor</code>。这些处理器会在 Bean 初始化前、后对 Bean 实例进行干预，例如处理 <code>@Autowired</code> 依赖注入、AOP 代理的创建等。</li>
<li><strong><code>initMessageSource()</code></strong>: 初始化国际化消息源。</li>
<li><strong><code>initApplicationEventMulticaster()</code></strong>: 初始化事件广播器。</li>
<li><strong><code>onRefresh()</code></strong>: <strong>【关键】</strong> 子类扩展点。对于 Web 应用 (<code>ServletWebServerApplicationContext</code>)，这一步会 <strong>创建并启动内嵌的 Web 服务器</strong> (如 Tomcat, Jetty)。</li>
<li><strong><code>registerListeners()</code></strong>: 注册 <code>ApplicationListener</code> 监听器。</li>
<li><strong><code>finishBeanFactoryInitialization()</code></strong>: <strong>【关键】</strong> 实例化所有剩余的非懒加载单例 Bean。此时，IoC 容器中定义的绝大部分 Bean 都会被创建和初始化，依赖注入也在这里完成。</li>
<li><strong><code>finishRefresh()</code></strong>: 完成刷新过程，发布 <strong><code>ContextRefreshedEvent</code></strong> 事件，标志着 IoC 容器已经准备就绪。</li>
</ul>
<p><strong>Step 8: <code>afterRefresh</code> 回调</strong></p>
<ul>
<li>提供一个空的模板方法，留给子类扩展。</li>
</ul>
<p><strong>Step 9: 发布 <code>ApplicationStartedEvent</code> 事件</strong></p>
<ul>
<li>调用 <code>RunListener</code> 的 <code>started()</code> 方法，并发布 <strong><code>ApplicationStartedEvent</code></strong> 事件。</li>
</ul>
<p><strong>Step 10: 调用 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code></strong></p>
<ul>
<li>从 <code>ApplicationContext</code> 中获取所有 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 类型的 Bean。</li>
<li>对它们进行排序（<code>@Order</code>）。</li>
<li>依次调用它们的 <code>run</code> 方法。这通常用于执行应用启动后需要立即运行的一些自定义任务（如加载初始数据、启动定时任务等）。</li>
</ul>
<p><strong>Step 11: 发布 <code>ApplicationReadyEvent</code> 事件</strong></p>
<ul>
<li>调用 <code>RunListener</code> 的 <code>ready()</code> 方法 (在 Spring Boot 2.5 及以后版本中，原 <code>running</code> 方法被重命名为 <code>ready</code>)，并发布 <strong><code>ApplicationReadyEvent</code></strong> 事件。这标志着应用已完全启动，并准备好接收请求。</li>
<li>如果启动过程中出现异常，则会发布 <code>ApplicationFailedEvent</code> 事件。</li>
</ul>
<p><strong>Step 12: 返回 <code>ApplicationContext</code></strong></p>
<ul>
<li><code>run()</code> 方法执行结束，返回创建并刷新好的 <code>ApplicationContext</code> 实例。</li>
</ul>
<hr>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><pre><code class="highlight mermaid">flowchart TD
    subgraph 第一阶段: SpringApplication 构造函数
        direction TB
        A_Start(new SpringApplication) --&gt; A1[&quot;1.确定Web应用类型&lt;br&gt;(SERVLET/REACTIVE/NONE)&quot;];
        A1 --&gt; A2[&quot;2.从 spring.factories 加载&lt;br/&gt;ApplicationContextInitializer&quot;];
        A2 --&gt; A3[&quot;3.从 spring.factories 加载&lt;br/&gt;ApplicationListener&quot;];
        A3 --&gt; A4[&quot;4.推断主启动类 (main class)&quot;];
    end

    subgraph &quot;第二阶段: run() 方法核心流程&quot;
        direction TB
        B_Run(&quot;SpringApplication.run()&quot;) --&gt; B1[Step 1: 启动StopWatch计时];
        B1 --&gt; B2&#123;&quot;Step 2: 准备 SpringApplicationRunListeners&quot;&#125;;
        B2 --&gt; B2_Event(发布 ApplicationStartingEvent):::event;
        
        B2_Event --&gt; B3[&quot;Step 3: 准备 Environment&lt;br/&gt;加载各级配置文件(yml/properties等)&quot;];
        B3 --&gt; B3_Event(发布 ApplicationEnvironmentPreparedEvent):::event;

        B3_Event --&gt; B4[Step 4: 打印 Banner];
        B4 --&gt; B5&#123;Step 5: 根据应用类型&lt;br&gt;创建 ApplicationContext&#125;;
        
        subgraph &quot;Step 6: prepareContext - 上下文预处理&quot;
            B5 -- SERVLET/REACTIVE/NONE --&gt; B6_1[设置Environment];
            B6_1 --&gt; B6_2[调用所有 ApplicationContextInitializer];
            B6_2 --&gt; B6_2_Event(发布 ApplicationContextInitializedEvent):::event;
            B6_2_Event --&gt; B6_3[加载主启动类等配置源];
            B6_3 --&gt; B6_3_Event(发布 ApplicationPreparedEvent):::event;
        end
        
        subgraph &quot;Step 7: refreshContext - 刷新上下文 (最核心)&quot;
            B6_3_Event --&gt; B7_1[&quot;invokeBeanFactoryPostProcessors&lt;br/&gt;&lt;b&gt;@EnableAutoConfiguration 生效&lt;/b&gt;&quot;]:::critical;
            B7_1 --&gt; B7_2[&quot;registerBeanPostProcessors&lt;br/&gt;&lt;b&gt;处理 @Autowired, AOP代理&lt;/b&gt;&quot;]:::critical;
            B7_2 --&gt; B7_3[&quot;onRefresh&lt;br/&gt;&lt;b&gt;启动内嵌Web服务器 (Tomcat)&lt;/b&gt;&quot;]:::critical;
            B7_3 --&gt; B7_4[&quot;finishBeanFactoryInitialization&lt;br/&gt;&lt;b&gt;实例化所有单例Bean&lt;/b&gt;&quot;]:::critical;
            B7_4 --&gt; B7_4_Event(发布 ContextRefreshedEvent):::event;
        end

        B7_4_Event --&gt; B8[Step 8: afterRefresh 回调];
        B8 --&gt; B9_Event(Step 9: 发布 ApplicationStartedEvent):::event;
        
        B9_Event --&gt; B10[&quot;Step 10: 调用所有&lt;br/&gt;ApplicationRunner 和 CommandLineRunner&quot;];
        B10 --&gt; B11_Event(Step 11: 发布 ApplicationReadyEvent&lt;br/&gt;&lt;b&gt;应用启动完成，准备接收请求&lt;/b&gt;):::event;
        
        B11_Event --&gt; B12_End(&quot;run()方法结束&lt;br&gt;返回ConfigurableApplicationContext&quot;);
        
        B_Run -- 启动异常 --&gt; B_Failed_Event(发布 ApplicationFailedEvent):::event_fail;
    end
    
    A4 --&gt; B_Run;

    %% 样式定义
    classDef event fill:#d4edda,stroke:#155724,stroke-width:2px;
    classDef event_fail fill:#f8d7da,stroke:#721c24,stroke-width:2px;
    classDef critical fill:#fff3cd,stroke:#856404,stroke-width:2px,font-weight:bold;</code></pre>

<hr>
<h2 id="2-配置文件详解"><a href="#2-配置文件详解" class="headerlink" title="2. 配置文件详解"></a>2. 配置文件详解</h2><h3 id="2-1-application-properties-vs-application-yml"><a href="#2-1-application-properties-vs-application-yml" class="headerlink" title="2.1 application.properties vs application.yml"></a>2.1 <code>application.properties</code> vs <code>application.yml</code></h3><p>Spring Boot 允许开发者使用两种主流的格式来编写配置文件：传统的 <code>.properties</code> 文件和更现代的 <code>.yml</code> (或 <code>.yaml</code>) 文件。两者在功能上是等价的，都可以用来定义应用的配置属性，但它们在<strong>语法、可读性和结构化数据表达</strong>方面存在显著差异。</p>
<p>当项目中同时存在 <code>application.properties</code> 和 <code>application.yml</code> 文件时，<strong><code>.properties</code> 文件的优先级更高</strong>。</p>
<hr>
<h4 id="2-1-1-application-properties"><a href="#2-1-1-application-properties" class="headerlink" title="2.1.1 application.properties"></a>2.1.1 <code>application.properties</code></h4><p>这是Java世界中最传统、最经典的配置文件格式，继承自 <code>java.util.Properties</code> 类。</p>
<ul>
<li><p><strong>语法</strong>：<strong>键值对 (Key-Value) 格式</strong>。</p>
<ul>
<li>使用 <code>=</code> 或 <code>:</code> 作为键和值的分隔符。</li>
<li>键（Key）通常采用点分（dot-separated）命名法来表示层级关系，例如 <code>spring.datasource.url</code>。</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>语法简单、直观，对于扁平化的、非复杂的配置非常友好。</li>
<li>所有的配置项都是独立的行，结构一目了然。</li>
<li>原生被Java支持，无需引入额外的依赖。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器配置</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/myapp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 数据库配置 (层级关系通过前缀来体现)</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/testdb</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 自定义配置</span></span><br><span class="line"><span class="attr">myapp.author</span>=<span class="string">Alice</span></span><br><span class="line"><span class="attr">myapp.version</span>=<span class="string">1.0.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><p><strong>冗余</strong>：当配置具有深层级的结构时，每一行都需要重复写很长的前缀（如 <code>spring.datasource.</code>），显得非常冗余。</p>
</li>
<li><p><strong>结构不直观</strong>：虽然通过前缀表示了层级，但视觉上仍然是扁平的，无法一眼看出配置项之间的父子关系。</p>
</li>
<li><p><strong>对复杂数据结构支持不佳</strong>：配置一个列表（List）或Map相对繁琐。</p>
<ul>
<li><p><strong>配置列表 (List&#x2F;Array)</strong>:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myapp.servers[0]</span>=<span class="string">dev.example.com</span></span><br><span class="line"><span class="attr">myapp.servers[1]</span>=<span class="string">qa.example.com</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置Map</strong>:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myapp.users.alice.name</span>=<span class="string">Alice</span></span><br><span class="line"><span class="attr">myapp.users.alice.age</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">myapp.users.bob.name</span>=<span class="string">Bob</span></span><br><span class="line"><span class="attr">myapp.users.bob.age</span>=<span class="string">25</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-2-application-yml-yaml"><a href="#2-1-2-application-yml-yaml" class="headerlink" title="2.1.2 application.yml (.yaml)"></a>2.1.2 <code>application.yml</code> (<code>.yaml</code>)</h4><p>YAML (YAML Ain’t Markup Language) 是一种以<strong>数据为中心</strong>的标记语言，被设计用来提供极高的人类可读性。Spring Boot通过集成 <code>SnakeYAML</code> 库来支持YAML格式。</p>
<ul>
<li><p><strong>语法</strong>：<strong>树状结构 (Tree Structure)</strong>。</p>
<ul>
<li>使用 <strong>缩进 (indentation)</strong> 来表示层级关系。<strong>注意：缩进必须使用空格，不能使用Tab键，且同一层级的缩进空格数必须一致</strong>。</li>
<li>使用 <code>:</code> 后面跟一个空格来分隔键和值。</li>
<li>使用 <code>-</code> (短横线) 后跟一个空格来表示列表（数组）中的一个元素。</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li><strong>简洁、无冗余</strong>：共享相同前缀的配置项被自然地组织在一起，无需重复书写。</li>
<li><strong>结构清晰</strong>：层级关系通过缩进一目了然，非常适合表达复杂的、结构化的配置数据。</li>
<li><strong>可读性极高</strong>：更接近自然语言的表达方式。</li>
</ul>
</li>
<li><p><strong>示例 (与上面的 <code>.properties</code> 完全等价)</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库配置 (层级关系通过缩进体现)</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义配置</span></span><br><span class="line"><span class="attr">myapp:</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">Alice</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对复杂数据结构的支持非常优雅</strong>：</p>
<ul>
<li><p><strong>配置列表 (List&#x2F;Array)</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myapp:</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dev.example.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">qa.example.com</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置Map</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myapp:</span></span><br><span class="line">  <span class="attr">users:</span></span><br><span class="line">    <span class="attr">alice:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">Alice</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">bob:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">Bob</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置对象列表 (List of Objects)</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myapp:</span></span><br><span class="line">  <span class="attr">employees:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Carol</span></span><br><span class="line">      <span class="attr">email:</span> <span class="string">carol@example.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">David</span></span><br><span class="line">      <span class="attr">email:</span> <span class="string">david@example.com</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-3-对比与总结"><a href="#2-1-3-对比与总结" class="headerlink" title="2.1.3 对比与总结"></a>2.1.3 对比与总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>application.properties</code></th>
<th align="left"><code>application.yml</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>语法</strong></td>
<td align="left"><strong>键值对</strong>，使用 <code>=</code> 或 <code>:</code> 分隔</td>
<td align="left"><strong>树状&#x2F;层级结构</strong>，使用<strong>空格缩进</strong>表示层级</td>
</tr>
<tr>
<td align="left"><strong>结构</strong></td>
<td align="left"><strong>扁平化</strong>，通过点分前缀模拟层级</td>
<td align="left"><strong>结构化</strong>，层级关系一目了然</td>
</tr>
<tr>
<td align="left"><strong>可读性</strong></td>
<td align="left">较好，但层级深时较差</td>
<td align="left"><strong>极高</strong>，更接近自然语言</td>
</tr>
<tr>
<td align="left"><strong>冗余度</strong></td>
<td align="left"><strong>高</strong>，需要重复书写长前缀</td>
<td align="left"><strong>低</strong>，共享前缀</td>
</tr>
<tr>
<td align="left"><strong>复杂数据</strong></td>
<td align="left">支持，但语法相对繁琐 (如 <code>list[0]</code>)</td>
<td align="left"><strong>非常优雅</strong>，使用 <code>-</code> 表示列表，天然支持嵌套对象</td>
</tr>
<tr>
<td align="left"><strong>注意事项</strong></td>
<td align="left">字符需要转义</td>
<td align="left"><strong>缩进必须使用空格，不能用Tab</strong>。语法对格式要求严格。</td>
</tr>
<tr>
<td align="left"><strong>优先级</strong></td>
<td align="left"><strong>高</strong> (当两者共存时)</td>
<td align="left"><strong>低</strong> (当两者共存时)</td>
</tr>
</tbody></table>
<p><strong>如何选择？</strong></p>
<ul>
<li><strong>对于新项目和追求高可读性的团队，强烈推荐使用 <code>application.yml</code></strong>。它的结构化特性在管理复杂的微服务配置时优势巨大。</li>
<li><strong>对于配置非常简单、扁平化的项目，或者习惯了传统 <code>.properties</code> 格式的开发者</strong>，使用 <code>.properties</code> 也是完全可以的，它的简单直接也是一种优点。</li>
<li>在一些<strong>自动化脚本或工具</strong>中，逐行解析 <code>.properties</code> 文件可能比解析复杂的YAML树更容易。</li>
</ul>
<p>在现代Spring Boot开发中，<code>application.yml</code> 已经成为事实上的主流选择，因为它更好地适应了现代应用配置日益增长的复杂性。</p>
<hr>
<h3 id="2-2-多环境配置-Profiles-application-dev-yml-application-prod-yml"><a href="#2-2-多环境配置-Profiles-application-dev-yml-application-prod-yml" class="headerlink" title="2.2 多环境配置 (Profiles) - application-dev.yml, application-prod.yml"></a>2.2 多环境配置 (Profiles) - <code>application-dev.yml</code>, <code>application-prod.yml</code></h3><h4 id="2-2-1-为什么需要多环境配置？"><a href="#2-2-1-为什么需要多环境配置？" class="headerlink" title="2.2.1 为什么需要多环境配置？"></a>2.2.1 为什么需要多环境配置？</h4><p>在软件开发的完整生命周期中，一个应用程序通常会在多个不同的环境中运行。每个环境的配置项（尤其是数据库连接、服务器地址、第三方服务密钥等）都大相径庭。</p>
<p>典型的环境包括：</p>
<ul>
<li><strong>开发环境 (Development - <code>dev</code>)</strong>:<ul>
<li><strong>用途</strong>: 开发者本地开发和调试。</li>
<li><strong>配置特点</strong>:<ul>
<li>数据库通常是本地的MySQL、H2内存数据库或测试库。</li>
<li>日志级别通常设为 <code>DEBUG</code> 以便查看详细信息。</li>
<li>可能会开启热部署、禁用缓存等便于开发的功能。</li>
<li>服务器端口可能使用默认的8080。</li>
</ul>
</li>
</ul>
</li>
<li><strong>测试环境 (Testing - <code>test</code> &#x2F; <code>qa</code>)</strong>:<ul>
<li><strong>用途</strong>: 测试团队进行功能测试、集成测试和回归测试。</li>
<li><strong>配置特点</strong>:<ul>
<li>连接到专门的测试数据库，里面的数据可以随意修改。</li>
<li>第三方服务（如支付、短信）可能连接到沙箱或模拟（mock）环境。</li>
<li>配置与生产环境尽量接近，但数据是隔离的。</li>
</ul>
</li>
</ul>
</li>
<li><strong>生产环境 (Production - <code>prod</code>)</strong>:<ul>
<li><strong>用途</strong>: 最终面向用户的线上运行环境。</li>
<li><strong>配置特点</strong>:<ul>
<li>连接到生产环境的数据库，数据真实且重要。</li>
<li>日志级别通常设为 <code>INFO</code> 或 <code>WARN</code>，以减少性能开销。</li>
<li>性能优化相关的配置（如启用缓存、GZIP压缩）会被开启。</li>
<li>服务器端口通常是80或443（通过反向代理）。</li>
<li>安全性要求最高。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果将所有环境的配置都写在一起，通过注释来切换，那将是一场灾难：容易出错、难以管理、且有泄露生产环境敏感信息的风险。<strong>Profile机制</strong>就是Spring提供的一套优雅的解决方案，用于管理和切换不同环境的配置。</p>
<hr>
<h4 id="2-2-2-Profile的实现方式"><a href="#2-2-2-Profile的实现方式" class="headerlink" title="2.2.2 Profile的实现方式"></a>2.2.2 Profile的实现方式</h4><p>Spring Boot的Profile机制允许你将不同环境的配置隔离在不同的文件中，然后在应用启动时指定激活哪个环境（Profile），Spring Boot就会加载对应环境的专属配置。</p>
<h5 id="1-基于文件名的Profile配置-application-profile-yml"><a href="#1-基于文件名的Profile配置-application-profile-yml" class="headerlink" title="1. 基于文件名的Profile配置 (application-{profile}.yml)"></a>1. 基于文件名的Profile配置 (<code>application-{profile}.yml</code>)</h5><p>这是最常用、最直观的方式。</p>
<p><strong>步骤 1: 创建多个Profile配置文件</strong></p>
<p>在 <code>src/main/resources</code> 目录下，除了主配置文件 <code>application.yml</code>，我们再为每个环境创建一个专属的配置文件，遵循 <code>application-{profile名称}.yml</code> 的命名规范。</p>
<ul>
<li><p><code>application.yml</code> (主&#x2F;通用配置文件):</p>
<ul>
<li>存放所有环境<strong>共享</strong>的配置。</li>
<li>也可以在这里指定<strong>默认</strong>激活的Profile。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是所有环境都通用的配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-cool-app</span></span><br><span class="line">  <span class="comment"># 指定默认激活的环境为dev, 如果没有通过其他方式指定，则加载dev配置</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">encoding:</span></span><br><span class="line">      <span class="attr">charset:</span> <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>application-dev.yml</code> (开发环境配置):</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/dev_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>application-prod.yml</code> (生产环境配置):</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 实际生产中通常由Nginx等代理</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://prod-server:3306/prod_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">prod_user</span></span><br><span class="line">    <span class="comment"># 敏感信息通常通过环境变量或配置中心注入，而不是写在文件里</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;PROD_DB_PASSWORD&#125;</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">INFO</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>加载规则</strong>：</p>
<p>当一个Profile（如 <code>dev</code>）被激活时，Spring Boot会<strong>同时加载</strong> <code>application.yml</code> 和 <code>application-dev.yml</code>。如果两个文件中存在相同的配置项（如<code>server.port</code>），<strong>Profile专属配置文件 (<code>application-dev.yml</code>) 中的值会覆盖主配置文件 (<code>application.yml</code>) 中的值</strong>。</p>
<hr>
<h5 id="2-YAML文档分隔符方式"><a href="#2-YAML文档分隔符方式" class="headerlink" title="2. YAML文档分隔符方式"></a>2. YAML文档分隔符方式</h5><p>YAML语法允许在一个文件中使用 <code>---</code> 分隔符来定义多个文档。Spring Boot支持这种方式来管理多环境配置。</p>
<ul>
<li><p><strong><code>application.yml</code> (单一文件)</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个文档：通用配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-cool-app</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span> <span class="comment"># 这是一个默认端口</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 第二个文档：dev环境配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">dev</span> <span class="comment"># 指定这个文档在dev profile激活时生效</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/dev_db</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 第三个文档：prod环境配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">prod</span> <span class="comment"># 指定这个文档在prod profile激活时生效</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://prod-server:3306/prod_db</span></span><br></pre></td></tr></table></figure>

<p>这种方式将所有配置集中在一个文件里，优点是管理单个文件更方便，缺点是当配置非常多时，文件会变得很长，不如多文件方式清晰。</p>
</li>
</ul>
<hr>
<h4 id="2-2-3-如何激活指定的Profile？"><a href="#2-2-3-如何激活指定的Profile？" class="headerlink" title="2.2.3 如何激活指定的Profile？"></a>2.2.3 如何激活指定的Profile？</h4><p>激活Profile的方式有多种，同样遵循<strong>高优先级覆盖低优先级</strong>的原则。</p>
<ol>
<li><p><strong>在 <code>application.yml</code> 中指定 (优先级最低)</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命令行参数 (推荐用于部署脚本)</strong></p>
<ul>
<li>这是<strong>最常用</strong>的在服务器上指定环境的方式。</li>
<li><code>java -jar my-app.jar --spring.profiles.active=prod</code></li>
</ul>
</li>
<li><p><strong>Java系统属性</strong></p>
<ul>
<li><code>java -Dspring.profiles.active=prod -jar my-app.jar</code></li>
</ul>
</li>
<li><p><strong>操作系统环境变量</strong></p>
<ul>
<li>在服务器上设置环境变量 <code>SPRING_PROFILES_ACTIVE=prod</code>，然后直接运行 <code>java -jar my-app.jar</code>。</li>
</ul>
</li>
<li><p><strong>在IDE中配置 (用于开发)</strong></p>
<ul>
<li>在IntelliJ IDEA或Eclipse的运行配置中，可以设置”Active profiles”为你想要的开发环境，如 <code>dev</code>。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-2-4-在Java代码中使用Profile-Profile-注解"><a href="#2-2-4-在Java代码中使用Profile-Profile-注解" class="headerlink" title="2.2.4 在Java代码中使用Profile (@Profile 注解)"></a>2.2.4 在Java代码中使用Profile (<code>@Profile</code> 注解)</h4><p>Profile不仅可以用来管理配置文件，还可以用来<strong>有条件地创建Bean</strong>。</p>
<p><code>@Profile</code> 注解可以标记在 <code>@Configuration</code> 类或 <code>@Bean</code> 方法上，表示只有当指定的Profile被激活时，这个配置类或Bean才会被创建。</p>
<p><strong>示例</strong>：我们希望在开发环境(<code>dev</code>)使用一个内存数据库(H2)，而在生产环境(<code>prod</code>)使用MySQL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个Bean只有在dev profile激活时才会被创建</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">devDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 配置并返回一个连接到H2的DataSource</span></span><br><span class="line">        System.out.println(<span class="string">&quot;DEV DataSource is created.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">H2DataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个Bean只有在prod profile激活时才会被创建</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">prodDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 配置并返回一个连接到MySQL的DataSource</span></span><br><span class="line">        System.out.println(<span class="string">&quot;PROD DataSource is created.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MySqlDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @Profile注解也支持复杂的逻辑表达式</span></span><br><span class="line">    <span class="comment">// @Profile(&quot;!prod&quot;) // 非prod环境</span></span><br><span class="line">    <span class="comment">// @Profile(&quot;dev | test&quot;) // dev或test环境</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，根据启动时激活的Profile，Spring容器中只会存在一个<code>DataSource</code>类型的Bean，实现了环境隔离。</p>
<hr>
<h3 id="2-3-配置加载优先级"><a href="#2-3-配置加载优先级" class="headerlink" title="2.3 配置加载优先级"></a>2.3 配置加载优先级</h3><p>Spring Boot 的外部化配置功能之所以强大，很大一部分原因在于它设计了一套<strong>层次分明、逻辑清晰的优先级加载机制</strong>。这意味着你可以把默认配置放在项目内部，然后在不同的部署环境中通过更高优先级的配置源来覆盖它，而无需修改任何代码。</p>
<p>Spring Boot 会从多个位置加载配置属性，这些位置形成了一个有序的优先级列表。<strong>排在列表越前面的（优先级越高），其配置项就会覆盖排在后面的同名配置项</strong>。</p>
<p>以下是官方文档中列出的一个精简但核心的优先级顺序列表，<strong>从高到低</strong>排列：</p>
<hr>
<h4 id="2-3-1-核心配置源优先级列表-由高到低"><a href="#2-3-1-核心配置源优先级列表-由高到低" class="headerlink" title="2.3.1 核心配置源优先级列表 (由高到低)"></a>2.3.1 核心配置源优先级列表 (由高到低)</h4><p><strong>1. 开发时工具 (Devtools)</strong></p>
<ul>
<li>如果你使用了 <code>spring-boot-devtools</code>，在 <code>~/.config/spring-boot/</code> 目录下的全局配置。这主要用于本地开发，优先级非常高。</li>
</ul>
<p><strong>2. 单元测试中的 <code>@TestPropertySource</code> 注解</strong></p>
<ul>
<li>在进行单元测试或集成测试时，通过 <code>@TestPropertySource</code> 注解指定的属性，优先级极高，专门用于覆盖测试环境的配置。</li>
</ul>
<p><strong>3. <code>@SpringBootTest</code> 的 <code>properties</code> 属性</strong></p>
<ul>
<li>同样在测试中，<code>@SpringBootTest(properties = &quot;my.prop=test&quot;)</code> 这种方式指定的属性。</li>
</ul>
<hr>
<p><strong>4. 命令行参数 (Command-line arguments)</strong></p>
<ul>
<li><strong>这是日常使用中优先级最高的配置方式</strong>。</li>
<li>通过 <code>java -jar my-app.jar --server.port=9000 --my.prop=value</code> 形式传入。</li>
<li><code>--</code> 后面的参数会被解析为配置属性。</li>
<li><strong>用途</strong>：在启动时临时覆盖某个特定配置，非常适合自动化部署脚本。</li>
</ul>
<p><strong>5. <code>SPRING_APPLICATION_JSON</code></strong></p>
<ul>
<li>来自于系统环境变量或Java系统属性的JSON字符串。</li>
<li>示例：<code>SPRING_APPLICATION_JSON=&#39;{&quot;server&quot;:{&quot;port&quot;:9000}}&#39;</code></li>
<li>允许以结构化的方式传入配置。</li>
</ul>
<p><strong>6. <code>ServletConfig</code> 和 <code>ServletContext</code> 的初始化参数</strong></p>
<ul>
<li>在传统的WAR包部署方式中，从 <code>web.xml</code> 或Servlet容器配置中获取。</li>
</ul>
<p><strong>7. JNDI属性 (<code>java:comp/env</code>)</strong></p>
<ul>
<li>从Java命名和目录接口中获取，常见于传统的应用服务器环境。</li>
</ul>
<hr>
<p><strong>8. Java系统属性 (<code>System.getProperties()</code>)</strong></p>
<ul>
<li>通过 <code>-D</code> 参数在启动JVM时传入。</li>
<li>示例：<code>java -Dserver.port=9000 -jar my-app.jar</code></li>
</ul>
<p><strong>9. 操作系统环境变量 (OS environment variables)</strong></p>
<ul>
<li>从操作系统的环境变量中读取。</li>
<li><strong>命名规则</strong>：Spring Boot 会将环境变量的格式进行转换。例如：<ul>
<li><code>SERVER_PORT</code> -&gt; <code>server.port</code></li>
<li><code>MY_APP_DATABASE_URL</code> -&gt; <code>my.app.database.url</code></li>
<li><code>MY_APP_SERVER_LIST[0]</code> -&gt; <code>my.app.server.list[0]</code></li>
</ul>
</li>
<li><strong>用途</strong>：在容器化环境（如Docker, Kubernetes）中，通过环境变量来注入配置是一种非常普遍和推荐的做法。</li>
</ul>
<hr>
<p><strong>10. <code>random.\*</code> 属性</strong></p>
<ul>
<li><code>RandomValuePropertySource</code> 提供的随机值，如 <code>random.int</code>, <code>random.uuid</code>。</li>
</ul>
<p><strong>11. JAR包外部的 <code>application-{profile}.properties</code> 或 <code>.yml</code> 文件</strong></p>
<ul>
<li><strong>这是生产环境中覆盖配置最常用的方式之一</strong>。</li>
<li>指的是与你的可执行JAR包<strong>放在同一个目录下</strong>的配置文件。</li>
<li>Spring Boot 会先加载profile特定的文件（如<code>application-prod.yml</code>），再加载通用的文件（<code>application.yml</code>）。</li>
</ul>
<p><strong>12. JAR包内部的 <code>application-{profile}.properties</code> 或 <code>.yml</code> 文件</strong></p>
<ul>
<li><p>打包在 <code>src/main/resources</code> 目录下的，针对不同环境（profile）的配置文件。</p>
</li>
<li><p>这是我们在开发时为不同环境预设配置的地方。</p>
</li>
</ul>
<p><strong>13. <code>@PropertySource</code> 注解</strong></p>
<ul>
<li><p>在 <code>@Configuration</code> 类上通过此注解显式加载的配置文件。</p>
</li>
<li><p><strong>注意</strong>：通过 <code>@PropertySource</code> 加载的配置优先级较低，无法覆盖<code>application.properties</code>中定义的属性。它更多是作为一种补充。</p>
</li>
</ul>
<p><strong>14. 默认属性 (<code>SpringApplication.setDefaultProperties</code>)</strong></p>
<ul>
<li><p>通过代码 <code>new SpringApplicationBuilder().properties(&quot;...&quot;).run()</code> 设置的默认属性。</p>
</li>
<li><p><strong>这是优先级最低的配置方式</strong>。</p>
</li>
</ul>
<hr>
<h4 id="2-3-2-示例"><a href="#2-3-2-示例" class="headerlink" title="2.3.2 示例"></a>2.3.2 示例</h4><p>假设你的项目中有以下配置：</p>
<ol>
<li><p><strong>JAR包内部 <code>src/main/resources/application.yml</code></strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 默认端口</span></span><br><span class="line"><span class="attr">myapp:</span></span><br><span class="line">  <span class="attr">greeting:</span> <span class="string">&quot;Hello from default config&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JAR包外部 <code>/opt/app/application.yml</code></strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运维人员在服务器上放了一个配置文件</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 覆盖为80端口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>操作系统环境变量</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置了一个环境变量</span></span><br><span class="line"><span class="built_in">export</span> MYAPP_GREETING=<span class="string">&quot;Hello from environment variable&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动命令</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在启动时，又通过命令行参数指定了端口</span></span><br><span class="line">java -jar my-app.jar --server.port=9090</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>那么，最终应用生效的配置是什么？</strong></p>
<ul>
<li><code>server.port</code>: <strong><code>9090</code></strong><ul>
<li><strong>分析</strong>: 命令行参数 (<code>9090</code>) 的优先级 <strong>最高</strong>，覆盖了包外文件 (<code>80</code>) 和包内文件 (<code>8080</code>) 的所有同名配置。</li>
</ul>
</li>
<li><code>myapp.greeting</code>: <strong><code>&quot;Hello from environment variable&quot;</code></strong><ul>
<li><strong>分析</strong>: 操作系统环境变量 (<code>&quot;Hello from environment variable&quot;</code>) 的优先级 <strong>高于</strong> 包内文件 (<code>&quot;Hello from default config&quot;</code>)。由于没有更高优先级的配置（如命令行参数）来覆盖它，所以环境变量的值生效。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-3-总结与最佳实践"><a href="#2-3-3-总结与最佳实践" class="headerlink" title="2.3.3 总结与最佳实践"></a>2.3.3 总结与最佳实践</h4><ol>
<li><p><strong>代码内 (JAR包内)</strong>:</p>
<ul>
<li>在 <code>application.yml</code> 中放置<strong>通用的、安全的默认配置</strong>。</li>
<li>在 <code>application-{profile}.yml</code> 中放置<strong>特定环境的、非敏感的默认配置</strong>（如开发环境的数据库地址）。</li>
</ul>
</li>
<li><p><strong>代码外 (部署时)</strong>:</p>
<ul>
<li><p>对于<strong>敏感信息</strong>（如数据库密码、API密钥），<strong>强烈推荐</strong>使用<strong>操作系统环境变量</strong>或<strong>配置中心</strong>来注入。这避免了将机密信息硬编码在任何文件中。</p>
</li>
<li><p>对于<strong>非敏感但需要经常调整</strong>的配置（如线程池大小、功能开关），可以在<strong>JAR包同级目录下</strong>放置 <code>application.yml</code> 或 <code>config/application.yml</code> 文件，方便运维人员修改。</p>
</li>
<li><p>对于<strong>临时调试或一次性任务</strong>，使用<strong>命令行参数</strong>是最便捷的方式。</p>
</li>
</ul>
</li>
</ol>
<p>深刻理解这个优先级顺序，可以让你在复杂的部署环境中游刃有余地管理应用的配置，确保正确的配置在正确的环境中生效。</p>
<hr>
<h3 id="2-4-属性注入"><a href="#2-4-属性注入" class="headerlink" title="2.4 属性注入"></a>2.4 属性注入</h3><h4 id="2-4-1-Value注入单个属性"><a href="#2-4-1-Value注入单个属性" class="headerlink" title="2.4.1 @Value注入单个属性"></a>2.4.1 <code>@Value</code>注入单个属性</h4><p><code>@Value</code> 注解是 Spring 框架提供的一种依赖注入机制，它允许我们将外部配置源（如 <code>.properties</code> &#x2F; <code>.yml</code> 文件、环境变量、系统属性等）中的<strong>单个值</strong>直接注入到 Spring Bean 的字段、方法参数或构造函数参数中。</p>
<h5 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h5><p><code>@Value</code> 的核心语法是使用占位符 <code>${...}</code> 来引用一个配置属性的键（Key）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;property.key&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String propertyValue;</span><br></pre></td></tr></table></figure>

<p>当 Spring IoC 容器在初始化一个包含 <code>@Value</code> 注解的 Bean 时，它会：</p>
<ol>
<li>从已加载的所有配置源中（根据优先级顺序）查找键为 <code>property.key</code> 的属性。</li>
<li>找到后，将其值赋给 <code>propertyValue</code> 这个字段。</li>
<li>如果找不到该属性，应用程序在启动时会抛出 <code>IllegalArgumentException</code> 异常，导致启动失败。</li>
</ol>
<hr>
<h5 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h5><p>假设我们有以下 <code>application.yml</code> 配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">myapp:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&quot;My Awesome App&quot;</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">&quot;1.2.3&quot;</span></span><br><span class="line">  <span class="attr">feature-enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">thread-pool:</span></span><br><span class="line">    <span class="attr">core-size:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>我们可以创建一个组件来读取这些配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppInfoReader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入字符串类型</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myapp.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring会自动进行类型转换，将 &quot;1.2.3&quot; 转为 String</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myapp.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入布尔类型，&quot;true&quot; 会被转为 boolean true</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myapp.feature-enabled&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isFeatureEnabled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入整型</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入深层级的属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myapp.thread-pool.core-size&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> corePoolSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAppInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Application Name: &quot;</span> + appName);</span><br><span class="line">        System.out.println(<span class="string">&quot;Version: &quot;</span> + appVersion);</span><br><span class="line">        System.out.println(<span class="string">&quot;Feature Enabled: &quot;</span> + isFeatureEnabled);</span><br><span class="line">        System.out.println(<span class="string">&quot;Server Port: &quot;</span> + serverPort);</span><br><span class="line">        System.out.println(<span class="string">&quot;Core Pool Size: &quot;</span> + corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-提供默认值"><a href="#3-提供默认值" class="headerlink" title="3. 提供默认值"></a>3. 提供默认值</h5><p>为了避免因某个配置项缺失而导致应用启动失败，<code>@Value</code> 允许我们提供一个默认值。语法是在键后面加上冒号 <code>:</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;property.key:defaultValue&#125;&quot;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果 <code>property.key</code> 存在</strong>，则注入其配置值。</li>
<li><strong>如果 <code>property.key</code> 不存在</strong>，则注入 <code>defaultValue</code>，应用会正常启动。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果配置文件中没有 myapp.author，author 字段将被赋值为 &quot;Unknown&quot;</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;myapp.author:Unknown&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值也可以是数字、布尔值等</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;myapp.timeout:3000&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> timeoutInMillis;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：即使提供了默认值，如果配置项存在但为空（例如 <code>myapp.author=</code>），那么注入的将是空字符串 <code>&quot;&quot;</code>，而不是默认值 <code>&quot;Unknown&quot;</code>。</p>
<hr>
<h5 id="4-SpEL-Spring-Expression-Language-支持"><a href="#4-SpEL-Spring-Expression-Language-支持" class="headerlink" title="4. SpEL (Spring Expression Language) 支持"></a>4. SpEL (Spring Expression Language) 支持</h5><p><code>@Value</code> 的功能远不止于简单的属性占位符。它还支持强大的 <strong>Spring 表达式语言 (SpEL)</strong>，语法是 <code>#{...}</code>。这允许我们执行一些动态的计算或引用其他Bean的属性。</p>
<p><strong>SpEL 常见用法</strong>：</p>
<ul>
<li><p><strong>引用其他Bean的属性</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个名为 systemProperties 的Bean (它是一个Map)</span></span><br><span class="line"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;java.home&#x27;]&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String javaHome;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行方法调用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;someBean.getSomeValue().toUpperCase()&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String uppercaseValue;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进行数学运算</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;1 + 2&#125;&quot;)</span> <span class="comment">// 注入 3</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> result;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>组合属性占位符和SpEL</strong>:<br>我们可以将 <code>${...}</code> 和 <code>#{...}</code> 结合使用，先解析属性，再用SpEL处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从配置中读取一个逗号分隔的字符串，然后用SpEL将其分割成一个List</span></span><br><span class="line"><span class="comment">// application.properties: myapp.servers=host1,host2,host3</span></span><br><span class="line"><span class="meta">@Value(&quot;#&#123;&#x27;$&#123;myapp.servers&#125;&#x27;.split(&#x27;,&#x27;)&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; serverList;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-Value-vs-ConfigurationProperties"><a href="#5-Value-vs-ConfigurationProperties" class="headerlink" title="5. @Value vs @ConfigurationProperties"></a>5. <code>@Value</code> vs <code>@ConfigurationProperties</code></h5><p>虽然 <code>@Value</code> 很方便，但在某些场景下，<code>@ConfigurationProperties</code> 是更好的选择。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Value</code></th>
<th align="left"><code>@ConfigurationProperties</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>注入粒度</strong></td>
<td align="left"><strong>单个</strong>属性注入</td>
<td align="left"><strong>批量</strong>、<strong>结构化</strong>的属性绑定到一个对象上</td>
</tr>
<tr>
<td align="left"><strong>类型安全</strong></td>
<td align="left">较弱。如果类型转换失败，错误信息可能不够明确。</td>
<td align="left"><strong>强</strong>。提供复杂的类型转换和校验，失败时有清晰的错误报告。</td>
</tr>
<tr>
<td align="left"><strong>松散绑定 (Relaxed Binding)</strong></td>
<td align="left"><strong>不支持</strong>。属性键必须<strong>精确匹配</strong> (<code>feature-enabled</code> 必须写成 <code>feature-enabled</code>)。</td>
<td align="left"><strong>支持</strong>。<code>feature-enabled</code>, <code>featureEnabled</code>, <code>FEATURE_ENABLED</code> 都能匹配到 <code>featureEnabled</code> 字段。</td>
</tr>
<tr>
<td align="left"><strong>JSR-303 校验</strong></td>
<td align="left">不支持。</td>
<td align="left">支持。可以在属性类上使用<code>@Validated</code>和<code>@NotNull</code>等注解进行校验。</td>
</tr>
<tr>
<td align="left"><strong>SpEL 支持</strong></td>
<td align="left"><strong>支持</strong>。</td>
<td align="left">不支持。</td>
</tr>
</tbody></table>
<p><strong>选择建议</strong>：</p>
<ul>
<li>当你只需要注入<strong>一两个简单</strong>的、非结构化的配置项时，使用 <code>@Value</code> 非常快捷方便。</li>
<li>当你的配置项具有<strong>层级结构</strong>、数量较多，并且希望获得更好的<strong>类型安全</strong>和<strong>IDE支持</strong>时，<strong>强烈推荐使用 <code>@ConfigurationProperties</code></strong>。</li>
</ul>
<hr>
<h4 id="2-4-2-ConfigurationProperties"><a href="#2-4-2-ConfigurationProperties" class="headerlink" title="2.4.2 @ConfigurationProperties"></a>2.4.2 <code>@ConfigurationProperties</code></h4><p><code>@ConfigurationProperties</code> 注解是 Spring Boot 提供的一种将外部配置文件中的<strong>一组相关属性</strong>，以<strong>类型安全</strong>的方式<strong>批量绑定</strong>到一个Java对象（通常是POJO）上的强大机制。</p>
<p>它解决了 <code>@Value</code> 注解在处理大量、结构化配置时显得分散和繁琐的问题，提供了更优雅、更健壮的配置管理方案。</p>
<h5 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p><code>@ConfigurationProperties</code> 的核心思想是**“约定优于配置”<strong>和</strong>“面向对象”**。</p>
<ul>
<li><strong>约定</strong>：你定义一个Java类，其<strong>字段名</strong>与配置文件中的<strong>属性键</strong>相对应。</li>
<li><strong>面向对象</strong>：将一组相关的配置（如数据库连接的所有参数）封装在一个单一的、内聚的对象中，而不是将它们散落在代码的各个角落。</li>
</ul>
<hr>
<h5 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a>2. 基本用法</h5><p>使用 <code>@ConfigurationProperties</code> 通常涉及三个步骤：</p>
<p><strong>Step 1: 创建一个属性绑定类 (Properties Class)</strong></p>
<p>创建一个普通的Java类（POJO），用来承载配置信息。这个类需要为每个属性提供标准的 <code>getter</code> 和 <code>setter</code> 方法。</p>
<p><strong>Step 2: 使用 <code>@ConfigurationProperties</code> 注解</strong></p>
<p>在该类上添加 <code>@ConfigurationProperties</code> 注解，并通过 <code>prefix</code> 属性指定要绑定的配置属性的<strong>公共前缀</strong>。</p>
<p><strong>Step 3: 将该类注册为 Spring Bean</strong></p>
<p>为了让Spring Boot能够扫描到并处理这个属性类，你需要将它声明为一个Bean。最简单的方式是在类上添加 <code>@Component</code> 注解。</p>
<p><strong>示例</strong>：</p>
<p>假设我们有以下 <code>application.yml</code> 配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.example.com</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">587</span></span><br><span class="line">    <span class="attr">auth:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">user@example.com</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">secret-password</span></span><br><span class="line">    <span class="attr">recipients:</span> <span class="comment"># 列表</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin@example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">support@example.com</span></span><br><span class="line">    <span class="attr">headers:</span> <span class="comment"># Map</span></span><br><span class="line">      <span class="attr">X-Priority:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">X-Mailer:</span> <span class="string">MyAppMailer</span></span><br></pre></td></tr></table></figure>

<p>我们可以创建一个 <code>MailProperties</code> 类来绑定这组配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app.mail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 邮件服务器主机地址. */</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 邮件服务器端口. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 认证信息 (这是一个嵌套对象). */</span></span><br><span class="line">    <span class="keyword">private</span> Auth auth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 默认收件人列表. */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; recipients;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 自定义邮件头信息. */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; headers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套的静态内部类，用于映射 auth 配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Auth</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Auth 的 Getters and Setters</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123; <span class="keyword">return</span> username; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123; <span class="built_in">this</span>.username = username; &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123; <span class="keyword">return</span> password; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123; <span class="built_in">this</span>.password = password; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MailProperties 的 Getters and Setters</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123; <span class="keyword">return</span> host; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHost</span><span class="params">(String host)</span> &#123; <span class="built_in">this</span>.host = host; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPort</span><span class="params">()</span> &#123; <span class="keyword">return</span> port; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPort</span><span class="params">(<span class="type">int</span> port)</span> &#123; <span class="built_in">this</span>.port = port; &#125;</span><br><span class="line">    <span class="keyword">public</span> Auth <span class="title function_">getAuth</span><span class="params">()</span> &#123; <span class="keyword">return</span> auth; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuth</span><span class="params">(Auth auth)</span> &#123; <span class="built_in">this</span>.auth = auth; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getRecipients</span><span class="params">()</span> &#123; <span class="keyword">return</span> recipients; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRecipients</span><span class="params">(List&lt;String&gt; recipients)</span> &#123; <span class="built_in">this</span>.recipients = recipients; &#125;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">getHeaders</span><span class="params">()</span> &#123; <span class="keyword">return</span> headers; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeaders</span><span class="params">(Map&lt;String, String&gt; headers)</span> &#123; <span class="built_in">this</span>.headers = headers; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在其他地方使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MailProperties mailProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EmailService</span><span class="params">(MailProperties mailProperties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mailProperties = mailProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending email via host: &quot;</span> + mailProperties.getHost());</span><br><span class="line">        System.out.println(<span class="string">&quot;Username: &quot;</span> + mailProperties.getAuth().getUsername());</span><br><span class="line">        System.out.println(<span class="string">&quot;Recipients: &quot;</span> + mailProperties.getRecipients());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-核心特性"><a href="#3-核心特性" class="headerlink" title="3. 核心特性"></a>3. 核心特性</h5><p><strong>a. 松散绑定 (Relaxed Binding)</strong></p>
<p>这是 <code>@ConfigurationProperties</code> 一个非常强大的特性。它在匹配属性键和Java字段名时，不要求完全精确匹配，支持多种命名风格的转换。</p>
<p>例如，以下所有格式的配置键，都能成功绑定到Java字段 <code>myProperty</code> 上：</p>
<table>
<thead>
<tr>
<th align="left">配置文件中的Key</th>
<th align="left">对应的Java字段名</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>app.my-property</code> (kebab-case)</td>
<td align="left"><code>myProperty</code></td>
</tr>
<tr>
<td align="left"><code>app.my_property</code> (snake_case)</td>
<td align="left"><code>myProperty</code></td>
</tr>
<tr>
<td align="left"><code>app.myProperty</code> (camelCase)</td>
<td align="left"><code>myProperty</code></td>
</tr>
<tr>
<td align="left"><code>APP_MY_PROPERTY</code> (screaming snake_case, 用于环境变量)</td>
<td align="left"><code>myProperty</code></td>
</tr>
</tbody></table>
<p>官方推荐在 <code>.yml</code> 或 <code>.properties</code> 中使用 <strong>kebab-case (短横线分隔)</strong> 风格，因为它最易读。</p>
<p><strong>b. JSR-303 数据校验</strong></p>
<p>你可以结合使用 <code>javax.validation</code> 注解（如 <code>@NotNull</code>, <code>@Min</code>, <code>@Email</code>）和 <code>@Validated</code> 注解，让Spring Boot在绑定属性时自动进行数据校验。如果校验失败，应用启动会失败并给出明确的错误提示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotEmpty;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app.mail&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span> <span class="comment">// 开启校验</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty</span> <span class="comment">// 校验host不能为空字符串</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(1025)</span> <span class="comment">// 端口号必须大于1024</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span> <span class="comment">// 校验auth对象不能为null</span></span><br><span class="line">    <span class="keyword">private</span> Auth auth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>c. 强大的类型转换</strong></p>
<p>Spring Boot的类型转换服务非常强大，能自动处理很多复杂的转换，例如：</p>
<ul>
<li><code>&quot;10s&quot;</code> -&gt; <code>java.time.Duration</code></li>
<li><code>&quot;2KB&quot;</code> -&gt; <code>org.springframework.util.unit.DataSize</code></li>
<li><code>&quot;com.example.MyClass&quot;</code> -&gt; <code>java.lang.Class&lt;?&gt;</code></li>
<li>逗号分隔的字符串 -&gt; <code>List&lt;String&gt;</code></li>
</ul>
<p><strong>d. 启用 <code>@ConfigurationProperties</code> 的另一种方式</strong></p>
<p>除了在属性类上加 <code>@Component</code>，你还可以在一个 <code>@Configuration</code> 类上使用 <code>@EnableConfigurationProperties</code> 来激活一个或多个属性类。这种方式的好处是属性类本身可以是一个纯粹的POJO，不依赖于Spring的任何注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 属性类 (纯POJO)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app.mail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailProperties</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MailProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 这样，MailProperties 就会被自动注册为一个Bean</span></span><br><span class="line">    <span class="comment">// 并且可以在这个配置类中直接注入它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-总结与最佳实践"><a href="#4-总结与最佳实践" class="headerlink" title="4. 总结与最佳实践"></a>4. 总结与最佳实践</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Value</code></th>
<th align="left"><code>@ConfigurationProperties</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>用途</strong></td>
<td align="left">注入单个、离散的属性值</td>
<td align="left">绑定一组结构化的、相关的配置属性</td>
</tr>
<tr>
<td align="left"><strong>代码风格</strong></td>
<td align="left">分散在各个类的字段上</td>
<td align="left">集中在一个专门的属性类中，内聚性高</td>
</tr>
<tr>
<td align="left"><strong>类型安全</strong></td>
<td align="left">较弱</td>
<td align="left"><strong>强</strong>，支持复杂的类型转换和校验</td>
</tr>
<tr>
<td align="left"><strong>松散绑定</strong></td>
<td align="left">不支持</td>
<td align="left"><strong>支持</strong>，代码和配置的命名风格可以解耦</td>
</tr>
<tr>
<td align="left"><strong>IDE支持</strong></td>
<td align="left">有限</td>
<td align="left"><strong>极好</strong>，提供配置键的自动补全、提示和元数据生成</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong>：</p>
<ul>
<li><strong>优先使用 <code>@ConfigurationProperties</code></strong>：对于任何一组（即使只有两三个）相关的配置，都应该优先考虑使用 <code>@ConfigurationProperties</code>。这会让你的代码更健壮、更易于维护和测试。</li>
<li><strong><code>@Value</code> 的适用场景</strong>：只在需要注入单个、与其他配置无强关联的简单值时，或者需要利用其SpEL能力时，才使用 <code>@Value</code>。</li>
</ul>
<hr>
<h2 id="3-监控与管理-Actuator"><a href="#3-监控与管理-Actuator" class="headerlink" title="3. 监控与管理(Actuator)"></a>3. 监控与管理(Actuator)</h2><h3 id="3-1-Actuator是什么？"><a href="#3-1-Actuator是什么？" class="headerlink" title="3.1 Actuator是什么？"></a>3.1 Actuator是什么？</h3><h4 id="3-1-1-核心定义"><a href="#3-1-1-核心定义" class="headerlink" title="3.1.1 核心定义"></a>3.1.1 核心定义</h4><p>Spring Boot <strong>Actuator</strong>（直译为“执行器”或“驱动器”），它的核心功能是为你的应用程序添加一系列<strong>生产就绪 (Production-Ready) 的特性</strong>，主要用于<strong>监控和管理</strong>正在运行中的应用程序。 能让你在<strong>不停止应用</strong>的情况下，通过HTTP端点（Endpoints）或JMX（Java Management Extensions），轻松地窥探应用程序的内部状态、运行状况和各种度量指标。</p>
<hr>
<h4 id="3-1-2-解决的问题：应用的“黑盒”困境"><a href="#3-1-2-解决的问题：应用的“黑盒”困境" class="headerlink" title="3.1.2 解决的问题：应用的“黑盒”困境"></a>3.1.2 解决的问题：应用的“黑盒”困境</h4><p>想象一下，一个没有监控的应用被部署到生产服务器上后，它就像一个**“黑盒”**：</p>
<ul>
<li><strong>它还活着吗？</strong> 应用进程还在，但它是否能正常处理业务？是不是已经僵死或陷入了死循环？</li>
<li><strong>它健康吗？</strong> 数据库连接是否正常？消息队列是否通畅？磁盘空间是否充足？</li>
<li><strong>它内部发生了什么？</strong> 加载了哪些Bean？当前的环境变量和配置是什么？最近的HTTP请求是成功了还是失败了？JVM内存使用情况如何？</li>
<li><strong>如何优雅地关闭它？</strong> 直接 <code>kill</code> 吗？这可能会导致正在处理的数据丢失。</li>
</ul>
<p>在没有Actuator的时代，开发者和运维人员需要自己编写大量的代码、集成各种第三方库（如Metrics, JMX MBeans）来回答这些问题。这个过程不仅繁琐，而且缺乏统一的标准。</p>
<p><strong>Actuator 的出现，就是为了打开这个“黑盒”，为所有Spring Boot应用提供一套标准化的、开箱即用的监控和管理解决方案。</strong></p>
<hr>
<h4 id="3-1-3-工作原理与核心组件"><a href="#3-1-3-工作原理与核心组件" class="headerlink" title="3.1.3 工作原理与核心组件"></a>3.1.3 工作原理与核心组件</h4><p>Actuator 的工作原理非常简单，它通过Spring Boot的自动配置机制，向你的应用中自动注册一系列特殊的基础设施Bean。其中最核心的两个组件是：</p>
<h5 id="1-端点-Endpoints"><a href="#1-端点-Endpoints" class="headerlink" title="1. 端点 (Endpoints)"></a>1. 端点 (Endpoints)</h5><ul>
<li><strong>定义</strong>：一个<strong>端点</strong>就是 Actuator 暴露出的一个<strong>特定监控或管理功能的入口</strong>。每个端点都专注于一个方面的信息，例如 <code>/health</code> 端点用于检查应用健康状况，<code>/metrics</code> 端点用于提供详细的度量指标。</li>
<li><strong>暴露方式</strong>：默认情况下，Actuator 主要通过 <strong>HTTP</strong> 和 <strong>JMX</strong> 两种方式暴露这些端点。<ul>
<li><strong>HTTP</strong>: 你可以通过访问特定的URL（如 <code>http://localhost:8081/actuator/health</code>）来获取JSON格式的监控数据。这是最常用、最直观的方式，也便于与各种监控系统（如Prometheus, Zabbix, Nagios）集成。</li>
<li><strong>JMX</strong>: 可以通过JConsole、VisualVM等JMX客户端连接到应用进程，以树状结构查看和管理应用。</li>
</ul>
</li>
</ul>
<h5 id="2-健康指示器-Health-Indicators"><a href="#2-健康指示器-Health-Indicators" class="headerlink" title="2. 健康指示器 (Health Indicators)"></a>2. 健康指示器 (Health Indicators)</h5><ul>
<li>这是 <code>/health</code> 端点的核心组成部分。Spring Boot Actuator 内置了大量的 <code>HealthIndicator</code> 实现，用于自动检查应用所依赖的各种外部资源的状态。</li>
<li><strong>常见的 <code>HealthIndicator</code></strong>:<ul>
<li><code>DataSourceHealthIndicator</code>: 检查数据库连接是否正常。</li>
<li><code>RedisHealthIndicator</code>: 检查Redis连接是否正常。</li>
<li><code>DiskSpaceHealthIndicator</code>: 检查磁盘空间是否低于阈值。</li>
<li><code>RabbitHealthIndicator</code>: 检查RabbitMQ连接。</li>
<li><code>PingHealthIndicator</code>: 一个基本的指示器，表示应用自身是启动的。</li>
</ul>
</li>
<li>当访问 <code>/health</code> 端点时，Actuator会汇总所有已启用的 <code>HealthIndicator</code> 的检查结果。只有当<strong>所有</strong>指示器的状态都是 <code>UP</code> 时，总的健康状态才是 <code>UP</code>。任何一个指示器状态为 <code>DOWN</code>，总状态就会变为 <code>DOWN</code>。</li>
</ul>
<hr>
<h4 id="3-1-4-如何使用-Actuator？"><a href="#3-1-4-如何使用-Actuator？" class="headerlink" title="3.1.4 如何使用 Actuator？"></a>3.1.4 如何使用 Actuator？</h4><h5 id="1-添加-spring-boot-starter-actuator-依赖"><a href="#1-添加-spring-boot-starter-actuator-依赖" class="headerlink" title="1. 添加 spring-boot-starter-actuator 依赖"></a>1. 添加 <code>spring-boot-starter-actuator</code> 依赖</h5><p>在你的 <code>pom.xml</code> 中添加起步依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一旦添加了这个依赖，Spring Boot的自动配置就会生效，为你注册所有Actuator相关的Bean。</p>
<hr>
<h5 id="2-配置端点的暴露"><a href="#2-配置端点的暴露" class="headerlink" title="2. 配置端点的暴露"></a>2. 配置端点的暴露</h5><p>出于安全考虑，Spring Boot 2.x 及以上版本，<strong>默认只通过HTTP暴露 <code>/health</code> 和 <code>/info</code> 两个端点</strong>。如果你想暴露更多的端点（如 <code>/metrics</code>, <code>/beans</code> 等），需要在 <code>application.yml</code> 中进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="comment"># 暴露所有端点，用 &#x27;*&#x27;</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="comment"># 也可以指定暴露哪些，例如: include: health,info,metrics,beans</span></span><br><span class="line">        <span class="comment"># 如果想排除某些端点，可以用 exclude</span></span><br><span class="line">        <span class="comment"># exclude: env,beans</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># （可选）如果想修改Actuator端点的基础路径 (默认为 /actuator)</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="comment"># （可选）配置health端点显示更多细节</span></span><br><span class="line">      <span class="comment"># NEVER: 不显示, WHEN_AUTHORIZED: 授权用户看, ALWAYS: 总是显示</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span> </span><br></pre></td></tr></table></figure>

<p>完成这两步后，重启你的应用，就可以通过 <code>http://localhost:8080/actuator</code> 来查看所有已暴露的端点列表了。</p>
<hr>
<h4 id="3-1-5-Actuator-带来的价值"><a href="#3-1-5-Actuator-带来的价值" class="headerlink" title="3.1.5 Actuator 带来的价值"></a>3.1.5 Actuator 带来的价值</h4><ol>
<li><strong>标准化的应用洞察力</strong>: 提供了一套统一的接口来了解应用的内部状态，无需为每个项目重复发明轮子。</li>
<li><strong>DevOps 和 SRE 的利器</strong>: 为运维和网站可靠性工程师提供了强大的工具，用于自动化监控、健康检查、告警和故障排查。</li>
<li><strong>与监控生态无缝集成</strong>: Actuator 的 <code>/prometheus</code> 端点可以直接输出Prometheus格式的指标，<code>/health</code> 端点可以被Kubernetes的存活探针（Liveness Probe）和就绪探针（Readiness Probe）直接使用。</li>
<li><strong>动态管理能力</strong>: 一些端点（如 <code>/loggers</code>）甚至允许你在<strong>运行时</strong>动态修改应用的配置（如调整某个类的日志级别），而无需重启应用，这对于线上问题排查非常有用。</li>
</ol>
<hr>
<h3 id="3-2-常用端点-Endpoints-介绍"><a href="#3-2-常用端点-Endpoints-介绍" class="headerlink" title="3.2 常用端点 (Endpoints) 介绍"></a>3.2 常用端点 (Endpoints) 介绍</h3><p>当你在 <code>application.yml</code> 中通过 <code>management.endpoints.web.exposure.include=&quot;*&quot;</code> 暴露了所有Web端点后，你就可以通过访问 <code>http://&lt;host&gt;:&lt;port&gt;/actuator/{endpoint-id}</code> 来获取各种信息。</p>
<hr>
<h4 id="3-2-1-health-应用健康检查"><a href="#3-2-1-health-应用健康检查" class="headerlink" title="3.2.1 /health - 应用健康检查"></a>3.2.1 <code>/health</code> - 应用健康检查</h4><ul>
<li><p><strong>路径</strong>: <code>/actuator/health</code></p>
</li>
<li><p><strong>用途</strong>: <strong>这是最重要的端点之一</strong>。它用于检查应用程序的整体健康状况，是自动化监控系统（如负载均衡器、服务发现组件、Kubernetes探针）判断应用是否存活和就绪的核心依据。</p>
</li>
<li><p><strong>返回信息</strong>:</p>
<ul>
<li><p>它会聚合所有已配置的 <code>HealthIndicator</code>（健康指示器）的状态。</p>
</li>
<li><p><strong>默认配置下</strong>，它只返回一个总的 <code>status</code> 字段，值为 <code>UP</code> 或 <code>DOWN</code>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>当 <code>management.endpoint.health.show-details=always</code> 时</strong>，它会返回详细的组件健康信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;components&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;db&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;database&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MySQL&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;validationQuery&quot;</span><span class="punctuation">:</span> <span class="string">&quot;isValid()&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;diskSpace&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">123456789</span><span class="punctuation">,</span> <span class="attr">&quot;free&quot;</span><span class="punctuation">:</span> <span class="number">12345678</span><span class="punctuation">,</span> <span class="attr">&quot;threshold&quot;</span><span class="punctuation">:</span> <span class="number">10485760</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ping&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;redis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6.2.5&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>只要有一个组件的 <code>status</code> 是 <code>DOWN</code>，总的 <code>status</code> 就会是 <code>DOWN</code>。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-2-info-应用基本信息"><a href="#3-2-2-info-应用基本信息" class="headerlink" title="3.2.2 /info - 应用基本信息"></a>3.2.2 <code>/info</code> - 应用基本信息</h4><ul>
<li><p><strong>路径</strong>: <code>/actuator/info</code></p>
</li>
<li><p><strong>用途</strong>: 提供一些通用的、非敏感的应用程序信息。这些信息通常是静态的，用于快速识别应用的版本、构建信息等。</p>
</li>
<li><p><strong>返回信息</strong>: 默认情况下是空的 <code>{}</code>。你需要自己在 <code>application.yml</code> 中配置 <code>info.*</code> 属性，或者通过构建工具插件自动生成。</p>
</li>
<li><p><strong>示例配置 (<code>application.yml</code>)</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">Awesome</span> <span class="string">App</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">a</span> <span class="string">demo</span> <span class="string">application</span> <span class="string">for</span> <span class="string">Spring</span> <span class="string">Boot</span> <span class="string">Actuator.</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">contact:</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">devteam@example.com</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回结果</strong>:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;app&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Awesome App&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is a demo application for Spring Boot Actuator.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;contact&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;devteam@example.com&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自动生成构建信息</strong>: 在<code>pom.xml</code>中加入 <code>spring-boot-maven-plugin</code> 的 <code>build-info</code> 目标，可以自动将Git提交信息、构建时间等加入到 <code>/info</code> 端点。</p>
</li>
</ul>
<hr>
<h4 id="3-2-3-metrics-详细度量指标"><a href="#3-2-3-metrics-详细度量指标" class="headerlink" title="3.2.3 /metrics - 详细度量指标"></a>3.2.3 <code>/metrics</code> - 详细度量指标</h4><ul>
<li><p><strong>路径</strong>: <code>/actuator/metrics</code></p>
</li>
<li><p><strong>用途</strong>: <strong>性能监控和问题排查的核心</strong>。它提供了大量关于应用程序运行时的详细度量指标，如JVM内存使用、CPU使用率、HTTP请求统计等。</p>
</li>
<li><p><strong>使用方式</strong>:</p>
<ul>
<li><p>访问 <code>/actuator/metrics</code> 会列出所有<strong>可用的度量指标名称</strong>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;names&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;jvm.memory.used&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;jvm.gc.pause&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http.server.requests&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;process.cpu.usage&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;system.cpu.count&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ... 还有很多</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问 <code>/actuator/metrics/{metric-name}</code> 来获取某个具体指标的详细数据。例如 <code>/actuator/metrics/jvm.memory.used</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jvm.memory.used&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The amount of used memory&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;baseUnit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;measurements&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;statistic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VALUE&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">1.23456789E8</span> <span class="punctuation">&#125;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;availableTags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;area&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;heap&quot;</span><span class="punctuation">,</span> <span class="string">&quot;nonheap&quot;</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;G1 Old Gen&quot;</span><span class="punctuation">,</span> <span class="string">&quot;G1 Survivor Space&quot;</span><span class="punctuation">,</span> ... <span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>你可以使用标签（Tags）来筛选数据，例如：<code>/actuator/metrics/http.server.requests?tag=status:200&amp;tag=uri:/api/users</code> 可以查看特定URI和状态码的请求统计。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-4-beans-Spring容器中的Bean"><a href="#3-2-4-beans-Spring容器中的Bean" class="headerlink" title="3.2.4 /beans - Spring容器中的Bean"></a>3.2.4 <code>/beans</code> - Spring容器中的Bean</h4><ul>
<li><p><strong>路径</strong>: <code>/actuator/beans</code></p>
</li>
<li><p><strong>用途</strong>: 展示Spring IoC容器中所有已加载的Bean的完整列表。这对于调试和理解应用的组件构成非常有用。</p>
</li>
<li><p><strong>返回信息</strong>: 返回一个包含所有Bean信息的JSON数组。每个Bean的信息包括：</p>
<ul>
<li><code>bean</code>: Bean的名称&#x2F;ID。</li>
<li><code>aliases</code>: Bean的别名。</li>
<li><code>scope</code>: Bean的作用域（如 <code>singleton</code>, <code>prototype</code>）。</li>
<li><code>type</code>: Bean的完整类名。</li>
<li><code>resource</code>: Bean定义的来源（例如，哪个配置类）。</li>
<li><code>dependencies</code>: 该Bean依赖的其他Bean。</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;contexts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;application-1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;beans&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;myController&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;aliases&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;singleton&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.example.MyController&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file [/path/to/classes/com.example.MyController.class]&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;myService&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// ... 其他所有Bean</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-5-env-环境变量与配置"><a href="#3-2-5-env-环境变量与配置" class="headerlink" title="3.2.5 /env - 环境变量与配置"></a>3.2.5 <code>/env</code> - 环境变量与配置</h4><ul>
<li><strong>路径</strong>: <code>/actuator/env</code></li>
<li><strong>用途</strong>: 显示应用程序当前生效的所有环境属性。这包括来自操作系统、JVM、配置文件、命令行等所有来源的配置。</li>
<li><strong>返回信息</strong>:<ul>
<li>它会列出所有激活的Profile（<code>activeProfiles</code>）。</li>
<li>它会按优先级顺序列出所有的属性源（<code>propertySources</code>），并显示每个源中的具体属性。</li>
<li><strong>安全警告</strong>: <code>/env</code> 端点可能会暴露<strong>敏感信息</strong>（如数据库密码、API密钥），因此在生产环境中必须<strong>谨慎暴露</strong>，或者通过配置<code>management.endpoint.env.keys-to-sanitize</code>来对敏感键进行脱敏处理。</li>
</ul>
</li>
<li><strong>获取单个属性</strong>: 访问 <code>/actuator/env/{property-name}</code> 可以获取单个属性的值，例如 <code>/actuator/env/server.port</code>。</li>
</ul>
<hr>
<h4 id="3-2-6-loggers-日志级别管理"><a href="#3-2-6-loggers-日志级别管理" class="headerlink" title="3.2.6 /loggers - 日志级别管理"></a>3.2.6 <code>/loggers</code> - 日志级别管理</h4><ul>
<li><p><strong>路径</strong>: <code>/actuator/loggers</code></p>
</li>
<li><p><strong>用途</strong>: <strong>动态管理应用的日志级别，无需重启</strong>。这是线上问题排查的“神器”。</p>
</li>
<li><p><strong>使用方式</strong>:</p>
<ul>
<li><p><strong><code>GET /actuator/loggers</code></strong>: 获取所有logger的当前配置级别。</p>
</li>
<li><p><strong><code>GET /actuator/loggers/{logger-name}</code></strong>: 获取指定logger（包名或类名）的配置级别。</p>
<ul>
<li>例如：<code>GET /actuator/loggers/com.example.service</code></li>
</ul>
</li>
<li><p><strong><code>POST /actuator/loggers/{logger-name}</code></strong>: <strong>修改</strong>指定logger的日志级别。</p>
<ul>
<li><p><strong>请求体 (JSON)</strong>: <code>{&quot;configuredLevel&quot;: &quot;DEBUG&quot;}</code></p>
</li>
<li><p><strong>示例 (使用curl)</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">-d <span class="string">&#x27;&#123;&quot;configuredLevel&quot;: &quot;DEBUG&quot;&#125;&#x27;</span> \</span><br><span class="line">http://localhost:8080/actuator/loggers/com.example.service</span><br></pre></td></tr></table></figure>

<p>执行后，<code>com.example.service</code> 包下的所有类的日志输出级别会立即变为<code>DEBUG</code>。将<code>configuredLevel</code>设为<code>null</code>可以重置为默认级别。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-7-其他常用端点"><a href="#3-2-7-其他常用端点" class="headerlink" title="3.2.7 其他常用端点"></a>3.2.7 其他常用端点</h4><ul>
<li><strong><code>/mappings</code></strong>: 显示所有 <code>@RequestMapping</code> 的路径映射信息，包括哪个Controller的哪个方法处理哪个URL。</li>
<li><strong><code>/threaddump</code></strong>: 生成并返回当前应用的线程转储信息，用于分析线程死锁、性能瓶颈等问题。</li>
<li><strong><code>/heapdump</code></strong>: 生成并下载一个JVM堆转储文件（<code>hprof</code>格式），用于分析内存泄漏问题。<strong>这是一个重量级操作，请谨慎在生产环境使用</strong>。</li>
<li><strong><code>/shutdown</code></strong>: 通过<code>POST</code>请求可以<strong>优雅地关闭</strong>应用程序。默认是禁用的，需要通过<code>management.endpoint.shutdown.enabled=true</code>开启。</li>
</ul>
<hr>
<h3 id="3-3-定制化Actuator端点"><a href="#3-3-定制化Actuator端点" class="headerlink" title="3.3 定制化Actuator端点"></a>3.3 定制化Actuator端点</h3><h4 id="3-3-1-定制现有端点"><a href="#3-3-1-定制现有端点" class="headerlink" title="3.3.1 定制现有端点"></a>3.3.1 定制现有端点</h4><h5 id="1-定制-health-端点-编写自定义-HealthIndicator"><a href="#1-定制-health-端点-编写自定义-HealthIndicator" class="headerlink" title="1. 定制 /health 端点 (编写自定义 HealthIndicator)"></a>1. 定制 <code>/health</code> 端点 (编写自定义 <code>HealthIndicator</code>)</h5><p>这是最常见的定制需求。当你的应用依赖于一些Spring Boot没有内置健康检查的外部服务时（例如一个特定的RPC服务、一个文件系统挂载点、一个自定义的第三方API），你可以通过实现 <code>HealthIndicator</code> 接口来创建自己的健康检查逻辑。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>创建一个类实现 <code>HealthIndicator</code> 接口。</li>
<li>实现 <code>health()</code> 方法。这个方法需要返回一个 <code>Health</code> 对象。</li>
<li>使用 <code>Health.up()</code>、<code>Health.down()</code>、<code>Health.outOfService()</code> 等构建器来创建返回结果。</li>
<li>可以使用 <code>.withDetail(&quot;key&quot;, &quot;value&quot;)</code> 来添加详细信息。</li>
<li>将这个类注册为一个Spring Bean (通常使用 <code>@Component</code> 注解)。</li>
</ol>
<p><strong>示例：检查一个外部API是否可用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.Health;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.HealthIndicator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;myExternalApi&quot;)</span> <span class="comment">// Bean的名字会成为health组件的key</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalApiHealthIndicator</span> <span class="keyword">implements</span> <span class="title class_">HealthIndicator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Health <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试调用外部API的某个状态检查接口</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">apiUrl</span> <span class="operator">=</span> <span class="string">&quot;https://api.example.com/status&quot;</span>;</span><br><span class="line">            <span class="comment">// 假设API成功时返回 &quot;OK&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> restTemplate.getForObject(apiUrl, String.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equalsIgnoreCase(response)) &#123;</span><br><span class="line">                <span class="comment">// 如果API正常，返回UP状态，并带上一些额外信息</span></span><br><span class="line">                <span class="keyword">return</span> Health.up().withDetail(<span class="string">&quot;url&quot;</span>, apiUrl).withDetail(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;Available&quot;</span>).build();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果API返回非预期内容，返回DOWN状态</span></span><br><span class="line">                <span class="keyword">return</span> Health.down().withDetail(<span class="string">&quot;url&quot;</span>, apiUrl).withDetail(<span class="string">&quot;response&quot;</span>, response).build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 如果调用过程中发生异常，返回DOWN状态，并带上异常信息</span></span><br><span class="line">            <span class="keyword">return</span> Health.down(e).withDetail(<span class="string">&quot;error&quot;</span>, e.getMessage()).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong>：重启应用后，再次访问 <code>/actuator/health</code>，你会在 <code>components</code> 字段下看到一个名为 <code>myExternalApi</code> 的新条目，显示你自定义的健康检查结果。</p>
<hr>
<h5 id="2-定制-info-端点-编写自定义-InfoContributor"><a href="#2-定制-info-端点-编写自定义-InfoContributor" class="headerlink" title="2. 定制 /info 端点 (编写自定义 InfoContributor)"></a>2. 定制 <code>/info</code> 端点 (编写自定义 <code>InfoContributor</code>)</h5><p>与<code>/health</code>类似，你可以通过实现 <code>InfoContributor</code> 接口，动态地向 <code>/info</code> 端点添加信息。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>创建一个类实现 <code>InfoContributor</code> 接口。</li>
<li>实现 <code>contribute()</code> 方法，通过 <code>builder</code> 对象添加信息。</li>
<li>将这个类注册为一个Spring Bean。</li>
</ol>
<p><strong>示例：添加当前激活的Spring Profiles到 <code>/info</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.Info;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.InfoContributor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveProfilesInfoContributor</span> <span class="keyword">implements</span> <span class="title class_">InfoContributor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ActiveProfilesInfoContributor</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contribute</span><span class="params">(Info.Builder builder)</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前激活的profiles添加到info端点的一个&quot;activeProfiles&quot;键下</span></span><br><span class="line">        builder.withDetail(<span class="string">&quot;activeProfiles&quot;</span>, Arrays.asList(environment.getActiveProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong>：重启应用后，访问 <code>/actuator/info</code>，会看到新增的 <code>activeProfiles</code> 字段。</p>
<hr>
<h4 id="3-3-2-创建全新端点-实现-Endpoint"><a href="#3-3-2-创建全新端点-实现-Endpoint" class="headerlink" title="3.3.2 创建全新端点 (实现 @Endpoint)"></a>3.3.2 创建全新端点 (实现 <code>@Endpoint</code>)</h4><p>如果你需要一个完全自定义的管理功能，你可以创建自己的Actuator端点。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>创建一个类，并使用 <code>@Endpoint(id = &quot;...&quot;)</code> 注解标记它。<code>id</code> 属性将成为端点的路径（如 <code>id = &quot;custom&quot;</code>，路径就是 <code>/actuator/custom</code>）。</li>
<li>将这个类注册为一个Spring Bean (<code>@Component</code>)。</li>
<li>在类中创建方法，并使用 <code>@ReadOperation</code>, <code>@WriteOperation</code>, <code>@DeleteOperation</code> 来标记它们，分别对应HTTP的GET, POST, DELETE方法。</li>
<li>方法的参数可以用来接收URL路径变量 (<code>@Selector</code>) 或请求参数。</li>
</ol>
<p><strong>示例：创建一个 <code>/sessions</code> 端点来查看和管理用户会话</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.endpoint.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Endpoint(id = &quot;sessions&quot;)</span> <span class="comment">// 端点ID为 &quot;sessions&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionsEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一个Session存储</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; sessions = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟添加一些初始会话</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SessionsEndpoint</span><span class="params">()</span> &#123;</span><br><span class="line">        sessions.put(<span class="string">&quot;user-alice&quot;</span>, <span class="string">&quot;alice-session-id-123&quot;</span>);</span><br><span class="line">        sessions.put(<span class="string">&quot;user-bob&quot;</span>, <span class="string">&quot;bob-session-id-456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应 GET /actuator/sessions</span></span><br><span class="line">    <span class="meta">@ReadOperation</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">getAllSessions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sessions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应 GET /actuator/sessions/&#123;username&#125;</span></span><br><span class="line">    <span class="comment">// @Selector会将路径变量注入到方法参数中</span></span><br><span class="line">    <span class="meta">@ReadOperation</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSessionByUsername</span><span class="params">(<span class="meta">@Selector</span> String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sessions.get(<span class="string">&quot;user-&quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应 POST /actuator/sessions/&#123;username&#125;</span></span><br><span class="line">    <span class="comment">// @WriteOperation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrUpdateSession</span><span class="params">(<span class="meta">@Selector</span> String username, String sessionId)</span> &#123;</span><br><span class="line">        sessions.put(<span class="string">&quot;user-&quot;</span> + username, sessionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应 DELETE /actuator/sessions/&#123;username&#125;</span></span><br><span class="line">    <span class="meta">@DeleteOperation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteSession</span><span class="params">(<span class="meta">@Selector</span> String username)</span> &#123;</span><br><span class="line">        sessions.remove(<span class="string">&quot;user-&quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong>：</p>
<ul>
<li><code>GET /actuator/sessions</code>: 返回所有会话。</li>
<li><code>GET /actuator/sessions/alice</code>: 返回alice的会话ID。</li>
<li><code>POST /actuator/sessions/charlie</code> (请求体为<code>{&quot;sessionId&quot;: &quot;charlie-session-id-789&quot;}</code>): 新增charlie的会话。</li>
<li><code>DELETE /actuator/sessions/bob</code>: 删除bob的会话。</li>
</ul>
<p><strong>不要忘记暴露新端点</strong>：</p>
<p>需要在 <code>application.yml</code> 中将新端点加入暴露列表：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">health,info,sessions</span> <span class="comment"># 别忘了加上 sessions</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-3-安全与暴露策略定制"><a href="#3-3-3-安全与暴露策略定制" class="headerlink" title="3.3.3 安全与暴露策略定制"></a>3.3.3 安全与暴露策略定制</h4><p>Actuator端点可能会暴露敏感信息，因此对其进行安全控制非常重要。</p>
<h5 id="1-精细化暴露"><a href="#1-精细化暴露" class="headerlink" title="1. 精细化暴露"></a>1. 精细化暴露</h5><p>如前所述，使用 <code>include</code> 和 <code>exclude</code> 来精确控制哪些端点通过Web暴露。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">health,info,prometheus</span> <span class="comment"># 只暴露这三个</span></span><br><span class="line">        <span class="comment"># exclude: beans,env # 明确排除这两个</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-修改基础路径和端口"><a href="#2-修改基础路径和端口" class="headerlink" title="2. 修改基础路径和端口"></a>2. 修改基础路径和端口</h5><p>你可以将Actuator端点运行在一个与主应用不同的端口上，以实现网络层面的隔离。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span> <span class="comment"># Actuator端点将运行在8081端口</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># 只允许本地访问</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">base-path:</span> <span class="string">/manage</span> <span class="comment"># 将基础路径从 /actuator 改为 /manage</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-集成Spring-Security"><a href="#3-集成Spring-Security" class="headerlink" title="3. 集成Spring Security"></a>3. 集成Spring Security</h5><p>如果你的项目中引入了<code>spring-boot-starter-security</code>，<strong>Actuator的所有端点（除了<code>/health</code>和<code>/info</code>）默认都会被安全机制保护</strong>。你需要提供正确的认证信息（如用户名密码）才能访问。</p>
<p>你可以通过Spring Security的配置，为Actuator端点定义更精细的访问规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActuatorSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint()) <span class="comment">// 匹配所有Actuator端点</span></span><br><span class="line">            .authorizeRequests(requests -&gt; requests</span><br><span class="line">                .requestMatchers(EndpointRequest.to(ShutdownEndpoint.class))</span><br><span class="line">                .hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// /shutdown端点需要ADMIN角色</span></span><br><span class="line">                .anyRequest().permitAll() <span class="comment">// 其他端点允许所有认证用户访问</span></span><br><span class="line">            )</span><br><span class="line">            .httpBasic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个配置要求访问<code>/shutdown</code>端点需要<code>ADMIN</code>角色，而访问其他端点只需通过HTTP Basic认证即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/29/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/29/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/" class="post-title-link" itemprop="url">Spring全家桶-SpringFramework</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-29 15:53:40" itemprop="dateCreated datePublished" datetime="2025-09-29T15:53:40+08:00">2025-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:09:46" itemprop="dateModified" datetime="2025-10-17T11:09:46+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言：Spring生态系统"><a href="#前言：Spring生态系统" class="headerlink" title="前言：Spring生态系统"></a>前言：Spring生态系统</h1><h2 id="1-Spring是什么？"><a href="#1-Spring是什么？" class="headerlink" title="1. Spring是什么？"></a>1. Spring是什么？</h2><p>Spring 是一个<strong>开源的、轻量级的Java应用程序开发框架</strong>，其最初目标是为了简化传统 Java EE（企业级应用）的开发。</p>
<p>可以从三个层面理解它：</p>
<ol>
<li><strong>从思想层面</strong>：Spring 是一个**“管理对象”的容器**。它基于两大核心思想：<ul>
<li><strong>控制反转 (IoC - Inversion of Control)</strong>：将对象的创建权和依赖关系的管理权从代码中移交给了Spring容器，极大地降低了代码的耦合度。</li>
<li><strong>面向切面编程 (AOP - Aspect-Oriented Programming)</strong>：将日志、事务、安全等“横切关注点”从主业务逻辑中分离出来，提高了代码的模块化程度和可维护性。</li>
</ul>
</li>
<li><strong>从功能层面</strong>：Spring 提供了一整套**“一站式”的企业级应用解决方案**。它不仅仅是一个IoC容器，还无缝整 合了Web开发（Spring MVC&#x2F;WebFlux）、数据访问（Spring Data）、事务管理、安全控制（Spring Security）等众多优秀的技术，让开发者无需重复“造轮子”。</li>
<li><strong>从生态层面</strong>：Spring 已经发展成为一个庞大而繁荣的<strong>生态系统 (Ecosystem)</strong>。以 Spring Framework 为基石，衍生出了 Spring Boot（简化开发）、Spring Cloud（微服务治理）等一系列项目，共同构成了现代Java开发的事实标准。</li>
</ol>
<p><strong>总之，Spring 的使命是：让Java开发更简单、更高效、更健壮。</strong></p>
<hr>
<h2 id="2-Spring全家桶"><a href="#2-Spring全家桶" class="headerlink" title="2. Spring全家桶"></a>2. Spring全家桶</h2><p>Spring 全家桶（Ecosystem）指的是围绕 Spring Framework 核心构建的一系列项目，它们协同工作，覆盖了现代应用开发的方方面面。</p>
<ul>
<li><strong>核心 - Spring Framework</strong>:<ul>
<li>是整个生态的基石。提供了最核心的功能，如 IoC容器、AOP、事务管理、数据访问等。其他所有项目都构建于此之上。</li>
</ul>
</li>
<li><strong>主要项目 - Spring Boot &amp; Spring Cloud</strong>:<ul>
<li><strong>Spring Boot</strong>：<strong>“脚手架”和“助推器”</strong>。它极大地简化了Spring应用的初始搭建和开发过程，遵循“约定优于配置”的原则，实现了开箱即用。<strong>我们现在开发Spring应用，基本都是通过Spring Boot来启动。</strong></li>
<li><strong>Spring Cloud</strong>：<strong>“微服务工具箱”</strong>。基于Spring Boot，它提供了一整套用于构建分布式系统（微服务架构）的解决方案，如服务发现、配置中心、API网关、熔断器等。</li>
</ul>
</li>
<li><strong>专项解决方案 - Spring Data, Spring Security 等</strong>:<ul>
<li><strong>Spring Data</strong>: <strong>“数据访问利器”</strong>。它的目标是简化数据访问层的开发，无论是关系型数据库 (JPA)、NoSQL数据库 (Redis, MongoDB) 还是搜索引擎 (Elasticsearch)，它都提供了一致的、基于 Repository 的编程模型。</li>
<li><strong>Spring Security</strong>: <strong>“安全护卫”</strong>。为Spring应用提供强大且可定制的认证（Authentication）和授权（Authorization）功能。</li>
<li><strong>Spring MVC &#x2F; WebFlux</strong>: Spring Framework 内置的Web框架，分别是同步阻塞和异步非阻塞模型的代表，是构建Web应用的基石。</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="一、SpringFramework-核心"><a href="#一、SpringFramework-核心" class="headerlink" title="一、SpringFramework 核心"></a>一、SpringFramework 核心</h1><h2 id="1-核心容器"><a href="#1-核心容器" class="headerlink" title="1. 核心容器"></a>1. 核心容器</h2><h3 id="1-1-控制反转-IoC"><a href="#1-1-控制反转-IoC" class="headerlink" title="1.1 控制反转(IoC)"></a>1.1 控制反转(IoC)</h3><p>IoC（Inversion of Control），即“控制反转”，是Spring框架的基石。它是一种重要的面向对象编程的设计原则，<strong>其核心思想是将传统上由程序代码直接操控的对象创建、依赖关系管理的权力，交（反转）给一个专门的第三方容器来控制。</strong></p>
<h4 id="1-1-1-什么是”控制反转”？"><a href="#1-1-1-什么是”控制反转”？" class="headerlink" title="1.1.1 什么是”控制反转”？"></a>1.1.1 什么是”控制反转”？</h4><ul>
<li><p><strong>传统控制方式（正向控制）：</strong> 假设 <code>UserService</code> 需要使用 <code>UserDao</code> 来操作数据库。在传统模式下，<code>UserService</code> 内部会主动创建或获取 <code>UserDao</code> 的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// UserService 主动创建 UserDao，控制权在自己手中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        userDao.save(user);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>UserService</code> 牢牢地控制着对 <code>UserDao</code> 的依赖。如果 <code>UserDao</code> 的实现类发生变化（例如从 <code>UserDaoImpl</code> 变成 <code>UserDaoMyBatisImpl</code>），我们就必须修改 <code>UserService</code> 的源代码。这导致了组件之间的高度耦合。</p>
</li>
<li><p><strong>控制反转 (IoC)：</strong> 在IoC模式下，<code>UserService</code> 不再主动创建 <code>UserDao</code>。它只需要声明“我需要一个<code>UserDao</code>”，而不再关心这个 <code>UserDao</code> 是如何被创建、它具体是哪个实现类。这个创建和“给予”的过程由Spring IoC容器来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// UserService 不再主动创建，而是等待外部“注入”</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring容器会通过这个方法将UserDao实例“塞”进来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        userDao.save(user); <span class="comment">// 直接使用，无需关心其来源</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>控制权从 <code>UserService</code> 手中被反转到了Spring容器手中</strong>，<code>UserService</code> 从一个主动的“索取者”变成了被动的“接收者”。</p>
</li>
</ul>
<hr>
<h4 id="1-1-2-IoC实现方式"><a href="#1-1-2-IoC实现方式" class="headerlink" title="1.1.2 IoC实现方式"></a>1.1.2 IoC实现方式</h4><p>控制反转（IoC）是一种设计思想，而不是一种具体的技术。要实现这种思想，业界主要有两种主流的方式：<strong>依赖注入（Dependency Injection, DI）和 依赖查找（Dependency Lookup, DL）</strong>。Spring框架主要使用<strong>依赖注入</strong>来实现其IoC容器。</p>
<h5 id="1-依赖注入-Dependency-Injection-DI"><a href="#1-依赖注入-Dependency-Injection-DI" class="headerlink" title="1. 依赖注入 (Dependency Injection - DI)"></a>1. 依赖注入 (Dependency Injection - DI)</h5><p>这是最常用、也是Spring推荐的实现方式。</p>
<ul>
<li><p><strong>核心思想</strong>：容器<strong>主动地</strong>将一个对象所依赖的其他对象（依赖项）“注入”到该对象中。对象本身是<strong>被动</strong>的，它只负责接收，不关心依赖从哪里来，如何创建。</p>
</li>
<li><p><strong>比喻</strong>：就像你点外卖。你（<code>UserService</code>）只需要告诉平台“我需要一份宫保鸡丁”（<code>UserDao</code>），然后在家等着就行。外卖小哥（Spring容器）会把做好的宫保鸡丁送到你手上。你是一个被动的接收者。</p>
</li>
<li><p><strong>实现形式</strong>：Spring支持三种主要的注入形式，这将在后续章节详细介绍：</p>
<ul>
<li><strong>构造器注入</strong>：通过类的构造函数传入依赖。</li>
<li><strong>Setter注入</strong>：通过<code>setXxx()</code>方法传入依赖。</li>
<li><strong>字段注入</strong>：直接在成员变量上使用注解（如<code>@Autowired</code>）注入。</li>
</ul>
</li>
<li><p><strong>代码体现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 依赖项，等待容器来填充</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形式一：构造器注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形式二：Setter注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...业务方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>UserService</code> 并没有自己去创建<code>UserDao</code>，而是被动地等待Spring容器将一个<code>UserDao</code>的实例通过构造函数或setter方法传递进来。</p>
</li>
</ul>
<hr>
<h5 id="2-依赖查找-Dependency-Lookup-DL"><a href="#2-依赖查找-Dependency-Lookup-DL" class="headerlink" title="2. 依赖查找 (Dependency Lookup - DL)"></a>2. 依赖查找 (Dependency Lookup - DL)</h5><p>这种方式相对不常用，但在某些特定场景下有用。</p>
<ul>
<li><p><strong>核心思想</strong>：容器不主动注入，而是对象在需要时，<strong>主动地</strong>向容器“查找”并获取它所需要的依赖项。对象是<strong>主动</strong>的，它需要知道容器的存在，并向容器发出请求。</p>
</li>
<li><p><strong>比喻</strong>：就像你自己去餐厅吃饭。你（<code>UserService</code>）需要知道餐厅（Spring容器）的地址，然后主动走进去，跟服务员说“给我来一份宫保鸡丁”（<code>UserDao</code>）。你是一个主动的索取者。</p>
</li>
<li><p><strong>实现形式</strong>：通常通过调用容器提供的API来完成，例如在Spring中调用<code>ApplicationContext</code>的<code>getBean()</code>方法。</p>
</li>
<li><p><strong>代码体现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 主动向Spring容器请求UserDao实例</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> ...; <span class="comment">// 需要先获取到容器的引用 </span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> context.getBean(UserDao.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        userDao.save(user);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-DI-与-DL-的对比与总结"><a href="#3-DI-与-DL-的对比与总结" class="headerlink" title="3. DI 与 DL 的对比与总结"></a>3. DI 与 DL 的对比与总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">依赖注入 (DI)</th>
<th align="left">依赖查找 (DL)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>角色</strong></td>
<td align="left">组件是被动接收者 (Passive)</td>
<td align="left">组件是主动索取者 (Active)</td>
</tr>
<tr>
<td align="left"><strong>耦合度</strong></td>
<td align="left"><strong>低</strong>。业务代码不依赖于任何容器API，对容器无感知。</td>
<td align="left"><strong>高</strong>。业务代码必须依赖容器API（如<code>ApplicationContext</code>）。</td>
</tr>
<tr>
<td align="left"><strong>代码侵入性</strong></td>
<td align="left"><strong>低</strong>。代码更简洁，是普通的POJO（Plain Old Java Object）。</td>
<td align="left"><strong>高</strong>。容器API侵入到业务代码中。</td>
</tr>
<tr>
<td align="left"><strong>推荐程度</strong></td>
<td align="left"><strong>强烈推荐</strong>。这是Spring的核心和精髓。</td>
<td align="left"><strong>不推荐</strong>。仅在无法使用DI的特殊场景下（如静态工具类）考虑。</td>
</tr>
</tbody></table>
<p><strong>结论</strong>：</p>
<p>Spring框架之所以强大和流行，很大程度上是因为它极力推崇并完美实现了<strong>依赖注入（DI）</strong>。DI是实现IoC思想的最佳实践，它让我们的代码与框架解耦，变得更加清晰、灵活且易于单元测试。</p>
<hr>
<h3 id="1-2-Spring-IoC容器"><a href="#1-2-Spring-IoC容器" class="headerlink" title="1.2 Spring IoC容器"></a>1.2 Spring IoC容器</h3><h4 id="1-2-1-容器的职责"><a href="#1-2-1-容器的职责" class="headerlink" title="1.2.1 容器的职责"></a>1.2.1 容器的职责</h4><p>Spring IoC 容器是整个 Spring 框架的心脏。它的核心职责可以概括为：<strong>统一管理应用中所有对象（Bean）的创建、配置、组装和生命周期</strong>。</p>
<h5 id="1-Bean的创建与装配-Bean-Creation-and-Wiring"><a href="#1-Bean的创建与装配-Bean-Creation-and-Wiring" class="headerlink" title="1. Bean的创建与装配 (Bean Creation and Wiring)"></a>1. Bean的创建与装配 (Bean Creation and Wiring)</h5><ul>
<li><strong>创建 (Instantiation)</strong>：这是容器最基础的职责。开发者不再需要在代码中使用 <code>new</code> 关键字来创建对象，而是通过配置文件（XML）、注解（<code>@Component</code>）或Java配置（<code>@Bean</code>），告诉容器“需要创建哪些类的对象”。容器会负责在适当的时机实例化这些对象。</li>
<li><strong>装配 (Wiring&#x2F;Assembly)</strong>：也称为<strong>依赖注入 (DI)</strong>。当容器创建好一个Bean（如<code>UserService</code>）后，它会分析这个Bean依赖的其他Bean（如<code>UserDao</code>）。然后，容器会自动从自己管理的一堆Bean中找到匹配的<code>UserDao</code>实例，并将其“注入”到<code>UserService</code>中。这个过程解决了对象之间复杂的依赖关系，实现了“解耦”。</li>
</ul>
<hr>
<h5 id="2-Bean生命周期的管理-Bean-Lifecycle-Management"><a href="#2-Bean生命周期的管理-Bean-Lifecycle-Management" class="headerlink" title="2. Bean生命周期的管理 (Bean Lifecycle Management)"></a>2. Bean生命周期的管理 (Bean Lifecycle Management)</h5><p>容器的管理贯穿了一个Bean从诞生到销毁的全过程，是一个“管家式”服务。</p>
<ul>
<li><strong>实例化 (Instantiation)</strong>：通过反射创建Bean的实例。</li>
<li><strong>属性填充 (Populate Properties)</strong>：进行依赖注入，将Bean依赖的其他Bean或属性值设置进去。</li>
<li><strong>初始化 (Initialization)</strong>：在Bean准备就绪、可以被使用之前，执行一些自定义的初始化操作。例如，调用<code>@PostConstruct</code>注解的方法，或者执行<code>InitializingBean</code>接口的方法。</li>
<li><strong>使用 (In Use)</strong>：将初始化完成的Bean放入容器的“单例池”中，等待应用程序随时调用。</li>
<li><strong>销毁 (Destruction)</strong>：当容器关闭时，或者Bean不再需要时，执行一些清理工作。例如，调用<code>@PreDestroy</code>注解的方法，释放资源、关闭连接等。</li>
</ul>
<hr>
<h5 id="3-配置的集中管理-Centralized-Configuration"><a href="#3-配置的集中管理-Centralized-Configuration" class="headerlink" title="3. 配置的集中管理 (Centralized Configuration)"></a>3. 配置的集中管理 (Centralized Configuration)</h5><p>容器提供了一个统一的配置入口。无论是早期的XML文件，还是现在主流的Java Config和注解，所有关于Bean的定义和它们之间关系的配置都由容器统一解析和管理。这使得应用的结构一目了然，修改配置也变得非常方便，而不需要深入到业务代码中。</p>
<hr>
<h5 id="4-提供高级服务与集成-Providing-Advanced-Services"><a href="#4-提供高级服务与集成-Providing-Advanced-Services" class="headerlink" title="4. 提供高级服务与集成 (Providing Advanced Services)"></a>4. 提供高级服务与集成 (Providing Advanced Services)</h5><p>除了上述核心职责，<code>ApplicationContext</code>作为高级容器，还集成了许多企业级功能，将它们以非侵入的方式提供给Bean使用。</p>
<ul>
<li><strong>集成AOP</strong>：自动为符合切点（Pointcut）的Bean创建代理对象，实现面向切面编程，如声明式事务、日志记录等。</li>
<li><strong>事件发布&#x2F;监听 (Event Publishing)</strong>：支持应用内的组件通过事件进行解耦通信。</li>
<li><strong>国际化支持 (i18n)</strong>：提供处理多语言消息的机制。</li>
<li><strong>统一的资源访问</strong>：提供强大的<code>Resource</code>接口，可以透明地访问来自文件系统、类路径、URL等不同来源的资源。</li>
</ul>
<p><strong>总结来说，Spring IoC容器的根本目标是“让开发者专注于业务逻辑”。</strong> 它接管了所有与对象管理相关的繁琐、重复的底层工作，从而大大降低了应用的复杂性和组件间的耦合度，提升了代码的可维护性、可测试性和可扩展性。</p>
<hr>
<h4 id="1-2-2-两大核心接口"><a href="#1-2-2-两大核心接口" class="headerlink" title="1.2.2 两大核心接口"></a>1.2.2 两大核心接口</h4><p>Spring IoC 容器并非只有一个具体的实现，而是通过一系列接口来定义的。其中，<code>BeanFactory</code> 和 <code>ApplicationContext</code> 是两个最核心、最顶层的接口，它们共同构成了Spring容器的骨架。</p>
<h5 id="1-BeanFactory-IoC容器的“心脏”"><a href="#1-BeanFactory-IoC容器的“心脏”" class="headerlink" title="1. BeanFactory - IoC容器的“心脏”"></a>1. <code>BeanFactory</code> - IoC容器的“心脏”</h5><p><code>BeanFactory</code> 是Spring容器最基础、最核心的接口，它定义了IoC容器的基本行为规范。</p>
<ul>
<li><strong>定位</strong>：一个纯粹的 <strong>Bean 工厂</strong>。负责生产和管理Bean。</li>
<li><strong>核心功能</strong>：提供了访问Bean容器的根接口，其最核心的方法就是 <code>getBean(String name)</code>，用于获取容器中指定名称的Bean实例。</li>
<li><strong>核心特点：延迟加载 (Lazy Loading)</strong><ul>
<li>默认情况下，<code>BeanFactory</code> 在容器启动时并不会立即创建所有的Bean实例。</li>
<li>只有当第一次通过 <code>getBean()</code> 方法请求某个Bean时，<code>BeanFactory</code> 才会真正地去创建、初始化并返回该Bean的实例。</li>
<li><strong>优点</strong>：启动速度快，节省内存，特别是在资源受限的环境中（例如早期的Applet应用）。</li>
<li><strong>缺点</strong>：如果被请求的Bean存在配置错误（如类找不到、依赖缺失），这个错误只有在运行时第一次获取该Bean时才会被发现，而不是在应用启动时。这可能会导致应用运行一段时间后突然因配置问题而崩溃。</li>
</ul>
</li>
<li><strong>使用场景</strong>：由于其功能相对基础，<code>BeanFactory</code> 如今已<strong>很少被直接使用</strong>。学习它，主要是为了理解Spring IoC容器的底层工作原理。</li>
</ul>
<hr>
<h5 id="2-ApplicationContext-功能完备的“企业级”容器"><a href="#2-ApplicationContext-功能完备的“企业级”容器" class="headerlink" title="2. ApplicationContext - 功能完备的“企业级”容器"></a>2. <code>ApplicationContext</code> - 功能完备的“企业级”容器</h5><p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个<strong>子接口</strong>，也是我们实际开发中<strong>最常使用的容器接口</strong>。</p>
<ul>
<li><strong>定位</strong>：一个<strong>全能型的应用上下文</strong>。它继承了 <code>BeanFactory</code> 的所有功能，因此它也是一个Bean工厂。但在此基础上，它增加了大量面向企业级应用的高级特性。</li>
<li><strong>核心特点：即时加载 (Eager Loading)</strong><ul>
<li>与<code>BeanFactory</code>相反，<code>ApplicationContext</code> 在容器<strong>启动时</strong>，会一次性地创建并初始化所有<strong>单例（Singleton）作用域</strong>的Bean。</li>
<li><strong>优点</strong>：<strong>Fail-Fast（快速失败）机制</strong>。如果在配置中有任何错误（比如<code>@Autowired</code>的依赖找不到，Bean的类名写错等），应用在启动阶段就会立即抛出异常并失败，而不是等到运行时才暴露问题。这对于开发和部署阶段排查错误至关重要。</li>
<li><strong>缺点</strong>：相对于<code>BeanFactory</code>，启动时间会稍长，占用内存会稍多。但在现代服务器硬件条件下，这点开销通常可以忽略不计。</li>
</ul>
</li>
<li><strong>增强功能</strong>：除了<code>BeanFactory</code>的基本功能外，<code>ApplicationContext</code>还提供了以下强大的企业级服务：<ul>
<li><strong>AOP集成</strong>：与Spring AOP框架深度集成，能够自动发现切面（Aspect）并为Bean创建代理。</li>
<li><strong>事件发布与监听 (ApplicationEventPublisher)</strong>：支持基于观察者模式的应用内事件通知机制，实现组件间的解耦通信。</li>
<li><strong>国际化支持 (MessageSource)</strong>：提供处理多语言消息资源的能力，轻松实现应用的国际化（i18n）。</li>
<li><strong>统一的资源加载 (ResourceLoader)</strong>：提供强大的资源访问能力，可以透明地从类路径 (<code>classpath:</code>)、文件系统 (<code>file:</code>)、URL等位置加载资源。</li>
<li><strong>自动注册 <code>BeanPostProcessor</code></strong>：会自动扫描并注册容器中定义的<code>BeanPostProcessor</code>和<code>BeanFactoryPostProcessor</code>，而<code>BeanFactory</code>需要手动注册。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-总结与对比"><a href="#3-总结与对比" class="headerlink" title="3. 总结与对比"></a>3. 总结与对比</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>BeanFactory</code> (基础容器)</th>
<th align="left"><code>ApplicationContext</code> (高级容器)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>继承关系</strong></td>
<td align="left">IoC容器的顶层接口</td>
<td align="left"><code>BeanFactory</code>的子接口</td>
</tr>
<tr>
<td align="left"><strong>加载策略</strong></td>
<td align="left"><strong>延迟加载 (Lazy Loading)</strong> - 按需创建Bean</td>
<td align="left"><strong>即时加载 (Eager Loading)</strong> - 启动时创建所有单例Bean</td>
</tr>
<tr>
<td align="left"><strong>功能丰富度</strong></td>
<td align="left">基础，仅提供核心的Bean管理功能</td>
<td align="left"><strong>强大</strong>，继承并扩展了BeanFactory，提供AOP、事件、国际化等高级服务</td>
</tr>
<tr>
<td align="left"><strong>错误暴露</strong></td>
<td align="left">运行时，第一次<code>getBean()</code>时才暴露配置错误</td>
<td align="left"><strong>启动时</strong>，通过Fail-Fast机制提前暴露配置错误</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">几乎不再直接使用，主要用于理解底层原理</td>
<td align="left"><strong>99%的开发场景</strong>，是事实上的标准Spring容器</td>
</tr>
</tbody></table>
<p><strong>总结：<code>ApplicationContext</code> &#x3D; <code>BeanFactory</code> + 更多企业级服务。在任何现代Spring应用中，我们都应该优先且默认使用 <code>ApplicationContext</code>。</strong></p>
<hr>
<h4 id="1-2-3-ApplicationContext-的关键实现类"><a href="#1-2-3-ApplicationContext-的关键实现类" class="headerlink" title="1.2.3 ApplicationContext 的关键实现类"></a>1.2.3 <code>ApplicationContext</code> 的关键实现类</h4><h5 id="1-ClassPathXmlApplicationContext-从类路径加载XML"><a href="#1-ClassPathXmlApplicationContext-从类路径加载XML" class="headerlink" title="1. ClassPathXmlApplicationContext: 从类路径加载XML"></a>1. <code>ClassPathXmlApplicationContext</code>: 从类路径加载XML</h5><h6 id="a-定义与职责"><a href="#a-定义与职责" class="headerlink" title="a). 定义与职责"></a>a). 定义与职责</h6><p><code>ClassPathXmlApplicationContext</code> 是 <code>ApplicationContext</code> 接口的一个核心实现类。它的主要职责是<strong>从应用程序的类路径（Classpath）中查找并加载一个或多个XML配置文件，然后根据这些文件中的定义来创建和初始化Spring IoC容器</strong>。</p>
<p>这是在Spring早期，以及许多遗留项目中，最常用的一种容器启动方式。</p>
<hr>
<h6 id="b-关键概念：什么是“类路径-Classpath-”？"><a href="#b-关键概念：什么是“类路径-Classpath-”？" class="headerlink" title="b). 关键概念：什么是“类路径 (Classpath)”？"></a>b). 关键概念：什么是“类路径 (Classpath)”？</h6><p>在Java世界中，“类路径”是一个至关重要的概念。它告诉Java虚拟机（JVM）和类似Spring的框架，去哪里查找<code>.class</code>文件和其他资源文件（如<code>.xml</code>, <code>.properties</code>）。</p>
<ul>
<li><strong>简单理解</strong>：你可以把类路径想象成一个**“资源搜索目录列表”**。当你请求一个资源时，系统会按顺序在这些目录中查找。</li>
<li><strong>在典型的Maven&#x2F;Gradle项目中</strong>：<ul>
<li><code>src/main/java</code> 目录下的Java源码编译后生成的 <code>.class</code> 文件会被自动放入类路径。</li>
<li><code>src/main/resources</code> 目录是<strong>专门用来存放资源文件</strong>的地方。放置在这里的所有文件（如 <code>applicationContext.xml</code>）都会被构建工具（Maven&#x2F;Gradle）自动复制到最终的类路径根目录下。</li>
</ul>
</li>
</ul>
<p><strong>因此，当我们说“从类路径加载”时，通常意味着将XML配置文件放在 <code>src/main/resources</code> 目录下。</strong></p>
<hr>
<h6 id="c-使用示例"><a href="#c-使用示例" class="headerlink" title="c). 使用示例"></a>c). 使用示例</h6><p>让我们通过一个完整的、简单的例子来理解它的工作流程。</p>
<p><strong>步骤 1: 创建项目结构 (以Maven为例)</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my-spring-app</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── example</span><br><span class="line">        │           ├── UserService.java</span><br><span class="line">        │           └── MainApp.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── applicationContext.xml</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 定义一个简单的Bean (<code>UserService.java</code>)</strong></p>
<p>这是一个普通的Java类，我们将把它交给Spring管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, this is UserService managed by Spring!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 创建Spring XML配置文件 (<code>applicationContext.xml</code>)</strong></p>
<p>这个文件放在 <code>src/main/resources</code> 目录下。它告诉Spring容器需要创建哪些Bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        定义一个Bean。</span></span><br><span class="line"><span class="comment">        id: Bean的唯一标识符，类似于变量名。</span></span><br><span class="line"><span class="comment">        class: Bean的完整类路径。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里可以配置属性注入等 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 4: 创建启动类 (<code>MainApp.java</code>)</strong></p>
<p>这是程序的入口，我们在这里创建并启动Spring容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建ApplicationContext实例</span></span><br><span class="line">        <span class="comment">//    构造函数参数是XML配置文件在类路径下的名称</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Spring container started successfully.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从容器中获取Bean</span></span><br><span class="line">        <span class="comment">//    通过在XML中定义的id (&quot;userService&quot;)来获取</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也可以通过类型来获取，如果该类型只有一个Bean实例的话</span></span><br><span class="line">        <span class="comment">// UserService userService = context.getBean(UserService.class);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用Bean</span></span><br><span class="line">        userService.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 关闭容器 (可选，但在非Web应用中最好手动关闭以释放资源)</span></span><br><span class="line">        ((ClassPathXmlApplicationContext) context).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring container started successfully.</span><br><span class="line">Hello, this is UserService managed by Spring!</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="d-加载多个配置文件"><a href="#d-加载多个配置文件" class="headerlink" title="d). 加载多个配置文件"></a>d). 加载多个配置文件</h6><p>如果配置被拆分到了多个XML文件中，可以在构造函数中传入一个字符串数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有两个配置文件：services.xml 和 daos.xml</span></span><br><span class="line">String[] configFiles = &#123;<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>&#125;;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(configFiles);</span><br></pre></td></tr></table></figure>

<p>或者使用通配符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载所有以 -context.xml 结尾的配置文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath*:/META-INF/*-context.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="e-总结"><a href="#e-总结" class="headerlink" title="e). 总结"></a>e). 总结</h6><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>加载源</strong></td>
<td align="left"><strong>类路径 (Classpath)</strong></td>
</tr>
<tr>
<td align="left"><strong>配置文件</strong></td>
<td align="left">XML格式</td>
</tr>
<tr>
<td align="left"><strong>典型位置</strong></td>
<td align="left"><code>src/main/resources</code> 目录</td>
</tr>
<tr>
<td align="left"><strong>核心用法</strong></td>
<td align="left"><code>new ClassPathXmlApplicationContext(&quot;config.xml&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">1. 学习和理解Spring基于XML的配置方式。<br>2. 维护使用XML配置的遗留项目。<br>3. 在某些单元测试场景中快速加载特定配置。</td>
</tr>
<tr>
<td align="left"><strong>现代替代</strong></td>
<td align="left">在新的Spring Boot项目中，几乎完全被 <strong><code>AnnotationConfigApplicationContext</code></strong> (基于Java类配置) 和<strong>自动配置</strong>所取代。</td>
</tr>
</tbody></table>
<hr>
<h5 id="2-FileSystemXmlApplicationContext-从文件系统加载XML"><a href="#2-FileSystemXmlApplicationContext-从文件系统加载XML" class="headerlink" title="2. FileSystemXmlApplicationContext: 从文件系统加载XML"></a>2. <code>FileSystemXmlApplicationContext</code>: 从文件系统加载XML</h5><h6 id="a-定义与职责-1"><a href="#a-定义与职责-1" class="headerlink" title="a). 定义与职责"></a>a). 定义与职责</h6><p><code>FileSystemXmlApplicationContext</code> 同样是 <code>ApplicationContext</code> 接口的一个重要实现类。与 <code>ClassPathXmlApplicationContext</code> 不同，它的职责是<strong>从操作系统的文件系统中加载一个或多个XML配置文件</strong>。</p>
<p>这意味着它加载的配置文件路径是<strong>相对于文件系统的绝对路径或相对路径</strong>，而不是相对于项目的类路径。</p>
<hr>
<h6 id="b-关键概念：文件系统路径-vs-类路径"><a href="#b-关键概念：文件系统路径-vs-类路径" class="headerlink" title="b). 关键概念：文件系统路径 vs 类路径"></a>b). 关键概念：文件系统路径 vs 类路径</h6><ul>
<li><strong>类路径 (Classpath)</strong>：是一个<strong>抽象</strong>的、相对于项目构建结果的位置。当你的应用被打包成一个JAR或WAR文件后，类路径的资源就在这个包的内部。因此，它是<strong>可移植的</strong>，不依赖于应用部署在哪个具体的服务器目录下。</li>
<li><strong>文件系统路径 (File System Path)</strong>：是一个<strong>具体</strong>的、物理磁盘上的位置。这个路径是<strong>硬编码</strong>的，依赖于应用部署的环境。</li>
</ul>
<hr>
<h6 id="c-使用示例-1"><a href="#c-使用示例-1" class="headerlink" title="c). 使用示例"></a>c). 使用示例</h6><p>这个例子将演示如何将配置文件放在项目外部，并通过文件系统路径加载它。</p>
<p><strong>步骤 1: 创建项目与配置文件结构</strong></p>
<p>注意，这次我们将 <code>app-config.xml</code> 放在了项目根目录下的一个 <code>config</code> 文件夹中，它<strong>不在 <code>src/main/resources</code></strong>，因此不属于类路径。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my-spring-app</span><br><span class="line">├── config</span><br><span class="line">│   └── app-config.xml  &lt;-- 配置文件在这里！</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── example</span><br><span class="line">                    ├── UserService.java</span><br><span class="line">                    └── MainApp.java</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 定义Bean和XML配置 (与上例相同)</strong></p>
<p><code>UserService.java</code> 和 <code>app-config.xml</code> 的内容可以和 <code>ClassPathXmlApplicationContext</code> 示例中的完全一样。</p>
<p><code>app-config.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 创建启动类 (<code>MainApp.java</code>)</strong></p>
<p>这是关键区别所在。我们将使用 <code>FileSystemXmlApplicationContext</code> 来加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 演示一：使用相对路径加载</span></span><br><span class="line">        <span class="comment">// 这个路径是相对于项目根目录（即应用的当前工作目录）</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;config/app-config.xml&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Container 1 (relative path) started successfully.&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service1</span> <span class="operator">=</span> context1.getBean(UserService.class);</span><br><span class="line">        service1.sayHello();</span><br><span class="line">        ((FileSystemXmlApplicationContext) context1).close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n----------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 演示二：使用绝对路径加载</span></span><br><span class="line">        <span class="comment">// 注意：这种方式可移植性很差，因为路径是硬编码的</span></span><br><span class="line">        <span class="comment">// 请将下面的路径替换为你自己项目中 app-config.xml 的实际绝对路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">absolutePath</span> <span class="operator">=</span> <span class="string">&quot;D:/projects/my-spring-app/config/app-config.xml&quot;</span>; <span class="comment">// 示例路径</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(absolutePath);</span><br><span class="line">        System.out.println(<span class="string">&quot;Container 2 (absolute path) started successfully.&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service2</span> <span class="operator">=</span> context2.getBean(UserService.class);</span><br><span class="line">        service2.sayHello();</span><br><span class="line">        ((FileSystemXmlApplicationContext) context2).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Container 1 (relative path) started successfully.</span><br><span class="line">Hello, this is UserService managed by Spring!</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"></span><br><span class="line">Container 2 (absolute path) started successfully.</span><br><span class="line">Hello, this is UserService managed by Spring!</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="d-ClassPathXmlApplicationContext-vs-FileSystemXmlApplicationContext"><a href="#d-ClassPathXmlApplicationContext-vs-FileSystemXmlApplicationContext" class="headerlink" title="d). ClassPathXmlApplicationContext vs FileSystemXmlApplicationContext"></a>d). <code>ClassPathXmlApplicationContext</code> vs <code>FileSystemXmlApplicationContext</code></h6><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>ClassPathXmlApplicationContext</code></th>
<th align="left"><code>FileSystemXmlApplicationContext</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>加载源</strong></td>
<td align="left"><strong>类路径 (Classpath)</strong></td>
<td align="left"><strong>文件系统 (File System)</strong></td>
</tr>
<tr>
<td align="left"><strong>路径类型</strong></td>
<td align="left">抽象路径，如 <code>beans.xml</code></td>
<td align="left">具体的物理路径，如 <code>C:/config/beans.xml</code> 或 <code>config/beans.xml</code></td>
</tr>
<tr>
<td align="left"><strong>可移植性</strong></td>
<td align="left"><strong>高</strong>。配置文件打包在应用内部，随应用部署到任何地方。</td>
<td align="left"><strong>低</strong>。路径通常是硬编码的，换个环境可能就需要修改代码或配置。</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">将配置作为应用程序<strong>内部资源</strong>的一部分。</td>
<td align="left">将配置作为<strong>外部资源</strong>，独立于应用程序包进行管理。</td>
</tr>
</tbody></table>
<hr>
<h6 id="e-适用场景"><a href="#e-适用场景" class="headerlink" title="e). 适用场景"></a>e). 适用场景</h6><p>虽然在现代Spring Boot应用中不常用，但 <code>FileSystemXmlApplicationContext</code> 在某些特定场景下非常有用：</p>
<ol>
<li><strong>外部化配置</strong>：最核心的用途。允许将配置文件放在应用程序包（JAR&#x2F;WAR）的外部。这样，运维人员可以在<strong>不重新打包和部署应用</strong>的情况下，直接修改外部的XML配置文件来改变应用的行为（例如修改数据库连接池参数）。</li>
<li><strong>多应用共享配置</strong>：可以将一些公共的配置文件放在服务器的某个共享目录下，多个不同的应用实例都从这个位置加载公共配置。</li>
<li><strong>测试场景</strong>：在进行集成测试时，可以方便地从一个特定的、固定的文件系统位置加载一套专为测试准备的配置文件。</li>
</ol>
<hr>
<h5 id="3-AnnotationConfigApplicationContext-从Java配置类加载"><a href="#3-AnnotationConfigApplicationContext-从Java配置类加载" class="headerlink" title="3. AnnotationConfigApplicationContext: 从Java配置类加载"></a>3. <code>AnnotationConfigApplicationContext</code>: 从Java配置类加载</h5><h6 id="a-定义与职责-2"><a href="#a-定义与职责-2" class="headerlink" title="a). 定义与职责"></a>a). 定义与职责</h6><p><code>AnnotationConfigApplicationContext</code> 是 Spring 框架进入 “去XML化” 时代的核心。其职责是<strong>从一个或多个使用注解的Java类（通常称为配置类, Configuration Class）中加载Bean的定义，从而构建和初始化IoC容器</strong>。</p>
<p>这种方式完全摒弃了XML文件，允许开发者使用<strong>纯Java代码</strong>来完成所有的Spring配置，是当前Spring Boot和现代Spring应用开发的事实标准。</p>
<hr>
<h6 id="b-关键注解"><a href="#b-关键注解" class="headerlink" title="b). 关键注解"></a>b). 关键注解</h6><p>要使用 <code>AnnotationConfigApplicationContext</code>，我们必须先了解两个核心注解：</p>
<ul>
<li><strong><code>@Configuration</code></strong>:<ul>
<li><strong>作用</strong>：标记在一个类上，向Spring声明这个类是一个<strong>配置类</strong>。它的角色等同于一个XML配置文件。</li>
<li><strong>本质</strong>：<code>@Configuration</code> 本身也被 <code>@Component</code> 注解，所以配置类也会被Spring当作一个特殊的Bean进行管理。</li>
<li><strong>特点</strong>：Spring会对 <code>@Configuration</code> 类进行CGLIB代理增强，以保证通过方法调用获取Bean时，能够正确处理Bean的作用域（如单例）。</li>
</ul>
</li>
<li><strong><code>@Bean</code></strong>:<ul>
<li><strong>作用</strong>：标记在一个<strong>方法</strong>上，这个方法必须定义在<code>@Configuration</code>类中。</li>
<li><strong>职责</strong>：Spring容器会<strong>调用这个方法</strong>，并将方法的<strong>返回值</strong>注册为一个Bean。</li>
<li><strong>命名</strong>：默认情况下，Bean的ID就是<strong>方法名</strong>。你也可以通过 <code>@Bean(name = &quot;customName&quot;)</code> 或 <code>@Bean(&quot;customName&quot;)</code> 来指定一个自定义的ID。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="c-使用示例-2"><a href="#c-使用示例-2" class="headerlink" title="c). 使用示例"></a>c). 使用示例</h6><p>让我们用纯Java的方式重构之前的 <code>UserService</code> 示例。</p>
<p><strong>步骤 1: 项目结构 (无XML文件)</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my-spring-app</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── example</span><br><span class="line">                    ├── config</span><br><span class="line">                    │   └── AppConfig.java    &lt;-- 这是我们的Java配置类</span><br><span class="line">                    ├── service</span><br><span class="line">                    │   └── UserService.java</span><br><span class="line">                    └── MainApp.java</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 定义Bean (<code>UserService.java</code>)</strong></p>
<p>这仍然是一个简单的POJO，无需任何改动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, this is UserService configured via Java Config!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 创建Java配置类 (<code>AppConfig.java</code>)</strong></p>
<p>这是替代 <code>applicationContext.xml</code> 的核心文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用 @Configuration 注解，表明这是一个配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用 @Bean 注解，声明一个Bean</span></span><br><span class="line">    <span class="comment">//    方法名 &quot;userService&quot; 将成为这个Bean的ID</span></span><br><span class="line">    <span class="comment">//    方法的返回值 new UserService() 将成为Bean的实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 4: 创建启动类 (<code>MainApp.java</code>)</strong></p>
<p>在这里，我们使用 <code>AnnotationConfigApplicationContext</code> 来启动容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.config.AppConfig;</span><br><span class="line"><span class="keyword">import</span> com.example.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 AnnotationConfigApplicationContext 实例</span></span><br><span class="line">        <span class="comment">//    构造函数参数是我们的配置类 AppConfig.class</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Spring container started successfully using Java Config.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从容器中获取Bean</span></span><br><span class="line">        <span class="comment">//    可以通过方法名（Bean ID）获取</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceById</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userServiceById.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//    更推荐通过类型获取，因为这样更安全</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceByType</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        userServiceByType.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 关闭容器</span></span><br><span class="line">        ((AnnotationConfigApplicationContext) context).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring container started successfully using Java Config.</span><br><span class="line">Hello, this is UserService configured via Java Config!</span><br><span class="line">Hello, this is UserService configured via Java Config!</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="d-结合组件扫描-ComponentScan"><a href="#d-结合组件扫描-ComponentScan" class="headerlink" title="d). 结合组件扫描 (@ComponentScan)"></a>d). 结合组件扫描 (<code>@ComponentScan</code>)</h6><p>除了使用<code>@Bean</code>方法手动定义每一个Bean，更常见的做法是结合<strong>组件扫描</strong>。</p>
<ul>
<li><p><strong>修改 <code>UserService</code></strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component; <span class="comment">// 引入注解</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 将UserService标记为一个组件，让Spring自动发现它</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改 <code>AppConfig</code></strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 告诉Spring去扫描 &quot;com.example.service&quot; 包下的所有组件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example.service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 因为UserService已经通过@Component被自动扫描了，</span></span><br><span class="line">    <span class="comment">// 所以这里的 @Bean 方法就不再需要了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>启动代码<code>MainApp.java</code>无需任何改变，运行结果完全相同。这种**<code>@Configuration</code> + <code>@ComponentScan</code>** 的组合是现代Spring应用配置的基石。</p>
<hr>
<h6 id="e-Java配置相对于XML的优势"><a href="#e-Java配置相对于XML的优势" class="headerlink" title="e). Java配置相对于XML的优势"></a>e). Java配置相对于XML的优势</h6><ol>
<li><strong>类型安全 (Type-Safe)</strong>：所有的配置都是Java代码。如果你在<code>class=&quot;com.example.UserService123&quot;</code>中写错了类名，XML配置在运行时才会报错；而Java配置 <code>new UserService123()</code> 在<strong>编译时</strong>就会被编译器发现错误。</li>
<li><strong>更好的IDE支持和重构</strong>：当你想重命名一个类或方法时，IDE的重构工具可以自动更新所有的Java引用。而重构XML中的字符串值则非常困难和易错。</li>
<li><strong>灵活性和编程能力</strong>：你可以在<code>@Bean</code>方法中使用任何Java逻辑（如<code>if-else</code>、循环、调用其他方法）来动态地、有条件地创建和配置Bean，这是静态的XML无法比拟的。</li>
<li><strong>更简洁、更内聚</strong>：配置和代码都在同一个语言环境中，导航和理解都更加方便。</li>
</ol>
<p><strong>总结</strong>：<code>AnnotationConfigApplicationContext</code> 和与之配套的Java配置方式，是Spring发展的必然趋势。它提供了比XML更安全、更灵活、更强大的配置能力，是所有新Spring项目的不二之选。</p>
<hr>
<h5 id="4-WebApplicationContext-Web应用专属，与ServletContext集成"><a href="#4-WebApplicationContext-Web应用专属，与ServletContext集成" class="headerlink" title="4. WebApplicationContext: Web应用专属，与ServletContext集成"></a>4. <code>WebApplicationContext</code>: Web应用专属，与<code>ServletContext</code>集成</h5><h6 id="a-定义与核心角色"><a href="#a-定义与核心角色" class="headerlink" title="a). 定义与核心角色"></a>a). 定义与核心角色</h6><p><code>WebApplicationContext</code> 是一个专为Web应用程序设计的 <code>ApplicationContext</code> 子接口。在 <code>ApplicationContext</code> 基础上添加了一些Web环境特有的能力。</p>
<p>它的<strong>核心角色</strong>是：<strong>充当Spring IoC容器与底层Servlet容器（如Tomcat, Jetty）之间的桥梁</strong>。</p>
<p>与前面三种 <code>ApplicationContext</code> 不同，它的生命周期不再由 <code>main</code> 方法中的代码来控制，而是<strong>与Web应用的生命周期绑定</strong>。当Web应用启动时，它被创建；当Web应用停止时，它被销毁。</p>
<hr>
<h6 id="b-与ServletContext的集成关系"><a href="#b-与ServletContext的集成关系" class="headerlink" title="b). 与ServletContext的集成关系"></a>b). 与<code>ServletContext</code>的集成关系</h6><p>要理解 <code>WebApplicationContext</code>，必须先理解 <strong><code>ServletContext</code></strong>。</p>
<ul>
<li><strong><code>ServletContext</code> 是什么？</strong><ul>
<li><code>ServletContext</code> 是Java Servlet规范中定义的<strong>四大域对象</strong>之一。</li>
<li>可以把它理解为<strong>整个Web应用的全局上下文（Global Context）</strong> 或 <strong>“全局管家”</strong>。</li>
<li>当Web服务器（如Tomcat）启动一个Web应用时，它会为这个应用创建一个<strong>唯一的 <code>ServletContext</code> 实例</strong>。</li>
<li>这个实例在整个应用的生命周期内都存在，所有Servlet、Filter、Listener都可以共享它内部的数据。</li>
</ul>
</li>
<li><strong>如何集成？</strong><ul>
<li>Spring的巧妙之处在于，它将创建好的 <code>WebApplicationContext</code> 实例作为一个**属性（Attribute）**存储到这个全局的 <code>ServletContext</code> 中。</li>
<li>这样一来，<code>WebApplicationContext</code> 就成为了 <code>ServletContext</code> 的一部分，任何能访问到 <code>ServletContext</code> 的组件，理论上都能间接地访问到Spring容器。</li>
<li>存储时使用的默认键（Key）是 <code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="c-生命周期与创建方式-传统Web应用"><a href="#c-生命周期与创建方式-传统Web应用" class="headerlink" title="c). 生命周期与创建方式 (传统Web应用)"></a>c). 生命周期与创建方式 (传统Web应用)</h6><p>在没有Spring Boot的传统Web应用中，<code>WebApplicationContext</code> 的创建通常依赖于 <code>web.xml</code> 文件中的配置。这个过程涉及两个关键组件：</p>
<p><strong>A. <code>ContextLoaderListener</code> (上下文加载监听器)</strong></p>
<ul>
<li><strong>作用</strong>：它是一个实现了 <code>ServletContextListener</code> 接口的监听器。它会监听Web应用的<strong>启动</strong>和<strong>销毁</strong>事件。</li>
<li><strong>创建时机</strong>：当Tomcat等服务器启动你的Web应用时，<code>ContextLoaderListener</code> 会被触发。</li>
<li><strong>动作</strong>：它会读取 <code>web.xml</code> 中指定的配置文件（默认为 <code>/WEB-INF/applicationContext.xml</code>），然后<strong>创建并初始化一个 <code>WebApplicationContext</code> 实例</strong>，并将其存入 <code>ServletContext</code>。这个Context被称为 <strong>“根上下文” (Root WebApplicationContext)</strong>。</li>
</ul>
<p><strong>B. <code>DispatcherServlet</code> (前端控制器)</strong></p>
<ul>
<li><strong>作用</strong>：这是Spring MVC的核心。所有进入应用的Web请求都会先经过它。</li>
<li><strong>创建时机</strong>：当 <code>DispatcherServlet</code> 被第一次初始化时。</li>
<li><strong>动作</strong>：<code>DispatcherServlet</code> 也会创建<strong>自己的 <code>WebApplicationContext</code></strong>，并读取它自己的配置文件（默认为 <code>/WEB-INF/[servlet-name]-servlet.xml</code>）。这个Context被称为 <strong>“Servlet上下文”</strong>。</li>
</ul>
<hr>
<h6 id="d-父子容器结构-Parent-Child-Container-Structure"><a href="#d-父子容器结构-Parent-Child-Container-Structure" class="headerlink" title="d). 父子容器结构 (Parent-Child Container Structure)"></a>d). 父子容器结构 (Parent-Child Container Structure)</h6><p>这是 <code>WebApplicationContext</code> 最核心、最重要的一个概念。</p>
<ul>
<li><strong>根上下文 (Parent Context)</strong>：<ul>
<li>由 <code>ContextLoaderListener</code> 创建。</li>
<li>通常用于存放<strong>业务层</strong>和<strong>数据访问层</strong>的Bean，如 <code>Service</code>, <code>Repository</code>, <code>DataSource</code>, 事务管理器等。</li>
<li>它是<strong>全局共享</strong>的，整个Web应用只有一个。</li>
</ul>
</li>
<li><strong>Servlet上下文 (Child Context)</strong>：<ul>
<li>由 <code>DispatcherServlet</code> 创建。</li>
<li>通常用于存放<strong>Web层</strong>的Bean，如 <code>@Controller</code>, <code>HandlerMapping</code>, <code>ViewResolver</code> 等。</li>
<li>它可以有多个（如果配置了多个 <code>DispatcherServlet</code>）。</li>
</ul>
</li>
<li><strong>关系与规则</strong>：<ul>
<li>Servlet上下文（子容器）将根上下文（父容器）作为自己的“父级”。</li>
<li><strong>可见性规则</strong>：<strong>子容器可以访问父容器中的Bean，但父容器无法访问子容器中的Bean。</strong></li>
<li><strong>为什么这样设计？</strong> 这是一种优秀的分层设计。Web层的Controller需要调用业务层的Service，所以子容器必须能访问父容器。反之，业务层的Service不应该依赖于Web层的任何具体实现（如Controller），保证了业务逻辑的独立性和可重用性。</li>
</ul>
</li>
</ul>
<p><strong><code>web.xml</code> 配置示例：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 配置 ContextLoaderListener 来创建根上下文 (Parent) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定根上下文的配置文件位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 配置 DispatcherServlet 来创建其自己的上下文 (Child) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定Servlet上下文的配置文件位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/dispatcher-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h6 id="e-在Spring-Boot中的演变"><a href="#e-在Spring-Boot中的演变" class="headerlink" title="e). 在Spring Boot中的演变"></a>e). 在Spring Boot中的演变</h6><p>Spring Boot 极大地简化了这个过程：</p>
<ol>
<li><strong>无需 <code>web.xml</code></strong>：Spring Boot通过内嵌的Servlet容器（如Tomcat）和自动配置，完全消除了 <code>web.xml</code>。</li>
<li><strong>自动注册</strong>：<code>ContextLoaderListener</code> 和 <code>DispatcherServlet</code> 会被Spring Boot自动检测并注册到Servlet容器中。</li>
<li><strong>简化为单一上下文</strong>：在大多数标准的Spring Boot Web应用中，<strong>不再有明显的父子容器划分</strong>。Spring Boot会创建一个<strong>单一的、统一的 <code>AnnotationConfigServletWebServerApplicationContext</code></strong>，这个上下文同时承担了根上下文和Servlet上下文的角色。所有的Bean（<code>@Service</code>, <code>@Controller</code>等）都注册在这个统一的容器中，大大简化了开发者的心智模型。</li>
</ol>
<p><strong>总结</strong>：<code>WebApplicationContext</code> 是Spring与Web世界集成的基石。理解它在传统Web应用中的<strong>父子容器结构</strong>，有助于我们深入理解Spring MVC的分层设计思想。而了解它在Spring Boot中的<strong>演变和简化</strong>，则能帮助我们更好地利用现代框架进行高效开发。</p>
<hr>
<h3 id="1-3-Bean"><a href="#1-3-Bean" class="headerlink" title="1.3 Bean"></a>1.3 Bean</h3><h4 id="1-3-1-什么是Bean？"><a href="#1-3-1-什么是Bean？" class="headerlink" title="1.3.1 什么是Bean？"></a>1.3.1 什么是Bean？</h4><h5 id="1-核心定义"><a href="#1-核心定义" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h5><p>在Spring框架中，一个<strong>Bean</strong>本质上就是一个<strong>由Spring IoC容器负责实例化、配置、组装和管理生命周期的Java对象</strong>。</p>
<p>换句话说，任何一个普通的Java对象（POJO - Plain Old Java Object），一旦它的创建和管理权被交给了Spring容器，我们就不再称它为简单的“对象”，而是称之为Spring的“Bean”。</p>
<hr>
<h5 id="2-从对象-Object-到Bean的转变"><a href="#2-从对象-Object-到Bean的转变" class="headerlink" title="2. 从对象(Object)到Bean的转变"></a>2. 从对象(Object)到Bean的转变</h5><p>一个普通的Java对象要成为一个Spring Bean，需要经历一个“注册”的过程。</p>
<p>这个“注册”的方式，就是我们接下来要学习的三种声明方式：</p>
<ol>
<li><strong>XML配置</strong>：在<code>&lt;bean&gt;</code>标签中定义。</li>
<li><strong>注解</strong>：在类上添加<code>@Component</code>, <code>@Service</code>, <code>@Repository</code>等注解。</li>
<li><strong>Java Config</strong>：在<code>@Configuration</code>类中使用<code>@Bean</code>方法。</li>
</ol>
<p>一旦Spring容器知道了这个声明，它就会在其生命周期的适当阶段，通过<strong>反射机制</strong>来创建该类的实例，并将其纳入自己的管理体系中，此时，这个对象就正式成为了一个Bean。</p>
<hr>
<h5 id="3-Bean的关键特征"><a href="#3-Bean的关键特征" class="headerlink" title="3. Bean的关键特征"></a>3. Bean的关键特征</h5><p>一个被Spring管理的Bean具有以下几个显著特征：</p>
<ol>
<li><strong>由容器管理 (Container-Managed)</strong>：<ul>
<li>Bean的生老病死（创建、初始化、销毁）完全由IoC容器掌控，开发者无需关心这些细节。</li>
</ul>
</li>
<li><strong>通过配置元数据定义 (Defined by Configuration Metadata)</strong>：<ul>
<li>容器需要一份“蓝图”或“说明书”来了解要创建哪些Bean、它们是什么类型、它们之间有什么依赖关系。这份“说明书”就是XML文件、注解或Java Config。</li>
</ul>
</li>
<li><strong>拥有唯一标识符 (ID&#x2F;Name)</strong>：<ul>
<li>在容器中，每个Bean都有一个或多个唯一的名称（通常称为Bean ID或Bean Name）。我们可以通过这个名称从容器中精确地获取到对应的Bean实例。</li>
<li>默认情况下，如果使用注解，Bean的ID是类名的首字母小写形式（如<code>UserServiceImpl</code>的ID是<code>userServiceImpl</code>）。</li>
</ul>
</li>
<li><strong>拥有作用域 (Scope)</strong>：<ul>
<li>容器可以控制一个Bean是以<strong>单例</strong>（Singleton，整个应用只有一个实例）、<strong>原型</strong>（Prototype，每次请求都创建一个新实例）还是其他作用域（如<code>request</code>、<code>session</code>）存在。</li>
</ul>
</li>
<li><strong>可参与依赖注入 (DI-Capable)</strong>：<ul>
<li>Bean可以声明自己的依赖项（比如<code>UserService</code>依赖<code>UserDao</code>），容器会自动将这些依赖项注入进来，完成Bean之间的“组装”。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">传统对象 (Traditional Object)</th>
<th align="left">Spring Bean</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>创建控制权</strong></td>
<td align="left">在开发者手中，使用 <code>new</code> 关键字。</td>
<td align="left">在Spring容器手中，根据配置元数据创建。</td>
</tr>
<tr>
<td align="left"><strong>依赖管理</strong></td>
<td align="left">开发者手动创建并设置依赖关系。</td>
<td align="left">Spring容器自动注入依赖。</td>
</tr>
<tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left">由JVM的垃圾回收机制决定。</td>
<td align="left">由Spring容器精确管理（初始化、销毁回调）。</td>
</tr>
<tr>
<td align="left"><strong>如何获取</strong></td>
<td align="left">直接通过变量引用。</td>
<td align="left">通过 <code>context.getBean()</code> 或 <code>@Autowired</code> 从容器获取。</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-3-2-声明Bean的三种主流方式"><a href="#1-3-2-声明Bean的三种主流方式" class="headerlink" title="1.3.2 声明Bean的三种主流方式"></a>1.3.2 声明Bean的三种主流方式</h4><h5 id="1-XML配置"><a href="#1-XML配置" class="headerlink" title="1. XML配置"></a>1. XML配置</h5><p>XML配置是Spring框架诞生之初最原始、也是最经典的一种Bean声明方式。开发者通过编写一个或多个XML格式的配置文件，来向Spring IoC容器描述需要管理哪些Bean，以及这些Bean之间的依赖关系。</p>
<h6 id="a-核心标签："><a href="#a-核心标签：" class="headerlink" title="a). 核心标签：&lt;bean&gt;"></a>a). 核心标签：<code>&lt;bean&gt;</code></h6><p>XML配置的核心就是<code>&lt;bean&gt;</code>标签。每一个<code>&lt;bean&gt;</code>标签都对应着容器中一个将被创建和管理的Bean实例。</p>
<p><strong>基本配置</strong></p>
<p>最简单的<code>&lt;bean&gt;</code>标签包含两个基本属性：</p>
<ul>
<li><code>id</code>：定义Bean的唯一标识符（Bean ID）。这个ID在整个IoC容器中必须是唯一的。我们可以通过这个ID从容器中获取Bean。</li>
<li><code>class</code>：指定该Bean实例对应的<strong>完整类名</strong>（包名+类名）。Spring容器会通过反射机制来实例化这个类。</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><p><strong>Java类 (<code>HelloWorld.java</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Your Message : &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>XML配置文件 (<code>beans.xml</code>)</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明一个HelloWorld类型的Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.HelloWorld&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 稍后会介绍如何在这里注入属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="b-依赖注入-DI-in-XML"><a href="#b-依赖注入-DI-in-XML" class="headerlink" title="b). 依赖注入 (DI) in XML"></a>b). 依赖注入 (DI) in XML</h6><p>XML配置支持两种主要的依赖注入方式：<strong>Setter注入</strong>和<strong>构造器注入</strong>。</p>
<p><strong>Setter注入 (Property Injection)</strong></p>
<ul>
<li><strong>原理</strong>：IoC容器首先调用Bean的<strong>无参构造函数</strong>来创建实例，然后调用相应的<code>setXxx()</code>方法来注入依赖。</li>
<li><strong>XML标签</strong>：使用<code>&lt;property&gt;</code>子标签。<ul>
<li><code>name</code>：对应Java类中的<strong>属性名</strong>（实际上是对应<code>set</code>方法名，如<code>name=&quot;message&quot;</code>对应<code>setMessage()</code>方法）。</li>
<li><code>value</code>：用于注入<strong>基本类型</strong>（如<code>String</code>, <code>int</code>, <code>boolean</code>）和它们的包装类。</li>
<li><code>ref</code>：用于注入<strong>其他Bean的引用</strong>。它的值是另一个Bean的ID。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><p><strong>Java类 (<code>UserService.java</code> 和 <code>UserDao.java</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserDao接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123; <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="comment">// UserDao实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;User saved to database.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须提供setter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; <span class="built_in">this</span>.userDao = userDao; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServiceName</span><span class="params">(String serviceName)</span> &#123; <span class="built_in">this</span>.serviceName = serviceName; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service Name: &quot;</span> + serviceName);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>XML配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 先定义依赖的Bean: userDao --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 定义需要被注入的Bean: userService --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用 &lt;property&gt; 进行Setter注入 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入一个字符串 (基本类型) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;DefaultUserService&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入另一个Bean的引用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>构造器注入 (Constructor Injection)</strong></p>
<ul>
<li><strong>原理</strong>：IoC容器在创建Bean实例时，直接调用其<strong>带有参数的构造函数</strong>，将依赖项作为构造函数的参数传入。</li>
<li><strong>XML标签</strong>：使用<code>&lt;constructor-arg&gt;</code>子标签。<ul>
<li><code>index</code>：指定参数在构造函数参数列表中的<strong>索引</strong>（从0开始）。</li>
<li><code>type</code>：指定参数的<strong>类型</strong>（如<code>java.lang.String</code>），用于避免歧义。</li>
<li><code>name</code>：指定参数的<strong>名称</strong>（需要Java 8+的编译器支持并开启 <code>-parameters</code> 选项）。</li>
<li><code>value</code>和<code>ref</code>属性与<code>&lt;property&gt;</code>标签中的作用相同。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><p><strong>Java类 (<code>UserService.java</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao; <span class="comment">// 依赖可以是final的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供带参数的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao, String serviceName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">        <span class="built_in">this</span>.serviceName = serviceName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>XML配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用 &lt;constructor-arg&gt; 进行构造器注入 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 方式一：按索引注入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ConstructorUserService&quot;</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 方式二：按类型注入 (如果类型不重复) --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;constructor-arg type=&quot;com.example.UserDao&quot; ref=&quot;userDao&quot; /&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;ConstructorUserService&quot; /&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="c-优势与劣势"><a href="#c-优势与劣势" class="headerlink" title="c). 优势与劣势"></a>c). 优势与劣势</h6><p><strong><code>a. 优势</code></strong></p>
<ol>
<li><strong>非侵入性</strong>：配置信息与Java源代码完全分离。Java类是纯粹的POJO，不需要依赖任何Spring的注解。</li>
<li><strong>配置集中化</strong>：所有的Bean定义和依赖关系都集中在XML文件中，对于理解整个应用的宏观结构非常有帮助，一目了然。</li>
<li><strong>易于修改</strong>：在不重新编译Java代码的情况下，可以通过修改XML文件来改变Bean的行为或替换其实现。</li>
</ol>
<p><strong><code>b. 劣势</code></strong></p>
<ol>
<li><strong>繁琐和冗长</strong>：随着应用规模的增长，XML文件会变得异常庞大和复杂，难以维护。</li>
<li><strong>类型不安全</strong>：XML中配置的类名、属性名都是字符串。如果写错了，只有在运行时容器启动时才能发现，而不能在编译时检查。</li>
<li><strong>导航和重构困难</strong>：在IDE中，从XML配置跳转到对应的Java代码比较麻烦。对Java类进行重命名等操作时，IDE无法自动更新XML中的字符串引用。</li>
<li><strong>配置分散</strong>：虽然XML本身是集中的，但配置信息和它所配置的Java类是分离的，查找一个类的具体配置需要在XML文件中搜索，不如注解直观。</li>
</ol>
<hr>
<h5 id="2-注解驱动-Component-Service-Repository-Controller"><a href="#2-注解驱动-Component-Service-Repository-Controller" class="headerlink" title="2. 注解驱动 (@Component, @Service, @Repository, @Controller)"></a>2. 注解驱动 (<code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>)</h5><p>随着Java 5引入注解（Annotation），Spring框架也迅速跟进，提供了一种更为简洁、直观的Bean声明方式——<strong>基于注解的组件扫描（Component Scanning）</strong>。我们不再需要在XML中为每个Bean编写<code>&lt;bean&gt;</code>标签，而是直接在Java类上添加特定的注解，Spring容器会自动扫描并注册它们。</p>
<h6 id="a-核心思想：组件扫描-Component-Scanning"><a href="#a-核心思想：组件扫描-Component-Scanning" class="headerlink" title="a). 核心思想：组件扫描 (Component Scanning)"></a>a). 核心思想：组件扫描 (Component Scanning)</h6><ul>
<li><strong>机制</strong>：我们首先需要在一个配置类（XML或Java Config）中启用组件扫描，并指定一个或多个需要扫描的<strong>基础包（base package）</strong>。</li>
<li><strong>过程</strong>：Spring容器在启动时，会像雷达一样扫描这些基础包以及其所有子包下的所有类。如果发现某个类被特定的注解（如<code>@Component</code>）标记，Spring就会将这个类自动注册为一个Bean。</li>
</ul>
<hr>
<h6 id="b-启用组件扫描"><a href="#b-启用组件扫描" class="headerlink" title="b). 启用组件扫描"></a>b). 启用组件扫描</h6><ul>
<li><p><strong>在XML中启用</strong>：<br>使用<code>&lt;context:component-scan&gt;</code>标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">           https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 启用组件扫描，指定基础包为 &quot;com.example&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在Java Config中启用（更推荐）</strong>：<br>使用<code>@ComponentScan</code>注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="comment">// 如果不指定basePackages，默认扫描当前配置类所在的包及其子包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="c-核心注解：-Component-及其衍生注解"><a href="#c-核心注解：-Component-及其衍生注解" class="headerlink" title="c). 核心注解：@Component 及其衍生注解"></a>c). 核心注解：<code>@Component</code> 及其衍生注解</h6><p><strong><code>a. @Component - 通用组件注解</code></strong></p>
<ul>
<li><strong>作用</strong>：<code>@Component</code> 是最基础、最通用的组件注解。它可以标记任何一个你希望交给Spring管理的类。</li>
<li><strong>Bean ID</strong>：默认情况下，被<code>@Component</code>标记的类的Bean ID是其<strong>类名的首字母小写形式</strong>。例如，类<code>MyCoolService</code>的默认Bean ID是<code>myCoolService</code>。</li>
<li><strong>自定义ID</strong>：你也可以手动指定Bean ID，例如 <code>@Component(&quot;coolService&quot;)</code>。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 将MyUtility注册为Bean，默认ID为 &quot;myUtility&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUtility</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Utility is doing something.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>b. 衍生注解 (Stereotype Annotations)</code></strong></p>
<p>Spring为了更好地在架构层面<strong>区分不同分层的组件</strong>，并为它们附加一些特定功能，提供了三个<code>@Component</code>的衍生注解。它们在功能上与<code>@Component</code>完全等价（都能被扫描并注册为Bean），但<strong>在语义上有所区别</strong>。</p>
<p><strong><code>@Service</code></strong></p>
<ul>
<li><strong>语义</strong>：用于标记<strong>业务逻辑层 (Service Layer)</strong> 的组件。</li>
<li><strong>用途</strong>：通常用在实现业务逻辑的类上，如 <code>UserService</code>, <code>OrderService</code>。使用<code>@Service</code>能更清晰地表明这个类的职责。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span> <span class="comment">// 表明这是业务逻辑层组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Registering a new user...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>@Repository</code></strong></p>
<ul>
<li><strong>语义</strong>：用于标记<strong>数据访问层 (Data Access Layer &#x2F; Persistence Layer)</strong> 的组件。</li>
<li><strong>用途</strong>：通常用在直接与数据库交互的DAO（Data Access Object）类上，如 <code>UserDao</code>, <code>ProductRepository</code>。</li>
<li><strong>附加功能</strong>：除了标记组件外，<code>@Repository</code>还能<strong>将特定于数据访问技术的异常（如JDBC的<code>SQLException</code>）统一转译为Spring的数据访问异常体系（<code>DataAccessException</code>）</strong>。这使得上层业务代码可以从底层的具体持久化技术中解耦，无需处理特定的数据库异常。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 表明这是数据访问层组件，并开启异常转译</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 假设这里有JDBC代码，如果抛出SQLException</span></span><br><span class="line">        <span class="comment">// Spring会将其捕获并包装成一个非检查型异常抛出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Saving user to the database.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>@Controller</code> &#x2F; <code>@RestController</code></strong></p>
<ul>
<li><strong>语义</strong>：用于标记<strong>表现层 (Presentation Layer)</strong> 的组件，通常是<strong>Web层的控制器</strong>。</li>
<li><strong>用途</strong>：在Spring MVC或Spring WebFlux项目中，用于处理HTTP请求的控制器类。</li>
<li><strong><code>@RestController</code></strong>：是<code>@Controller</code>和<code>@ResponseBody</code>的组合注解，专门用于构建RESTful API，它表示该控制器所有方法的返回值都将直接作为响应体（通常是JSON格式）返回，而不是去解析视图。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// 表明这是Web层的REST控制器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;List of users&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要有衍生注解？</strong></p>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">目标分层</th>
<th align="left">主要职责</th>
<th align="left">附加功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@Component</code></strong></td>
<td align="left">(通用)</td>
<td align="left">任何希望被Spring管理的组件</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><strong><code>@Service</code></strong></td>
<td align="left"><strong>业务层</strong></td>
<td align="left">封装核心业务逻辑</td>
<td align="left">无 (纯语义)</td>
</tr>
<tr>
<td align="left"><strong><code>@Repository</code></strong></td>
<td align="left"><strong>数据访问层</strong></td>
<td align="left">数据库增删改查、数据持久化</td>
<td align="left"><strong>异常转译</strong></td>
</tr>
<tr>
<td align="left"><strong><code>@Controller</code></strong></td>
<td align="left"><strong>表现层</strong></td>
<td align="left">接收HTTP请求，返回视图或模型数据</td>
<td align="left">(与Spring MVC集成)</td>
</tr>
</tbody></table>
<p>使用这些语义化的注解，而不是到处都用<code>@Component</code>，是一种<strong>最佳实践</strong>。它能让你的代码<strong>自解释 (self-documenting)</strong>，使得其他开发者（或未来的你）能通过注解一眼就看出这个类的架构职责。</p>
<hr>
<h6 id="d-优势与劣势"><a href="#d-优势与劣势" class="headerlink" title="d). 优势与劣势"></a>d). 优势与劣势</h6><p><strong><code>a. 优势</code></strong></p>
<ol>
<li><strong>简洁直观</strong>：配置信息（注解）直接写在它所配置的Java类上，代码和配置高度内聚，易于理解和维护。</li>
<li><strong>开发效率高</strong>：只需在类上加一个注解，无需在XML中进行繁琐的配置。</li>
<li><strong>更好的IDE支持</strong>：IDE可以轻松地识别注解，提供更好的代码导航、自动补全和重构支持。</li>
</ol>
<p><strong><code>b. 劣势</code></strong></p>
<ol>
<li><strong>侵入性</strong>：Java代码需要依赖Spring的注解API（如<code>org.springframework.stereotype.Component</code>），与Spring框架产生了耦合。</li>
<li><strong>配置分散</strong>：配置信息分散在各个Java类中，不如XML那样能提供一个全局的、集中的配置视图。</li>
<li><strong>对第三方库不友好</strong>：如果你想将一个<strong>第三方库</strong>中的类（你没有它的源码）注册为Bean，你无法去修改它的源码来添加<code>@Component</code>注解。这种场景下，XML配置或Java Config是更好的选择。</li>
</ol>
<p><strong>总结</strong></p>
<p>注解驱动是目前Spring应用开发中最主流、最高效的配置方式。它通过<strong>组件扫描</strong>和<strong>语义化的分层注解</strong>，极大地简化了Bean的声明过程。虽然它有一定的侵入性，但在大多数业务开发场景中，其带来的开发便利性远远超过了这点小小的代价。</p>
<hr>
<h5 id="3-Java-Config-Configuration-Bean"><a href="#3-Java-Config-Configuration-Bean" class="headerlink" title="3. Java Config (@Configuration, @Bean)"></a>3. Java Config (<code>@Configuration</code>, <code>@Bean</code>)</h5><h6 id="a-什么是Java-Config？"><a href="#a-什么是Java-Config？" class="headerlink" title="a). 什么是Java Config？"></a>a). 什么是Java Config？</h6><p>Java Config 是一种使用Java类和注解来定义Spring IoC容器中Bean及其依赖关系的方式。它的核心就是 <code>@Configuration</code> 和 <code>@Bean</code> 这两个注解。</p>
<p>这种方式的巨大优势在于：</p>
<ul>
<li><strong>类型安全 (Type-Safe)</strong>：所有的配置都是Java代码，编译器可以检查你的配置是否存在语法错误、方法名错误等问题。而在XML中，这些错误只能在运行时才能发现。</li>
<li><strong>重构友好 (Refactoring-Friendly)</strong>：如果你要重命名一个类或方法，IDE的重构工具可以自动更新所有引用它的Java Config，而XML配置则需要手动查找和修改。</li>
<li><strong>灵活性和编程能力</strong>：你可以在 <code>@Bean</code> 方法中使用任何Java代码（if&#x2F;else、循环、调用其他方法）来动态地、有条件地创建和配置Bean。</li>
</ul>
<hr>
<h6 id="b-核心注解详解"><a href="#b-核心注解详解" class="headerlink" title="b). 核心注解详解"></a>b). 核心注解详解</h6><p><strong>a) <code>@Configuration</code></strong></p>
<ul>
<li><strong>作用</strong>：标记在一个类上，表明这个类是一个<strong>配置类</strong>。Spring容器会处理这个类，并将其中的 <code>@Bean</code> 方法定义的Bean注册到 <code>ApplicationContext</code> 中。</li>
<li><strong>本质</strong>：一个带有 <code>@Configuration</code> 注解的类，其本身也会被Spring当作一个特殊的 <code>@Component</code> 来管理。你可以像注入其他Bean一样注入它。</li>
<li><strong>类比</strong>：可以把它看作是一个 <strong>XML配置文件</strong>（如 <code>applicationContext.xml</code>）。</li>
</ul>
<p><strong>b) <code>@Bean</code></strong></p>
<ul>
<li><strong>作用</strong>：标记在一个方法上，并且这个方法必须位于一个 <code>@Configuration</code> 类中（或者带有 <code>@Component</code> 及其派生注解的类中，但推荐在 <code>@Configuration</code> 中使用）。</li>
<li><strong>功能</strong>：Spring会调用这个方法，并将方法的<strong>返回值</strong>注册为一个Bean。</li>
<li><strong>Bean的名称</strong>：默认情况下，Bean的名称就是<strong>方法名</strong>。你也可以通过 <code>@Bean(name = &quot;customName&quot;)</code> 或 <code>@Bean(&quot;customName&quot;)</code> 来指定一个不同的名字。</li>
<li><strong>类比</strong>：可以把它看作是XML配置中的一个 <strong><code>&lt;bean&gt;</code> 标签</strong>。</li>
</ul>
<hr>
<h6 id="c-SpringBoot中的实际应用与示例"><a href="#c-SpringBoot中的实际应用与示例" class="headerlink" title="c). SpringBoot中的实际应用与示例"></a>c). SpringBoot中的实际应用与示例</h6><p>在SpringBoot中，<code>@SpringBootApplication</code> 这个注解本身就是一个组合注解，它包含了 <code>@Configuration</code>。这意味着你的主启动类（例如 <code>MyApplication.java</code>）本身就是一个配置类！</p>
<p>让我们通过一个实际的例子来理解。假设我们需要在项目中使用一个第三方的邮件发送客户端，这个客户端类我们无法修改，不能在它上面加 <code>@Component</code> 注解。这时，<code>@Bean</code> 就派上用场了。</p>
<p><strong>第一步：定义一个需要被管理的类 (假设这是第三方库提供的)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个模拟的第三方库中的类，我们无法修改它的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmtpMailSender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmtpMailSender</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        System.out.println(<span class="string">&quot;Initializing SmtpMailSender for host: &quot;</span> + host);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String to, String subject, String body)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending email to &quot;</span> + to);</span><br><span class="line">        System.out.println(<span class="string">&quot;Host: &quot;</span> + host + <span class="string">&quot;:&quot;</span> + port);</span><br><span class="line">        System.out.println(<span class="string">&quot;Subject: &quot;</span> + subject);</span><br><span class="line">        System.out.println(<span class="string">&quot;Body: &quot;</span> + body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：创建一个配置类来定义Bean</strong></p>
<p>我们创建一个专门的配置类来管理邮件相关的Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 application.properties 文件中注入配置值</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mail.smtp.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mail.smtp.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 这个方法告诉Spring：调用我，然后把我返回的对象注册成一个Bean</span></span><br><span class="line">    <span class="keyword">public</span> SmtpMailSender <span class="title function_">smtpMailSender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里，我们可以使用任何Java代码来创建和配置这个对象</span></span><br><span class="line">        <span class="comment">// 这比XML灵活得多</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Creating SmtpMailSender bean...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SmtpMailSender</span>(host, port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><code>application.properties</code> 文件内容:</em></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mail.smtp.host</span>=<span class="string">smtp.example.com</span></span><br><span class="line"><span class="attr">mail.smtp.port</span>=<span class="string">587</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步：在业务代码中使用这个Bean</strong></p>
<p>现在，<code>SmtpMailSender</code> 已经被注册到了 <code>ApplicationContext</code> 中，我们可以在任何需要的地方通过依赖注入来使用它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmtpMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring会自动找到名为&quot;smtpMailSender&quot;的Bean并注入进来</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationService</span><span class="params">(SmtpMailSender mailSender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mailSender = mailSender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendWelcomeEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        mailSender.send(email, <span class="string">&quot;Welcome!&quot;</span>, <span class="string">&quot;Thanks for signing up.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="d-Java-Config-与-ComponentScan-的关系"><a href="#d-Java-Config-与-ComponentScan-的关系" class="headerlink" title="d). Java Config 与 @ComponentScan 的关系"></a>d). <code>Java Config</code> 与 <code>@ComponentScan</code> 的关系</h6><p>现在我们把所有知识点串起来：</p>
<ol>
<li><strong>启动过程</strong>：当你运行 <code>SpringApplication.run()</code> 时，SpringBoot创建了 <code>AnnotationConfigServletWebServerApplicationContext</code>。</li>
<li><strong>寻找配置源</strong>：这个 <code>ApplicationContext</code> 需要知道去哪里加载Bean的定义。它会把你的主启动类（带有 <code>@SpringBootApplication</code>）作为一个主要的配置源。</li>
<li><strong>处理配置类</strong>：<ul>
<li>因为 <code>@SpringBootApplication</code> 包含了 <code>@ComponentScan</code>，所以<code>Context</code>会扫描主类所在的包及其子包，寻找所有被 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@RestController</code> 等注解标记的类，并将它们自动注册为Bean（这是<strong>隐式Bean定义</strong>）。</li>
<li>因为 <code>@SpringBootApplication</code> 包含了 <code>@Configuration</code>，所以<code>Context</code>会处理主启动类，以及扫描到的其他 <code>@Configuration</code> 类（比如我们上面写的 <code>MailConfig</code>）。它会查找这些类中所有被 <code>@Bean</code> 注解标记的方法，执行它们，并将返回值注册为Bean（这是<strong>显式Bean定义</strong>）。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>在实际的SpringBoot Web后端开发中，<code>ApplicationContext</code> (即 <code>AnnotationConfigServletWebServerApplicationContext</code>) 就是通过这两种方式结合来构建完整的Bean集合的：</p>
<ul>
<li><strong>组件扫描 (<code>@ComponentScan</code>)</strong>：用于自动发现和注册你自己编写的业务组件。</li>
<li><strong>Java配置 (<code>@Configuration</code> + <code>@Bean</code>)</strong>：用于显式地、集中地定义那些需要复杂初始化逻辑的、或者来自第三方库的Bean。</li>
</ul>
<p>这两者共同构成了 <code>AnnotationConfig...</code> 上下文的配置基础，为你提供了一个强大、灵活且类型安全的IoC容器。</p>
<hr>
<h4 id="1-3-3-组件扫描-ComponentScan-的工作原理"><a href="#1-3-3-组件扫描-ComponentScan-的工作原理" class="headerlink" title="1.3.3 组件扫描(@ComponentScan)的工作原理"></a>1.3.3 组件扫描(<code>@ComponentScan</code>)的工作原理</h4><h5 id="1-核心目标"><a href="#1-核心目标" class="headerlink" title="1. 核心目标"></a>1. 核心目标</h5><p><code>@ComponentScan</code> 的核心目标是：<strong>自动化地发现和注册Bean</strong>。</p>
<p>在没有组件扫描之前，你需要为每一个想让Spring管理的类，在XML文件中写一个对应的<code>&lt;bean&gt;</code>标签，或者在Java配置类中写一个<code>@Bean</code>方法。当项目规模变大时，这种手动注册的方式会变得极其繁琐和容易出错。</p>
<hr>
<h5 id="2-工作流程详解"><a href="#2-工作流程详解" class="headerlink" title="2. 工作流程详解"></a>2. 工作流程详解</h5><p>组件扫描的整个过程可以分解为以下几个步骤</p>
<pre><code class="highlight mermaid">graph TD
    subgraph &quot;阶段一：扫描与定义&quot;
        A[&quot;&lt;b&gt;第一步：触发扫描&lt;/b&gt;&lt;br/&gt;ApplicationContext初始化&lt;br/&gt;处理 @Configuration/&lt;br&gt;@SpringBootApplication&quot;] --&gt; B;
        B[&quot;&lt;b&gt;第二步：确定扫描起点 &lt;br&gt;(Base Packages)&lt;/b&gt;&lt;br/&gt;&lt;i&gt;默认: @ComponentScan所在包&lt;br/&gt;显式: basePackages等&lt;/i&gt;&quot;] --&gt; C;
        C[&quot;&lt;b&gt;第三步：执行类路径扫描&lt;/b&gt;&lt;br/&gt;递归遍历包下的.class文件&lt;br/&gt;(使用ASM高效读取元数据)&quot;] --&gt; D;
        D&#123;&quot;&lt;b&gt;第四步：筛选候选组件&lt;/b&gt;&lt;br/&gt;类是否带有@Component等注解?&quot;&#125; -- 是 --&gt; E;
        D -- 否 --&gt; F[忽略此类, 继续扫描];
        E[&quot;&lt;b&gt;第五步:注册Bean定义&lt;/b&gt;&lt;br/&gt;为每个候选组件创建&lt;br&gt;BeanDefinition(蓝图)&lt;br/&gt;&lt;b&gt;注意：此时不创建实例&lt;/b&gt;&quot;] --&gt; G(BeanDefinitionRegistry&lt;br/&gt;注册并存储所有Bean定义);
    end

    subgraph &quot;阶段二：实例化与使用&quot;
        G --&gt; H[&quot;&lt;b&gt;第六步:实例化Bean&lt;/b&gt;&lt;br/&gt;(在容器后续阶段)&lt;br/&gt;BeanFactory读取BeanDefinition&lt;br/&gt;创建实例、处理依赖注入&lt;br/&gt;执行初始化回调&quot;];
        H --&gt; I(单例池 Singleton Cache&lt;br/&gt;存储最终可用的Bean实例);
    end

    %% --- 样式定义 ---
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style H fill:#ccf,stroke:#333,stroke-width:2px
    style G fill:#bfa,stroke:#333,stroke-width:2px
    style I fill:#bfa,stroke:#333,stroke-width:2px</code></pre>

<p><strong>第一步：触发扫描</strong></p>
<ul>
<li>扫描是在Spring容器（<code>ApplicationContext</code>）的初始化过程中被触发的。</li>
<li>当容器处理一个带有 <code>@Configuration</code> 注解的配置类时，它会检查这个类上是否存在 <code>@ComponentScan</code> 注解。</li>
<li>在SpringBoot中，<code>@SpringBootApplication</code> 注解已经包含了 <code>@ComponentScan</code>，所以主启动类就是扫描的触发点。</li>
</ul>
<p><strong>第二步：确定扫描起点（Base Packages）</strong></p>
<ul>
<li><code>@ComponentScan</code> 需要知道从哪里开始扫描。这个起始点被称为“基础包”（Base Packages）。</li>
<li><strong>默认行为（SpringBoot中）</strong>：如果没有明确指定基础包，Spring会把<strong>声明<code>@ComponentScan</code>注解的那个类所在的包</strong>作为扫描的起点。<ul>
<li>这就是为什么SpringBoot推荐你把主启动类放在项目的根包下（例如 <code>com.example.myapp</code>），这样它就能自动扫描到 <code>com.example.myapp.controller</code>、<code>com.example.myapp.service</code> 等所有子包中的组件。</li>
</ul>
</li>
<li><strong>显式指定</strong>：你可以通过参数来精确控制扫描的范围：<ul>
<li><code>@ComponentScan(basePackages = &quot;com.example.anotherpackage&quot;)</code></li>
<li><code>@ComponentScan(basePackageClasses = SomeClass.class)</code> (更类型安全的方式，它会扫描<code>SomeClass</code>所在的包)</li>
</ul>
</li>
</ul>
<p><strong>第三步：执行类路径扫描</strong></p>
<ul>
<li>确定了起点后，Spring的扫描器会开始工作。它会递归地遍历基础包及其所有子包下的<strong>类路径（classpath）</strong>。</li>
<li>这个过程并不是去读取<code>.java</code>源文件，而是去检查编译后的<code>.class</code>文件。</li>
<li>为了提高效率，Spring使用了一种名为ASM的字节码操作库。它可以在不完全加载类到JVM的情况下，就能读取到类的元数据（比如类名、注解信息等），这比使用Java反射要快得多。</li>
</ul>
<p><strong>第四步：筛选候选组件</strong></p>
<ul>
<li><p>扫描器在遍历<code>.class</code>文件时，会检查每个类是否带有特定的**“构造型注解”（Stereotype Annotations）**。</p>
</li>
<li><p>最核心的构造型注解是 <code>@Component</code>。</p>
</li>
<li><p>其他常见的注解，如 <code>@Service</code>、<code>@Repository</code>、<code>@RestController</code>、<code>@Configuration</code>，它们本身都是被 <code>@Component</code> <strong>元注解</strong>（meta-annotated）的。这意味着，一个类只要被这些注解中的任何一个标记，就会被扫描器视为一个候选的Bean组件。</p>
<ul>
<li><p>例如，<code>@Service</code>注解的源码是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// &lt;-- 关键在于这里！</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>第五步：注册Bean定义（BeanDefinition）</strong></p>
<ul>
<li>对于每一个筛选出来的候选组件，Spring并不会立即创建它的实例。</li>
<li>相反，它会为这个类创建一个**<code>BeanDefinition</code>**对象。</li>
<li><code>BeanDefinition</code> 就像是创建Bean的“蓝图”或“配方”，它包含了所有关于这个Bean的元信息，例如：<ul>
<li>Bean的类名 (<code>com.example.myapp.service.MyService</code>)</li>
<li>Bean的作用域（默认为<code>singleton</code>）</li>
<li>是否是懒加载</li>
<li>依赖关系等</li>
</ul>
</li>
<li>然后，Spring将这个<code>BeanDefinition</code>注册到容器内部的一个名为<code>BeanDefinitionRegistry</code>的注册表中。</li>
</ul>
<p><strong>第六步：实例化Bean</strong></p>
<ul>
<li>在容器初始化后续阶段，Spring会遍历<code>BeanDefinitionRegistry</code>中所有的<code>BeanDefinition</code>。</li>
<li>根据这些“蓝图”，Spring的<code>BeanFactory</code>才会真正地去创建Bean的实例、处理依赖注入（<code>@Autowired</code>）、执行初始化回调方法等，最终将一个完整的、可用的Bean放入到单例池（Singleton Cache）中，供应用程序使用。</li>
</ul>
<hr>
<h5 id="3-示例与总结"><a href="#3-示例与总结" class="headerlink" title="3. 示例与总结"></a>3. 示例与总结</h5><p><strong>项目结构:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.example.myapp</span><br><span class="line">├── MyApplication.java       // 主启动类，位于根包</span><br><span class="line">├── controller</span><br><span class="line">│   └── UserController.java  // @RestController</span><br><span class="line">├── service</span><br><span class="line">│   └── UserService.java     // @Service</span><br><span class="line">└── repository</span><br><span class="line">    └── UserRepository.java  // @Repository</span><br></pre></td></tr></table></figure>

<p><strong>工作流程演示:</strong></p>
<ol>
<li>运行 <code>MyApplication</code>，SpringBoot启动 <code>AnnotationConfigServletWebServerApplicationContext</code>。</li>
<li><code>Context</code> 发现 <code>MyApplication</code> 上有 <code>@SpringBootApplication</code>，其中包含了 <code>@ComponentScan</code>。</li>
<li>由于没有指定<code>basePackages</code>，扫描起点被确定为 <code>com.example.myapp</code>。</li>
<li>扫描器开始递归扫描 <code>com.example.myapp</code> 及其子包 <code>controller</code>, <code>service</code>, <code>repository</code>。</li>
<li>它发现了：<ul>
<li><code>UserController</code> 带有 <code>@RestController</code> (其元注解是 <code>@Component</code>)</li>
<li><code>UserService</code> 带有 <code>@Service</code> (其元注解是 <code>@Component</code>)</li>
<li><code>UserRepository</code> 带有 <code>@Repository</code> (其元注解是 <code>@Component</code>)</li>
</ul>
</li>
<li>Spring为这三个类分别创建了<code>BeanDefinition</code>，并注册到容器中。</li>
<li>随后，Spring根据这些<code>BeanDefinition</code>实例化<code>UserController</code>, <code>UserService</code>, <code>UserRepository</code>，并处理它们之间的依赖注入关系。</li>
</ol>
<hr>
<h3 id="1-4-依赖注入-DI"><a href="#1-4-依赖注入-DI" class="headerlink" title="1.4 依赖注入(DI)"></a>1.4 依赖注入(DI)</h3><h4 id="1-4-1-Setter注入"><a href="#1-4-1-Setter注入" class="headerlink" title="1.4.1 Setter注入"></a>1.4.1 Setter注入</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h5><p>Setter注入是Spring IoC容器通过调用Bean的<strong>setter方法</strong>来将依赖项注入到该Bean中的一种方式。为了让Spring能够执行Setter注入，类中必须为对应的依赖提供一个 <code>public</code> 的setter方法。</p>
<hr>
<h5 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ol>
<li><strong>实例化Bean</strong>：Spring容器首先通过调用Bean的<strong>无参构造函数</strong>来创建该Bean的实例。在这一步，被注入的依赖字段是 <code>null</code>。</li>
<li><strong>调用Setter方法</strong>：创建实例后，Spring容器会查找被<code>@Autowired</code>注解标记的setter方法（或者被标记的字段对应的setter方法）。</li>
<li><strong>注入依赖</strong>：Spring从容器中找到所需类型的Bean（依赖项），然后调用setter方法，将该依赖项作为参数传入，从而完成注入。</li>
</ol>
<hr>
<h5 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p>让我们沿用之前的例子，有一个<code>MessageService</code>和需要它的<code>NotificationManager</code>。</p>
<p><strong>第一步：定义接口和实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 注册为一个Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending email with message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：使用Setter注入</strong></p>
<p>在<code>NotificationManager</code>中，我们定义一个setter方法来接收<code>MessageService</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在无参构造函数执行时，messageService 仍然是 null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;NotificationManager constructor called. MessageService is: &quot;</span> + <span class="built_in">this</span>.messageService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring容器会找到这个setter方法并调用它来注入MessageService的实例</span></span><br><span class="line">    <span class="comment">// @Autowired可以放在方法上</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessageService</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Setter injection: Injecting MessageService into NotificationManager.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 在setter被调用后，messageService才可用</span></span><br><span class="line">        <span class="keyword">if</span> (messageService == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Error: MessageService has not been injected!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        messageService.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <code>@Autowired</code>注解可以直接放在setter方法上。更常见的做法是将其放在字段上，Spring在注入时会尝试寻找并使用对应的setter方法（如果存在）。如果不存在setter方法，Spring会通过反射直接设置私有字段的值（这其实是字段注入）。但从概念上讲，为字段提供setter方法并让Spring使用它，就是标准的Setter注入。                                                                                                      </p>
<hr>
<h5 id="4-优点"><a href="#4-优点" class="headerlink" title="4. 优点"></a>4. 优点</h5><ul>
<li><strong>可选依赖（Optional Dependencies）</strong>：这是Setter注入最主要的适用场景。如果一个依赖不是必需的，那么使用Setter注入就非常合适。即使容器中没有找到对应的Bean，对象本身仍然可以被创建，只是与该依赖相关的功能将不可用。</li>
<li><strong>灵活性和可重配置性</strong>：对象创建后，理论上仍然可以通过调用setter方法来更换其依赖（虽然在单例Bean的生命周期中很少这样做）。</li>
<li><strong>解决部分循环依赖问题</strong>：在某些情况下，Setter注入可以解决构造器注入无法解决的循环依赖问题（例如A依赖B，B又依赖A）。因为对象A可以先被构造出来（依赖B此时为null），然后再注入B。当构造B时，因为A的实例已经存在（虽然未完全初始化），所以可以注入到B中。<strong>但循环依赖通常是代码设计不良的信号</strong>。</li>
</ul>
<hr>
<h5 id="5-缺点（以及为什么它不再是首选）"><a href="#5-缺点（以及为什么它不再是首选）" class="headerlink" title="5. 缺点（以及为什么它不再是首选）"></a>5. 缺点（以及为什么它不再是首选）</h5><ul>
<li><strong>对象状态不完整</strong>：Bean在构造函数执行完毕后，其依赖项可能仍然是<code>null</code>。它不是一个“开箱即用”的完整对象。只有在所有setter方法都被调用后，这个对象才处于完全可用的状态。这可能导致在初始化过程中出现<code>NullPointerException</code>。</li>
<li><strong>可变性（Mutability）</strong>：由于提供了<code>public</code>的setter方法，这个类的依赖关系可以在外部被改变，破坏了对象的不变性。在多线程环境中，这可能会引入不确定性。</li>
<li><strong>隐藏依赖关系</strong>：类的使用者无法通过构造函数清晰地看到这个类需要哪些<strong>必要</strong>的依赖。一个只有无参构造函数的类看起来似乎不依赖任何东西，但实际上它可能无法在没有setter注入的情况下正常工作。</li>
</ul>
<hr>
<h4 id="1-4-2-构造器注入-官方推荐"><a href="#1-4-2-构造器注入-官方推荐" class="headerlink" title="1.4.2 构造器注入 (官方推荐)"></a>1.4.2 构造器注入 (官方推荐)</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h5><p>构造器注入是Spring IoC容器通过调用Bean的<strong>构造函数</strong>，并将依赖项作为构造函数<strong>参数</strong>传入，来完成依赖注入的方式。这是实现依赖注入最清晰、最安全的方法。</p>
<hr>
<h5 id="2-工作原理-1"><a href="#2-工作原理-1" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ol>
<li><strong>识别构造函数</strong>：当Spring容器需要创建一个Bean的实例时（例如<code>NotificationManager</code>），它会检查这个类的构造函数。<ul>
<li><strong>如果只有一个构造函数</strong>：从Spring 4.3开始，Spring会自动使用这个构造函数进行注入，你<strong>甚至不需要</strong>在上面添加<code>@Autowired</code>注解。这是最简洁、最推荐的方式。</li>
<li><strong>如果有多个构造函数</strong>：Spring会不知道使用哪一个。在这种情况下，你<strong>必须</strong>在你想让Spring使用的那个构造函数上明确地添加<code>@Autowired</code>注解。</li>
</ul>
</li>
<li><strong>解析依赖项</strong>：Spring会分析所选构造函数的参数列表（例如，它看到需要一个<code>MessageService</code>类型的Bean）。</li>
<li><strong>获取依赖Bean</strong>：Spring会去自己的容器中查找一个匹配类型的Bean（例如，它找到了我们之前定义的<code>EmailService</code>实例）。</li>
<li><strong>调用构造函数并实例化</strong>：Spring调用该构造函数，并将找到的依赖Bean作为参数传入，从而创建<code>NotificationManager</code>的实例。</li>
</ol>
<p>关键在于，<strong>对象在被创建的那一刻，其所有必需的依赖就已经被完全设置好了</strong>。</p>
<hr>
<h5 id="3-代码示例-1"><a href="#3-代码示例-1" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p>我们继续使用<code>NotificationManager</code>的例子，这次改用构造器注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 final 关键字声明依赖，这是一个非常好的实践！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring会自动调用这个构造函数</span></span><br><span class="line">    <span class="comment">// @Autowired 在只有一个构造函数时是可选的</span></span><br><span class="line">    <span class="comment">// public NotificationManager(@Qualifier(&quot;emailService&quot;) MessageService messageService) &#123; // 如果有多个实现，可以使用@Qualifier指定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor injection: Injecting MessageService into NotificationManager.&quot;</span>);</span><br><span class="line">        <span class="comment">// 在构造函数执行时，依赖就已经可用了</span></span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// messageService 保证不为 null，因为构造函数强制要求它</span></span><br><span class="line">        messageService.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-优点-为什么官方推荐？"><a href="#4-优点-为什么官方推荐？" class="headerlink" title="4. 优点 (为什么官方推荐？)"></a>4. 优点 (为什么官方推荐？)</h5><p>构造器注入之所以成为首选，是因为它具有Setter注入无法比拟的巨大优势：</p>
<ol>
<li><p><strong>依赖的不可变性 (Dependency Immutability)</strong></p>
<ul>
<li>你可以将依赖字段声明为 <code>final</code>（如示例所示）。</li>
<li><code>final</code> 字段必须在构造函数中被初始化，并且之后不能再被修改。</li>
<li>这使得你的Bean成为一个<strong>不可变对象</strong>（至少其依赖关系是不可变的），这在多线程环境中更安全，也使得代码的行为更加可预测和稳定。</li>
</ul>
</li>
<li><p><strong>保证对象状态的完整性 (Guaranteed Object Integrity)</strong></p>
<ul>
<li>对象一旦被创建，就处于一个完全初始化、可用的状态。</li>
<li>你永远不会遇到一个已经被构造出来、但其必需的依赖还是 <code>null</code> 的情况。这从根本上杜绝了在后续方法调用中出现<code>NullPointerException</code>的风险。</li>
</ul>
</li>
<li><p><strong>明确的依赖关系 (Clear Dependency Declaration)</strong></p>
<ul>
<li>类的构造函数签名就像一份“契约”，清晰地声明了“要创建我这个类的实例，你<strong>必须</strong>提供这些依赖”。</li>
<li>这使得代码的可读性大大提高。任何开发者看到这个类，都能立刻明白它的核心依赖是什么，而不需要去寻找散落在各处的setter方法。</li>
</ul>
</li>
<li><p><strong>易于单元测试 (Easier Unit Testing)</strong></p>
<ul>
<li>使用构造器注入的类，在进行单元测试时非常方便。你不需要启动整个Spring容器。</li>
<li>你可以直接使用 <code>new</code> 关键字来实例化你的类，并传入一个模拟（Mock）的依赖对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JUnit测试中</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSendNotification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个模拟的依赖</span></span><br><span class="line">    <span class="type">MessageService</span> <span class="variable">mockService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockMessageService</span>(); <span class="comment">// 或者使用Mockito.mock(MessageService.class)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 直接使用new关键字创建被测试对象，完全脱离Spring</span></span><br><span class="line">    <span class="type">NotificationManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationManager</span>(mockService);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行测试</span></span><br><span class="line">    manager.sendNotification(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 验证模拟对象的行为</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="5-缺点-注意事项"><a href="#5-缺点-注意事项" class="headerlink" title="5. 缺点&#x2F;注意事项"></a>5. 缺点&#x2F;注意事项</h5><ul>
<li><p><strong>循环依赖问题 (Circular Dependency Problem)</strong></p>
<ul>
<li>如果类A通过构造器依赖类B，同时类B也通过构造器依赖类A，Spring在启动时会抛出<code>BeanCurrentlyInCreationException</code>异常，因为无法解决这个“先有鸡还是先有蛋”的问题。</li>
<li><strong>但这通常被认为是一个优点</strong>！它在应用启动的早期就暴露了代码设计的坏味道（Bad Smell）。循环依赖通常意味着类的职责划分不清晰，应该通过重构来解决，而不是绕过它。</li>
</ul>
</li>
<li><p><strong>代码冗长 (Verbosity)</strong></p>
<ul>
<li>如果一个类有大量的依赖，构造函数会变得很长。</li>
<li>但这同样也是一个代码设计的警告信号，可能表示该类承担了过多的责任（违反了单一职责原则）。</li>
<li>在实践中，可以使用<strong>Lombok</strong>项目的<code>@RequiredArgsConstructor</code>注解来自动生成构造函数，从而完全消除这种冗长的代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span> <span class="comment">// Lombok注解：为所有final字段生成一个构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line">    <span class="comment">// 构造函数代码被自动生成了，非常简洁！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        messageService.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-4-3-字段注入-简洁但不推荐"><a href="#1-4-3-字段注入-简洁但不推荐" class="headerlink" title="1.4.3 字段注入 (简洁但不推荐)"></a>1.4.3 字段注入 (简洁但不推荐)</h4><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1. 定义"></a>1. 定义</h5><p>字段注入是通过将 <code>@Autowired</code> 注解直接标记在类的<strong>成员字段</strong>上，来让Spring容器注入依赖的方式。它不需要任何构造函数或setter方法。</p>
<hr>
<h5 id="2-工作原理-2"><a href="#2-工作原理-2" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ol>
<li><strong>实例化Bean</strong>：Spring容器首先通过调用Bean的<strong>无参构造函数</strong>来创建实例。在这一刻，所有被 <code>@Autowired</code> 标记的字段都还是 <code>null</code>。</li>
<li><strong>使用反射进行注入</strong>：在对象实例化之后，Spring容器会使用<strong>Java的反射（Reflection）API</strong>来直接设置这些字段的值。它会强行访问这些字段（即使它们是 <code>private</code> 的），并将从容器中找到的依赖Bean赋值给它们。</li>
</ol>
<p>这个过程完全绕过了类的公共方法（构造函数和setter），直接在“幕后”完成了依赖的设置。</p>
<hr>
<h5 id="3-代码示例-2"><a href="#3-代码示例-2" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p>这是看起来最简洁的一种写法，也因此在很多早期教程和项目中非常流行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Autowired直接放在字段上</span></span><br><span class="line">    <span class="comment">// Spring会通过反射直接为这个私有字段赋值</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要一个无参构造函数（如果没有其他构造函数，默认就有一个）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在构造函数执行时，messageService 绝对是 null!</span></span><br><span class="line">        System.out.println(<span class="string">&quot;NotificationManager constructor called. MessageService is: &quot;</span> + <span class="built_in">this</span>.messageService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 在Spring完成反射注入后，messageService才可用</span></span><br><span class="line">        <span class="keyword">if</span> (messageService == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 理论上在Spring管理的Bean中，这个分支不会被执行</span></span><br><span class="line">            System.err.println(<span class="string">&quot;Error: MessageService has not been injected!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        messageService.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出日志会显示：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager constructor called. MessageService is: null</span><br><span class="line">Sending email with message: Your notification</span><br></pre></td></tr></table></figure>

<p>这清晰地证明了注入发生在构造函数执行<strong>之后</strong>。</p>
<hr>
<h5 id="4-优点（为什么人们会用它？）"><a href="#4-优点（为什么人们会用它？）" class="headerlink" title="4. 优点（为什么人们会用它？）"></a>4. 优点（为什么人们会用它？）</h5><ul>
<li><strong>极其简洁</strong>：代码量最少。只需要加一个注解和一行字段声明，不需要写任何构造函数或setter方法，看起来非常“干净”。</li>
</ul>
<p>这就是它唯一的优点，但这个优点带来的代价远大于它的便利性。</p>
<hr>
<h5 id="5-缺点（为什么官方和社区强烈不推荐？）"><a href="#5-缺点（为什么官方和社区强烈不推荐？）" class="headerlink" title="5. 缺点（为什么官方和社区强烈不推荐？）"></a>5. 缺点（为什么官方和社区强烈不推荐？）</h5><ol>
<li><p><strong>隐藏依赖关系 (Hidden Dependencies)</strong></p>
<ul>
<li>类的依赖关系被隐藏在了实现细节中。你无法通过查看类的公共接口（构造函数）来知道它需要什么才能工作。你必须阅读整个类的源码才能找到所有 <code>@Autowired</code> 字段。</li>
</ul>
</li>
<li><p><strong>极大地增加了单元测试的难度 (Difficulty in Unit Testing)</strong></p>
<ul>
<li>这是最致命的缺点。由于这个类依赖于Spring的反射注入，你无法在单元测试中简单地用 <code>new</code>的实例并提供模拟依赖。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单元测试中，这样做会失败！</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSendNotification_Fails</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">NotificationManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationManager</span>();</span><br><span class="line">    <span class="comment">// 运行到下面这行时，manager.messageService 是 null，会抛出 NullPointerException</span></span><br><span class="line">    manager.sendNotification(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为了测试它，你不得不使用更复杂的方法：<ul>
<li><strong>A) 使用反射来手动设置私有字段</strong>：这非常繁琐且容易出错。</li>
<li><strong>B) 启动一个完整的Spring测试容器</strong>（例如使用 <code>@SpringBootTest</code>）：这会大大减慢测试速度，使其更像是集成测试，而不是轻量级的单元测试。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>无法创建不可变对象 (Immutability is Impossible)</strong></p>
<ul>
<li>因为依赖是在对象构造之后才注入的，所以你<strong>无法将依赖字段声明为 <code>final</code></strong>。</li>
<li>这意味着你的Bean本质上是可变的，失去了 <code>final</code> 关键字带来的所有好处（如线程安全、代码可预测性等）。</li>
</ul>
</li>
<li><p><strong>与依赖注入容器强耦合 (Tight Coupling to DI Container)</strong></p>
<ul>
<li>这个类只有在Spring容器的环境下才能被正确地实例化和使用。它无法脱离Spring作为一个独立的、普通的Java对象（POJO）来使用。而使用构造器注入的类则完全可以。</li>
</ul>
</li>
<li><p><strong>可能助长坏习惯 (Encourages Bad Practices)</strong></p>
<ul>
<li>因为添加一个新依赖非常简单（只需加一行 <code>@Autowired</code> 字段），开发者可能会不知不觉地给一个类添加过多的依赖（例如10个、15个）。</li>
<li>如果使用构造器注入，一个有15个参数的构造函数会立刻发出强烈的“警告信号”，表明这个类职责过多，需要重构。字段注入则完美地隐藏了这个问题。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="6-一个可以接受的例外场景"><a href="#6-一个可以接受的例外场景" class="headerlink" title="6. 一个可以接受的例外场景"></a>6. 一个可以接受的例外场景</h5><p>字段注入有一个被社区普遍接受的例外使用场景：<strong>在测试类中注入Mocks</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span> <span class="comment">// 启用Mockito扩展</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotificationManagerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span> <span class="comment">// 创建一个MessageService的模拟对象</span></span><br><span class="line">    <span class="keyword">private</span> MessageService mockMessageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMocks</span> <span class="comment">// 创建NotificationManager实例，并将上面@Mock标记的对象注入进去</span></span><br><span class="line">    <span class="keyword">private</span> NotificationManager notificationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSendNotification</span><span class="params">()</span> &#123;</span><br><span class="line">        notificationManager.sendNotification(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="comment">// ... 验证 mockMessageService 的行为 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，使用字段注入是为了减少测试代码的样板代码，是可以接受的，因为测试类本身不是应用程序的组件。</p>
<hr>
<h5 id="总结与最终对比"><a href="#总结与最终对比" class="headerlink" title="总结与最终对比"></a>总结与最终对比</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">构造器注入 (Constructor Injection)</th>
<th align="left">Setter注入 (Setter Injection)</th>
<th align="left">字段注入 (Field Injection)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left"><strong>官方首选</strong></td>
<td align="left">用于可选依赖</td>
<td align="left"><strong>强烈不推荐</strong></td>
</tr>
<tr>
<td align="left"><strong>依赖类型</strong></td>
<td align="left">强制性、必需的依赖</td>
<td align="left">可选的、非必需的依赖</td>
<td align="left">任何依赖 (不区分)</td>
</tr>
<tr>
<td align="left"><strong>不可变性</strong></td>
<td align="left"><strong>支持 (通过 <code>final</code>)</strong></td>
<td align="left">不支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left"><strong>对象状态</strong></td>
<td align="left"><strong>创建即完整可用</strong></td>
<td align="left">创建后可能不完整</td>
<td align="left">创建后不完整</td>
</tr>
<tr>
<td align="left"><strong>依赖声明</strong></td>
<td align="left"><strong>清晰，在构造函数中</strong></td>
<td align="left">较隐蔽，在setter方法中</td>
<td align="left"><strong>非常隐蔽，在私有字段中</strong></td>
</tr>
<tr>
<td align="left"><strong>单元测试</strong></td>
<td align="left"><strong>非常容易 (POJO友好)</strong></td>
<td align="left">较麻烦 (需手动调用setter)</td>
<td align="left"><strong>非常困难 (需反射或容器)</strong></td>
</tr>
<tr>
<td align="left"><strong>循环依赖</strong></td>
<td align="left"><strong>启动时失败 (暴露问题)</strong></td>
<td align="left">可以解决 (但不推荐)</td>
<td align="left">可以解决 (但不推荐)</td>
</tr>
<tr>
<td align="left"><strong>代码简洁度</strong></td>
<td align="left">较冗长 (可用Lombok解决)</td>
<td align="left">冗长</td>
<td align="left"><strong>非常简洁</strong></td>
</tr>
</tbody></table>
<p><strong>最终建议：在你的所有应用组件（<code>@Service</code>, <code>@Component</code>, <code>@Controller</code>等）中，坚持使用构造器注入。</strong></p>
<hr>
<h4 id="1-4-4-Autowired-Resource-Inject-的区别"><a href="#1-4-4-Autowired-Resource-Inject-的区别" class="headerlink" title="1.4.4 @Autowired, @Resource, @Inject 的区别"></a>1.4.4 <code>@Autowired</code>, <code>@Resource</code>, <code>@Inject</code> 的区别</h4><h5 id="1-Autowired"><a href="#1-Autowired" class="headerlink" title="1. @Autowired"></a>1. <code>@Autowired</code></h5><ul>
<li><strong>来源</strong>: <strong>Spring框架</strong> 自带的注解。它是Spring IoC中使用最广泛的注解。</li>
<li><strong>注入规则 (匹配策略)</strong>: <strong>默认按类型（byType）注入</strong>。<ol>
<li>首先，Spring容器会寻找一个与注入点类型完全匹配的Bean。</li>
<li>如果找到了<strong>唯一一个</strong>匹配的Bean，就直接注入。</li>
<li>如果找到了<strong>多个</strong>匹配的Bean，Spring会陷入困惑。此时，它会尝试将<strong>变量名</strong>（或字段名）作为Bean的ID（或name）进行二次匹配。如果有一个Bean的ID与变量名匹配，就注入那个。</li>
<li>如果二次匹配也失败了（比如没有Bean的ID匹配变量名），Spring就会抛出<code>NoUniqueBeanDefinitionException</code>异常。</li>
<li>为了解决上述的歧义性，<code>@Autowired</code> 通常与 <code>@Qualifier(&quot;beanName&quot;)</code> 注解配合使用，来明确指定要注入哪一个Bean。</li>
</ol>
</li>
<li><strong>关键属性</strong>:<ul>
<li><code>required = false</code>：允许注入的Bean不存在。如果设置为 <code>false</code> 且找不到匹配的Bean，Spring会注入 <code>null</code> 而不是抛出异常。</li>
</ul>
</li>
<li><strong>适用位置</strong>: 构造器、字段、Setter方法、以及任何自定义方法。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认按类型查找 MessageService</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当有多个 MessageService 实现时，使用 @Qualifier 指定</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;smsService&quot;)</span> <span class="comment">// 明确指定注入ID为 &quot;smsService&quot; 的Bean</span></span><br><span class="line">    <span class="keyword">private</span> MessageService specificMessageService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-Resource"><a href="#2-Resource" class="headerlink" title="2. @Resource"></a>2. <code>@Resource</code></h5><ul>
<li><p><strong>来源</strong>: <strong>Java EE 的 JSR-250 规范</strong>。它不属于Spring，而是Java的标准注解。Spring框架支持这个注解。</p>
</li>
<li><p><strong>注入规则 (匹配策略)</strong>: <strong>默认按名称（byName）注入</strong>。</p>
<ol>
<li>首先，它会寻找与**<code>name</code>属性**指定的名称匹配的Bean。</li>
<li>如果没有指定<code>name</code>属性，它会使用<strong>字段名或setter方法名</strong>（去掉<code>set</code>前缀并首字母小写）作为Bean的名称去查找。</li>
<li>如果按名称找不到匹配的Bean，它会<strong>回退（fallback）到按类型（byType）查找</strong>。</li>
<li>如果按类型查找到多个，它会抛出<code>NoUniqueBeanDefinitionException</code>。</li>
</ol>
</li>
<li><p><strong>关键属性</strong>:</p>
<ul>
<li><code>name = &quot;beanName&quot;</code>：直接指定要注入的Bean的名称。</li>
</ul>
</li>
<li><p><strong>适用位置</strong>: 字段、Setter方法。</p>
</li>
<li><p><strong>注意事项</strong>: 从 Java 9 开始，JSR-250 相关的库（<code>javax.annotation-api</code>）被标记为废弃，并在 Java 11 中被移除。如果你在现代的Java版本（9+）中使用 <code>@Resource</code>，你需要手动在 <code>pom.xml</code> 中添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 按名称 &quot;smsService&quot; 查找</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;smsService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 未指定name，则按字段名 &quot;emailService&quot; 查找</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageService emailService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-Inject"><a href="#3-Inject" class="headerlink" title="3. @Inject"></a>3. <code>@Inject</code></h5><ul>
<li><p><strong>来源</strong>: <strong>Java 的 JSR-330 规范</strong> (CDI - Contexts and Dependency Injection)。它也是一个Java标准，旨在为所有框架提供统一的依赖注入API。</p>
</li>
<li><p><strong>注入规则 (匹配策略)</strong>: <strong>默认按类型（byType）注入</strong>。它的行为几乎和 <code>@Autowired</code> 完全一样。</p>
<ol>
<li>首先按类型查找。</li>
<li>如果找到多个，它需要配合 JSR-330 的 <code>@Named</code> 注解来指定名称，功能类似于Spring的 <code>@Qualifier</code>。</li>
</ol>
</li>
<li><p><strong>关键属性</strong>:</p>
<ul>
<li>它没有 <code>required</code> 属性。如果你想实现可选注入，需要使用Java 8的 <code>Optional&lt;T&gt;</code>。例如 <code>private Optional&lt;MessageService&gt; messageService;</code>。</li>
</ul>
</li>
<li><p><strong>适用位置</strong>: 构造器、字段、方法。</p>
</li>
<li><p><strong>注意事项</strong>: 要使用 <code>@Inject</code>，你需要添加 <code>javax.inject</code> 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认按类型查找</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当有多个实现时，使用 @Named 指定</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@Named(&quot;smsService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MessageService specificMessageService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-总结与核心区别（面试高频）"><a href="#3-总结与核心区别（面试高频）" class="headerlink" title="3. 总结与核心区别（面试高频）"></a>3. 总结与核心区别（面试高频）</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Autowired</code> (Spring)</th>
<th align="left"><code>@Resource</code> (JSR-250 &#x2F; Java EE)</th>
<th align="left"><code>@Inject</code> (JSR-330 &#x2F; CDI)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>来源</strong></td>
<td align="left">Spring 框架</td>
<td align="left">Java EE 规范</td>
<td align="left">Java CDI 规范</td>
</tr>
<tr>
<td align="left"><strong>默认匹配策略</strong></td>
<td align="left"><strong>按类型 (byType)</strong></td>
<td align="left"><strong>按名称 (byName)</strong></td>
<td align="left"><strong>按类型 (byType)</strong></td>
</tr>
<tr>
<td align="left"><strong>按名称注入方式</strong></td>
<td align="left"><code>@Qualifier(&quot;beanName&quot;)</code></td>
<td align="left"><code>name=&quot;beanName&quot;</code> 或 默认使用字段名</td>
<td align="left"><code>@Named(&quot;beanName&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>处理可选依赖</strong></td>
<td align="left"><code>required = false</code></td>
<td align="left">不直接支持</td>
<td align="left">使用 <code>Optional&lt;T&gt;</code></td>
</tr>
<tr>
<td align="left"><strong>兼容性</strong></td>
<td align="left">仅 Spring 环境</td>
<td align="left">Spring 及其他 Java EE 容器</td>
<td align="left">Spring 及其他支持CDI的容器</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">无需额外依赖 (Spring项目自带)</td>
<td align="left"><strong>需要 <code>jakarta.annotation-api</code> (Java 9+)</strong></td>
<td align="left"><strong>需要 <code>javax.inject</code></strong></td>
</tr>
</tbody></table>
<hr>
<h5 id="4-SpringBoot中的最佳实践和选择"><a href="#4-SpringBoot中的最佳实践和选择" class="headerlink" title="4. SpringBoot中的最佳实践和选择"></a>4. SpringBoot中的最佳实践和选择</h5><ol>
<li><strong>首选 <code>@Autowired</code></strong>：<br>在纯粹的Spring或SpringBoot项目中，<strong>始终优先使用 <code>@Autowired</code></strong>。因为：<ul>
<li>它是Spring的原生注解，与Spring生态（如 <code>@Qualifier</code>, <code>@Primary</code>, Spring Test等）的集成最好、功能最强大。</li>
<li>配合构造器注入，可以创建不可变对象，是目前公认的最佳实践。</li>
</ul>
</li>
<li><strong>什么时候考虑 <code>@Resource</code></strong>？<ul>
<li>当你非常明确地<strong>想通过Bean的名称来进行注入</strong>时，<code>@Resource</code> 的意图比 <code>@Autowired</code> + <code>@Qualifier</code> 更直接。</li>
<li>在一些需要同时兼容其他Java EE容器的老项目中，使用 <code>@Resource</code> 可以提供更好的移植性。但要注意新Java版本的依赖问题。</li>
</ul>
</li>
<li><strong>什么时候考虑 <code>@Inject</code></strong>？<ul>
<li>在现代SpringBoot项目中，几乎没有理由选择 <code>@Inject</code>。它的功能被 <code>@Autowired</code> 完全覆盖且更弱（没有 <code>required</code> 属性）。</li>
<li>它的设计初衷是编写可以脱离特定框架（如Spring, Guice）的、具有可移植性的库或组件。如果你在开发这样一个通用库，使用 <code>@Inject</code> 是一个不错的选择。但在开发应用程序时，坚持使用框架提供的原生工具通常更好。</li>
</ul>
</li>
</ol>
<p><strong>结论：</strong> 在实际的SpringBoot Web后端开发中，<strong>坚持使用 <code>@Autowired</code> 并配合构造器注入</strong>，这是最现代、最安全、最符合Spring设计理念的方式。</p>
<hr>
<h4 id="1-4-5-解决注入歧义-Primary-与-Qualifier"><a href="#1-4-5-解决注入歧义-Primary-与-Qualifier" class="headerlink" title="1.4.5 解决注入歧义(@Primary 与 @Qualifier)"></a>1.4.5 解决注入歧义(<code>@Primary</code> 与 <code>@Qualifier</code>)</h4><h5 id="1-问题场景：什么是注入歧义？"><a href="#1-问题场景：什么是注入歧义？" class="headerlink" title="1. 问题场景：什么是注入歧义？"></a>1. 问题场景：什么是注入歧义？</h5><p>假设我们有一个 <code>MessageService</code> 接口，以及两个不同的实现：一个通过邮件发送，一个通过短信发送。</p>
<p><strong>接口定义:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String recipient, String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两个实现:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;emailService&quot;)</span> <span class="comment">// 默认Bean name是 &quot;emailService&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String recipient, String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending EMAIL to &quot;</span> + recipient + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;smsService&quot;)</span> <span class="comment">// 默认Bean name是 &quot;smsService&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String recipient, String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending SMS to &quot;</span> + recipient + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，有一个 <code>NotificationManager</code> 需要使用 <code>MessageService</code>。如果我们像下面这样写，问题就出现了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题点!</span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// Spring: &quot;我找到了两个 MessageService (EmailService 和 SmsService)，我该用哪个?!&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Spring应用启动时，它会尝试为 <code>NotificationManager</code> 的构造函数注入一个 <code>MessageService</code>。但容器里有两个符合条件的Bean，Spring无法做出决定，于是会抛出 <code>NoUniqueBeanDefinitionException</code> 异常，导致应用启动失败。</p>
<p>下面我们来看两种解决这个问题的方案。</p>
<hr>
<h5 id="2-解决方案一-Primary-指定“首选”Bean"><a href="#2-解决方案一-Primary-指定“首选”Bean" class="headerlink" title="2. 解决方案一: @Primary - 指定“首选”Bean"></a>2. 解决方案一: <code>@Primary</code> - 指定“首选”Bean</h5><p><code>@Primary</code> 注解的作用是告诉Spring：“当出现多个相同类型的候选Bean时，请<strong>优先选择</strong>被 <code>@Primary</code> 标记的这一个。”</p>
<ul>
<li><strong>特点</strong>: 这是一种<strong>提供方驱动</strong>的策略。Bean的定义者（提供方）决定了谁是默认选项。</li>
</ul>
<p><strong>如何使用:</strong></p>
<p>我们只需要在首选的实现类上添加 <code>@Primary</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;emailService&quot;)</span></span><br><span class="line"><span class="meta">@Primary</span> <span class="comment">// &lt;-- 在这里添加注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;smsService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当 <code>NotificationManager</code> 请求注入 <code>MessageService</code> 时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// Spring: &quot;哦，有两个选择，但EmailService被标记为@Primary，就用它了！&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService; <span class="comment">// 这里注入的将是 EmailService 的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用可以正常启动，并且 <code>NotificationManager</code> 会默认使用 <code>EmailService</code>。</p>
<p><strong>适用场景</strong>:</p>
<p>当你有一个主要的、最常用的或默认的实现时，<code>@Primary</code> 是一个绝佳的选择。例如，系统中可能有多种支付方式，但“支付宝支付”是默认的首选方式。</p>
<hr>
<h5 id="3-解决方案二-Qualifier-指定“限定”Bean"><a href="#3-解决方案二-Qualifier-指定“限定”Bean" class="headerlink" title="3. 解决方案二: @Qualifier - 指定“限定”Bean"></a>3. 解决方案二: <code>@Qualifier</code> - 指定“限定”Bean</h5><p><code>@Qualifier</code> 注解的作用是告诉Spring：“我不要默认的，我<strong>明确地需要</strong>名为 <code>xxx</code> 的那一个Bean。”</p>
<ul>
<li><strong>特点</strong>: 这是一种<strong>消费方驱动</strong>的策略。依赖的注入点（消费方）明确指定它需要哪个具体的实现。</li>
</ul>
<p><strong>如何使用:</strong></p>
<p>在使用 <code>@Autowired</code> 的地方，同时使用 <code>@Qualifier</code> 注解，并传入你想要的Bean的名称（Bean Name）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个实现保持原样，不需要修改</span></span><br><span class="line"><span class="meta">@Service(&quot;emailService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;smsService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>现在，假设我们有两个不同的通知管理器，一个用于常规通知（用邮件），一个用于紧急通知（用短信）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegularNotificationManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确要求注入名为 &quot;emailService&quot; 的Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegularNotificationManager</span><span class="params">(<span class="meta">@Qualifier(&quot;emailService&quot;)</span> MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrgentNotificationManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确要求注入名为 &quot;smsService&quot; 的Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UrgentNotificationManager</span><span class="params">(<span class="meta">@Qualifier(&quot;smsService&quot;)</span> MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，每个消费者都可以根据自己的需求，精确地选择想要的实现，完全不受默认设置的影响。</p>
<p><strong>适用场景</strong>:</p>
<p>当选择哪个实现本身就是一种业务逻辑，不同的消费者需要不同的实现时，<code>@Qualifier</code> 是唯一的正确选择。它提供了更高的灵活性和精确性。</p>
<hr>
<h5 id="4-Primary-vs-Qualifier-总结与最佳实践"><a href="#4-Primary-vs-Qualifier-总结与最佳实践" class="headerlink" title="4. @Primary vs. @Qualifier - 总结与最佳实践"></a>4. <code>@Primary</code> vs. <code>@Qualifier</code> - 总结与最佳实践</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Primary</code></th>
<th align="left"><code>@Qualifier</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>决定方</strong></td>
<td align="left"><strong>Bean的提供者 (Provider-side)</strong></td>
<td align="left"><strong>Bean的消费者 (Consumer-side)</strong></td>
</tr>
<tr>
<td align="left"><strong>作用</strong></td>
<td align="left">设置一个全局的<strong>默认</strong>选项</td>
<td align="left">在注入点进行<strong>精确</strong>的选择</td>
</tr>
<tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">较低（一个类型只能有一个<code>@Primary</code>）</td>
<td align="left"><strong>非常高</strong>（每个注入点都可以独立选择）</td>
</tr>
<tr>
<td align="left"><strong>代码位置</strong></td>
<td align="left">标记在Bean的实现类上</td>
<td align="left">标记在注入点 (<code>@Autowired</code>旁边)</td>
</tr>
</tbody></table>
<p><strong>黄金法则：<code>@Qualifier</code> 的优先级高于 <code>@Primary</code>。</strong></p>
<p>这意味着，即使 <code>EmailService</code> 被标记为 <code>@Primary</code>，如果一个消费者使用 <code>@Qualifier(&quot;smsService&quot;)</code>，它仍然会得到 <code>SmsService</code>。<strong>精确指定永远胜过默认设置。</strong></p>
<p><strong>最佳实践建议：</strong></p>
<ol>
<li><strong>问自己一个问题</strong>：“在我的系统中，这个接口的实现是否有一个‘标准’或‘最常用’的版本？”<ul>
<li><strong>如果答案是肯定的</strong>，那么给那个实现加上 <code>@Primary</code>。这可以让80%的普通用例保持代码简洁，无需任何额外注解。</li>
<li><strong>如果答案是否定的</strong>，或者所有实现都同等重要，那么<strong>不要使用 <code>@Primary</code></strong>。强制每个消费者都使用 <code>@Qualifier</code> 来明确做出选择，这样可以避免错误的默认行为。</li>
</ul>
</li>
<li><strong>组合使用</strong>：将两者结合是最佳实践。<ul>
<li>为最常见的实现设置 <code>@Primary</code>。</li>
<li>对于那些需要特定非默认实现的特殊消费者，使用 <code>@Qualifier</code> 进行覆盖。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-5-Bean的生命周期与作用域"><a href="#1-5-Bean的生命周期与作用域" class="headerlink" title="1.5  Bean的生命周期与作用域"></a>1.5  Bean的生命周期与作用域</h3><h4 id="1-5-1-Bean的完整生命周期"><a href="#1-5-1-Bean的完整生命周期" class="headerlink" title="1.5.1 Bean的完整生命周期"></a>1.5.1 Bean的完整生命周期</h4><p>Bean的生命周期是指一个Bean从被Spring容器创建（实例化），到最终被销毁的整个过程。我们可以将其划分为四个主要阶段：<strong>实例化、属性填充、初始化、销毁</strong>。其中，“初始化”阶段本身又包含了一系列复杂的步骤。</p>
<h5 id="1-整体流程图（简化版）"><a href="#1-整体流程图（简化版）" class="headerlink" title="1. 整体流程图（简化版）"></a>1. 整体流程图（简化版）</h5><pre><code class="highlight mermaid">graph TD
    %% --- 流程起点 ---
    A&#123;&quot;&lt;b&gt;1. 容器启动&lt;/b&gt;&lt;br/&gt;寻找Bean的定义信息&lt;br/&gt;(BeanDefinition)&quot;&#125; --&gt; B

    %% --- 创建阶段 ---
    subgraph &quot;Bean创建阶段 (Creation Phase)&quot;
        direction TB
        B[&quot;&lt;b&gt;2. 【实例化】&lt;/b&gt;&lt;br/&gt;通过反射创建Bean的原始实例&lt;br/&gt;&lt;i&gt;(一个&#x27;裸&#x27;对象)&lt;/i&gt;&quot;] --&gt; C
        C[&quot;&lt;b&gt;3. 【属性填充】&lt;/b&gt;&lt;br/&gt;为Bean实例注入依赖 (DI)&lt;br/&gt;&lt;i&gt;如 @Autowired 标记的属性&lt;/i&gt;&quot;] --&gt; D
        
        D[&quot;&lt;b&gt;4. 【初始化】&lt;/b&gt;&lt;br/&gt;(执行一系列回调)&quot;]--&gt; D_sub
        
        subgraph D_sub[&quot;初始化子流程 (Initialization Sub-flow)&quot;]
            direction TB
            D1[&quot;4.1 执行Aware接口的方法&lt;br/&gt;&lt;i&gt;(如BeanNameAware)&lt;/i&gt;&quot;]
            D2[&quot;4.2 执行BeanPostProcessor&lt;br/&gt;&lt;b&gt;前置&lt;/b&gt;处理方法&quot;]
            D3[&quot;4.3 执行Bean自身的初始化方法&lt;br/&gt;&lt;i&gt;(@PostConstruct, afterPropertiesSet)&lt;/i&gt;&quot;]
            D4[&quot;4.4 执行BeanPostProcessor&lt;br/&gt;&lt;b&gt;后置&lt;/b&gt;处理方法 (AOP代理在此发生)&quot;]
            
            D1 --&gt; D2 --&gt; D3 --&gt; D4
        end
        D_sub --&gt; E
    end

    %% --- 使用阶段 ---
    E(&lt;b&gt;5. Bean可用&lt;/b&gt;&lt;br/&gt;驻留在单例池中&lt;br/&gt;响应应用程序的调用) --&gt; F

    %% --- 销毁阶段 ---
    F&#123;&lt;b&gt;6. Spring容器关闭&lt;/b&gt;&#125; --&gt; G
    
    subgraph &quot;Bean销毁阶段 (Destruction Phase)&quot;
        direction TB
        G[&quot;&lt;b&gt;7. 【销毁】&lt;/b&gt;&lt;br/&gt;执行Bean的销毁回调方法&lt;br/&gt;&lt;i&gt;(如@PreDestroy, destroy-method)&lt;/i&gt;&quot;] --&gt; H
        H[&quot;&lt;b&gt;8. Bean被垃圾回收&lt;/b&gt;&lt;br/&gt;(由JVM管理)&quot;]
    end

    %% --- 样式定义 ---
    style A fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style F fill:#ffcdd2,stroke:#c62828,stroke-width:2px
    style B fill:#e3f2fd,stroke:#1565c0
    style C fill:#e3f2fd,stroke:#1565c0
    style D fill:#e3f2fd,stroke:#1565c0
    style E fill:#a5d6a7,stroke:#2e7d32,stroke-width:4px,stroke-dasharray: 5 5
    style G fill:#ffe0b2,stroke:#ef6c00
    style H fill:#ffe0b2,stroke:#ef6c00</code></pre>



<hr>
<h5 id="2-详细步骤分解"><a href="#2-详细步骤分解" class="headerlink" title="2. 详细步骤分解"></a>2. 详细步骤分解</h5><p>下面我们用一个贯穿始终的例子 <code>MyBean</code> 来详细拆解每一步。</p>
<h6 id="阶段一：实例化-Instantiation"><a href="#阶段一：实例化-Instantiation" class="headerlink" title="阶段一：实例化 (Instantiation)"></a>阶段一：实例化 (Instantiation)</h6><ol>
<li><strong>容器查找BeanDefinition</strong>：Spring容器从配置源（如 <code>@Component</code> 扫描、<code>@Configuration</code> 类）中读取到<code>MyBean</code>的定义信息，即<code>BeanDefinition</code>。这就像是创建Bean的“蓝图”。</li>
<li><strong>创建实例</strong>：容器通过Java反射调用<code>MyBean</code>的构造函数，创建一个<strong>原始的对象实例</strong>。<ul>
<li><strong>此时</strong>：对象刚刚被创建，内存已经分配，但其所有依赖项（如被<code>@Autowired</code>标记的字段）都还是<code>null</code>。它只是一个“空的”外壳。</li>
</ul>
</li>
</ol>
<h6 id="阶段二：属性填充-Population"><a href="#阶段二：属性填充-Population" class="headerlink" title="阶段二：属性填充 (Population)"></a>阶段二：属性填充 (Population)</h6><ol>
<li><strong>依赖注入 (DI)</strong>：Spring容器检查<code>MyBean</code>中需要注入的依赖（通过<code>@Autowired</code>, <code>@Resource</code>等注解）。它会从容器中找到这些依赖的Bean，并通过反射（字段注入）或调用setter方法（Setter注入）将它们设置到<code>MyBean</code>的实例中。<ul>
<li><strong>此时</strong>：<code>MyBean</code>的依赖字段已经被赋值，但这个Bean可能还需要执行一些自定义的初始化逻辑后才能真正投入使用。</li>
</ul>
</li>
</ol>
<h6 id="阶段三：初始化-Initialization-这是最复杂也最重要的阶段"><a href="#阶段三：初始化-Initialization-这是最复杂也最重要的阶段" class="headerlink" title="阶段三：初始化 (Initialization) - 这是最复杂也最重要的阶段"></a>阶段三：初始化 (Initialization) - 这是最复杂也最重要的阶段</h6><p>这个阶段提供了一系列回调钩子，让你可以在Bean完全可用之前执行自定义逻辑。<strong>以下步骤严格按顺序执行</strong>。</p>
<ol>
<li><strong>调用Aware接口的方法</strong>：如果<code>MyBean</code>实现了特定的<code>Aware</code>接口，Spring会调用它们。这些接口的目的是让Bean能“感知”到并获取到容器自身的资源。<ul>
<li><code>BeanNameAware</code> -&gt; <code>setBeanName()</code>: Bean可以获取到它在容器中的ID&#x2F;name。</li>
<li><code>BeanClassLoaderAware</code> -&gt; <code>setBeanClassLoader()</code>: Bean可以获取到加载它的类加载器。</li>
<li><code>BeanFactoryAware</code> -&gt; <code>setBeanFactory()</code>: <strong>最强大的<code>Aware</code>接口</strong>，Bean可以获取到创建它的<code>BeanFactory</code>，从而能够以编程方式与容器交互。</li>
</ul>
</li>
<li><strong><code>BeanPostProcessor</code>前置处理</strong>：Spring会遍历容器中所有的<code>BeanPostProcessor</code>实现，并调用它们的 <code>postProcessBeforeInitialization()</code> 方法。<ul>
<li>这是一个<strong>全局的</strong>、<strong>容器级别</strong>的钩子。它允许你在<strong>任何Bean</strong>的自定义初始化方法执行<strong>之前</strong>，对这个Bean实例进行修改或包装。</li>
<li>例如，Spring的很多AOP功能和代理对象的创建就是在这个阶段附近完成的。</li>
</ul>
</li>
<li><strong>执行Bean自身的初始化方法</strong>：这是我们最常用来编写自定义初始化逻辑的地方。Spring会按照以下顺序检查并执行：<ul>
<li><strong>① <code>@PostConstruct</code> 注解的方法</strong>：这是JSR-250规范定义的注解，是<strong>现代Spring应用中的首选</strong>，因为它与框架解耦。</li>
<li><strong>② <code>InitializingBean</code>接口的<code>afterPropertiesSet()</code>方法</strong>：这是Spring框架自己的接口。如果<code>MyBean</code>实现了这个接口，该方法会被调用。</li>
<li><strong>③ 自定义的<code>init-method</code></strong>：如果你在<code>@Bean(initMethod = &quot;customInit&quot;)</code>中指定了初始化方法，该方法会被调用。</li>
</ul>
</li>
<li><strong><code>BeanPostProcessor</code>后置处理</strong>：Spring再次遍历容器中所有的<code>BeanPostProcessor</code>，并调用它们的 <code>postProcessAfterInitialization()</code> 方法。<ul>
<li>这也是一个全局钩子。它允许你在Bean完成所有初始化之后，再次对其进行处理。</li>
<li><strong>Spring的AOP代理（例如为<code>@Transactional</code>方法创建代理）主要就是在这里完成的</strong>。<code>postProcessAfterInitialization</code>会返回一个Bean实例，这个返回的实例可能是原始Bean，也可能是一个被代理包装过的对象。<strong>最终放入单例池并供后续使用的是这个返回的对象</strong>。</li>
</ul>
</li>
</ol>
<h6 id="阶段四：Bean可用-In-Use"><a href="#阶段四：Bean可用-In-Use" class="headerlink" title="阶段四：Bean可用 (In Use)"></a>阶段四：Bean可用 (In Use)</h6><ol>
<li><strong>完成初始化</strong>：经过了上述所有初始化步骤后，Bean被认为是完全准备就绪的。</li>
<li><strong>放入单例池</strong>：Spring将这个最终处理完成的Bean实例放入单例缓存池（Singleton Cache）中。</li>
<li><strong>提供使用</strong>：当其他Bean需要注入这个<code>MyBean</code>时，Spring会直接从单例池中获取并提供给它们。Bean现在开始处理业务逻辑，进入其生命周期中最长的阶段。</li>
</ol>
<h6 id="阶段五：销毁-Destruction"><a href="#阶段五：销毁-Destruction" class="headerlink" title="阶段五：销毁 (Destruction)"></a>阶段五：销毁 (Destruction)</h6><p>这个阶段只在容器关闭时发生，并且<strong>只对<code>singleton</code>作用域的Bean有效</strong>。对于<code>prototype</code>作用域的Bean，容器创建后就不再管理其生命周期。</p>
<ol>
<li><strong>容器关闭</strong>：当<code>ApplicationContext</code>被关闭时（例如应用正常停止），Spring会触发Bean的销毁流程。</li>
<li><strong>执行Bean自身的销毁方法</strong>：与初始化类似，Spring会按照以下顺序检查并执行销毁回调：<ul>
<li><strong>① <code>@PreDestroy</code> 注解的方法</strong>：JSR-250规范，<strong>首选的销毁回调方式</strong>。</li>
<li><strong>② <code>DisposableBean</code>接口的<code>destroy()</code>方法</strong>：Spring框架自己的接口。</li>
<li><strong>③ 自定义的<code>destroy-method</code></strong>：在<code>@Bean(destroyMethod = &quot;customDestroy&quot;)</code>中指定的方法。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-综合代码示例"><a href="#3-综合代码示例" class="headerlink" title="3. 综合代码示例"></a>3. 综合代码示例</h5><p>创建一个Bean，它经历了生命周期中的所有关键点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycleDemoBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycleDemoBean</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1. 【实例化】执行构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是需要注入的依赖</span></span><br><span class="line">    <span class="comment">// Spring会在这里进行【属性填充】</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postConstruct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3. 【初始化】执行 @PostConstruct 注解的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4. 【初始化】执行 InitializingBean 的 afterPropertiesSet 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customInitMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5. 【初始化】执行自定义的 init-method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanPostProcessor 的 before/after 方法会穿插在2和6之间</span></span><br><span class="line">    <span class="comment">// ... Bean is now in use ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;7. 【销毁】执行 @PreDestroy 注解的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;8. 【销毁】执行 DisposableBean 的 destroy 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customDestroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;9. 【销毁】执行自定义的 destroy-method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>(为了演示<code>init-method</code>，你需要在<code>@Configuration</code>类中使用<code>@Bean</code>来定义它)</em></p>
<p><strong>总结与最佳实践：</strong></p>
<ul>
<li><strong>初始化</strong>：<strong>优先使用 <code>@PostConstruct</code></strong>。它代码侵入性小，是Java标准，更优雅。</li>
<li><strong>销毁</strong>：<strong>优先使用 <code>@PreDestroy</code></strong>。</li>
<li><strong>Aware接口</strong>：除非你真的需要与Spring容器底层进行交互，否则尽量避免使用，以保持业务代码的纯净。</li>
<li><strong><code>BeanPostProcessor</code></strong>：这是一个非常强大的高级工具，主要用于框架级别的开发，用来对一批Bean进行统一的增强处理，普通业务开发很少直接实现它。</li>
</ul>
<hr>
<h4 id="1-5-2-BeanPostProcessor-与-BeanFactoryPostProcessor"><a href="#1-5-2-BeanPostProcessor-与-BeanFactoryPostProcessor" class="headerlink" title="1.5.2 BeanPostProcessor 与 BeanFactoryPostProcessor"></a>1.5.2 <code>BeanPostProcessor</code> 与 <code>BeanFactoryPostProcessor</code></h4><h5 id="1-核心区别一览"><a href="#1-核心区别一览" class="headerlink" title="1. 核心区别一览"></a>1. 核心区别一览</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>BeanFactoryPostProcessor</code> (工厂后处理器)</th>
<th align="left"><code>BeanPostProcessor</code> (Bean后处理器)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>操作对象</strong></td>
<td align="left"><strong><code>BeanDefinition</code></strong> (Bean的定义&#x2F;蓝图)</td>
<td align="left"><strong>Bean 实例</strong> (已经<code>new</code>出来的对象)</td>
</tr>
<tr>
<td align="left"><strong>执行时机</strong></td>
<td align="left"><strong>非常早</strong>。在所有<code>BeanDefinition</code>加载完成之后，<strong>但在任何Bean实例化之前</strong>。</td>
<td align="left"><strong>较晚</strong>。在每个Bean<strong>实例化和依赖注入之后</strong>，但在其初始化方法前后。</td>
</tr>
<tr>
<td align="left"><strong>作用范围</strong></td>
<td align="left"><strong>容器级别</strong>。一次性对整个<code>BeanFactory</code>的配置元数据进行修改。</td>
<td align="left"><strong>Bean级别</strong>。对容器中<strong>每一个</strong>符合条件的Bean实例进行单独处理。</td>
</tr>
<tr>
<td align="left"><strong>核心目的</strong></td>
<td align="left">修改或增强Bean的<strong>定义信息</strong>。比如，修改Bean的作用域、替换Bean的类、添加属性等。</td>
<td align="left">修改或增强Bean的<strong>实例本身</strong>。比如，为Bean实例创建一个代理对象(AOP)、修改实例的属性值等。</td>
</tr>
<tr>
<td align="left"><strong>关键方法</strong></td>
<td align="left"><code>postProcessBeanFactory(ConfigurableListableBeanFactory factory)</code></td>
<td align="left"><code>postProcessBeforeInitialization(Object bean, String beanName)</code><br><code>postProcessAfterInitialization(Object bean, String beanName)</code></td>
</tr>
</tbody></table>
<hr>
<h5 id="2-深入解析-BeanFactoryPostProcessor"><a href="#2-深入解析-BeanFactoryPostProcessor" class="headerlink" title="2. 深入解析 BeanFactoryPostProcessor"></a>2. 深入解析 <code>BeanFactoryPostProcessor</code></h5><h6 id="a-它是做什么的？"><a href="#a-它是做什么的？" class="headerlink" title="a). 它是做什么的？"></a>a). 它是做什么的？</h6><p>它允许你在Spring容器读取了所有的Bean定义信息（<code>BeanDefinition</code>）之后，但在容器根据这些定义去实例化任何Bean之前，对这些定义信息进行修改。</p>
<h6 id="b-它是怎么工作的？"><a href="#b-它是怎么工作的？" class="headerlink" title="b). 它是怎么工作的？"></a>b). 它是怎么工作的？</h6><ol>
<li>Spring容器启动，扫描并加载所有的配置（XML, <code>@Configuration</code>等）。</li>
<li>容器将这些配置信息解析成一个个的<code>BeanDefinition</code>对象，并把它们注册到一个<code>BeanDefinitionRegistry</code>中。</li>
<li>此时，容器会查找并执行所有实现了<code>BeanFactoryPostProcessor</code>接口的Bean。</li>
<li>在<code>postProcessBeanFactory</code>方法中，你可以通过传入的<code>ConfigurableListableBeanFactory</code>参数，获取到所有的<code>BeanDefinition</code>，然后对它们进行修改。</li>
</ol>
<h6 id="c-实际的Spring内部用例"><a href="#c-实际的Spring内部用例" class="headerlink" title="c). 实际的Spring内部用例"></a>c). 实际的Spring内部用例</h6><ul>
<li><strong>属性占位符替换</strong>：<code>PropertySourcesPlaceholderConfigurer</code>就是一个<code>BeanFactoryPostProcessor</code>。它的作用就是在Bean实例化之前，扫描所有<code>BeanDefinition</code>，找到像 <code>${db.url}</code> 这样的占位符，并用配置文件中的实际值去替换它们。</li>
<li><strong><code>@Configuration</code>类的处理</strong>：Spring通过一个内部的<code>ConfigurationClassPostProcessor</code>来处理<code>@Configuration</code>注解的类，解析其中的<code>@Bean</code>, <code>@ComponentScan</code>, <code>@Import</code>等注解，并注册更多的<code>BeanDefinition</code>到容器中。</li>
</ul>
<h6 id="d-自定义示例"><a href="#d-自定义示例" class="headerlink" title="d). 自定义示例"></a>d). 自定义示例</h6><p>假设你想把容器中所有<code>UserRepository</code>的Bean都强制改为<code>prototype</code>作用域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing BeanFactoryPostProcessor...&quot;</span>);</span><br><span class="line">        String[] beanNames = beanFactory.getBeanNamesForType(UserRepository.class);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> beanFactory.getBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">// 修改Bean的定义信息：将作用域改为prototype</span></span><br><span class="line">            definition.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-深入解析-BeanPostProcessor"><a href="#3-深入解析-BeanPostProcessor" class="headerlink" title="3. 深入解析 BeanPostProcessor"></a>3. 深入解析 <code>BeanPostProcessor</code></h5><h6 id="a-它是做什么的？-1"><a href="#a-它是做什么的？-1" class="headerlink" title="a). 它是做什么的？"></a>a). 它是做什么的？</h6><p>它允许你在Spring容器实例化、配置和初始化一个Bean之后，以及在它的自定义初始化回调（如<code>@PostConstruct</code>）之前和之后，添加你自己的处理逻辑。</p>
<h6 id="b-它是怎么工作的？-1"><a href="#b-它是怎么工作的？-1" class="headerlink" title="b). 它是怎么工作的？"></a>b). 它是怎么工作的？</h6><p>对于容器中<strong>每一个</strong>正在被创建的Bean，它的初始化过程都会经过容器中<strong>所有</strong><code>BeanPostProcessor</code>的“加工”。</p>
<ul>
<li><code>postProcessBeforeInitialization</code>: 在Bean的<code>@PostConstruct</code>或<code>init-method</code>执行<strong>前</strong>调用。</li>
<li><code>postProcessAfterInitialization</code>: 在Bean的<code>@PostConstruct</code>或<code>init-method</code>执行<strong>后</strong>调用。<strong>这个方法返回的对象将是最终被使用的Bean实例</strong>，它可能是一个代理。</li>
</ul>
<h6 id="c-实际的Spring内部用例-1"><a href="#c-实际的Spring内部用例-1" class="headerlink" title="c). 实际的Spring内部用例"></a>c). 实际的Spring内部用例</h6><ul>
<li><strong>AOP代理创建</strong>：<code>AnnotationAwareAspectJAutoProxyCreator</code>就是一个关键的<code>BeanPostProcessor</code>。在<code>postProcessAfterInitialization</code>阶段，它会检查Bean的类或方法上是否有切面注解（如<code>@Transactional</code>）。如果有，它不会返回原始的Bean实例，而是返回一个围绕原始Bean创建的<strong>代理对象</strong>。这就是为什么AOP能够生效。</li>
<li><strong><code>@Autowired</code>等注解的处理</strong>：<code>AutowiredAnnotationBeanPostProcessor</code>负责处理<code>@Autowired</code>注解，完成属性填充。</li>
<li><strong><code>@PostConstruct</code>和<code>@PreDestroy</code>的处理</strong>：<code>CommonAnnotationBeanPostProcessor</code>负责识别和执行这两个注解标记的方法。</li>
</ul>
<h6 id="d-自定义示例-1"><a href="#d-自定义示例-1" class="headerlink" title="d). 自定义示例"></a>d). 自定义示例</h6><p>假设你想在每个Bean初始化后打印它的类名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 在初始化前不做任何事，直接返回原始bean</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; of type [&quot;</span> + bean.getClass().getName() + <span class="string">&quot;] has been initialized.&quot;</span>);</span><br><span class="line">        <span class="comment">// 在初始化后，返回处理过的bean（这里我们没处理，直接返回）</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a>4. 总结</h5><ul>
<li>如果你想干预<strong>Bean的创建过程</strong>，对<strong>Bean实例本身</strong>进行操作（例如创建代理），请使用 <code>BeanPostProcessor</code>。</li>
<li>如果你想干预<strong>Spring容器的启动过程</strong>，对<strong>Bean的配置元数据</strong>（即<code>BeanDefinition</code>）进行操作，请使用 <code>BeanFactoryPostProcessor</code>。</li>
</ul>
<p>在日常业务开发中，你几乎不会去实现这两个接口。它们是典型的“框架级”扩展点，主要用于Spring自身或第三方库的开发者，用来实现一些底层的、通用的功能。但理解它们，是真正掌握Spring IoC容器工作原理的钥匙。</p>
<hr>
<h4 id="1-5-3-初始化与销毁回调"><a href="#1-5-3-初始化与销毁回调" class="headerlink" title="1.5.3 初始化与销毁回调"></a>1.5.3 初始化与销毁回调</h4><h5 id="1-为什么需要这些回调？"><a href="#1-为什么需要这些回调？" class="headerlink" title="1. 为什么需要这些回调？"></a>1. 为什么需要这些回调？</h5><p>一个Bean在被创建并注入所有依赖后，往往还不能立即投入使用。它可能需要：</p>
<ul>
<li><strong>初始化资源</strong>：建立数据库连接、打开网络套接字、加载缓存数据。</li>
<li><strong>预处理数据</strong>：对某些配置属性进行计算或验证。</li>
<li><strong>启动后台任务</strong>：启动一个定时器或一个后台线程。</li>
</ul>
<p>同样，当应用程序关闭，Bean被销毁时，它需要一个机会来：</p>
<ul>
<li><strong>释放资源</strong>：关闭数据库连接、断开网络连接、将缓存数据写回磁盘。</li>
<li><strong>优雅地停止</strong>：通知后台线程停止工作，等待其完成。</li>
</ul>
<p>Spring提供了三种主要的方式来实现这些初始化和销毁逻辑。</p>
<hr>
<h5 id="2-初始化回调-Initialization-Callbacks"><a href="#2-初始化回调-Initialization-Callbacks" class="headerlink" title="2. 初始化回调 (Initialization Callbacks)"></a>2. 初始化回调 (Initialization Callbacks)</h5><p>初始化回调发生在Bean的<strong>实例化</strong>和<strong>属性填充</strong>完成之后。Spring确保在调用这些方法时，所有的依赖都已经注入完毕。</p>
<h6 id="a-使用-JSR-250-的-PostConstruct-注解-官方推荐"><a href="#a-使用-JSR-250-的-PostConstruct-注解-官方推荐" class="headerlink" title="a). 使用 JSR-250 的 @PostConstruct 注解 (官方推荐)"></a>a). 使用 JSR-250 的 <code>@PostConstruct</code> 注解 (官方推荐)</h6><ul>
<li><strong>来源</strong>：Java EE 的标准规范 (JSR-250)。</li>
<li><strong>方式</strong>：在一个无参数、返回值为 <code>void</code> 的 <code>public</code> 方法上添加此注解。</li>
<li><strong>优点</strong>：<ul>
<li><strong>标准规范</strong>：与Spring框架解耦，代码更具可移植性。</li>
<li><strong>非侵入式</strong>：不需要实现任何接口，代码更简洁。</li>
</ul>
</li>
<li><strong>缺点</strong>：无明显缺点，是现代Spring应用的首选。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConnector</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Database connection established.&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行连接数据库、加载初始数据等逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeQuery</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing: &quot;</span> + query);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="b-实现-InitializingBean-接口"><a href="#b-实现-InitializingBean-接口" class="headerlink" title="b). 实现 InitializingBean 接口"></a>b). 实现 <code>InitializingBean</code> 接口</h6><ul>
<li><strong>来源</strong>：Spring框架自身的接口。</li>
<li><strong>方式</strong>：让Bean类实现 <code>InitializingBean</code> 接口，并重写 <code>afterPropertiesSet()</code> 方法。</li>
<li><strong>优点</strong>：意图非常明确，实现了接口就代表有初始化逻辑。</li>
<li><strong>缺点</strong>：<ul>
<li><strong>与Spring框架强耦合</strong>：你的业务代码中引入了Spring的API (<code>org.springframework.beans.factory.InitializingBean</code>)，降低了代码的可移植性。</li>
</ul>
</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheManager</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cache is being populated...&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行加载缓存的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="c-使用-Bean-的-initMethod-属性"><a href="#c-使用-Bean-的-initMethod-属性" class="headerlink" title="c). 使用 @Bean 的 initMethod 属性"></a>c). 使用 <code>@Bean</code> 的 <code>initMethod</code> 属性</h6><ul>
<li><strong>来源</strong>：源自XML配置时代的 <code>&lt;bean init-method=&quot;...&quot;&gt;</code>，现在适用于Java Config。</li>
<li><strong>方式</strong>：在 <code>@Configuration</code> 类的 <code>@Bean</code> 注解中，指定一个方法名作为初始化方法。</li>
<li><strong>优点</strong>：<ul>
<li><strong>对于第三方库的Bean非常有用</strong>：当你使用的类来自一个你无法修改源码的jar包时，这是唯一可以为其指定初始化逻辑的方式。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>初始化逻辑与Bean的定义分离，不够直观。</li>
<li>使用“魔术字符串”（方法名），没有编译时检查，容易写错。</li>
</ul>
</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这是第三方库的类，我们无法修改它</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThirdPartyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Third party client is starting up.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;startup&quot;)</span> <span class="comment">// &lt;-- 指定初始化方法</span></span><br><span class="line">    <span class="keyword">public</span> ThirdPartyClient <span class="title function_">thirdPartyClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThirdPartyClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-销毁回调-Destruction-Callbacks"><a href="#3-销毁回调-Destruction-Callbacks" class="headerlink" title="3. 销毁回调 (Destruction Callbacks)"></a>3. 销毁回调 (Destruction Callbacks)</h5><p>销毁回调在Spring容器关闭时被触发。<strong>注意：这只对 <code>singleton</code> 作用域的Bean有效</strong>。对于<code>prototype</code>作用域的Bean，Spring创建后就不再负责其销毁。</p>
<h6 id="a-使用-JSR-250-的-PreDestroy-注解-官方推荐"><a href="#a-使用-JSR-250-的-PreDestroy-注解-官方推荐" class="headerlink" title="a). 使用 JSR-250 的 @PreDestroy 注解 (官方推荐)"></a>a). 使用 JSR-250 的 <code>@PreDestroy</code> 注解 (官方推荐)</h6><ul>
<li><strong>来源</strong>：Java EE 的标准规范 (JSR-250)。</li>
<li><strong>方式</strong>：在一个无参数、返回值为 <code>void</code> 的 <code>public</code> 方法上添加此注解。</li>
<li><strong>优点</strong>：与 <code>@PostConstruct</code> 一样，标准、解耦、简洁。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续写上面的 DatabaseConnector</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConnector</span> &#123;</span><br><span class="line">    <span class="comment">// ... @PostConstruct ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Database connection is being closed.&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行关闭连接、释放资源的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="b-实现-DisposableBean-接口"><a href="#b-实现-DisposableBean-接口" class="headerlink" title="b). 实现 DisposableBean 接口"></a>b). 实现 <code>DisposableBean</code> 接口</h6><ul>
<li><strong>来源</strong>：Spring框架自身的接口。</li>
<li><strong>方式</strong>：让Bean类实现 <code>DisposableBean</code> 接口，并重写 <code>destroy()</code> 方法。</li>
<li><strong>缺点</strong>：与 <code>InitializingBean</code> 一样，会与Spring框架强耦合。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续写上面的 CacheManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheManager</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line">    <span class="comment">// ... afterPropertiesSet ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cache is being cleared and written to disk...&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行清理缓存、持久化数据的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="c-使用-Bean-的-destroyMethod-属性"><a href="#c-使用-Bean-的-destroyMethod-属性" class="headerlink" title="c). 使用 @Bean 的 destroyMethod 属性"></a>c). 使用 <code>@Bean</code> 的 <code>destroyMethod</code> 属性</h6><ul>
<li><strong>来源</strong>：XML配置时代的 <code>&lt;bean destroy-method=&quot;...&quot;&gt;</code>。</li>
<li><strong>方式</strong>：在 <code>@Bean</code> 注解中指定销毁方法名。</li>
<li><strong>优点</strong>：同样，是为无法修改源码的第三方Bean指定清理逻辑的最佳方式。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续写上面的 ThirdPartyClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThirdPartyClient</span> &#123;</span><br><span class="line">    <span class="comment">// ... startup ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Third party client is shutting down.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;startup&quot;, destroyMethod = &quot;shutdown&quot;)</span> <span class="comment">// &lt;-- 指定销毁方法</span></span><br><span class="line">    <span class="keyword">public</span> ThirdPartyClient <span class="title function_">thirdPartyClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThirdPartyClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>对于<code>close</code>或<code>shutdown</code>等常见方法名，Spring可以自动推断，甚至无需显式指定<code>destroyMethod</code>。</em></p>
<hr>
<h5 id="4-执行顺序"><a href="#4-执行顺序" class="headerlink" title="4. 执行顺序"></a>4. 执行顺序</h5><p>如果一个Bean同时使用了多种回调方式，Spring会按照固定的顺序执行它们：</p>
<ul>
<li><strong>初始化顺序</strong>:<ol>
<li><code>@PostConstruct</code> 注解的方法</li>
<li><code>InitializingBean</code> 的 <code>afterPropertiesSet()</code> 方法</li>
<li>自定义的 <code>init-method</code></li>
</ol>
</li>
<li><strong>销毁顺序</strong>:<ol>
<li><code>@PreDestroy</code> 注解的方法</li>
<li><code>DisposableBean</code> 的 <code>destroy()</code> 方法</li>
<li>自定义的 <code>destroy-method</code></li>
</ol>
</li>
</ul>
<hr>
<h5 id="5-总结与最佳实践"><a href="#5-总结与最佳实践" class="headerlink" title="5. 总结与最佳实践"></a>5. 总结与最佳实践</h5><table>
<thead>
<tr>
<th align="left">回调类型</th>
<th align="left">方式</th>
<th align="left">推荐度</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>初始化</strong></td>
<td align="left"><strong><code>@PostConstruct</code></strong></td>
<td align="left">⭐⭐⭐⭐⭐ <strong>(首选)</strong></td>
<td align="left">所有自定义Bean的初始化逻辑。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>InitializingBean</code></td>
<td align="left">⭐⭐</td>
<td align="left">遗留代码或特定框架集成。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>initMethod</code></td>
<td align="left">⭐⭐⭐</td>
<td align="left"><strong>为无法修改源码的第三方Bean配置初始化</strong>。</td>
</tr>
<tr>
<td align="left"><strong>销毁</strong></td>
<td align="left"><strong><code>@PreDestroy</code></strong></td>
<td align="left">⭐⭐⭐⭐⭐ <strong>(首选)</strong></td>
<td align="left">所有自定义Bean的销毁逻辑。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>DisposableBean</code></td>
<td align="left">⭐⭐</td>
<td align="left">遗留代码。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>destroyMethod</code></td>
<td align="left">⭐⭐⭐</td>
<td align="left"><strong>为无法修改源码的第三方Bean配置销毁</strong>。</td>
</tr>
</tbody></table>
<p><strong>核心建议</strong>：在日常开发中，<strong>始终坚持使用 <code>@PostConstruct</code> 和 <code>@PreDestroy</code></strong>。它们是现代、标准、非侵入式的方式，能让你的代码更干净、更专业。只有在需要管理第三方库中对象的生命周期时，才去使用 <code>@Bean</code> 的 <code>initMethod</code> 和 <code>destroyMethod</code> 属性。</p>
<hr>
<h4 id="1-5-4-Bean的作用域"><a href="#1-5-4-Bean的作用域" class="headerlink" title="1.5.4 Bean的作用域"></a>1.5.4 Bean的作用域</h4><h5 id="1-什么是Bean的作用域？"><a href="#1-什么是Bean的作用域？" class="headerlink" title="1. 什么是Bean的作用域？"></a>1. 什么是Bean的作用域？</h5><p>Bean的作用域定义了<strong>从一个Bean定义（Bean Definition）创建多少个实例</strong>，以及这些<strong>实例的生命周期和可见范围</strong>。</p>
<p>在SpringBoot中，可以使用 <code>@Scope</code> 注解来为一个Bean指定其作用域。</p>
<hr>
<h5 id="2-Spring的核心作用域"><a href="#2-Spring的核心作用域" class="headerlink" title="2. Spring的核心作用域"></a>2. Spring的核心作用域</h5><h6 id="a-singleton-单例-默认作用域"><a href="#a-singleton-单例-默认作用域" class="headerlink" title="a). singleton (单例) - 默认作用域"></a>a). <code>singleton</code> (单例) - 默认作用域</h6><ul>
<li><p><strong>定义</strong>：在整个Spring IoC容器中，一个Bean定义<strong>只对应一个实例</strong>。</p>
</li>
<li><p><strong>行为</strong>：</p>
<ul>
<li>容器启动时，就会创建该Bean的实例（非懒加载情况下）。</li>
<li>这个唯一的实例会被存储在一个缓存中（单例池）。</li>
<li>之后任何对该Bean的请求或注入，都会返回这个<strong>共享的、唯一的实例</strong>。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：绝大多数无状态的Bean。例如 <code>Service</code> 层对象、<code>Repository</code> 层对象、<code>Controller</code>、配置类等。这些对象不保存与特定请求或用户相关的状态，只提供方法和功能。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// @Scope(&quot;singleton&quot;) // 这是默认值，所以通常不需要显式声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingletonService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySingletonService</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MySingletonService instance created!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论你在多少个地方注入<code>MySingletonService</code>，它的构造函数在整个应用生命周期中只会被调用一次。</p>
</li>
</ul>
<h6 id="b-prototype-原型-多例"><a href="#b-prototype-原型-多例" class="headerlink" title="b). prototype (原型&#x2F;多例)"></a>b). <code>prototype</code> (原型&#x2F;多例)</h6><ul>
<li><p><strong>定义</strong>：每次对该Bean进行请求（注入或通过<code>getBean()</code>方法获取）时，都会<strong>创建一个全新的实例</strong>。</p>
</li>
<li><p><strong>行为</strong>：</p>
<ul>
<li>Spring容器负责创建、配置和初始化一个新的<code>prototype</code> Bean实例。</li>
<li>但是，一旦将实例交给客户端代码后，<strong>Spring就不再管理该实例的完整生命周期了</strong>。Spring不会为<code>prototype</code> Bean调用其销毁回调方法（如<code>@PreDestroy</code>）。客户端代码需要自己负责清理<code>prototype</code> Bean所持有的昂贵资源。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：需要保存状态的Bean。例如，一个记录多步骤操作向导的当前状态的对象，或者一个用于构建复杂对象的Builder。每个用户或每个线程都需要一个独立的状态对象，不能共享。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserActionTracker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; actions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserActionTracker</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New UserActionTracker instance created: &quot;</span> + <span class="built_in">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAction</span><span class="params">(String action)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.actions.add(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次注入<code>UserActionTracker</code>，你都会得到一个全新的、拥有自己<code>actions</code>列表的对象。</p>
</li>
</ul>
<hr>
<h5 id="3-Web应用中的额外作用域"><a href="#3-Web应用中的额外作用域" class="headerlink" title="3. Web应用中的额外作用域"></a>3. Web应用中的额外作用域</h5><p>在Web环境中（即当你的<code>ApplicationContext</code>是<code>WebApplicationContext</code>时），Spring提供了几个额外的作用域，它们的生命周期与Web请求紧密相关。</p>
<h6 id="a-request"><a href="#a-request" class="headerlink" title="a). request"></a>a). <code>request</code></h6><ul>
<li><strong>定义</strong>：对于<strong>每一次HTTP请求</strong>，都会创建一个全新的Bean实例。</li>
<li><strong>生命周期</strong>：Bean实例的生命周期从HTTP请求开始到该请求结束（响应发送回客户端）为止。</li>
<li><strong>适用场景</strong>：存放与单次请求相关的信息。例如，将请求参数封装成一个对象、存放用户的IP地址、为当前请求建立的数据库连接等。</li>
</ul>
<h6 id="b-session"><a href="#b-session" class="headerlink" title="b). session"></a>b). <code>session</code></h6><ul>
<li><strong>定义</strong>：对于<strong>每一个HTTP Session</strong>，会创建一个全新的Bean实例。</li>
<li><strong>生命周期</strong>：Bean实例的生命周期与用户的Session相同。只要Session不失效，该实例就一直存在。</li>
<li><strong>适用场景</strong>：存放与特定用户会话相关的信息。最经典的例子就是<strong>购物车</strong>、用户的<strong>登录状态</strong>信息。</li>
</ul>
<h6 id="c-application"><a href="#c-application" class="headerlink" title="c). application"></a>c). <code>application</code></h6><ul>
<li><strong>定义</strong>：对于整个Web应用（<code>ServletContext</code>），只创建一个Bean实例。</li>
<li><strong>生命周期</strong>：从<code>ServletContext</code>被创建（应用启动）到它被销毁（应用关闭）。</li>
<li><strong>适用场景</strong>：存放应用级别的全局共享数据。例如，网站访问量计数器、应用范围内的缓存、共享的配置信息。它的行为非常类似<code>singleton</code>，但它的生命周期是绑定到<code>ServletContext</code>的。</li>
</ul>
<h6 id="d-websocket"><a href="#d-websocket" class="headerlink" title="d). websocket"></a>d). <code>websocket</code></h6><ul>
<li><strong>定义</strong>：对于每一个WebSocket会话，创建一个Bean实例。</li>
</ul>
<hr>
<h5 id="4-作用域代理-Scoped-Proxies-解决注入难题"><a href="#4-作用域代理-Scoped-Proxies-解决注入难题" class="headerlink" title="4. 作用域代理 (Scoped Proxies) - 解决注入难题"></a>4. 作用域代理 (Scoped Proxies) - 解决注入难题</h5><p><strong>问题</strong>：如果一个<code>singleton</code> Bean（在应用启动时创建）需要注入一个<code>request</code>作用域的Bean（在每次请求时创建），会发生什么？</p>
<p>Spring在启动时为<code>singleton</code> Bean注入依赖时，<code>request</code>作用域的Bean还不存在！</p>
<p><strong>解决方案</strong>：使用<strong>作用域代理</strong>。</p>
<p>当你为一个短生命周期的Bean（如<code>request</code>, <code>session</code>）声明作用域代理时，Spring注入到长生命周期Bean（如<code>singleton</code>）中的不再是这个Bean的实例本身，而是一个<strong>代理对象</strong>。</p>
<ul>
<li><strong>工作原理</strong>：<ol>
<li><code>singleton</code> Bean持有的是这个<strong>代理</strong>。</li>
<li>当<code>singleton</code> Bean的方法调用这个代理的方法时，代理会“聪明地”从当前作用域（例如，当前的HTTP请求）中查找<strong>真正的Bean实例</strong>。</li>
<li>然后，代理将方法调用<strong>委托</strong>给这个真正的实例。</li>
</ol>
</li>
</ul>
<p>这样就完美地解决了生命周期不匹配的问题。</p>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个Request作用域的Bean，用于存储当前登录用户的信息</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = &quot;request&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// getters and setters...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个Singleton作用域的Service，它需要获取当前用户</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入的实际上是一个代理对象，而不是真正的CurrentUser实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CurrentUser currentUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(CurrentUser currentUser)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentUser = currentUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 当调用此方法时，代理会找到当前HTTP请求对应的CurrentUser实例</span></span><br><span class="line">        <span class="comment">// 并从中获取用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> currentUser.getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating order for user: &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>proxyMode = ScopedProxyMode.TARGET_CLASS</code> 告诉Spring使用CGLIB创建一个基于类的代理。这是SpringBoot中的常见用法。</li>
</ul>
<hr>
<h5 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h5><table>
<thead>
<tr>
<th align="left">作用域</th>
<th align="left">描述</th>
<th align="left">实例数量</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>singleton</code></strong></td>
<td align="left">(默认) 每个容器一个实例</td>
<td align="left"><strong>1</strong></td>
<td align="left">无状态的Service, Repository, Controller</td>
</tr>
<tr>
<td align="left"><strong><code>prototype</code></strong></td>
<td align="left">每次请求创建一个新实例</td>
<td align="left"><strong>N</strong></td>
<td align="left">有状态的对象，如Builder模式</td>
</tr>
<tr>
<td align="left"><strong><code>request</code></strong></td>
<td align="left">每次HTTP请求一个实例</td>
<td align="left">每个请求1个</td>
<td align="left">请求级别的数据，如请求参数对象</td>
</tr>
<tr>
<td align="left"><strong><code>session</code></strong></td>
<td align="left">每个用户会话一个实例</td>
<td align="left">每个Session 1个</td>
<td align="left">用户级别的数据，如购物车、登录信息</td>
</tr>
<tr>
<td align="left"><strong><code>application</code></strong></td>
<td align="left">每个Web应用一个实例</td>
<td align="left"><strong>1</strong> (Web范围)</td>
<td align="left">应用级别的全局数据，如网站计数器</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-5-5-循环依赖"><a href="#1-5-5-循环依赖" class="headerlink" title="1.5.5 循环依赖"></a>1.5.5 循环依赖</h4><h5 id="1-什么是循环依赖？"><a href="#1-什么是循环依赖？" class="headerlink" title="1. 什么是循环依赖？"></a>1. 什么是循环依赖？</h5><p>循环依赖，也叫循环引用，指的是两个或多个Bean之间相互持有对方的引用，形成一个闭环。最简单的形式是：</p>
<ul>
<li><strong>A 依赖 B，同时 B 又依赖 A。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceA</span><span class="params">(ServiceB serviceB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceB = serviceB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceB</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceB</span><span class="params">(ServiceA serviceA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceA = serviceA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Spring试图创建<code>ServiceA</code>时，它发现需要<code>ServiceB</code>。于是它暂停创建<code>ServiceA</code>，转而去创建<code>ServiceB</code>。在创建<code>ServiceB</code>时，它又发现需要<code>ServiceA</code>。此时，<code>ServiceA</code>还没有创建完成，这就形成了一个无法解决的死锁，就像一个“先有鸡还是先有蛋”的问题。</p>
<hr>
<h5 id="2-Spring是如何解决的？-仅限Setter-字段注入"><a href="#2-Spring是如何解决的？-仅限Setter-字段注入" class="headerlink" title="2. Spring是如何解决的？(仅限Setter&#x2F;字段注入)"></a>2. Spring是如何解决的？(仅限Setter&#x2F;字段注入)</h5><p>Spring设计了一套非常巧妙的机制来解决<strong>单例（singleton）作用域</strong>下，通过<strong>Setter或字段注入</strong>产生的循环依赖。这个机制的核心是<strong>三级缓存</strong>。</p>
<p>让我们把Bean的创建过程想象成盖房子：</p>
<ul>
<li><strong>一级缓存 (<code>singletonObjects</code>)</strong>: <strong>成品房仓库</strong>。存放已经完全创建好、可以随时入住的房子（Bean实例）。<code>Map&lt;String, Object&gt;</code></li>
<li><strong>二级缓存 (<code>earlySingletonObjects</code>)</strong>: <strong>半成品房仓库</strong>。存放刚刚建好框架、但还没装修的房子（已经实例化但未填充属性的Bean）。关键在于，你已经可以拿到这栋房子的<strong>地址</strong>（早期引用）了。<code>Map&lt;String, Object&gt;</code></li>
<li><strong>三级缓存 (<code>singletonFactories</code>)</strong>: <strong>房屋设计图&#x2F;施工队仓库</strong>。存放能建造半成品房的“工厂对象”（<code>ObjectFactory</code>）。当你需要一栋房子的地址时，施工队会告诉你：“虽然房子没盖完，但我可以先给你一个地址的‘期房合同’（早期引用）”。<code>Map&lt;String, ObjectFactory&lt;?&gt;&gt;</code></li>
</ul>
<p><strong>解决流程（A依赖B，B依赖A）</strong></p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client as 客户端
    participant Spring as Spring容器
    participant L1_Cache as 一级缓存 (singletonObjects)
    participant L2_Cache as 二级缓存 (earlySingletonObjects)
    participant L3_Cache as 三级缓存 (singletonFactories)
    participant A as ServiceA
    participant B as ServiceB

    title Spring 循环依赖解决流程 (三级缓存)

    Client-&gt;&gt;Spring: getBean(&quot;a&quot;)

    %% 1. 创建A
    Spring-&gt;&gt;L1_Cache: 检查 &quot;a&quot;
    L1_Cache--&gt;&gt;Spring: 未找到
    note over Spring: 开始创建A
    Spring-&gt;&gt;A: 1. 实例化 new ServiceA()
    A--&gt;&gt;Spring: a_instance (裸对象)
    Spring-&gt;&gt;L3_Cache: 2. put(&quot;a&quot;, aFactory)
    note right of L3_Cache: 放入A的工厂，暴露早期引用

    %% 2. 填充A的属性，发现依赖B
    note over Spring: 3. 填充A，发现依赖B
    Spring-&gt;&gt;Spring: getBean(&quot;b&quot;)

    %% 3. 创建B
    Spring-&gt;&gt;L1_Cache: 检查 &quot;b&quot;
    L1_Cache--&gt;&gt;Spring: 未找到
    note over Spring: 开始创建B
    Spring-&gt;&gt;B: 4. 实例化 new ServiceB()
    B--&gt;&gt;Spring: b_instance (裸对象)
    Spring-&gt;&gt;L3_Cache: 5. put(&quot;b&quot;, bFactory)

    %% 4. 填充B的属性，发现依赖A
    note over Spring: 6. 填充B，发现依赖A
    Spring-&gt;&gt;Spring: getBean(&quot;a&quot;)

    %% 5. 解决循环的关键点
    note over Spring: 再次获取A, 检查三级缓存
    Spring-&gt;&gt;L1_Cache: 检查 &quot;a&quot; -&gt; 未找到
    Spring-&gt;&gt;L2_Cache: 检查 &quot;a&quot; -&gt; 未找到
    Spring-&gt;&gt;L3_Cache: 检查 &quot;a&quot; -&gt; 找到aFactory!
    L3_Cache--&gt;&gt;Spring: 返回 aFactory
    
    note over Spring: 7. 执行aFactory, 获取早期引用
    Spring-&gt;&gt;L3_Cache: aFactory.getObject()
    L3_Cache--&gt;&gt;Spring: early_a_ref (A的早期引用)
    Spring-&gt;&gt;L2_Cache: 8. put(&quot;a&quot;, early_a_ref)
    Spring-&gt;&gt;L3_Cache: 9. remove(&quot;a&quot;)
    note right of L2_Cache: A的早期引用放入二级缓存，防止重复创建
    
    Spring-&gt;&gt;B: 10. 将early_a_ref注入B
    note left of B: B的属性填充完成

    %% 6. 完成B的创建
    note over Spring: 11. B初始化完成
    B--&gt;&gt;Spring: 完整的B实例
    Spring-&gt;&gt;L1_Cache: 12. put(&quot;b&quot;, b_instance)
    note right of L1_Cache: 完整的B放入一级缓存

    %% 7. 完成A的创建
    note over Spring: 13. 返回A的创建流程，注入B
    Spring-&gt;&gt;L1_Cache: getBean(&quot;b&quot;)
    L1_Cache--&gt;&gt;Spring: 返回完整的B实例
    Spring-&gt;&gt;A: 14. 将完整的B注入A
    note left of A: A的属性填充完成
    
    note over Spring: 15. A初始化完成
    A--&gt;&gt;Spring: 完整的A实例
    Spring-&gt;&gt;L1_Cache: 16. put(&quot;a&quot;, a_instance)
    note right of L1_Cache: 完整的A放入一级缓存

    Spring--&gt;&gt;Client: 返回完整的A实例</code></pre>

<ol>
<li><strong>创建A</strong>:<ul>
<li><code>getBean(&quot;a&quot;)</code>被调用。</li>
<li>Spring检查一级缓存，没有A。</li>
<li>Spring开始创建A。首先，通过构造函数<strong>实例化</strong>A，得到一个“裸”对象<code>a_instance</code>。</li>
<li><strong>关键一步</strong>：Spring不会立即填充A的属性。而是创建一个能获取<code>a_instance</code>的工厂（<code>ObjectFactory</code>），并将其放入<strong>三级缓存</strong>中：<code>singletonFactories.put(&quot;a&quot;, aFactory)</code>。</li>
</ul>
</li>
<li><strong>填充A的属性</strong>:<ul>
<li>Spring开始为<code>a_instance</code>注入依赖。它发现A需要B（<code>private ServiceB serviceB;</code>）。</li>
</ul>
</li>
<li><strong>创建B</strong>:<ul>
<li>Spring暂停A的创建，转而去<code>getBean(&quot;b&quot;)</code>。</li>
<li>和A一样，Spring实例化B，得到<code>b_instance</code>，然后将B的工厂放入<strong>三级缓存</strong>：<code>singletonFactories.put(&quot;b&quot;, bFactory)</code>。</li>
</ul>
</li>
<li><strong>填充B的属性</strong>:<ul>
<li>Spring为<code>b_instance</code>注入依赖。它发现B需要A。</li>
</ul>
</li>
<li><strong>解决循环的关键点</strong>:<ul>
<li>Spring暂停B的创建，转而去<code>getBean(&quot;a&quot;)</code>。</li>
<li>Spring再次检查缓存：<ul>
<li>一级缓存 (<code>singletonObjects</code>): 没有A。</li>
<li>二级缓存 (<code>earlySingletonObjects</code>): 也没有A。</li>
<li><strong>三级缓存 (<code>singletonFactories</code>): 找到了A的工厂 <code>aFactory</code>！</strong></li>
</ul>
</li>
<li>Spring立刻执行这个<code>aFactory</code>，得到一个A的<strong>早期引用</strong>（Early Reference），也就是那个刚实例化但还没装修的<code>a_instance</code>。</li>
<li>为了防止重复创建，Spring将这个早期引用放入<strong>二级缓存</strong> <code>earlySingletonObjects.put(&quot;a&quot;, early_a_ref)</code>，并从三级缓存中移除A的工厂。</li>
<li>这个A的早期引用被返回并注入到B的<code>serviceA</code>字段中。</li>
</ul>
</li>
<li><strong>完成B的创建</strong>:<ul>
<li>B成功获取了A的引用（虽然是早期的），B的属性填充完成。</li>
<li>B执行初始化方法，成为一个完整的Bean。</li>
<li>完整的B被放入<strong>一级缓存</strong> <code>singletonObjects.put(&quot;b&quot;, b_instance)</code>。</li>
</ul>
</li>
<li><strong>完成A的创建</strong>:<ul>
<li>执行流程回到第2步，<code>getBean(&quot;b&quot;)</code>现在可以直接从一级缓存中拿到完整的B实例。</li>
<li>完整的B被注入到A的<code>serviceB</code>字段中。</li>
<li>A的属性填充完成，执行初始化，成为一个完整的Bean。</li>
<li>完整的A被放入<strong>一级缓存</strong> <code>singletonObjects.put(&quot;a&quot;, a_instance)</code>。</li>
</ul>
</li>
</ol>
<p>至此，循环依赖被完美解决。两个Bean都持有了对方的完整实例。</p>
<hr>
<h5 id="3-为什么需要三级缓存而不是二级？"><a href="#3-为什么需要三级缓存而不是二级？" class="headerlink" title="3. 为什么需要三级缓存而不是二级？"></a>3. 为什么需要三级缓存而不是二级？</h5><p>“既然二级缓存就能存放早期引用，为什么还需要三级缓存？”</p>
<p>答案是：<strong>为了支持AOP代理</strong>。</p>
<p>如果Bean A需要被AOP代理，那么注入到B中的不能是原始的A实例，而应该是A的代理对象。创建代理对象的时机通常是在Bean初始化完成之后（通过<code>BeanPostProcessor</code>）。</p>
<p>但是，在循环依赖的场景下，B需要提前引用A，此时A还没有完成初始化。三级缓存的<code>ObjectFactory</code>就解决了这个问题：<code>aFactory</code>被执行时，它可以检查A是否需要被代理，如果需要，就返回代理对象；如果不需要，就返回原始对象。这样，无论是否需要代理，B都能拿到正确的引用。二级缓存只存放结果，而三级缓存存放的是“可以创建结果的工厂”，这提供了更高的灵活性。</p>
<hr>
<h5 id="4-Spring无法解决的循环依赖"><a href="#4-Spring无法解决的循环依赖" class="headerlink" title="4. Spring无法解决的循环依赖"></a>4. Spring无法解决的循环依赖</h5><ol>
<li><strong>构造器注入的循环依赖</strong><ul>
<li>构造器注入要求在<code>new</code>一个对象时，其所有依赖项必须是已完成的实例。这形成了一个无法打破的死锁。Spring无法通过“提前暴露引用”来解决，所以它会直接在启动时抛出<code>BeanCurrentlyInCreationException</code>。</li>
<li><strong>这也是官方推荐使用构造器注入的另一个原因</strong>：它能迫使你在编码阶段就发现并解决不良的循环依赖设计。</li>
</ul>
</li>
<li><strong><code>prototype</code>作用域的循环依赖</strong><ul>
<li>因为<code>prototype</code> Bean每次请求都会创建一个新的实例，Spring不会对它们进行缓存。没有了缓存机制，自然也就无法通过三级缓存来解决循环依赖。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="5-最佳实践：避免循环依赖"><a href="#5-最佳实践：避免循环依赖" class="headerlink" title="5. 最佳实践：避免循环依赖"></a>5. 最佳实践：避免循环依赖</h5><p>虽然Spring能够解决部分循环依赖，但在软件设计中，<strong>循环依赖通常被认为是一种“坏味道”（Bad Smell）</strong>，它暗示着类的职责划分可能不清晰，耦合度过高。</p>
<p><strong>如何解决？</strong></p>
<ol>
<li><p><strong>重构代码</strong>：这是最好的方法。</p>
<ul>
<li><strong>提取新类</strong>：找出A和B共同依赖的逻辑或数据，将其提取到一个新的类C中。然后让A和B都依赖C，从而打破A和B之间的直接循环。</li>
<li><strong>重新分配职责</strong>：重新审视A和B的职责，可能B的某个功能实际上属于A，或者反之。调整后，依赖关系可能就变成单向的了。</li>
</ul>
</li>
<li><p><strong>使用 <code>@Lazy</code> 注解</strong> (作为最后的手段)</p>
<ul>
<li>可以在其中一个注入点（构造器参数或字段）上添加 <code>@Lazy</code> 注解。</li>
<li>这会告诉Spring：“不要立即注入这个Bean，而是注入一个它的代理。等到我第一次真正调用这个Bean的方法时，再去容器里查找并加载它。”</li>
<li>这推迟了其中一个Bean的加载，从而在启动时打破了循环。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在B的注入点使用@Lazy</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceA</span><span class="params">(<span class="meta">@Lazy</span> ServiceB serviceB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceB = serviceB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>总结：</strong> 在实际开发中，首要目标应该是<strong>通过优秀的设计来避免循环依赖的产生</strong>。</p>
<hr>
<h2 id="2-面向切面编程"><a href="#2-面向切面编程" class="headerlink" title="2. 面向切面编程"></a>2. 面向切面编程</h2><h3 id="2-1-AOP核心概念"><a href="#2-1-AOP核心概念" class="headerlink" title="2.1 AOP核心概念"></a>2.1 AOP核心概念</h3><h4 id="2-1-1-为什么需要AOP？（The-“Why”）"><a href="#2-1-1-为什么需要AOP？（The-“Why”）" class="headerlink" title="2.1.1 为什么需要AOP？（The “Why”）"></a>2.1.1 为什么需要AOP？（The “Why”）</h4><p>想象一下，我们有很多业务方法，比如<code>createUser()</code>, <code>updateOrder()</code>, <code>deleteProduct()</code>。现在，我们需要为这些方法统一添加一些功能，比如：</p>
<ul>
<li><strong>日志记录</strong>：在方法开始和结束时打印日志。</li>
<li><strong>事务管理</strong>：在方法开始时开启事务，结束时提交或回滚。</li>
<li><strong>权限校验</strong>：在方法执行前检查当前用户是否有权限。</li>
<li><strong>性能监控</strong>：记录每个方法的执行时间。</li>
</ul>
<p><strong>如果没有AOP，我们可能会这样做：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 权限校验</span></span><br><span class="line">        checkPermission(<span class="string">&quot;CREATE_USER&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 开启事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> transactionManager.begin();</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 核心业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Executing core logic: creating user &quot;</span> + user.getName());</span><br><span class="line">            userRepository.save(user);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 提交事务</span></span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 5. 回滚事务</span></span><br><span class="line">            tx.rollback();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 记录日志和性能</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">            System.out.println(<span class="string">&quot;Method createUser executed in &quot;</span> + duration + <span class="string">&quot;ms.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... updateOrder() 和 deleteProduct() 方法中也要重复1-6步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题显而易见：</strong></p>
<ul>
<li><strong>代码重复</strong>：日志、事务、权限代码在每个业务方法中都重复出现。</li>
<li><strong>业务逻辑混杂</strong>：核心的业务逻辑（<code>userRepository.save(user)</code>）被大量非业务的“样板代码”所包围，难以阅读和维护。</li>
</ul>
<p><strong>AOP的目标</strong>：就是将这些分散在各处的、与核心业务无关但又必不可少的通用功能（我们称之为<strong>横切关注点</strong>），从业务代码中<strong>抽离</strong>出来，形成独立的模块（<strong>切面</strong>），然后以一种非侵入的方式，在需要的时候动态地“织入”到业务代码中。</p>
<hr>
<h4 id="2-1-2-AOP的核心术语（The-“What”-and-“How”）"><a href="#2-1-2-AOP的核心术语（The-“What”-and-“How”）" class="headerlink" title="2.1.2 AOP的核心术语（The “What” and “How”）"></a>2.1.2 AOP的核心术语（The “What” and “How”）</h4><p>为了实现上述目标，AOP定义了一套专门的术语。理解这些术语是掌握AOP的关键。</p>
<p>让我们用一个<strong>剧院表演</strong>的类比来理解：</p>
<ul>
<li><strong>剧本 (核心业务)</strong>：演员按照剧本表演，这是核心内容。</li>
<li><strong>灯光&#x2F;音效 (横切关注点)</strong>：灯光师和音效师的工作（打光、播放背景音乐）会穿插在整个表演中，但它不是剧本的核心。</li>
</ul>
<hr>
<h5 id="1-Aspect-切面"><a href="#1-Aspect-切面" class="headerlink" title="1. Aspect (切面)"></a>1. Aspect (切面)</h5><ul>
<li><strong>定义</strong>：一个封装了<strong>横切关注点</strong>的模块。它告诉程序<strong>做什么</strong>（通知）以及<strong>在哪里做</strong>（切点）。</li>
<li><strong>类比</strong>：<strong>灯光&#x2F;音效团队</strong>。这个团队负责所有与灯光和音效相关的工作。</li>
<li><strong>在Spring中</strong>：一个带有 <code>@Aspect</code> 注解的Java类。</li>
</ul>
<hr>
<h5 id="2-Join-Point-连接点"><a href="#2-Join-Point-连接点" class="headerlink" title="2. Join Point (连接点)"></a>2. Join Point (连接点)</h5><ul>
<li><strong>定义</strong>：程序执行过程中的一个<strong>特定时机点</strong>，可以被切面织入。</li>
<li><strong>类比</strong>：剧本中的<strong>每一句台词、每一个动作</strong>。这些都是灯光师可以决定“打光”的潜在时机。</li>
<li><strong>在Spring中</strong>：<strong>只能是方法的执行</strong>。例如，<code>OrderService.createOrder()</code> 方法的执行就是一个连接点。</li>
</ul>
<hr>
<h5 id="3-Pointcut-切点"><a href="#3-Pointcut-切点" class="headerlink" title="3. Pointcut (切点)"></a>3. Pointcut (切点)</h5><ul>
<li><strong>定义</strong>：一个<strong>表达式</strong>，用于<strong>筛选</strong>出一批符合条件的连接点。切面只会对这些被选中的连接点起作用。</li>
<li><strong>类比</strong>：灯光师的<strong>指令</strong>：“在<strong>第二幕</strong>中，<strong>主角说的所有台词</strong>处，都要打上追光灯。” 这条指令精确地筛选出了需要打光的时机点。</li>
<li><strong>在Spring中</strong>：一个使用特定语法（如 <code>execution(* com.example.service.*.*(..))</code>）定义的表达式，通常与 <code>@Pointcut</code> 注解关联。</li>
</ul>
<hr>
<h5 id="4-Advice-通知"><a href="#4-Advice-通知" class="headerlink" title="4. Advice (通知)"></a>4. Advice (通知)</h5><ul>
<li><strong>定义</strong>：切面在特定的切点上要<strong>执行的具体动作</strong>。</li>
<li><strong>类比</strong>：灯光师的具体操作，比如“<strong>打开追光灯</strong>”、“<strong>将灯光调暗</strong>”。</li>
<li><strong>在Spring中</strong>：切面类中带有特殊注解的方法。共有5种类型的通知：<ol>
<li><strong><code>@Before</code> (前置通知)</strong>：在连接点（目标方法）执行<strong>之前</strong>执行。</li>
<li><strong><code>@AfterReturning</code> (后置通知)</strong>：在连接点<strong>正常执行完毕</strong>（没有抛出异常）后执行。</li>
<li><strong><code>@AfterThrowing</code> (异常通知)</strong>：在连接点执行过程中<strong>抛出异常</strong>后执行。</li>
<li><strong><code>@After</code> (最终通知)</strong>：<strong>无论</strong>连接点是正常结束还是异常退出，<strong>都会</strong>执行（类似于<code>finally</code>块）。</li>
<li><strong><code>@Around</code> (环绕通知)</strong>：<strong>最强大</strong>的通知。它完全包裹了连接点，可以在连接点执行<strong>前后</strong>都进行操作，甚至可以决定是否执行连接点。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="5-Target-Object-目标对象"><a href="#5-Target-Object-目标对象" class="headerlink" title="5. Target Object (目标对象)"></a>5. Target Object (目标对象)</h5><ul>
<li><strong>定义</strong>：被一个或多个切面“通知”的对象。也就是包含我们核心业务逻辑的那个对象。</li>
<li><strong>类比</strong>：正在舞台上表演的<strong>演员</strong>。</li>
<li><strong>在Spring中</strong>：原始的业务Bean，例如<code>UserServiceImpl</code>的实例。</li>
</ul>
<hr>
<h5 id="6-Proxy-代理"><a href="#6-Proxy-代理" class="headerlink" title="6. Proxy (代理)"></a>6. Proxy (代理)</h5><ul>
<li><strong>定义</strong>：Spring AOP的实现机制。Spring不会直接修改你的业务代码，而是在运行时创建一个<strong>代理对象</strong>。这个代理对象包含了原始目标对象的所有方法，并在方法的特定位置（由切点决定）嵌入了通知的逻辑。</li>
<li><strong>类比</strong>：演员的<strong>替身</strong>。观众（客户端代码）看到的和互动的其实是这个替身，替身在表演核心动作（调用原始演员的方法）前后，会自己加上一些额外的动作（执行通知）。</li>
<li><strong>在Spring中</strong>：默认使用CGLIB（针对类）或JDK动态代理（针对接口）来创建。</li>
</ul>
<hr>
<h5 id="7-Weaving-织入"><a href="#7-Weaving-织入" class="headerlink" title="7. Weaving (织入)"></a>7. Weaving (织入)</h5><ul>
<li><strong>定义</strong>：将切面应用到目标对象，从而创建出代理对象的这个<strong>过程</strong>。</li>
<li><strong>类比</strong>：在表演开始前，导演告诉灯光师和演员如何配合的整个<strong>彩排和准备过程</strong>。</li>
<li><strong>在Spring中</strong>：织入发生在<strong>运行时</strong>，当Spring容器为目标Bean创建代理实例的时候。</li>
</ul>
<hr>
<h4 id="2-1-3-总结与关系图"><a href="#2-1-3-总结与关系图" class="headerlink" title="2.1.3 总结与关系图"></a>2.1.3 总结与关系图</h4><pre><code class="highlight mermaid">graph TD
    subgraph &quot;AOP Core Concepts&quot;
        Aspect[&quot;&lt;b&gt;Aspect (切面: 灯光团队)&lt;/b&gt;&lt;br/&gt;@Aspect&quot;]
        Pointcut[&quot;&lt;b&gt;Pointcut (切点: 指令)&lt;/b&gt;&quot;]
        Advice[&quot;&lt;b&gt;Advice (通知: 打开灯)&lt;/b&gt;&lt;br/&gt;(具体要做什么?)&lt;br/&gt;@Before, @Around...&quot;]
        
        Aspect -- &quot;包含&quot; --&gt; Pointcut
        Aspect -- &quot;包含&quot; --&gt; Advice
        Pointcut -- &quot;(在哪里做?)&quot; --&gt; Advice
    end

    JoinPoints[&quot;&lt;b&gt;Join Points (连接点: 剧本里的每个动作)&lt;/b&gt;&lt;br/&gt;(程序执行过程中的所有可能时机，如方法调用)&quot;]
    
    Pointcut -- &quot;Selects (筛选)&quot; --&gt; JoinPoints

    subgraph &quot;Weaving(织入过程)&quot;
        IoC[&quot;&lt;b&gt;Spring IoC (容器)&lt;/b&gt;&quot;]
        Proxy[&quot;&lt;b&gt;Proxy (代理: 替身)&lt;/b&gt;&quot;]
        Target[&quot;&lt;b&gt;Target Object (目标对象: 演员)&lt;/b&gt;&quot;]

        IoC -- Creates --&gt; Proxy
        Proxy -- &quot;Delegates to&quot; --&gt; Target
    end

    %% Style definitions for better visuals
    style Aspect fill:#f9f,stroke:#333,stroke-width:2px
    style Pointcut fill:#ccf,stroke:#333,stroke-width:2px
    style Advice fill:#cfc,stroke:#333,stroke-width:2px
    style JoinPoints fill:#ff9,stroke:#333,stroke-width:2px</code></pre>



<hr>
<h3 id="2-2-通知"><a href="#2-2-通知" class="headerlink" title="2.2 通知"></a>2.2 通知</h3><h4 id="2-2-1-准备工作"><a href="#2-2-1-准备工作" class="headerlink" title="2.2.1 准备工作"></a>2.2.1 准备工作</h4><h5 id="1-我们的目标对象"><a href="#1-我们的目标对象" class="headerlink" title="1. 我们的目标对象"></a>1. 我们的目标对象</h5><p>我们将对这个<code>CalculatorService</code>的方法执行进行“通知”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/CalculatorService.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.aop.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CalculatorService</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service/CalculatorServiceImpl.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.aop.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CalculatorService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 执行核心逻辑: add(&quot;</span> + a + <span class="string">&quot;, &quot;</span> + b + <span class="string">&quot;) ---&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 执行核心逻辑: divide(&quot;</span> + a + <span class="string">&quot;, &quot;</span> + b + <span class="string">&quot;) ---&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;除数不能为零&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-我们的切面和切点"><a href="#2-我们的切面和切点" class="headerlink" title="2. 我们的切面和切点"></a>2. 我们的切面和切点</h5><p>我们创建一个<code>LoggingAspect</code>，并定义一个通用的切点，指向<code>CalculatorService</code>中的所有方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aspect/LoggingAspect.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.aop.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个可重用的切点，匹配CalculatorService接口中的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.aop.service.CalculatorService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculatorServiceMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来，我们将在这个类中添加五种不同类型的通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>请确保你的SpringBoot应用开启了AOP支持（<code>spring-boot-starter-aop</code>依赖）。</em></p>
<hr>
<h4 id="2-2-2-Advice的五种类型详解"><a href="#2-2-2-Advice的五种类型详解" class="headerlink" title="2.2.2 Advice的五种类型详解"></a>2.2.2 Advice的五种类型详解</h4><h5 id="1-Before-前置通知"><a href="#1-Before-前置通知" class="headerlink" title="1. @Before (前置通知)"></a>1. <code>@Before</code> (前置通知)</h5><ul>
<li><strong>执行时机</strong>：在目标方法（连接点）<strong>执行之前</strong>运行。</li>
<li><strong>特点</strong>：<ul>
<li>无法阻止目标方法的执行。</li>
<li>可以获取到目标方法的元数据（如方法名、参数），但无法改变参数。</li>
</ul>
</li>
<li><strong>适用场景</strong>：权限检查、参数日志记录、数据预处理。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="meta">@Before(&quot;calculatorServiceMethods()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    System.out.println(<span class="string">&quot;[@Before] 方法 &quot;</span> + methodName + <span class="string">&quot; 即将执行，参数: &quot;</span> + Arrays.toString(args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>add(5, 3)</code> 时，输出:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[@Before] 方法 add 即将执行，参数: [5, 3]</span><br><span class="line">--- 执行核心逻辑: add(5, 3) ---</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-AfterReturning-后置通知-返回通知"><a href="#2-AfterReturning-后置通知-返回通知" class="headerlink" title="2. @AfterReturning (后置通知&#x2F;返回通知)"></a>2. <code>@AfterReturning</code> (后置通知&#x2F;返回通知)</h5><ul>
<li><strong>执行时机</strong>：在目标方法<strong>正常执行完毕</strong>（即没有抛出任何异常）并<strong>返回结果后</strong>运行。</li>
<li><strong>特点</strong>：<ul>
<li>可以获取到目标方法的返回值。</li>
<li>但无法改变返回值（虽然可以通过一些技巧包装，但不推荐）。</li>
</ul>
</li>
<li><strong>适用场景</strong>：对返回结果进行日志记录、对结果进行格式化或加密后再返回给某些审计系统。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="comment">// `returning = &quot;result&quot;` 将目标方法的返回值绑定到通知方法的`result`参数上</span></span><br><span class="line"><span class="meta">@AfterReturning(pointcut = &quot;calculatorServiceMethods()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;[@AfterReturning] 方法 &quot;</span> + methodName + <span class="string">&quot; 成功执行并返回: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>add(5, 3)</code> 时，输出:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- 执行核心逻辑: add(5, 3) ---</span><br><span class="line">[@AfterReturning] 方法 add 成功执行并返回: 8</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-AfterThrowing-异常通知"><a href="#3-AfterThrowing-异常通知" class="headerlink" title="3. @AfterThrowing (异常通知)"></a>3. <code>@AfterThrowing</code> (异常通知)</h5><ul>
<li><strong>执行时机</strong>：在目标方法执行过程中<strong>抛出异常后</strong>运行。</li>
<li><strong>特点</strong>：<ul>
<li>可以获取到抛出的异常对象。</li>
<li>可以用于统一的异常处理和日志记录。</li>
</ul>
</li>
<li><strong>适用场景</strong>：记录异常日志、发送错误告警（如邮件、短信）、触发事务回滚的特定逻辑。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="comment">// `throwing = &quot;ex&quot;` 将抛出的异常绑定到通知方法的`ex`参数上</span></span><br><span class="line"><span class="meta">@AfterThrowing(pointcut = &quot;calculatorServiceMethods()&quot;, throwing = &quot;ex&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    System.err.println(<span class="string">&quot;[@AfterThrowing] 方法 &quot;</span> + methodName + <span class="string">&quot; 抛出异常: &quot;</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>divide(10, 0)</code> 时，输出:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- 执行核心逻辑: divide(10, 0) ---</span><br><span class="line">[@AfterThrowing] 方法 divide 抛出异常: 除数不能为零</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-After-最终通知"><a href="#4-After-最终通知" class="headerlink" title="4. @After (最终通知)"></a>4. <code>@After</code> (最终通知)</h5><ul>
<li><strong>执行时机</strong>：<strong>无论</strong>目标方法是正常返回还是抛出异常，它<strong>总会</strong>执行。类似于<code>try-catch-finally</code>中的<code>finally</code>块。</li>
<li><strong>特点</strong>：<ul>
<li>无法获取返回值或异常信息，因为它不知道方法是如何结束的。</li>
</ul>
</li>
<li><strong>适用场景</strong>：资源释放。例如，关闭文件句柄、释放数据库连接、清理临时数据等，这些操作无论成功失败都必须执行。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="meta">@After(&quot;calculatorServiceMethods()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfter</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;[@After] 方法 &quot;</span> + methodName + <span class="string">&quot; 执行结束。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>add(5, 3)</code> (成功) 或 <code>divide(10, 0)</code> (失败) 时，这行日志都会被打印。</strong></p>
<hr>
<h5 id="5-Around-环绕通知"><a href="#5-Around-环绕通知" class="headerlink" title="5. @Around (环绕通知)"></a>5. <code>@Around</code> (环绕通知)</h5><ul>
<li><strong>执行时机</strong>：它完全<strong>包裹</strong>了目标方法的执行。</li>
<li><strong>特点</strong>：<ul>
<li><strong>最强大、最灵活</strong>的通知类型。</li>
<li>方法的第一个参数必须是 <code>ProceedingJoinPoint</code> 类型。</li>
<li>你可以决定是否调用 <code>pjp.proceed()</code> 来<strong>执行目标方法</strong>。不调用它，目标方法就相当于被“拦截”了。</li>
<li>你可以在 <code>pjp.proceed()</code> 调用前后添加自定义逻辑。</li>
<li>你可以获取、修改参数，甚至可以捕获异常并返回一个不同的结果。</li>
</ul>
</li>
<li><strong>适用场景</strong>：事务管理、性能监控（计算方法执行时间）、缓存、方法重试机制。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="meta">@Around(&quot;calculatorServiceMethods()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">profile</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;[@Around] &gt;&gt; 进入方法: &quot;</span> + pjp.getSignature().getName());</span><br><span class="line"></span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用这行代码才会真正执行目标方法</span></span><br><span class="line">        result = pjp.proceed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[@Around] !! 捕获到异常: &quot;</span> + t.getMessage());</span><br><span class="line">        <span class="comment">// 决定是否将异常继续向上抛出</span></span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;[@Around] &lt;&lt; 退出方法: &quot;</span> + pjp.getSignature().getName() + <span class="string">&quot;。 执行耗时: &quot;</span> + (endTime - startTime) + <span class="string">&quot;ms。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须返回目标方法的执行结果，否则调用方会得到null</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>add(5, 3)</code> 时，输出将展示完整的环绕过程。</strong></p>
<hr>
<h5 id="6-执行顺序总结"><a href="#6-执行顺序总结" class="headerlink" title="6. 执行顺序总结"></a>6. 执行顺序总结</h5><p>当一个方法同时被多种通知作用时，其执行顺序（以<code>@Around</code>为中心）如下：</p>
<ol>
<li><strong><code>@Around</code></strong> (前半部分)</li>
<li><strong><code>@Before</code></strong></li>
<li><strong>目标方法执行</strong><ul>
<li><strong>如果成功:</strong><ol start="4">
<li><strong><code>@Around</code></strong> (后半部分，<code>proceed()</code>返回后)</li>
<li><strong><code>@AfterReturning</code></strong></li>
<li><strong><code>@After</code></strong></li>
</ol>
</li>
<li><strong>如果抛出异常:</strong><ol start="4">
<li><strong><code>@Around</code></strong> (进入<code>catch</code>块)</li>
<li><strong><code>@AfterThrowing</code></strong></li>
<li><strong><code>@After</code></strong></li>
</ol>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-2-3-通知顺序"><a href="#2-2-3-通知顺序" class="headerlink" title="2.2.3 通知顺序"></a>2.2.3 通知顺序</h4><p>在Spring AOP中，当多个通知（Advice）应用到同一个连接点（JoinPoint，通常是方法）时，它们的执行顺序遵循一套明确的规则。理解这套规则对于编写健壮、可预测的AOP代码至关重要。</p>
<p>核心思想是 <strong>“洋葱模型”</strong> 或 <strong>“同心圆模型”</strong>。优先级高的切面在最外层，它最先开始执行，也最后结束执行。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client as 调用方
    participant Aspect_A as &quot;Aspect A (@Order(1))&quot;
    participant Aspect_B as &quot;Aspect B (@Order(2))&quot;
    participant Target as 目标方法

    Client-&gt;&gt;Aspect_A: 调用方法
    activate Aspect_A
    Note right of Aspect_A: 1. Aspect A 前置逻辑执行
    Aspect_A-&gt;&gt;Aspect_B: chain.proceed()
    activate Aspect_B
    Note right of Aspect_B: 2. Aspect B 前置逻辑执行
    Aspect_B-&gt;&gt;Target: chain.proceed()
    activate Target
    Note over Target: 3. 目标方法核心逻辑执行
    Target--&gt;&gt;Aspect_B: 方法返回
    deactivate Target
    Note right of Aspect_B: 4. Aspect B 后置逻辑执行
    Aspect_B--&gt;&gt;Aspect_A: 返回
    deactivate Aspect_B
    Note right of Aspect_A: 5. Aspect A 后置逻辑执行
    Aspect_A--&gt;&gt;Client: 最终结果返回
    deactivate Aspect_A</code></pre>

<hr>
<h5 id="1-单一切面内的执行顺序"><a href="#1-单一切面内的执行顺序" class="headerlink" title="1. 单一切面内的执行顺序"></a>1. 单一切面内的执行顺序</h5><p>当只有一个切面类，并且它的多个不同类型的通知都匹配了同一个方法时，执行顺序是固定的。</p>
<p><strong>目标方法正常执行（无异常）</strong></p>
<p>执行顺序如下：</p>
<ol>
<li><code>@Around</code> 环绕通知（<code>proceed()</code> 方法之前的部分）</li>
<li><code>@Before</code> 前置通知</li>
<li><strong>目标方法执行</strong></li>
<li><code>@Around</code> 环绕通知（<code>proceed()</code> 方法之后的部分）</li>
<li><code>@AfterReturning</code> 返回通知</li>
<li><code>@After</code> 后置通知</li>
</ol>
<p><strong>目标方法抛出异常</strong></p>
<p>执行顺序如下：</p>
<ol>
<li><code>@Around</code> 环绕通知（<code>proceed()</code> 方法之前的部分）</li>
<li><code>@Before</code> 前置通知</li>
<li><strong>目标方法执行，并抛出异常</strong></li>
<li><code>@AfterThrowing</code> 异常通知</li>
<li><code>@After</code> 后置通知</li>
<li><code>@Around</code> 环绕通知会捕获到异常（如果在<code>try-catch</code>块中），然后决定是处理还是继续向外抛出。</li>
</ol>
<hr>
<h5 id="2-多个不同切面间的执行顺序"><a href="#2-多个不同切面间的执行顺序" class="headerlink" title="2. 多个不同切面间的执行顺序"></a>2. 多个不同切面间的执行顺序</h5><p>这是最常见的场景。当多个切面类中的通知都匹配了同一个方法时，<strong>切面类的顺序</strong>决定了通知的执行顺序。</p>
<p><strong>规则：使用 <code>@Order(数字)</code> 或实现 <code>Ordered</code> 接口</strong></p>
<ol>
<li><strong><code>@Order(数字)</code> 注解</strong>：加在切面类上。</li>
<li><strong><code>Ordered</code> 接口</strong>：让切面类实现 <code>org.springframework.core.Ordered</code> 接口，并重写 <code>getOrder()</code> 方法。<ul>
<li><strong>数字越小，优先级越高</strong>。<code>@Order(1)</code> 的优先级高于 <code>@Order(10)</code>。</li>
<li>如果没有指定顺序，则执行顺序是 <strong>未定义的（Undefined）</strong>。<strong>绝对不要</strong>依赖默认的类名字母顺序，因为它不可靠。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-同一切面内多个同类型通知的执行顺序"><a href="#3-同一切面内多个同类型通知的执行顺序" class="headerlink" title="3. 同一切面内多个同类型通知的执行顺序"></a>3. 同一切面内多个同类型通知的执行顺序</h5><p>当<strong>同一个切面类</strong>中，有<strong>多个同类型的通知</strong>（例如，两个<code>@Before</code>）都匹配了同一个方法。</p>
<p><strong>规则：未定义（Undefined）</strong></p>
<p>Spring AOP规范没有定义在同一个切面内同类型通知的执行顺序。你<strong>不能依赖</strong>它们在代码文件中的书写顺序。</p>
<p><strong>最佳实践</strong></p>
<p>如果多个逻辑之间确实存在顺序依赖，请遵循以下两种方式之一：</p>
<ol>
<li><strong>合并为一个通知方法</strong>：将所有逻辑按顺序写在同一个<code>@Before</code>方法体内，这是最简单的方式。</li>
<li><strong>拆分到不同的切面类中</strong>：将每个逻辑块放入一个独立的切面类中，然后使用<code>@Order</code>来精确控制这些切面类的执行顺序。这种方式更符合“单一职责原则”，代码结构更清晰。</li>
</ol>
<hr>
<h3 id="2-3-Pointcut表达式语法详解"><a href="#2-3-Pointcut表达式语法详解" class="headerlink" title="2.3 Pointcut表达式语法详解"></a>2.3 Pointcut表达式语法详解</h3><p>Pointcut表达式本质上是一种<strong>查询语言</strong>，用于定位和筛选程序中的<strong>连接点（Join Points）</strong>。在Spring AOP中，连接点就是方法的执行。</p>
<p>Pointcut表达式由一个或多个**切点指示符（Pointcut Designators, PCD）**组成，可以通过逻辑运算符 <code>&amp;&amp;</code> (and), <code>||</code> (or), <code>!</code> (not) 进行组合。</p>
<h4 id="2-3-1-execution-最常用、最强大的指示符"><a href="#2-3-1-execution-最常用、最强大的指示符" class="headerlink" title="2.3.1 execution - 最常用、最强大的指示符"></a>2.3.1 <code>execution</code> - 最常用、最强大的指示符</h4><p><code>execution</code> 用于匹配方法的签名（返回类型、方法名、参数等）。这是你90%的情况下会用到的指示符。</p>
<p><strong>完整语法:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(修饰符? 返回类型 包名.类名.方法名(参数类型) 异常?)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>?</code> 表示该部分是可选的。</li>
<li><code>*</code> 是一个通配符，可以匹配任意字符（除.<code> </code>外）。</li>
<li><code>..</code> 是一个通配符，在不同位置有不同含义：<ul>
<li>在包名中：表示当前包及其所有子包。</li>
<li>在参数列表中：表示任意数量、任意类型的参数。</li>
</ul>
</li>
</ul>
<p><strong>语法分解与示例:</strong></p>
<ul>
<li><strong><code>修饰符</code> (可选)</strong>: 如<code>public</code>, <code>protected</code>, <code>private</code>。通常省略，表示匹配所有修饰符。<ul>
<li><code>execution(public * *(..))</code> - 匹配所有<code>public</code>方法。</li>
</ul>
</li>
<li><strong><code>返回类型</code> (必选)</strong>:<ul>
<li><code>*</code> - 匹配任意返回类型。</li>
<li><code>void</code> - 匹配返回类型为<code>void</code>的方法。</li>
<li><code>java.lang.String</code> - 匹配返回类型为<code>String</code>的方法。</li>
<li><code>execution(* com.example.service.UserService.*(..))</code> - 匹配<code>UserService</code>中任意返回类型的方法。</li>
</ul>
</li>
<li><strong><code>包名.类名.方法名</code> (包名和类名可选)</strong>:<ul>
<li><strong>完整匹配</strong>: <code>com.example.service.UserService.createUser</code></li>
<li><strong>类内所有方法</strong>: <code>com.example.service.UserService.*</code></li>
<li><strong>包内所有类的所有方法</strong>: <code>com.example.service.*.*</code></li>
<li><strong>包及其子包下所有类的所有方法</strong>: <code>com.example.service..*.*</code> ( <strong><code>..</code></strong> 在这里至关重要！)</li>
<li><strong>方法名通配符</strong>: <code>*</code> (所有方法), <code>get*</code> (所有以get开头的方法), <code>*ById</code> (所有以ById结尾的方法)。</li>
</ul>
</li>
<li><strong><code>参数类型</code> (必选)</strong>:<ul>
<li><code>()</code> - 匹配无参方法。</li>
<li><code>(..)</code> - 匹配任意数量、任意类型的参数 (<strong>最常用</strong>)。</li>
<li><code>(*)</code> - 匹配只有一个参数的方法，类型不限。</li>
<li><code>(String)</code> - 匹配只有一个<code>String</code>类型参数的方法。</li>
<li><code>(String, ..)</code> - 匹配第一个参数是<code>String</code>，后面有任意数量、任意类型参数的方法。</li>
</ul>
</li>
<li><strong><code>异常</code> (可选)</strong>: <code>throws</code>子句，匹配抛出特定异常的方法。很少使用。</li>
</ul>
<p><strong>实战组合示例:</strong></p>
<ul>
<li><strong>匹配 <code>UserService</code> 接口中的所有方法</strong>:<br><code>execution(* com.example.service.UserService.*(..))</code></li>
<li><strong>匹配 <code>service</code> 包及其所有子包下，所有类的所有方法</strong>:<br><code>execution(* com.example.service..*.*(..))</code></li>
<li><strong>匹配所有以 <code>Repository</code> 结尾的类中的所有方法</strong>:<br><code>execution(* com.example..*Repository.*(..))</code></li>
<li><strong>匹配任何返回 <code>String</code> 类型，并且以 <code>find</code> 开头的方法</strong>:<br><code>execution(String com.example..*.find*(..))</code></li>
</ul>
<hr>
<h4 id="2-3-2-within-匹配指定类型内的所有方法"><a href="#2-3-2-within-匹配指定类型内的所有方法" class="headerlink" title="2.3.2 within - 匹配指定类型内的所有方法"></a>2.3.2 <code>within</code> - 匹配指定类型内的所有方法</h4><p><code>within</code> 用于限定连接点必须在某个指定的类或包内。它比 <code>execution</code> 粒度更粗，不关心方法的具体签名。</p>
<ul>
<li><code>within(com.example.service.UserServiceImpl)</code> - 匹配 <code>UserServiceImpl</code> 类中的所有方法。</li>
<li><code>within(com.example.service.*)</code> - 匹配 <code>com.example.service</code> 包下所有类中的所有方法（<strong>不含子包</strong>）。</li>
<li><code>within(com.example.service..*)</code> - 匹配 <code>com.example.service</code> 包及其所有子包下所有类中的所有方法。</li>
</ul>
<p><strong><code>within</code> vs. <code>execution</code></strong>:</p>
<ul>
<li><code>within(com.example.service..*)</code> 与 <code>execution(* com.example.service..*.*(..))</code> 看起来相似，但 <code>execution</code> 更强大，可以进一步限制返回类型、方法名等。通常优先使用<code>execution</code>。</li>
</ul>
<hr>
<h4 id="2-3-3-annotation-匹配带有指定注解的方法"><a href="#2-3-3-annotation-匹配带有指定注解的方法" class="headerlink" title="2.3.3 @annotation - 匹配带有指定注解的方法"></a>2.3.3 <code>@annotation</code> - 匹配带有指定注解的方法</h4><p>这个指示符用于匹配那些<strong>方法本身</strong>被特定注解标记的连接点。</p>
<p><strong>场景</strong>：创建一个自定义注解 <code>@Loggable</code>，希望所有被此注解标记的方法都能被AOP记录日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Loggable &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务方法</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Loggable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">importantOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切点表达式</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.example.aop.annotation.Loggable)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loggableMethods</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-4-within-匹配带有指定注解的类中的所有方法"><a href="#2-3-4-within-匹配带有指定注解的类中的所有方法" class="headerlink" title="2.3.4 @within - 匹配带有指定注解的类中的所有方法"></a>2.3.4 <code>@within</code> - 匹配带有指定注解的类中的所有方法</h4><p><code>@within</code> 与 <code>@annotation</code> 的区别在于，它匹配的是<strong>类级别</strong>的注解。如果一个类被某个注解标记，那么这个类中的<strong>所有方法</strong>（连接点）都会被匹配。</p>
<p><strong>场景</strong>：创建一个注解 <code>@Secured</code>，希望所有被标记为<code>@Secured</code>的类中的所有方法都执行权限检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Secured &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Secured</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resetPassword</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切点表达式</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@within(com.example.aop.annotation.Secured)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">securedClassMethods</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样，<code>deleteUser()</code> 和 <code>resetPassword()</code> 都会被匹配。</li>
</ul>
<hr>
<h4 id="2-3-5-bean-匹配指定名称的Spring-Bean"><a href="#2-3-5-bean-匹配指定名称的Spring-Bean" class="headerlink" title="2.3.5 bean - 匹配指定名称的Spring Bean"></a>2.3.5 <code>bean</code> - 匹配指定名称的Spring Bean</h4><p>这是Spring AOP特有的指示符，用于根据Bean在容器中的ID&#x2F;name来匹配。</p>
<ul>
<li><code>bean(&quot;userServiceImpl&quot;)</code> - 匹配ID为 <code>userServiceImpl</code> 的Bean中的所有方法。</li>
<li><code>bean(&quot;*Service&quot;)</code> - 匹配所有ID以 <code>Service</code> 结尾的Bean中的所有方法。</li>
</ul>
<hr>
<h4 id="2-3-6-组合使用与最佳实践"><a href="#2-3-6-组合使用与最佳实践" class="headerlink" title="2.3.6 组合使用与最佳实践"></a>2.3.6 组合使用与最佳实践</h4><p>为了代码的可读性和可维护性，强烈建议使用 <code>@Pointcut</code> 定义可重用的切点，然后通过逻辑运算符组合它们。</p>
<p><strong>示例：</strong></p>
<p>假设我们要为一个所有 <code>service</code> 包下，被 <code>@Transactional</code> 注解标记的 <code>public</code> 方法记录性能日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerformanceAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义一个切点，匹配service包及其子包</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.example.service..*)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inServiceLayer</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 定义一个切点，匹配被@Transactional注解的方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionalMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 定义一个切点，匹配所有public方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 组合以上切点</span></span><br><span class="line">    <span class="meta">@Around(&quot;publicMethods() &amp;&amp; inServiceLayer() &amp;&amp; transactionalMethods()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">profile</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// ... 性能监控逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式比写一个超长的<code>@Around(&quot;execution(public * com.example.service..*.*(..)) &amp;&amp; @annotation(...)&quot;)</code>要清晰得多，并且每个切点都可以被其他通知复用。</p>
<hr>
<h4 id="总结表"><a href="#总结表" class="headerlink" title="总结表"></a>总结表</h4><table>
<thead>
<tr>
<th align="left">指示符</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>execution</code></strong></td>
<td align="left"><strong>匹配方法签名（最常用）</strong></td>
<td align="left"><code>execution(* com.example..*.*(..))</code></td>
</tr>
<tr>
<td align="left"><code>within</code></td>
<td align="left">匹配指定类型或包内的所有方法</td>
<td align="left"><code>within(com.example.service..*)</code></td>
</tr>
<tr>
<td align="left"><strong><code>@annotation</code></strong></td>
<td align="left"><strong>匹配被特定注解标记的方法</strong></td>
<td align="left"><code>@annotation(com.example.Loggable)</code></td>
</tr>
<tr>
<td align="left"><code>@within</code></td>
<td align="left">匹配被特定注解标记的类中的所有方法</td>
<td align="left"><code>@within(com.example.Secured)</code></td>
</tr>
<tr>
<td align="left"><code>bean</code></td>
<td align="left">匹配特定名称的Spring Bean</td>
<td align="left"><code>bean(*ServiceImpl)</code></td>
</tr>
<tr>
<td align="left"><code>args</code></td>
<td align="left">匹配参数类型为指定类型的连接点</td>
<td align="left"><code>args(String, ..)</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="2-4-连接点"><a href="#2-4-连接点" class="headerlink" title="2.4 连接点"></a>2.4 连接点</h3><p>当我们定义一个通知（Advice）时，可以声明一个<code>org.aspectj.lang.JoinPoint</code>类型的参数，Spring容器会自动将与该切点匹配的连接点信息注入进来。通过这个对象，我们可以在运行时获取到大量关于方法执行的上下文信息。</p>
<h4 id="2-4-1-JoinPoint-适用于所有通知类型"><a href="#2-4-1-JoinPoint-适用于所有通知类型" class="headerlink" title="2.4.1 JoinPoint (适用于所有通知类型)"></a>2.4.1 <code>JoinPoint</code> (适用于所有通知类型)</h4><h5 id="1-获取方法签名信息-getSignature"><a href="#1-获取方法签名信息-getSignature" class="headerlink" title="1. 获取方法签名信息 getSignature()"></a>1. 获取方法签名信息 <code>getSignature()</code></h5><p>这是最核心和最常用的方法，它返回一个<code>Signature</code>对象，包含了被拦截方法的详细信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br></pre></td></tr></table></figure>

<p><code>Signature</code>对象本身有很多有用的方法：</p>
<ul>
<li><p><strong><code>String getName()</code></strong>: 获取被拦截的方法名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName(); <span class="comment">// 例如：&quot;addUser&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>Class getDeclaringType()</code></strong>: 获取方法所属的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">declaringType</span> <span class="operator">=</span> signature.getDeclaringType(); <span class="comment">// 例如：class com.example.service.UserService</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>String getDeclaringTypeName()</code></strong>: 获取方法所属类的全限定名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">declaringTypeName</span> <span class="operator">=</span> signature.getDeclaringTypeName(); <span class="comment">// 例如：&quot;com.example.service.UserService&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>int getModifiers()</code></strong>: 获取方法的修饰符，返回的是一个代表修饰符的整数（例如 <code>public</code>, <code>static</code>）。可以使用 <code>java.lang.reflect.Modifier.toString()</code> 来转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> signature.getModifiers();</span><br><span class="line">System.out.println(Modifier.toString(modifiers)); <span class="comment">// 例如：&quot;public&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>String toShortString()</code></strong>: 返回一个简短的方法签名描述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">shortString</span> <span class="operator">=</span> signature.toShortString(); <span class="comment">// 例如：&quot;UserService.addUser(..)&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>String toLongString()</code></strong>: 返回一个详细的方法签名描述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">longString</span> <span class="operator">=</span> signature.toLongString(); <span class="comment">// 例如：&quot;public void com.example.service.UserService.addUser(com.example.model.User)&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-获取方法参数-getArgs"><a href="#2-获取方法参数-getArgs" class="headerlink" title="2. 获取方法参数 getArgs()"></a>2. 获取方法参数 <code>getArgs()</code></h5><p>获取传递给被拦截方法的参数数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object[] args = joinPoint.getArgs();</span><br><span class="line"><span class="comment">// 你可以遍历或直接访问参数</span></span><br><span class="line"><span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数: &quot;</span> + arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-获取目标和代理对象"><a href="#3-获取目标和代理对象" class="headerlink" title="3. 获取目标和代理对象"></a>3. 获取目标和代理对象</h5><ul>
<li><p><strong><code>Object getTarget()</code></strong>: 获取被代理的 <strong>目标对象</strong>（原始的Bean对象）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> joinPoint.getTarget(); <span class="comment">// 例如：UserServiceImpl 实例</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>Object getThis()</code></strong>: 获取 <strong>代理对象</strong> 本身。通常是CGLIB或JDK动态代理生成的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> joinPoint.getThis(); <span class="comment">// 例如：UserServiceImpl$$EnhancerBySpringCGLIB$$... 实例</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>getTarget()</code> 和 <code>getThis()</code> 返回的对象通常是不同的。<code>getTarget()</code> 是原始的业务逻辑类，而 <code>getThis()</code> 是Spring为了实现AOP而创建的代理类实例。</p>
</li>
</ul>
<hr>
<h5 id="4-其他静态信息"><a href="#4-其他静态信息" class="headerlink" title="4. 其他静态信息"></a>4. 其他静态信息</h5><ul>
<li><strong><code>StaticPart getStaticPart()</code></strong>: 提供对连接点的静态部分的访问，功能与 <code>getSignature()</code> 类似，但提供了更通用的Aspect静态信息。</li>
<li><strong><code>String getKind()</code></strong>: 获取连接点的类型。在Spring AOP中，这个值通常是 <code>method-execution</code>。</li>
</ul>
<hr>
<h4 id="2-4-2-ProceedingJoinPoint-仅适用于-Around环绕通知"><a href="#2-4-2-ProceedingJoinPoint-仅适用于-Around环绕通知" class="headerlink" title="2.4.2 ProceedingJoinPoint (仅适用于@Around环绕通知)"></a>2.4.2 <code>ProceedingJoinPoint</code> (仅适用于<code>@Around</code>环绕通知)</h4><p><code>ProceedingJoinPoint</code> 继承自 <code>JoinPoint</code>，因此它拥有上述所有方法。除此之外，它增加了一个至关重要的核心方法，用于控制目标方法的执行。</p>
<h4 id="Object-proceed-和-Object-proceed-Object-args"><a href="#Object-proceed-和-Object-proceed-Object-args" class="headerlink" title="Object proceed() 和 Object proceed(Object[] args)"></a><code>Object proceed()</code> 和 <code>Object proceed(Object[] args)</code></h4><p>这是<code>ProceedingJoinPoint</code>的专属方法，也是<code>@Around</code>通知如此强大的原因。</p>
<ul>
<li><strong><code>Object proceed()</code></strong>: 执行目标方法。调用此方法会触发目标方法的执行。其返回值就是目标方法的返回值。</li>
<li><strong><code>Object proceed(Object[] args)</code></strong>: 执行目标方法，并使用新的参数数组替换原有的参数。这允许你在执行目标方法前修改传入的参数。</li>
</ul>
<p><strong>核心作用</strong>:</p>
<ol>
<li><strong>执行控制</strong>: 你可以决定是否调用<code>proceed()</code>方法。如果不调用，目标方法将永远不会被执行。</li>
<li><strong>参数修改</strong>: 在调用<code>proceed(newArgs)</code>之前，可以修改参数。</li>
<li><strong>返回值修改</strong>: <code>proceed()</code>方法调用结束后，可以获取到原始返回值，并对其进行修改或替换，然后返回一个新的值。</li>
<li><strong>异常处理</strong>: 可以使用 <code>try-catch</code> 块来捕获目标方法抛出的异常，并进行处理或包装后重新抛出。</li>
</ol>
<p>一个典型的<code>@Around</code>通知结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;环绕通知：方法 &quot;</span> + pjp.getSignature().getName() + <span class="string">&quot; 开始执行...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        result = pjp.proceed(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 甚至可以在这里修改返回值</span></span><br><span class="line">        <span class="comment">// if (result instanceof String) &#123;</span></span><br><span class="line">        <span class="comment">//     result = &quot;Modified: &quot; + result;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知：方法 &quot;</span> + pjp.getSignature().getName() + <span class="string">&quot; 发生异常...&quot;</span>);</span><br><span class="line">        <span class="comment">// 决定是否向上抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> throwable; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知：方法 &quot;</span> + pjp.getSignature().getName() + <span class="string">&quot; 执行结束，耗时：&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-AOP的实现原理-JDK动态代理-vs-CGLIB"><a href="#2-5-AOP的实现原理-JDK动态代理-vs-CGLIB" class="headerlink" title="2.5 AOP的实现原理 (JDK动态代理 vs CGLIB)"></a>2.5 AOP的实现原理 (JDK动态代理 vs CGLIB)</h3><p>在Java笔记中的第三章4.8.3中我们详细介绍过了JDK与CGLIB，这里简单回顾一下</p>
<h4 id="2-5-1-JDK动态代理-“基于接口的伪装者”"><a href="#2-5-1-JDK动态代理-“基于接口的伪装者”" class="headerlink" title="2.5.1 JDK动态代理 - “基于接口的伪装者”"></a>2.5.1 JDK动态代理 - “基于接口的伪装者”</h4><ul>
<li><strong>核心机制</strong>：<strong>实现共同的接口</strong>。</li>
<li><strong>工作方式</strong>：Spring创建一个代理类，这个代理类和你真正的业务类（目标类）<strong>实现了相同的接口</strong>。当客户端代码调用接口方法时，实际上调用的是代理对象的方法。代理对象内部的<code>InvocationHandler</code>会先执行切面逻辑（Advice），然后再通过<strong>反射</strong>调用你真正的业务对象的方法。</li>
<li><strong>限制</strong>：你的业务类<strong>必须实现一个接口</strong>。Spring AOP只会代理接口中定义的方法，业务类中自己特有的方法不会被代理。</li>
<li><strong>Spring中的默认行为</strong>：如果一个Bean实现了至少一个接口，Spring AOP<strong>默认</strong>会选用JDK动态代理。</li>
</ul>
<p><strong>一句话总结：客户端面向接口编程，得到的是一个接口的“冒牌”实现类，这个冒牌货在完成核心任务前后会加一些额外的动作。</strong></p>
<hr>
<h4 id="2-5-2-CGLIB动态代理-“基于继承的增强者”"><a href="#2-5-2-CGLIB动态代理-“基于继承的增强者”" class="headerlink" title="2.5.2 CGLIB动态代理 - “基于继承的增强者”"></a>2.5.2 CGLIB动态代理 - “基于继承的增强者”</h4><ul>
<li><strong>核心机制</strong>：<strong>创建子类</strong>。</li>
<li><strong>工作方式</strong>：Spring使用CGLIB库，在运行时动态地创建一个你业务类（目标类）的<strong>子类</strong>作为代理。这个子类会<strong>重写</strong>父类中所有非<code>final</code>的方法。当调用这些方法时，子类中的<code>MethodInterceptor</code>会先执行切面逻辑，然后再调用父类（即你真正的业务对象）的原始方法。</li>
<li><strong>限制</strong>：你的业务类<strong>不能是 <code>final</code> 的</strong>，被代理的方法也<strong>不能是 <code>final</code> 的</strong>，否则子类无法继承或重写。</li>
<li><strong>Spring中的默认行为</strong>：如果一个Bean<strong>没有实现任何接口</strong>，Spring AOP<strong>别无选择</strong>，只能使用CGLIB。</li>
</ul>
<p><strong>一句话总结：客户端得到的是一个业务类的“增强版”子类，这个子类在调用从父类继承来的方法时，会加入额外的切面逻辑。</strong></p>
<hr>
<h4 id="2-5-3-Spring-Boot中的选择与演变"><a href="#2-5-3-Spring-Boot中的选择与演变" class="headerlink" title="2.5.3 Spring Boot中的选择与演变"></a>2.5.3 Spring Boot中的选择与演变</h4><ul>
<li><strong>SpringBoot 2.x 及以后，默认倾向于使用CGLIB</strong>。<ul>
<li>在<code>spring-boot-starter-aop</code>中，默认配置 <code>spring.aop.proxy-target-class=true</code>。</li>
<li>这意味着，<strong>无论你的Bean是否实现了接口，SpringBoot都默认优先使用CGLIB来创建代理</strong>。</li>
</ul>
</li>
<li><strong>为什么会有这个变化？</strong><ol>
<li><strong>解决了类型转换问题</strong>：如果使用JDK代理，从容器中获取的代理对象不能被强制转换为其具体的实现类类型（只能转换为接口类型），有时会引发<code>ClassCastException</code>。而CGLIB代理是目标类的子类，不存在这个问题。</li>
<li><strong>代理类内调用问题</strong>：可以更好地处理在同一个类中的方法相互调用时，AOP可能失效的情况（虽然这个问题根源更复杂，但CGLIB在某些场景下表现更直观）。</li>
<li><strong>性能差异已忽略不计</strong>：现代JDK中两者的性能差异已经微乎其微。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-5-4-核心回顾表"><a href="#2-5-4-核心回顾表" class="headerlink" title="2.5.4 核心回顾表"></a>2.5.4 核心回顾表</h4><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left">JDK动态代理</th>
<th align="left">CGLIB动态代理</th>
<th align="left">Spring Boot默认</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心原理</strong></td>
<td align="left">实现接口</td>
<td align="left">继承父类</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>目标要求</strong></td>
<td align="left">必须有接口</td>
<td align="left">不能是final类&#x2F;方法</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>代理对象类型</strong></td>
<td align="left"><code>com.sun.proxy.$ProxyX</code></td>
<td align="left"><code>TargetClass$$EnhancerByCGLIB$$...</code></td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>Spring选择</strong></td>
<td align="left">目标<strong>有</strong>接口时默认使用</td>
<td align="left">目标<strong>无</strong>接口时使用</td>
<td align="left"><strong>优先使用CGLIB</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="3-事务管理"><a href="#3-事务管理" class="headerlink" title="3. 事务管理"></a>3. 事务管理</h2><h3 id="3-1-声明式事务"><a href="#3-1-声明式事务" class="headerlink" title="3.1 声明式事务"></a>3.1 声明式事务</h3><p>旨在<strong>将事务管理代码从业务逻辑中彻底分离出去</strong>。我们只需通过一个简单的<strong>注解</strong>来“声明”某个方法需要事务，而具体的事务管理工作全部交给Spring框架在“幕后”完成。</p>
<p>这正是AOP思想的体现：<strong>事务管理</strong>就是一个典型的<strong>横切关注点</strong>。</p>
<p><strong><code>@Transactional</code> 注解：声明式事务的核心</strong></p>
<p><code>@Transactional</code> 是Spring提供的核心注解，用于声明事务。当它被应用到一个<strong>public方法</strong>上时，Spring AOP就会为这个方法（或者整个类）创建一个代理，自动地在方法执行前后添加事务管理逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegistrationService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProfileRepository profileRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 只需这一个注解！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(User user, Profile profile)</span> &#123;</span><br><span class="line">        <span class="comment">// --- 纯粹的业务逻辑 ---</span></span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果这里发生异常，整个事务会自动回滚</span></span><br><span class="line">        <span class="keyword">if</span> (profile.getBio().contains(<span class="string">&quot;error&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Simulated error during profile creation!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        profileRepository.save(profile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>工作原理（AOP的应用）</strong></p>
<ol>
<li>Spring容器在启动时，发现<code>UserRegistrationService</code>的<code>registerUser</code>方法上带有<code>@Transactional</code>注解。</li>
<li>Spring AOP会为<code>UserRegistrationService</code>创建一个<strong>代理对象</strong>。</li>
<li>当外部代码调用<code>registerUser</code>方法时，实际上调用的是这个<strong>代理对象</strong>的同名方法。</li>
<li>代理对象的方法内部逻辑大致如下：<ul>
<li><strong>方法执行前</strong>：开启事务 (<code>BEGIN TRANSACTION</code>)。</li>
<li><strong>调用原始的业务方法</strong>：即你写的<code>userRepository.save(user)</code>等代码。</li>
<li><strong>方法执行后</strong>：<ul>
<li>如果业务方法<strong>正常执行完毕</strong>（没有抛出异常），则<strong>提交事务</strong> (<code>COMMIT</code>)。</li>
<li>如果业务方法<strong>抛出了<code>RuntimeException</code>或<code>Error</code></strong>，则<strong>回滚事务</strong> (<code>ROLLBACK</code>)。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-2-事务的核心属性"><a href="#3-2-事务的核心属性" class="headerlink" title="3.2 事务的核心属性"></a>3.2 <strong>事务的核心属性</strong></h3><h4 id="3-2-1-传播行为"><a href="#3-2-1-传播行为" class="headerlink" title="3.2.1 传播行为"></a>3.2.1 传播行为</h4><h5 id="1-核心问题"><a href="#1-核心问题" class="headerlink" title="1. 核心问题"></a>1. 核心问题</h5><p>事务传播行为要回答的核心问题是：</p>
<blockquote>
<p>当一个已经处于事务上下文中的方法（我们称之为<strong>外部方法</strong>），去调用另一个也配置了事务的方法（我们称之为<strong>内部方法</strong>）时，内部方法的事务应该如何表现？是加入外部方法的现有事务，还是自己创建一个新的事务？</p>
</blockquote>
<p>这个行为定义了事务边界如何跨越多个方法调用进行“传播”。</p>
<p>在 <code>@Transactional</code> 注解中，通过 <code>propagation</code> 属性来设置，其值是 <code>Propagation</code> 枚举。</p>
<p>这七种行为可以分为三类：<strong>支持型</strong>、<strong>独立型</strong>和<strong>嵌套型</strong>。</p>
<hr>
<h5 id="2-支持型（默认行为）"><a href="#2-支持型（默认行为）" class="headerlink" title="2. 支持型（默认行为）"></a>2. 支持型（默认行为）</h5><p>这类行为倾向于加入已存在的事务。</p>
<h6 id="a-Propagation-REQUIRED-默认值"><a href="#a-Propagation-REQUIRED-默认值" class="headerlink" title="a). Propagation.REQUIRED (默认值)"></a>a). <code>Propagation.REQUIRED</code> (默认值)</h6><ul>
<li><strong>含义</strong>：<strong>需要事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>如果当前已经存在一个事务（外部方法带来了事务），那么内部方法就<strong>加入</strong>这个已存在的事务。它们在同一个事务中运行，要么一起成功提交，要么一起失败回滚。</li>
<li>如果当前不存在事务，那么就为内部方法<strong>创建一个新的事务</strong>。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<strong>绝大多数（超过95%）的业务场景</strong>。它是最常用、最合理的默认行为。例如，一个<code>updateOrder</code>方法调用<code>decreaseStock</code>和<code>updateUserBalance</code>，这三个操作必须在同一个事务中。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span> <span class="comment">// 默认，可省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 创建订单操作 ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用stockService的方法，它会加入createOrder的事务</span></span><br><span class="line">        stockService.decreaseStock(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span> <span class="comment">// 默认</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decreaseStock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 扣减库存操作 ...</span></span><br><span class="line">        <span class="comment">// 如果这里失败，整个createOrder事务都会回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="b-Propagation-SUPPORTS"><a href="#b-Propagation-SUPPORTS" class="headerlink" title="b). Propagation.SUPPORTS"></a>b). <code>Propagation.SUPPORTS</code></h6><ul>
<li><strong>含义</strong>：<strong>支持事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>如果当前存在事务，则<strong>加入</strong>该事务。</li>
<li>如果当前没有事务，则以<strong>非事务</strong>的方式继续运行。</li>
</ul>
</li>
<li><strong>适用场景</strong>：通常用于那些<strong>不关心事务</strong>，但如果能运行在事务中也无妨的方法，比如一些<strong>只读的查询</strong>操作。</li>
</ul>
<h6 id="c-Propagation-MANDATORY"><a href="#c-Propagation-MANDATORY" class="headerlink" title="c). Propagation.MANDATORY"></a>c). <code>Propagation.MANDATORY</code></h6><ul>
<li><strong>含义</strong>：<strong>强制需要事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>如果当前存在事务，则<strong>加入</strong>该事务。</li>
<li>如果当前没有事务，则<strong>抛出异常</strong> (<code>IllegalTransactionStateException</code>)。</li>
</ul>
</li>
<li><strong>适用场景</strong>：很少使用。用于那些必须在特定事务上下文中执行的工具类或辅助方法，以确保它们不会被错误地在事务外部调用。</li>
</ul>
<hr>
<h5 id="3-独立型"><a href="#3-独立型" class="headerlink" title="3. 独立型"></a>3. 独立型</h5><p>这类行为总是试图独立于外部事务运行。</p>
<h6 id="a-Propagation-REQUIRES-NEW"><a href="#a-Propagation-REQUIRES-NEW" class="headerlink" title="a). Propagation.REQUIRES_NEW"></a>a). <code>Propagation.REQUIRES_NEW</code></h6><ul>
<li><strong>含义</strong>：<strong>需要新事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>无论当前是否存在事务，它<strong>总是创建一个全新的、独立的事务</strong>。</li>
<li>如果当前存在事务（外部事务），则会将外部事务<strong>挂起 (suspend)</strong>，直到这个新事务完成（提交或回滚）。新事务完成后，再恢复外部事务。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>日志记录</strong>：你可能希望记录操作日志的这个动作<strong>必须成功</strong>，即使主业务操作最终失败回滚。例如，记录一次“尝试支付”的日志，无论支付成功与否，这条日志都应该被保存。</li>
<li><strong>独立的审计或消息发送</strong>：确保某些与主业务逻辑解耦的操作能够独立提交。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ... 核心支付逻辑，可能会失败 ...</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Payment failed!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论支付成功与否，都尝试记录日志</span></span><br><span class="line">            <span class="comment">// logService.logAttempt() 会开启一个新事务，独立于processPayment的事务</span></span><br><span class="line">            logService.logAttempt(<span class="string">&quot;some_payment_info&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="comment">// 即使processPayment事务回滚了，这个新事务也会独立提交</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAttempt</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 将日志信息写入数据库 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="b-Propagation-NOT-SUPPORTED"><a href="#b-Propagation-NOT-SUPPORTED" class="headerlink" title="b). Propagation.NOT_SUPPORTED"></a>b). <code>Propagation.NOT_SUPPORTED</code></h6><ul>
<li><strong>含义</strong>：<strong>不支持事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>总是以<strong>非事务</strong>的方式运行。</li>
<li>如果当前存在事务，则将外部事务<strong>挂起</strong>。</li>
</ul>
</li>
<li><strong>适用场景</strong>：当一个方法内部有大量的、长时间运行的、且不需要事务的非DB操作时（例如，调用外部API、进行复杂计算），可以用来临时跳出事务，避免长时间占用数据库连接。</li>
</ul>
<h6 id="c-Propagation-NEVER"><a href="#c-Propagation-NEVER" class="headerlink" title="c). Propagation.NEVER"></a>c). <code>Propagation.NEVER</code></h6><ul>
<li><strong>含义</strong>：<strong>绝不需要事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>总是以<strong>非事务</strong>的方式运行。</li>
<li>如果当前存在事务，则<strong>抛出异常</strong>。</li>
</ul>
</li>
<li><strong>适用场景</strong>：非常罕见。用于确保某些方法绝对不会在事务中被调用。</li>
</ul>
<hr>
<h5 id="4-嵌套型"><a href="#4-嵌套型" class="headerlink" title="4. 嵌套型"></a>4. 嵌套型</h5><h6 id="a-Propagation-NESTED"><a href="#a-Propagation-NESTED" class="headerlink" title="a). Propagation.NESTED"></a>a). <code>Propagation.NESTED</code></h6><ul>
<li><strong>含义</strong>：<strong>嵌套事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>如果当前存在事务，则创建一个<strong>嵌套事务</strong>，它“嵌套”在外部事务中。</li>
<li>如果当前没有事务，则行为与 <code>REQUIRED</code> 相同（创建一个新事务）。</li>
</ul>
</li>
<li><strong>嵌套事务的特点 (Savepoint)</strong>：<ul>
<li>嵌套事务是外部事务的一个<strong>子事务</strong>。</li>
<li>它有自己独立的<strong>保存点 (Savepoint)</strong>。</li>
<li><strong>内部（嵌套）事务的回滚不会影响外部事务</strong>。外部事务可以捕获内部事务的异常并继续执行。</li>
<li><strong>外部事务的回滚一定会导致所有嵌套事务的回滚</strong>。</li>
</ul>
</li>
<li><strong><code>NESTED</code> vs. <code>REQUIRES_NEW</code></strong><ul>
<li><code>REQUIRES_NEW</code> 创建的是一个<strong>完全独立</strong>的事务，使用独立的数据库连接。</li>
<li><code>NESTED</code> 创建的是一个<strong>依赖于外部事务</strong>的子事务，共享同一个数据库连接。</li>
</ul>
</li>
<li><strong>注意事项</strong>：并非所有数据库或JDBC驱动都支持嵌套事务（Savepoint）。需要数据库提供支持。</li>
</ul>
<hr>
<h5 id="5-总结表"><a href="#5-总结表" class="headerlink" title="5. 总结表"></a>5. 总结表</h5><table>
<thead>
<tr>
<th align="left">传播行为</th>
<th align="left">当前有事务</th>
<th align="left">当前无事务</th>
<th align="left">主要应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>REQUIRED</code></strong></td>
<td align="left"><strong>加入事务</strong></td>
<td align="left"><strong>创建新事务</strong></td>
<td align="left"><strong>绝大多数业务场景（默认）</strong></td>
</tr>
<tr>
<td align="left"><code>SUPPORTS</code></td>
<td align="left">加入事务</td>
<td align="left">非事务运行</td>
<td align="left">不关心事务的查询等</td>
</tr>
<tr>
<td align="left"><code>MANDATORY</code></td>
<td align="left">加入事务</td>
<td align="left">抛出异常</td>
<td align="left">必须在事务中运行的工具方法</td>
</tr>
<tr>
<td align="left"><strong><code>REQUIRES_NEW</code></strong></td>
<td align="left"><strong>挂起当前，创建新事务</strong></td>
<td align="left"><strong>创建新事务</strong></td>
<td align="left"><strong>日志、审计等需要独立提交的场景</strong></td>
</tr>
<tr>
<td align="left"><code>NOT_SUPPORTED</code></td>
<td align="left">挂起当前，非事务运行</td>
<td align="left">非事务运行</td>
<td align="left">跳出事务执行非DB耗时操作</td>
</tr>
<tr>
<td align="left"><code>NEVER</code></td>
<td align="left">抛出异常</td>
<td align="left">非事务运行</td>
<td align="left">确保方法不在事务中运行</td>
</tr>
<tr>
<td align="left"><strong><code>NESTED</code></strong></td>
<td align="left"><strong>创建嵌套事务(Savepoint)</strong></td>
<td align="left"><strong>创建新事务</strong></td>
<td align="left">需要部分回滚的复杂业务场景</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-2-2-隔离级别"><a href="#3-2-2-隔离级别" class="headerlink" title="3.2.2 隔离级别"></a>3.2.2 隔离级别</h4><h5 id="1-核心问题-1"><a href="#1-核心问题-1" class="headerlink" title="1. 核心问题"></a>1. 核心问题</h5><p>隔离级别要回答的核心问题是：</p>
<blockquote>
<p>在数据库系统<strong>并发</strong>运行时，一个事务中的操作对其他并发执行的事务的<strong>可见性</strong>有多高？或者说，一个事务应该在多大程度上与其他事务<strong>隔离</strong>开来？</p>
</blockquote>
<p>隔离级别本质上是在<strong>数据一致性</strong>和<strong>系统并发性能</strong>之间做出的一个权衡。</p>
<ul>
<li><strong>隔离级别越高</strong>：数据一致性越好，越能避免并发问题，但系统并发性能越差（因为需要更多的锁定机制）。</li>
<li><strong>隔离级别越低</strong>：系统并发性能越好，但可能引发各种数据不一致的问题。</li>
</ul>
<hr>
<h5 id="2-并发事务带来的三大问题"><a href="#2-并发事务带来的三大问题" class="headerlink" title="2. 并发事务带来的三大问题"></a>2. 并发事务带来的三大问题</h5><p>在讨论隔离级别之前，我们必须先理解如果没有隔离或隔离不当，会发生哪些问题。</p>
<h6 id="a-脏读-Dirty-Read"><a href="#a-脏读-Dirty-Read" class="headerlink" title="a). 脏读 (Dirty Read)"></a>a). 脏读 (Dirty Read)</h6><ul>
<li><strong>定义</strong>：一个事务（T1）读取到了另一个事务（T2）<strong>尚未提交</strong>的修改数据。如果T2最终<strong>回滚</strong>了，那么T1读取到的就是“脏”的、无效的数据。</li>
<li><strong>例子</strong>：<ol>
<li>T1 开始。</li>
<li>T2 开始，将某商品库存从 10 修改为 9。</li>
<li>T1 读取库存，得到 9。</li>
<li>T2 回滚（例如，因为用户支付失败）。库存恢复为 10。</li>
<li>T1 拿着错误的库存 9 进行了后续操作。</li>
</ol>
</li>
</ul>
<h6 id="b-不可重复读-Non-Repeatable-Read"><a href="#b-不可重复读-Non-Repeatable-Read" class="headerlink" title="b). 不可重复读 (Non-Repeatable Read)"></a>b). 不可重复读 (Non-Repeatable Read)</h6><ul>
<li><strong>定义</strong>：在一个事务（T1）内，<strong>两次读取同一行数据</strong>，但得到的结果却不一样。这是因为在两次读取之间，另一个事务（T2）<strong>提交了对这行数据的修改</strong>。</li>
<li><strong>重点</strong>：问题出在<strong>同一行数据</strong>的**修改（UPDATE）**上。</li>
<li><strong>例子</strong>：<ol>
<li>T1 开始，读取商品A的价格为 100 元。</li>
<li>T2 开始，将商品A的价格修改为 120 元，并<strong>提交</strong>。</li>
<li>T1 <strong>在同一个事务内</strong>再次读取商品A的价格，发现价格变成了 120 元。</li>
<li>T1 发现自己事务内的数据“不翼而飞”地变了，导致后续计算可能出错。</li>
</ol>
</li>
</ul>
<h6 id="c-幻读-Phantom-Read"><a href="#c-幻读-Phantom-Read" class="headerlink" title="c). 幻读 (Phantom Read)"></a>c). 幻读 (Phantom Read)</h6><ul>
<li><strong>定义</strong>：在一个事务（T1）内，<strong>两次执行相同的范围查询</strong>，但第二次查询返回了<strong>更多的行</strong>。这是因为在两次查询之间，另一个事务（T2）<strong>插入了新的、符合该范围查询条件的行</strong>，并<strong>提交</strong>了。</li>
<li><strong>重点</strong>：问题出在<strong>一批数据</strong>的**新增（INSERT）或删除（DELETE）**上。看起来就像出现了“幻影”行。</li>
<li><strong>例子</strong>：<ol>
<li>T1 开始，查询所有年龄小于 30 岁的员工，得到 10 条记录。</li>
<li>T2 开始，插入一个 25 岁的新员工，并<strong>提交</strong>。</li>
<li>T1 <strong>在同一个事务内</strong>再次执行相同的查询（<code>SELECT * FROM employees WHERE age &lt; 30</code>），发现结果变成了 11 条记录。</li>
<li>T1 感到困惑，为什么会多出来一个“幻影”员工。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="3-四种标准隔离级别"><a href="#3-四种标准隔离级别" class="headerlink" title="3. 四种标准隔离级别"></a>3. 四种标准隔离级别</h5><p>为了解决上述问题，SQL标准定义了四种隔离级别。在Spring中，可以通过 <code>@Transactional(isolation = Isolation.XXX)</code> 来设置。</p>
<h6 id="a-Isolation-READ-UNCOMMITTED-读未提交"><a href="#a-Isolation-READ-UNCOMMITTED-读未提交" class="headerlink" title="a).Isolation.READ_UNCOMMITTED (读未提交)"></a>a).<code>Isolation.READ_UNCOMMITTED</code> (读未提交)</h6><ul>
<li><strong>隔离级别最低</strong>。</li>
<li><strong>行为</strong>：允许一个事务读取到另一个事务<strong>未提交</strong>的数据。</li>
<li><strong>解决的问题</strong>：无。</li>
<li><strong>引发的问题</strong>：<strong>脏读、不可重复读、幻读</strong>都可能发生。</li>
<li><strong>适用场景</strong>：几乎从不使用。只在对数据一致性要求极低，但对性能要求极高的场景下（如某些报表的近似统计）才可能考虑。</li>
</ul>
<h6 id="b-Isolation-READ-COMMITTED-读已提交"><a href="#b-Isolation-READ-COMMITTED-读已提交" class="headerlink" title="b). Isolation.READ_COMMITTED (读已提交)"></a>b). <code>Isolation.READ_COMMITTED</code> (读已提交)</h6><ul>
<li><strong>大多数数据库的默认隔离级别</strong> (如 Oracle, SQL Server, PostgreSQL)。</li>
<li><strong>行为</strong>：一个事务只能读取到其他事务<strong>已经提交</strong>的数据。</li>
<li><strong>解决的问题</strong>：<strong>避免了脏读</strong>。</li>
<li><strong>引发的问题</strong>：<strong>不可重复读、幻读</strong>仍然可能发生。</li>
<li><strong>实现原理</strong>：通常通过“读锁”或MVCC（多版本并发控制）实现。</li>
</ul>
<h6 id="c-Isolation-REPEATABLE-READ-可重复读"><a href="#c-Isolation-REPEATABLE-READ-可重复读" class="headerlink" title="c). Isolation.REPEATABLE_READ (可重复读)"></a>c). <code>Isolation.REPEATABLE_READ</code> (可重复读)</h6><ul>
<li><strong>MySQL InnoDB 引擎的默认隔离级别</strong>。</li>
<li><strong>行为</strong>：在一个事务开始时，它能看到的数据版本就被“固定”下来了。在该事务内，无论其他事务如何修改并提交数据，它多次读取同一行数据的结果都是一致的。</li>
<li><strong>解决的问题</strong>：<strong>避免了脏读、不可重复读</strong>。</li>
<li><strong>引发的问题</strong>：标准的<code>REPEATABLE_READ</code>级别仍然可能发生<strong>幻读</strong>。<ul>
<li><strong>但注意</strong>：MySQL的InnoDB引擎通过<strong>MVCC + Next-Key Locking</strong>技术，在<code>REPEATABLE_READ</code>级别下<strong>基本解决了幻读问题</strong>，使其表现得更像<code>SERIALIZABLE</code>。</li>
</ul>
</li>
<li><strong>实现原理</strong>：MVCC。</li>
</ul>
<h6 id="d-Isolation-SERIALIZABLE-可串行化"><a href="#d-Isolation-SERIALIZABLE-可串行化" class="headerlink" title="d). Isolation.SERIALIZABLE (可串行化)"></a>d). <code>Isolation.SERIALIZABLE</code> (可串行化)</h6><ul>
<li><strong>隔离级别最高</strong>。</li>
<li><strong>行为</strong>：强制事务串行执行。一个事务在操作某一批数据时，会完全锁定这些数据，其他事务必须等待其结束后才能访问。</li>
<li><strong>解决的问题</strong>：<strong>避免了脏读、不可重复读、幻读</strong>。</li>
<li><strong>引发的问题</strong>：<strong>并发性能极差</strong>。容易导致大量的超时和锁竞争。</li>
<li><strong>适用场景</strong>：只在对数据一致性要求极高，且并发量不大的场景下使用，例如银行的转账操作，但即使是银行，也通常通过其他机制（如行级锁、乐观锁）来避免使用此级别。</li>
</ul>
<hr>
<h5 id="4-总结与选择"><a href="#4-总结与选择" class="headerlink" title="4. 总结与选择"></a>4. 总结与选择</h5><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="center">脏读 (Dirty Read)</th>
<th align="center">不可重复读 (Non-Repeatable Read)</th>
<th align="center">幻读 (Phantom Read)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>READ_UNCOMMITTED</code></td>
<td align="center">允许</td>
<td align="center">允许</td>
<td align="center">允许</td>
</tr>
<tr>
<td align="left"><code>READ_COMMITTED</code></td>
<td align="center"><strong>禁止</strong></td>
<td align="center">允许</td>
<td align="center">允许</td>
</tr>
<tr>
<td align="left"><code>REPEATABLE_READ</code></td>
<td align="center"><strong>禁止</strong></td>
<td align="center"><strong>禁止</strong></td>
<td align="center">允许 (MySQL基本禁止)</td>
</tr>
<tr>
<td align="left"><code>SERIALIZABLE</code></td>
<td align="center"><strong>禁止</strong></td>
<td align="center"><strong>禁止</strong></td>
<td align="center"><strong>禁止</strong></td>
</tr>
</tbody></table>
<p><strong>最佳实践与建议：</strong></p>
<ol>
<li><strong>使用数据库的默认隔离级别</strong>：在绝大多数情况下，直接使用你的数据库（如MySQL的<code>REPEATABLE_READ</code>，Oracle的<code>READ_COMMITTED</code>）的默认隔离级别就足够了。这些默认设置是数据库厂商在性能和一致性之间做出的最佳平衡。</li>
<li><strong>非必要不修改</strong>：不要轻易在代码中通过 <code>@Transactional</code> 去修改隔离级别，除非你非常清楚你正在解决什么特定的并发问题，并且愿意承担由此带来的性能影响。</li>
<li><strong>理解你的数据库</strong>：了解你所使用的数据库在特定隔离级别下的具体实现机制（例如，了解MySQL的MVCC和Next-Key Lock）比死记硬背SQL标准更重要。</li>
<li><strong>优先使用乐观锁&#x2F;悲观锁</strong>：对于并发写操作非常频繁的“热点数据”，与其提升整个事务的隔离级别，不如使用更细粒度的<strong>乐观锁</strong>（如版本号字段）或<strong>悲观锁</strong>（如<code>SELECT ... FOR UPDATE</code>）来解决并发冲突，这样对性能的影响更小。</li>
</ol>
<hr>
<h4 id="3-2-3-其他属性"><a href="#3-2-3-其他属性" class="headerlink" title="3.2.3 其他属性"></a>3.2.3 其他属性</h4><h5 id="1-readOnly-只读"><a href="#1-readOnly-只读" class="headerlink" title="1. readOnly (只读)"></a>1. <code>readOnly</code> (只读)</h5><ul>
<li><p><strong>属性定义</strong>: <code>boolean readOnly()</code></p>
</li>
<li><p><strong>默认值</strong>: <code>false</code></p>
</li>
<li><p><strong>核心作用</strong>: 这是一个<strong>性能优化提示</strong>。当你将一个事务标记为 <code>readOnly = true</code> 时，你是在告诉Spring和底层数据库：“这个事务中的所有操作都<strong>不会</strong>修改任何数据（只有SELECT查询）。”</p>
</li>
<li><p><strong>带来的好处</strong>:</p>
<ol>
<li><strong>数据库层面的优化</strong>: 某些数据库（如MySQL InnoDB）可以根据这个只读提示进行优化。例如，它可能不必为这个事务维护回滚所需的undo log，从而减少开销。</li>
<li><strong>避免不必要的脏检查</strong>: 在使用JPA&#x2F;Hibernate等ORM框架时，将事务设为只读可以避免框架进行不必要的“脏数据检查”（Dirty Checking），从而提升性能。</li>
<li><strong>代码可读性</strong>: 它清晰地向其他开发者表明，这个方法是一个查询方法，不应该包含任何写操作。</li>
</ol>
</li>
<li><p><strong>注意事项</strong>:</p>
<ul>
<li>这只是一个“提示”，不是强制约束。如果你在一个标记为<code>readOnly = true</code>的事务中执行了写操作（INSERT, UPDATE, DELETE），其行为取决于具体的数据库和事务管理器。有些可能会直接报错，有些可能会忽略这个提示。因此，它不能替代真正的权限控制。</li>
</ul>
</li>
<li><p><strong>最佳实践</strong>: <strong>强烈建议为所有只进行查询操作的Service方法添加 <code>@Transactional(readOnly = true)</code>。</strong></p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductRepository productRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询方法，标记为只读以优化性能</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">findProductById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作方法，使用默认的 readOnly = false</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">(String name, BigDecimal price)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">newProduct</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(name, price);</span><br><span class="line">        <span class="keyword">return</span> productRepository.save(newProduct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-timeout-超时"><a href="#2-timeout-超时" class="headerlink" title="2. timeout (超时)"></a>2. <code>timeout</code> (超时)</h5><ul>
<li><p><strong>属性定义</strong>: <code>int timeout()</code></p>
</li>
<li><p><strong>默认值</strong>: <code>-1</code> (表示使用底层事务系统的默认超时时间，通常意味着永不超时)</p>
</li>
<li><p><strong>核心作用</strong>: 设置事务允许执行的<strong>最大时长（秒）</strong>。如果事务在指定的时间内没有完成（提交或回滚），事务管理器将<strong>强制回滚</strong>该事务，并抛出<code>TransactionTimedOutException</code>。</p>
</li>
<li><p><strong>为什么需要它</strong>:</p>
<ul>
<li><strong>防止资源耗尽</strong>: 作为一个<strong>安全阀</strong>，它可以防止一个有问题的事务（例如，一个执行了死循环查询或遭遇死锁的事务）长时间占用数据库连接和锁资源，从而拖垮整个系统。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>对于那些可能涉及复杂计算、大量数据处理或调用外部慢速服务的事务，设置一个合理的超时时间是一种很好的保护措施。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReportGenerationService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个报表生成可能非常耗时，我们设置一个30秒的超时上限</span></span><br><span class="line">    <span class="meta">@Transactional(timeout = 30)</span></span><br><span class="line">    <span class="keyword">public</span> Report <span class="title function_">generateMonthlyReport</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 复杂的、可能耗时很长的数据库查询和计算 ...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟一个长时间操作</span></span><br><span class="line">            Thread.sleep(<span class="number">35000</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果执行到这里超过30秒，事务早已被回滚</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Report</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-回滚规则-rollbackFor-noRollbackFor"><a href="#3-回滚规则-rollbackFor-noRollbackFor" class="headerlink" title="3. 回滚规则 (rollbackFor, noRollbackFor)"></a>3. 回滚规则 (<code>rollbackFor</code>, <code>noRollbackFor</code>)</h5><p>这是<code>@Transactional</code>中一个非常重要且容易出错的配置，因为它定义了<strong>什么样的异常会触发事务回滚</strong>。</p>
<ul>
<li><strong>Spring的默认回滚行为</strong>:<ul>
<li>当方法抛出 <strong><code>RuntimeException</code></strong> (非受检异常) 或 <strong><code>Error</code></strong> 时，<strong>默认回滚</strong>事务。</li>
<li>当方法抛出 <strong><code>Exception</code></strong> (受检异常，即必须<code>try-catch</code>或<code>throws</code>的异常) 时，<strong>默认不回滚</strong>事务。</li>
</ul>
</li>
<li><strong>为什么有这个默认行为</strong>:<ul>
<li>这是一种设计哲学。Spring认为<code>RuntimeException</code>通常代表了程序中的意外错误（bug），状态很可能已经不一致，回滚是保证数据安全的唯一方式。而受检<code>Exception</code>通常代表了可预期的、业务逻辑上的一种情况（如“余额不足异常”），在这种情况下，开发者可能希望即使有异常，之前的某些操作也依然被提交。</li>
</ul>
</li>
</ul>
<h6 id="a-rollbackFor-和-rollbackForClassName"><a href="#a-rollbackFor-和-rollbackForClassName" class="headerlink" title="a) rollbackFor 和 rollbackForClassName"></a>a) <code>rollbackFor</code> 和 <code>rollbackForClassName</code></h6><ul>
<li><p><strong>核心作用</strong>: 告诉Spring，除了默认的<code>RuntimeException</code>和<code>Error</code>，当遇到<strong>指定的异常类型时，也应该回滚</strong>事务。</p>
</li>
<li><p><strong>适用场景</strong>: 最常见的场景就是当你自定义了一个受检异常，并希望它能触发回滚。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义一个受检异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsufficientStockException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InsufficientStockException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">// 默认情况下，抛出 InsufficientStockException 不会回滚</span></span><br><span class="line">    <span class="comment">// 我们用 rollbackFor 来改变这个行为</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = InsufficientStockException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Long productId, <span class="type">int</span> quantity)</span> <span class="keyword">throws</span> InsufficientStockException &#123;</span><br><span class="line">        <span class="comment">// 1. 减少库存</span></span><br><span class="line">        stockService.decreaseStock(productId, quantity); <span class="comment">// 这个方法可能会抛出 InsufficientStockException</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建订单记录</span></span><br><span class="line">        orderRepository.create(...);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 decreaseStock 抛出异常，因为配置了 rollbackFor，</span></span><br><span class="line">        <span class="comment">// 即使它是受检异常，整个事务也会回滚。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="b-noRollbackFor-和-noRollbackForClassName"><a href="#b-noRollbackFor-和-noRollbackForClassName" class="headerlink" title="b) noRollbackFor 和 noRollbackForClassName"></a>b) <code>noRollbackFor</code> 和 <code>noRollbackForClassName</code></h6><ul>
<li><p><strong>核心作用</strong>: 告诉Spring，当遇到<strong>指定的异常类型时，不应该回滚</strong>事务，即使它是默认会回滚的<code>RuntimeException</code>。</p>
</li>
<li><p><strong>适用场景</strong>: 比较少见。用于某些特殊的业务场景，即某个非关键性操作的失败不应该影响主流程的提交。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 假设 RecordNotFoundException 是一个 RuntimeException</span></span><br><span class="line">    <span class="comment">// 我们希望即使更新积分失败，用户创建操作也应该成功</span></span><br><span class="line">    <span class="meta">@Transactional(noRollbackFor = RecordNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUserAndAddBonusPoints</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建用户（关键操作）</span></span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 为推荐人增加积分（非关键操作）</span></span><br><span class="line">            <span class="comment">// 这个方法如果找不到推荐人，可能会抛出 RecordNotFoundException</span></span><br><span class="line">            pointsService.addPointsForReferrer(user.getReferrerId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RecordNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获异常，记录日志，但不希望它回滚上面的 userRepository.save(user)</span></span><br><span class="line">            log.warn(<span class="string">&quot;Referrer not found, bonus points not added. But user creation is successful.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-总结表"><a href="#4-总结表" class="headerlink" title="4. 总结表"></a>4. 总结表</h5><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">默认值</th>
<th align="left">主要用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>readOnly</code></strong></td>
<td align="left"><code>false</code></td>
<td align="left"><strong>性能优化</strong>。标记只读查询，建议所有查询方法都使用。</td>
</tr>
<tr>
<td align="left"><strong><code>timeout</code></strong></td>
<td align="left"><code>-1</code></td>
<td align="left"><strong>安全保护</strong>。防止事务长时间运行，耗尽系统资源。</td>
</tr>
<tr>
<td align="left"><strong><code>rollbackFor</code></strong></td>
<td align="left"><code>{}</code></td>
<td align="left"><strong>改变默认回滚规则</strong>。添加需要触发回滚的异常类型（通常是受检异常）。</td>
</tr>
<tr>
<td align="left"><strong><code>noRollbackFor</code></strong></td>
<td align="left"><code>{}</code></td>
<td align="left"><strong>改变默认回滚规则</strong>。添加即使发生也不触发回滚的异常类型（通常是运行时异常）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-3-Transactional-失效的经典场景"><a href="#3-3-Transactional-失效的经典场景" class="headerlink" title="3.3 @Transactional 失效的经典场景"></a>3.3 <code>@Transactional</code> 失效的经典场景</h3><h4 id="3-3-1-应用在非-public-方法上"><a href="#3-3-1-应用在非-public-方法上" class="headerlink" title="3.3.1 应用在非 public 方法上"></a>3.3.1 应用在非 <code>public</code> 方法上</h4><ul>
<li><p><strong>现象</strong>：将 <code>@Transactional</code> 注解放在 <code>private</code>, <code>protected</code>, 或包可见（default）的方法上。</p>
</li>
<li><p><strong>原因</strong>：Spring AOP的实现原理是<strong>动态代理</strong>。无论是JDK动态代理还是CGLIB，它们都是通过创建一个代理类来<strong>重写（override）或实现</strong>目标方法，并在其中织入事务逻辑。</p>
<ul>
<li><code>private</code> 方法：无法被子类重写，也无法被外部的代理类调用。</li>
<li><code>protected</code> &#x2F; <code>default</code> 方法：虽然可以被子类重写，但Spring的代理机制为了保持一致性和减少复杂性，其AOP拦截器默认只为 <code>public</code> 方法创建代理。</li>
</ul>
</li>
<li><p><strong>结论</strong>：Spring AOP会<strong>静默地忽略</strong>非 <code>public</code> 方法上的 <code>@Transactional</code> 注解，事务不会生效，也不会有任何错误提示。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 生效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 将被忽略，事务无效！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-3-2-方法内部调用（“自调用”问题）"><a href="#3-3-2-方法内部调用（“自调用”问题）" class="headerlink" title="3.3.2 方法内部调用（“自调用”问题）"></a>3.3.2 方法内部调用（“自调用”问题）</h4><ul>
<li><p><strong>现象</strong>：在同一个类中，一个没有 <code>@Transactional</code> 注解的方法 <code>a()</code>，调用了本类中另一个带有 <code>@Transactional</code> 注解的方法 <code>b()</code>。</p>
</li>
<li><p><strong>原因</strong>：<strong>这是最常见、最隐蔽的失效场景</strong>。当外部代码调用 <code>a()</code> 方法时，它通过的是Spring的代理对象。但在 <code>a()</code> 方法内部，当执行 <code>this.b()</code> 或直接 <code>b()</code> 时，这里的 <code>this</code> 指向的是<strong>原始的目标对象实例</strong>，而不是代理对象。因此，<code>b()</code> 方法的调用是<strong>直接的内部方法调用</strong>，完全绕过了代理对象，AOP拦截器自然也就没有机会介入来开启事务。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123; <span class="comment">// 外部调用这个方法</span></span><br><span class="line">        <span class="comment">// ...一些准备工作...</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.placeOrder(); <span class="comment">// &lt;-- 问题所在！这里是内部调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 这个事务不会生效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...数据库操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong>：</p>
<ol>
<li><p><strong>推荐：将事务方法移到另一个Bean中</strong>。让 <code>OrderService</code> 注入一个新的 <code>OrderPlacementService</code>，然后调用 <code>orderPlacementService.placeOrder()</code>。</p>
</li>
<li><p><strong>在同一个类中解决</strong>：注入自己。在 <code>OrderService</code> 中注入 <code>OrderService</code> 自身的一个代理实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService selfProxy; <span class="comment">// 注入自身的代理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        selfProxy.placeOrder(); <span class="comment">// 通过代理对象调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(这种方法需要配置 <code>spring.main.allow-circular-references=true</code> 并在注入点上使用 <code>@Lazy</code>)</p>
</li>
<li><p><strong>使用 <code>AopContext.currentProxy()</code></strong>：获取当前线程绑定的代理对象来调用。<br><em>(需要开启 <code>expose-proxy=true</code>，代码侵入性较强)</em></p>
</li>
</ol>
</li>
</ul>
<hr>
<h4 id="3-3-3-异常被-try-catch-捕获且没有重新抛出"><a href="#3-3-3-异常被-try-catch-捕获且没有重新抛出" class="headerlink" title="3.3.3 异常被 try-catch 捕获且没有重新抛出"></a>3.3.3 异常被 <code>try-catch</code> 捕获且没有重新抛出</h4><ul>
<li><p><strong>现象</strong>：在 <code>@Transactional</code> 方法内部，一个可能导致回滚的异常被 <code>try-catch</code> 块捕获了，但在 <code>catch</code> 块中没有将异常重新抛出。</p>
</li>
<li><p><strong>原因</strong>：Spring的事务管理器是通过<strong>捕获从业务方法中抛出的异常</strong>来决定是否回滚事务的。如果你在方法内部把异常“吃掉”（handle）了，那么对于事务拦截器来说，这个方法就是<strong>正常返回</strong>的。既然是正常返回，它自然就会选择<strong>提交事务</strong>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            repository.save(data1);</span><br><span class="line">            <span class="comment">// 假设这里抛出了一个 RuntimeException</span></span><br><span class="line">            <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Something went wrong!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            repository.save(data2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// 异常被捕获了，没有继续向上抛出</span></span><br><span class="line">            log.error(<span class="string">&quot;An error occurred but we handled it.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法正常结束，事务将被提交！data1 的保存不会被回滚。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong>：</p>
<ul>
<li><p>在 <code>catch</code> 块中，如果你希望触发回滚，必须将异常重新抛出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Error occurred, rolling back.&quot;</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// 或者 throw new MyBusinessException(e);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者，在 <code>catch</code> 块中手动设置事务为回滚状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(这种方式耦合度较高，不推荐)</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-4-不正确的回滚规则配置-rollbackFor"><a href="#3-3-4-不正确的回滚规则配置-rollbackFor" class="headerlink" title="3.3.4 不正确的回滚规则配置 (rollbackFor)"></a>3.3.4 不正确的回滚规则配置 (<code>rollbackFor</code>)</h4><ul>
<li><p><strong>现象</strong>：方法抛出了一个<strong>受检异常 (Checked Exception)</strong>，但事务没有回滚。</p>
</li>
<li><p><strong>原因</strong>：如前所述，Spring<strong>默认只对 <code>RuntimeException</code> 和 <code>Error</code> 进行回滚</strong>。对于普通的 <code>Exception</code> 子类（如<code>IOException</code>, <code>SQLException</code>），Spring默认认为这是业务逻辑的一部分，不应该自动回滚。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 默认配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        repository.save(data);</span><br><span class="line">        <span class="comment">// 抛出受检异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;File not found!&quot;</span>);</span><br><span class="line">        <span class="comment">// 事务将不会回滚，data 会被提交到数据库！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong>：</p>
<ul>
<li>在 <code>@Transactional</code> 注解中明确使用 <code>rollbackFor</code> 属性，指定该受检异常也需要触发回滚。</li>
<li><code>@Transactional(rollbackFor = IOException.class)</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-5-数据库引擎不支持事务"><a href="#3-3-5-数据库引擎不支持事务" class="headerlink" title="3.3.5 数据库引擎不支持事务"></a>3.3.5 数据库引擎不支持事务</h4><ul>
<li><strong>现象</strong>：所有配置都正确，但事务就是不回滚。</li>
<li><strong>原因</strong>：你可能使用了不支持事务的数据库存储引擎。最典型的例子就是<strong>MySQL的MyISAM引擎</strong>。MyISAM引擎本身没有事务的概念，所有操作都是立即生效的，自然也就无所谓回滚。</li>
<li><strong>解决方案</strong>：<ul>
<li>检查你的数据库表结构，确保使用的存储引擎是支持事务的，如 <strong>InnoDB</strong> (MySQL的默认引擎)。</li>
<li><code>SHOW TABLE STATUS LIKE &#39;your_table_name&#39;;</code> 查看 <code>Engine</code> 列。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-6-总结表"><a href="#3-3-6-总结表" class="headerlink" title="3.3.6 总结表"></a>3.3.6 总结表</h4><table>
<thead>
<tr>
<th align="left">失效场景</th>
<th align="left">根本原因</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 非<code>public</code>方法</strong></td>
<td align="left">Spring AOP代理机制限制</td>
<td align="left">始终将<code>@Transactional</code>用在<code>public</code>方法上。</td>
</tr>
<tr>
<td align="left"><strong>2. 方法内部调用</strong></td>
<td align="left"><code>this</code>关键字调用绕过了代理对象</td>
<td align="left">将事务方法移到新Bean中；或注入自身代理。</td>
</tr>
<tr>
<td align="left"><strong>3. 异常被捕获</strong></td>
<td align="left">异常没有传播到代理层，被视为正常返回</td>
<td align="left">在<code>catch</code>块中重新抛出异常；或手动设置回滚。</td>
</tr>
<tr>
<td align="left"><strong>4. 回滚规则错误</strong></td>
<td align="left">默认不回滚受检异常(<code>Exception</code>)</td>
<td align="left">使用<code>rollbackFor</code>属性指定需要回滚的异常类型。</td>
</tr>
<tr>
<td align="left"><strong>5. 数据库引擎</strong></td>
<td align="left">底层存储引擎不支持事务</td>
<td align="left">确保使用支持事务的引擎，如MySQL的InnoDB。</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-4-编程式事务-vs-声明式事务"><a href="#3-4-编程式事务-vs-声明式事务" class="headerlink" title="3.4 编程式事务 vs 声明式事务"></a>3.4 编程式事务 vs 声明式事务</h3><h4 id="3-4-1-核心思想对比"><a href="#3-4-1-核心思想对比" class="headerlink" title="3.4.1 核心思想对比"></a>3.4.1 核心思想对比</h4><ul>
<li><strong>声明式事务 (Declarative Transaction Management)</strong><ul>
<li><strong>思想</strong>: <strong>“配置”而非“编码”</strong>。将事务管理视为一种<strong>横切关注点</strong>，通过AOP技术，将其从业务代码中完全分离。</li>
<li><strong>实现</strong>: 开发者使用注解（<code>@Transactional</code>）或XML配置来“声明”事务的边界和属性。Spring框架在运行时动态地创建代理，将事务逻辑织入到业务方法周围。</li>
<li><strong>开发者视角</strong>: 几乎感觉不到事务管理代码的存在，只需专注于业务逻辑。</li>
</ul>
</li>
<li><strong>编程式事务 (Programmatic Transaction Management)</strong><ul>
<li><strong>思想</strong>: <strong>“编码”而非“配置”</strong>。将事务管理作为业务逻辑的一部分，通过编写明确的代码来手动控制事务的生命周期。</li>
<li><strong>实现</strong>: Spring提供了一套API（主要是<code>TransactionTemplate</code>或<code>PlatformTransactionManager</code>），开发者在代码中直接调用这些API来开启、提交或回滚事务。</li>
<li><strong>开发者视角</strong>: 需要显式地编写事务控制代码，与业务逻辑混合在一起。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-4-2-编程式事务的实现方式"><a href="#3-4-2-编程式事务的实现方式" class="headerlink" title="3.4.2 编程式事务的实现方式"></a>3.4.2 编程式事务的实现方式</h4><p>Spring主要提供了两种编程式事务的实现方式。</p>
<h5 id="1-使用-TransactionTemplate-推荐的编程式方式"><a href="#1-使用-TransactionTemplate-推荐的编程式方式" class="headerlink" title="1. 使用 TransactionTemplate (推荐的编程式方式)"></a>1. 使用 <code>TransactionTemplate</code> (推荐的编程式方式)</h5><p><code>TransactionTemplate</code> 是Spring对编程式事务的封装，它使用了<strong>模板方法设计模式</strong>，简化了事务管理的样板代码。</p>
<ul>
<li><p><strong>工作方式</strong>: 你需要提供一个 <code>TransactionCallback</code> 的实现，在这个回调中编写你的业务逻辑。<code>TransactionTemplate</code> 会自动处理事务的开启、提交和异常时的回滚。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProgrammaticService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者直接注入 TransactionTemplate</span></span><br><span class="line">    <span class="comment">// @Autowired</span></span><br><span class="line">    <span class="comment">// private TransactionTemplate transactionTemplate;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performComplexOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TransactionTemplate</span> <span class="variable">transactionTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(transactionManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execute方法会自动处理事务</span></span><br><span class="line">        transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// --- 你的业务逻辑在这里 ---</span></span><br><span class="line">                repository.save(data1);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ... 更多复杂的逻辑 ...</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在这个回调中，你不需要手动commit</span></span><br><span class="line">                <span class="comment">// 如果没有异常抛出，模板会自动提交</span></span><br><span class="line">                repository.save(data2);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果需要手动回滚，可以这样做</span></span><br><span class="line">                <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 抛出异常，模板会自动回滚</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Operation failed&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果有返回值，在这里返回</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-直接使用-PlatformTransactionManager-更底层"><a href="#2-直接使用-PlatformTransactionManager-更底层" class="headerlink" title="2. 直接使用 PlatformTransactionManager (更底层)"></a>2. 直接使用 <code>PlatformTransactionManager</code> (更底层)</h5><p>这是最原始、最灵活的方式，你需要手动管理事务的每一个步骤。</p>
<ul>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLowLevelService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 定义事务属性</span></span><br><span class="line">        <span class="type">DefaultTransactionDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        <span class="comment">// def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 开启事务</span></span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(def);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// --- 业务逻辑 ---</span></span><br><span class="line">            repository.save(data1);</span><br><span class="line">            repository.save(data2);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 手动提交</span></span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 4. 手动回滚</span></span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Operation failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这种方式与原始的JDBC事务管理非常相似，只是API换成了Spring的。</p>
</li>
</ul>
<hr>
<h4 id="3-4-3-全面比较"><a href="#3-4-3-全面比较" class="headerlink" title="3.4.3 全面比较"></a>3.4.3 全面比较</h4><table>
<thead>
<tr>
<th align="left">对比维度</th>
<th align="left">声明式事务 (<code>@Transactional</code>)</th>
<th align="left">编程式事务 (<code>TransactionTemplate</code>)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>代码侵入性</strong></td>
<td align="left"><strong>极低</strong>。业务代码非常纯净，与事务逻辑完全解耦。</td>
<td align="left"><strong>较高</strong>。事务控制代码与业务逻辑紧密耦合在一起。</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left"><strong>极高</strong>。只需一个注解即可，简单明了。</td>
<td align="left"><strong>较低</strong>。需要编写更多的样板代码。</td>
</tr>
<tr>
<td align="left"><strong>可维护性</strong></td>
<td align="left"><strong>高</strong>。事务规则集中在注解中，易于查看和修改。</td>
<td align="left"><strong>低</strong>。事务逻辑分散在代码各处，难以统一管理。</td>
</tr>
<tr>
<td align="left"><strong>粒度控制</strong></td>
<td align="left"><strong>方法级别</strong>。事务边界只能定义在整个方法的开始和结束。</td>
<td align="left"><strong>代码块级别</strong>。可以非常精细地控制事务的边界，甚至可以在一个方法内开启多个不同的事务。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>绝大多数（99%）的业务场景</strong>。</td>
<td align="left"><strong>极少数需要精细控制事务边界的复杂场景</strong>。</td>
</tr>
<tr>
<td align="left"><strong>学习成本</strong></td>
<td align="left"><strong>低</strong>。只需理解注解和其属性即可。</td>
<td align="left"><strong>较高</strong>。需要熟悉<code>TransactionTemplate</code>或<code>PlatformTransactionManager</code>的API。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-4-4-什么时候应该考虑使用编程式事务？"><a href="#3-4-4-什么时候应该考虑使用编程式事务？" class="headerlink" title="3.4.4 什么时候应该考虑使用编程式事务？"></a>3.4.4 什么时候应该考虑使用编程式事务？</h4><p>尽管声明式事务如此优秀，但在一些极端情况下，编程式事务依然有其用武之地：</p>
<ol>
<li><strong>超细粒度的事务控制</strong>：<ul>
<li>当你需要在一个非常长的方法中，只对其中一小段代码块应用事务时。如果为整个方法开启事务，可能会导致数据库连接被长时间占用。</li>
<li><strong>示例</strong>：一个方法需要先从一个事务中读取配置数据，然后进行大量的、与数据库无关的计算（可能耗时几秒），最后再开启另一个新事务将计算结果写入数据库。</li>
</ul>
</li>
<li><strong>一个方法内涉及多个不同事务</strong>：<ul>
<li>当你需要在一个方法内，先执行一个事务并提交，然后根据其结果，再决定是否执行另一个完全独立的事务。这种场景用声明式事务很难实现。</li>
</ul>
</li>
<li><strong>动态决定事务属性</strong>：<ul>
<li>在运行时，根据不同的业务参数动态地决定事务的传播行为、隔离级别或超时时间。</li>
</ul>
</li>
</ol>
<p><strong>一个综合示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBatch</span><span class="params">(List&lt;Item&gt; items)</span> &#123;</span><br><span class="line">    <span class="comment">// 步骤1：在一个只读事务中，加载所有需要的配置</span></span><br><span class="line">    <span class="type">TransactionTemplate</span> <span class="variable">readOnlyTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(transactionManager);</span><br><span class="line">    readOnlyTemplate.setReadOnly(<span class="literal">true</span>);</span><br><span class="line">    Map&lt;String, Config&gt; configs = readOnlyTemplate.execute(status -&gt; loadConfigs());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2：大量的非DB计算</span></span><br><span class="line">    List&lt;Result&gt; results = performHeavyComputations(items, configs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤3：为每个结果开启一个独立的、需要新事务的写操作</span></span><br><span class="line">    <span class="type">TransactionTemplate</span> <span class="variable">requiresNewTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(transactionManager);</span><br><span class="line">    requiresNewTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Result result : results) &#123;</span><br><span class="line">        requiresNewTemplate.execute(status -&gt; &#123;</span><br><span class="line">            saveResult(result);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>这个复杂的场景，如果用声明式事务，会非常难以甚至无法实现。</em></p>
<p><strong>总结</strong></p>
<ul>
<li><strong>声明式事务</strong>是<strong>战略性</strong>工具，它定义了业务单元的宏观事务边界，是构建企业级应用的首选和标准。</li>
<li><strong>编程式事务</strong>是<strong>战术性</strong>工具，它提供了对事务的微观控制能力，是在特定、复杂的场景下解决声明式事务无法覆盖问题的“瑞士军刀”。</li>
</ul>
<p><strong>最佳实践</strong>：</p>
<p><strong>始终优先使用声明式事务。</strong> 只有当你明确遇到了声明式事务无法解决的细粒度控制问题时，才考虑在局部使用编程式事务作为补充。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/ORM%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/ORM%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">ORM框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-24 15:23:30" itemprop="dateCreated datePublished" datetime="2025-09-24T15:23:30+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 16:08:55" itemprop="dateModified" datetime="2025-10-17T16:08:55+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">数据库与持久化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><strong>ORM（Object-Relational Mapping，对象关系映射）</strong> 是一种编程技术，用于在<strong>关系型数据库</strong>和<strong>面向对象编程语言</strong>之间建立一座“桥梁”。它的核心思想是将数据库中的**关系数据（表、行、列）<strong>与程序中的</strong>对象（类、对象、属性）**进行自动化的映射。</p>
<p>简单来说，ORM 框架允许开发者<strong>使用操作对象的方式来操作数据库表</strong>，而无需手动编写繁琐、重复的 SQL 语句和 JDBC 代码。</p>
<ul>
<li><strong>O (Object):</strong> 指的是我们编程语言中的对象，例如一个 Java 类 <code>User</code>。</li>
<li><strong>R (Relational):</strong> 指的是关系型数据库，例如 MySQL 中的一张表 <code>users</code>。</li>
<li><strong>M (Mapping):</strong> 指的是 ORM 框架建立的映射规则，它告诉程序：<ul>
<li><code>User</code> 类 对应 <code>users</code> 表。</li>
<li><code>User</code> 类的 <code>id</code> 属性 对应 <code>users</code> 表的 <code>id</code> 字段。</li>
<li><code>User</code> 类的 <code>username</code> 属性 对应 <code>users</code> 表的 <code>username</code> 字段。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-核心优势"><a href="#2-核心优势" class="headerlink" title="2. 核心优势"></a>2. 核心优势</h2><p>在没有 ORM 的时代，我们使用原生 JDBC 来与数据库交互，代码通常是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：原生 JDBC 查询</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    conn = DriverManager.getConnection(...);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, username, password FROM users WHERE id = ?&quot;</span>;</span><br><span class="line">    ps = conn.prepareStatement(sql);</span><br><span class="line">    ps.setInt(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line">    rs = ps.executeQuery();</span><br><span class="line">    <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        user.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        user.setPassword(rs.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="comment">// ... 使用 user 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 繁琐的资源关闭</span></span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="literal">null</span>) rs.close();</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="literal">null</span>) ps.close();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>) conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 ORM 框架后，代码变得极其简洁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：使用 ORM 框架查询</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.findUserById(<span class="number">101</span>);</span><br><span class="line"><span class="comment">// ... 直接使用 user 对象</span></span><br></pre></td></tr></table></figure>

<p><strong>ORM 的主要优势：</strong></p>
<ol>
<li><strong>提高开发效率</strong>：将开发者从繁琐的 SQL 编写、参数设置、结果集映射等重复性劳动中解放出来，专注于业务逻辑。</li>
<li><strong>代码更简洁、可读性更高</strong>：用面向对象的方式操作数据，使得业务逻辑更加清晰。</li>
<li><strong>更好的可维护性</strong>：<ul>
<li><strong>解耦</strong>：将数据访问层与业务逻辑层解耦。</li>
<li><strong>易于修改</strong>：当数据库表结构发生微小变化时（如增加一个字段），通常只需修改映射关系和对象类，而不用深入到每个 SQL 语句中去修改。</li>
</ul>
</li>
<li><strong>数据库无关性</strong>：优秀的 ORM 框架支持多种数据库。当需要更换数据库时（如从 MySQL 切换到 PostgreSQL），通常只需修改配置文件，而无需修改大量的业务代码和 SQL 语句。</li>
<li><strong>内置高级功能</strong>：许多 ORM 框架内置了缓存、懒加载、事务管理等高级功能，简化了复杂应用的开发。</li>
</ol>
<hr>
<h2 id="3-ORM-的缺点与挑战"><a href="#3-ORM-的缺点与挑战" class="headerlink" title="3. ORM 的缺点与挑战"></a>3. ORM 的缺点与挑战</h2><ol>
<li><strong>性能开销</strong>：ORM 框架在对象和 SQL 之间增加了一个抽象层，这会带来一定的性能损失。对于性能要求极高的场景，手写优化的 SQL 可能效率更高。</li>
<li><strong>学习成本</strong>：需要学习 ORM 框架本身的使用方法、API 和配置。</li>
<li><strong>复杂查询的挑战</strong>：对于非常复杂的多表连接、统计报表等查询，使用 ORM 可能变得笨拙，甚至不如直接编写原生 SQL 灵活和高效。</li>
<li><strong>“黑盒”问题</strong>：ORM 可能会隐藏底层的 SQL 执行细节，导致开发者不清楚实际执行了哪些 SQL，可能会产生意料之外的性能问题（如下一节的 <code>N+1</code> 查询问题）。</li>
</ol>
<hr>
<hr>
<h1 id="二、MyBatis"><a href="#二、MyBatis" class="headerlink" title="二、MyBatis"></a>二、MyBatis</h1><h2 id="1-MyBatis简介与核心思想"><a href="#1-MyBatis简介与核心思想" class="headerlink" title="1. MyBatis简介与核心思想"></a>1. MyBatis简介与核心思想</h2><h3 id="1-1-定义与定位"><a href="#1-1-定义与定位" class="headerlink" title="1.1 定义与定位"></a>1.1 定义与定位</h3><p><strong>MyBatis</strong> 是一个优秀的 <strong>持久层框架</strong>，它支持自定义 SQL、存储过程以及高级映射。与传统的全自动 ORM 框架（如 Hibernate）不同，MyBatis 并非完全将开发者与 SQL 隔离开，而是让开发者能够完全掌控 SQL 的编写。因此，它通常被定位为 <strong>“半自动 ORM” (Semi-ORM)</strong> 或 <strong>“SQL 映射器” (SQL Mapper)</strong>。</p>
<p>它的核心任务是：将 <strong>Java 对象 (POJO)</strong> 与 <strong>SQL 语句</strong> 进行映射，从而将繁琐的 JDBC 操作（如创建连接、设置参数、处理结果集、关闭资源等）自动化，让开发者可以更专注于 SQL 本身。</p>
<hr>
<h3 id="1-2-核心思想"><a href="#1-2-核心思想" class="headerlink" title="1.2 核心思想"></a>1.2 核心思想</h3><h4 id="1-2-1-SQL-与代码分离，专注业务逻辑"><a href="#1-2-1-SQL-与代码分离，专注业务逻辑" class="headerlink" title="1.2.1 SQL 与代码分离，专注业务逻辑"></a>1.2.1 SQL 与代码分离，专注业务逻辑</h4><p>这是 MyBatis 最核心的思想。它主张将 SQL 语句从 Java 代码中抽离出来，统一配置在 XML 映射文件中（或使用注解）。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>解耦</strong>：业务逻辑（Java 代码）与数据访问逻辑（SQL）分离，使得代码更清晰、更易于维护。</li>
<li><strong>便于管理与优化</strong>：DBA 或 SQL 专家可以独立地审查和优化 SQL，而无需关心 Java 代码的实现细节。</li>
<li><strong>提高可维护性</strong>：当 SQL 逻辑需要调整时，通常只需要修改 XML 文件，而不需要重新编译 Java 代码。</li>
</ul>
<hr>
<h4 id="1-2-2-开发者完全掌控-SQL，提供极致灵活性"><a href="#1-2-2-开发者完全掌控-SQL，提供极致灵活性" class="headerlink" title="1.2.2 开发者完全掌控 SQL，提供极致灵活性"></a>1.2.2 开发者完全掌控 SQL，提供极致灵活性</h4><p>与 Hibernate (后续章节详细讲解) 这类全自动 ORM 框架自动生成 SQL 不同，MyBatis 将 SQL 的编写权完全交还给开发者。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>性能优化</strong>：开发者可以根据具体的业务场景编写最高效、最复杂的 SQL，包括多表连接、子查询、调用存储过程、使用数据库特性函数等。这对于性能要求极高的场景至关重要。</li>
<li><strong>应对复杂需求</strong>：对于复杂的报表查询或特定业务逻辑，自动生成的 SQL 往往难以满足需求或效率低下，手动编写 SQL 则能轻松应对。</li>
<li><strong>易于过渡</strong>：对于熟悉 SQL 的开发者来说，学习曲线非常平缓，可以快速上手。</li>
</ul>
<hr>
<h4 id="1-2-3-简化-JDBC-操作，实现优雅的数据访问"><a href="#1-2-3-简化-JDBC-操作，实现优雅的数据访问" class="headerlink" title="1.2.3 简化 JDBC 操作，实现优雅的数据访问"></a>1.2.3 简化 JDBC 操作，实现优雅的数据访问</h4><p>MyBatis 极大地简化了基于 JDBC 的编程模型，封装了所有冗余的“样板代码”。</p>
<p><strong>封装内容</strong>：</p>
<ul>
<li><strong>参数映射</strong>：自动将传入的 Java 对象属性映射到 SQL 语句的参数中（<code>PreparedStatement</code> 的 <code>?</code> 占位符）。</li>
<li><strong>结果集映射</strong>：自动将查询返回的结果集（<code>ResultSet</code>）映射到 Java 对象、List 或 Map 中。</li>
<li><strong>资源管理</strong>：自动处理数据库连接的获取、使用和关闭。</li>
<li><strong>异常处理</strong>：将 JDBC 的 <code>SQLException</code> 转换为更易于处理的非检查性异常。</li>
</ul>
<hr>
<h2 id="2-核心组件与工作流程"><a href="#2-核心组件与工作流程" class="headerlink" title="2. 核心组件与工作流程"></a>2. 核心组件与工作流程</h2><h3 id="2-1-核心组件"><a href="#2-1-核心组件" class="headerlink" title="2.1 核心组件"></a>2.1 核心组件</h3><p>MyBatis 的架构由几个核心组件构成，每个组件都扮演着不可或缺的角色。</p>
<ol>
<li><strong>Configuration (配置)</strong><ul>
<li><strong>描述</strong>：MyBatis 的所有配置信息都保存在一个 <code>Configuration</code> 对象中。它包含了从数据源、事务管理器到类型别名、映射器（Mapper）等所有设置。</li>
<li><strong>来源</strong>：通常由主配置文件 <code>mybatis-config.xml</code> 和各个映射文件 <code>*.xml</code> 解析而来。</li>
</ul>
</li>
<li><strong>SqlSessionFactoryBuilder (构建器)</strong><ul>
<li><strong>描述</strong>：这是一个“一次性”的类，它的唯一作用就是根据配置信息（通常是一个 XML 配置文件的输入流）来构建一个 <code>SqlSessionFactory</code>。一旦创建了 <code>SqlSessionFactory</code>，这个构建器就不再需要了。</li>
<li><strong>生命周期</strong>：方法作用域（用完即可丢弃）。</li>
</ul>
</li>
<li><strong>SqlSessionFactory (会话工厂)</strong><ul>
<li><strong>描述</strong>：这是 MyBatis 的核心入口，类似于一个数据库连接池的工厂。它的主要职责是创建 <code>SqlSession</code> 实例。由于 <code>SqlSessionFactory</code> 的创建过程需要解析 XML 并进行初始化，这是一个昂贵的操作，因此它在应用程序的整个生命周期中通常只存在一个实例（单例模式）。</li>
<li><strong>生命周期</strong>：应用作用域（Application Scope）。</li>
</ul>
</li>
<li><strong>SqlSession (会话)</strong><ul>
<li><strong>描述</strong>：这是应用程序与数据库进行交互的主要接口。你可以通过 <code>SqlSession</code> 实例来执行 SQL 命令、获取 Mapper 代理对象以及管理事务。它封装了底层的 JDBC 连接。</li>
<li><strong>重要特性</strong>：<strong><code>SqlSession</code> 是线程不安全的</strong>，因此绝不能在多个线程之间共享。最佳实践是将其生命周期限制在单个请求或方法作用域内，用完后必须关闭（<code>try-with-resources</code> 是一个很好的选择）。</li>
<li><strong>生命周期</strong>：请求或方法作用域。</li>
</ul>
</li>
<li><strong>Executor (执行器)</strong><ul>
<li><strong>描述</strong>：<code>SqlSession</code> 内部的真正执行者。所有 SQL 的执行（查询、更新、存储过程调用）都是由 <code>Executor</code> 完成的。它负责处理参数映射、SQL 动态解析、执行 SQL，并与缓存机制（一级缓存）紧密交互。</li>
<li><strong>类型</strong>：MyBatis 提供了几种执行器，如 <code>SimpleExecutor</code>（默认）、<code>ReuseExecutor</code>（重用 <code>PreparedStatement</code>）、<code>BatchExecutor</code>（批量执行）。</li>
</ul>
</li>
<li><strong>Mapped Statement (映射语句)</strong><ul>
<li><strong>描述</strong>：一个封装了单条 SQL 语句所有信息的对象，包括 SQL 文本、输入参数类型、输出结果类型等。它是在解析 XML 映射文件或注解时创建的。<code>Configuration</code> 对象中会有一个 Map 存储所有 <code>MappedStatement</code>，其键（key）通常是 <code>namespace + id</code>（例如 <code>com.example.UserMapper.selectById</code>）。</li>
</ul>
</li>
<li><strong>Handler (处理器)</strong><ul>
<li><strong>描述</strong>：MyBatis 底层使用一系列处理器来完成具体的 JDBC 操作。</li>
<li><strong><code>ParameterHandler</code></strong>：负责将用户传入的参数设置到 <code>PreparedStatement</code> 中。</li>
<li><strong><code>ResultSetHandler</code></strong>：负责将 <code>ResultSet</code> 的查询结果集转换成 Java 对象（POJO）。</li>
<li><strong><code>StatementHandler</code></strong>：负责封装和管理底层的 <code>java.sql.Statement</code> 操作，包括创建 <code>Statement</code>、设置参数和执行 SQL。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-2-工作流程"><a href="#2-2-工作流程" class="headerlink" title="2.2 工作流程"></a>2.2 工作流程</h3><p>下面以一次典型的查询调用（<code>userMapper.selectById(1)</code>）为例，串联起上述核心组件的工作流程。</p>
<p><strong>整体流程示例:</strong><code>应用程序 -&gt; SqlSession -&gt; Executor -&gt; StatementHandler -&gt; 数据库</code></p>
<p><strong>详细步骤:</strong></p>
<ol>
<li><strong>加载配置与初始化 (应用启动时)</strong><ul>
<li>应用程序通过 <code>SqlSessionFactoryBuilder</code> 读取 <code>mybatis-config.xml</code> 和所有映射器 XML 文件。</li>
<li><code>Builder</code> 解析这些文件，创建一个包含所有配置信息的 <code>Configuration</code> 对象。</li>
<li>最后，<code>Builder</code> 使用这个 <code>Configuration</code> 对象创建一个唯一的 <code>SqlSessionFactory</code> 实例。</li>
</ul>
</li>
<li><strong>创建 SqlSession (请求开始时)</strong><ul>
<li>当需要进行数据库操作时，应用程序代码从 <code>SqlSessionFactory</code> 中获取一个 <code>SqlSession</code> 实例。</li>
<li><code>SqlSessionFactory</code> 在创建 <code>SqlSession</code> 时，会根据配置为其创建一个 <code>Executor</code>（执行器）。</li>
</ul>
</li>
<li><strong>获取 Mapper 代理对象</strong><ul>
<li>应用程序调用 <code>sqlSession.getMapper(UserMapper.class)</code>。</li>
<li>MyBatis 会使用 JDK 动态代理为 <code>UserMapper</code> 接口生成一个代理实现类。这个代理对象将所有接口方法的调用都转发给 <code>SqlSession</code> 内部的相应方法。</li>
</ul>
</li>
<li><strong>执行 Mapper 方法</strong><ul>
<li>当代码调用 <code>userMapper.selectById(1)</code> 时，实际上是调用了代理对象的方法。</li>
<li>代理对象会通过 <code>SqlSession</code> 找到并执行对应的 SQL。具体来说，它会调用 <code>sqlSession.selectOne(&quot;com.example.UserMapper.selectById&quot;, 1)</code>。</li>
</ul>
</li>
<li><strong>Executor 执行查询</strong><ul>
<li><code>SqlSession</code> 将请求委托给内部的 <code>Executor</code>。</li>
<li><strong>一级缓存检查</strong>：<code>Executor</code> 首先会检查一级缓存（Session 级别的缓存）中是否存在相同的查询结果。如果命中，则直接返回缓存中的数据，不再查询数据库。</li>
<li><strong>创建 Statement</strong>：如果缓存未命中，<code>Executor</code> 会从 <code>Configuration</code> 中获取 ID 为 <code>com.example.UserMapper.selectById</code> 的 <code>MappedStatement</code> 对象。</li>
<li><code>Executor</code> 通过 <code>StatementHandler</code> 来准备 SQL 语句。如果 SQL 是动态的，此时会进行解析和拼接。</li>
</ul>
</li>
<li><strong>参数设置与 SQL 执行</strong><ul>
<li><code>StatementHandler</code> 使用 <code>ParameterHandler</code> 将传入的参数（<code>id=1</code>）安全地设置到 <code>PreparedStatement</code> 的占位符上。</li>
<li><code>StatementHandler</code> 调用 JDBC 的 <code>execute()</code> 或 <code>executeQuery()</code> 方法，向数据库发送 SQL 请求。</li>
</ul>
</li>
<li><strong>结果集映射</strong><ul>
<li>数据库返回 <code>ResultSet</code> 结果集。</li>
<li><code>StatementHandler</code> 使用 <code>ResultSetHandler</code> 来处理这个结果集。</li>
<li><code>ResultSetHandler</code> 根据 <code>MappedStatement</code> 中定义的 <code>&lt;resultMap&gt;</code> 或结果类型，将 <code>ResultSet</code> 中的每一行数据转换成一个 Java 对象（如 <code>User</code> 对象）。</li>
</ul>
</li>
<li><strong>返回结果与缓存</strong><ul>
<li><code>Executor</code> 接收到 <code>ResultSetHandler</code> 返回的 Java 对象列表。</li>
<li><code>Executor</code> 将查询结果存入一级缓存中，以备后续相同的查询使用。</li>
<li>结果最终被返回给调用者（应用程序）。</li>
</ul>
</li>
<li><strong>关闭 SqlSession (请求结束时)</strong><ul>
<li>应用程序在使用完毕后，必须调用 <code>sqlSession.close()</code>。</li>
<li>这个操作会释放 <code>SqlSession</code> 占用的资源，最重要的是将数据库连接归还给连接池，并清空该会话的一级缓存。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3. 快速入门"></a>3. 快速入门</h2><h3 id="3-1-环境准备"><a href="#3-1-环境准备" class="headerlink" title="3.1 环境准备"></a>3.1 环境准备</h3><ul>
<li><strong>JDK</strong>: 1.8 或更高版本</li>
<li><strong>Maven</strong>: 3.6 或更高版本</li>
<li><strong>数据库</strong>: 以 MySQL 为例</li>
</ul>
<hr>
<h3 id="3-2-创建Maven项目并添加依赖"><a href="#3-2-创建Maven项目并添加依赖" class="headerlink" title="3.2 创建Maven项目并添加依赖"></a>3.2 创建Maven项目并添加依赖</h3><p>创建一个标准的 Maven 项目，并在 <code>pom.xml</code> 文件中添加 MyBatis 和 MySQL 驱动的核心依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis 核心库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MySQL 数据库驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 日志（可选，但推荐） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-准备数据库和数据表"><a href="#3-3-准备数据库和数据表" class="headerlink" title="3.3 准备数据库和数据表"></a>3.3 准备数据库和数据表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 user 表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `<span class="keyword">user</span>` (`id`, `username`, `password`, `email`) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;password123&#x27;</span>, <span class="string">&#x27;alice@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-创建实体类"><a href="#3-4-创建实体类" class="headerlink" title="3.4 创建实体类"></a>3.4 创建实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/model/UserPO.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserPO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters 和 Setters</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserPO&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-5-创建Mapper接口"><a href="#3-5-创建Mapper接口" class="headerlink" title="3.5 创建Mapper接口"></a>3.5 创建Mapper接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/mapper/UserMapper.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.model.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID查询用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-6-创建Mapper-XML映射文件"><a href="#3-6-创建Mapper-XML映射文件" class="headerlink" title="3.6 创建Mapper XML映射文件"></a>3.6 创建Mapper XML映射文件</h3><p>在 <code>src/main/resources</code> 目录下，创建一个与 Mapper 接口对应的 XML 文件 <code>UserMapper.xml</code>。<strong>注意：目录结构通常要与接口的包结构保持一致。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/main/resources/com/example/mapper/UserMapper.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- namespace 必须指向 Mapper 接口的全限定名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        select 标签定义一个查询操作</span></span><br><span class="line"><span class="comment">        id: 必须与接口中的方法名一致</span></span><br><span class="line"><span class="comment">        resultType: 查询结果映射的 Java 类型（全限定名或别名）</span></span><br><span class="line"><span class="comment">        parameterType: 传入参数的类型（可选，MyBatis通常能自动推断）</span></span><br><span class="line"><span class="comment">        #&#123;id&#125;: MyBatis 的参数占位符，表示从传入的参数中获取 id 属性/值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-7-创建-MyBatis-核心配置文件"><a href="#3-7-创建-MyBatis-核心配置文件" class="headerlink" title="3.7 创建 MyBatis 核心配置文件"></a>3.7 创建 MyBatis 核心配置文件</h3><p>在 <code>src/main/resources</code> 目录下创建 <code>mybatis-config.xml</code>，这是 MyBatis 的主配置文件，用于配置数据源、事务管理器和引入映射文件。</p>
<p>在实际开发中这种核心配置文件被SpringBoot的application.yml替代，不再需要这么复杂的xml语句。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/main/resources/mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据库连接环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 事务管理器：使用 JDBC 的提交和回滚设置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 数据源：使用 MyBatis 自带的连接池 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/your_database?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;your_password&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册 Mapper XML 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/example/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 请将 <code>your_database</code> 和 <code>your_password</code> 替换为您自己的数据库名和密码。</p>
<hr>
<h3 id="3-8-编写测试代码"><a href="#3-8-编写测试代码" class="headerlink" title="3.8 编写测试代码"></a>3.8 编写测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 指定核心配置文件的路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// 2. 读取配置文件输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="comment">// 3. 创建 SqlSessionFactory（重量级对象，全局唯一）</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 从 SqlSessionFactory 获取 SqlSession（轻量级对象，线程不安全，用完即关）</span></span><br><span class="line">        <span class="comment">// 使用 try-with-resources 语句确保 SqlSession 被自动关闭</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">            <span class="comment">// 5. 获取 Mapper 接口的代理对象</span></span><br><span class="line">            <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 6. 调用 Mapper 方法执行查询</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Querying user with ID 1...&quot;</span>);</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 处理并打印结果</span></span><br><span class="line">            <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;User found: &quot;</span> + user);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;User not found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-XML映射文件"><a href="#4-XML映射文件" class="headerlink" title="4. XML映射文件"></a>4. XML映射文件</h2><p>XML 映射文件是 MyBatis 的核心和灵魂所在。它体现了 MyBatis “SQL 与代码分离”的设计哲学，允许开发者将 SQL 语句集中管理，提供了极大的灵活性和可维护性。</p>
<h3 id="4-1-角色与结构"><a href="#4-1-角色与结构" class="headerlink" title="4.1 角色与结构"></a>4.1 角色与结构</h3><p><strong>角色</strong>：XML 映射文件是 <strong>Mapper 接口</strong> 与 <strong>SQL 语句</strong> 之间的桥梁。它告诉 MyBatis，当调用接口中的某个方法时，应该执行哪条 SQL 语句，以及如何处理参数和结果。</p>
<p><strong>基本结构</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 根元素 &lt;mapper&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 在这里定义各种 SQL 语句映射 --&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>&lt;!DOCTYPE mapper ...&gt;</code></strong>: 这是标准的 DTD (Document Type Definition) 声明，用于验证 XML 文件的结构合法性，并提供 IDE 的代码提示功能。</li>
<li><strong><code>&lt;mapper namespace=&quot;...&quot;&gt;</code></strong>: 根元素。<ul>
<li><strong><code>namespace</code> (命名空间)</strong>: 这是映射文件最重要的属性，它必须被设置为 <strong>对应的 Mapper 接口的全限定名</strong> (例如 <code>com.example.mapper.UserMapper</code>)。它的作用是将这个 XML 文件与指定的 Java 接口绑定起来，MyBatis 通过这个命名空间来定位和执行 SQL。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-2-CRUD操作标签"><a href="#4-2-CRUD操作标签" class="headerlink" title="4.2 CRUD操作标签"></a>4.2 CRUD操作标签</h3><p>MyBatis 为增删改查操作提供了四个基本标签：</p>
<ul>
<li><strong><code>&lt;select&gt;</code></strong>: 用于定义查询语句。</li>
<li><strong><code>&lt;insert&gt;</code></strong>: 用于定义插入语句。</li>
<li><strong><code>&lt;update&gt;</code></strong>: 用于定义更新语句。</li>
<li><strong><code>&lt;delete&gt;</code></strong>: 用于定义删除语句。</li>
</ul>
<p><strong>通用属性</strong>:</p>
<ul>
<li><strong><code>id</code></strong>: 必填。唯一标识符，必须与 Mapper 接口中对应的方法名完全一致。</li>
<li><strong><code>parameterType</code></strong>: 可选。传入参数的 Java 类型全限定名或别名。MyBatis 通常可以自动推断，所以大部分情况下可以省略。</li>
<li><strong><code>timeout</code></strong>: 设置超时时间（秒）。</li>
<li><strong><code>flushCache</code></strong>: 默认为 <code>false</code> (select) 或 <code>true</code> (insert&#x2F;update&#x2F;delete)。设置为 <code>true</code> 时，执行该语句会清空一级和二级缓存。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 查询 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 插入并返回自增主键 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.User&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO user (username, password, email) </span><br><span class="line">        VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 更新 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        UPDATE user SET username = #&#123;username&#125;, email = #&#123;email&#125; WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 删除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>useGeneratedKeys=&quot;true&quot;</code></strong> 和 <strong><code>keyProperty=&quot;id&quot;</code></strong>: 这两个属性配合使用，可以在执行 <code>insert</code> 语句后，将数据库生成的自增主键值回填到传入的 <code>User</code> 对象的 <code>id</code> 属性中。</li>
</ul>
<hr>
<h3 id="4-3-参数处理-vs"><a href="#4-3-参数处理-vs" class="headerlink" title="4.3 参数处理 (#{} vs ${})"></a>4.3 参数处理 (<code>#{}</code> vs <code>${}</code>)</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>#{}</code> (占位符)</th>
<th align="left"><code>${}</code> (拼接符)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层实现</strong></td>
<td align="left"><code>PreparedStatement</code></td>
<td align="left"><code>Statement</code></td>
</tr>
<tr>
<td align="left"><strong>工作方式</strong></td>
<td align="left">参数替换，将 <code>#{...}</code> 替换为 <code>?</code>，然后安全地设置值。</td>
<td align="left">字符串直接拼接，将 <code>${...}</code> 的内容原样拼接到 SQL 中。</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>安全</strong>，能有效防止 SQL 注入。</td>
<td align="left"><strong>不安全</strong>，存在 SQL 注入风险，必须谨慎使用。</td>
</tr>
<tr>
<td align="left"><strong>类型处理</strong></td>
<td align="left">自动进行数据类型转换（如 String 转 ‘String’）。</td>
<td align="left">不进行任何处理，原样输出。</td>
</tr>
<tr>
<td align="left"><strong>推荐使用</strong></td>
<td align="left"><strong>绝大多数情况下都应该使用。</strong></td>
<td align="left">仅用于无法使用 <code>#{}</code> 的场景。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">传递查询条件、更新值等所有用户输入的数据。</td>
<td align="left">动态指定表名、列名、<code>ORDER BY</code> 子句等非参数值部分。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 安全的用法 (推荐)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> #&#123;userId&#125;;</span><br><span class="line"><span class="comment">-- MyBatis 会生成: SELECT * FROM user WHERE id = ?;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 危险的用法 (有 SQL 注入风险)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> $&#123;userId&#125;;</span><br><span class="line"><span class="comment">-- 如果 userId 是 &quot;1 OR 1=1&quot;，SQL 会变成: SELECT * FROM user WHERE id = 1 OR 1=1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- `$&#123;&#125;` 的合理用法</span></span><br><span class="line"><span class="comment">-- 动态排序：orderByColumn 可以是 &quot;username&quot; 或 &quot;email&quot;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> $&#123;orderByColumn&#125; <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-结果映射"><a href="#4-4-结果映射" class="headerlink" title="4.4 结果映射 (&lt;resultMap&gt;)"></a>4.4 结果映射 (<code>&lt;resultMap&gt;</code>)</h3><p>当数据库表的列名与 Java 对象的属性名不一致时，或者需要处理复杂的关联查询（如一对一、一对多）时，<code>resultType</code> 就显得力不从心了。此时，需要使用功能更强大的 <code>&lt;resultMap&gt;</code>。</p>
<p><strong><code>resultType</code> vs <code>&lt;resultMap&gt;</code></strong>:</p>
<ul>
<li><strong><code>resultType</code></strong>: 用于简单的自动映射。它要求 SQL 查询出的列名与 Java 对象的属性名（忽略大小写和下划线）能够匹配。例如，数据库列 <code>user_name</code> 可以自动映射到 Java 属性 <code>userName</code>。</li>
<li><strong><code>&lt;resultMap&gt;</code></strong>: 提供手动的、精细化的映射规则。</li>
</ul>
<p><strong><code>&lt;resultMap&gt;</code> 的使用</strong>:</p>
<ol>
<li><p><strong>定义 <code>&lt;resultMap&gt;</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  id: resultMap 的唯一标识</span></span><br><span class="line"><span class="comment">  type: 映射的目标 Java 类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;id&gt; 用于映射主键，有助于性能提升 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;result&gt; 用于映射普通列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 <code>&lt;select&gt;</code> 标签中引用 <code>resultMap</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserWithCustomMapping&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT user_id, user_name, user_password, user_email FROM user WHERE user_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="4-5-可重用-SQL-片段"><a href="#4-5-可重用-SQL-片段" class="headerlink" title="4.5 可重用 SQL 片段 (&lt;sql&gt;)"></a>4.5 可重用 SQL 片段 (<code>&lt;sql&gt;</code>)</h3><p>为了避免重复编写相同的 SQL 代码（如查询的列名列表），可以使用 <code>&lt;sql&gt;</code> 标签定义可重用的 SQL 片段，并通过 <code>&lt;include&gt;</code> 标签引用它。</p>
<p><strong>示例</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 定义可重用的 SQL 片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;baseColumnList&quot;</span>&gt;</span></span><br><span class="line">    id, username, password, email</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 在查询语句中引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;baseColumnList&quot;</span>/&gt;</span></span><br><span class="line">    FROM user </span><br><span class="line">    WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;baseColumnList&quot;</span>/&gt;</span></span><br><span class="line">    FROM user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-动态SQL"><a href="#5-动态SQL" class="headerlink" title="5. 动态SQL"></a>5. 动态SQL</h2><p><strong>动态 SQL</strong> 是 MyBatis 最强大、最核心的功能之一。它允许你根据不同的条件，在 XML 映射文件中动态地拼接、组合 SQL 语句。这极大地解决了传统 JDBC 中需要通过 Java 代码进行大量 <code>if-else</code> 判断来拼接 SQL 的痛点，使得 SQL 语句的管理更加清晰和高效。</p>
<h3 id="5-1-为什么需要动态-SQL？"><a href="#5-1-为什么需要动态-SQL？" class="headerlink" title="5.1 为什么需要动态 SQL？"></a>5.1 为什么需要动态 SQL？</h3><p>在实际开发中，我们经常遇到“多条件组合查询”的场景。例如，一个用户搜索功能，用户可能只输入了用户名，或者只选择了状态，或者两者都输入了。如果使用静态 SQL，你需要为每一种可能的组合编写一个 SQL 语句，这是不现实的。</p>
<p>动态 SQL 让你只需编写一个 SQL 模板，通过使用特定的标签，MyBatis 会在运行时根据传入的参数动态地生成最终要执行的 SQL。</p>
<hr>
<h3 id="5-2-核心动态-SQL-标签"><a href="#5-2-核心动态-SQL-标签" class="headerlink" title="5.2 核心动态 SQL 标签"></a>5.2 核心动态 SQL 标签</h3><h4 id="5-2-1"><a href="#5-2-1" class="headerlink" title="5.2.1 &lt;if&gt;"></a>5.2.1 <code>&lt;if&gt;</code></h4><p>这是最常用的动态 SQL 标签，用于进行单条件判断。如果 <code>test</code> 表达式的值为 <code>true</code>，则会将 <code>&lt;if&gt;</code> 标签内的 SQL 片段包含进来。</p>
<p><strong>场景</strong>：根据用户名（可选）和邮箱（可选）查询用户。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.User&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    WHERE 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        AND username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        AND email = #&#123;email&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>test</code> 属性</strong>：接收一个 OGNL (Object-Graph Navigation Language) 表达式。你可以直接访问传入参数对象的属性。</li>
<li><strong><code>WHERE 1=1</code> 的技巧</strong>：这是一个经典的“hack”手法。为了避免当所有 <code>&lt;if&gt;</code> 条件都不满足时 SQL 语法错误，或者当第一个 <code>&lt;if&gt;</code> 满足时需要处理 <code>WHERE</code> 和 <code>AND</code> 的连接问题，<code>WHERE 1=1</code> 可以巧妙地让后续所有条件都以 <code>AND</code> 开头，简化了逻辑。不过，MyBatis 提供了更优雅的解决方案。</li>
</ul>
<hr>
<h4 id="5-2-2"><a href="#5-2-2" class="headerlink" title="5.2.2 &lt;where&gt;"></a>5.2.2 <code>&lt;where&gt;</code></h4><p><code>&lt;where&gt;</code> 标签专门用于解决上述 <code>WHERE 1=1</code> 的问题。它会智能地处理 SQL 拼接：</p>
<ul>
<li>只有当 <code>&lt;where&gt;</code> 标签内有内容输出时，它才会生成 <code>WHERE</code> 关键字。</li>
<li>它会自动<strong>去除</strong>标签内 SQL 语句<strong>开头</strong>的 <code>AND</code> 或 <code>OR</code>。</li>
</ul>
<p><strong>使用 <code>&lt;where&gt;</code> 优化上述示例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.User&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND username = #&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND email = #&#123;email&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码更加简洁、优雅，且意图明确。<strong>强烈推荐使用 <code>&lt;where&gt;</code> 替代 <code>WHERE 1=1</code> 的写法。</strong></p>
<hr>
<h4 id="5-2-3"><a href="#5-2-3" class="headerlink" title="5.2.3 &lt;set&gt;"></a>5.2.3 <code>&lt;set&gt;</code></h4><p><code>&lt;set&gt;</code> 标签主要用于 <code>UPDATE</code> 语句中，它解决了动态更新时可能出现的“逗号问题”。</p>
<ul>
<li>只有当 <code>&lt;set&gt;</code> 标签内有内容输出时，它才会生成 <code>SET</code> 关键字。</li>
<li>它会自动<strong>去除</strong>标签内 SQL 语句<strong>结尾</strong>多余的逗号 <code>,</code>。</li>
</ul>
<p><strong>场景</strong>：动态更新用户信息，只更新传入对象中非 <code>null</code> 的字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;updateUserSelective&quot; parameterType=&quot;com.example.model.User&quot;&gt;</span><br><span class="line">    UPDATE user</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">        &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            username = #&#123;username&#125;,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            password = #&#123;password&#125;,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            email = #&#123;email&#125;,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    WHERE id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<p>如果没有 <code>&lt;set&gt;</code>，当最后一个 <code>&lt;if&gt;</code> 条件满足时，SQL 语句会以一个逗号结尾，导致语法错误。<code>&lt;set&gt;</code> 完美地解决了这个问题。</p>
<hr>
<h4 id="5-2-4"><a href="#5-2-4" class="headerlink" title="5.2.4 &lt;foreach&gt;"></a>5.2.4 <code>&lt;foreach&gt;</code></h4><p><code>&lt;foreach&gt;</code> 标签用于对集合（如 <code>List</code>, <code>Set</code>, <code>Array</code>）进行迭代，常用于构建 <code>IN</code> 子句或批量插入。</p>
<p><strong>核心属性</strong>:</p>
<ul>
<li><strong><code>collection</code></strong>: 必填。要迭代的集合参数。当参数是 <code>List</code> 时，默认为 <code>list</code>；当是数组时，默认为 <code>array</code>。也可以通过 <code>@Param</code> 注解指定名称。</li>
<li><strong><code>item</code></strong>: 迭代过程中当前元素的变量名。</li>
<li><strong><code>open</code></strong>: 整个循环内容开始前要拼接的字符串。</li>
<li><strong><code>close</code></strong>: 整个循环内容结束后要拼接的字符串。</li>
<li><strong><code>separator</code></strong>: 每次迭代之间要拼接的分隔符。</li>
</ul>
<p><strong>场景</strong>：根据一组 ID 查询多个用户。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mapper 接口方法: List&lt;User&gt; selectByIds(@Param(&quot;ids&quot;) List&lt;Integer&gt; ids); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    WHERE id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果传入的 <code>ids</code> 是 <code>[1, 2, 3]</code>，上述代码会生成如下 SQL：<code>SELECT * FROM user WHERE id IN ( ? , ? , ? )</code></p>
<hr>
<h4 id="5-2-5"><a href="#5-2-5" class="headerlink" title="5.2.5 &lt;choose&gt;, &lt;when&gt;, &lt;otherwise&gt;"></a>5.2.5 <code>&lt;choose&gt;</code>, <code>&lt;when&gt;</code>, <code>&lt;otherwise&gt;</code></h4><p>这组标签相当于 Java 中的 <code>switch-case</code> 或 <code>if-else if-else</code> 结构，提供了“多选一”的逻辑。</p>
<p><strong>场景</strong>：根据传入的 <code>searchType</code> 决定按哪个字段搜索。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserBySearchType&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;searchType == &#x27;username&#x27; and username != null&quot;</span>&gt;</span></span><br><span class="line">                username LIKE CONCAT(&#x27;%&#x27;, #&#123;username&#125;, &#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;searchType == &#x27;email&#x27; and email != null&quot;</span>&gt;</span></span><br><span class="line">                email = #&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                AND status = &#x27;active&#x27;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-2-6"><a href="#5-2-6" class="headerlink" title="5.2.6 &lt;trim&gt;"></a>5.2.6 <code>&lt;trim&gt;</code></h4><p><code>&lt;trim&gt;</code> 是一个更通用的自定义标签，<code>&lt;where&gt;</code> 和 <code>&lt;set&gt;</code> 本质上是 <code>&lt;trim&gt;</code> 的特定配置。它允许你自定义前缀、后缀以及需要覆盖（移除）的前缀和后缀。</p>
<p><strong>属性</strong>:</p>
<ul>
<li><code>prefix</code>: 在标签内容前添加的前缀。</li>
<li><code>suffix</code>: 在标签内容后添加的后缀。</li>
<li><code>prefixOverrides</code>: 需要从标签内容<strong>开头</strong>移除的文本（多个用 <code>|</code> 分隔）。</li>
<li><code>suffixOverrides</code>: 需要从标签内容<strong>结尾</strong>移除的文本（多个用 <code>|</code> 分隔）。</li>
</ul>
<p><strong>使用 <code>&lt;trim&gt;</code> 模拟 <code>&lt;where&gt;</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... a bunch of if statements ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>&lt;trim&gt;</code> 模拟 <code>&lt;set&gt;</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... a bunch of if statements ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>虽然 <code>&lt;trim&gt;</code> 更强大，但在适用场景下，使用 <code>&lt;where&gt;</code> 和 <code>&lt;set&gt;</code> 会让代码意图更清晰，可读性更好。</p>
<h2 id="6-注解开发"><a href="#6-注解开发" class="headerlink" title="6. 注解开发"></a>6. 注解开发</h2><p>MyBatis 注解开发是一种将 SQL 语句直接写在 Mapper 接口方法上的方式，作为 XML 映射文件的替代方案。它以牺牲“SQL与代码分离”的原则为代价，换取了开发的便捷性，特别适用于简单、固定的 SQL 场景。</p>
<h3 id="6-1-简介与适用场景"><a href="#6-1-简介与适用场景" class="headerlink" title="6.1 简介与适用场景"></a>6.1 简介与适用场景</h3><p><strong>核心思想</strong>：将 SQL 映射的配置信息从 XML 文件中移到 Java 接口的注解上，让接口本身就成为一个完整的映射单元。</p>
<p><strong>适用场景</strong>:</p>
<ul>
<li><strong>简单的 CRUD 操作</strong>：对于那些 SQL 语句非常简短、固定且不会改变的增删改查，使用注解可以减少一个 XML 文件，使项目结构更紧凑。</li>
<li><strong>快速原型开发</strong>：在项目初期或开发小型应用时，注解方式可以快速实现功能。</li>
<li><strong>SQL 语句非常简单</strong>：当 SQL 逻辑不涉及复杂的动态判断或关联时，注解是很好的选择。</li>
</ul>
<p><strong>不适用场景</strong>：</p>
<ul>
<li><strong>复杂的动态 SQL</strong>：虽然注解也支持动态 SQL，但写法非常笨拙，可读性和可维护性远不如 XML。</li>
<li><strong>SQL 需要被 DBA 审查或优化</strong>：当 SQL 需要由专门的数据库管理员进行管理时，XML 的分离特性是巨大优势。</li>
<li><strong>需要处理复杂的结果集映射</strong>：注解方式处理复杂映射（如嵌套查询）比 XML 更加繁琐。</li>
</ul>
<hr>
<h3 id="6-2-启用注解开发"><a href="#6-2-启用注解开发" class="headerlink" title="6.2 启用注解开发"></a>6.2 启用注解开发</h3><p>要让 MyBatis 扫描并识别注解，需要在核心配置文件 <code>mybatis-config.xml</code> 中注册 Mapper <strong>接口类</strong>，而不是 XML 文件资源。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方案一：逐个注册 Mapper 接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方案二：批量扫描指定包下的所有 Mapper 接口（更常用） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.example.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：MyBatis 允许混合使用 XML 和注解。即使你使用了注解，MyBatis 默认还是会去寻找与接口同名同路径的 XML 文件。这种混合模式提供了极大的灵活性。</p>
<hr>
<h3 id="6-3-核心-CRUD-注解"><a href="#6-3-核心-CRUD-注解" class="headerlink" title="6.3 核心 CRUD 注解"></a>6.3 核心 CRUD 注解</h3><p>MyBatis 提供了一套与 XML 标签对应的注解，用于定义增删改查操作。</p>
<ul>
<li><code>@Select</code>: 对应 <code>&lt;select&gt;</code> 标签，用于查询。</li>
<li><code>@Insert</code>: 对应 <code>&lt;insert&gt;</code> 标签，用于插入。</li>
<li><code>@Update</code>: 对应 <code>&lt;update&gt;</code> 标签，用于更新。</li>
<li><code>@Delete</code>: 对应 <code>&lt;delete&gt;</code> 标签，用于删除。</li>
</ul>
<p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com/example/mapper/UserMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO user (username, password, email) VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;)&quot;)</span></span><br><span class="line">    <span class="comment">// 使用 @Options 注解获取自增主键</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE user SET username = #&#123;username&#125;, email = #&#123;email&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-参数处理-Param"><a href="#6-4-参数处理-Param" class="headerlink" title="6.4 参数处理 (@Param)"></a>6.4 参数处理 (<code>@Param</code>)</h3><p><code>@Param</code> 注解的核心作用是<strong>给 Mapper 接口方法中的参数命名</strong>。</p>
<p>当 MyBatis 将 Java 方法的参数传入 XML 文件中的 SQL 语句时，它需要一种方式来关联这两者。</p>
<h4 id="6-4-1-使用场景"><a href="#6-4-1-使用场景" class="headerlink" title="6.4.1 使用场景"></a>6.4.1 使用场景</h4><h5 id="1-方法有多个参数时"><a href="#1-方法有多个参数时" class="headerlink" title="1. 方法有多个参数时"></a>1. 方法有多个参数时</h5><p>如果一个 Mapper 方法有多个参数，比如 <code>(String username, String password)</code>，MyBatis 默认情况下无法区分哪个参数对应 SQL 语句中的哪个占位符。它可能会使用 <code>arg0</code>, <code>arg1</code>… 或者 <code>param1</code>, <code>param2</code>… 这样的默认名称，但这非常不直观且容易出错。</p>
<p>使用 <code>@Param</code> 为每个参数指定一个明确的、有意义的名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名和密码查询用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">findUserByUsernameAndPassword</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, </span></span><br><span class="line"><span class="params">                                       <span class="meta">@Param(&quot;password&quot;)</span> String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByUsernameAndPassword&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * </span><br><span class="line">    FROM user </span><br><span class="line">    WHERE username = #&#123;username&#125; AND password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Param(&quot;username&quot;)</code> 将 Java 方法的第一个参数 <code>username</code> 命名为 “username”。</li>
<li><code>@Param(&quot;password&quot;)</code> 将 Java 方法的第二个参数 <code>password</code> 命名为 “password”。</li>
<li>在 XML 中，我们就可以通过 <code>#{username}</code> 和 <code>#{password}</code> 来精确地引用这两个参数了。名字必须完全匹配。</li>
</ul>
<hr>
<h5 id="2-参数是集合或数组时"><a href="#2-参数是集合或数组时" class="headerlink" title="2. 参数是集合或数组时"></a>2. 参数是集合或数组时</h5><p>当你的方法参数是 <code>List</code>、<code>Set</code> 或数组，并且需要在 SQL 中进行遍历（例如 <code>IN</code> 查询），强烈推荐使用 <code>@Param</code>。</p>
<p>MyBatis 在处理集合类参数时，会将其包装在一个 <code>Map</code> 对象中。如果你不指定名称，MyBatis 会使用默认的名称，如 <code>list</code>、<code>collection</code> 或 <code>array</code>。虽然可用，但这同样不直观。</p>
<p>使用 <code>@Param</code> 给集合参数一个有意义的名称，让 XML 中的 <code>&lt;foreach&gt;</code> 标签更具可读性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户ID列表查询多个用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userIds 用户ID列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUsersByIds</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; userIds)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUsersByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM user</span><br><span class="line">    WHERE id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;userId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Param(&quot;ids&quot;)</code> 将 <code>List&lt;Integer&gt; userIds</code> 这个参数命名为 “ids”。</li>
<li>在 <code>&lt;foreach&gt;</code> 标签中，<code>collection</code> 属性的值就直接写成 “ids”，代码意图一目了然。</li>
</ul>
<hr>
<h4 id="6-4-2-可以不使用"><a href="#6-4-2-可以不使用" class="headerlink" title="6.4.2 可以不使用"></a>6.4.2 可以不使用</h4><p><strong>当方法只有一个参数，且不是集合&#x2F;数组时</strong></p>
<p>如果方法只有一个参数，并且它是简单类型（如 <code>Integer</code>, <code>String</code>）或一个 POJO (JavaBean) 对象，那么你可以<strong>不使用</strong> <code>@Param</code>。</p>
<p>**原理：**在这种情况下，MyBatis 能够自动识别，你可以直接在 XML 中使用参数名或者对象的属性名。</p>
<h5 id="1-单个简单类型参数"><a href="#1-单个简单类型参数" class="headerlink" title="1. 单个简单类型参数"></a>1. 单个简单类型参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- #&#123;id&#125; 或 #&#123;_parameter&#125; 或任何你喜欢的名字都可以 --&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>#{}</code> 里的名字可以任意写（虽然推荐写成和参数名一致的 <code>id</code> 以便于理解）。</p>
<hr>
<h5 id="2-单个-POJO-对象参数"><a href="#2-单个-POJO-对象参数" class="headerlink" title="2. 单个 POJO 对象参数"></a>2. 单个 POJO 对象参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可以直接使用User对象的属性名--&gt;</span></span><br><span class="line">    INSERT INTO user (username, password, email)</span><br><span class="line">    VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis 会自动从 <code>user</code> 对象中获取名为 <code>username</code>, <code>password</code> 的属性值。</p>
<p>**但是，即使在这种情况下，使用 <code>@Param</code> 也是一个好习惯，**因为它可以增加代码的明确性和一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加上@Param让代码更清晰</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(<span class="meta">@Param(&quot;user&quot;)</span> User user)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML中也对应地使用user.属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO user (username, password, email)</span><br><span class="line">    VALUES (#&#123;user.username&#125;, #&#123;user.password&#125;, #&#123;user.email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-4-3-Java-8-的-parameters-编译选项"><a href="#6-4-3-Java-8-的-parameters-编译选项" class="headerlink" title="6.4.3 Java 8 的 -parameters 编译选项"></a>6.4.3 Java 8 的 <code>-parameters</code> 编译选项</h4><p>如果你使用的是 Java 8 或更高版本，并且在编译时开启了 <code>-parameters</code> 标志（默认关闭），MyBatis 3.4.1+ 可以通过反射获取到方法的实际参数名（例如 <code>username</code>, <code>password</code>）。</p>
<p>在这种情况下，即使有多个参数，也可以不使用 <code>@Param</code> 注解。</p>
<p><strong>示例 (开启了 <code>-parameters</code> 标志):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无需 @Param</span></span><br><span class="line">User <span class="title function_">findUserByUsernameAndPassword</span><span class="params">(String username, String password)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以直接使用参数名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByUsernameAndPassword&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * </span><br><span class="line">    FROM user </span><br><span class="line">    WHERE username = #&#123;username&#125; AND password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>然而，依赖这个特性有风险：</strong></p>
<ol>
<li><strong>构建环境依赖</strong>：它要求你的项目（以及所有依赖它的项目）都必须在开启 <code>-parameters</code> 标志的情况下编译。如果构建配置发生变化，代码可能会在运行时失败。</li>
<li><strong>可移植性差</strong>：其他开发者或者 CI&#x2F;CD 环境可能没有配置这个标志，导致构建失败。</li>
</ol>
<p>因此，<strong>最佳实践是：不要依赖 <code>-parameters</code> 标志，始终为多个参数显式地使用 <code>@Param</code> 注解。</strong> 这样你的代码会更健壮、更清晰、更不容易出错。</p>
<hr>
<h3 id="6-5-结果映射-Results-Result"><a href="#6-5-结果映射-Results-Result" class="headerlink" title="6.5 结果映射 (@Results &amp; @Result)"></a>6.5 结果映射 (<code>@Results</code> &amp; <code>@Result</code>)</h3><p>当数据库列名与 Java 实体类的属性名不匹配时，可以使用 <code>@Results</code> 和 <code>@Result</code> 注解来进行手动映射，它们的功能等同于 XML 中的 <code>&lt;resultMap&gt;</code>。</p>
<ul>
<li><code>@Results</code>: 包含一组 <code>@Result</code> 映射规则的容器，可以给它指定一个 <code>id</code> 以便复用。</li>
<li><code>@Result</code>: 定义单个列与属性的映射关系。<ul>
<li><code>column</code>: 数据库列名。</li>
<li><code>property</code>: Java 实体类属性名。</li>
<li><code>id = true</code>: 表明这是主键字段。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Results(id = &quot;userResultMap&quot;, value = &#123;</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;id&quot;, column = &quot;user_id&quot;, id = true),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;username&quot;, column = &quot;user_name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;password&quot;, column = &quot;user_pwd&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;email&quot;, column = &quot;user_email&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT user_id, user_name, user_pwd, user_email FROM user WHERE user_id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">selectUserWithCustomMapping</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复用上面定义的 Results</span></span><br><span class="line">    <span class="meta">@ResultMap(&quot;userResultMap&quot;)</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT user_id, user_name, user_pwd, user_email FROM user&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAllUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-6-动态-SQL-注解的局限与方案"><a href="#6-6-动态-SQL-注解的局限与方案" class="headerlink" title="6.6 动态 SQL (注解的局限与方案)"></a>6.6 动态 SQL (注解的局限与方案)</h3><p>在注解中实现动态 SQL 是其最大的短板，可读性很差。主要有两种方案：</p>
<p><strong>方案一：使用 <code>&lt;script&gt;</code> 标签 (推荐)</strong></p>
<p>你可以在注解的 SQL 字符串中嵌入 <code>&lt;script&gt;</code> 标签，然后在标签内部使用和 XML 中一样的动态 SQL 标签（如 <code>&lt;if&gt;</code>, <code>&lt;where&gt;</code>, <code>&lt;foreach&gt;</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;&lt;script&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;SELECT * FROM user &quot; +</span></span><br><span class="line"><span class="meta">            &quot;&lt;where&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;  &lt;if test=&#x27;username != null and username != \&quot;\&quot;&#x27;&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;    AND username = #&#123;username&#125;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;  &lt;/if&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;  &lt;if test=&#x27;email != null and email != \&quot;\&quot;&#x27;&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;    AND email = #&#123;email&#125;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;  &lt;/if&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;&lt;/where&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;&lt;/script&gt;&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUserByCondition</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：SQL 以字符串形式存在，容易出错，IDE 没有语法高亮和检查，可读性差。</p>
<p><strong>方案二：使用 <code>Provider</code> 注解 (高级)</strong></p>
<p>对于极其复杂的动态 SQL，可以使用 <code>@SelectProvider</code>, <code>@InsertProvider</code> 等注解，将构建 SQL 的逻辑委托给一个外部的 Java 类来完成。</p>
<ol>
<li><p><strong>创建一个 SQL Provider 类</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUserByCondition</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 MyBatis 内置的 SQL 构建器，比手动拼接更安全</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (user.getUsername() != <span class="literal">null</span> &amp;&amp; !user.getUsername().isEmpty()) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;username = #&#123;username&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (user.getEmail() != <span class="literal">null</span> &amp;&amp; !user.getEmail().isEmpty()) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;email = #&#123;email&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Mapper 接口中引用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;findUserByCondition&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUserByCondition</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点</strong>：可以利用 Java 的全部能力来构建 SQL，逻辑最强大。</p>
<p><strong>缺点</strong>：实现复杂，将数据访问逻辑分散到了另一个类中。</p>
<hr>
<h3 id="6-7-总结：注解-vs-XML-最佳实践"><a href="#6-7-总结：注解-vs-XML-最佳实践" class="headerlink" title="6.7 总结：注解 vs XML (最佳实践)"></a>6.7 总结：注解 vs XML (最佳实践)</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">注解方式</th>
<th align="left">XML 方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>简洁性</strong></td>
<td align="left"><strong>优</strong>，无需额外文件</td>
<td align="left"><strong>良</strong>，需要维护 XML 文件</td>
</tr>
<tr>
<td align="left"><strong>SQL与代码分离</strong></td>
<td align="left"><strong>差</strong>，SQL 与 Java 代码耦合</td>
<td align="left"><strong>优</strong>，完全分离，便于维护</td>
</tr>
<tr>
<td align="left"><strong>动态 SQL 支持</strong></td>
<td align="left"><strong>差</strong>，可读性极低</td>
<td align="left"><strong>优</strong>，语法清晰，功能强大</td>
</tr>
<tr>
<td align="left"><strong>复杂结果映射</strong></td>
<td align="left"><strong>差</strong>，注解写法繁琐</td>
<td align="left"><strong>优</strong>，<code>&lt;resultMap&gt;</code> 结构清晰</td>
</tr>
<tr>
<td align="left"><strong>IDE 支持</strong></td>
<td align="left"><strong>差</strong>，SQL 为字符串，无提示</td>
<td align="left"><strong>优</strong>，有语法高亮和提示</td>
</tr>
</tbody></table>
<p><strong>最佳实践：混合使用</strong></p>
<p>在实际项目中，最理想的策略是<strong>混合使用</strong>两种方式，发挥各自的优势：</p>
<ul>
<li>对于<strong>简单、固定、不常变动</strong>的 CRUD 操作，使用<strong>注解</strong>，以提高开发效率。</li>
<li>对于<strong>复杂查询、动态 SQL、需要 DBA 介入或频繁优化</strong>的 SQL，使用 <strong>XML 文件</strong>，以保证可读性和可维护性。</li>
</ul>
<hr>
<h2 id="7-适用场景-原生MyBatis"><a href="#7-适用场景-原生MyBatis" class="headerlink" title="7. 适用场景 (原生MyBatis)"></a>7. 适用场景 (原生MyBatis)</h2><p>原生MyBatis的核心优势在于它在 <strong>自动化便利性</strong> 和 <strong>SQL 终极控制力</strong> 之间取得了完美的平衡。</p>
<h4 id="7-1-极致的性能追求与复杂的-SQL-优化"><a href="#7-1-极致的性能追求与复杂的-SQL-优化" class="headerlink" title="7.1 极致的性能追求与复杂的 SQL 优化"></a>7.1 极致的性能追求与复杂的 SQL 优化</h4><p>当应用程序的性能瓶颈在于数据库交互，且需要对 SQL 进行精细化、极致的优化时，原生 MyBatis 是不二之选。</p>
<ul>
<li><strong>完全掌控 SQL</strong>：开发者可以手动编写最高效的 SQL，包括使用数据库特有的查询提示（Hints）、强制使用特定索引、编写复杂的子查询或 <code>WITH</code> 公共表表达式（CTE）等。</li>
<li><strong>避免 ORM 开销</strong>：全自动 ORM 框架（如 Hibernate）在生成 SQL 的过程中可能会产生额外的性能开销，或者生成的 SQL 并非最优解。原生 MyBatis 则完全没有这层“中间商”。</li>
<li><strong>场景示例</strong>：高并发的电商系统中的商品查询、金融系统中的实时交易报表、秒杀活动等对数据库响应时间要求极为苛刻的场景。</li>
</ul>
<hr>
<h4 id="7-2-遗留系统或复杂的数据库设计"><a href="#7-2-遗留系统或复杂的数据库设计" class="headerlink" title="7.2 遗留系统或复杂的数据库设计"></a>7.2 遗留系统或复杂的数据库设计</h4><p>在面对设计不规范、年代久远的遗留系统数据库时，原生 MyBatis 的灵活性展现出巨大优势。</p>
<ul>
<li><strong>解耦领域模型与数据模型</strong>：遗留系统的表结构可能非常混乱，与理想的 Java 对象模型相去甚远。全自动 ORM 框架强制的实体映射关系在这种情况下会变得非常痛苦。</li>
<li><strong>强大的 <code>&lt;resultMap&gt;</code></strong>：通过 MyBatis 强大的 <code>&lt;resultMap&gt;</code>，你可以将任何复杂的查询结果（无论表结构多么不合理）灵活地映射到干净的 POJO 或 DTO 对象上，实现数据访问层对业务逻辑层的完美隔离。</li>
<li><strong>场景示例</strong>：对一个没有主外键约束、存在大量冗余字段、命名不规范的老旧系统进行现代化改造或功能扩展。</li>
</ul>
<hr>
<h4 id="7-3-报表系统与数据分析"><a href="#7-3-报表系统与数据分析" class="headerlink" title="7.3 报表系统与数据分析"></a>7.3 报表系统与数据分析</h4><p>报表和数据分析类需求往往涉及极其复杂的 SQL 查询，这些查询是业务的核心。</p>
<ul>
<li><strong>复杂的多表连接与聚合</strong>：报表查询通常需要连接十几个表，并进行大量的 <code>GROUP BY</code>, <code>HAVING</code>, 聚合函数（<code>SUM</code>, <code>AVG</code>, <code>COUNT</code>）和窗口函数等操作。用 Java 代码（如 JPA Criteria API）来构建这类查询既复杂又低效。</li>
<li><strong>SQL 集中管理</strong>：将这些复杂的报表 SQL 集中存放在 XML 文件中，使得 SQL 的维护、审查和调优变得非常方便，业务逻辑代码则保持简洁。</li>
<li><strong>场景示例</strong>：生成财务月度报表、BI 系统的数据看板、多维度的数据统计与分析。</li>
</ul>
<hr>
<h4 id="7-4-大量使用存储过程与数据库特性"><a href="#7-4-大量使用存储过程与数据库特性" class="headerlink" title="7.4 大量使用存储过程与数据库特性"></a>7.4 大量使用存储过程与数据库特性</h4><p>当业务逻辑严重依赖数据库的存储过程、函数或特定高级特性时，MyBatis 提供了最直接、最方便的支持。</p>
<ul>
<li><strong>一流的存储过程支持</strong>：MyBatis 对存储过程的调用支持非常完善，可以轻松处理输入参数、输出参数以及返回的结果集。</li>
<li><strong>利用数据库方言</strong>：可以无缝使用特定数据库的功能，例如 Oracle 的 <code>CONNECT BY</code> 树形查询、PostgreSQL 的 JSONB 函数等，而这些功能是标准化的 JPA 规范无法覆盖的。</li>
<li><strong>场景示例</strong>：与银行、电信等核心系统对接，这些系统通常会通过存储过程暴露接口；利用数据库原生功能进行高性能的地理空间计算或全文检索。</li>
</ul>
<hr>
<h4 id="7-5-对-SQL-有强掌控欲或-DBA-深度参与的项目"><a href="#7-5-对-SQL-有强掌控欲或-DBA-深度参与的项目" class="headerlink" title="7.5 对 SQL 有强掌控欲或 DBA 深度参与的项目"></a>7.5 对 SQL 有强掌控欲或 DBA 深度参与的项目</h4><p>在一些对数据库安全性和稳定性要求极高的团队或项目中，所有上线的 SQL 都需要经过 DBA (数据库管理员) 的严格审核。</p>
<ul>
<li><strong>SQL 透明化</strong>：MyBatis 的 XML 文件将所有 SQL 语句清晰地展示出来，非常便于 DBA 进行审查（Code Review）和性能分析（Explain Plan）。</li>
<li><strong>职责分离</strong>：Java 开发者负责业务逻辑，DBA 负责 SQL 的编写和优化，两者通过 XML 文件协作，职责清晰。全自动 ORM 产生的“黑盒”SQL 在这种模式下是不可接受的。</li>
<li><strong>场景示例</strong>：金融、证券、政府等领域的关键业务系统。</li>
</ul>
<hr>
<hr>
<h1 id="三、MyBatis-Plus-效率增强"><a href="#三、MyBatis-Plus-效率增强" class="headerlink" title="三、MyBatis-Plus (效率增强)"></a>三、MyBatis-Plus (效率增强)</h1><h2 id="1-简介与核心优势"><a href="#1-简介与核心优势" class="headerlink" title="1. 简介与核心优势"></a>1. 简介与核心优势</h2><h3 id="1-1-MyBatis-Plus-是什么？"><a href="#1-1-MyBatis-Plus-是什么？" class="headerlink" title="1.1 MyBatis-Plus 是什么？"></a>1.1 MyBatis-Plus 是什么？</h3><p><strong>MyBatis-Plus (简称 MP)</strong> 是一个为 MyBatis 量身打造的<strong>增强工具</strong>，其设计的初衷和口号是 <strong>“为简化而生”</strong>。它并非要取代 MyBatis，而是在 MyBatis 的基础上进行功能扩展和优化，旨在最大化地简化开发、提高效率。</p>
<p><strong>核心定位</strong>：</p>
<p>MyBatis-Plus 并不改变 MyBatis 的核心，它是一个<strong>无侵入</strong>的增强包。这意味着：</p>
<ul>
<li>依然可以像以前一样使用 MyBatis 的所有原生功能（如编写 XML、动态 SQL 等）。</li>
<li>在此之上，MP 提供了一系列开箱即用的强大功能，让你从大量重复的、简单的 CRUD（增删改查）工作中解放出来。</li>
</ul>
<hr>
<h3 id="1-2-核心优势"><a href="#1-2-核心优势" class="headerlink" title="1.2 核心优势"></a>1.2 核心优势</h3><h4 id="1-2-1-极简-CRUD"><a href="#1-2-1-极简-CRUD" class="headerlink" title="1.2.1 极简 CRUD"></a>1.2.1 极简 CRUD</h4><p>只需要定义一个 Mapper 接口并继承 <code>BaseMapper&lt;T&gt;</code>，即可<strong>无需编写任何 SQL 语句</strong>，自动拥有多达 30+ 种通用的增、删、改、查方法。这覆盖了 80% 以上的单表操作需求，极大地减少了样板代码。</p>
<ul>
<li><strong>示例</strong>：<code>insert()</code>, <code>deleteById()</code>, <code>updateById()</code>, <code>selectById()</code>, <code>selectList()</code>, <code>selectPage()</code> 等。</li>
</ul>
<hr>
<h4 id="1-2-2-强大的条件构造器-Wrapper"><a href="#1-2-2-强大的条件构造器-Wrapper" class="headerlink" title="1.2.2 强大的条件构造器 (Wrapper)"></a>1.2.2 强大的条件构造器 (Wrapper)</h4><p>MP 提供了一套功能强大且易于使用的条件构造器 (<code>Wrapper</code>)，允许9通过<strong>链式调用的 Java 代码</strong>来安全、动态地构建复杂的查询条件。这在绝大多数场景下可以完美替代手写 XML 动态 SQL。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>类型安全</strong>：推荐使用 <code>LambdaQueryWrapper</code>，它通过方法引用 (<code>User::getUsername</code>) 来指定字段，避免了手写字符串 “username” 可能带来的拼写错误，并能在编译期进行检查。</li>
<li><strong>代码直观</strong>：查询逻辑直接体现在 Java 代码中，比在 XML 和 Java 代码之间来回切换更加直观。</li>
<li><strong>功能丰富</strong>：支持 <code>like</code>, <code>gt</code>, <code>lt</code>, <code>in</code>, <code>or</code>, <code>groupBy</code>, <code>orderBy</code> 等所有常见 SQL 关键字。</li>
</ul>
<hr>
<h4 id="1-2-3-内置实用插件，开箱即用"><a href="#1-2-3-内置实用插件，开箱即用" class="headerlink" title="1.2.3 内置实用插件，开箱即用"></a>1.2.3 内置实用插件，开箱即用</h4><p>MP 提供了许多在企业级开发中高频使用的功能插件，只需简单配置即可启用，无需自己造轮子。</p>
<ul>
<li><strong>分页插件 (<code>PaginationInnerInterceptor</code>)</strong>: 实现了真正的物理分页，自动识别数据库类型并拼接分页 SQL，使用极其简单。</li>
<li><strong>乐观锁插件 (<code>OptimisticLockerInnerInterceptor</code>)</strong>: 优雅地实现了乐观锁机9制，有效防止并发场景下的数据更新冲突。</li>
<li><strong>防全表更新与删除插件 (<code>BlockAttackInnerInterceptor</code>)</strong>: 防止开发人员误操作，执行没有 <code>WHERE</code> 条件的 <code>UPDATE</code> 或 <code>DELETE</code> 语句，保障数据安全。</li>
</ul>
<hr>
<h4 id="1-2-4-代码生成器-AutoGenerator"><a href="#1-2-4-代码生成器-AutoGenerator" class="headerlink" title="1.2.4 代码生成器 (AutoGenerator)"></a>1.2.4 代码生成器 (AutoGenerator)</h4><p>这是一个极大地提升开发效率的利器。通过简单的配置，MP 的代码生成器可以一键为你生成 <strong>Entity、Mapper、Mapper.xml、Service、ServiceImpl、Controller</strong> 等所有分层的代码，让你专注于业务逻辑的实现。</p>
<hr>
<h4 id="1-2-5-无侵入设计，完美兼容"><a href="#1-2-5-无侵入设计，完美兼容" class="headerlink" title="1.2.5 无侵入设计，完美兼容"></a>1.2.5 无侵入设计，完美兼容</h4><p>MP 始终坚持“只做增强不做改变”的原则。它与原生 MyBatis 完美兼容。对于 MP 无法满足的复杂业务场景（如复杂的报表查询、存储过程调用等），你可以随时切换回 MyBatis 的传统方式，在 XML 文件中编写和优化你的 SQL，两者可以无缝共存。</p>
<hr>
<h4 id="1-2-6-内置高级功能"><a href="#1-2-6-内置高级功能" class="headerlink" title="1.2.6 内置高级功能"></a>1.2.6 内置高级功能</h4><ul>
<li><strong>逻辑删除</strong>: 只需一个注解 (<code>@TableLogic</code>) 和简单配置，即可实现“软删除”。所有查询会自动过滤掉被逻辑删除的数据，而删除操作会自动转为更新操作。</li>
<li><strong>自动填充 (<code>MetaObjectHandler</code>)</strong>: 对于 <code>create_time</code>, <code>update_time</code>, <code>create_by</code> 等公共字段，可以实现插入或更新时的自动填充，无需在业务代码中手动设置。</li>
<li><strong>强大的主键策略</strong>: 内置了雪花算法 (<code>ASSIGN_ID</code>)、UUID、数据库自增等多种主键生成策略，特别适合分布式系统。</li>
</ul>
<hr>
<h2 id="2-快速入门-与-Spring-Boot-集成"><a href="#2-快速入门-与-Spring-Boot-集成" class="headerlink" title="2. 快速入门 (与 Spring Boot 集成)"></a>2. 快速入门 (与 Spring Boot 集成)</h2><p>MyBatis-Plus 与 Spring Boot 的集成就如同鱼和水，官方提供了 <code>mybatis-plus-boot-starter</code>，使得整合过程极其简单快捷。下面将通过一个完整的步骤，演示如何在一个 Spring Boot 项目中快速集成并使用 MyBatis-Plus。</p>
<h3 id="2-1-环境与项目准备"><a href="#2-1-环境与项目准备" class="headerlink" title="2.1 环境与项目准备"></a>2.1 环境与项目准备</h3><ul>
<li><strong>环境</strong>: JDK 1.8+, Maven 3.6+, MySQL 5.7+</li>
<li><strong>项目</strong>: 使用 <a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initializr</a> 创建一个新的 Spring Boot 项目，并勾选以下依赖：<ul>
<li>Spring Web</li>
<li>MySQL Driver</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-添加-MyBatis-Plus-依赖"><a href="#2-2-添加-MyBatis-Plus-依赖" class="headerlink" title="2.2 添加 MyBatis-Plus 依赖"></a>2.2 添加 MyBatis-Plus 依赖</h3><p>在 <code>pom.xml</code> 文件中，添加 MyBatis-Plus 的启动器依赖。这个启动器已经包含了 MyBatis 核心和 Spring Boot 集成的所有必要组件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用一个较新的稳定版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-配置数据库连接"><a href="#2-3-配置数据库连接" class="headerlink" title="2.3 配置数据库连接"></a>2.3 配置数据库连接</h3><p>在 <code>src/main/resources/application.yml</code> (或 <code>application.properties</code>) 文件中，配置数据库的数据源信息。</p>
<p><strong><code>application.yml</code> 格式:</strong></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataSource Configuration</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    	<span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/your_database?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8</span></span><br><span class="line">    	<span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    	<span class="attr">password:</span> <span class="string">your_password</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MyBatis-Plus Global Configuration (可选)</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">	<span class="attr">configuration:</span></span><br><span class="line">    	<span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="comment"># 日志打印到控制台</span></span><br><span class="line">		<span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span>     <span class="comment">#开启驼峰自动转换</span></span><br><span class="line">    <span class="attr">global-config:</span></span><br><span class="line">    	<span class="attr">db-config:</span></span><br><span class="line">      		<span class="attr">id-type:</span> <span class="string">assign_id</span>    <span class="comment">#设置统一的主键生成策略</span></span><br><span class="line">      		<span class="attr">logic-delete-field:</span> <span class="string">deleted</span>	<span class="comment"># 全局逻辑删除字段名(逻辑删除激活)</span></span><br><span class="line">      		<span class="attr">logic-delete-value:</span> <span class="number">1</span>	<span class="comment"># 全局逻辑删除字段名(逻辑删除激活)</span></span><br><span class="line">      		<span class="attr">logic-not-delete-value:</span> <span class="number">0</span>  <span class="comment"># 逻辑未删除值（默认为 0）</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 请替换 <code>your_database</code> 和 <code>your_password</code> 为你自己的配置。</p>
<hr>
<h3 id="2-4-创建实体类-Entity"><a href="#2-4-创建实体类-Entity" class="headerlink" title="2.4 创建实体类 (Entity)"></a>2.4 创建实体类 (Entity)</h3><p>创建一个与数据库表对应的 Java 实体类。使用 MyBatis-Plus 的注解来标识表名和主键。</p>
<p><strong>数据库表 (user):</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `age` <span class="type">INT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>

<p><strong>实体类 <code>User.java</code>:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/entity/User.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span> <span class="comment">// 指定该实体类对应的数据库表名为 &quot;user&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span> <span class="comment">// 指定 id 是主键，并且主键策略是数据库自增</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter/Setter/toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-创建-Mapper-接口"><a href="#2-5-创建-Mapper-接口" class="headerlink" title="2.5 创建 Mapper 接口"></a>2.5 创建 Mapper 接口</h3><p>创建一个 Mapper 接口，它需要继承 MyBatis-Plus 提供的 <code>BaseMapper&lt;T&gt;</code> 泛型接口。<strong>你不需要在这个接口里写任何方法定义</strong>，就已经拥有了强大的 CRUD 能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/mapper/UserMapper.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.mapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Mapper 注解也可以在这里加，但推荐在启动类上使用 @MapperScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// BaseMapper 已经提供了丰富的 CRUD 方法</span></span><br><span class="line">    <span class="comment">// 如果有自定义的、复杂的 SQL 查询，可以在这里定义方法，并在 XML 文件中实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-6-配置-Mapper-扫描"><a href="#2-6-配置-Mapper-扫描" class="headerlink" title="2.6 配置 Mapper 扫描"></a>2.6 配置 Mapper 扫描</h3><p>在 Spring Boot 的主启动类上，添加 <code>@MapperScan</code> 注解，告诉 MyBatis-Plus 去哪里查找你的 Mapper 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/MyApplication.java</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span> <span class="comment">// 扫描 com.example.mapper 包下的所有 Mapper 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-7-编写测试代码"><a href="#2-7-编写测试代码" class="headerlink" title="2.7 编写测试代码"></a>2.7 编写测试代码</h3><p>现在，你可以在任何被 Spring 管理的组件（如 <code>@Service</code> 或 <code>@RestController</code>）中注入 <code>UserMapper</code> 并直接使用了。</p>
<p>创建一个测试类来验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test/java/com/example/MyApplicationTests.java</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----- selectAll method test ------&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用 BaseMapper 的 selectList 方法，参数为 null 表示查询所有</span></span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// Assert.isTrue(5 == userList.size(), &quot;&quot;); // 断言</span></span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----- insert method test ------&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;MP-Tester&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">25</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;mp@baomidou.com&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;Insert result: &quot;</span> + result);</span><br><span class="line">        System.out.println(<span class="string">&quot;Generated ID: &quot;</span> + user.getId()); <span class="comment">// ID 会自动回填</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----- updateById method test ------&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>); <span class="comment">// 假设 ID=1 的用户存在</span></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            user.setAge(<span class="number">30</span>);</span><br><span class="line">            userMapper.updateById(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----- deleteById method test ------&quot;</span>);</span><br><span class="line">        userMapper.deleteById(<span class="number">1L</span>); <span class="comment">// 删除 ID=1 的用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-通用-CRUD-BaseMapper-IService"><a href="#3-通用-CRUD-BaseMapper-IService" class="headerlink" title="3. 通用 CRUD (BaseMapper &amp; IService)"></a>3. 通用 CRUD (BaseMapper &amp; IService)</h2><h3 id="3-1-BaseMapper-数据访问层的基石"><a href="#3-1-BaseMapper-数据访问层的基石" class="headerlink" title="3.1 BaseMapper&lt;T&gt;: 数据访问层的基石"></a>3.1 <code>BaseMapper&lt;T&gt;</code>: 数据访问层的基石</h3><p><code>BaseMapper</code> 是一个泛型接口，定义在数据访问层 (DAO&#x2F;Mapper)。<strong>只要你的 Mapper 接口继承了 <code>BaseMapper</code>，就立即拥有了一整套现成的、无需编写 SQL 的 CRUD 方法。</strong></p>
<h4 id="3-1-1-如何使用"><a href="#3-1-1-如何使用" class="headerlink" title="3.1.1 如何使用"></a>3.1.1 如何使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserMapper.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需继承 BaseMapper&lt;User&gt; 即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里是空的！所有通用方法都已继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-2-常用方法一览"><a href="#3-1-2-常用方法一览" class="headerlink" title="3.1.2 常用方法一览"></a>3.1.2 常用方法一览</h4><p><code>BaseMapper</code> 提供了非常丰富的方法，以下是一些最常用的：</p>
<p><strong>插入操作 (Insert):</strong></p>
<ul>
<li><code>int insert(T entity)</code>: 插入一条记录。实体中为 <code>null</code> 的字段<strong>会</strong>被插入到数据库（即插入 <code>NULL</code> 值）。</li>
</ul>
<p><strong>删除操作 (Delete):</strong></p>
<ul>
<li><code>int deleteById(Serializable id)</code>: 根据主键 ID 删除一条记录。</li>
<li><code>int deleteBatchIds(Collection&lt;? extends Serializable&gt; idList)</code>: 根据 ID 批量删除。</li>
<li><code>int deleteByMap(Map&lt;String, Object&gt; columnMap)</code>: 根据 <code>Map</code> 中的列名和值删除记录（多个条件是 AND 关系）。</li>
<li><code>int delete(Wrapper&lt;T&gt; queryWrapper)</code>: 根据条件构造器 (<code>Wrapper</code>) 删除记录。</li>
</ul>
<p><strong>更新操作 (Update):</strong></p>
<ul>
<li><code>int updateById(T entity)</code>: 根据主键 ID 更新。实体中为 <code>null</code> 的字段<strong>不会</strong>被更新。</li>
<li><code>int update(T entity, Wrapper&lt;T&gt; updateWrapper)</code>: 根据 <code>Wrapper</code> 条件更新 <code>entity</code> 中<strong>非 <code>null</code></strong> 的字段。</li>
</ul>
<p><strong>查询操作 (Select):</strong></p>
<ul>
<li><code>T selectById(Serializable id)</code>: 根据主鍵 ID 查询一条记录。</li>
<li><code>List&lt;T&gt; selectBatchIds(Collection&lt;? extends Serializable&gt; idList)</code>: 根据 ID 批量查询。</li>
<li><code>T selectOne(Wrapper&lt;T&gt; queryWrapper)</code>: 根据 <code>Wrapper</code> 条件查询一条记录。如果结果超过 1 条会报错。</li>
<li><code>Long selectCount(Wrapper&lt;T&gt; queryWrapper)</code>: 根据 <code>Wrapper</code> 条件查询记录总数。</li>
<li><code>List&lt;T&gt; selectList(Wrapper&lt;T&gt; queryWrapper)</code>: 根据 <code>Wrapper</code> 条件查询所有记录。</li>
<li><code>IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code>: 根据 <code>Wrapper</code> 条件进行分页查询。</li>
</ul>
<hr>
<h3 id="3-2-IService-ServiceImpl-业务逻辑层的封装"><a href="#3-2-IService-ServiceImpl-业务逻辑层的封装" class="headerlink" title="3.2 IService&lt;T&gt; &amp; ServiceImpl&lt;M, T&gt;: 业务逻辑层的封装"></a>3.2 <code>IService&lt;T&gt;</code> &amp; <code>ServiceImpl&lt;M, T&gt;</code>: 业务逻辑层的封装</h3><p>虽然 <code>BaseMapper</code> 已经很强大，但在实际分层架构中，我们通常不建议在 Controller 或更上层直接调用 Mapper。业务逻辑应该封装在 Service 层。为此，MP 贴心地提供了 <code>IService</code> 和 <code>ServiceImpl</code>。</p>
<p><strong><code>IService</code> 的作用</strong>：</p>
<ol>
<li><strong>分层解耦</strong>：遵循标准的 <code>Controller -&gt; Service -&gt; Mapper</code> 架构，使代码结构更清晰。</li>
<li><strong>功能增强</strong>：在 <code>BaseMapper</code> 的基础上，提供了一些更符合业务语义、功能更强大的方法，特别是批量操作。</li>
<li><strong>事务控制</strong>：Service 层是添加声明式事务 (<code>@Transactional</code>) 的理想位置。</li>
</ol>
<hr>
<h4 id="3-2-1-如何使用"><a href="#3-2-1-如何使用" class="headerlink" title="3.2.1 如何使用"></a>3.2.1 如何使用</h4><ol>
<li><p><strong>创建 <code>IService</code> 接口</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IUserService.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 可以在这里定义自定义的业务方法</span></span><br><span class="line">    <span class="comment">// e.g., void registerUser(User user);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 <code>ServiceImpl</code> 实现类</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserServiceImpl.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="comment">// ServiceImpl 已经自动注入了 baseMapper (即 UserMapper)，可以直接使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现自定义的业务方法</span></span><br><span class="line">    <span class="comment">// @Transactional</span></span><br><span class="line">    <span class="comment">// public void registerUser(User user) &#123;</span></span><br><span class="line">    <span class="comment">//     // 1. 检查用户名是否存在</span></span><br><span class="line">    <span class="comment">//     // 2. 加密密码</span></span><br><span class="line">    <span class="comment">//     // 3. 调用 baseMapper.insert(user) 或 save(user)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="3-2-2-IService-增强的方法"><a href="#3-2-2-IService-增强的方法" class="headerlink" title="3.2.2 IService 增强的方法"></a>3.2.2 <code>IService</code> 增强的方法</h4><p><code>IService</code> 不仅包含了 <code>BaseMapper</code> 的所有功能（通过 <code>getBaseMapper()</code> 调用），还提供了一些更方便的封装：</p>
<ul>
<li><strong><code>save(T entity)</code></strong>: 保存一条记录（内部调用 <code>insert</code>）。</li>
<li><strong><code>saveBatch(Collection&lt;T&gt; entityList)</code></strong>: 批量插入。</li>
<li><strong><code>saveOrUpdate(T entity)</code></strong>: 根据实体 <code>id</code> 是否存在，智能判断是插入还是更新。</li>
<li><strong><code>saveOrUpdateBatch(Collection&lt;T&gt; entityList)</code></strong>: 批量插入或更新。</li>
<li><strong><code>removeById(Serializable id)</code></strong>: 根据 ID 删除（内部调用 <code>deleteById</code>）。</li>
<li><strong><code>removeByIds(Collection&lt;?&gt; list)</code></strong>: 批量删除。</li>
<li><strong><code>updateById(T entity)</code></strong>: 根据 ID 更新。</li>
<li><strong><code>updateBatchById(Collection&lt;T&gt; entityList)</code></strong>: 批量更新。</li>
<li><strong><code>getById(Serializable id)</code></strong>: 根据 ID 查询（内部调用 <code>selectById</code>）。</li>
<li><strong><code>getOne(Wrapper&lt;T&gt; queryWrapper)</code></strong>: 查询一条记录。</li>
<li><strong><code>list()</code></strong>: 查询全部。</li>
<li><strong><code>page(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code></strong>: 分页查询。</li>
</ul>
<hr>
<h3 id="3-3-BaseMapper-vs-IService-总结与最佳实践"><a href="#3-3-BaseMapper-vs-IService-总结与最佳实践" class="headerlink" title="3.3 BaseMapper vs IService (总结与最佳实践)"></a>3.3 <code>BaseMapper</code> vs <code>IService</code> (总结与最佳实践)</h3><table>
<thead>
<tr>
<th align="left">特性&#x2F;方面</th>
<th align="left"><code>BaseMapper&lt;T&gt;</code></th>
<th align="left"><code>IService&lt;T&gt;</code> &#x2F; <code>ServiceImpl&lt;M, T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>层级定位</strong></td>
<td align="left"><strong>数据访问层 (DAO&#x2F;Mapper)</strong></td>
<td align="left"><strong>业务逻辑层 (Service)</strong></td>
</tr>
<tr>
<td align="left"><strong>主要职责</strong></td>
<td align="left">直接与数据库交互，执行最底层的 SQL 操作。</td>
<td align="left">封装业务逻辑，处理事务，组合 Mapper 方法。</td>
</tr>
<tr>
<td align="left"><strong>方法命名</strong></td>
<td align="left">偏向 SQL 动词，如 <code>insert</code>, <code>selectById</code>。</td>
<td align="left">偏向业务语义，如 <code>save</code>, <code>getById</code>, <code>remove</code>。</td>
</tr>
<tr>
<td align="left"><strong>批量操作</strong></td>
<td align="left">部分支持（如 <code>selectBatchIds</code>），但功能较少。</td>
<td align="left"><strong>提供了更完善的批量操作</strong>，如 <code>saveBatch</code>, <code>updateBatchById</code>。</td>
</tr>
<tr>
<td align="left"><strong>事务管理</strong></td>
<td align="left">不负责事务。</td>
<td align="left"><strong>是添加 <code>@Transactional</code> 的理想位置。</strong></td>
</tr>
<tr>
<td align="left"><strong>使用建议</strong></td>
<td align="left">在 <code>ServiceImpl</code> 内部调用。<strong>不应直接暴露给 Controller。</strong></td>
<td align="left"><strong>应由 Controller 调用</strong>，作为业务入口。</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong>:</p>
<ol>
<li><strong>严格分层</strong>：始终遵循 <code>Controller -&gt; IService -&gt; UserMapper</code> 的调用链路。Controller 注入 <code>IUserService</code>，而<strong>不是</strong> <code>UserMapper</code>。</li>
<li><strong>业务封装</strong>：将复杂的业务逻辑、多个 Mapper 操作的组合、事务控制等都放在 <code>ServiceImpl</code> 中完成。</li>
<li><strong>优先使用 <code>IService</code> 方法</strong>：在 Service 层，优先使用 <code>IService</code> 提供的 <code>save</code>, <code>getById</code>, <code>list</code> 等方法，因为它们更符合业务语义，且可能包含更优的实现（如批量操作）。</li>
<li><strong>自定义 SQL</strong>：对于 MP 通用方法无法满足的复杂查询（如多表连接），在 <code>UserMapper</code> 接口中定义新方法，并在对应的 XML 文件中编写 SQL，然后在 <code>ServiceImpl</code> 中调用这个自定义的 Mapper 方法。</li>
</ol>
<hr>
<h2 id="4-条件构造器-Wrapper"><a href="#4-条件构造器-Wrapper" class="headerlink" title="4. 条件构造器 (Wrapper)"></a>4. 条件构造器 (Wrapper)</h2><h3 id="4-1-QueryWrapper-UpdateWrapper"><a href="#4-1-QueryWrapper-UpdateWrapper" class="headerlink" title="4.1 QueryWrapper &amp; UpdateWrapper"></a>4.1 QueryWrapper &amp; UpdateWrapper</h3><h4 id="4-1-1-QueryWrapper"><a href="#4-1-1-QueryWrapper" class="headerlink" title="4.1.1 QueryWrapper&lt;T&gt;"></a>4.1.1 <code>QueryWrapper&lt;T&gt;</code></h4><p><strong>用途</strong>：主要用于构建 <strong>查询</strong> 条件，即 <code>SELECT</code> 语句的 <code>WHERE</code> 子句、<code>ORDER BY</code> 子句等。</p>
<p>它是 MP 中使用频率最高的条件构造器。</p>
<h5 id="1-核心方法"><a href="#1-核心方法" class="headerlink" title="1. 核心方法"></a>1. 核心方法</h5><p><code>QueryWrapper</code> 提供了丰富的链式方法，几乎涵盖了所有 SQL <code>WHERE</code> 子句的操作。</p>
<p><strong>比较操作:</strong></p>
<ul>
<li><code>eq(column, value)</code>: 等于 <code>=</code> (equal)</li>
<li><code>ne(column, value)</code>: 不等于 <code>&lt;&gt;</code> (not equal)</li>
<li><code>gt(column, value)</code>: 大于 <code>&gt;</code> (greater than)</li>
<li><code>ge(column, value)</code>: 大于等于 <code>&gt;=</code> (greater than or equal)</li>
<li><code>lt(column, value)</code>: 小于 <code>&lt;</code> (less than)</li>
<li><code>le(column, value)</code>: 小于等于 <code>&lt;=</code> (less than or equal)</li>
<li><code>between(column, val1, val2)</code>: <code>BETWEEN ... AND ...</code></li>
<li><code>notBetween(column, val1, val2)</code>: <code>NOT BETWEEN ... AND ...</code></li>
</ul>
<p><strong>模糊查询:</strong></p>
<ul>
<li><code>like(column, value)</code>: <code>LIKE &#39;%值%&#39;</code></li>
<li><code>notLike(column, value)</code>: <code>NOT LIKE &#39;%值%&#39;</code></li>
<li><code>likeLeft(column, value)</code>: <code>LIKE &#39;%值&#39;</code> (左模糊)</li>
<li><code>likeRight(column, value)</code>: <code>LIKE &#39;值%&#39;</code> (右模糊)</li>
</ul>
<p><strong>空值判断:</strong></p>
<ul>
<li><code>isNull(column)</code>: <code>... IS NULL</code></li>
<li><code>isNotNull(column)</code>: <code>... IS NOT NULL</code></li>
</ul>
<p><strong>集合操作:</strong></p>
<ul>
<li><code>in(column, collection)</code>: <code>... IN (...)</code></li>
<li><code>notIn(column, collection)</code>: <code>... NOT IN (...)</code></li>
<li><code>inSql(column, sql)</code>: <code>... IN (子查询)</code></li>
</ul>
<p><strong>逻辑连接:</strong></p>
<ul>
<li><code>or()</code>: 连接 <code>OR</code> 条件。例如 <code>... WHERE name = &#39;Tom&#39; OR age &gt; 25</code></li>
<li><code>and(Consumer&lt;Wrapper&gt; consumer)</code>: 嵌套 <code>AND</code> 条件。例如 <code>... AND (name = &#39;Tom&#39; AND age &gt; 25)</code></li>
<li><code>nested(Consumer&lt;Wrapper&gt; consumer)</code>: 正常嵌套，括号内由 <code>AND</code> 连接。</li>
</ul>
<p><strong>排序与分组:</strong></p>
<ul>
<li><code>orderByAsc(column...)</code>: 升序 <code>ORDER BY ... ASC</code></li>
<li><code>orderByDesc(column...)</code>: 降序 <code>ORDER BY ... DESC</code></li>
<li><code>groupBy(column...)</code>: <code>GROUP BY ...</code></li>
</ul>
<p><strong>结果集筛选:</strong></p>
<ul>
<li><code>select(column...)</code>: 指定要查询的字段。例如 <code>select(&quot;id&quot;, &quot;name&quot;)</code> 会生成 <code>SELECT id, name FROM ...</code></li>
</ul>
<hr>
<h5 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h5><p><strong>场景</strong>：查询所有年龄在 20 到 30 岁之间、名字中包含 “a”、并且邮箱不为空的用户，结果按年龄降序排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入 UserMapper</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 QueryWrapper 对象</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 链式调用，构建查询条件</span></span><br><span class="line">    queryWrapper.between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>) <span class="comment">// age BETWEEN 20 AND 30</span></span><br><span class="line">                .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)       <span class="comment">// AND name LIKE &#x27;%a%&#x27;</span></span><br><span class="line">                .isNotNull(<span class="string">&quot;email&quot;</span>)      <span class="comment">// AND email IS NOT NULL</span></span><br><span class="line">                .orderByDesc(<span class="string">&quot;age&quot;</span>);     <span class="comment">// ORDER BY age DESC</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将 Wrapper 作为参数传入 Mapper 方法</span></span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br><span class="line"></span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MP 最终生成的 SQL 语句大致如下：<code>SELECT id, name, age, email FROM user WHERE age BETWEEN ? AND ? AND name LIKE ? AND email IS NOT NULL ORDER BY age DESC</code></p>
<hr>
<h4 id="4-1-2-UpdateWrapper"><a href="#4-1-2-UpdateWrapper" class="headerlink" title="4.1.2 UpdateWrapper&lt;T&gt;"></a>4.1.2 <code>UpdateWrapper&lt;T&gt;</code></h4><p><strong>用途</strong>：功能比 <code>QueryWrapper</code> 更广，它既可以用于构建 <strong>更新</strong> 和 <strong>删除</strong> 时的 <code>WHERE</code> 条件，还可以用于指定 <code>UPDATE</code> 语句的 <code>SET</code> 子句。</p>
<h5 id="1-核心方法-1"><a href="#1-核心方法-1" class="headerlink" title="1. 核心方法"></a>1. 核心方法</h5><p><code>UpdateWrapper</code> 继承了 <code>QueryWrapper</code> 的所有 <code>WHERE</code> 构建方法，并在此基础上增加了用于更新操作的方法。</p>
<p><strong>设置更新字段:</strong></p>
<ul>
<li><strong><code>set(column, value)</code></strong>: 核心方法，用于指定 <code>SET column = value</code>。</li>
<li><code>setSql(sql)</code>: 用于设置复杂的 SQL 表达式，如 <code>setSql(&quot;age = age + 1&quot;)</code>。</li>
</ul>
<hr>
<h5 id="2-使用示例-1"><a href="#2-使用示例-1" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h5><p><strong>示例1: 更新操作</strong></p>
<p><strong>场景</strong>：将所有名字为 “Sandy” 的用户的年龄更新为 22 岁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 UpdateWrapper 对象</span></span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构建 SET 子句和 WHERE 子句</span></span><br><span class="line">updateWrapper.set(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>)         <span class="comment">// SET age = 22</span></span><br><span class="line">             .eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Sandy&quot;</span>);    <span class="comment">// WHERE name = &#x27;Sandy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用 update 方法，第一个参数为 null (因为 set 已经在 wrapper 中定义)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">updatedRows</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;Updated rows: &quot;</span> + updatedRows);</span><br></pre></td></tr></table></figure>

<p>生成的 SQL 语句大致如下：<code>UPDATE user SET age = ? WHERE name = ?</code></p>
<p><strong>示例2: 删除操作</strong></p>
<p><strong>场景</strong>：删除所有年龄大于 60 岁的用户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 UpdateWrapper 对象 (也可以用 QueryWrapper，因为只用到 WHERE)</span></span><br><span class="line">UpdateWrapper&lt;User&gt; deleteWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构建 WHERE 子句</span></span><br><span class="line">deleteWrapper.gt(<span class="string">&quot;age&quot;</span>, <span class="number">60</span>); <span class="comment">// WHERE age &gt; 60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用 delete 方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">deletedRows</span> <span class="operator">=</span> userMapper.delete(deleteWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;Deleted rows: &quot;</span> + deletedRows);</span><br></pre></td></tr></table></figure>

<p>生成的 SQL 语句大致如下：<code>DELETE FROM user WHERE age &gt; ?</code></p>
<hr>
<h3 id="4-2-LambdaQueryWrapper-LambdaUpdateWrapper"><a href="#4-2-LambdaQueryWrapper-LambdaUpdateWrapper" class="headerlink" title="4.2 LambdaQueryWrapper &amp; LambdaUpdateWrapper"></a>4.2 LambdaQueryWrapper &amp; LambdaUpdateWrapper</h3><h4 id="4-2-1-为什么需要-Lambda-Wrapper？"><a href="#4-2-1-为什么需要-Lambda-Wrapper？" class="headerlink" title="4.2.1 为什么需要 Lambda Wrapper？"></a>4.2.1 为什么需要 Lambda Wrapper？</h4><p>使用 <code>QueryWrapper(&quot;name&quot;, &quot;value&quot;)</code> 这种方式存在几个显著的缺点：</p>
<ol>
<li><strong>无编译期安全检查</strong>：如果字段名 <code>name</code> 拼写错误，例如写成了 <code>namae</code>，编译器不会报错，只有在程序运行时才会抛出异常。</li>
<li><strong>重构困难</strong>：当实体类的属性名或数据库字段名需要修改时，你必须手动在整个项目中搜索并替换这些字符串，非常容易出错和遗漏。</li>
<li><strong>IDE 支持不佳</strong>：IDE 无法对字符串进行有效的代码提示、补全或跳转。</li>
</ol>
<p>Lambda Wrapper 通过<strong>方法引用 (Method Reference)</strong> 的方式完美地解决了以上所有问题。</p>
<hr>
<h4 id="4-2-2-核心思想"><a href="#4-2-2-核心思想" class="headerlink" title="4.2.2 核心思想"></a>4.2.2 核心思想</h4><p>Lambda Wrapper 利用了 Java 8 的方法引用特性，例如 <code>User::getName</code>。MyBatis-Plus 可以在运行时解析这个方法引用，从而安全地、动态地获取到对应的属性名 (<code>name</code>)，并根据驼峰命名或注解规则映射到数据库的列名 (<code>name</code> 或 <code>user_name</code>)。</p>
<p>这样一来，字段的指定就从一个不安全的<strong>字符串</strong>变成了一个与实体类强关联的<strong>方法引用</strong>。</p>
<hr>
<h4 id="4-2-3-LambdaQueryWrapper"><a href="#4-2-3-LambdaQueryWrapper" class="headerlink" title="4.2.3 LambdaQueryWrapper&lt;T&gt;"></a>4.2.3 <code>LambdaQueryWrapper&lt;T&gt;</code></h4><p>它是 <code>QueryWrapper</code> 的 Lambda 版本，使用方式几乎完全相同，只是将列名的字符串参数替换为了方法引用。</p>
<p><strong>对比示例</strong></p>
<p><strong>场景</strong>：查询所有年龄在 20 到 30 岁之间、名字中包含 “a”、并且邮箱不为空的用户，结果按年龄降序排序。</p>
<p><strong>之前 (使用 <code>QueryWrapper</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">            .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .isNotNull(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">            .orderByDesc(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure>

<p><strong>现在 (使用 <code>LambdaQueryWrapper</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 LambdaQueryWrapper 对象</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaQuery = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用方法引用来指定列，更加安全和直观</span></span><br><span class="line">lambdaQuery.between(User::getAge, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">           .like(User::getName, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">           .isNotNull(User::getEmail)</span><br><span class="line">           .orderByDesc(User::getAge);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行查询</span></span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(lambdaQuery);</span><br></pre></td></tr></table></figure>

<p><strong>LambdaQueryWrapper 的优势</strong></p>
<ol>
<li><strong>编译期安全</strong>：如果你写的 <code>User::getNamae</code> 是一个不存在的方法，代码将无法通过编译，错误在开发阶段就被发现。</li>
<li><strong>代码可读性与智能提示</strong>：IDE 可以为 <code>User::</code> 提供所有 <code>get</code> 方法的提示，代码意图一目了然。</li>
<li><strong>重构友好</strong>：当你想把 <code>User</code> 类的 <code>name</code> 属性重命名为 <code>username</code> 时，只需使用 IDE 的重构功能（例如 <code>Shift+F6</code>），所有相关的 <code>User::getName</code> 引用都会被自动更新为 <code>User::getUsername</code>，安全可靠。</li>
</ol>
<hr>
<h4 id="4-2-4-LambdaUpdateWrapper"><a href="#4-2-4-LambdaUpdateWrapper" class="headerlink" title="4.2.4 LambdaUpdateWrapper&lt;T&gt;"></a>4.2.4 <code>LambdaUpdateWrapper&lt;T&gt;</code></h4><p>同理，<code>LambdaUpdateWrapper</code> 是 <code>UpdateWrapper</code> 的 Lambda 版本。</p>
<p><strong>对比示例</strong></p>
<p><strong>场景</strong>：将所有名字为 “Sandy” 的用户的年龄更新为 22 岁。</p>
<p><strong>之前 (使用 <code>UpdateWrapper</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">updateWrapper.set(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>)</span><br><span class="line">             .eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Sandy&quot;</span>);</span><br><span class="line">userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br></pre></td></tr></table></figure>

<p><strong>现在 (使用 <code>LambdaUpdateWrapper</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LambdaUpdateWrapper&lt;User&gt; lambdaUpdate = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">lambdaUpdate.set(User::getAge, <span class="number">22</span>)</span><br><span class="line">            .eq(User::getName, <span class="string">&quot;Sandy&quot;</span>);</span><br><span class="line">userMapper.update(<span class="literal">null</span>, lambdaUpdate);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-5-总结与最佳实践"><a href="#4-2-5-总结与最佳实践" class="headerlink" title="4.2.5 总结与最佳实践"></a>4.2.5 总结与最佳实践</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>QueryWrapper</code> (字符串)</th>
<th align="left"><code>LambdaQueryWrapper</code> (Lambda)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>语法</strong></td>
<td align="left"><code>wrapper.eq(&quot;name&quot;, &quot;Tom&quot;)</code></td>
<td align="left"><code>wrapper.eq(User::getName, &quot;Tom&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>类型安全</strong></td>
<td align="left"><strong>无</strong>，依赖字符串的正确性</td>
<td align="left"><strong>有</strong>，依赖方法引用，编译期检查</td>
</tr>
<tr>
<td align="left"><strong>重构支持</strong></td>
<td align="left"><strong>差</strong>，需要手动修改字符串</td>
<td align="left"><strong>优秀</strong>，IDE 可自动重构</td>
</tr>
<tr>
<td align="left"><strong>IDE支持</strong></td>
<td align="left">弱，无代码提示和跳转</td>
<td align="left">强，提供方法提示、补全和跳转</td>
</tr>
<tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left">不推荐在项目中使用</td>
<td align="left"><strong>强烈推荐，是现代 MP 开发的首选</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-3-常用查询方法详解"><a href="#4-3-常用查询方法详解" class="headerlink" title="4.3 常用查询方法详解"></a>4.3 常用查询方法详解</h3><h4 id="4-3-1-查询单个对象-selectOne"><a href="#4-3-1-查询单个对象-selectOne" class="headerlink" title="4.3.1 查询单个对象: selectOne()"></a>4.3.1 查询单个对象: <code>selectOne()</code></h4><ul>
<li><p><strong>方法签名</strong>: <code>T selectOne(Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件查询<strong>一条</strong>记录。</p>
</li>
<li><p><strong>使用场景</strong>: 当你预期查询结果<strong>有且仅有一条</strong>时使用。例如，根据唯一的用户名、邮箱或手机号查询用户信息。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户名为 &quot;admin&quot; 的用户</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(User::getName, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">admin</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (admin != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Found admin user: &quot;</span> + admin);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Admin user not found.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li>如果查询结果<strong>不存在</strong>，此方法返回 <code>null</code>。</li>
<li>如果查询结果<strong>超过一条</strong>，此方法会抛出 <code>TooManyResultsException</code> 异常。这是为了防止脏数据或不严谨的查询条件导致业务逻辑错误，是一个非常重要的保护机制。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-2-查询对象列表-selectList"><a href="#4-3-2-查询对象列表-selectList" class="headerlink" title="4.3.2 查询对象列表: selectList()"></a>4.3.2 查询对象列表: <code>selectList()</code></h4><ul>
<li><p><strong>方法签名</strong>: <code>List&lt;T&gt; selectList(Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件查询<strong>所有</strong>满足条件的记录。这是最常用的查询方法。</p>
</li>
<li><p><strong>使用场景</strong>: 查询满足某个条件的一组数据。例如，查询所有年龄大于 18 岁的用户，或查询某个部门下的所有员工。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有年龄大于 18 岁的用户</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.gt(User::getAge, <span class="number">18</span>);</span><br><span class="line">List&lt;User&gt; adults = userMapper.selectList(wrapper);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Total adult users: &quot;</span> + adults.size());</span><br><span class="line">adults.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li>如果查询结果<strong>不存在</strong>，此方法返回一个<strong>空的 <code>List</code></strong> (<code>Collections.emptyList()</code>)，而<strong>不是 <code>null</code></strong>。这避免了空指针异常，是一个很好的设计。</li>
<li><strong>性能警惕</strong>：当查询的表数据量巨大时，在没有分页的情况下直接调用 <code>selectList</code> 可能会一次性加载大量数据到内存，导致<strong>内存溢出 (OOM)</strong>。务必确保你的查询条件足够精确，或者使用分页查询。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-3-查询记录总数-selectCount"><a href="#4-3-3-查询记录总数-selectCount" class="headerlink" title="4.3.3 查询记录总数: selectCount()"></a>4.3.3 查询记录总数: <code>selectCount()</code></h4><ul>
<li><p><strong>方法签名</strong>: <code>Long selectCount(Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件查询满足条件的记录<strong>总数</strong>。</p>
</li>
<li><p><strong>使用场景</strong>: 获取总数以用于分页显示，或进行业务统计。例如，统计网站的注册用户总数，或搜索结果的总条目数。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计邮箱后缀为 @gmail.com 的用户数量</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.likeRight(User::getEmail, <span class="string">&quot;@gmail.com&quot;</span>); <span class="comment">// email LIKE &#x27;@gmail.com%&#x27;</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.selectCount(wrapper);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Gmail user count: &quot;</span> + count);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li>该方法底层执行的是 <code>SELECT COUNT(*)</code> SQL 语句，比 <code>userMapper.selectList(wrapper).size()</code> 的方式<strong>高效得多</strong>，因为它只返回一个数字，而不需要传输和映射整个结果集。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-4-分页查询-selectPage"><a href="#4-3-4-分页查询-selectPage" class="headerlink" title="4.3.4 分页查询: selectPage()"></a>4.3.4 分页查询: <code>selectPage()</code></h4><ul>
<li><p><strong>方法签名</strong>: <code>IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件进行<strong>物理分页</strong>查询。</p>
</li>
<li><p><strong>使用场景</strong>: Web 后台管理系统的表格数据展示、App 的信息流列表加载等需要分页的场景。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询第二页，每页 5 条数据</span></span><br><span class="line"><span class="comment">// 1. 创建 Page 对象，传入当前页码和每页数量</span></span><br><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 Wrapper (可以为 null，表示查询所有)</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.orderByDesc(User::getId); <span class="comment">// 按 ID 降序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行分页查询，返回 IPage 对象</span></span><br><span class="line">IPage&lt;User&gt; userPage = userMapper.selectPage(page, wrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 从 IPage 对象中获取分页信息</span></span><br><span class="line">System.out.println(<span class="string">&quot;总页数: &quot;</span> + userPage.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;总记录数: &quot;</span> + userPage.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;当前页数据: &quot;</span>);</span><br><span class="line">userPage.getRecords().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li><strong>必须配置分页插件！</strong> 使用此方法前，必须在 Spring Boot 配置中添加 <code>MybatisPlusInterceptor</code> 并注册 <code>PaginationInnerInterceptor</code>。否则，<code>selectPage</code> 方法会退化成 <code>selectList</code>，一次性查询出所有数据，无法实现分页效果，并可能导致内存溢出。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-5-检查存在性-exists-MP-3-5-3-版本"><a href="#4-3-5-检查存在性-exists-MP-3-5-3-版本" class="headerlink" title="4.3.5 检查存在性: exists() (MP 3.5.3+ 版本)"></a>4.3.5 检查存在性: <code>exists()</code> (MP 3.5.3+ 版本)</h4><ul>
<li><p><strong>方法签名</strong>: <code>boolean exists(Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件判断是否存在满足条件的记录。</p>
</li>
<li><p><strong>使用场景</strong>: 需要快速判断数据是否存在，而不需要获取具体数据。例如，注册时检查用户名是否已被占用。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否存在名为 &quot;root&quot; 的用户</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(User::getName, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isExist</span> <span class="operator">=</span> userMapper.exists(wrapper);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Username &#x27;root&#x27; already exists.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li>此方法比 <code>selectCount(wrapper) &gt; 0</code> 的方式<strong>更高效</strong>。因为它底层生成的 SQL 是 <code>SELECT 1 FROM ... LIMIT 1</code>，数据库只要找到第一条匹配的记录就会立即返回，而 <code>COUNT</code> 则需要扫描所有满足条件的记录。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-核心插件机制"><a href="#5-核心插件机制" class="headerlink" title="5. 核心插件机制"></a>5. 核心插件机制</h2><h3 id="5-1-分页插件-PaginationInnerInterceptor"><a href="#5-1-分页插件-PaginationInnerInterceptor" class="headerlink" title="5.1 分页插件 (PaginationInnerInterceptor)"></a>5.1 分页插件 (PaginationInnerInterceptor)</h3><h4 id="5-1-1-为什么需要分页插件？"><a href="#5-1-1-为什么需要分页插件？" class="headerlink" title="5.1.1 为什么需要分页插件？"></a>5.1.1 为什么需要分页插件？</h4><p>如果没有分页插件，实现分页查询会非常痛苦：</p>
<ol>
<li><strong>SQL 方言差异</strong>：不同数据库的分页 SQL 完全不同。MySQL 使用 <code>LIMIT</code>, Oracle 使用 <code>ROWNUM</code>, SQL Server 使用 <code>OFFSET...FETCH...</code>。开发者需要为每种数据库编写不同的分页逻辑。</li>
<li><strong>硬编码与拼接</strong>：开发者需要在代码或 XML 中手动拼接分页参数，容易出错且不安全。</li>
<li><strong>逻辑分页的陷阱</strong>：一种错误的做法是查询出所有数据，然后在 Java 内存中进行分页（逻辑分页）。当数据量巨大时，这会立即导致<strong>内存溢出 (OOM)</strong>。</li>
</ol>
<p>MP 的分页插件通过<strong>拦截并改写 SQL</strong>的方式，实现了<strong>物理分页</strong>，从根本上解决了以上所有问题。</p>
<hr>
<h4 id="5-1-2-插件的核心原理"><a href="#5-1-2-插件的核心原理" class="headerlink" title="5.1.2 插件的核心原理"></a>5.1.2 插件的核心原理</h4><p><code>PaginationInnerInterceptor</code> 是 MyBatis-Plus 拦截器链中的一个内部拦截器。它的工作原理如下：</p>
<ol>
<li><strong>拦截</strong>：当 MP 执行一个 Mapper 方法时，<code>MybatisPlusInterceptor</code> 会拦截这次调用。</li>
<li><strong>判断</strong>：<code>PaginationInnerInterceptor</code> 会检查方法的参数中是否包含 <code>IPage</code> 接口的实现类（通常是 <code>Page</code> 对象）。如果包含，就认为这是一次分页查询。</li>
<li><strong>改写 SQL</strong>: 插件会获取本次查询的原始 SQL 语句，并根据配置的数据库类型 (<code>DbType</code>) 和 <code>Page</code> 对象中的分页参数（当前页 <code>current</code>、每页数量 <code>size</code>），自动在原始 SQL 的末尾追加上对应数据库的分页语句（如 <code>LIMIT ?,?</code>）。</li>
<li><strong>执行查询</strong>: 执行被改写后的分页 SQL，获取当前页的数据。</li>
<li><strong>执行 Count 查询</strong>: 插件会自动生成一条 <code>SELECT COUNT(*)</code> 语句（基于原始 SQL）来查询满足条件的总记录数。</li>
<li><strong>封装返回</strong>: 将查询到的当前页数据列表、总记录数、总页数等信息全部封装到传入的 <code>Page</code> 对象中，并最终返回。</li>
</ol>
<hr>
<h4 id="5-1-3-如何配置-Spring-Boot"><a href="#5-1-3-如何配置-Spring-Boot" class="headerlink" title="5.1.3 如何配置 (Spring Boot)"></a>5.1.3 如何配置 (Spring Boot)</h4><p>自 MP 3.4.0 版本起，官方推荐使用 <code>MybatisPlusInterceptor</code> 来统一管理所有内部拦截器。</p>
<ol>
<li>创建一个配置类（例如 <code>MybatisPlusConfig.java</code>）。</li>
<li>将 <code>MybatisPlusInterceptor</code> 注册为一个 Spring Bean。</li>
<li>向 <code>MybatisPlusInterceptor</code> 中添加 <code>PaginationInnerInterceptor</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/config/MybatisPlusConfig.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加分页插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 定义 MybatisPlusInterceptor 拦截器</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 添加具体的分页插件 PaginationInnerInterceptor</span></span><br><span class="line">        <span class="comment">//    参数指定了数据库类型，MP 会根据该类型生成对应的分页 SQL</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL)); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置说明</strong>:</p>
<ul>
<li><code>DbType.MYSQL</code>: 明确指定数据库类型为 MySQL。MP 支持所有主流数据库，如 <code>ORACLE</code>, <code>POSTGRE_SQL</code> 等。通常 MP 也能自动识别，但显式指定更稳妥。</li>
<li><strong>必须配置</strong>：如果不配置这个 Bean，所有分页相关的调用 (<code>selectPage</code>) 都不会生效，会退化为查询全表数据。</li>
</ul>
<hr>
<h4 id="5-1-4-如何使用"><a href="#5-1-4-如何使用" class="headerlink" title="5.1.4 如何使用"></a>5.1.4 如何使用</h4><p>配置完成后，在 Service 或 Mapper 中使用分页查询就变得非常简单。</p>
<p><strong>核心步骤</strong>：</p>
<ol>
<li>创建一个 <code>Page&lt;T&gt;</code> 对象，指定<strong>当前页码 (current)</strong> 和 <strong>每页显示条数 (size)</strong>。</li>
<li>（可选）创建一个 <code>Wrapper</code> 来设置查询条件。</li>
<li>调用 <code>mapper.selectPage(page, wrapper)</code> 或 <code>service.page(page, wrapper)</code> 方法。</li>
<li>从返回的 <code>IPage&lt;T&gt;</code> 对象中获取分页结果。</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IPage&lt;User&gt; <span class="title function_">findUsersByPage</span><span class="params">(<span class="type">int</span> currentPage, <span class="type">int</span> pageSize, Integer minAge)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 Page 对象</span></span><br><span class="line">        <span class="comment">// 参数：当前页，每页大小</span></span><br><span class="line">        Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(currentPage, pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建查询条件 Wrapper</span></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (minAge != <span class="literal">null</span>) &#123;</span><br><span class="line">            wrapper.ge(User::getAge, minAge);</span><br><span class="line">        &#125;</span><br><span class="line">        wrapper.orderByDesc(User::getId); <span class="comment">// 按 ID 降序排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行分页查询。</span></span><br><span class="line">        <span class="comment">// MP 会自动将查询结果和分页信息封装到 page 对象中</span></span><br><span class="line">        <span class="comment">// 注意：selectPage 方法的返回值就是传入的 page 对象，也可以不接收返回值直接使用 page。</span></span><br><span class="line">        IPage&lt;User&gt; userPage = <span class="built_in">this</span>.baseMapper.selectPage(page, wrapper);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 从 IPage 对象中获取分页信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;查询结果--------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总记录数: &quot;</span> + userPage.getTotal());</span><br><span class="line">        System.out.println(<span class="string">&quot;总页数: &quot;</span> + userPage.getPages());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页码: &quot;</span> + userPage.getCurrent());</span><br><span class="line">        System.out.println(<span class="string">&quot;每页数量: &quot;</span> + userPage.getSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页数据: &quot;</span>);</span><br><span class="line">        userPage.getRecords().forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> userPage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-1-5-总结与注意事项"><a href="#5-1-5-总结与注意事项" class="headerlink" title="5.1.5 总结与注意事项"></a>5.1.5 总结与注意事项</h4><ul>
<li><strong>必须配置</strong>：分页插件不是开箱即用的，必须手动将其配置为 Spring Bean。</li>
<li><strong>物理分页</strong>：插件实现的是物理分页，直接在数据库层面完成数据筛选，性能高，内存占用小。</li>
<li><strong>两次 SQL</strong>：一次 <code>selectPage</code> 调用通常会触发<strong>两次</strong>数据库查询：一次是获取总记录数的 <code>COUNT(*)</code> 查询，另一次是获取当前页数据的分页查询。</li>
<li><strong><code>IPage</code> 返回值</strong>：分页查询的返回结果是一个 <code>IPage</code> 对象（<code>Page</code> 是其实现类），它包含了分页所需的所有信息（数据列表、总数、总页数等），可以直接返回给前端进行渲染。</li>
<li><strong>参数传递</strong>：<code>Page</code> 对象是作为参数传入的，MP 在执行过程中会修改这个对象的内容，而不是创建一个新的对象。</li>
</ul>
<hr>
<h3 id="5-2-乐观锁插件-OptimisticLockerInnerInterceptor"><a href="#5-2-乐观锁插件-OptimisticLockerInnerInterceptor" class="headerlink" title="5.2 乐观锁插件 (OptimisticLockerInnerInterceptor)"></a>5.2 乐观锁插件 (OptimisticLockerInnerInterceptor)</h3><p>在多线程或分布式高并发场景下，数据的一致性至关重要。”更新丢失” (Lost Update) 是一个常见的问题：当多个线程同时读取同一条数据，各自修改后又写回数据库，最后一个写回的操作会覆盖掉之前的所有修改，导致数据丢失。</p>
<p><strong>解决并发更新问题的两种主要方式</strong>：</p>
<ol>
<li><strong>悲观锁 (Pessimistic Locking)</strong>: 认为数据冲突总是会发生。在整个数据处理过程中，将数据锁定，阻止其他线程访问。数据库的行锁、表锁（如 <code>SELECT ... FOR UPDATE</code>）都属于悲观锁。<strong>优点</strong>是数据安全，<strong>缺点</strong>是并发性能差。</li>
<li><strong>乐观锁 (Optimistic Locking)</strong>: 认为数据冲突是小概率事件。在数据处理过程中不加锁，而是在<strong>提交更新时检查数据是否被其他线程修改过</strong>。如果没有，则更新成功；如果已被修改，则更新失败，由调用方决定如何处理（如重试或提示用户）。</li>
</ol>
<p>MyBatis-Plus 提供的 <code>OptimisticLockerInnerInterceptor</code> 就是一个优雅的乐观锁实现方案。</p>
<hr>
<h4 id="5-2-1-乐观锁的实现原理"><a href="#5-2-1-乐观锁的实现原理" class="headerlink" title="5.2.1 乐观锁的实现原理"></a>5.2.1 乐观锁的实现原理</h4><p>MP 的乐观锁插件基于 <strong>版本号 (version)</strong> 机制：</p>
<ol>
<li><p>在数据库表中增加一个整型字段，通常命名为 <code>version</code>，用于记录数据的版本号。</p>
</li>
<li><p><strong>读取数据</strong>：当查询数据时，将 <code>version</code> 字段的值一并读出。</p>
</li>
<li><p><strong>更新数据</strong>：当执行更新操作时，将<strong>当前持有的 <code>version</code> 值作为 <code>WHERE</code> 条件的一部分</strong>。同时，在 <code>SET</code> 子句中将 <code>version</code> 值<strong>加一</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设读取出的 version 是 1</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;New Name&#x27;</span>, version <span class="operator">=</span> <span class="number">2</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> version <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果判断</strong>：</p>
<ul>
<li>如果 <code>WHERE</code> 条件匹配（<code>id=1</code> 且 <code>version=1</code>），说明在你读取数据到提交更新的这段时间内，数据没有被其他线程修改过。更新成功，受影响行数为 1。</li>
<li>如果 <code>WHERE</code> 条件不匹配（受影响行数为 0），说明在你准备更新时，已经有其他线程修改了这条数据，使其 <code>version</code> 值不再是 1。更新失败，表示发生了并发冲突。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-2-2-如何在-MyBatis-Plus-中使用"><a href="#5-2-2-如何在-MyBatis-Plus-中使用" class="headerlink" title="5.2.2 如何在 MyBatis-Plus 中使用"></a>5.2.2 如何在 MyBatis-Plus 中使用</h4><p>使用乐观锁插件非常简单，只需三步：</p>
<p><strong>第 1 步：修改数据库表结构</strong></p>
<p>在需要进行乐观锁控制的表中，添加一个 <code>version</code> 字段（字段名可自定义）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `version` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;版本号&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：初始值建议设为 <code>1</code> 或 <code>0</code>。</p>
<p><strong>第 2 步：修改实体类</strong></p>
<p>在对应的实体类中，添加 <code>version</code> 属性，并使用 <code>@Version</code> 注解标记它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.Version;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Version</span> <span class="comment">// 标记这是一个乐观锁版本号字段</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 3 步：配置乐观锁插件</strong></p>
<p>和分页插件一样，将 <code>OptimisticLockerInnerInterceptor</code> 添加到 <code>MybatisPlusInterceptor</code> 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/config/MybatisPlusConfig.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加分页插件 (注意插件的添加顺序)</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL)); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：插件的添加顺序可能会影响其行为，通常建议将功能性插件（如乐观锁）放在分页等流程性插件之前。</p>
<hr>
<h4 id="5-2-3-使用示例"><a href="#5-2-3-使用示例" class="headerlink" title="5.2.3 使用示例"></a>5.2.3 使用示例</h4><p>配置完成后，乐观锁插件会自动对<strong>包含 <code>@Version</code> 字段</strong>的实体的<strong>更新操作</strong>生效。你无需在业务代码中做任何特殊处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOptimisticLocker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 小王查询商品信息，此时 version=1</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p1</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小王查询到的版本号: &quot;</span> + p1.getVersion());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 小李也查询该商品信息，此时 version=1</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p2</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李查询到的版本号: &quot;</span> + p2.getVersion());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 小王将商品价格修改为 90 元，并提交更新</span></span><br><span class="line">    p1.setPrice(<span class="number">90</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> productMapper.updateById(p1);</span><br><span class="line">    System.out.println(<span class="string">&quot;小王更新结果: &quot;</span> + (result1 &gt; <span class="number">0</span> ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>));</span><br><span class="line">    <span class="comment">// 此时数据库中 version 变为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 小李将商品价格修改为 110 元，并提交更新</span></span><br><span class="line">    p2.setPrice(<span class="number">110</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> productMapper.updateById(p2); <span class="comment">// 提交时携带的 version 仍然是 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;小李更新结果: &quot;</span> + (result2 &gt; <span class="number">0</span> ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>));</span><br><span class="line">    <span class="comment">// 由于数据库 version 已经是 2，而小李的更新条件是 version=1，所以更新失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 查看最终的商品信息</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">finalProduct</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;最终商品价格: &quot;</span> + finalProduct.getPrice()); <span class="comment">// 应该是 90</span></span><br><span class="line">    System.out.println(<span class="string">&quot;最终版本号: &quot;</span> + finalProduct.getVersion());   <span class="comment">// 应该是 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插件在背后做了什么？</strong></p>
<p>当执行 <code>productMapper.updateById(p2)</code> 时，插件会自动将 SQL 改写为：<code>UPDATE product SET price=110, version=2 WHERE id=1 AND version=1</code></p>
<p>由于数据库中的 <code>version</code> 已经是 2，这个 <code>UPDATE</code> 语句的 <code>WHERE</code> 条件不成立，执行后影响行数为 0，因此 <code>updateById</code> 方法返回 0，表示更新失败。</p>
<hr>
<h4 id="5-2-4-适用场景与注意事项"><a href="#5-2-4-适用场景与注意事项" class="headerlink" title="5.2.4 适用场景与注意事项"></a>5.2.4 适用场景与注意事项</h4><ul>
<li><strong>适用场景</strong>：适用于**“读多写少”**的并发场景。如果写操作非常频繁，冲突会经常发生，导致大量更新失败和重试，反而降低了系统性能。在这种情况下，悲观锁可能更合适。</li>
<li><strong>仅支持特定方法</strong>：乐观锁插件仅对 <code>updateById(T)</code> 和 <code>update(T, Wrapper)</code> 方法生效。对于自定义的 XML 更新语句，插件不会生效，你需要手动在 SQL 中实现版本号的判断和递增。</li>
<li><strong>失败处理</strong>：当更新失败时（返回值为 0 或 false），业务代码需要进行处理，例如：抛出异常提示用户“操作失败，请刷新重试”，或者加入循环进行一定次数的重试。</li>
<li><strong>CAS 思想</strong>：乐观锁的本质是 CAS (Compare-and-Swap) 思想，即“比较并交换”。</li>
</ul>
<hr>
<h2 id="6-代码生成器-AutoGenerator"><a href="#6-代码生成器-AutoGenerator" class="headerlink" title="6. 代码生成器 (AutoGenerator)"></a>6. 代码生成器 (AutoGenerator)</h2><p>在项目开发初期，搭建项目骨架和创建各个分层的基础类（如 Entity, Mapper, Service, Controller）是一项重复性高、技术含量低但又非常耗时的工作。MyBatis-Plus 的代码生成器 (<code>AutoGenerator</code>) 就是为了解决这一痛点而生的，它可以根据数据库表结构，<strong>一键生成</strong>项目所需的基础代码，极大地提升开发效率。</p>
<h3 id="6-1-核心功能与优势"><a href="#6-1-核心功能与优势" class="headerlink" title="6.1 核心功能与优势"></a>6.1 核心功能与优势</h3><ul>
<li><strong>全方位代码生成</strong>: 可以自动生成从数据层到表现层的全套代码，包括：<ul>
<li><strong>Entity</strong> (实体类)</li>
<li><strong>Mapper</strong> (接口)</li>
<li><strong>Mapper.xml</strong> (XML映射文件)</li>
<li><strong>Service</strong> (业务接口)</li>
<li><strong>ServiceImpl</strong> (业务实现类)</li>
<li><strong>Controller</strong> (控制器)</li>
</ul>
</li>
<li><strong>高度可配置</strong>: 提供了丰富的配置选项，允许你自定义生成的代码，包括：<ul>
<li>作者、输出目录、文件覆盖策略。</li>
<li>要生成的表、要排除的表、表&#x2F;字段前缀。</li>
<li>实体类的命名策略（驼峰）、Lombok 支持、主键策略。</li>
<li>自定义模板引擎（默认 Velocity，可选 FreeMarker）。</li>
</ul>
</li>
<li><strong>解放生产力</strong>: 将开发者从繁琐的“CV大法”中解放出来，使其能够更专注于业务逻辑的实现，尤其是在微服务架构或新项目启动阶段，效果显著。</li>
</ul>
<hr>
<h3 id="6-2-如何使用"><a href="#6-2-如何使用" class="headerlink" title="6.2 如何使用"></a>6.2 如何使用</h3><p>使用代码生成器通常需要以下步骤：</p>
<ol>
<li><p><strong>添加依赖</strong>: 在项目中添加代码生成器引擎的依赖。MyBatis-Plus 默认使用 Velocity 模板引擎。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意：此依赖仅在开发阶段使用，可以放在 &lt;scope&gt;test&lt;/scope&gt; 或不打包到生产环境 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 版本最好与 mybatis-plus-boot-starter 一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果使用 Freemarker 引擎 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    &lt;version&gt;2.3.31&lt;/version&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编写生成器主类</strong>: 创建一个独立的 Java main 方法来运行代码生成器。这通常放在 <code>src/test/java</code> 目录下，因为它不属于项目的业务代码。</p>
</li>
<li><p><strong>进行配置</strong>: 代码生成器的配置主要分为几个部分：</p>
<ul>
<li><strong>全局配置 (<code>GlobalConfig</code>)</strong>: 设置作者、输出路径、是否覆盖文件等。</li>
<li><strong>数据源配置 (<code>DataSourceConfig</code>)</strong>: 配置数据库连接信息。</li>
<li><strong>包配置 (<code>PackageConfig</code>)</strong>: 设置各层代码生成的包名。</li>
<li><strong>策略配置 (<code>StrategyConfig</code>)</strong>: <strong>核心配置</strong>，用于设置表映射、命名策略、要生成的表、Lombok 支持等。</li>
<li><strong>模板配置 (<code>TemplateConfig</code>)</strong>: （可选）自定义要生成的模板文件路径。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-3-示例代码"><a href="#6-3-示例代码" class="headerlink" title="6.3 示例代码"></a>6.3 示例代码</h3><p>以下是一个完整且带有详细注释的代码生成器示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test/java/com/example/CodeGenerator.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.FastAutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.OutputFile;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; <span class="comment">// 如果使用Freemarker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 数据库连接信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dbUrl</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/your_database?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbUsername</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbPassword</span> <span class="operator">=</span> <span class="string">&quot;your_password&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取项目路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FastAutoGenerator.create(dbUrl, dbUsername, dbPassword)</span><br><span class="line">            <span class="comment">// 1. 全局配置</span></span><br><span class="line">            .globalConfig(builder -&gt; &#123;</span><br><span class="line">                builder.author(<span class="string">&quot;YourName&quot;</span>) <span class="comment">// 设置作者</span></span><br><span class="line">                       .outputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>) <span class="comment">// 指定输出目录</span></span><br><span class="line">                       .commentDate(<span class="string">&quot;yyyy-MM-dd&quot;</span>) <span class="comment">// 注释日期格式</span></span><br><span class="line">                       .disableOpenDir(); <span class="comment">// 禁止生成后打开资源管理器</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 2. 包配置</span></span><br><span class="line">            .packageConfig(builder -&gt; &#123;</span><br><span class="line">                builder.parent(<span class="string">&quot;com.example&quot;</span>) <span class="comment">// 设置父包名</span></span><br><span class="line">                       .moduleName(<span class="string">&quot;system&quot;</span>) <span class="comment">// 设置父包模块名</span></span><br><span class="line">                       .entity(<span class="string">&quot;entity&quot;</span>)</span><br><span class="line">                       .service(<span class="string">&quot;service&quot;</span>)</span><br><span class="line">                       .serviceImpl(<span class="string">&quot;service.impl&quot;</span>)</span><br><span class="line">                       .mapper(<span class="string">&quot;mapper&quot;</span>)</span><br><span class="line">                       .xml(<span class="string">&quot;mapper.xml&quot;</span>)</span><br><span class="line">                       .controller(<span class="string">&quot;controller&quot;</span>)</span><br><span class="line">                       .pathInfo(Collections.singletonMap(OutputFile.xml, projectPath + <span class="string">&quot;/src/main/resources/mapper/system&quot;</span>)); <span class="comment">// 设置 mapperXml 生成路径</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 3. 策略配置</span></span><br><span class="line">            .strategyConfig(builder -&gt; &#123;</span><br><span class="line">                builder.addInclude(<span class="string">&quot;sys_user&quot;</span>, <span class="string">&quot;sys_role&quot;</span>) <span class="comment">// 设置需要生成的表名，可变参数</span></span><br><span class="line">                       .addTablePrefix(<span class="string">&quot;t_&quot;</span>, <span class="string">&quot;sys_&quot;</span>) <span class="comment">// 设置过滤表前缀</span></span><br><span class="line"></span><br><span class="line">                       <span class="comment">// Entity 策略配置</span></span><br><span class="line">                       .entityBuilder()</span><br><span class="line">                       .enableLombok() <span class="comment">// 开启 Lombok</span></span><br><span class="line">                       .enableTableFieldAnnotation() <span class="comment">// 开启生成实体时生成字段注解</span></span><br><span class="line">                       </span><br><span class="line">                       <span class="comment">// Controller 策略配置</span></span><br><span class="line">                       .controllerBuilder()</span><br><span class="line">                       .enableRestStyle() <span class="comment">// 开启生成 @RestController 控制器</span></span><br><span class="line">                       </span><br><span class="line">                       <span class="comment">// Service 策略配置</span></span><br><span class="line">                       .serviceBuilder()</span><br><span class="line">                       .formatServiceFileName(<span class="string">&quot;%sService&quot;</span>) <span class="comment">// Service 文件名格式</span></span><br><span class="line">                       .formatServiceImplFileName(<span class="string">&quot;%sServiceImpl&quot;</span>) <span class="comment">// ServiceImpl 文件名格式</span></span><br><span class="line">                       </span><br><span class="line">                       <span class="comment">// Mapper 策略配置</span></span><br><span class="line">                       .mapperBuilder()</span><br><span class="line">                       .enableBaseResultMap() <span class="comment">// 启用 BaseResultMap 生成</span></span><br><span class="line">                       .enableBaseColumnList(); <span class="comment">// 启用 BaseColumnList</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 4. 模板引擎配置 (可选，MP 默认使用 Velocity)</span></span><br><span class="line">            <span class="comment">// .templateEngine(new FreemarkerTemplateEngine()) </span></span><br><span class="line">            </span><br><span class="line">            .execute(); <span class="comment">// 执行生成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-核心配置项详解-strategyConfig"><a href="#6-4-核心配置项详解-strategyConfig" class="headerlink" title="6.4 核心配置项详解 (strategyConfig)"></a>6.4 核心配置项详解 (<code>strategyConfig</code>)</h3><ul>
<li><strong><code>addInclude(&quot;table1&quot;, &quot;table2&quot;)</code></strong>: 指定要为哪些表生成代码。如果不设置，则默认生成所有表。</li>
<li><strong><code>addExclude(&quot;table_to_ignore&quot;)</code></strong>: 指定不为哪些表生成代码。</li>
<li><strong><code>addTablePrefix(&quot;t_&quot;, &quot;c_&quot;)</code></strong>: 在生成实体类名时，会自动移除这些表名前缀。例如，表名 <code>t_user</code> 会生成实体类 <code>User</code>。</li>
<li><strong><code>entityBuilder()</code></strong>: 进入实体类配置。<ul>
<li><strong><code>.enableLombok()</code></strong>: 自动为实体类添加 <code>@Data</code> 等 Lombok 注解。</li>
<li><strong><code>.logicDeleteColumnName(&quot;deleted&quot;)</code></strong>: 指定逻辑删除字段名。</li>
<li><strong><code>.versionColumnName(&quot;version&quot;)</code></strong>: 指定乐观锁版本号字段名。</li>
</ul>
</li>
<li><strong><code>controllerBuilder()</code></strong>: 进入 Controller 配置。<ul>
<li><strong><code>.enableRestStyle()</code></strong>: 生成的 Controller 会自带 <code>@RestController</code> 注解。</li>
</ul>
</li>
<li><strong><code>mapperBuilder()</code></strong>: 进入 Mapper 配置。<ul>
<li><strong><code>.enableBaseResultMap()</code></strong>: 会在生成的 Mapper.xml 文件中自动创建 <code>&lt;resultMap&gt;</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-5-最佳实践"><a href="#6-5-最佳实践" class="headerlink" title="6.5 最佳实践"></a>6.5 最佳实践</h3><ol>
<li><strong>独立模块或测试目录</strong>: 将代码生成器的代码放在项目的 <code>src/test/java</code> 目录下，或者创建一个专门的 <code>generator</code> 模块，避免将其打包到生产环境中。</li>
<li><strong>按需生成</strong>: 在 <code>addInclude</code> 中明确指定需要生成的表，而不是生成所有表，避免产生不必要的代码。</li>
<li><strong>覆盖策略</strong>: 默认情况下，如果文件已存在，生成器不会覆盖。如果需要重新生成，可以在 <code>globalConfig</code> 中配置 <code>.fileOverride()</code>。但请注意，这会覆盖你手动修改过的代码，务必谨慎使用。</li>
<li><strong>多次使用</strong>: 在项目迭代过程中，如果新增了表，只需修改 <code>addInclude</code> 中的表名，然后重新运行生成器即可，非常方便。</li>
</ol>
<hr>
<h2 id="7-高级特性"><a href="#7-高级特性" class="headerlink" title="7. 高级特性"></a>7. 高级特性</h2><h3 id="7-1-逻辑删除"><a href="#7-1-逻辑删除" class="headerlink" title="7.1 逻辑删除"></a>7.1 逻辑删除</h3><h4 id="7-1-1-什么是逻辑删除？"><a href="#7-1-1-什么是逻辑删除？" class="headerlink" title="7.1.1 什么是逻辑删除？"></a>7.1.1 什么是逻辑删除？</h4><p>在业务系统中，删除操作通常分为两种：</p>
<ol>
<li><strong>物理删除 (Physical Delete)</strong>: 直接从数据库中执行 <code>DELETE</code> 语句，将数据行<strong>永久抹除</strong>。这种操作是不可逆的。</li>
<li><strong>逻辑删除 (Logical Delete &#x2F; Soft Delete)</strong>: 并<strong>不真正删除</strong>数据，而是通过一个特定的字段（例如 <code>is_deleted</code>, <code>status</code> 等）来<strong>标记</strong>这条数据的状态为“已删除”。对于应用程序来说，这条数据就如同被删除了一样，在正常的查询中不会再出现。</li>
</ol>
<p>MyBatis-Plus 提供的逻辑删除功能，就是对<strong>逻辑删除</strong>操作的完美封装和自动化。</p>
<hr>
<h4 id="7-1-2-为什么使用逻辑删除？"><a href="#7-1-2-为什么使用逻辑删除？" class="headerlink" title="7.1.2 为什么使用逻辑删除？"></a>7.1.2 为什么使用逻辑删除？</h4><p>使用逻辑删除主要有以下几个核心优势：</p>
<ul>
<li><strong>数据可恢复</strong>: 这是最大的优点。如果发生误删除操作，只需将标记字段的状态改回去，数据就能立刻恢复，避免了从数据库备份中恢复数据的复杂过程。</li>
<li><strong>保留数据完整性</strong>: 在复杂的关联关系中，物理删除一条主记录可能会导致关联的子记录成为“孤儿数据”，或者因为外键约束而删除失败。逻辑删除则可以保留这些关联关系。</li>
<li><strong>便于审计与追溯</strong>: 所有的数据操作历史都被保留在数据库中，便于日后进行数据审计、问题排查和行为分析。</li>
<li><strong>操作安全</strong>: 避免了因 <code>DELETE</code> 语句 <code>WHERE</code> 条件错误而导致灾难性数据丢失的风险。</li>
</ul>
<hr>
<h4 id="7-1-3-MyBatis-Plus-中的实现原理"><a href="#7-1-3-MyBatis-Plus-中的实现原理" class="headerlink" title="7.1.3 MyBatis-Plus 中的实现原理"></a>7.1.3 MyBatis-Plus 中的实现原理</h4><p>MyBatis-Plus 的逻辑删除功能是通过其<strong>拦截器机制</strong>实现的，对开发者完全透明：</p>
<ol>
<li><strong>改写 <code>DELETE</code></strong>: 当你调用 <code>deleteById()</code> 或 <code>removeById()</code> 等删除方法时，MP 拦截器会捕获这个操作，并自动将其<strong>改写</strong>为一个 <code>UPDATE</code> 语句。<ul>
<li><strong>原始意图</strong>: <code>DELETE FROM user WHERE id = ?</code></li>
<li><strong>MP 实际执行</strong>: <code>UPDATE user SET deleted = 1 WHERE id = ? AND deleted = 0</code></li>
</ul>
</li>
<li><strong>过滤 <code>SELECT</code></strong>: 当你调用 <code>selectList()</code>, <code>selectById()</code>, <code>selectPage()</code> 等所有查询方法时，MP 拦截器会自动在 <code>WHERE</code> 子句的末尾<strong>追加</strong>逻辑删除字段的过滤条件。<ul>
<li><strong>原始意图</strong>: <code>SELECT * FROM user WHERE name = &#39;Tom&#39;</code></li>
<li><strong>MP 实际执行</strong>: <code>SELECT * FROM user WHERE name = &#39;Tom&#39; AND deleted = 0</code></li>
</ul>
</li>
<li><strong>过滤 <code>UPDATE</code></strong>: 同样，在执行更新操作时，也会自动追加过滤条件，以确保你不会更新到一条已经被“删除”的数据。</li>
</ol>
<hr>
<h4 id="7-1-4-如何配置和使用"><a href="#7-1-4-如何配置和使用" class="headerlink" title="7.1.4 如何配置和使用"></a>7.1.4 如何配置和使用</h4><p>在 MP 中启用逻辑删除非常简单，只需两到三步：</p>
<p><strong>第 1 步：数据库表</strong></p>
<p>在需要逻辑删除的表中，增加一个用于标记状态的字段，例如 <code>deleted</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `deleted` TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;逻辑删除标记 0-未删除 1-已删除&#x27;</span>;</span><br><span class="line"><span class="comment">-- 建议为该字段添加索引，以提高查询性能</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_deleted <span class="keyword">ON</span> <span class="keyword">user</span>(deleted);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 必须为该字段设置一个默认值（通常是 <code>0</code> 表示未删除）。</p>
<p><strong>第 2 步：实体类</strong></p>
<p>在对应的实体类中，添加该字段，并使用 <code>@TableLogic</code> 注解标记。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableLogic;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TableLogic</span> <span class="comment">// 标记为逻辑删除字段</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 3 步：全局配置 (可选，但强烈推荐)</strong></p>
<p>虽然 <code>@TableLogic</code> 注解可以指定删除和未删除的值，但在 <code>application.yml</code> 或 <code>properties</code> 中进行全局配置是更好的实践，可以统一管理。</p>
<p><strong><code>application.yml</code> 示例:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 逻辑删除字段名 (全局)</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> </span><br><span class="line">      <span class="comment"># 逻辑删除值 (默认为 1)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># 逻辑未删除值 (默认为 0)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>全局配置 vs 注解</strong>: 如果同时进行了全局配置和 <code>@TableLogic</code> 注解配置，<strong>注解的优先级更高</strong>。</li>
</ul>
<hr>
<h4 id="7-1-5-实际效果"><a href="#7-1-5-实际效果" class="headerlink" title="7.1.5 实际效果"></a>7.1.5 实际效果</h4><p>配置完成后，所有操作都会被 MP 自动处理：</p>
<ul>
<li><p><strong>执行删除</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.deleteById(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL</strong>: <code>UPDATE user SET deleted=1 WHERE id=1 AND deleted=0</code></p>
</li>
<li><p><strong>执行查询</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有用户</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL</strong>: <code>SELECT id,name,age,email,deleted FROM user WHERE deleted=0</code></p>
</li>
<li><p><strong>执行更新</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">1L</span>);</span><br><span class="line">user.setAge(<span class="number">30</span>);</span><br><span class="line">userMapper.updateById(user);</span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL</strong>: <code>UPDATE user SET age=30 WHERE id=1 AND deleted=0</code></p>
</li>
</ul>
<hr>
<h4 id="7-1-6-如何查询被逻辑删除的数据？"><a href="#7-1-6-如何查询被逻辑删除的数据？" class="headerlink" title="7.1.6 如何查询被逻辑删除的数据？"></a>7.1.6 如何查询被逻辑删除的数据？</h4><p>一个常见的需求是，管理员需要一个“回收站”功能来查看并恢复被删除的数据。由于 MP 的查询会自动过滤掉已删除数据，你需要<strong>手写 SQL</strong> 来绕过这个机制。</p>
<p>在 <code>UserMapper</code> 接口中定义一个自定义方法，并在对应的 XML 文件中编写 SQL：</p>
<p><strong><code>UserMapper.java</code></strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectDeletedUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>UserMapper.xml</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDeletedUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.entity.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE deleted = 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过这种方式，你可以精确控制何时需要忽略逻辑删除的过滤规则。</p>
<hr>
<h3 id="7-2-自动填充-MetaObjectHandler"><a href="#7-2-自动填充-MetaObjectHandler" class="headerlink" title="7.2 自动填充 (MetaObjectHandler)"></a>7.2 自动填充 (MetaObjectHandler)</h3><p>在大多数业务系统中，许多数据表都包含一些公共字段，如 <code>create_time</code>（创建时间）、<code>update_time</code>（更新时间）、<code>create_by</code>（创建人）、<code>update_by</code>（更新人）等。这些字段的值通常具有固定的填充规则，例如在插入数据时自动设置创建时间和更新时间，在更新数据时自动设置更新时间。</p>
<p>如果在每个 Service 的 <code>save</code> 和 <code>update</code> 方法中都手动设置这些值，不仅会导致大量重复代码，还容易遗漏。</p>
<p>MyBatis-Plus 的<strong>自动填充</strong>功能 (<code>MetaObjectHandler</code>) 就是为了优雅地解决这个问题而设计的。</p>
<hr>
<h4 id="7-2-1-核心思想与原理"><a href="#7-2-1-核心思想与原理" class="headerlink" title="7.2.1 核心思想与原理"></a>7.2.1 核心思想与原理</h4><p><code>MetaObjectHandler</code> 是一个公共字段填充处理器。它的核心思想是利用 AOP（面向切面编程）的理念，在 MP 执行<strong>插入 (<code>insert</code>)</strong> 和 <strong>更新 (<code>update</code>)</strong> 操作时，通过拦截器机制自动对指定字段进行填充。</p>
<p>开发者只需定义一个实现了 <code>MetaObjectHandler</code> 接口的 Bean，并实现其中的 <code>insertFill</code> 和 <code>updateFill</code> 方法，MP 就会在相应的 SQL 执行前调用这些方法，完成对实体对象（<code>metaObject</code>）属性的赋值。</p>
<hr>
<h4 id="7-2-2-如何使用"><a href="#7-2-2-如何使用" class="headerlink" title="7.2.2 如何使用"></a>7.2.2 如何使用</h4><p>实现自动填充功能主要需要三步：</p>
<p><strong>第 1 步：在实体类中标记需要填充的字段</strong></p>
<p>在实体类的属性上，使用 <code>@TableField</code> 注解并指定 <code>fill</code> 策略。</p>
<ul>
<li><code>FieldFill.INSERT</code>: 只在<strong>插入</strong>时填充。</li>
<li><code>FieldFill.UPDATE</code>: 只在<strong>更新</strong>时填充。</li>
<li><code>FieldFill.INSERT_UPDATE</code>: 在<strong>插入和更新</strong>时都填充。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span> <span class="comment">// 插入时填充</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span> <span class="comment">// 插入和更新时都填充</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> String createBy;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> String updateBy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 2 步：创建 <code>MetaObjectHandler</code> 实现类</strong></p>
<p>创建一个类，实现 <code>MetaObjectHandler</code> 接口，并重写 <code>insertFill</code> 和 <code>updateFill</code> 方法。在这个类中定义具体的字段填充逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/handler/MyMetaObjectHandler.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// **重要**：必须将处理器注入到 Spring 容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作时的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject 元数据对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill ....&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 参1: 实体类的属性名, 不是数据库的字段名</span></span><br><span class="line">        <span class="comment">// 参2: 要填充的值</span></span><br><span class="line">        <span class="comment">// 参3: 元数据对象</span></span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 示例：填充创建人（需要从当前会话或安全上下文中获取）</span></span><br><span class="line">        <span class="comment">// String currentUsername = getCurrentUsername(); // 假设有方法可以获取当前用户名</span></span><br><span class="line">        <span class="comment">// this.strictInsertFill(metaObject, &quot;createBy&quot;, String.class, currentUsername);</span></span><br><span class="line">        <span class="comment">// this.strictInsertFill(metaObject, &quot;updateBy&quot;, String.class, currentUsername);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作时的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject 元数据对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill ....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// String currentUsername = getCurrentUsername();</span></span><br><span class="line">        <span class="comment">// this.strictUpdateFill(metaObject, &quot;updateBy&quot;, String.class, currentUsername);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>strict...Fill</code> vs <code>setFieldValByName</code></strong>:</p>
<ul>
<li><code>setFieldValByName(fieldName, fieldVal, metaObject)</code>: 无论属性值是否已存在，都会强制覆盖。</li>
<li><code>strictInsertFill(metaObject, fieldName, fieldType, fieldVal)</code>: 更严谨的版本。它会先判断实体中该属性是否已有值，<strong>只有在值为 <code>null</code> 时才进行填充</strong>。这允许你在业务代码中手动设置一个特定的创建时间，而不会被自动填充覆盖。<code>strictUpdateFill</code> 同理。<strong>官方推荐使用 <code>strict</code> 版本。</strong></li>
</ul>
<p><strong>第 3 步：将 Handler 注册为 Spring Bean</strong></p>
<p>只需在 <code>MyMetaObjectHandler</code> 类上添加 <code>@Component</code> 或 <code>@Configuration</code> 注解，确保它被 Spring IoC 容器管理即可。MyBatis-Plus 的 starter 会自动检测并装配它。</p>
<hr>
<h4 id="7-2-3-实际效果"><a href="#7-2-3-实际效果" class="headerlink" title="7.2.3 实际效果"></a>7.2.3 实际效果</h4><p>配置完成后，当你执行插入或更新操作时，不再需要手动设置这些公共字段。</p>
<p><strong>插入操作</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">userService.save(user); <span class="comment">// 或者 userMapper.insert(user)</span></span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL 会包含自动填充的字段</strong>:</p>
<p><code>INSERT INTO user ( name, create_time, update_time ) VALUES ( &#39;Jack&#39;, &#39;2023-10-27 10:00:00&#39;, &#39;2023-10-27 10:00:00&#39; )</code></p>
<p><strong>更新操作</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(<span class="number">1L</span>);</span><br><span class="line">user.setName(<span class="string">&quot;Jack-updated&quot;</span>);</span><br><span class="line">userService.updateById(user);</span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL 会自动更新 <code>update_time</code> 字段</strong>:</p>
<p><code>UPDATE user SET name=&#39;Jack-updated&#39;, update_time=&#39;2023-10-27 10:05:00&#39; WHERE id=1</code></p>
<hr>
<h4 id="7-2-4-获取当前操作人"><a href="#7-2-4-获取当前操作人" class="headerlink" title="7.2.4 获取当前操作人"></a>7.2.4 获取当前操作人</h4><p>在 <code>MetaObjectHandler</code> 中填充 <code>createBy</code> 和 <code>updateBy</code> 字段是一个常见的需求。这通常需要从当前的用户会话中获取登录信息。一种常见的实现方式是：</p>
<ol>
<li>使用 <strong>Spring Security</strong> 或其他安全框架，用户信息保存在 <code>SecurityContextHolder</code> 中。</li>
<li>使用 <strong><code>ThreadLocal</code></strong>。在请求进入 Controller 或经过某个 Filter&#x2F;Interceptor 时，将当前用户信息存入 <code>ThreadLocal</code>，在 <code>MetaObjectHandler</code> 中从中读取，请求结束后再清除。</li>
</ol>
<hr>
<h3 id="7-3-主键策略"><a href="#7-3-主键策略" class="headerlink" title="7.3 主键策略"></a>7.3 主键策略</h3><h4 id="7-3-1-简介"><a href="#7-3-1-简介" class="headerlink" title="7.3.1 简介"></a>7.3.1 简介</h4><p>主键 (Primary Key, PK) 是数据库中每条记录的唯一标识。如何生成和管理主键，在不同的系统架构下有不同的最佳实践。在单体应用中，数据库的自增 ID (Auto Increment) 简单高效；但在分布式、微服务架构下，依赖单个数据库的自增 ID 会带来扩展性问题和主键冲突的风险。</p>
<p>MyBatis-Plus (MP) 深刻理解这一挑战，内置了多种主键生成策略，并通过简单的配置即可应用，使得主键管理变得异常轻松。</p>
<hr>
<h4 id="7-3-2-配置方式"><a href="#7-3-2-配置方式" class="headerlink" title="7.3.2 配置方式"></a>7.3.2 配置方式</h4><p>MP 主要通过在实体类的主键字段上使用 <code>@TableId</code> 注解来配置主键策略。其核心属性是 <code>type</code>，它接收一个 <code>IdType</code> 枚举值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@TableId</span> 注解用于标识主键字段</span></span><br><span class="line"><span class="comment">     * type 属性用于指定主键生成策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.ASSIGN_ID)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... other fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-3-3-核心主键策略详解"><a href="#7-3-3-核心主键策略详解" class="headerlink" title="7.3.3 核心主键策略详解"></a>7.3.3 核心主键策略详解</h4><p><code>IdType</code> 枚举定义了以下几种常用的主键策略：</p>
<h5 id="1-IdType-AUTO-数据库ID自增"><a href="#1-IdType-AUTO-数据库ID自增" class="headerlink" title="1. IdType.AUTO (数据库ID自增)"></a>1. <code>IdType.AUTO</code> (数据库ID自增)</h5><ul>
<li><strong>描述</strong>: 依赖数据库自身的 ID 自增机制来生成主键。例如 MySQL 的 <code>AUTO_INCREMENT</code>。</li>
<li><strong>如何工作</strong>: 当插入数据时，MP 不会为主键赋值，而是由数据库生成后，再通过 JDBC 将生成的主键值回填到实体对象中。</li>
<li><strong>适用场景</strong>: 单体应用、数据量不大、没有分库分表需求的简单项目。这是最传统、最简单的方式。</li>
<li><strong>配置</strong>: <code>@TableId(type = IdType.AUTO)</code></li>
</ul>
<h5 id="2-IdType-ASSIGN-ID-雪花算法-默认-推荐"><a href="#2-IdType-ASSIGN-ID-雪花算法-默认-推荐" class="headerlink" title="2. IdType.ASSIGN_ID (雪花算法, 默认&#x2F;推荐)"></a>2. <code>IdType.ASSIGN_ID</code> (雪花算法, 默认&#x2F;推荐)</h5><ul>
<li><strong>描述</strong>: MP 默认的主键策略。它使用<strong>雪花算法 (Snowflake)</strong> 在应用程序层面生成一个全局唯一的、趋势递增的 64 位长整型 ID。</li>
<li><strong>雪花算法简介</strong>: 该算法生成的 ID 由 <code>时间戳 + 数据中心ID + 机器ID + 序列号</code> 组合而成，保证了在分布式系统中的全局唯一性和高性能。</li>
<li><strong>优点</strong>:<ul>
<li><strong>全局唯一</strong>: 在分布式环境下，不同机器生成的 ID 不会冲突。</li>
<li><strong>高性能</strong>: ID 在本地生成，不依赖数据库，性能极高。</li>
<li><strong>趋势递增</strong>: ID 整体上随时间增长，有利于数据库索引的性能。</li>
<li><strong>数值类型</strong>: 作为数值型主键，查询效率高于字符串类型。</li>
</ul>
</li>
<li><strong>适用场景</strong>: <strong>微服务、分布式系统、高并发应用</strong>。这是 MP 在分布式场景下的<strong>首选推荐</strong>策略。</li>
<li><strong>配置</strong>: <code>@TableId(type = IdType.ASSIGN_ID)</code> 或不写 <code>type</code> 属性（因为它是默认值）。</li>
</ul>
<h5 id="3-IdType-ASSIGN-UUID-UUID"><a href="#3-IdType-ASSIGN-UUID-UUID" class="headerlink" title="3. IdType.ASSIGN_UUID (UUID)"></a>3. <code>IdType.ASSIGN_UUID</code> (UUID)</h5><ul>
<li><strong>描述</strong>: 使用 UUID (Universally Unique Identifier) 算法生成一个全局唯一的字符串 ID。</li>
<li><strong>如何工作</strong>: 生成一个类似 <code>550e8400-e29b-41d4-a716-446655440000</code> 的 32 位十六进制字符串作为主键。</li>
<li><strong>优点</strong>:<ul>
<li><strong>全局唯一</strong>: 绝对的全局唯一，不依赖任何中心节点。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>字符串类型</strong>: 占用存储空间大，查询性能低于数值型主键。</li>
<li><strong>无序性</strong>: UUID 是无序的，作为主键会导致数据库索引频繁重建，插入性能下降。</li>
<li><strong>可读性差</strong>。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 当主键需要对外暴露，且不希望其具有规律性（如订单号、支付流水号的场景，但通常这些是业务ID而非主键），或者对主键的唯一性要求极高而不在乎性能时。</li>
<li><strong>配置</strong>: <code>@TableId(type = IdType.ASSIGN_UUID)</code></li>
</ul>
<h5 id="4-IdType-INPUT-用户输入"><a href="#4-IdType-INPUT-用户输入" class="headerlink" title="4. IdType.INPUT (用户输入)"></a>4. <code>IdType.INPUT</code> (用户输入)</h5><ul>
<li><strong>描述</strong>: 表示主键由用户或业务代码<strong>手动设置</strong>。MP 不会为其生成任何值。</li>
<li><strong>如何工作</strong>: 在执行 <code>insert</code> 操作之前，你必须手动为实体的主键字段赋一个值。</li>
<li><strong>适用场景</strong>: 当主键本身具有业务含义时，例如使用用户的学号、身份证号、或自定义的编码作为主键。</li>
<li><strong>配置</strong>: <code>@TableId(type = IdType.INPUT)</code></li>
</ul>
<h5 id="5-IdType-NONE-无状态"><a href="#5-IdType-NONE-无状态" class="headerlink" title="5. IdType.NONE (无状态)"></a>5. <code>IdType.NONE</code> (无状态)</h5><ul>
<li><strong>描述</strong>: 表示未设置主键类型，MP 会遵循全局配置。如果全局也未配置，则等同于 <code>INPUT</code>。</li>
</ul>
<h5 id="6-IdType-SEQUENCE-序列"><a href="#6-IdType-SEQUENCE-序列" class="headerlink" title="6. IdType.SEQUENCE (序列)"></a>6. <code>IdType.SEQUENCE</code> (序列)</h5><ul>
<li><strong>描述</strong>: 使用数据库的序列（Sequence）来生成主键。这是 Oracle、PostgreSQL 等数据库推荐的主键生成方式。需要配合 <code>@KeySequence</code> 注解使用。</li>
</ul>
<hr>
<h4 id="7-3-4-全局主键策略配置"><a href="#7-3-4-全局主键策略配置" class="headerlink" title="7.3.4 全局主键策略配置"></a>7.3.4 全局主键策略配置</h4><p>除了在每个实体类上单独配置，你还可以在 <code>application.yml</code> 中配置一个全局的主键生成策略。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 设置全局的主键生成策略为数据库自增</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure>

<p><strong>优先级</strong>: 实体类上的 <code>@TableId</code> 注解配置的优先级 <strong>高于</strong> 全局配置。</p>
<hr>
<h4 id="7-3-5-策略选型总结"><a href="#7-3-5-策略选型总结" class="headerlink" title="7.3.5 策略选型总结"></a>7.3.5 策略选型总结</h4><table>
<thead>
<tr>
<th align="left">策略 (<code>IdType</code>)</th>
<th align="left">描述</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>AUTO</code></td>
<td align="left">数据库自增</td>
<td align="left">简单、连续、易于理解</td>
<td align="left">仅限单数据库，不适用于分布式</td>
<td align="left">单体应用，简单项目</td>
</tr>
<tr>
<td align="left"><strong><code>ASSIGN_ID</code></strong></td>
<td align="left"><strong>雪花算法</strong></td>
<td align="left"><strong>全局唯一、高性能、趋势递增</strong></td>
<td align="left">依赖时间，时钟回拨可能导致问题</td>
<td align="left"><strong>微服务、分布式系统、高并发（强烈推荐）</strong></td>
</tr>
<tr>
<td align="left"><code>ASSIGN_UUID</code></td>
<td align="left">UUID字符串</td>
<td align="left">全局唯一，无中心依赖</td>
<td align="left">字符串性能差、无序、占用空间大</td>
<td align="left">对唯一性要求极高，不关心性能的场景</td>
</tr>
<tr>
<td align="left"><code>INPUT</code></td>
<td align="left">手动输入</td>
<td align="left">灵活，主键可具业务含义</td>
<td align="left">需要手动管理，易出错</td>
<td align="left">主键有明确业务意义（如身份证号）</td>
</tr>
<tr>
<td align="left"><code>SEQUENCE</code></td>
<td align="left">数据库序列</td>
<td align="left">高性能、数据库原生支持</td>
<td align="left">特定数据库（Oracle等）</td>
<td align="left">使用支持序列的数据库时</td>
</tr>
</tbody></table>
<hr>
<hr>
<h1 id="四、JPA-Hibernate"><a href="#四、JPA-Hibernate" class="headerlink" title="四、JPA &amp; Hibernate"></a>四、JPA &amp; Hibernate</h1><h2 id="1-JPA-规范与-Hibernate-实现"><a href="#1-JPA-规范与-Hibernate-实现" class="headerlink" title="1. JPA 规范与 Hibernate 实现"></a>1. JPA 规范与 Hibernate 实现</h2><h3 id="1-1-什么是-JPA-Java-Persistence-API-？"><a href="#1-1-什么是-JPA-Java-Persistence-API-？" class="headerlink" title="1.1 什么是 JPA (Java Persistence API)？"></a>1.1 什么是 JPA (Java Persistence API)？</h3><p><strong>JPA 本质上是一套 Java EE (现为 Jakarta EE) 的技术规范</strong>，由 JSR (Java Specification Request) 定义。它并非一个可以直接使用的框架或工具，而是一系列 <strong>API 接口、注解和查询语言 (JPQL)</strong> 的集合。</p>
<p><strong>JPA 的核心目标是</strong>：为 Java 开发者提供一个<strong>标准化的、与具体 ORM 框架无关</strong>的持久化编程模型。</p>
<p>它主要定义了以下几个方面的内容：</p>
<ol>
<li><strong>ORM 映射元数据 (Mapping Metadata)</strong>:<ul>
<li>通过注解（如 <code>@Entity</code>, <code>@Table</code>, <code>@Id</code>, <code>@Column</code>, <code>@OneToMany</code> 等）或 XML 配置，来定义 Java 对象 (POJO) 与数据库表之间的映射关系。</li>
</ul>
</li>
<li><strong>实体操作 API</strong>:<ul>
<li>定义了一套用于操作实体的标准接口，其中最核心的是 <code>EntityManager</code>。它提供了 <code>persist()</code> (保存), <code>merge()</code> (更新), <code>remove()</code> (删除), <code>find()</code> (查询) 等方法。</li>
</ul>
</li>
<li><strong>查询语言 (JPQL)</strong>:<ul>
<li>定义了一种面向对象的、与具体数据库方言无关的查询语言——Java Persistence Query Language (JPQL)。JPQL 的语法与 SQL 类似，但操作的是<strong>实体对象和属性</strong>，而不是数据库的表和列。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-什么是-Hibernate？"><a href="#1-2-什么是-Hibernate？" class="headerlink" title="1.2 什么是 Hibernate？"></a>1.2 什么是 Hibernate？</h3><p><strong>Hibernate 是一个功能强大、开源、成熟的 ORM (对象关系映射) 框架</strong>。它是一个<strong>具体的产品</strong>，负责将开发者定义好的对象模型持久化到数据库中。</p>
<p>Hibernate 诞生于 JPA 之前，凭借其强大的功能和灵活性迅速成为 Java 持久化领域的领导者。正因为 Hibernate 的成功，JPA 规范在制定时大量借鉴了 Hibernate 的设计思想。</p>
<p>Hibernate 不仅完整地实现了 JPA 规范定义的所有功能，还提供了许多<strong>超越 JPA 规范的、自身特有的高级功能</strong>，例如：</p>
<ul>
<li>更丰富的查询方式（如 QBC - Query by Criteria API）。</li>
<li>更强大的二级缓存策略和集成方案。</li>
<li>更细粒度的性能调优选项。</li>
<li>特有的 HQL (Hibernate Query Language)，它是 JPQL 的超集。</li>
</ul>
<hr>
<h3 id="1-3-两者的关系：规范与实现"><a href="#1-3-两者的关系：规范与实现" class="headerlink" title="1.3 两者的关系：规范与实现"></a>1.3 两者的关系：规范与实现</h3><p><strong>JPA 是“标准”，Hibernate 是“实现”</strong>。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JPA (Java Persistence API)</th>
<th align="left">Hibernate</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left">一套<strong>技术规范、接口标准</strong></td>
<td align="left">一个<strong>具体的 ORM 框架、JPA 规范的实现</strong></td>
</tr>
<tr>
<td align="left"><strong>提供内容</strong></td>
<td align="left">API 接口 (<code>EntityManager</code>), 注解 (<code>@Entity</code>), JPQL</td>
<td align="left">JPA 规范所有功能的具体实现，以及额外的增强功能</td>
</tr>
<tr>
<td align="left"><strong>可移植性</strong></td>
<td align="left"><strong>高</strong>。应用程序面向 JPA 编程，理论上可以无缝切换 ORM 实现。</td>
<td align="left"><strong>低</strong>。如果代码中使用了 Hibernate 特有的 API，将无法轻松切换到其他框架。</td>
</tr>
<tr>
<td align="left"><strong>依赖关系</strong></td>
<td align="left">Hibernate 依赖并实现了 JPA 规范。</td>
<td align="left">JPA 是一种标准，不依赖任何具体实现。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-4-为什么我们通常将它们一起提及？"><a href="#1-4-为什么我们通常将它们一起提及？" class="headerlink" title="1.4 为什么我们通常将它们一起提及？"></a>1.4 为什么我们通常将它们一起提及？</h3><ol>
<li><strong>Hibernate 是事实上的标准实现</strong>: 尽管存在其他 JPA 实现，但 Hibernate 是最流行、最强大、社区最活跃的一个，绝大多数使用 JPA 的项目底层都默认选择了 Hibernate。</li>
<li><strong>Spring Data JPA 的推动</strong>: Spring 生态中的 <code>Spring Data JPA</code> 模块极大地简化了 JPA 的使用。它默认的底层实现就是 Hibernate。这使得“Spring Boot + Spring Data JPA + Hibernate”成为现代 Java Web 开发的黄金组合。</li>
</ol>
<p><strong>最佳实践</strong>:</p>
<p>在开发中，我们应该<strong>面向 JPA 规范编程</strong>。这意味着：</p>
<ul>
<li>使用 JPA 定义的注解 (<code>@Entity</code>, <code>@Id</code> 等)。</li>
<li>通过依赖注入获取和使用 JPA 的核心接口 <code>EntityManager</code>。</li>
<li>编写 JPQL 而不是特定于 Hibernate 的 HQL。</li>
</ul>
<hr>
<h2 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2. 核心概念"></a>2. 核心概念</h2><h3 id="2-1-实体-Entity"><a href="#2-1-实体-Entity" class="headerlink" title="2.1 实体 (Entity)"></a>2.1 实体 (Entity)</h3><p><strong>实体是 JPA 的核心。</strong> 它是一个普通的 Java 对象 (POJO)，通过注解或 XML 配置，与数据库中的一张表进行了映射。</p>
<ul>
<li><strong>定义</strong>: 一个被 JPA 管理的、持久化的领域对象。</li>
<li><strong>核心要求</strong>:<ol>
<li>必须使用 <code>@Entity</code> 注解进行标记。</li>
<li>必须有一个无参的构造函数 (<code>public</code> 或 <code>protected</code>)。</li>
<li>必须有一个主键，使用 <code>@Id</code> 注解进行标记。</li>
</ol>
</li>
<li><strong>特点</strong>: 实体<strong>不是</strong>一个简单的 DTO (Data Transfer Object)。它是有状态的，其生命周期由持久化上下文（Persistence Context）管理。对托管状态下实体对象的任何修改，都可能被自动同步到数据库。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="comment">// 标记这是一个实体类</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_user&quot;)</span> <span class="comment">// 映射到数据库的 t_user 表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">// 标记这是主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">// 主键生成策略</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_name&quot;, length = 50)</span> <span class="comment">// 映射到 user_name 列</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age; <span class="comment">// 如果属性名和列名相同，可以省略 @Column</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123; <span class="comment">// 必须有无参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-EntityManagerFactory-实体管理器工厂"><a href="#2-2-EntityManagerFactory-实体管理器工厂" class="headerlink" title="2.2 EntityManagerFactory (实体管理器工厂)"></a>2.2 EntityManagerFactory (实体管理器工厂)</h3><ul>
<li><strong>定义</strong>: 用于创建 <code>EntityManager</code> 实例的工厂对象。</li>
<li><strong>类比</strong>: 类似于 MyBatis 中的 <code>SqlSessionFactory</code> 或数据库的连接池。</li>
<li><strong>特点</strong>:<ul>
<li><strong>重量级对象</strong>: 创建 <code>EntityManagerFactory</code> 的过程非常耗时，因为它需要解析所有持久化配置信息、建立与数据库的连接池等。</li>
<li><strong>线程安全</strong>: 它的设计是线程安全的。</li>
<li><strong>生命周期</strong>: 在整个应用程序中，通常<strong>只创建一个</strong> <code>EntityManagerFactory</code> 实例（单例模式）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-EntityManager-实体管理器"><a href="#2-3-EntityManager-实体管理器" class="headerlink" title="2.3 EntityManager (实体管理器)"></a>2.3 EntityManager (实体管理器)</h3><ul>
<li><strong>定义</strong>: <strong>与持久化上下文交互的主要 API</strong>。所有对实体的操作（增删改查）都是通过 <code>EntityManager</code> 来完成的。</li>
<li><strong>类比</strong>: 类似于 MyBatis 中的 <code>SqlSession</code> 或一个数据库连接。</li>
<li><strong>核心方法</strong>:<ul>
<li><code>persist(Object entity)</code>: 将一个新建的实体纳入管理，使其持久化（对应 <code>INSERT</code>）。</li>
<li><code>merge(T entity)</code>: 将一个游离态的实体重新合并到上下文中，或更新一个托管态的实体（对应 <code>UPDATE</code>）。</li>
<li><code>remove(Object entity)</code>: 将一个实体标记为删除状态（对应 <code>DELETE</code>）。</li>
<li><code>find(Class&lt;T&gt; entityClass, Object primaryKey)</code>: 根据主键查找实体（对应 <code>SELECT</code>）。</li>
<li><code>createQuery(String jpql)</code>: 创建 JPQL 查询对象。</li>
</ul>
</li>
<li><strong>特点</strong>:<ul>
<li><strong>轻量级对象</strong>: 创建和销毁的开销很小。</li>
<li><strong>线程不安全</strong>: <strong>绝对不能在多个线程之间共享</strong> <code>EntityManager</code> 实例。</li>
<li><strong>生命周期</strong>: 通常与一个事务或一个请求绑定，即“一请求一 <code>EntityManager</code>，一事务一 <code>EntityManager</code>”。用完后必须关闭。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-4-持久化上下文-Persistence-Context"><a href="#2-4-持久化上下文-Persistence-Context" class="headerlink" title="2.4 持久化上下文 (Persistence Context)"></a>2.4 持久化上下文 (Persistence Context)</h3><p><strong>这是 JPA&#x2F;Hibernate 最核心、最关键的概念，是理解其“魔法”的关键。</strong></p>
<ul>
<li><strong>定义</strong>: 一个<strong>实体实例的集合</strong>，可以理解为一个<strong>一级缓存</strong>或一个“工作单元”。<code>EntityManager</code> 管理的所有实体都存放在这个上下文中。</li>
<li><strong>特点</strong>:<ol>
<li><strong>身份管理 (Identity Management)</strong>: 在同一个持久化上下文中，对于同一个主键，<code>find()</code> 方法永远返回<strong>同一个 Java 对象实例</strong>。这保证了数据的一致性。</li>
<li><strong>事务回写 (Transactional Write-Behind)</strong>: 当你调用 <code>persist()</code> 或 <code>merge()</code> 时，Hibernate <strong>不会</strong>立即执行 SQL。它会将这些操作缓存起来，直到事务提交或上下文被刷新 (<code>flush</code>) 时，才会将这些变更批量同步到数据库。</li>
<li><strong>自动脏检查 (Automatic Dirty Checking)</strong>: 这是 JPA&#x2F;Hibernate 最神奇的特性。当事务提交时，持久化上下文会<strong>自动检测</strong>其中所有<strong>托管态 (Managed)</strong> 实体的属性是否发生了变化（与加载时的快照进行对比）。如果发生变化，Hibernate 会<strong>自动生成</strong>一条 <code>UPDATE</code> 语句并执行，<strong>无需你手动调用任何 <code>update</code> 方法</strong>。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-5-实体生命周期-Entity-Lifecycle"><a href="#2-5-实体生命周期-Entity-Lifecycle" class="headerlink" title="2.5 实体生命周期 (Entity Lifecycle)"></a>2.5 实体生命周期 (Entity Lifecycle)</h3><p>一个实体对象在其生命周期中会经历四种状态，<code>EntityManager</code> 的方法就是用来驱动实体在这些状态之间转换的。</p>
<ol>
<li><strong>新建态 (New &#x2F; Transient)</strong><ul>
<li><strong>描述</strong>: 一个刚刚 <code>new</code> 出来的 POJO 对象，它还没有主键，也<strong>没有</strong>被任何持久化上下文所管理。</li>
<li><strong>特点</strong>: 数据库中没有与之对应的记录。</li>
</ul>
</li>
<li><strong>托管态 (Managed &#x2F; Persistent)</strong><ul>
<li><strong>描述</strong>: 实体<strong>正在</strong>被一个持久化上下文所管理。</li>
<li><strong>来源</strong>:<ul>
<li>通过 <code>em.find()</code> 或 JPQL 查询从数据库加载而来。</li>
<li>通过 <code>em.persist()</code> 将一个新建态实体转入。</li>
<li>通过 <code>em.merge()</code> 将一个游离态实体转入。</li>
</ul>
</li>
<li><strong>特点</strong>: <strong>所有对该实体属性的修改都会被自动脏检查机制监视，并在事务提交时同步到数据库。</strong></li>
</ul>
</li>
<li><strong>游离态 (Detached)</strong><ul>
<li><strong>描述</strong>: 实体曾经被持久化上下文管理，但该上下文<strong>已经关闭</strong> (<code>em.close()</code>)，或者实体被<strong>明确地</strong>从上下文中分离 (<code>em.detach()</code>)。</li>
<li><strong>特点</strong>: 实体仍然拥有主键，但它已不再受 JPA 管理。对它的任何修改都<strong>不会</strong>被自动同步到数据库。</li>
</ul>
</li>
<li><strong>删除态 (Removed)</strong><ul>
<li><strong>描述</strong>: 实体正在被持久化上下文管理，但已被标记为删除状态（通过 <code>em.remove()</code>）。</li>
<li><strong>特点</strong>: 在事务提交时，数据库中与该实体对应的记录将被删除。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-6-事务-Transaction"><a href="#2-6-事务-Transaction" class="headerlink" title="2.6 事务 (Transaction)"></a>2.6 事务 (Transaction)</h3><ul>
<li><strong>定义</strong>: 一个原子性的工作单元。JPA 规定，所有对数据的修改操作（<code>persist</code>, <code>merge</code>, <code>remove</code>）都<strong>必须</strong>在一个活动的事务中进行。</li>
<li><strong>关联</strong>: 事务的生命周期通常与 <code>EntityManager</code> 和持久化上下文的生命周期绑定。当事务提交时，持久化上下文会将所有变更刷新 (<code>flush</code>) 到数据库。如果事务回滚，所有变更都会被丢弃。</li>
</ul>
<hr>
<h2 id="3-快速入门-1"><a href="#3-快速入门-1" class="headerlink" title="3. 快速入门"></a>3. 快速入门</h2><p>在现代 Java 开发中，直接使用原生的 JPA API (<code>EntityManager</code>) 相对繁琐。Spring Boot 集成了 <strong>Spring Data JPA</strong>，它在 JPA 规范之上提供了一个更高层次的抽象，极大地简化了数据访问层的开发。本快速入门将基于这一黄金组合。</p>
<h3 id="3-1-环境与项目准备"><a href="#3-1-环境与项目准备" class="headerlink" title="3.1 环境与项目准备"></a>3.1 环境与项目准备</h3><ul>
<li><strong>环境</strong>: JDK 1.8+, Maven 3.6+, MySQL 5.7+</li>
<li><strong>项目</strong>: 使用 <a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initializr</a> 创建一个新的 Spring Boot 项目，并勾选以下依赖：<ul>
<li><strong>Spring Web</strong>: 用于创建 Web 应用。</li>
<li><strong>Spring Data JPA</strong>: JPA 的核心依赖。</li>
<li><strong>MySQL Driver</strong>: 数据库驱动。</li>
<li><strong>Lombok</strong>: (可选，但推荐) 简化实体类代码。</li>
</ul>
</li>
</ul>
<p><strong>生成的 <code>pom.xml</code> 核心依赖</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: <code>spring-boot-starter-data-jpa</code> 会自动传递依赖引入 <strong>Hibernate</strong> 作为默认的 JPA 实现。</p>
<hr>
<h3 id="3-2-配置数据库连接"><a href="#3-2-配置数据库连接" class="headerlink" title="3.2 配置数据库连接"></a>3.2 配置数据库连接</h3><p>在 <code>src/main/resources/application.properties</code> (或 <code>application.yml</code>) 文件中，配置数据库信息和 JPA&#x2F;Hibernate 的相关属性。</p>
<p><strong><code>application.properties</code> 格式:</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataSource Configuration</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/your_database?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">your_password</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># JPA / Hibernate Configuration</span></span><br><span class="line"><span class="comment"># (可选) 让 Hibernate 自动根据实体类创建或更新数据库表结构。</span></span><br><span class="line"><span class="comment"># create: 每次启动都删除并重建。</span></span><br><span class="line"><span class="comment"># create-drop: 启动时创建，关闭时删除。</span></span><br><span class="line"><span class="comment"># update: 检查差异并更新（不删除列）。</span></span><br><span class="line"><span class="comment"># validate: 验证实体与表的匹配性。</span></span><br><span class="line"><span class="comment"># none: (生产环境推荐) 不做任何操作。</span></span><br><span class="line"><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># (可选) 在控制台显示 Hibernate 执行的 SQL 语句，方便调试。</span></span><br><span class="line"><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># (可选) 对显示的 SQL 进行格式化。</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.format_sql</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 请替换 <code>your_database</code> 和 <code>your_password</code>。<code>ddl-auto=update</code> 仅适用于开发和测试环境，生产环境应使用 <code>validate</code> 或 <code>none</code>，并由专业的数据库迁移工具（如 Flyway, Liquibase）管理表结构。</p>
<hr>
<h3 id="3-3-创建实体类-Entity"><a href="#3-3-创建实体类-Entity" class="headerlink" title="3.3 创建实体类 (Entity)"></a>3.3 创建实体类 (Entity)</h3><p>创建一个与数据库表对应的 Java 实体类，并使用 JPA 注解进行映射。</p>
<p><strong>数据库表 (user):</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">INT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>实体类 <code>User.java</code>:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/entity/User.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.persistence.*; <span class="comment">// Spring Boot 3.x 使用 jakarta.persistence</span></span><br><span class="line"><span class="comment">// import javax.persistence.*; // Spring Boot 2.x 使用 javax.persistence</span></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span> <span class="comment">// 标记这是一个 JPA 实体</span></span><br><span class="line"><span class="meta">@Table(name = &quot;user&quot;)</span> <span class="comment">// 映射到数据库的 &quot;user&quot; 表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">// 标记主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">// 主键生成策略：数据库自增</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;, length = 50)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name = &quot;age&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;email&quot;, unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-创建-Repository-接口"><a href="#3-4-创建-Repository-接口" class="headerlink" title="3.4 创建 Repository 接口"></a>3.4 创建 Repository 接口</h3><p>这是 Spring Data JPA 的魔力所在。你只需要创建一个接口，并继承 <code>JpaRepository</code>，就能<strong>立即拥有一整套完整的 CRUD 方法，无需任何实现</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/repository/UserRepository.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 标记这是一个 Spring 管理的 Repository Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// JpaRepository&lt;实体类型, 主键类型&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring Data JPA 的另一大魔法：方法命名查询 (Query Methods)</span></span><br><span class="line">    <span class="comment">// 你只需按照约定的规则定义方法名，Spring Data JPA 就会自动为你生成 JPQL 查询。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名字查询用户</span></span><br><span class="line"><span class="comment">     * Spring Data JPA 会自动生成: SELECT u FROM User u WHERE u.name = ?1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">findByName</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名字模糊查询并按年龄降序排序</span></span><br><span class="line"><span class="comment">     * 会生成: SELECT u FROM User u WHERE u.name LIKE ?1 ORDER BY u.age DESC</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByNameContainingOrderByAgeDesc</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-5-编写测试代码"><a href="#3-5-编写测试代码" class="headerlink" title="3.5 编写测试代码"></a>3.5 编写测试代码</h3><p>现在，你可以编写一个测试类，注入 <code>UserRepository</code>，并直接调用其内置或自定义的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test/java/com/example/MyApplicationTests.java</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;JPA Tester&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">28</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;jpa@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">savedUser</span> <span class="operator">=</span> userRepository.save(user); <span class="comment">// save 方法兼具插入和更新功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Saved user: &quot;</span> + savedUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span> &#123;</span><br><span class="line">        Optional&lt;User&gt; userOptional = userRepository.findById(<span class="number">1L</span>); <span class="comment">// findById 返回 Optional</span></span><br><span class="line">        userOptional.ifPresent(user -&gt; System.out.println(<span class="string">&quot;Found user: &quot;</span> + user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = userRepository.findAll();</span><br><span class="line">        users.forEach(System.out.println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">        userRepository.findById(<span class="number">1L</span>).ifPresent(user -&gt; &#123;</span><br><span class="line">            user.setAge(<span class="number">30</span>);</span><br><span class="line">            userRepository.save(user); <span class="comment">// ID 存在时，save 方法执行更新</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Updated user: &quot;</span> + user);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">        userRepository.deleteById(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;User with ID 1 deleted.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testCustomQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findByName(<span class="string">&quot;JPA Tester&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Found by custom query: &quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-实体关系映射"><a href="#4-实体关系映射" class="headerlink" title="4. 实体关系映射"></a>4. 实体关系映射</h2><p>在真实的业务场景中，数据库的表之间往往存在着各种关联关系，如一个用户有多个订单，一个订单属于一个用户。JPA 提供了一套丰富的注解，用于在实体类 (Entity) 之间精确地描述这些关系。正确地进行关系映射是 ORM 框架的核心价值所在。</p>
<p>数据库中的关系主要有四种：<strong>一对一 (OneToOne)</strong>, <strong>一对多 (OneToMany)</strong>, <strong>多对一 (ManyToOne)</strong>, 和 <strong>多对多 (ManyToMany)</strong>。</p>
<h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><ul>
<li><strong>关系拥有方 (Owning Side)</strong>: 负责维护关联关系的一方。通常是<strong>包含外键</strong>的那一方。在拥有方的实体中，会通过 <code>@JoinColumn</code> 注解来指定外键列。</li>
<li><strong>关系被拥有方 (Inverse Side)</strong>: 不负责维护关联关系的一方。在被拥有方的注解中，通常需要使用 <code>mappedBy</code> 属性来指明这段关系是由对方的哪个属性来维护的。</li>
<li><strong>级联操作 (Cascade)</strong>: 当对主实体进行操作（如 <code>persist</code>, <code>remove</code>, <code>merge</code>）时，是否要将该操作<strong>级联</strong>到其关联的实体上。通过 <code>@...To...</code> 注解的 <code>cascade</code> 属性来配置。</li>
<li><strong>抓取策略 (Fetch)</strong>: 当加载一个实体时，是否要<strong>立即</strong>加载其关联的实体（<strong>饥饿加载 Eager Fetch</strong>），还是在<strong>第一次访问</strong>关联实体时才去加载（<strong>懒加载 Lazy Fetch</strong>）。通过 <code>@...To...</code> 注解的 <code>fetch</code> 属性来配置。</li>
</ul>
<hr>
<h3 id="4-2-多对一-ManyToOne-一对多-OneToMany"><a href="#4-2-多对一-ManyToOne-一对多-OneToMany" class="headerlink" title="4.2 多对一 (ManyToOne) &amp; 一对多 (OneToMany)"></a>4.2 多对一 (ManyToOne) &amp; 一对多 (OneToMany)</h3><p>这是最常见的一种关系。例如：<strong>多个订单 (<code>Order</code>) 属于一个客户 (<code>Customer</code>)</strong>。</p>
<ul>
<li><strong><code>@ManyToOne</code></strong>: 放在“多”的一方（<code>Order</code>），表示多个订单对应一个客户。</li>
<li><strong><code>@OneToMany</code></strong>: 放在“一”的一方（<code>Customer</code>），表示一个客户拥有一个订单列表。</li>
</ul>
<p><strong>数据库表结构</strong>: <code>t_order</code> 表中会有一个 <code>customer_id</code> 外键列，指向 <code>t_customer</code> 表的主键。</p>
<p><strong>实体类定义</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户实体 (&quot;一&quot;的一方)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_customer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@OneToMany</span>: 声明一对多关系</span></span><br><span class="line"><span class="comment">     * mappedBy = &quot;customer&quot;: </span></span><br><span class="line"><span class="comment">     *      - 指明这个关联关系由 Order 实体的 &quot;customer&quot; 属性来维护。</span></span><br><span class="line"><span class="comment">     *      - 这意味着 Customer 是关系的【被拥有方】，它不包含外键。</span></span><br><span class="line"><span class="comment">     *      - &quot;customer&quot; 必须是 Order 类中 <span class="doctag">@ManyToOne</span> 注解的那个字段名。</span></span><br><span class="line"><span class="comment">     * cascade = CascadeType.ALL: </span></span><br><span class="line"><span class="comment">     *      - 级联所有操作。保存客户时会自动保存其名下的新订单，删除客户时会自动删除其所有订单。</span></span><br><span class="line"><span class="comment">     * fetch = FetchType.LAZY:</span></span><br><span class="line"><span class="comment">     *      - 懒加载。查询客户时，默认不加载其订单列表，只有在首次调用 getOrders() 时才会去查询数据库。</span></span><br><span class="line"><span class="comment">     *      - 【最佳实践】所有集合类型的关联（OneToMany, ManyToMany）都应配置为懒加载，避免性能问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;customer&quot;, cascade = CascadeType.ALL, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单实体 (&quot;多&quot;的一方)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String orderNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ManyToOne</span>: 声明多对一关系</span></span><br><span class="line"><span class="comment">     * fetch = FetchType.EAGER:</span></span><br><span class="line"><span class="comment">     *      - 饥饿加载。查询订单时，会立即通过 LEFT JOIN 将其关联的客户信息一并查询出来。</span></span><br><span class="line"><span class="comment">     *      - 【默认策略】...ToOne 关系的默认抓取策略是 EAGER。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@JoinColumn</span>(name = &quot;customer_id&quot;):</span></span><br><span class="line"><span class="comment">     *      - 指定外键列。这表明 Order 是关系的【拥有方】。</span></span><br><span class="line"><span class="comment">     *      - name = &quot;customer_id&quot; 指的是 t_order 表中的外键列名。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.EAGER)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-一对一-OneToOne"><a href="#4-3-一对一-OneToOne" class="headerlink" title="4.3 一对一 (OneToOne)"></a>4.3 一对一 (OneToOne)</h3><p>例如：一个<strong>用户 (<code>User</code>)</strong> 对应一个<strong>用户详情 (<code>UserProfile</code>)</strong>。</p>
<p>一对一关系可以通过共享主键或唯一外键来实现。这里以外键为例。</p>
<p><strong>数据库表结构</strong>: <code>t_user_profile</code> 表中有一个 <code>user_id</code> 外键列，且该列具有唯一约束 (<code>UNIQUE</code>)。</p>
<p><strong>实体类定义</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户实体</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mappedBy = &quot;user&quot;: 表示关系由 UserProfile 的 &quot;user&quot; 属性维护。</span></span><br><span class="line"><span class="comment">     * cascade = CascadeType.ALL: 级联操作。</span></span><br><span class="line"><span class="comment">     * optional = false: 表示 UserProfile 对于 User 来说是必须存在的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OneToOne(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL, fetch = FetchType.LAZY, optional = false)</span></span><br><span class="line">    <span class="keyword">private</span> UserProfile userProfile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户详情实体</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_user_profile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@JoinColumn</span>: 指定外键，使其成为关系拥有方。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OneToOne(fetch = FetchType.EAGER)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;user_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-多对多-ManyToMany"><a href="#4-4-多对多-ManyToMany" class="headerlink" title="4.4 多对多 (ManyToMany)"></a>4.4 多对多 (ManyToMany)</h3><p>例如：一个<strong>学生 (<code>Student</code>)</strong> 可以选择多门<strong>课程 (<code>Course</code>)</strong>，一门课程也可以被多个学生选择。</p>
<p>多对多关系在数据库中必须通过一个**中间表（连接表）**来实现。</p>
<p><strong>数据库表结构</strong>: 除了 <code>t_student</code> 和 <code>t_course</code> 表，还需要一个 <code>t_student_course</code> 中间表，它至少包含 <code>student_id</code> 和 <code>course_id</code> 两个外键。</p>
<p><strong>实体类定义</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ManyToMany</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@JoinTable</span>: 配置中间表信息</span></span><br><span class="line"><span class="comment">     *      - name: 中间表的名称</span></span><br><span class="line"><span class="comment">     *      - joinColumns: 定义中间表中与【本实体】关联的外键。</span></span><br><span class="line"><span class="comment">     *          - <span class="doctag">@JoinColumn</span>(name = &quot;student_id&quot;): 中间表中名为 &quot;student_id&quot; 的列。</span></span><br><span class="line"><span class="comment">     *      - inverseJoinColumns: 定义中间表中与【对方实体】关联的外键。</span></span><br><span class="line"><span class="comment">     *          - <span class="doctag">@JoinColumn</span>(name = &quot;course_id&quot;): 中间表中名为 &quot;course_id&quot; 的列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.LAZY, cascade = CascadeType.PERSIST)</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;t_student_course&quot;,</span></span><br><span class="line"><span class="meta">               joinColumns = @JoinColumn(name = &quot;student_id&quot;),</span></span><br><span class="line"><span class="meta">               inverseJoinColumns = @JoinColumn(name = &quot;course_id&quot;))</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Course&gt; courses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_course&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mappedBy = &quot;courses&quot;: </span></span><br><span class="line"><span class="comment">     *      - 表示这是一个双向关系，且由 Student 实体的 &quot;courses&quot; 属性维护。</span></span><br><span class="line"><span class="comment">     *      - 通常在多对多关系中，我们会选择一方作为拥有方（配置<span class="doctag">@JoinTable</span>），另一方作为被拥有方（配置mappedBy）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ManyToMany(mappedBy = &quot;courses&quot;, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-5-总结与最佳实践"><a href="#4-5-总结与最佳实践" class="headerlink" title="4.5 总结与最佳实践"></a>4.5 总结与最佳实践</h3><ul>
<li><strong><code>@...ToOne</code> 默认是 EAGER，<code>@...ToMany</code> 默认是 LAZY</strong>。</li>
<li><strong>最佳实践</strong>: 为了避免 N+1 查询问题和不必要的性能开销，<strong>强烈建议将所有关联关系都显式地设置为 <code>fetch = FetchType.LAZY</code></strong>，然后在需要时通过 JPQL 的 <code>JOIN FETCH</code> 或 <code>@EntityGraph</code> 来主动抓取数据。</li>
<li><strong>双向关系</strong>: 在设置双向关系时，<strong>必须</strong>在其中一方使用 <code>mappedBy</code> 来指定关系维护方，否则 Hibernate 会认为这是两个独立的关系，可能会创建出两张中间表或两个外键列。</li>
<li><strong>集合类型</strong>: 对于 <code>@OneToMany</code> 和 <code>@ManyToMany</code>，推荐使用 <code>Set</code> 集合类型，因为 <code>Set</code> 不允许重复元素，更符合关系模型的语义，并且在某些场景下比 <code>List</code> 性能更好。</li>
</ul>
<hr>
<h2 id="5-JPQL-Java-Persistence-Query-Language"><a href="#5-JPQL-Java-Persistence-Query-Language" class="headerlink" title="5. JPQL (Java Persistence Query Language)"></a>5. JPQL (Java Persistence Query Language)</h2><h3 id="5-1-什么是-JPQL？"><a href="#5-1-什么是-JPQL？" class="headerlink" title="5.1 什么是 JPQL？"></a>5.1 什么是 JPQL？</h3><p><strong>JPQL (Java Persistence Query Language)</strong> 是 JPA 规范中定义的一种<strong>面向对象的查询语言</strong>。它在语法上与 SQL 非常相似，但有一个根本性的区别：</p>
<ul>
<li><strong>SQL</strong> 操作的是数据库的<strong>表 (table)</strong> 和<strong>列 (column)</strong>。</li>
<li><strong>JPQL</strong> 操作的是 JPA 的<strong>实体 (Entity)</strong> 和<strong>属性 (property)</strong>。</li>
</ul>
<p>这种面向对象的特性使得 JPQL 具有<strong>平台无关性</strong>。你编写的 JPQL 查询语句可以被任何 JPA 实现（如 Hibernate, EclipseLink）正确地解析，并由底层框架转换为对应数据库方言的 SQL 语句来执行。</p>
<hr>
<h3 id="5-2-JPQL-的核心优势"><a href="#5-2-JPQL-的核心优势" class="headerlink" title="5.2 JPQL 的核心优势"></a>5.2 JPQL 的核心优势</h3><ol>
<li><strong>面向对象</strong>: 查询逻辑直接与你的领域模型（实体类）绑定，而不是与底层数据库结构耦合，代码更直观，可读性更高。</li>
<li><strong>数据库无关</strong>: 无需关心不同数据库的 SQL 语法差异（如分页、函数等）。JPA 提供商会自动处理这些转换。</li>
<li><strong>类型安全</strong>: 与拼接原生 SQL 相比，JPQL 查询通常与参数绑定结合使用，可以有效防止 SQL 注入。</li>
<li><strong>支持复杂查询</strong>: 支持连接查询 (JOIN)、聚合函数、分组、子查询等所有高级查询功能。</li>
</ol>
<hr>
<h3 id="5-3-JPQL-基础语法"><a href="#5-3-JPQL-基础语法" class="headerlink" title="5.3 JPQL 基础语法"></a>5.3 JPQL 基础语法</h3><p>JPQL 的语法结构与 SQL 几乎一致，主要包括 <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code> 语句。</p>
<h4 id="5-3-1-SELECT-查询"><a href="#5-3-1-SELECT-查询" class="headerlink" title="5.3.1 SELECT 查询"></a>5.3.1 <code>SELECT</code> 查询</h4><p>这是最常用的查询类型。</p>
<p><strong>基本结构</strong>:<br><code>SELECT ... FROM EntityName [alias] WHERE ... GROUP BY ... HAVING ... ORDER BY ...</code></p>
<p><strong>示例 1: 简单查询</strong><br>查询所有年龄大于 18 岁的用户。</p>
<ul>
<li><strong>JPQL</strong>: <code>SELECT u FROM User u WHERE u.age &gt; 18</code></li>
<li><strong>注意</strong>:<ul>
<li><code>FROM User u</code>: <code>User</code> 是<strong>实体类的名称</strong>，不是表名。<code>u</code> 是别名。</li>
<li><code>u.age</code>: 引用的是 <code>User</code> 实体的 <code>age</code> <strong>属性</strong>，不是数据库的 <code>age</code> 列。</li>
</ul>
</li>
</ul>
<p><strong>示例 2: 投影查询 (查询部分属性)</strong><br>只查询用户的姓名和邮箱。</p>
<ul>
<li><strong>JPQL</strong>: <code>SELECT u.name, u.email FROM User u</code></li>
<li><strong>返回类型</strong>: 默认返回 <code>List&lt;Object[]&gt;</code>，每个 <code>Object[]</code> 包含 <code>name</code> 和 <code>email</code>。</li>
<li><strong>构造器表达式 (推荐)</strong>: 为了获得类型安全的 <code>List&lt;UserDTO&gt;</code>，可以使用构造器表达式。<ul>
<li><strong>JPQL</strong>: <code>SELECT new com.example.dto.UserDTO(u.name, u.email) FROM User u</code></li>
<li>这要求 <code>UserDTO</code> 有一个匹配的构造函数 <code>public UserDTO(String name, String email)</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例 3: 参数绑定</strong><br>使用<strong>命名参数 (<code>:paramName</code>)</strong> 或 <strong>位置参数 (<code>?index</code>)</strong> 来传递查询条件，防止 SQL 注入。<strong>命名参数是首选</strong>，因为它更具可读性。</p>
<ul>
<li><strong>JPQL (命名参数)</strong>: <code>SELECT u FROM User u WHERE u.name = :name AND u.age &gt; :minAge</code></li>
<li><strong>JPQL (位置参数)</strong>: <code>SELECT u FROM User u WHERE u.name = ?1 AND u.age &gt; ?2</code></li>
</ul>
<hr>
<h4 id="5-3-2-UPDATE-和-DELETE-查询"><a href="#5-3-2-UPDATE-和-DELETE-查询" class="headerlink" title="5.3.2 UPDATE 和 DELETE 查询"></a>5.3.2 <code>UPDATE</code> 和 <code>DELETE</code> 查询</h4><p>JPQL 也支持批量更新和删除操作。</p>
<ul>
<li><strong><code>UPDATE</code></strong>: <code>UPDATE User u SET u.age = u.age + 1 WHERE u.status = &#39;inactive&#39;</code></li>
<li><strong><code>DELETE</code></strong>: <code>DELETE FROM User u WHERE u.lastLoginTime &lt; :someDate</code></li>
</ul>
<p><strong>重要注意事项</strong>:</p>
<ul>
<li>批量 <code>UPDATE</code> 和 <code>DELETE</code> 操作会<strong>直接在数据库层面执行</strong>，它们会<strong>绕过持久化上下文 (一级缓存)</strong>。</li>
<li>这意味着，如果持久化上下文中存在已被这些批量操作修改或删除的实体，这些实体<strong>不会</strong>自动更新，可能会导致<strong>数据不一致</strong>。</li>
<li>因此，在执行批量操作后，通常建议<strong>清空持久化上下文</strong> (<code>entityManager.clear()</code>)，以强制后续查询从数据库重新加载最新数据。</li>
</ul>
<hr>
<h3 id="5-4-连接查询-JOIN"><a href="#5-4-连接查询-JOIN" class="headerlink" title="5.4 连接查询 (JOIN)"></a>5.4 连接查询 (JOIN)</h3><p>JPQL 的连接查询是其强大功能的核心，它允许你根据实体之间的关联关系进行导航查询。</p>
<p>假设有 <code>Customer</code> (一) 和 <code>Order</code> (多) 两个实体。</p>
<ul>
<li><strong><code>INNER JOIN</code></strong>: <code>SELECT c FROM Customer c JOIN c.orders o WHERE o.amount &gt; 100</code><ul>
<li>查询所有拥有订单金额大于 100 的客户。</li>
<li><code>c.orders</code> 是 <code>Customer</code> 实体中定义的关联属性。</li>
</ul>
</li>
<li><strong><code>LEFT JOIN</code></strong>: <code>SELECT c, o FROM Customer c LEFT JOIN c.orders o</code><ul>
<li>查询所有客户及其订单，即使客户没有任何订单也会被查询出来。</li>
</ul>
</li>
<li><strong><code>JOIN FETCH</code> (性能优化的关键)</strong>: 这是 JPQL 中一个极其重要的特性，用于解决 <strong>N+1 查询问题</strong>。<ul>
<li><strong>普通 JOIN</strong>: <code>SELECT c FROM Customer c JOIN c.orders</code> 只会查询出 <code>Customer</code>，当你访问 <code>c.getOrders()</code> 时，仍然会为每个 <code>Customer</code> 发起一次新的 SQL 去查询其 <code>Order</code>（如果关联是懒加载）。</li>
<li><strong><code>JOIN FETCH</code></strong>: <code>SELECT c FROM Customer c LEFT JOIN FETCH c.orders</code></li>
<li><code>FETCH</code> 关键字告诉 JPA 提供商，在执行查询时，不仅要加载主实体 (<code>Customer</code>)，还要<strong>立即、一次性地</strong>将其关联的集合 (<code>orders</code>) 也查询出来并填充好。</li>
<li>这会将多次查询合并为一次 <code>LEFT JOIN</code> SQL，极大地提升了性能。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-5-在-Spring-Data-JPA-中使用-JPQL"><a href="#5-5-在-Spring-Data-JPA-中使用-JPQL" class="headerlink" title="5.5 在 Spring Data JPA 中使用 JPQL"></a>5.5 在 Spring Data JPA 中使用 JPQL</h3><p>Spring Data JPA 提供了多种使用 JPQL 的方式，最常用的是通过 <code>@Query</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 JPQL 进行查询，并使用命名参数</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.email = :email&quot;)</span></span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findByEmailAddress</span><span class="params">(<span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用构造器表达式返回 DTO</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT new com.example.dto.UserSummary(u.id, u.name) FROM User u WHERE u.age &gt; :minAge&quot;)</span></span><br><span class="line">    List&lt;UserSummary&gt; <span class="title function_">findUserSummariesByAge</span><span class="params">(<span class="meta">@Param(&quot;minAge&quot;)</span> <span class="type">int</span> age)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 JOIN FETCH 解决 N+1 问题</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT DISTINCT c FROM Customer c LEFT JOIN FETCH c.orders&quot;)</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">findAllCustomersWithOrders</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Modifying 注解来执行更新或删除操作</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 更新/删除操作需要事务</span></span><br><span class="line">    <span class="meta">@Query(&quot;UPDATE User u SET u.status = :newStatus WHERE u.id = :id&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUserStatus</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;newStatus&quot;)</span> String newStatus)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>:</p>
<ul>
<li><code>@Query</code>: 将 JPQL 语句直接写在接口方法上。</li>
<li><code>@Param</code>: 用于将方法参数与 JPQL 中的命名参数进行绑定。</li>
<li><code>@Modifying</code>: <strong>必须</strong>用于标记执行 <code>UPDATE</code> 或 <code>DELETE</code> 操作的方法。</li>
<li><code>@Transactional</code>: 修改数据的操作通常需要事务支持。</li>
</ul>
<hr>
<h2 id="6-Spring-Data-JPA"><a href="#6-Spring-Data-JPA" class="headerlink" title="6. Spring Data JPA"></a>6. Spring Data JPA</h2><h3 id="6-1-什么是-Spring-Data-JPA？"><a href="#6-1-什么是-Spring-Data-JPA？" class="headerlink" title="6.1 什么是 Spring Data JPA？"></a>6.1 什么是 Spring Data JPA？</h3><p><strong>Spring Data JPA</strong> 是 Spring Data 项目下的一个核心子模块。它并非一个新的 ORM 框架，也不是 JPA 的替代品，而是<strong>在 JPA 规范之上构建的一个更高层次的抽象层</strong>。</p>
<p><strong>核心目标</strong>：<strong>极大地简化和标准化数据访问层 (DAO&#x2F;Repository) 的开发</strong>。</p>
<p>Spring Data JPA 通过提供强大的 <code>Repository</code> 抽象和一系列约定，使得开发者可以从繁琐的、样板化的数据访问代码中解放出来，甚至在很多情况下，<strong>无需编写任何实现代码</strong>就能完成复杂的数据库操作。</p>
<p>它底层的持久化工作仍然委托给 JPA 提供商（默认为 Hibernate）来完成。可以理解为：<br><code>你的代码 -&gt; Spring Data JPA -&gt; JPA API (Hibernate) -&gt; JDBC -&gt; 数据库</code></p>
<hr>
<h3 id="6-2-核心特性与优势"><a href="#6-2-核心特性与优势" class="headerlink" title="6.2 核心特性与优势"></a>6.2 核心特性与优势</h3><h4 id="1-强大的-Repository-抽象-JpaRepository"><a href="#1-强大的-Repository-抽象-JpaRepository" class="headerlink" title="1. 强大的 Repository 抽象 (JpaRepository)"></a><strong>1. 强大的 Repository 抽象 (<code>JpaRepository</code>)</strong></h4><p>这是 Spring Data JPA 的基石。你只需要创建一个接口并继承 <code>JpaRepository&lt;T, ID&gt;</code>，就能<strong>立即免费获得</strong>一整套开箱即用的、功能完善的 CRUD 和分页排序方法。</p>
<ul>
<li><code>save(S entity)</code>: 保存或更新实体。</li>
<li><code>findById(ID id)</code>: 根据主键查询。</li>
<li><code>findAll()</code>: 查询所有。</li>
<li><code>deleteById(ID id)</code>: 根据主键删除。</li>
<li><code>count()</code>: 统计总数。</li>
<li><code>findAll(Sort sort)</code>: 排序查询。</li>
<li><code>findAll(Pageable pageable)</code>: 分页查询。</li>
<li>… 等等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要定义接口，无需任何实现类！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-方法命名查询-Query-Methods-Derived-Queries"><a href="#2-方法命名查询-Query-Methods-Derived-Queries" class="headerlink" title="2. 方法命名查询 (Query Methods &#x2F; Derived Queries)"></a><strong>2. 方法命名查询 (Query Methods &#x2F; Derived Queries)</strong></h4><p>这是 Spring Data JPA 最“神奇”的特性。你只需<strong>按照一套约定的命名规则来定义接口方法</strong>，Spring Data JPA 就会在运行时自动解析方法名，并为你生成相应的 JPQL 查询。</p>
<ul>
<li><strong>关键字</strong>: <code>FindBy</code>, <code>CountBy</code>, <code>ExistsBy</code>, <code>DeleteBy</code></li>
<li><strong>属性表达式</strong>: <code>And</code>, <code>Or</code>, <code>Between</code>, <code>LessThan</code>, <code>GreaterThan</code>, <code>Like</code>, <code>Containing</code>, <code>IsNull</code>, <code>In</code></li>
<li><strong>排序与限制</strong>: <code>OrderBy...Asc/Desc</code>, <code>Top</code>, <code>First</code></li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据 name 查询</span></span><br><span class="line">    <span class="comment">// JPQL: select u from User u where u.name = ?1</span></span><br><span class="line">    User <span class="title function_">findByName</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 name 和 age 查询</span></span><br><span class="line">    <span class="comment">// JPQL: select u from User u where u.name = ?1 and u.age = ?2</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByNameAndAge</span><span class="params">(String name, <span class="type">int</span> age)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 age 大于某个值并按 name 降序排序，只取前10条</span></span><br><span class="line">    <span class="comment">// JPQL: select u from User u where u.age &gt; ?1 order by u.name desc limit 10</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findTop10ByAgeGreaterThanOrderByNameDesc</span><span class="params">(<span class="type">int</span> age)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否存在某个 email 的用户</span></span><br><span class="line">    <span class="comment">// JPQL: select case when count(u) &gt; 0 then true else false end from User u where u.email = ?1</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">existsByEmail</span><span class="params">(String email)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-使用-Query-注解自定义查询"><a href="#3-使用-Query-注解自定义查询" class="headerlink" title="3. 使用 @Query 注解自定义查询"></a><strong>3. 使用 <code>@Query</code> 注解自定义查询</strong></h4><p>对于方法命名无法表达的复杂查询逻辑（例如多表连接、子查询、DTO 投影等），可以使用 <code>@Query</code> 注解，直接在接口方法上编写 <strong>JPQL</strong> 或 <strong>原生 SQL</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 JPQL</span></span><br><span class="line">    <span class="meta">@Query(&quot;select u from User u where u.name like %:name%&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUsersByNameLike</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用原生 SQL (nativeQuery = true)</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT * FROM user WHERE email = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">    User <span class="title function_">findByEmailWithNativeSQL</span><span class="params">(String email)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 @Modifying 执行更新操作</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Query(&quot;update User u set u.age = u.age + 1 where u.id = :id&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">incrementAge</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-动态查询支持-JPA-Criteria-API-QueryDSL"><a href="#4-动态查询支持-JPA-Criteria-API-QueryDSL" class="headerlink" title="4. 动态查询支持 (JPA Criteria API &amp; QueryDSL)"></a><strong>4. 动态查询支持 (JPA Criteria API &amp; QueryDSL)</strong></h4><p>对于需要根据运行时条件动态构建查询的场景（例如复杂的多条件搜索），Spring Data JPA 提供了两种强大的集成方案：</p>
<ul>
<li><strong>JPA Specification (规范)</strong>: 提供了一套类型安全的 API，允许你通过组合 <code>Predicate</code> 对象来构建动态的 <code>WHERE</code> 子句。</li>
<li><strong>QueryDSL</strong>: 一个更强大、更流畅的第三方类型安全查询库，与 Spring Data JPA 无缝集成。</li>
</ul>
<h4 id="5-简化的分页与排序"><a href="#5-简化的分页与排序" class="headerlink" title="5. 简化的分页与排序"></a><strong>5. 简化的分页与排序</strong></h4><p>分页和排序被抽象为 <code>Pageable</code> 和 <code>Sort</code> 接口，使用起来极其简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;User&gt; <span class="title function_">getUsersByPage</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(defaultValue = &quot;0&quot;)</span> <span class="type">int</span> page,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(defaultValue = &quot;id,desc&quot;)</span> String[] sort)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Spring MVC 会自动将请求参数转换为 Pageable 对象</span></span><br><span class="line">    <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(page, size, Sort.by(sort));</span><br><span class="line">    <span class="keyword">return</span> userRepository.findAll(pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-3-与-MyBatis-MyBatis-Plus-的对比"><a href="#6-3-与-MyBatis-MyBatis-Plus-的对比" class="headerlink" title="6.3 与 MyBatis&#x2F;MyBatis-Plus 的对比"></a>6.3 与 MyBatis&#x2F;MyBatis-Plus 的对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Spring Data JPA (Hibernate)</th>
<th align="left">MyBatis-Plus</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>抽象层次</strong></td>
<td align="left"><strong>高</strong>，完全面向对象，屏蔽 SQL</td>
<td align="left"><strong>中</strong>，半自动，SQL 仍是核心</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left"><strong>极高</strong>，方法命名和 JpaRepository 极大减少代码</td>
<td align="left"><strong>高</strong>，通用 CRUD 和 Wrapper 也很高效</td>
</tr>
<tr>
<td align="left"><strong>SQL 控制力</strong></td>
<td align="left"><strong>间接</strong>，通过 JPQL 或原生 SQL 控制，不直接</td>
<td align="left"><strong>直接且完全</strong>，可以精细优化每一条 SQL</td>
</tr>
<tr>
<td align="left"><strong>数据库移植性</strong></td>
<td align="left"><strong>非常强</strong>，面向 JPA 规范，更换数据库成本低</td>
<td align="left"><strong>较强</strong>，但复杂 SQL 可能依赖方言</td>
</tr>
<tr>
<td align="left"><strong>学习曲线</strong></td>
<td align="left">较陡峭，需理解实体生命周期、持久化上下文等核心概念</td>
<td align="left">较平缓，对熟悉 SQL 的开发者非常友好</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">简单 CRUD 性能优异，但复杂查询可能因自动生成 SQL 而非最优</td>
<td align="left">开发者可手动编写最优 SQL，性能潜力更高</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">快速开发、标准 CRUD 密集的业务系统、需要数据库无关性的项目</td>
<td align="left">复杂报表、性能要求极致、DBA 深度参与的项目</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>Spring Data JPA 是一个生产力工具，它站在 JPA 这一巨人的肩膀上，通过“<strong>约定优于配置</strong>”的理念，为开发者提供了一套极其优雅和高效的数据访问解决方案。它使得 Repository 层的代码量锐减，让开发者能够更专注于业务逻辑的实现。对于大多数标准的业务系统而言，Spring Data JPA + Hibernate 是一个非常强大且高效的选择。</p>
<hr>
<h2 id="7-适用场景"><a href="#7-适用场景" class="headerlink" title="7. 适用场景"></a>7. 适用场景</h2><p>JPA (以 Hibernate 为代表实现) 和 MyBatis 是 Java 持久化领域的两大主流框架，它们各自有明确的设计哲学和优势，因此适用于不同的项目场景。选择哪一个框架，通常取决于项目的业务复杂度、团队技能、对性能的要求以及对开发效率的权衡。</p>
<h3 id="JPA-Hibernate-的核心优势在于："><a href="#JPA-Hibernate-的核心优势在于：" class="headerlink" title="JPA &amp; Hibernate 的核心优势在于："></a>JPA &amp; Hibernate 的核心优势在于：</h3><ul>
<li><strong>高度的领域模型驱动</strong>: 完全面向对象，让开发者更专注于业务模型而非数据库细节。</li>
<li><strong>开发效率极高</strong>: Spring Data JPA 进一步将开发效率推向极致。</li>
<li><strong>数据库无关性</strong>: 优秀的跨数据库移植能力。</li>
<li><strong>强大的生态</strong>: 与 Spring 生态无缝集成，拥有丰富的社区支持和解决方案。</li>
</ul>
<p>基于以上优势，JPA &amp; Hibernate 特别适用于以下场景：</p>
<h4 id="1-新项目与快速原型开发"><a href="#1-新项目与快速原型开发" class="headerlink" title="1. 新项目与快速原型开发"></a>1. 新项目与快速原型开发</h4><p>对于从零开始的新项目，特别是初创公司或需要快速验证市场想法 (MVP) 的产品，JPA 是绝佳选择。</p>
<ul>
<li><strong>敏捷开发</strong>: <code>JpaRepository</code> 和方法命名查询可以让你在几分钟内就搭建好一套功能完整的 CRUD API，无需编写任何 SQL 或 XML。</li>
<li><strong>关注业务</strong>: 开发者可以将全部精力投入到业务领域模型的设计上，<code>ddl-auto</code> 功能还能自动根据实体类生成或更新数据库表，极大地加快了开发迭代速度。</li>
</ul>
<h4 id="2-CRUD-密集型的业务系统"><a href="#2-CRUD-密集型的业务系统" class="headerlink" title="2. CRUD 密集型的业务系统"></a>2. CRUD 密集型的业务系统</h4><p>大多数企业级应用，如 OA、CRM、ERP、电商后台管理系统等，其核心功能都围绕着大量的增删改查操作。</p>
<ul>
<li><strong>标准化与规范化</strong>: JPA 对这类操作提供了最优雅、最简洁的解决方案。整个数据访问层代码非常统一、干净。</li>
<li><strong>维护性高</strong>: 面向对象的查询（如方法命名查询、JPQL）比散落在各处的 SQL 语句更容易理解和维护。当业务需求变更导致实体属性增减时，重构也更加方便。</li>
</ul>
<h4 id="3-需要支持多种数据库或未来可能更换数据库的项目"><a href="#3-需要支持多种数据库或未来可能更换数据库的项目" class="headerlink" title="3. 需要支持多种数据库或未来可能更换数据库的项目"></a>3. 需要支持多种数据库或未来可能更换数据库的项目</h4><p>如果项目需要同时支持多种数据库（如 MySQL 和 Oracle），或者预见到未来有更换数据库的可能性，JPA 的数据库无关性是其杀手级特性。</p>
<ul>
<li><strong>无缝切换</strong>: 只要代码是面向 JPA 规范编写的（使用 JPQL 而非原生 SQL），理论上只需更改配置文件中的数据库方言 (<code>dialect</code>) 和驱动，就能平滑迁移到新的数据库平台，无需修改任何业务代码。</li>
<li><strong>场景示例</strong>: 需要部署到不同客户环境下的商业软件产品，这些客户可能使用不同的数据库。</li>
</ul>
<h4 id="4-领域驱动设计-DDD-实践"><a href="#4-领域驱动设计-DDD-实践" class="headerlink" title="4. 领域驱动设计 (DDD) 实践"></a>4. 领域驱动设计 (DDD) 实践</h4><p>JPA&#x2F;Hibernate 的设计哲学与领域驱动设计 (DDD) 的思想高度契合。</p>
<ul>
<li><strong>富领域模型</strong>: JPA 的实体 (Entity) 不仅仅是数据的载体，它们可以包含业务逻辑，成为真正的“富领域对象”。实体的生命周期、关联关系、懒加载等特性，都为实现复杂的领域模型提供了强大的技术支撑。</li>
<li><strong>聚合根 (Aggregate Root)</strong>: <code>JpaRepository</code> 的设计天然地鼓励开发者为每个聚合根创建一个 Repository，这与 DDD 的实践不谋而合。级联操作 (<code>cascade</code>) 也方便地实现了对聚合内部实体的一致性管理。</li>
</ul>
<h4 id="5-团队成员对-SQL-不够精通或希望屏蔽数据库细节"><a href="#5-团队成员对-SQL-不够精通或希望屏蔽数据库细节" class="headerlink" title="5. 团队成员对 SQL 不够精通或希望屏蔽数据库细节"></a>5. 团队成员对 SQL 不够精通或希望屏蔽数据库细节</h4><p>对于一个团队，如果大部分成员是 Java 开发背景，对复杂的 SQL 优化经验不足，或者希望将团队的关注点保持在 Java 业务逻辑层面，JPA 是一个很好的选择。</p>
<ul>
<li><strong>降低心智负担</strong>: 开发者无需过多关心底层 SQL 的实现细节，JPA&#x2F;Hibernate 会在大多数情况下生成正确且性能良好的 SQL。</li>
<li><strong>统一技术栈</strong>: 整个团队可以使用统一的、面向对象的方式进行数据访问，减少了因个人 SQL 水平差异带来的代码质量波动。</li>
</ul>
<hr>
<hr>
<h1 id="五、ORM-进阶与最佳实践"><a href="#五、ORM-进阶与最佳实践" class="headerlink" title="五、ORM 进阶与最佳实践"></a>五、ORM 进阶与最佳实践</h1><h2 id="1-N-1-查询问题"><a href="#1-N-1-查询问题" class="headerlink" title="1. N+1 查询问题"></a>1. N+1 查询问题</h2><h3 id="1-1-MyBatis-与-MyBatis-Plus-解决方案"><a href="#1-1-MyBatis-与-MyBatis-Plus-解决方案" class="headerlink" title="1.1 MyBatis 与 MyBatis-Plus 解决方案"></a>1.1 MyBatis 与 MyBatis-Plus 解决方案</h3><h4 id="1-1-1-在-MyBatis-中如何产生-N-1-问题"><a href="#1-1-1-在-MyBatis-中如何产生-N-1-问题" class="headerlink" title="1.1.1 在 MyBatis 中如何产生 N+1 问题"></a>1.1.1 在 MyBatis 中如何产生 N+1 问题</h4><p>N+1 问题通常在使用嵌套结果映射 (<code>&lt;association&gt;</code> 或 <code>&lt;collection&gt;</code>) 并通过<strong>分步查询 (Nested Selects)</strong> 时产生。</p>
<p><strong>问题示例 <code>CustomerMapper.xml</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 查询所有客户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAllCustomers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;CustomerWithOrdersMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_customer</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 根据客户ID查询其订单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findOrdersByCustomerId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.Order&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_order WHERE customer_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  这个 ResultMap 会导致 N+1 问题。</span></span><br><span class="line"><span class="comment">  它首先执行 findAllCustomers (1次查询)，</span></span><br><span class="line"><span class="comment">  然后在映射 orders 集合时，会为每个 customer 对象调用一次 findOrdersByCustomerId (N次查询)。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;CustomerWithOrdersMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.Customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collection 标签的 select 属性触发了分步查询 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.Order&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;findOrdersByCustomerId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-2-MyBatis-解决方案"><a href="#1-1-2-MyBatis-解决方案" class="headerlink" title="1.1.2 MyBatis 解决方案"></a>1.1.2 MyBatis 解决方案</h4><p>MyBatis 提供了两种核心方案来解决 N+1 问题。</p>
<h5 id="方案一：连接查询-Join-Query"><a href="#方案一：连接查询-Join-Query" class="headerlink" title="方案一：连接查询 (Join Query)"></a>方案一：连接查询 (Join Query)</h5><p><strong>核心思想</strong>：通过在一次 SQL 查询中使用 <code>JOIN</code>，将主实体和关联的子实体数据一次性全部查询出来。</p>
<p><strong>实现方式</strong>：修改 <code>ResultMap</code>，使其能够处理 <code>JOIN</code> 后的扁平化结果集。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAllCustomersWithOrders&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;CustomerWithOrdersJoinMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT </span><br><span class="line">        c.id as customer_id, </span><br><span class="line">        c.name as customer_name,</span><br><span class="line">        o.id as order_id,</span><br><span class="line">        o.order_number</span><br><span class="line">    FROM </span><br><span class="line">        t_customer c</span><br><span class="line">    LEFT JOIN </span><br><span class="line">        t_order o ON c.id = o.customer_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;CustomerWithOrdersJoinMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.Customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 映射 Customer 的主键和属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 映射关联的 Order 集合 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ofType 指定集合中元素的类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 映射 Order 的主键和属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;orderNumber&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_number&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis 会智能地将返回的多行结果（其中客户信息是重复的）聚合成一个 <code>Customer</code> 对象列表，每个 <code>Customer</code> 对象包含其对应的 <code>Order</code> 列表。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>一次数据库交互</strong>：性能最高，网络开销最小。</li>
<li>逻辑简单直观。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>数据冗余</strong>：如果一个客户有10个订单，那么这个客户的信息会在结果集中重复10次，增加了数据传输量。</li>
<li><strong>复杂分页问题</strong>：当对主实体（如 <code>Customer</code>）进行分页时，由于 <code>JOIN</code> 导致结果集膨胀，直接在 SQL 中使用 <code>LIMIT</code> 会导致分页结果不准确。这通常会导致“内存分页”，即查询出所有数据后再在内存中进行分页，有内存溢出的风险。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="方案二：分步查询-延迟加载-Nested-Selects-Lazy-Loading"><a href="#方案二：分步查询-延迟加载-Nested-Selects-Lazy-Loading" class="headerlink" title="方案二：分步查询 + 延迟加载 (Nested Selects + Lazy Loading)"></a>方案二：分步查询 + 延迟加载 (Nested Selects + Lazy Loading)</h5><p><strong>核心思想</strong>：仍然执行两次查询，但 MyBatis 会<strong>智能地将 N 次子查询合并为一次</strong>。这被称为**“N+1 优化”**。</p>
<p><strong>实现方式</strong>：</p>
<ol>
<li><p><strong>开启延迟加载</strong>：在 <code>mybatis-config.xml</code> 或 Spring Boot 的 <code>application.yml</code> 中开启延迟加载。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">lazy-loading-enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># aggressive-lazy-loading: false (默认为false，按需加载)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用分步查询的 <code>ResultMap</code></strong> (与问题示例中的 <code>ResultMap</code> 相同)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;CustomerWithOrdersMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.Customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.Order&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;findOrdersByCustomerId&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>工作原理</strong>：</p>
<ol>
<li>MyBatis 首先执行 <code>findAllCustomers</code>，返回 <code>Customer</code> 列表。但由于开启了延迟加载，<code>orders</code> 属性此时是一个代理对象，并未填充数据。</li>
<li>当你<strong>第一次</strong>访问某个 <code>customer.getOrders()</code> 时，MyBatis 不会立即执行查询。</li>
<li>它会<strong>收集</strong>所有已加载的 <code>Customer</code> 列表中的主键 (<code>id</code>)。</li>
<li>然后，它会执行<strong>一次</strong> <code>findOrdersByCustomerId</code> 查询，并使用 <code>IN</code> 子句将所有收集到的 <code>id</code> 传入。<br><code>SELECT * FROM t_order WHERE customer_id IN (1, 2, 3, ...)</code></li>
<li>最后，将查询到的所有 <code>Order</code> 分配给对应的 <code>Customer</code> 对象。</li>
</ol>
<p>这样，总的查询次数从 <strong>1+N</strong> 变成了 <strong>1+1</strong>，极大地提升了性能。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>SQL 语句清晰</strong>，解耦度高。</li>
<li><strong>完美支持分页</strong>：对主实体分页时，不会有任何问题。</li>
<li><strong>按需加载</strong>：如果从不访问 <code>orders</code> 属性，那么第二次查询永远不会被触发。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>需要执行两次数据库查询。</li>
<li>需要额外配置。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-3-MyBatis-Plus-解决方案"><a href="#1-1-3-MyBatis-Plus-解决方案" class="headerlink" title="1.1.3 MyBatis-Plus 解决方案"></a>1.1.3 MyBatis-Plus 解决方案</h4><p>MyBatis-Plus (MP) 底层就是 MyBatis，因此上述两种解决方案<strong>完全适用</strong>。但由于 MP 鼓励使用 Wrapper 进行单表操作，对于多表关联查询，通常的做法是回归 MyBatis 的本质。</p>
<ol>
<li><p><strong>对于连接查询 (方案一)</strong>:</p>
<ul>
<li>MP 的 <code>BaseMapper</code> 不直接支持多表 <code>JOIN</code> 查询。</li>
<li><strong>标准做法</strong>：在 <code>Mapper</code> 接口中自定义一个方法，然后在对应的 XML 文件中编写 <code>JOIN</code> 查询的 SQL 和 <code>ResultMap</code>，这与原生 MyBatis 的方案一<strong>完全一致</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CustomerMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Customer&gt; &#123;</span><br><span class="line">    <span class="comment">// 自定义方法，并使用 IPage 支持分页</span></span><br><span class="line">    IPage&lt;Customer&gt; <span class="title function_">selectCustomerWithOrders</span><span class="params">(IPage&lt;Customer&gt; page)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>CustomerMapper.xml</code> 中实现上述 <code>selectCustomerWithOrders</code> 方法和对应的 <code>ResultMap</code>。</p>
</li>
<li><p><strong>对于分步查询 (方案二)</strong>:</p>
<ul>
<li>同样，需要在 XML 文件中定义好分步查询的 <code>ResultMap</code>。</li>
<li>然后，你可以定义一个自定义的 Mapper 方法来使用这个 <code>ResultMap</code>，或者通过 Wrapper 查询时<strong>动态指定</strong>要使用的 <code>ResultMap</code> (需要额外封装，不常用)。</li>
<li>最直接的方式还是<strong>自定义 Mapper 方法 + XML</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-JPA-Hibernate-解决方案"><a href="#1-2-JPA-Hibernate-解决方案" class="headerlink" title="1.2 JPA&#x2F;Hibernate 解决方案"></a>1.2 JPA&#x2F;Hibernate 解决方案</h3><p>在 JPA&#x2F;Hibernate 中，N+1 问题通常由于<strong>不恰当的抓取策略 (Fetch Strategy)</strong> 和 <strong>不合理的查询方式</strong> 导致。Hibernate 作为其实现，提供了多种高效的解决方案来应对这一问题。</p>
<h4 id="1-2-1-在-JPA-Hibernate-中如何产生-N-1-问题"><a href="#1-2-1-在-JPA-Hibernate-中如何产生-N-1-问题" class="headerlink" title="1.2.1 在 JPA&#x2F;Hibernate 中如何产生 N+1 问题"></a>1.2.1 在 JPA&#x2F;Hibernate 中如何产生 N+1 问题</h4><p>N+1 问题主要发生在加载一个实体及其关联集合时。</p>
<p><strong>典型场景</strong>：查询所有客户 (<code>Customer</code>) 及其各自的订单 (<code>Order</code>) 列表。</p>
<p><strong>实体定义</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;customer&quot;, fetch = FetchType.LAZY)</span> <span class="comment">// LAZY 是默认且推荐的</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.EAGER)</span> <span class="comment">// EAGER 是 ...ToOne 的默认策略</span></span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 第1次查询: 执行查询获取所有客户</span></span><br><span class="line">List&lt;Customer&gt; customers = customerRepository.findAll(); </span><br><span class="line"><span class="comment">// SQL: SELECT * FROM t_customer;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 循环遍历客户，并访问其订单集合</span></span><br><span class="line"><span class="keyword">for</span> (Customer customer : customers) &#123;</span><br><span class="line">    <span class="comment">// 当首次访问 customer.getOrders() 时，由于是懒加载(LAZY)...</span></span><br><span class="line">    <span class="comment">// Hibernate 会为【每个】customer 发起一次新的查询来获取其订单</span></span><br><span class="line">    <span class="comment">// 这将触发 N 次查询！</span></span><br><span class="line">    Set&lt;Order&gt; orders = customer.getOrders(); </span><br><span class="line">    <span class="comment">// SQL: SELECT * FROM t_order WHERE customer_id = ? (此句会执行 N 次)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Customer: &quot;</span> + customer.getName() + <span class="string">&quot;, Orders count: &quot;</span> + orders.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：即使关联是 <code>EAGER</code>（饥饿加载），如果查询方式不当（如使用 <code>findAll()</code>），Hibernate 默认也可能采用分步查询的方式，从而同样引发 N+1 问题。</p>
<hr>
<h4 id="1-2-2-JPA-Hibernate-解决方案"><a href="#1-2-2-JPA-Hibernate-解决方案" class="headerlink" title="1.2.2 JPA&#x2F;Hibernate 解决方案"></a>1.2.2 JPA&#x2F;Hibernate 解决方案</h4><p>JPA&#x2F;Hibernate 提供了多种解决方案，核心思想都是通过<strong>一次查询</strong>将所需的主实体和关联实体都加载到持久化上下文中。</p>
<h5 id="方案一：JPQL-JOIN-FETCH-最常用，最推荐"><a href="#方案一：JPQL-JOIN-FETCH-最常用，最推荐" class="headerlink" title="方案一：JPQL JOIN FETCH (最常用，最推荐)"></a><strong>方案一：JPQL <code>JOIN FETCH</code> (最常用，最推荐)</strong></h5><p><strong>核心思想</strong>：在 JPQL 查询语句中使用 <code>JOIN FETCH</code> 关键字，明确告诉 Hibernate，在执行查询时，不仅要获取主实体，还要<strong>立即、一次性地</strong>将其指定的关联实体（或集合）的数据<strong>一并抓取</strong>出来。</p>
<p><strong>实现方式</strong>: 在 <code>Repository</code> 接口中自定义一个使用 <code>JOIN FETCH</code> 的查询方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Customer, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT DISTINCT c FROM Customer c LEFT JOIN FETCH c.orders&quot;)</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">findAllWithOrders</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>:<br>Hibernate 会将上述 JPQL 转换为一条<strong>包含 <code>LEFT JOIN</code> 的 SQL 语句</strong>：<br><code>SELECT ... FROM t_customer c LEFT JOIN t_order o ON c.id = o.customer_id;</code></p>
<p>它会一次性将所有客户及其所有订单都查询出来，并在内存中智能地组装成 <code>Customer</code> 和 <code>Order</code> 对象。整个过程只有<strong>一次数据库交互</strong>。</p>
<ul>
<li><strong><code>DISTINCT</code> 关键字</strong>：由于 <code>LEFT JOIN</code> 会导致主实体（<code>Customer</code>）因其关联的多个子实体（<code>Order</code>）而重复出现，使用 <code>DISTINCT</code> 可以确保返回的 <code>List&lt;Customer&gt;</code> 中不包含重复的 <code>Customer</code> 对象实例。</li>
<li><strong>优点</strong>:<ul>
<li><strong>性能极高</strong>：将 N+1 次查询合并为 1 次。</li>
<li><strong>代码清晰</strong>：查询意图明确地体现在 JPQL 中。</li>
<li><strong>通用性强</strong>：是解决 N+1 问题的标准和首选方案。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>分页问题</strong>：当对包含 <code>JOIN FETCH</code> 的集合关联进行分页时，Hibernate 会发出警告，因为它无法在数据库层面进行准确的分页。它会<strong>将所有数据加载到内存中再进行分页</strong>，这在数据量大时可能导致内存溢出 (OOM)。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="方案二：实体图-EntityGraph"><a href="#方案二：实体图-EntityGraph" class="headerlink" title="方案二：实体图 (@EntityGraph)"></a><strong>方案二：实体图 (<code>@EntityGraph</code>)</strong></h5><p><strong>核心思想</strong>：<code>@EntityGraph</code> 是 JPA 2.1 引入的一个更强大、更灵活的特性。它允许你<strong>动态地、声明式地</strong>定义一个“抓取计划”，指定在执行某个查询时需要<strong>饥饿加载</strong>哪些关联属性，而无需修改 JPQL 语句。</p>
<p><strong>实现方式</strong>:</p>
<ol>
<li>在实体类上使用 <code>@NamedEntityGraph</code> 定义一个可复用的实体图。</li>
<li>在 <code>Repository</code> 方法上使用 <code>@EntityGraph</code> 注解来应用这个图。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Customer.java</span></span><br><span class="line"><span class="meta">@NamedEntityGraph(</span></span><br><span class="line"><span class="meta">    name = &quot;customer-with-orders-graph&quot;,</span></span><br><span class="line"><span class="meta">    attributeNodes = &#123;</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;orders&quot;) // 指定要一同抓取的属性名</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CustomerRepository.java</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Customer, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行 findAll() 时，应用名为 &quot;customer-with-orders-graph&quot; 的实体图</span></span><br><span class="line">    <span class="meta">@EntityGraph(value = &quot;customer-with-orders-graph&quot;, type = EntityGraphType.FETCH)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">findAll</span><span class="params">()</span>; <span class="comment">// 可以覆盖 JpaRepository 的原生方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以直接在注解中定义 ad-hoc 实体图</span></span><br><span class="line">    <span class="meta">@EntityGraph(attributePaths = &#123;&quot;orders&quot;&#125;)</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">getAllCustomersWithTheirOrders</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>: 与 <code>JOIN FETCH</code> 类似，Hibernate 看到 <code>@EntityGraph</code> 注解后，会自动生成 <code>LEFT JOIN</code> SQL 来一次性加载关联数据。</p>
<ul>
<li><strong><code>type</code> 属性</strong>:<ul>
<li><code>EntityGraphType.FETCH</code>: 实体图中指定的属性会被饥饿加载，未指定的则遵循其默认的抓取策略。<strong>这是我们想要的模式</strong>。</li>
<li><code>EntityGraphType.LOAD</code>: 实体图中指定的属性会被饥饿加载，未指定的则会被强制设置为懒加载。</li>
</ul>
</li>
<li><strong>优点</strong>:<ul>
<li><strong>代码解耦</strong>：将抓取策略与 JPQL 查询本身分离，使得查询语句更简洁。</li>
<li><strong>可复用性</strong>：通过 <code>@NamedEntityGraph</code> 定义的图可以在多个查询中复用。</li>
<li><strong>解决了 <code>JOIN FETCH</code> 的分页问题</strong>：当 <code>@EntityGraph</code> 与分页查询（返回 <code>Page&lt;T&gt;</code>）结合使用时，Hibernate 会智能地执行<strong>两次 SQL</strong>：一次是获取主实体 ID 的分页查询，另一次是根据这些 ID 使用 <code>IN</code> 子句加载关联实体。从而避免了内存分页。这是它相对于 <code>JOIN FETCH</code> 的一大优势。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="方案三：批处理抓取-BatchSize"><a href="#方案三：批处理抓取-BatchSize" class="headerlink" title="方案三：批处理抓取 (@BatchSize)"></a><strong>方案三：批处理抓取 (<code>@BatchSize</code>)</strong></h5><p><strong>核心思想</strong>：这是一种对懒加载的优化。它不会将 N+1 次查询合并为 1 次，而是将其合并为 <strong>1 + (N &#x2F; batch_size)</strong> 次。</p>
<p><strong>实现方式</strong>: 在关联集合的注解上添加 <code>@BatchSize</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;customer&quot;, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@BatchSize(size = 10)</span> <span class="comment">// 设置批处理大小</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>:</p>
<ol>
<li>执行 <code>findAll()</code> 查询，获取 N 个 <code>Customer</code> (1次查询)。</li>
<li>当第一次访问某个 <code>customer.getOrders()</code> 时，Hibernate 不会只查询这一个客户的订单。</li>
<li>它会一次性地<strong>预加载接下来 <code>size</code> (这里是10) 个</strong> <code>Customer</code> 代理对象的 <code>orders</code> 集合。</li>
<li>它会生成一条带有 <code>IN</code> 子句的 SQL，一次性查询 10 个客户的订单：<br><code>SELECT * FROM t_order WHERE customer_id IN (?, ?, ..., ?)</code> (10个参数)</li>
<li>如果 N 是 35，那么总查询次数将是 1 + (10) + (10) + (10) + (5) &#x3D; 1 + 4 &#x3D; 5 次，而不是 1 + 35 &#x3D; 36 次。</li>
</ol>
<ul>
<li><strong>优点</strong>:<ul>
<li><strong>配置简单</strong>：只需一个注解即可。</li>
<li><strong>懒加载优化</strong>：对懒加载场景的性能提升非常有效，且不会像 <code>JOIN FETCH</code> 那样一次性加载所有数据。</li>
<li><strong>对分页友好</strong>。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>仍然需要多次数据库交互，不如 <code>JOIN FETCH</code> 和 <code>@EntityGraph</code> 直接。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-缓存机制"><a href="#2-缓存机制" class="headerlink" title="2. 缓存机制"></a>2. 缓存机制</h2><h3 id="2-1-一级缓存"><a href="#2-1-一级缓存" class="headerlink" title="2.1 一级缓存"></a>2.1 一级缓存</h3><h4 id="2-1-1-定义与核心特性"><a href="#2-1-1-定义与核心特性" class="headerlink" title="2.1.1 定义与核心特性"></a>2.1.1 定义与核心特性</h4><p><strong>一级缓存 (First-Level Cache)</strong> 是 ORM 框架中内置的、与<strong>会话 (Session)</strong> 或 <strong>持久化上下文 (Persistence Context)</strong> 绑定的缓存机制。它是一个无法被关闭或配置的<strong>强制性</strong>特性，是 ORM 框架实现其核心功能的基础。</p>
<p><strong>核心特性</strong>:</p>
<ol>
<li><strong>会话级别 (Session-Level)</strong>:<ul>
<li>一级缓存的生命周期与 <code>SqlSession</code> (MyBatis) 或 <code>EntityManager</code>&#x2F;<code>Session</code> (JPA&#x2F;Hibernate) 的生命周期<strong>完全绑定</strong>。</li>
<li>当会话被创建时，一级缓存随之开启。</li>
<li>当会话被关闭 (<code>close()</code>) 时，一级缓存随之被销毁，其中的所有数据都会被清空。<br>.</li>
</ul>
</li>
<li><strong>线程不共享</strong>:<ul>
<li>由于 <code>SqlSession</code> 和 <code>EntityManager</code> 都是<strong>线程不安全</strong>的，因此一级缓存也是<strong>线程隔离</strong>的。</li>
<li>每个线程（通常对应一个业务请求）都有自己独立的会话和一级缓存，不同线程之间的一级缓存互不影响、互不可见。</li>
</ul>
</li>
<li><strong>身份映射 (Identity Map)</strong>:<ul>
<li>这是ORM框架实现<strong>对象一致性</strong>的关键。</li>
<li>在一级缓存内部，通常是一个 <code>Map&lt;Key, Object&gt;</code> 结构，其中 <code>Key</code> 由实体的<strong>类名</strong>和<strong>主键</strong>组合而成，<code>Value</code> 则是从数据库加载的<strong>实体对象实例</strong>。</li>
<li>这个机制保证了在<strong>同一个会话</strong>中，对于<strong>同一个主键</strong>的<strong>同一个实体类</strong>，无论查询多少次，返回的永远是<strong>同一个 Java 对象实例</strong> (<code>objectA == objectB</code> 为 <code>true</code>)。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-1-2-MyBatis-中的一级缓存"><a href="#2-1-2-MyBatis-中的一级缓存" class="headerlink" title="2.1.2 MyBatis 中的一级缓存"></a>2.1.2 MyBatis 中的一级缓存</h4><p>MyBatis 的一级缓存是默认开启的，且由 <code>SqlSession</code> 直接管理。</p>
<p><strong>工作流程</strong>:</p>
<ol>
<li>当一个 <code>SqlSession</code> 开启后，MyBatis 会为其创建一个 <code>Executor</code>（执行器），<code>Executor</code> 内部持有一个 <code>PerpetualCache</code> 实例，这就是一级缓存。</li>
<li>当通过 <code>SqlSession</code> 执行一次<strong>查询</strong>操作时：<br>a. MyBatis 会根据查询语句、参数、分页信息等生成一个唯一的 <code>CacheKey</code>。<br>b. 首先使用这个 <code>CacheKey</code> 在一级缓存中查找结果。<br>c. <strong>如果命中</strong>，则直接从缓存中返回结果，<strong>不再查询数据库</strong>。<br>d. <strong>如果未命中</strong>，则执行数据库查询，获取结果。<br>e. 将查询到的结果存入一级缓存中（以 <code>CacheKey</code> 为键）。<br>f. 将结果返回给调用者。</li>
</ol>
<p><strong>缓存失效的场景</strong>:</p>
<p>MyBatis 的一级缓存设计得非常“智能”，会在可能导致数据不一致的情况下自动失效：</p>
<ol>
<li><strong>执行 CUD 操作</strong>:<ul>
<li>当在同一个 <code>SqlSession</code> 中执行了 <code>insert</code>, <code>update</code>, <code>delete</code> 操作时，MyBatis 会认为数据库中的数据可能已经发生了变化，为了防止脏读，它会<strong>清空 (clear)</strong> 该 <code>SqlSession</code> 的整个一级缓存。</li>
</ul>
</li>
<li><strong>手动清空缓存</strong>:<ul>
<li>可以调用 <code>sqlSession.clearCache()</code> 方法来手动清空一级缓存。</li>
</ul>
</li>
<li><strong>关闭 <code>SqlSession</code></strong>:<ul>
<li><code>sqlSession.close()</code> 会销毁会话，一级缓存自然也随之销毁。</li>
</ul>
</li>
<li><strong>XML 中设置 <code>flushCache=&quot;true&quot;</code></strong>:<ul>
<li>在 <code>&lt;select&gt;</code>, <code>&lt;insert&gt;</code>, <code>&lt;update&gt;</code>, <code>&lt;delete&gt;</code> 标签上设置 <code>flushCache=&quot;true&quot;</code>，会在执行该语句后强制清空一级缓存。默认情况下，<code>select</code> 为 <code>false</code>，CUD 操作为 <code>true</code>。</li>
</ul>
</li>
</ol>
<p><strong>示例代码 (MyBatis)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次查询，会从数据库加载</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User 1: &quot;</span> + user1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次查询相同的用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User 2: &quot;</span> + user2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于一级缓存的存在，第二次查询不会执行 SQL</span></span><br><span class="line">    <span class="comment">// 并且 user1 和 user2 是同一个 Java 对象实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;user1 == user2 ? &quot;</span> + (user1 == user2)); <span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一次更新操作</span></span><br><span class="line">    user1.setAge(<span class="number">30</span>);</span><br><span class="line">    userMapper.updateUser(user1);</span><br><span class="line">    session.commit(); <span class="comment">// CUD 操作会清空一级缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三次查询</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User 3: &quot;</span> + user3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于缓存已被清空，这次查询会重新从数据库加载</span></span><br><span class="line">    <span class="comment">// 因此 user1 和 user3 是不同的 Java 对象实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;user1 == user3 ? &quot;</span> + (user1 == user3)); <span class="comment">// 输出 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-3-JPA-Hibernate-中的一级缓存"><a href="#2-1-3-JPA-Hibernate-中的一级缓存" class="headerlink" title="2.1.3 JPA&#x2F;Hibernate 中的一级缓存"></a>2.1.3 JPA&#x2F;Hibernate 中的一级缓存</h4><p>JPA&#x2F;Hibernate 的一级缓存就是其核心概念——<strong>持久化上下文 (Persistence Context)</strong>。</p>
<p><strong>工作流程与 MyBatis 类似但更强大</strong>:</p>
<ol>
<li><strong>缓存命中</strong>: 当调用 <code>entityManager.find(User.class, 1L)</code> 时，Hibernate 会首先在持久化上下文中根据 <code>User</code> 类和主键 <code>1L</code> 查找实体。如果找到，直接返回，不访问数据库。</li>
<li><strong>自动脏检查 (Dirty Checking)</strong>: Hibernate 一级缓存的强大之处在于它不仅仅是简单的读缓存。它会保存实体加载时的<strong>快照 (Snapshot)</strong>。在事务提交时，Hibernate 会将当前托管态实体的状态与快照进行对比，如果发现不一致（即“脏”了），就会<strong>自动生成 <code>UPDATE</code> 语句</strong>并同步到数据库。</li>
<li><strong>事务回写 (Transactional Write-Behind)</strong>: 对实体的 <code>persist</code>, <code>merge</code>, <code>remove</code> 操作并不会立即执行 SQL，而是将这些操作缓存在持久化上下文中。直到事务提交或上下文被 <code>flush</code> 时，Hibernate 才会将这些操作以最优化的顺序（例如，先 <code>INSERT</code>，再 <code>UPDATE</code>）一次性发送到数据库。</li>
</ol>
<p><strong>缓存失效的场景</strong>:</p>
<ol>
<li><strong>关闭 <code>EntityManager</code></strong>: <code>entityManager.close()</code> 会销毁持久化上下文。</li>
<li><strong>事务提交或回滚</strong>: 在 Spring 环境下，一个事务结束后，与之关联的 <code>EntityManager</code> 通常也会被关闭。</li>
<li><strong>手动清除</strong>:<ul>
<li><code>entityManager.clear()</code>: <strong>分离 (detach)</strong> 持久化上下文中<strong>所有</strong>的实体。</li>
<li><code>entityManager.detach(entity)</code>: 分离<strong>指定</strong>的实体。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-1-4-一级缓存的意义"><a href="#2-1-4-一级缓存的意义" class="headerlink" title="2.1.4 一级缓存的意义"></a>2.1.4 一级缓存的意义</h4><ul>
<li><strong>保证会话内的数据一致性</strong>: 通过身份映射机制，确保对同一数据的操作都作用于同一个 Java 对象实例，避免了数据冲突和混乱。</li>
<li><strong>减少数据库交互</strong>: 在同一个事务或请求中，对于重复的读取操作，可以显著减少对数据库的访问次数，提升性能。</li>
<li><strong>ORM 核心功能的基础</strong>: 是实现自动脏检查、事务回写等高级特性的基础。没有一级缓存，Hibernate 的许多“魔法”将不复存在。</li>
</ul>
<hr>
<h3 id="2-2-二级缓存"><a href="#2-2-二级缓存" class="headerlink" title="2.2 二级缓存"></a>2.2 二级缓存</h3><h4 id="2-2-1-定义与核心特性"><a href="#2-2-1-定义与核心特性" class="headerlink" title="2.2.1 定义与核心特性"></a>2.2.1 定义与核心特性</h4><p><strong>二级缓存 (Second-Level Cache)</strong> 是一种<strong>跨会话 (Session) &#x2F; 跨事务</strong>的全局缓存机制。与一级缓存不同，二级缓存是可选的、可配置的，并且需要显式地开启和配置。</p>
<p><strong>核心特性</strong>:</p>
<ol>
<li><strong>应用级别 (Application-Level)</strong>:<ul>
<li>二级缓存的生命周期与<strong>应用程序</strong>或 <code>SessionFactory</code> (MyBatis 的 <code>SqlSessionFactory</code> &#x2F; Hibernate 的 <code>SessionFactory</code>) 的生命周期绑定。</li>
<li>只要应用程序在运行，二级缓存就存在，并且可以被应用程序中<strong>所有</strong>的会话&#x2F;线程共享。</li>
</ul>
</li>
<li><strong>线程共享</strong>:<ul>
<li>二级缓存是<strong>线程安全</strong>的。多个用户、多个请求、多个线程都可以访问和共享同一份缓存数据。</li>
</ul>
</li>
<li><strong>数据共享而非对象共享</strong>:<ul>
<li>这是二级缓存与一级缓存的一个关键区别。为了保证线程安全和避免数据被意外修改，从二级缓存中读取数据时，ORM 框架返回的通常是<strong>原始缓存对象的序列化副本 (Serialized Copy)</strong>，而不是缓存中对象的直接引用。</li>
<li>这意味着，不同会话从二级缓存中获取的同一个主键的实体，会是<strong>不同的 Java 对象实例</strong> (<code>objectA == objectB</code> 为 <code>false</code>)，尽管它们的数据内容是相同的。</li>
</ul>
</li>
<li><strong>可插拔 (Pluggable)</strong>:<ul>
<li>ORM 框架本身通常只提供二级缓存的<strong>接口规范</strong>，而具体的缓存实现则由第三方的缓存框架来提供，例如 <strong>EhCache</strong>, <strong>Redis</strong>, <strong>Caffeine</strong> 等。这使得开发者可以根据项目需求选择最合适的缓存产品。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-2-2-MyBatis-中的二级缓存"><a href="#2-2-2-MyBatis-中的二级缓存" class="headerlink" title="2.2.2 MyBatis 中的二级缓存"></a>2.2.2 MyBatis 中的二级缓存</h4><p>MyBatis 的二级缓存是基于 <strong><code>namespace</code> (即 Mapper 接口)</strong> 的。每个 <code>Mapper.xml</code> 文件可以拥有自己独立的二级缓存实例。</p>
<h5 id="1-开启步骤"><a href="#1-开启步骤" class="headerlink" title="1. 开启步骤:"></a>1. 开启步骤:</h5><ol>
<li><p><strong>全局开启</strong>: 在 <code>mybatis-config.xml</code> 或 <code>application.yml</code> 中全局开启二级缓存。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">cache-enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Mapper 级别开启</strong>: 在需要开启二级缓存的 <code>Mapper.xml</code> 文件中，添加 <code>&lt;cache/&gt;</code> 标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- UserMapper.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启该 namespace 的二级缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- ... select, insert, etc. ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实体类实现 <code>Serializable</code> 接口</strong>: 由于二级缓存可能涉及序列化（例如存入 Redis 或跨 JVM 共享），所有需要被缓存的实体类都必须实现 <code>java.io.Serializable</code> 接口。</p>
</li>
<li><p><strong>语句级别控制</strong>: 在单个 <code>&lt;select&gt;</code> 标签上，可以通过 <code>useCache=&quot;true&quot;</code> (默认) 或 <code>useCache=&quot;false&quot;</code> 来控制该查询是否使用二级缓存。</p>
</li>
</ol>
<h5 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程:"></a>2. 工作流程:</h5><ol>
<li>当一个会话 <code>session1</code> 执行查询时，如果一级缓存未命中，它会查询数据库。</li>
<li>查询结果返回后，不仅会存入 <code>session1</code> 的一级缓存，还会被<strong>提交 (commit)</strong> 到 <code>UserMapper</code> 的二级缓存中。<strong>注意：只有当会话被 <code>close()</code> 或 <code>commit()</code> 时，一级缓存中的数据才会被刷新到二级缓存。</strong></li>
<li>之后，另一个会话 <code>session2</code> 执行<strong>完全相同</strong>的查询（<code>CacheKey</code> 相同）。</li>
<li><code>session2</code> 首先检查自己的一级缓存，未命中。</li>
<li>然后，它会去 <code>UserMapper</code> 的二级缓存中查找。</li>
<li><strong>如果命中</strong>，它会从二级缓存中获取数据（的副本），存入自己的一级缓存，然后返回给调用者。<strong>整个过程 <code>session2</code> 没有访问数据库。</strong></li>
</ol>
<h5 id="3-缓存失效"><a href="#3-缓存失效" class="headerlink" title="3. 缓存失效:"></a>3. 缓存失效:</h5><p>当任何一个会话在 <code>UserMapper</code> 的 <code>namespace</code> 下执行了 <code>insert</code>, <code>update</code>, <code>delete</code> 操作并<strong>提交</strong>后，该 <code>namespace</code> 下的<strong>所有二级缓存数据都会被清空 (flush)</strong>。这种“一刀切”的策略保证了数据的最终一致性，但也可能降低缓存的命中率。</p>
<hr>
<h4 id="2-2-3-JPA-Hibernate-中的二级缓存"><a href="#2-2-3-JPA-Hibernate-中的二级缓存" class="headerlink" title="2.2.3 JPA&#x2F;Hibernate 中的二级缓存"></a>2.2.3 JPA&#x2F;Hibernate 中的二级缓存</h4><p>Hibernate 的二级缓存设计得更为精细和强大，它提供了<strong>实体级别</strong>的缓存，并支持更复杂的缓存策略。</p>
<h5 id="1-开启步骤-1"><a href="#1-开启步骤-1" class="headerlink" title="1. 开启步骤:"></a>1. 开启步骤:</h5><ol>
<li><p><strong>添加依赖</strong>: 在 <code>pom.xml</code> 中添加 Hibernate 对特定缓存产品的集成依赖，例如 <code>hibernate-jcache</code> (用于集成 JCache 标准的缓存，如 EhCache 3, Caffeine) 或 <code>hibernate-ehcache</code> (用于 EhCache 2)。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.orm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-jcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全局开启</strong>: 在 <code>application.properties</code> &#x2F; <code>yml</code> 中开启二级缓存并指定缓存工厂。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启二级缓存</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.cache.use_second_level_cache</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># (可选) 开启查询缓存，用于缓存 JPQL 查询结果</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.cache.use_query_cache</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 指定 JCache (EhCache 3) 作为缓存提供商</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.cache.region.factory_class</span>=<span class="string">org.hibernate.cache.jcache.JCacheRegionFactory</span></span><br><span class="line"><span class="comment"># 指定 EhCache 的配置文件路径</span></span><br><span class="line"><span class="attr">spring.jpa.properties.javax.persistence.sharedCache.mode</span>=<span class="string">ENABLE_SELECTIVE</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.javax.cache.provider</span>=<span class="string">org.ehcache.jsr107.EhcacheCachingProvider</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.javax.cache.uri</span>=<span class="string">classpath:ehcache.xml</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实体级别开启</strong>: 在需要缓存的实体类上，使用 <code>@Cacheable</code> 和 <code>@Cache</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Cacheable</span> <span class="comment">// 标记该实体可以被缓存</span></span><br><span class="line"><span class="meta">@org</span>.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE) <span class="comment">// 指定并发访问策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="2-Hibernate-缓存并发策略-CacheConcurrencyStrategy"><a href="#2-Hibernate-缓存并发策略-CacheConcurrencyStrategy" class="headerlink" title="2. Hibernate 缓存并发策略 (CacheConcurrencyStrategy):"></a>2. Hibernate 缓存并发策略 (<code>CacheConcurrencyStrategy</code>):</h5><p>这是 Hibernate 二级缓存的核心配置，决定了如何处理并发访问和保证数据一致性。</p>
<ul>
<li><strong><code>READ_ONLY</code></strong>: 只读缓存。适用于<strong>绝对不会被修改</strong>的数据（如字典表）。性能最高。</li>
<li><strong><code>NONSTRICT_READ_WRITE</code></strong>: 非严格读写。不保证缓存与数据库的强一致性，可能会有短暂的脏读。适用于对数据一致性要求不高的场景。</li>
<li><strong><code>READ_WRITE</code></strong>: 读写缓存。通过类似“版本戳”的机制保证缓存与数据库的<strong>强一致性</strong>（可重复读级别）。这是<strong>最常用</strong>的策略。</li>
<li><strong><code>TRANSACTIONAL</code></strong>: 事务缓存。将缓存的更新操作纳入 JTA 事务管理，提供最高级别的隔离。</li>
</ul>
<h5 id="3-查询缓存-Query-Cache"><a href="#3-查询缓存-Query-Cache" class="headerlink" title="3. 查询缓存 (Query Cache)"></a>3. 查询缓存 (Query Cache)</h5><p>Hibernate 的二级缓存默认只缓存<strong>通过主键 (<code>find</code>&#x2F;<code>get</code>) 加载的实体</strong>。对于 JPQL 或 Criteria 查询返回的<strong>实体列表</strong>，默认是<strong>不缓存</strong>的。</p>
<p>要缓存查询结果，必须：</p>
<ol>
<li><p>全局开启查询缓存 (<code>use_query_cache=true</code>)。</p>
</li>
<li><p>在执行查询时，显式地设置该查询为可缓存的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 Hibernate API</span></span><br><span class="line">query.setCacheable(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring Data JPA (通过 @QueryHint)</span></span><br><span class="line"><span class="meta">@QueryHints(&#123;@QueryHint(name = &quot;org.hibernate.cacheable&quot;, value = &quot;true&quot;)&#125;)</span></span><br><span class="line"><span class="meta">@Query(&quot;from User u where u.age &gt; ?1&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersByAge</span><span class="params">(<span class="type">int</span> age)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>查询缓存缓存的是<strong>查询结果集的主键列表 (ID list)</strong>，而不是实体本身。当执行查询时，Hibernate 会先从查询缓存中找到对应的主键列表，然后再去二级实体缓存中根据这些主-键获取实体数据。</p>
<hr>
<h3 id="2-3-缓存的意义、风险与配置"><a href="#2-3-缓存的意义、风险与配置" class="headerlink" title="2.3 缓存的意义、风险与配置"></a>2.3 缓存的意义、风险与配置</h3><h4 id="2-3-1-缓存的意义-Why-use-cache"><a href="#2-3-1-缓存的意义-Why-use-cache" class="headerlink" title="2.3.1 缓存的意义 (Why use cache?)"></a>2.3.1 缓存的意义 (Why use cache?)</h4><p>在应用中使用一级和二级缓存，主要出于以下几个核心目的：</p>
<ol>
<li><strong>提升性能 (Performance Improvement)</strong><ul>
<li><strong>减少数据库 I&#x2F;O</strong>: 这是最直接的意义。数据库访问通常是应用程序中最慢、资源消耗最大的操作之一，涉及网络延迟、磁盘 I&#x2F;O、SQL 解析与执行等。缓存将频繁读取的数据存储在内存中（内存的访问速度比磁盘快几个数量级），从而极大地减少了对数据库的直接访问。</li>
<li><strong>降低数据库负载</strong>: 当大量并发请求访问相同的数据时，缓存可以直接响应大部分请求，显著降低数据库服务器的压力，使其能够更从容地处理写操作和复杂的查询，从而提高整个系统的吞吐量。</li>
</ul>
</li>
<li><strong>保证数据一致性 (Data Consistency)</strong><ul>
<li>这主要体现在<strong>一级缓存</strong>中。通过其<strong>身份映射 (Identity Map)</strong> 机制，确保在同一个事务或会话中，对同一条数据的所有操作都作用于同一个 Java 对象实例。这避免了在业务逻辑处理过程中因持有不同对象副本而导致的数据状态不一致问题。</li>
</ul>
</li>
<li><strong>ORM 框架功能的基础 (Foundation for ORM Features)</strong><ul>
<li>对于像 Hibernate 这样的全自动 ORM 框架，<strong>一级缓存（持久化上下文）</strong> 是其实现<strong>自动脏检查 (Dirty Checking)</strong> 和 <strong>事务回写 (Transactional Write-Behind)</strong> 等“魔法”功能的基石。没有一级缓存，这些自动化特性将无法实现。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-3-2-缓存的风险与挑战-Risks-and-Challenges"><a href="#2-3-2-缓存的风险与挑战-Risks-and-Challenges" class="headerlink" title="2.3.2 缓存的风险与挑战 (Risks and Challenges)"></a>2.3.2 缓存的风险与挑战 (Risks and Challenges)</h4><p>引入缓存并非银弹，它在带来性能提升的同时，也引入了新的复杂性和风险：</p>
<ol>
<li><strong>数据不一致性 (Data Inconsistency)</strong><ul>
<li><strong>核心挑战</strong>: 缓存的本质是数据的副本。如何保证缓存中的数据与数据库中的主数据保持同步，是缓存系统面临的最大挑战。</li>
<li><strong>产生原因</strong>:<ul>
<li><strong>缓存更新延迟</strong>: 当数据库数据被修改后，如果缓存未能及时更新或失效，就会导致应用程序读到过期的“脏数据”。</li>
<li><strong>多节点问题</strong>: 在分布式系统中，如果多个应用实例各自拥有本地缓存（如 EhCache），当一个节点更新了数据库，其他节点的缓存可能仍然是旧的。</li>
<li><strong>绕过 ORM</strong>: 如果有其他服务或手动执行的 SQL 直接修改了数据库，ORM 框架的缓存机制将对此毫不知情，导致缓存数据过时。</li>
</ul>
</li>
</ul>
</li>
<li><strong>内存消耗 (Memory Consumption)</strong><ul>
<li>缓存是空间换时间的策略。将大量数据加载到内存中会占用宝贵的 JVM 堆空间。如果缓存的数据量过大，或者没有合适的<strong>淘汰策略 (Eviction Policy)</strong>，可能会导致频繁的 Full GC，甚至<strong>内存溢出 (OOM)</strong>。</li>
</ul>
</li>
<li><strong>增加了系统复杂性 (Increased Complexity)</strong><ul>
<li><strong>配置与维护</strong>: 需要仔细配置缓存的容量、过期时间、淘汰策略、并发策略等。</li>
<li><strong>问题排查</strong>: 当出现问题时，排查是源于业务逻辑、数据库还是缓存本身，会变得更加困难。开发者需要理解缓存的工作原理和失效机制。</li>
</ul>
</li>
<li><strong>缓存穿透、击穿和雪崩 (Advanced Cache Problems)</strong><ul>
<li><strong>穿透 (Penetration)</strong>: 查询一个<strong>绝对不存在</strong>的数据。由于缓存中没有，请求会一直穿透到数据库，如果被恶意利用，可能导致数据库崩溃。</li>
<li><strong>击穿 (Breakdown)</strong>: 一个<strong>热点数据</strong>的缓存刚好失效，在此时刻，大量并发请求同时涌入，直接打到数据库上，导致其压力瞬增。</li>
<li><strong>雪崩 (Avalanche)</strong>: 大量缓存数据在<strong>同一时刻</strong>集体失效（例如，设置了相同的过期时间），导致所有请求瞬间全部转向数据库，造成数据库宕机。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-3-3-如何合理配置与使用缓存"><a href="#2-3-3-如何合理配置与使用缓存" class="headerlink" title="2.3.3 如何合理配置与使用缓存"></a>2.3.3 如何合理配置与使用缓存</h4><p>为了最大化缓存的收益并规避其风险，应遵循以下原则：</p>
<ol>
<li><strong>明确缓存适用场景</strong>:<ul>
<li><strong>读多写少</strong>: 缓存最适用于那些<strong>读取频率远高于写入频率</strong>的数据。如果数据频繁变动，维护缓存的成本（不断地使其失效和重新加载）可能会超过其带来的收益。</li>
<li><strong>热点数据</strong>: 优先缓存那些被频繁访问的热点数据。</li>
<li><strong>对一致性要求不高的非核心数据</strong>: 对于一些可以容忍短暂数据不一致的场景（如新闻、商品分类），缓存是绝佳选择。对于金融交易等要求强一致性的核心数据，使用缓存必须极其谨慎。</li>
</ul>
</li>
<li><strong>选择合适的缓存粒度</strong>:<ul>
<li><strong>一级缓存</strong>: 默认开启，无需配置。主要用于保障事务内的数据一致性和性能。</li>
<li><strong>二级缓存</strong>: 按需开启。优先为那些<strong>稳定、不常变化的基础数据</strong>开启二级缓存，例如：<ul>
<li><strong>字典表</strong> (国家、省份、状态码等)</li>
<li><strong>权限配置</strong> (角色、权限资源等)</li>
<li><strong>商品分类</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>精细化配置</strong>:<ul>
<li><strong>设置合理的容量 (<code>max-entries</code>)</strong>: 根据可用内存和数据量估算缓存大小，避免 OOM。</li>
<li><strong>设置淘汰策略 (Eviction Policy)</strong>: 当缓存满时，如何淘汰旧数据。常用策略有：<ul>
<li><code>LRU</code> (Least Recently Used): 淘汰最久未被使用的数据。</li>
<li><code>LFU</code> (Least Frequently Used): 淘汰最不常用的数据。</li>
<li><code>FIFO</code> (First In First Out): 先进先出。</li>
</ul>
</li>
<li><strong>设置过期时间 (<code>TTL/TTI</code>)</strong>:<ul>
<li><code>TTL</code> (Time To Live): 数据存活时间。从放入缓存开始计时，到期自动失效。</li>
<li><code>TTI</code> (Time To Idle): 数据空闲时间。每次访问都会重置计时器，如果数据在指定时间内一直未被访问，则失效。</li>
</ul>
</li>
<li><strong>选择正确的并发策略 (Hibernate)</strong>: 根据数据的更新特性选择 <code>READ_ONLY</code>, <code>READ_WRITE</code> 等策略，在性能和一致性之间找到平衡。</li>
</ul>
</li>
<li><strong>分布式缓存方案</strong>:<ul>
<li>在分布式或微服务架构中，应优先考虑使用<strong>集中式&#x2F;分布式缓存</strong>，如 <strong>Redis</strong>, <strong>Memcached</strong>。</li>
<li>这可以保证所有服务实例共享同一份缓存数据，从根本上解决多节点间的缓存不一致问题。</li>
<li>ORM 框架（如 Hibernate）可以通过相应的集成包（如 <code>hibernate-redis</code>）与这些分布式缓存系统无缝集成。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>: 缓存是一把双刃剑。合理地使用和配置可以极大地提升系统性能和可伸缩性，但错误或盲目地使用则会引入数据不一致等严重问题。在决定使用二级缓存之前，务必进行充分的分析和评估。</p>
<hr>
<h2 id="3-事务管理"><a href="#3-事务管理" class="headerlink" title="3. 事务管理"></a>3. 事务管理</h2><h3 id="3-1-ORM框架与事务如何集成"><a href="#3-1-ORM框架与事务如何集成" class="headerlink" title="3.1 ORM框架与事务如何集成"></a>3.1 ORM框架与事务如何集成</h3><p>事务管理是企业级应用中保证数据一致性的核心机制。ORM 框架作为数据持久化层，其所有写操作（增、删、改）都必须在事务的边界内进行。因此，ORM 框架与事务管理的集成是天作之合，也是框架设计的关键部分。</p>
<h4 id="3-1-1-事务管理的核心职责"><a href="#3-1-1-事务管理的核心职责" class="headerlink" title="3.1.1 事务管理的核心职责"></a>3.1.1 事务管理的核心职责</h4><p>无论何种技术实现，事务管理器都需要负责以下核心职责：</p>
<ol>
<li><strong>开启事务 (Begin)</strong>: 标记一个新事务的开始。</li>
<li><strong>提交事务 (Commit)</strong>: 如果事务中的所有操作都成功执行，则将这些变更永久保存到数据库。</li>
<li><strong>回滚事务 (Rollback)</strong>: 如果事务中任何一个操作失败，或者业务逻辑要求中止，则撤销该事务中已执行的所有操作，使数据库恢复到事务开始前的状态。</li>
</ol>
<hr>
<h4 id="3-1-2-集成方式"><a href="#3-1-2-集成方式" class="headerlink" title="3.1.2 集成方式"></a>3.1.2 集成方式</h4><p>ORM 框架与事务的集成主要有两种方式：<strong>编程式事务</strong>和<strong>声明式事务</strong>。在现代开发中，特别是与 Spring 框架结合使用时，<strong>声明式事务是绝对的主流和最佳实践</strong>。</p>
<h5 id="1-编程式事务-Programmatic-Transaction-Management"><a href="#1-编程式事务-Programmatic-Transaction-Management" class="headerlink" title="1. 编程式事务 (Programmatic Transaction Management)"></a>1. 编程式事务 (Programmatic Transaction Management)</h5><p><strong>定义</strong>: 在业务代码中，通过<strong>手动调用</strong>事务管理 API 来精确控制事务的边界（开始、提交、回滚）。</p>
<p><strong>集成原理</strong>:ORM 框架提供获取和控制事务的底层 API。开发者需要显式地在代码中进行管理。</p>
<p><strong>MyBatis 中的编程式事务</strong>:</p>
<p>MyBatis 的事务管理是建立在 JDBC 事务之上的。<code>SqlSession</code> 默认是<strong>不自动提交</strong>事务的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession(); <span class="comment">// 默认 openSession(false)</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="comment">// ... 执行多个数据库操作</span></span><br><span class="line">    userMapper.updateUser(user1);</span><br><span class="line">    accountMapper.decreaseBalance(account1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有操作成功，手动提交事务</span></span><br><span class="line">    session.commit(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 发生异常，手动回滚事务</span></span><br><span class="line">    session.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 必须关闭 session</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>: 控制粒度最细，可以非常灵活地在代码的任何位置开启或结束事务。</li>
<li><strong>缺点</strong>:<ul>
<li><strong>代码侵入性强</strong>: 事务管理逻辑与业务逻辑紧密耦合在一起，污染了业务代码。</li>
<li><strong>重复性高</strong>: 每个需要事务的方法都必须编写类似的 <code>try-catch-finally</code> 样板代码，容易出错和遗漏。</li>
<li><strong>维护困难</strong>: 随着业务逻辑变复杂，事务边界的管理会变得非常混乱。</li>
</ul>
</li>
</ul>
<p><strong>JPA&#x2F;Hibernate 中的编程式事务</strong>:</p>
<p>JPA 提供了 <code>EntityTransaction</code> API 来管理事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EntityManager</span> <span class="variable">em</span> <span class="operator">=</span> emf.createEntityManager();</span><br><span class="line"><span class="type">EntityTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取并开启事务</span></span><br><span class="line">    transaction = em.getTransaction();</span><br><span class="line">    transaction.begin();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 执行实体操作</span></span><br><span class="line">    em.persist(newUser);</span><br><span class="line">    em.merge(existingAccount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    <span class="keyword">if</span> (transaction != <span class="literal">null</span> &amp;&amp; transaction.isActive()) &#123;</span><br><span class="line">        transaction.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    em.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其优缺点与 MyBatis 编程式事务完全相同。</p>
<hr>
<h5 id="2-声明式事务-Declarative-Transaction-Management-主流方式"><a href="#2-声明式事务-Declarative-Transaction-Management-主流方式" class="headerlink" title="2. 声明式事务 (Declarative Transaction Management) - (主流方式)"></a>2. 声明式事务 (Declarative Transaction Management) - (主流方式)</h5><p><strong>定义</strong>: 通过<strong>注解 (<code>@Transactional</code>)</strong> 或 XML 配置的方式来“声明”一个方法的事务属性，而无需在方法内部编写任何事务管理代码。事务管理的横切逻辑由框架（通常是 Spring AOP）自动织入。</p>
<p><strong>集成原理</strong>:</p>
<p>这是 Spring 框架与 ORM 框架集成的核心。Spring 提供了统一的事务管理抽象 (<code>PlatformTransactionManager</code>)，并为不同的持久化技术提供了具体的实现类。</p>
<ul>
<li>对于 <strong>JDBC&#x2F;MyBatis</strong>，使用 <code>DataSourceTransactionManager</code>。</li>
<li>对于 <strong>JPA&#x2F;Hibernate</strong>，使用 <code>JpaTransactionManager</code>。</li>
</ul>
<p><strong>工作流程 (以 Spring + JPA 为例)</strong>:</p>
<ol>
<li><p><strong>配置 <code>TransactionManager</code></strong>: 在 Spring 配置中，声明一个 <code>JpaTransactionManager</code> Bean，并将其与 <code>EntityManagerFactory</code> 关联起来。Spring Boot 会自动完成这个配置。</p>
</li>
<li><p><strong>开启事务支持</strong>: 使用 <code>@EnableTransactionManagement</code> 注解开启声明式事务功能。Spring Boot 也是自动开启的。</p>
</li>
<li><p><strong>声明事务边界</strong>: 在需要事务管理的方法或类上添加 <code>@Transactional</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">TransferService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountRepository accountRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 声明此方法需要事务管理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Long fromId, Long toId, BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 业务逻辑 ...</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">fromAccount</span> <span class="operator">=</span> accountRepository.findById(fromId).orElseThrow();</span><br><span class="line">        <span class="type">Account</span> <span class="variable">toAccount</span> <span class="operator">=</span> accountRepository.findById(toId).orElseThrow();</span><br><span class="line">        </span><br><span class="line">        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));</span><br><span class="line">        toAccount.setBalance(toAccount.getBalance().add(amount));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 无需手动 commit/rollback</span></span><br><span class="line">        <span class="comment">// Spring 会在方法成功执行后自动提交事务</span></span><br><span class="line">        <span class="comment">// 如果方法抛出运行时异常，Spring 会自动回滚事务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>AOP 动态代理</strong>:</p>
<ul>
<li>当 Spring 容器启动时，它会扫描到 <code>@Transactional</code> 注解。</li>
<li>Spring 会为 <code>TransferServiceImpl</code> 创建一个<strong>动态代理对象</strong>。</li>
<li>当外部代码调用 <code>transferService.transfer(...)</code> 时，实际上调用的是这个代理对象的方法。</li>
</ul>
</li>
<li><p><strong>事务拦截器</strong>:</p>
<ul>
<li>代理对象的方法在执行<strong>前</strong>，会触发一个事务拦截器（Transaction Interceptor）。</li>
<li>拦截器会从 <code>JpaTransactionManager</code> 中获取一个事务，并<strong>开启事务</strong>（底层是调用 <code>em.getTransaction().begin()</code>）。</li>
<li>同时，它会将 <code>EntityManager</code> 和事务信息绑定到当前线程的 <code>ThreadLocal</code> 中，以确保后续的数据库操作都在同一个事务和会z话中进行。</li>
</ul>
</li>
<li><p><strong>执行业务逻辑</strong>: 代理对象接着调用<strong>原始 <code>TransferServiceImpl</code> 对象</strong>的 <code>transfer</code> 方法。方法中的所有数据库操作都会使用从 <code>ThreadLocal</code> 中获取的 <code>EntityManager</code>。</p>
</li>
<li><p><strong>提交&#x2F;回滚</strong>:</p>
<ul>
<li>如果 <code>transfer</code> 方法<strong>正常执行完毕</strong>，事务拦截器会在方法返回后<strong>提交事务</strong> (<code>transaction.commit()</code>)。</li>
<li>如果 <code>transfer</code> 方法<strong>抛出运行时异常</strong>（<code>RuntimeException</code> 或 <code>Error</code>），事务拦截器会捕获异常，并<strong>回滚事务</strong> (<code>transaction.rollback()</code>)，然后将异常继续向外抛出。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-1-3-总结"><a href="#3-1-3-总结" class="headerlink" title="3.1.3 总结"></a>3.1.3 总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">编程式事务</th>
<th align="left">声明式事务</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现方式</strong></td>
<td align="left">手动调用 API</td>
<td align="left">注解 (<code>@Transactional</code>) &#x2F; XML 配置</td>
</tr>
<tr>
<td align="left"><strong>代码侵入性</strong></td>
<td align="left"><strong>高</strong>，业务与事务逻辑耦合</td>
<td align="left"><strong>极低</strong>，业务代码干净</td>
</tr>
<tr>
<td align="left"><strong>维护性</strong></td>
<td align="left"><strong>差</strong>，样板代码多，易出错</td>
<td align="left"><strong>优秀</strong>，逻辑清晰，易于管理</td>
</tr>
<tr>
<td align="left"><strong>框架</strong></td>
<td align="left">ORM 框架原生支持</td>
<td align="left"><strong>Spring AOP</strong></td>
</tr>
<tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left">仅在极少数需要精细控制的场景使用</td>
<td align="left"><strong>99% 的场景下的最佳实践</strong></td>
</tr>
</tbody></table>
<p><strong>结论</strong>: 在现代 Spring 应用中，ORM 框架与事务的集成几乎总是通过 <strong>Spring 的声明式事务管理</strong> 来实现的。这种方式将事务控制的复杂性完全交给了框架，让开发者可以专注于业务逻辑本身，是 AOP 思想的最佳体现之一。</p>
<hr>
<h3 id="3-2-声明式事务的工作原理"><a href="#3-2-声明式事务的工作原理" class="headerlink" title="3.2 声明式事务的工作原理"></a>3.2 声明式事务的工作原理</h3><p>Spring 的声明式事务是其最核心、最强大的功能之一，也是 AOP (Aspect-Oriented Programming, 面向切面编程) 思想的经典应用。理解其工作原理，有助于我们正确地使用 <code>@Transactional</code> 注解并避免常见的“事务失效”问题。</p>
<p>其核心可以概括为：<strong>基于 AOP 的动态代理和事务拦截器</strong>。</p>
<h4 id="3-2-1-核心组件"><a href="#3-2-1-核心组件" class="headerlink" title="3.2.1 核心组件"></a>3.2.1 核心组件</h4><ol>
<li><strong><code>@Transactional</code> 注解</strong>:<ul>
<li>一个元数据标记，用于告诉 Spring 哪些类或方法需要被事务管理。它本身不包含任何逻辑，只是一个“声明”。</li>
</ul>
</li>
<li><strong><code>PlatformTransactionManager</code> (平台事务管理器)</strong>:<ul>
<li>Spring 事务管理的<strong>统一接口</strong>，定义了 <code>getTransaction</code>, <code>commit</code>, <code>rollback</code> 等核心方法。</li>
<li>Spring 为不同的持久化技术提供了具体的实现，例如：<ul>
<li><code>DataSourceTransactionManager</code>: 用于 JDBC, MyBatis。</li>
<li><code>JpaTransactionManager</code>: 用于 JPA&#x2F;Hibernate。</li>
</ul>
</li>
<li>它的职责是实际执行事务的开启、提交和回滚操作。</li>
</ul>
</li>
<li><strong>AOP 代理 (AOP Proxy)</strong>:<ul>
<li>Spring AOP 的核心。当 Spring 容器扫描到一个类被 <code>@Transactional</code> 注解标记时，它<strong>不会</strong>直接将这个类的原始实例（目标对象 Target Object）放入容器。</li>
<li>相反，它会为这个目标对象创建一个<strong>动态代理对象 (Proxy)</strong>，并将这个代理对象作为 Bean 放入容器。</li>
<li>这个代理对象“包裹”了原始对象，并持有对它的引用。</li>
</ul>
</li>
<li><strong>事务拦截器 (Transaction Interceptor)</strong>:<ul>
<li>一个实现了 AOP <code>Advice</code> (通知) 的组件，通常是 <code>TransactionInterceptor</code> 类。</li>
<li>这个拦截器包含了事务管理的<strong>横切逻辑</strong>（即在业务方法执行前后需要做的事务操作）。</li>
<li>Spring 会通过<strong>切点 (Pointcut)</strong> 将这个拦截器与被 <code>@Transactional</code> 注解的方法绑定起来。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-2-2-详细工作流程"><a href="#3-2-2-详细工作流程" class="headerlink" title="3.2.2 详细工作流程"></a>3.2.2 详细工作流程</h4><p>下面以一个典型的服务调用 <code>someService.doBusinessLogic()</code> 为例，分解声明式事务的完整工作流程：</p>
<p><strong>步骤 1: 外部调用</strong></p>
<ul>
<li>当应用程序的其他部分（如 Controller）注入并调用 <code>SomeService</code> 的 <code>doBusinessLogic()</code> 方法时，它实际获取并调用的是 <strong>Spring 创建的 <code>SomeService</code> 的代理对象</strong>，而不是原始的 <code>SomeService</code> 实例。</li>
</ul>
<p><strong>步骤 2: 代理拦截</strong></p>
<ul>
<li>对代理对象的 <code>doBusinessLogic()</code> 方法的调用被 <strong>AOP 代理</strong>所拦截。</li>
</ul>
<p><strong>步骤 3: 事务拦截器介入</strong></p>
<ul>
<li>代理对象在调用原始业务方法<strong>之前</strong>，首先会调用<strong>事务拦截器</strong> (<code>TransactionInterceptor</code>) 的 <code>invoke</code> 方法。</li>
</ul>
<p><strong>步骤 4: 开启事务</strong></p>
<ul>
<li>事务拦截器检查 <code>doBusinessLogic()</code> 方法上的 <code>@Transactional</code> 注解的属性（如隔离级别、传播行为、只读等）。</li>
<li>它向 <code>PlatformTransactionManager</code> (例如 <code>JpaTransactionManager</code>) 请求一个新事务。</li>
<li><code>PlatformTransactionManager</code> 会：<br>a. 从数据源获取一个数据库连接 (<code>Connection</code>)。<br>b. <strong>禁用</strong>该连接的自动提交 (<code>connection.setAutoCommit(false)</code>)。<br>c. (对于 JPA) 创建一个 <code>EntityManager</code>，并开始一个事务 (<code>em.getTransaction().begin()</code>)。<br>d. 将数据库连接&#x2F;<code>EntityManager</code> 等事务资源<strong>绑定到当前线程的 <code>ThreadLocal</code></strong> 中。这是为了确保后续在该线程中的所有数据库操作都使用同一个连接&#x2F;<code>EntityManager</code>，从而处于同一个事务中。</li>
</ul>
<p><strong>步骤 5: 执行业务逻辑</strong></p>
<ul>
<li>事务拦截器调用<strong>原始 <code>SomeService</code> 实例 (Target Object)</strong> 的 <code>doBusinessLogic()</code> 方法。</li>
<li>在该方法内部，所有对 <code>Repository</code> 或 <code>Mapper</code> 的调用，都会从 <code>ThreadLocal</code> 中获取已经被事务管理的数据库连接或 <code>EntityManager</code>，并执行相应的 SQL 操作。这些操作的结果暂时停留在数据库的事务日志或 ORM 的一级缓存中，并未永久提交。</li>
</ul>
<p><strong>步骤 6: 事务提交或回滚</strong></p>
<ul>
<li>业务方法 <code>doBusinessLogic()</code> 执行完毕后，控制权返回给事务拦截器。</li>
<li><strong>情况 A: 方法正常返回 (没有抛出异常)</strong><ul>
<li>拦截器会通知 <code>PlatformTransactionManager</code> <strong>提交 (commit)</strong> 事务。</li>
<li><code>PlatformTransactionManager</code> 会调用 <code>connection.commit()</code> 或 <code>em.getTransaction().commit()</code>，将事务中的所有变更永久写入数据库。</li>
</ul>
</li>
<li><strong>情况 B: 方法抛出异常</strong><ul>
<li>拦截器会捕获这个异常。</li>
<li>默认情况下，如果异常是 <code>RuntimeException</code> 或 <code>Error</code>，拦截器会通知 <code>PlatformTransactionManager</code> <strong>回滚 (rollback)</strong> 事务。</li>
<li><code>PlatformTransactionManager</code> 会调用 <code>connection.rollback()</code> 或 <code>em.getTransaction().rollback()</code>，撤销事务中的所有变更。</li>
<li>如果异常是<strong>受检异常 (Checked Exception)</strong>，默认情况下事务<strong>不会</strong>回滚（可以通过 <code>@Transactional(rollbackFor = ...)</code> 来改变这个行为）。</li>
<li>回滚或提交后，拦截器会将捕获的异常继续向外抛出。</li>
</ul>
</li>
</ul>
<p><strong>步骤 7: 清理资源</strong></p>
<ul>
<li>无论事务是提交还是回滚，事务拦截器最终都会在 <code>finally</code> 块中执行清理操作。</li>
<li><code>PlatformTransactionManager</code> 会<strong>释放</strong>数据库连接（将其归还给连接池），并从 <code>ThreadLocal</code> 中<strong>解绑</strong>所有事务资源。</li>
</ul>
<hr>
<h4 id="3-2-3-为什么-Transactional-会失效？"><a href="#3-2-3-为什么-Transactional-会失效？" class="headerlink" title="3.2.3 为什么 @Transactional 会失效？"></a>3.2.3 为什么 <code>@Transactional</code> 会失效？</h4><p>理解了上述原理，就很容易明白为什么在某些情况下 <code>@Transactional</code> 会失效：</p>
<ul>
<li><strong>方法不是 <code>public</code> 的</strong>: Spring AOP 默认只能代理 <code>public</code> 方法。</li>
<li><strong>方法是 <code>final</code> 或 <code>static</code> 的</strong>: 代理是基于子类继承 (CGLIB) 或接口实现 (JDK Proxy) 的，<code>final</code> 和 <code>static</code> 方法无法被覆盖，因此无法被代理。</li>
<li><strong>同一个类中的方法调用 (this 调用)</strong>:<ul>
<li><code>public void methodA() { this.methodB(); }</code></li>
<li>如果外部调用 <code>methodA()</code> (无 <code>@Transactional</code> 注解)，而 <code>methodB()</code> 有 <code>@Transactional</code> 注解，<code>methodB</code> 的事务<strong>不会生效</strong>。</li>
<li><strong>原因</strong>: 调用 <code>this.methodB()</code> 是直接调用<strong>原始对象 (Target Object)</strong> 的方法，<strong>绕过了代理对象 (Proxy)</strong>。事务拦截器根本没有机会介入。</li>
</ul>
</li>
<li><strong>异常被 <code>catch</code> 掉了</strong>: 如果业务方法内部 <code>try-catch</code> 了一个 <code>RuntimeException</code> 并且没有重新抛出，事务拦截器就感知不到异常的发生，因此会<strong>正常提交事务</strong>。</li>
</ul>
<hr>
<h3 id="3-3-事务的隔离级别与传播行为"><a href="#3-3-事务的隔离级别与传播行为" class="headerlink" title="3.3 事务的隔离级别与传播行为"></a>3.3 事务的隔离级别与传播行为</h3><p>在使用 Spring 的 <code>@Transactional</code> 注解时，除了默认行为，我们还可以通过配置其 <code>isolation</code> (隔离级别) 和 <code>propagation</code> (传播行为) 属性，来精细化地控制事务的行为，以应对复杂的业务场景。</p>
<h4 id="3-3-1-事务的隔离级别-Isolation-Level"><a href="#3-3-1-事务的隔离级别-Isolation-Level" class="headerlink" title="3.3.1 事务的隔离级别 (Isolation Level)"></a>3.3.1 事务的隔离级别 (Isolation Level)</h4><p><strong>定义</strong>: 隔离级别定义了一个事务在执行过程中，其所做的修改对<strong>其他并发事务</strong>的可见程度。它旨在解决多事务并发执行时可能出现的<strong>脏读、不可重复读、幻读</strong>等问题。</p>
<p>隔离级别本质上是在<strong>数据一致性</strong>和<strong>并发性能</strong>之间做出的权衡。级别越高，数据一致性越好，但并发性能通常越差，因为需要更强的锁机制。</p>
<p><strong>并发问题简介</strong>:</p>
<ul>
<li><strong>脏读 (Dirty Read)</strong>: 一个事务读取到了另一个<strong>未提交</strong>事务修改的数据。</li>
<li><strong>不可重复读 (Non-Repeatable Read)</strong>: 在同一个事务内，两次读取<strong>同一行</strong>数据，得到的结果不同。这是因为在两次读取之间，有另一个事务<strong>提交了</strong>对这行数据的修改。</li>
<li><strong>幻读 (Phantom Read)</strong>: 在同一个事务内，两次执行<strong>相同的范围查询</strong>，第二次查询返回了第一次查询中<strong>不存在的新行</strong>。这是因为在两次查询之间，有另一个事务<strong>插入了</strong>符合该范围条件的新数据。</li>
</ul>
<p><strong>Spring 定义的隔离级别 (<code>Isolation</code> 枚举)</strong>:</p>
<table>
<thead>
<tr>
<th align="left">隔离级别 (<code>@Transactional(isolation = ...</code>)</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
<th align="left">数据库默认 (常见)</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>READ_UNCOMMITTED</code></td>
<td align="left"><strong>可能</strong></td>
<td align="left"><strong>可能</strong></td>
<td align="left"><strong>可能</strong></td>
<td align="left">-</td>
<td align="left"><strong>读未提交</strong>。级别最低，允许读取未提交的数据，性能最好但数据一致性最差。几乎不使用。</td>
</tr>
<tr>
<td align="left"><code>READ_COMMITTED</code></td>
<td align="left">不会</td>
<td align="left"><strong>可能</strong></td>
<td align="left"><strong>可能</strong></td>
<td align="left">Oracle, SQL Server</td>
<td align="left"><strong>读已提交</strong>。一个事务只能读取到其他已提交事务的修改。解决了脏读。这是大多数数据库的默认级别。</td>
</tr>
<tr>
<td align="left"><code>REPEATABLE_READ</code></td>
<td align="left">不会</td>
<td align="left">不会</td>
<td align="left"><strong>可能</strong></td>
<td align="left"><strong>MySQL (InnoDB)</strong></td>
<td align="left"><strong>可重复读</strong>。保证在同一事务中多次读取同一行数据的结果是一致的。解决了不可重复读。MySQL InnoDB 通过 Next-Key Lock 机制在一定程度上解决了幻读。</td>
</tr>
<tr>
<td align="left"><code>SERIALIZABLE</code></td>
<td align="left">不会</td>
<td align="left">不会</td>
<td align="left">不会</td>
<td align="left">-</td>
<td align="left"><strong>串行化</strong>。级别最高，强制事务串行执行，完全避免了所有并发问题。性能最差，通常不使用。</td>
</tr>
<tr>
<td align="left"><code>DEFAULT</code></td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left"><strong>使用数据库的默认隔离级别</strong>。这是 <code>@Transactional</code> 的<strong>默认值</strong>。</td>
</tr>
</tbody></table>
<p><strong>如何选择</strong>:</p>
<ul>
<li>绝大多数情况下，使用<strong>数据库的默认隔离级别 (<code>DEFAULT</code>)</strong> 就足够了。</li>
<li>如果业务上对数据一致性有特殊要求（例如，在一次交易中需要多次读取账户余额并确保其不变），可以考虑提升隔离级别到 <code>REPEATABLE_READ</code>。</li>
</ul>
<hr>
<h4 id="3-3-2-事务的传播行为-Propagation-Behavior"><a href="#3-3-2-事务的传播行为-Propagation-Behavior" class="headerlink" title="3.3.2 事务的传播行为 (Propagation Behavior)"></a>3.3.2 事务的传播行为 (Propagation Behavior)</h4><p><strong>定义</strong>: 传播行为定义了当一个<strong>已存在事务</strong>的方法调用另一个需要事务的方法时，事务应该如何<strong>传播或交互</strong>。它解决了<strong>事务嵌套</strong>的问题。</p>
<p>例如，<code>ServiceA.methodA()</code> 调用 <code>ServiceB.methodB()</code>，两者都标记了 <code>@Transactional</code>，<code>methodB</code> 是加入 <code>methodA</code> 的事务，还是开启一个新事务？这就是传播行为要解决的问题。</p>
<p><strong>Spring 定义的传播行为 (<code>Propagation</code> 枚举)</strong>:</p>
<table>
<thead>
<tr>
<th align="left">传播行为 (<code>@Transactional(propagation = ...</code>)</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>REQUIRED</code></strong> (默认值)</td>
<td align="left"><strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</strong> 这是最常用、最符合逻辑的行为。</td>
</tr>
<tr>
<td align="left"><code>SUPPORTS</code></td>
<td align="left">如果当前存在事务，则加入该事务；如果当前没有事务，则以<strong>非事务</strong>的方式执行。</td>
</tr>
<tr>
<td align="left"><code>MANDATORY</code></td>
<td align="left"><strong>强制要求</strong>当前必须存在一个事务，否则抛出异常。</td>
</tr>
<tr>
<td align="left"><strong><code>REQUIRES_NEW</code></strong></td>
<td align="left"><strong>总是创建一个新的事务。</strong> 如果当前已存在事务，则将<strong>当前事务挂起</strong>，执行完新事务后再恢复。两个事务是完全独立的，外部事务的回滚不影响内部事务的提交，反之亦然。</td>
</tr>
<tr>
<td align="left"><code>NOT_SUPPORTED</code></td>
<td align="left">以<strong>非事务</strong>的方式执行操作。如果当前存在事务，则将该事务挂起。</td>
</tr>
<tr>
<td align="left"><code>NEVER</code></td>
<td align="left">以<strong>非事务</strong>的方式执行，并且<strong>强制要求</strong>当前不能存在事务，否则抛出异常。</td>
</tr>
<tr>
<td align="left"><code>NESTED</code></td>
<td align="left"><strong>嵌套事务</strong>。如果当前存在事务，则在当前事务中创建一个保存点 (Savepoint)，形成一个嵌套事务。嵌套事务可以独立于外部事务进行回滚。如果当前没有事务，则行为等同于 <code>REQUIRED</code>。 (注意：并非所有数据库都支持保存点)</td>
</tr>
</tbody></table>
<p><strong>最常用的两种传播行为</strong>:</p>
<h5 id="1-REQUIRED-默认"><a href="#1-REQUIRED-默认" class="headerlink" title="1. REQUIRED (默认)"></a>1. <code>REQUIRED</code> (默认)</h5><ul>
<li><strong>场景</strong>: 绝大多数业务场景。例如，一个“下单”服务 <code>placeOrder()</code> 调用“扣减库存”服务 <code>deductStock()</code> 和“更新订单状态”服务 <code>updateStatus()</code>。这三个操作逻辑上属于<strong>同一个原子工作单元</strong>，必须同成败。<code>deductStock</code> 和 <code>updateStatus</code> 都应该加入到 <code>placeOrder</code> 的事务中。</li>
<li><strong>结果</strong>: 整个调用链在同一个事务中，任何一步失败，所有操作都会一起回滚。</li>
</ul>
<h5 id="2-REQUIRES-NEW"><a href="#2-REQUIRES-NEW" class="headerlink" title="2. REQUIRES_NEW"></a>2. <code>REQUIRES_NEW</code></h5><ul>
<li><p><strong>场景</strong>: 当你希望某个操作的事务独立于外部调用者的事务时。</p>
</li>
<li><p><strong>典型例子</strong>: 记录操作日志。假设有一个业务方法 <code>doBusiness()</code>，无论 <code>doBusiness()</code> 最终是成功提交还是失败回滚，我们都<strong>希望</strong>将本次操作的日志 (<code>logService.record(...)</code>) <strong>成功地保存到数据库</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusiness</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ... 核心业务逻辑，可能会失败 ...</span></span><br><span class="line">            <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;业务失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论业务成功与否，都尝试记录日志</span></span><br><span class="line">            logService.record(<span class="string">&quot;执行了一次业务操作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 将日志信息保存到数据库 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>工作流程</strong>:</p>
<ol>
<li><code>doBusiness</code> 开启事务 <code>TX1</code>。</li>
<li>调用 <code>logService.record</code> 时，<code>REQUIRES_NEW</code> 会使 <code>TX1</code> <strong>挂起</strong>。</li>
<li><code>logService.record</code> 开启一个<strong>全新的、独立的事务 <code>TX2</code></strong>。</li>
<li><code>record</code> 方法执行完毕，<code>TX2</code> <strong>独立提交</strong>，日志成功写入数据库。</li>
<li>控制权返回，<code>TX1</code> <strong>恢复</strong>。</li>
<li><code>doBusiness</code> 方法中抛出异常，<code>TX1</code> <strong>回滚</strong>。</li>
</ol>
</li>
<li><p><strong>最终结果</strong>: 核心业务操作被回滚，但操作日志成功保留。</p>
</li>
</ul>
<hr>
<h2 id="4-ORM框架选型"><a href="#4-ORM框架选型" class="headerlink" title="4. ORM框架选型"></a>4. ORM框架选型</h2><p>在 Java 持久化领域，MyBatis (及其增强版 MyBatis-Plus) 和 JPA (以 Hibernate 为代表实现) 是两大主流选择。它们没有绝对的优劣之分，而是各自在设计哲学、适用场景和开发体验上有所侧重。进行技术选型时，需要综合考虑项目需求、团队技能、性能要求和未来发展等多个维度。</p>
<h3 id="4-1-核心差异对比"><a href="#4-1-核心差异对比" class="headerlink" title="4.1 核心差异对比"></a>4.1 核心差异对比</h3><p>这是一张总结两大框架核心差异的对比表，可以作为选型的快速参考：</p>
<table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">MyBatis &#x2F; MyBatis-Plus</th>
<th align="left">JPA &#x2F; Hibernate</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>设计哲学</strong></td>
<td align="left"><strong>SQL中心 (SQL-centric)</strong></td>
<td align="left"><strong>对象中心 (Object-centric)</strong></td>
</tr>
<tr>
<td align="left"><strong>抽象层次</strong></td>
<td align="left"><strong>半自动 ORM (Semi-ORM)</strong></td>
<td align="left"><strong>全自动 ORM (Full-ORM)</strong></td>
</tr>
<tr>
<td align="left"><strong>SQL 控制力</strong></td>
<td align="left"><strong>完全控制</strong>，开发者手写和优化所有 SQL。</td>
<td align="left"><strong>间接控制</strong>，框架自动生成 SQL，也可通过 JPQL 或原生 SQL 干预。</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left">- <strong>原生MyBatis</strong>: 中等，需编写 XML 和接口。 <br>- <strong>MyBatis-Plus</strong>: <strong>很高</strong>，通用 CRUD 无需 SQL。</td>
<td align="left"><strong>极高</strong>，Spring Data JPA 的 <code>Repository</code> 和方法命名查询极大减少代码量。</td>
</tr>
<tr>
<td align="left"><strong>学习曲线</strong></td>
<td align="left"><strong>平缓</strong>，对熟悉 SQL 的开发者非常友好。</td>
<td align="left"><strong>较陡峭</strong>，需深入理解实体生命周期、持久化上下文、抓取策略等核心概念。</td>
</tr>
<tr>
<td align="left"><strong>数据库移植性</strong></td>
<td align="left"><strong>较好</strong>，但复杂 SQL 可能依赖数据库方言，移植时需要修改。</td>
<td align="left"><strong>非常好</strong>，只要面向 JPA 规范编程，更换数据库的成本极低。</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>潜力更高</strong>，开发者可以直接编写最优化的 SQL。</td>
<td align="left"><strong>通常良好</strong>，但自动生成的 SQL 可能非最优，复杂场景下需要手动调优。</td>
</tr>
<tr>
<td align="left"><strong>复杂查询支持</strong></td>
<td align="left"><strong>非常强大</strong>，特别适合复杂的报表和多表连接查询。</td>
<td align="left"><strong>良好</strong>，但构建复杂 JPQL 相对繁琐，有时不如手写 SQL 直观。</td>
</tr>
<tr>
<td align="left"><strong>生态集成</strong></td>
<td align="left">与 Spring 集成良好，MyBatis-Plus 社区活跃。</td>
<td align="left"><strong>与 Spring 生态无缝集成</strong>，是 Spring Data 的核心部分，生态极为成熟。</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-2-如何做出选择？"><a href="#4-2-如何做出选择？" class="headerlink" title="4.2 如何做出选择？"></a>4.2 如何做出选择？</h3><h4 id="4-2-1-选择-MyBatis-MyBatis-Plus-的场景："><a href="#4-2-1-选择-MyBatis-MyBatis-Plus-的场景：" class="headerlink" title="4.2.1 选择 MyBatis &#x2F; MyBatis-Plus 的场景："></a>4.2.1 选择 MyBatis &#x2F; MyBatis-Plus 的场景：</h4><ol>
<li><strong>SQL 优化是首要任务</strong>:<ul>
<li>当项目对数据库性能有极致要求，需要对每一条 SQL 进行精细化审查和优化（如使用索引提示、复杂子查询等）时，MyBatis 提供了无与伦比的控制力。</li>
<li><strong>适用项目</strong>: 高并发的互联网应用（如秒杀、实时推荐）、金融交易系统。</li>
</ul>
</li>
<li><strong>报表系统和数据分析平台</strong>:<ul>
<li>这类项目通常涉及大量复杂、动态、多表 <code>JOIN</code> 的聚合查询。用手写 SQL 来表达这些逻辑远比用 JPQL 或 Criteria API 更直接、更高效。</li>
<li>将这些复杂的 SQL 集中管理在 XML 中，也便于 DBA 介入和维护。</li>
</ul>
</li>
<li><strong>遗留系统或数据库设计不规范</strong>:<ul>
<li>当需要对接一个设计不佳或无法修改的遗留数据库时，MyBatis 强大的 <code>&lt;resultMap&gt;</code> 可以将任何奇特的查询结果灵活地映射到 Java 对象上。而 JPA 强制的实体映射关系在这种情况下可能会处处受限。</li>
</ul>
</li>
<li><strong>团队成员精通 SQL</strong>:<ul>
<li>如果团队成员（包括 DBA）对 SQL 有着深厚的功底，并乐于通过 SQL 解决问题，MyBatis 的学习曲线会非常平缓，能快速发挥团队的优势。</li>
</ul>
</li>
<li><strong>希望保持简单和轻量级</strong>:<ul>
<li>原生 MyBatis 本身非常轻量，其工作模式也相对透明。对于不希望引入过多“魔法”和复杂概念的项目，MyBatis 是一个可靠的选择。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-2-2-选择-JPA-Hibernate-的场景："><a href="#4-2-2-选择-JPA-Hibernate-的场景：" class="headerlink" title="4.2.2 选择 JPA &#x2F; Hibernate 的场景："></a>4.2.2 选择 JPA &#x2F; Hibernate 的场景：</h4><ol>
<li><strong>快速开发和原型验证</strong>:<ul>
<li>对于新项目，特别是需要快速迭代的业务系统，Spring Data JPA 的开发效率是无与伦比的。它可以让你在极短的时间内搭建起功能完备的数据访问层。</li>
<li><strong>适用项目</strong>: 创业公司的 MVP 产品、企业内部管理系统。</li>
</ul>
</li>
<li><strong>CRUD 密集的标准业务系统</strong>:<ul>
<li>对于大多数以表单和列表为核心的 CRUD 应用（如 OA, CRM, ERP），JPA 提供了最优雅的解决方案。代码简洁、规范，维护性好。</li>
</ul>
</li>
<li><strong>追求数据库无关性和高可移植性</strong>:<ul>
<li>如果项目计划支持多种数据库，或者未来可能需要从一个数据库迁移到另一个，JPA 是不二之选。它能最大程度地保护你的业务代码不受底层数据库变化的影响。</li>
<li><strong>适用项目</strong>: 需要私有化部署的商业软件产品。</li>
</ul>
</li>
<li><strong>践行领域驱动设计 (DDD)</strong>:<ul>
<li>JPA 的面向对象设计与 DDD 的思想天然契合。实体、值对象、聚合根等 DDD 概念都能在 JPA 中找到很好的技术映射，有助于构建健壮的领域模型。</li>
</ul>
</li>
<li><strong>希望全面拥抱 Spring 生态</strong>:<ul>
<li>Spring Data JPA 是 Spring 生态中的“一等公民”，与 Spring Boot、Spring Security 等其他模块的集成最为紧密和成熟。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-3-混合使用：一种务实的选择"><a href="#4-3-混合使用：一种务实的选择" class="headerlink" title="4.3 混合使用：一种务实的选择"></a>4.3 混合使用：一种务实的选择</h3><p>在复杂的项目中，<strong>没有必要将自己局限于单一的框架</strong>。Spring Boot 允许你在同一个项目中同时集成 MyBatis-Plus 和 Spring Data JPA。</p>
<p><strong>混合使用策略</strong>:</p>
<ul>
<li><strong>JPA 作为主力</strong>: 使用 Spring Data JPA 处理项目中 <strong>80% 的标准化 CRUD 和简单的业务查询</strong>，以享受其带来的高开发效率。</li>
<li><strong>MyBatis 作为补充</strong>: 对于那 <strong>20% 的、极其复杂的报表查询或需要极致性能优化的场景</strong>，单独创建 MyBatis 的 Mapper 接口和 XML 文件，手写最优的 SQL 来解决。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
